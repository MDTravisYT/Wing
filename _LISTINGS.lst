00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  DEBUG_BUILD	equ	0				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000000                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000000                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            
00000000                            		moveq	#0,d0
00000000                            
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	rTailNext.w,a0				; load first object slot into a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	oNext(a0),a0				; load the next object address to a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	#rDispInput+(\layer*dSize),oDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	rDispInput+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	#rDispInput+(\layer*dSize),rDispInput+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w				; else, copy over
00000000                            
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	layer,oDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	oDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,oDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	oDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,oDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            
00000000                            		move.w	oDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	oDrawNext(\obj),oDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	oDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	oDrawPrev(\obj),oDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            
00000000                            ;		cmp.w	oDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,oDrawNext(\fre)				; else, change to point to same address
00000000                            
00000000                            .no\@
00000000                            		clr.l	oDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  oAddr		rs.l	1				; Pointer to object code
00000000 =00000004                  oNext		rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  oPrev		rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  oDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  oDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  oFlags		rs.b	1				; Object flags
00000000 =0000000D                  oRender		rs.b	1				; Render flags
00000000 =0000000E                  oVRAM		rs.w	1				; Sprite tile properties
00000000 =00000010                  oFrame		rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  oMap		rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  oXPos		rs.l	1				; X position
00000000 =00000017                  oDrawW	=	__rs-1					; Sprite width
00000000 =00000018                  oYPos		rs.l	1				; Y position
00000000 =0000001B                  oDrawH	=	__rs-1					; Sprite height
00000000 =0000001C                  oXVel		rs.w	1				; X velocity
00000000 =0000001E                  oYVel		rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  oAni		rs.b	1				; Animation ID
00000000 =00000021                  oPrevAni	rs.b	1				; Saved animation ID
00000000 =00000022                  oAniFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  oAniTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  oSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  oRoutine	rs.b	1				; Routine ID
00000000 =00000026                  oRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  oStatus		rs.b	1				; Status flags
00000000 =00000029                  oShield		rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  oDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  oSize		rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oDynSSTs
00000000 =0000002A                  oColType	rs.b	1				; Collision type
00000000 =0000002B                  oColStat	rs.b	1				; Collision status
00000000 =0000002B                  oHitCnt		equ	oColStat			; Boss hit count
00000000 =0000002C                  oColW		rs.b	1				; Collision width
00000000 =0000002D                  oColH		rs.b	1				; Collision height
00000000 =0000002E                  oNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  oTilt		rs.b	1				; Tilt value
00000000 =00000030                  oLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oSubXPos	rs.w	1				; Sub sprite X position
00000000 =00000002                  oSubYPos	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000 =00000005                  oSubFrame	rs.b	1				; Sub sprite mapping frame
00000000 =00000006                  oSubSize	rs.b	0				; Sub sprite SSTs size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  oSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  oSubCnt		rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  oSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            oSub\$ct\X	rs.w	1				; Sub sprite X position
00000000                            oSub\$ct\Y	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000                            oSub\$ct\Frame	rs.b	1				; Sub sprite mapping frame position
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M osub0x	rs.w	1
00000000 =00000032                M osub0y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000035                M osub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M osub1x	rs.w	1
00000000 =00000038                M osub1y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000003B                M osub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M osub2x	rs.w	1
00000000 =0000003E                M osub2y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000041                M osub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M osub3x	rs.w	1
00000000 =00000044                M osub3y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000047                M osub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M osub4x	rs.w	1
00000000 =0000004A                M osub4y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000004D                M osub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M osub5x	rs.w	1
00000000 =00000050                M osub5y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000053                M osub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M osub6x	rs.w	1
00000000 =00000056                M osub6y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000059                M osub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M osub7x	rs.w	1
00000000 =0000005C                M osub7y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000005F                M osub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset oDrawPrev-6			; this awkward thing will make dPrev == oDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	oSize
00000000                            curobj_size		=	curobj_size+oSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  rBuffer		rs.b	0				; General buffer
00000000 =00FF0000                  rChunks		rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  rBuffer_End	rs.b	0
00000000                            
00000000                            		rsset	$FF000000|(RAM_START+$8000)
00000000                            
00000000 =FFFF8000                  rKosPBuf	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  rDMAQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  rDMASlot	rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  rHScroll	rs.b	$380				; HScroll table
00000000 =FFFF947E                  rHScroll_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  rVScroll	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  rVScroll_End	rs.b	0				; ''
00000000 =FFFF947E                  rVScrollFG	EQU	rVScroll			; VScroll foreground value
00000000 =FFFF9480                  rVScrollBG	EQU	rVScroll+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  rSprites	rs.b	$280				; Sprite table
00000000 =FFFF974E                  rSprites_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;rDestWtrPal	equ	rSprites_End-$100		; Target water palette buffer
00000000                            ;rDestPal	equ	rSprites_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  rDestWtrPal	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  rDestPal	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  rWaterPal	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  rPalette	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  rKosPVars	rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  rKosPCnt	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  rKosPRegs	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  rKosPSR		rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  rKosPBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  rKosPList	rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  rKosPSrc	equ	rKosPList			; ''
00000000 =FFFF9974                  rKosPDest	equ	rKosPList+4			; ''
00000000 =FFFF9990                  rKosPList_End	rs.b	0				; ''
00000000 =FFFF9990                  rKosPMMods	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  rKosPMLastSz	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  rKosPMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  rKosPMSrc	equ	rKosPMList			; ''
00000000 =FFFF9998                  rKosPMDest	equ	rKosPMList+4			; ''
00000000 =FFFF9A54                  rKosPMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  rKosPVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  rObjects	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9A54                M robj_0	rs.b	osize
00000000 =00000060                M curobj_size	=	curobj_size+osize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9AB4                M robj_1	rs.b	osize
00000000 =000000C0                M curobj_size	=	curobj_size+osize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9B14                M robj_2	rs.b	osize
00000000 =00000120                M curobj_size	=	curobj_size+osize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9B74                M robj_3	rs.b	osize
00000000 =00000180                M curobj_size	=	curobj_size+osize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9BD4                M robj_4	rs.b	osize
00000000 =000001E0                M curobj_size	=	curobj_size+osize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9C34                M robj_5	rs.b	osize
00000000 =00000240                M curobj_size	=	curobj_size+osize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9C94                M robj_6	rs.b	osize
00000000 =000002A0                M curobj_size	=	curobj_size+osize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9CF4                M robj_7	rs.b	osize
00000000 =00000300                M curobj_size	=	curobj_size+osize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFF9D54                M robj_8	rs.b	osize
00000000 =00000360                M curobj_size	=	curobj_size+osize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_9	rs.b	osize
00000000 =000003C0                M curobj_size	=	curobj_size+osize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_a	rs.b	osize
00000000 =00000420                M curobj_size	=	curobj_size+osize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_b	rs.b	osize
00000000 =00000480                M curobj_size	=	curobj_size+osize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_c	rs.b	osize
00000000 =000004E0                M curobj_size	=	curobj_size+osize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_d	rs.b	osize
00000000 =00000540                M curobj_size	=	curobj_size+osize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_e	rs.b	osize
00000000 =000005A0                M curobj_size	=	curobj_size+osize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_f	rs.b	osize
00000000 =00000600                M curobj_size	=	curobj_size+osize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_10	rs.b	osize
00000000 =00000660                M curobj_size	=	curobj_size+osize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_11	rs.b	osize
00000000 =000006C0                M curobj_size	=	curobj_size+osize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_12	rs.b	osize
00000000 =00000720                M curobj_size	=	curobj_size+osize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_13	rs.b	osize
00000000 =00000780                M curobj_size	=	curobj_size+osize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_14	rs.b	osize
00000000 =000007E0                M curobj_size	=	curobj_size+osize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_15	rs.b	osize
00000000 =00000840                M curobj_size	=	curobj_size+osize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_16	rs.b	osize
00000000 =000008A0                M curobj_size	=	curobj_size+osize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_17	rs.b	osize
00000000 =00000900                M curobj_size	=	curobj_size+osize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_18	rs.b	osize
00000000 =00000960                M curobj_size	=	curobj_size+osize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_19	rs.b	osize
00000000 =000009C0                M curobj_size	=	curobj_size+osize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_1a	rs.b	osize
00000000 =00000A20                M curobj_size	=	curobj_size+osize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_1b	rs.b	osize
00000000 =00000A80                M curobj_size	=	curobj_size+osize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_1c	rs.b	osize
00000000 =00000AE0                M curobj_size	=	curobj_size+osize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_1d	rs.b	osize
00000000 =00000B40                M curobj_size	=	curobj_size+osize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_1e	rs.b	osize
00000000 =00000BA0                M curobj_size	=	curobj_size+osize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_1f	rs.b	osize
00000000 =00000C00                M curobj_size	=	curobj_size+osize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_20	rs.b	osize
00000000 =00000C60                M curobj_size	=	curobj_size+osize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_21	rs.b	osize
00000000 =00000CC0                M curobj_size	=	curobj_size+osize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_22	rs.b	osize
00000000 =00000D20                M curobj_size	=	curobj_size+osize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_23	rs.b	osize
00000000 =00000D80                M curobj_size	=	curobj_size+osize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_24	rs.b	osize
00000000 =00000DE0                M curobj_size	=	curobj_size+osize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_25	rs.b	osize
00000000 =00000E40                M curobj_size	=	curobj_size+osize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_26	rs.b	osize
00000000 =00000EA0                M curobj_size	=	curobj_size+osize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_27	rs.b	osize
00000000 =00000F00                M curobj_size	=	curobj_size+osize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_28	rs.b	osize
00000000 =00000F60                M curobj_size	=	curobj_size+osize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_29	rs.b	osize
00000000 =00000FC0                M curobj_size	=	curobj_size+osize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_2a	rs.b	osize
00000000 =00001020                M curobj_size	=	curobj_size+osize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_2b	rs.b	osize
00000000 =00001080                M curobj_size	=	curobj_size+osize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_2c	rs.b	osize
00000000 =000010E0                M curobj_size	=	curobj_size+osize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_2d	rs.b	osize
00000000 =00001140                M curobj_size	=	curobj_size+osize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_2e	rs.b	osize
00000000 =000011A0                M curobj_size	=	curobj_size+osize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_2f	rs.b	osize
00000000 =00001200                M curobj_size	=	curobj_size+osize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_30	rs.b	osize
00000000 =00001260                M curobj_size	=	curobj_size+osize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_31	rs.b	osize
00000000 =000012C0                M curobj_size	=	curobj_size+osize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_32	rs.b	osize
00000000 =00001320                M curobj_size	=	curobj_size+osize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_33	rs.b	osize
00000000 =00001380                M curobj_size	=	curobj_size+osize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_34	rs.b	osize
00000000 =000013E0                M curobj_size	=	curobj_size+osize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_35	rs.b	osize
00000000 =00001440                M curobj_size	=	curobj_size+osize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_36	rs.b	osize
00000000 =000014A0                M curobj_size	=	curobj_size+osize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_37	rs.b	osize
00000000 =00001500                M curobj_size	=	curobj_size+osize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_38	rs.b	osize
00000000 =00001560                M curobj_size	=	curobj_size+osize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_39	rs.b	osize
00000000 =000015C0                M curobj_size	=	curobj_size+osize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_3a	rs.b	osize
00000000 =00001620                M curobj_size	=	curobj_size+osize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_3b	rs.b	osize
00000000 =00001680                M curobj_size	=	curobj_size+osize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_3c	rs.b	osize
00000000 =000016E0                M curobj_size	=	curobj_size+osize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_3d	rs.b	osize
00000000 =00001740                M curobj_size	=	curobj_size+osize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_3e	rs.b	osize
00000000 =000017A0                M curobj_size	=	curobj_size+osize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_3f	rs.b	osize
00000000 =00001800                M curobj_size	=	curobj_size+osize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_40	rs.b	osize
00000000 =00001860                M curobj_size	=	curobj_size+osize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_41	rs.b	osize
00000000 =000018C0                M curobj_size	=	curobj_size+osize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_42	rs.b	osize
00000000 =00001920                M curobj_size	=	curobj_size+osize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_43	rs.b	osize
00000000 =00001980                M curobj_size	=	curobj_size+osize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_44	rs.b	osize
00000000 =000019E0                M curobj_size	=	curobj_size+osize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_45	rs.b	osize
00000000 =00001A40                M curobj_size	=	curobj_size+osize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_46	rs.b	osize
00000000 =00001AA0                M curobj_size	=	curobj_size+osize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_47	rs.b	osize
00000000 =00001B00                M curobj_size	=	curobj_size+osize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_48	rs.b	osize
00000000 =00001B60                M curobj_size	=	curobj_size+osize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_49	rs.b	osize
00000000 =00001BC0                M curobj_size	=	curobj_size+osize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_4a	rs.b	osize
00000000 =00001C20                M curobj_size	=	curobj_size+osize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_4b	rs.b	osize
00000000 =00001C80                M curobj_size	=	curobj_size+osize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_4c	rs.b	osize
00000000 =00001CE0                M curobj_size	=	curobj_size+osize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_4d	rs.b	osize
00000000 =00001D40                M curobj_size	=	curobj_size+osize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_4e	rs.b	osize
00000000 =00001DA0                M curobj_size	=	curobj_size+osize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_4f	rs.b	osize
00000000 =00001E00                M curobj_size	=	curobj_size+osize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_50	rs.b	osize
00000000 =00001E60                M curobj_size	=	curobj_size+osize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_51	rs.b	osize
00000000 =00001EC0                M curobj_size	=	curobj_size+osize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_52	rs.b	osize
00000000 =00001F20                M curobj_size	=	curobj_size+osize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_53	rs.b	osize
00000000 =00001F80                M curobj_size	=	curobj_size+osize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_54	rs.b	osize
00000000 =00001FE0                M curobj_size	=	curobj_size+osize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_55	rs.b	osize
00000000 =00002040                M curobj_size	=	curobj_size+osize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_56	rs.b	osize
00000000 =000020A0                M curobj_size	=	curobj_size+osize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_57	rs.b	osize
00000000 =00002100                M curobj_size	=	curobj_size+osize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_58	rs.b	osize
00000000 =00002160                M curobj_size	=	curobj_size+osize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_59	rs.b	osize
00000000 =000021C0                M curobj_size	=	curobj_size+osize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_5a	rs.b	osize
00000000 =00002220                M curobj_size	=	curobj_size+osize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_5b	rs.b	osize
00000000 =00002280                M curobj_size	=	curobj_size+osize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_5c	rs.b	osize
00000000 =000022E0                M curobj_size	=	curobj_size+osize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_5d	rs.b	osize
00000000 =00002340                M curobj_size	=	curobj_size+osize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_5e	rs.b	osize
00000000 =000023A0                M curobj_size	=	curobj_size+osize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_5f	rs.b	osize
00000000 =00002400                M curobj_size	=	curobj_size+osize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFBE54                  rObjects_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(rObjects_End-rObjects)/oSize
00000000                            
00000000 =FFFFBE54                  rTailAddr	rs.l	1				; pointer to tail object code
00000000 =FFFFBE58                  rTailNext	rs.w	1				; pointer to the first object in linked list
00000000 =FFFFBE5A                  rTailPrev	rs.w	1				; pointer to the last object in linked list
00000000 =FFFFBE5C                  rFreeHead	rs.w	1				; pointer to the first object that is not loaded
00000000                            
00000000 =FFFFBE5A                  rDispInput	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFBE9E                  rDispInput_End	rs.b	0				; 
00000000                            
00000000 =FFFFBE9E                  rRespawns	rs.b	$300				; Object respawn table
00000000 =FFFFC19E                  rRespawns_End	rs.b	0				; ''
00000000                            
00000000 =FFFFC19E                  rFGRowBuf	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  rFGColBuf	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  rBGRowBuf	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  rBGColBuf	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  rAMPS		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC740                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC740                  rP1Data		rs.b	0				; Controller 1 data
00000000 =FFFFC740                  rP1Hold		rs.b	1				; Controller 1 held button data
00000000 =FFFFC741                  rP1Press	rs.b	1				; Controller 1 pressed button data
00000000 =FFFFC742                  rP2Data		rs.b	0				; Controller 2 data
00000000 =FFFFC742                  rP2Hold		rs.b	1				; Controller 2 held button data
00000000 =FFFFC743                  rP2Press	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC744                  rHWVersion	rs.b	1				; Hardware version
00000000 =FFFFC745                  rVINTFlag	rs.b	0				; V-INT flag
00000000 =FFFFC745                  rVINTRout	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC746                  rPalFade	rs.b	0				; Palette fade properties
00000000 =FFFFC746                  rFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC747                  rFadeLen	rs.b	1				; Palette fade size
00000000                            
00000000 =FFFFC748                  rLagCount	rs.b	1				; Lag frame counter
00000000                            
00000000 =FFFFC749                  rHIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74A                  rVIntJmp	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74C                  rVIntAddr	rs.l	1				; V-INT address
00000000 =FFFFC750                  rHIntJmp	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC752                  rHIntAddr	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC756                  rFrameCnt	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75A                  rGameMode	rs.b	1				; Game mode ID
00000000 =FFFFC75B                  rSprCount	rs.b	1				; Sprite count
00000000 =FFFFC75C                  rPauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75D                  rHIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC75E                  rHIntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC75F                  rHIntCnt	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC760                  rRNGSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC764                  rVDPReg1	rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC766                  rWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC768                  rMoveCheat	rs.b	1
00000000 =FFFFC769                  rArtCheat	rs.b	1
00000000                            
00000000 =FFFFC76A                  rOscNums	rs.b	0				; Oscillation numbers
00000000 =FFFFC76A                  rOscCtrl	rs.w	1				; Oscillation control
00000000 =FFFFC76C                  rOscData	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AC                  rOscNums_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AC                  rLevel		rs.b	0				; Level ID
00000000 =FFFFC7AC                  rZone		rs.b	1				; Zone ID
00000000 =FFFFC7AD                  rAct		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7AE                  rChkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7AE                  rLastChkpoint	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B0                  rSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B2                  rSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B4                  rChkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B4                  rObjPosAddr	rs.l	1				; Object position data pointer
00000000 =FFFFC7B8                  rObjManInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B9                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7BA                  rObjLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7BE                  rObjLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C2                  rObjRespL	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C4                  rObjRespR	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C6                  rObjXCoarse	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7C8                  rObjYCoarse	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CA                  rObjManX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CC                  rObjManY	rs.w	1				; Object manager's camera Y position
00000000                            
00000000 =FFFFC7CE                  rPalCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7CF                  rPalCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D0                  rGameVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  rGameVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  rStackSpace	rs.b	$100				; Stack space
00000000 =00000000                  rStackBase	rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000 =FFFFC7D0                  rBlocks		rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD0                  rLayout		rs.b	$1000				; Level layout
00000000                            
00000000 =FFFFEFD0                  rScrlSecs	rs.b	$384				; Scroll sections
00000000 =FFFFF354                  rScrlSecs_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF354                  rColList	rs.b	$80				; Collision response list
00000000 =FFFFF3D4                  rColList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF3D4                  rRings		rs.w	1				; Ring count
00000000                            
00000000 =FFFFF3D6                  rRingManRout	rs.b	1				; Ring manager routine
00000000 =FFFFF3D7                  rRingFrame	rs.b	1				; Ring animation frame
00000000                            
00000000 =FFFFF3D8                  rRingAniTime	rs.b	1				; Ring animation timer
00000000 =FFFFF3D9                  rRLossAniT	rs.b	1
00000000 =FFFFF3DA                  rRLossAniA	rs.w	1
00000000 =FFFFF3DC                  rRLossAniF	rs.b	1
00000000                            
00000000 =FFFFF3DD                  rBossDefeat	rs.b	1
00000000                            
00000000 =FFFFF3DE                  rRingStat	rs.b	$400				; Ring status table
00000000 =FFFFF7DE                  rRingStat_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF7DE                  rRingCol	rs.b	0				; Ring collection table
00000000 =FFFFF7DE                  rRingColCnt	rs.w	1				; Ring collection count
00000000 =FFFFF7E0                  rRingColList	rs.b	$7E				; Ring collection list
00000000 =FFFFF85E                  rRingCol_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF85E                  rRingPosAddr	rs.l	1				; Ring position data pointer
00000000 =FFFFF862                  rRingLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFF866                  rRingLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFF86A                  rRingStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFF86C                  rPlayer1Addr	rs.w	1				; Player 1 object address
00000000 =FFFFF86E                  rShield1Addr	rs.w	1				; Player 1 shield address
00000000 =FFFFF870                  rInvinc1Addr	rs.w	1				; Player 1 invincibility address
00000000 =FFFFF872                  rAftImg1Addr	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFF874                  rPlayer2Addr	rs.w	1				; Player 2 object address
00000000 =FFFFF876                  rShield2Addr	rs.w	1				; Player 2 shield address
00000000 =FFFFF878                  rInvinc2Addr	rs.w	1				; Player 2 invincibility address
00000000 =FFFFF87A                  rAftImg2Addr	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFF87C                  rWater1Addr	rs.w	1				; Water surface 1 address
00000000 =FFFFF87E                  rWater2Addr	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFF880                  rCamera		rs.b	0				; Camera RAM
00000000                            
00000000 =FFFFF880                  rFGCam		rs.b	cSize2				; Foreground variables
00000000 =FFFFF89E                  rBGCam		rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFF8BC                  rDestMaxCam	rs.b	0				; Target maximum camera positions
00000000 =FFFFF8BC                  rDestMaxX	rs.w	1				; Target maximum camera X position
00000000 =FFFFF8BE                  rDestMaxY	rs.w	1				; Target maximum camera Y position
00000000 =FFFFF8C0                  rMaxCam		rs.b	0				; Maximum camera positions
00000000 =FFFFF8C0                  rMaxCamX	rs.w	1				; Maximum camera X position
00000000 =FFFFF8C2                  rMaxCamY	rs.w	1				; Maximum camera Y position
00000000 =FFFFF8C4                  rDestMinCam	rs.b	0				; Target minimum camera positions
00000000 =FFFFF8C4                  rDestMinX	rs.w	1				; Target minimum camera X position
00000000 =FFFFF8C6                  rDestMinY	rs.w	1				; Target minimum camera Y position
00000000 =FFFFF8C8                  rMinCam		rs.b	0				; Minimum camera positions
00000000 =FFFFF8C8                  rMinCamX	rs.w	1				; Minimum camera X position
00000000 =FFFFF8CA                  rMinCamY	rs.w	1				; Minimum camera Y position
00000000 =FFFFF8CC                  rCamYPosDist	rs.w	1				; Distance from the player's Y position and the camera's
00000000 =FFFFF8CE                  rCamLocked	rs.b	0				; Camera locked flags
00000000 =FFFFF8CE                  rCamLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFF8CF                  rCamLockY	rs.b	1				; Camera locked vertically flag
00000000 =FFFFF8D0                  rCamMaxChg	rs.b	1				; Camera max Y position changing flag
00000000                            
00000000 =FFFFF8D1                  rCamera_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFF8D1                  rDebugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFF8D2                  rCamXPosCenter	rs.w	1				; Camera X center
00000000                            
00000000 =FFFFF8D4                  rCtrl		rs.b	0				; Player control data
00000000 =FFFFF8D4                  rCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFF8D5                  rCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFF8D6                  rLevelMusic	rs.b	1				; Level music ID
00000000 =FFFFF8D7                  rBossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFF8D8                  r1stCol		rs.l	1				; Primary level collision data pointer
00000000 =FFFFF8DC                  r2ndCol		rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFF8E0                  rColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFF8E4                  rLayerPos	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFF8E6                  rAngleVals	rs.l	1				; Angle value array pointer
00000000 =FFFFF8EA                  rColArrayN	rs.l	1				; Normal height map array pointer
00000000 =FFFFF8EE                  rColArrayR	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFF8F2                  rNextLevel	rs.b	1				; Flag to go to the next level
00000000                            
00000000 =FFFFF8F3                  rUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFF8F4                  rWaterFlag	rs.b	1				; Water in level flag
00000000 =FFFFF8F5                  rWaterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFF8F6                  rWaterLvl	rs.w	1				; Water height
00000000 =FFFFF8F8                  rDestWtrLvl	rs.w	1				; Target water height
00000000                            
00000000 =FFFFF8FA                  rLvlFrames	rs.w	1				; Level frame counter
00000000 =FFFFF8FC                  rLvlReload	rs.b	1				; Level reload flag
00000000 =FFFFF8FD                  rTimeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFF8FE                  rDynEvRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFF8FF                  rFloorActive	rs.b	1				; Floor active flag
00000000 =FFFFF900                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFF902                  rAnimCnts	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFF880                  rCamXPos		equ	rFGCam+cXPos			; Camera X position
00000000 =FFFFF888                  rCamYPos		equ	rFGCam+cYPos			; Camera Y position
00000000 =FFFFF89E                  rCamBGXPos		equ	rBGCam+cXPos			; Background camera X position
00000000 =FFFFF8A6                  rCamBGYPos		equ	rBGCam+cYPos			; Background camera Y position
00000000 =FFFFF89C                  rFGRedraw	equ	rFGCam+cRedraw		; Foreground redraw flag
00000000 =FFFFF8BA                  rBGRedraw	equ	rBGCam+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74A                  vInterrupt	equ	rVIntJmp			; V-INT
00000000 =FFFFC750                  hInterrupt	equ	rHIntJmp			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- Character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C750                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74A                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	rStackBase.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C744                  		move.b	d0,rHWVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74A                  		move.w	d0,rVIntJmp.w				; Set the "JMP" command for V-INT
000001F6 31C0 C750                  		move.w	d0,rHIntJmp.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74C        		move.l	#VInt_Standard,rVIntAddr.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C752        		move.l	#HInt_Water,rHIntAddr.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	rDMAQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0004 C75A             		move.b	#gLevel,rGameMode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	Level					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75A                  		move.b	rGameMode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C764             		move.w	#$8134,rVDPReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C75E             		move.w	#$8AFF,rHIntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	rHScroll, rVScroll_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"rvscroll_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(rhscroll).w,a1
0000027A 323C 00F3                M 	move.w	#(((rvscroll_end)-(rhscroll))-((rhscroll)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	rDMASlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#rDMASlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,rDMASlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#rDMASlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,rDMASlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	rDMAQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,rDMASlot.w
000003B0                            
000003B0                            		rept (rDMASlot-rDMAQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,rDMAQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	rDMAQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,rDMASlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (rDMASlot-rDMAQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	rPalette.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	rWaterPal.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000057C 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000592 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000604 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
00000620 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000686 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000069C 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000722 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
0000073E 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000786 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000007B4 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000007D0 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	rSprites.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C740                  	lea	rP1Data.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	rKosPMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,rKosPMMods.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,rKosPMMods.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,rKosPMLastSz.w
00000FA0 31C2 9998                  		move.w	d2,rKosPMDest.w
00000FA4 21C9 9994                  		move.l	a1,rKosPMSrc.w
00000FA8 5238 9990                  		addq.b	#1,rKosPMMods.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	rKosPMMods.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(rKosPList_End-rKosPList)/8,rKosPCnt.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	rKosPMList.w,a1
00000FC4 45F8 8000                  		lea	rKosPBuf.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,rKosPMMods.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	rKosPCnt.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,rKosPMMods.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,rKosPMMods.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	rKosPMLastSz.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	rKosPMDest.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,rKosPMDest.w		; Set new destination
00000FFE 2038 9994                  		move.l	rKosPMList.w,d0
00001002 2238 9970                  		move.l	rKosPList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,rKosPMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#rKosPBuf,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	rKosPMMods.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	rKosPMList.w,a0
0000102A 43F8 999A                  		lea	(rKosPMList+6).w,a1
0000102E                            	rept (rKosPMList_End-rKosPMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	rKosPMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	rKosPMDest.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	rKosPCnt.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	rKosPList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,rKosPCnt.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	rKosPCnt.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),rKosPBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	rKosPCnt.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,rKosPCnt.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	rKosPList.w,a0
00001118 2278 9974                  		movea.l	rKosPDest.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,rKosPList.w
000012E6 21C9 9974                  		move.l	a1,rKosPDest.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,rKosPCnt.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,rKosPCnt.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	rKosPList.w,a0
000012FA 43F8 9978                  		lea	(rKosPList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (rKosPList_End-rKosPList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	rKosPRegs.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(rKosPRegs+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	rKosPBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	rKosPSR.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,rKosPSR.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,rKosPRegs.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(rKosPRegs+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C760                  		move.l	rRNGSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C760                  		move.l	d1,rRNGSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76A                  		lea	rOscNums.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76A                  		lea	rOscNums.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76A                  		move.w	d3,rOscCtrl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	rRespawns			; Clear object respawn table
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"rrespawns_End"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 BE9E                M 	lea	(rrespawns).w,a1
000019C4 323C 00BF                M 	move.w	#(((rrespawns_end)-(rrespawns))-((rrespawns)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC BE54 BE58             		move.w	#rTailAddr,rTailNext.w		; set the first object as the tail object
000019D4 31FC BE54 BE5A             		move.w	#rTailAddr,rTailPrev.w		; set the last object as the tail object
000019DA 21FC 0000 0000 BE54        		move.l	#.rts,rTailAddr.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9A54                  		lea	rObjects.w,a0			; load the objects list into a0
000019E6 31C8 BE5C                  		move.w	a0,rFreeHead.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#oSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,oPrev-oSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	oDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	oPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 BE56                  		lea	rDispInput-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 BE5C                  		move.w	rFreeHead.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 BE5C             		move.w	oPrev(a1),rFreeHead.w		; copy the next free object pointer to list start
00001A2A                            ; --------------------------------------------------------------
00001A2A                            
00001A2A                            	; clear object memory
00001A2A 45E9 000A                  		lea	oDrawPrev(a1),a2		; load the first byte to clear to a2
00001A2E 425A                       		clr.w	(a2)+				; clear a word of data
00001A30                            
00001A30                            	rept (oSize-oDrawPrev) / 4			; repeat for every object property
00001A30                            		clr.l	(a2)+				; clear a longword of data
00001A30                            	endr
00001A30 429A                     M 	clr.l	(a2)+
00001A32 429A                     M 	clr.l	(a2)+
00001A34 429A                     M 	clr.l	(a2)+
00001A36 429A                     M 	clr.l	(a2)+
00001A38 429A                     M 	clr.l	(a2)+
00001A3A 429A                     M 	clr.l	(a2)+
00001A3C 429A                     M 	clr.l	(a2)+
00001A3E 429A                     M 	clr.l	(a2)+
00001A40 429A                     M 	clr.l	(a2)+
00001A42 429A                     M 	clr.l	(a2)+
00001A44 429A                     M 	clr.l	(a2)+
00001A46 429A                     M 	clr.l	(a2)+
00001A48 429A                     M 	clr.l	(a2)+
00001A4A 429A                     M 	clr.l	(a2)+
00001A4C 429A                     M 	clr.l	(a2)+
00001A4E 429A                     M 	clr.l	(a2)+
00001A50 429A                     M 	clr.l	(a2)+
00001A52 429A                     M 	clr.l	(a2)+
00001A54 429A                     M 	clr.l	(a2)+
00001A56 429A                     M 	clr.l	(a2)+
00001A58 429A                     M 	clr.l	(a2)+
00001A5A                            ; --------------------------------------------------------------
00001A5A                            
00001A5A 3478 BE5A                  		move.w	rTailPrev.w,a2			; load last object to a2
00001A5E 31C9 BE5A                  		move.w	a1,rTailPrev.w			; save as the new last object
00001A62 336A 0004 0004             		move.w	oNext(a2),oNext(a1)		; copy the next pointer from old tail to new object
00001A68 3549 0004                  		move.w	a1,oNext(a2)			; save new object as next pointer for old tail
00001A6C 334A 0006                  		move.w	a2,oPrev(a1)			; save old tail as prev pointer for new object
00001A70                            
00001A70                            .rts:
00001A70 4E75                       		rts
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; Delete the current object
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; PARAMETERS:
00001A72                            ;	Nothing
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; RETURNS:
00001A72                            ;	a1.l	- Trashed
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            DeleteObject:
00001A72                            	removeSprite	a0, a1, 1			; remove object display
00001A72 4A68 0008                M 	tst.w	odrawnext(a0)
00001A76 6700                     M 	beq.s	.yes_66
00001A78 3268 000A                M 	move.w	odrawprev(a0),a1
00001A7C 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00001A82 3268 0008                M 	move.w	odrawnext(a0),a1
00001A86 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00001A8C                          M .no_66
00001A8C 42A8 0008                M 	clr.l	odrawnext(a0)
00001A90                          M .yes_66
00001A90 3268 0006                  		move.w	oPrev(a0),a1			; copy previous pointer to a1
00001A94 3368 0004 0004             		move.w	oNext(a0),oNext(a1)		; copy next pointer to previous object
00001A9A 3268 0004                  		move.w	oNext(a0),a1			; get next object to a1
00001A9E 3368 0006 0006             		move.w	oPrev(a0),oPrev(a1)		; copy previous pointer
00001AA4                            
00001AA4 3178 BE5C 0006             		move.w	rFreeHead.w,oPrev(a0)		; get the head of the free list to previous pointer of this object
00001AAA 31C8 BE5C                  		move.w	a0,rFreeHead.w			; save as the new head of free list
00001AAE 4E75                       		rts
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; Delete an object
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; PARAMETERS:
00001AB0                            ;	a1.l	- Pointer to object space to clear
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; RETURNS:
00001AB0                            ;	a1.l	- Trashed
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            DeleteOtherObj:
00001AB0                            		push.l	a0
00001AB0 2F08                     M 	move.l	a0,-(sp)
00001AB2 2049                       		move.l	a1,a0
00001AB4 61BC                       		bsr.s	DeleteObject
00001AB6                            		pop.l	a0
00001AB6 205F                     M 	move.l	(sp)+,a0
00001AB8 4E75                       		rts
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; Render object sprites
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; PARAMETERS:
00001ABA                            ;	Nothing
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; RETURNS:
00001ABA                            ;	Nothing
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            RenderObjects:
00001ABA 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001ABC 7C00                       		moveq	#0,d6				; Render flags
00001ABE                            
00001ABE 47F8 F880                  		lea	rFGCam.w,a3			; Foreground camera variables
00001AC2 4BF8 BE5E                  		lea	rDispInput+dNext.w,a5	; Sprite input table
00001AC6 4DF8 94CE                  		lea	rSprites.w,a6			; Sprite table buffer
00001ACA                            
00001ACA 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Are we in level mode?
00001AD0 6600                       		bne.s	.PrioLvlLoop			; If not, branch
00001AD2 4EB9 0000 0000             		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AD8                            
00001AD8                            .PrioLvlLoop:
00001AD8 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001ADA 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001ADC 4A68 0008                  		tst.w	oDrawNext(a0)			; Is the next pointer for a valid object?
00001AE0 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AE4                            
00001AE4                            .ObjectLoop:
00001AE4                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AE4 4A90                       		tst.l	oAddr(a0)			; Is this object slot used?
00001AE6 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AEA                            
00001AEA 0228 007F 000D             		andi.b	#$7F,oRender(a0)		; Clear on-screen flag
00001AF0 1C28 000D                  		move.b	oRender(a0),d6			; Store render flags
00001AF4 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001AF8 3228 0018                  		move.w	oYPos(a0),d1			; Get Y position
00001AFC                            
00001AFC 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001B00 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001B04 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B08 6700                       		beq.s	.Render				; If not, branch
00001B0A                            
00001B0A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B0C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B10                            
00001B10                            .Render:
00001B10 7400                       		moveq	#0,d2
00001B12 1428 0017                  		move.b	oDrawW(a0),d2			; Get sprite width
00001B16 3600                       		move.w	d0,d3				; Get sprite X position
00001B18 D642                       		add.w	d2,d3				; Add width
00001B1A 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B1C 3600                       		move.w	d0,d3				; Get sprite X position
00001B1E 9642                       		sub.w	d2,d3				; Subtract width
00001B20 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B24 6C00                       		bge.s	.NextObject			; If so, branch
00001B26 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B2A                            
00001B2A 7400                       		moveq	#0,d2
00001B2C 1428 001B                  		move.b	oDrawH(a0),d2			; Get sprite height
00001B30 3601                       		move.w	d1,d3				; Get sprite Y position
00001B32 D642                       		add.w	d2,d3				; Add height
00001B34 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B36 3601                       		move.w	d1,d3				; Get sprite Y position
00001B38 9642                       		sub.w	d2,d3				; Subtract height
00001B3A 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B3E 6C00                       		bge.s	.NextObject			; If so, branch
00001B40 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B44                            
00001B44 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001B4A 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B4C 6B00                       		bmi.s	.NextObject			; If not, branch
00001B4E                            
00001B4E 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001B52 6700                       		beq.s	.NextObject			; If blank, branch
00001B54 2244                       		movea.l	d4,a1				; Store it
00001B56 7800                       		moveq	#0,d4
00001B58 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B5C 6600                       		bne.s	.Static				; If so, branch
00001B5E 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001B62 D844                       		add.w	d4,d4				; Turn into offset
00001B64 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B68 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B6A 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B6C 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B6E                            
00001B6E                            .Static:
00001B6E 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B72 6100 ECDE                  		bsr.w	DrawSprite			; Draw the sprites
00001B76                            
00001B76                            .NextObject:	
00001B76 3068 0008                  		move.w	oDrawNext(a0),a0		; Load next object to a0
00001B7A 4A68 0008                  		tst.w	oDrawNext(a0)			; Check the next pointer for valid object
00001B7E 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B82                            
00001B82                            .NextPrioLvl:
00001B82 BAFC BE9E                  		cmpa.w	#rDispInput_End,a5		; Are we at the end of the input table?
00001B86 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B8A                            
00001B8A 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B8C 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B8E 7000                       		moveq	#0,d0
00001B90                            
00001B90                            .FillRest:
00001B90 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B92 504E                       		addq.w	#8,a6				; Next sprite
00001B94 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B98                            
00001B98                            .SetDrawnSprites:
00001B98 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B9C 4446                       		neg.w	d6				; ''
00001B9E 11C6 C75B                  		move.b	d6,rSprCount.w		; Store it
00001BA2                            
00001BA2 4E75                       		rts
00001BA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BA4                            .MultiDraw:
00001BA4 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001BA8 6700                       		beq.s	.RenderMain			; If not, branch
00001BAA                            
00001BAA 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001BAC 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001BB0                            
00001BB0                            .RenderMain:
00001BB0 7400                       		moveq	#0,d2
00001BB2 1428 0017                  		move.b	oDrawW(a0),d2			; Get main sprite width
00001BB6 3600                       		move.w	d0,d3				; Get main sprite X position
00001BB8 D642                       		add.w	d2,d3				; Add width
00001BBA 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001BBC 3600                       		move.w	d0,d3				; Get main sprite X position
00001BBE 9642                       		sub.w	d2,d3				; Subtract width
00001BC0 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BC4 6CB0                       		bge.s	.NextObject			; If so, branch
00001BC6 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BCA                            
00001BCA 1428 001B                  		move.b	oDrawH(a0),d2			; Get main sprite height
00001BCE 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BD0 D642                       		add.w	d2,d3				; Add height
00001BD2 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BD4 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BD6 9642                       		sub.w	d2,d3				; Subtract height
00001BD8 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BDC 6C98                       		bge.s	.NextObject			; If so, branch
00001BDE 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BE2                            
00001BE2 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001BE8 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BEA 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BEE                            
00001BEE 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001BF2 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001BF6 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BFA 2444                       		movea.l	d4,a2				; Store it
00001BFC 7800                       		moveq	#0,d4
00001BFE 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001C02 D844                       		add.w	d4,d4				; Turn into offset
00001C04 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C06 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C0A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C0C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C0E 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001C10 3606                       		move.w	d6,d3				; Store render flags
00001C12 6100 ED22                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C16 3C03                       		move.w	d3,d6				; Restore render flags
00001C18                            
00001C18 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C1A 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001C1E                            
00001C1E                            .RenderSubSprites:
00001C1E 3628 002E                  		move.w	oSubCnt(a0),d3			; Get sub sprite count
00001C22 5343                       		subq.w	#1,d3				; Subtract 1
00001C24 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C28 41E8 0030                  		lea	oSubStart(a0),a0		; Get sub sprite SSTs start
00001C2C                            
00001C2C                            .RenderSubSprs_Loop:
00001C2C 3018                       		move.w	(a0)+,d0			; Get X position
00001C2E 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C32 3218                       		move.w	(a0)+,d1			; Get Y position
00001C34 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C38                            
00001C38 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C3C 6700                       		beq.s	.RenderSub			; If not, branch
00001C3E                            
00001C3E 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C40 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C44                            
00001C44                            .RenderSub:
00001C44 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C46 D844                       		add.w	d4,d4				; Turn into offset
00001C48 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C4A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C4E 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C50 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C52 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C54                            		push.w	d6				; Store render flags
00001C54 3F06                     M 	move.w	d6,-(sp)
00001C56 6100 ECDE                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C5A                            		pop.w	d6				; Restore render flags
00001C5A 3C1F                     M 	move.w	(sp)+,d6
00001C5C                            
00001C5C                            .RenderSubSprs_ChkLoop:
00001C5C 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C5E 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C62 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; Animate an object's sprite
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; PARAMETERS:
00001C66                            ;	a0.l	- Object space pointer
00001C66                            ;	a1.l	- Animation script pointer
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; RETURNS:
00001C66                            ;	Nothing
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            AnimateObject:
00001C66 7000                       		moveq	#0,d0
00001C68 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00001C6C B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00001C70 6700                       		beq.s	.Run				; If not, branch
00001C72 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00001C76 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C7A 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C7E                            
00001C7E                            .Run:
00001C7E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00001C82 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C84 D040                       		add.w	d0,d0				; Turn ID into offset
00001C86 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C8A 1151 0023                  		move.b	(a1),oAniTimer(a0)		; Set new animation timer
00001C8E                            
00001C8E 7200                       		moveq	#0,d1
00001C90 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00001C94 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C98 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C9C 6400                       		bhs.s	.CmdReset			; If so, branch
00001C9E                            
00001C9E                            .Next:
00001C9E 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00001CA2 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00001CA6 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001CAA 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00001CB0 8128 000D                  		or.b	d0,oRender(a0)			; Set flip bits
00001CB4 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00001CB8                            
00001CB8                            .Wait:
00001CB8 4E75                       		rts
00001CBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CBA                            .CmdReset:
00001CBA 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001CBC 6600                       		bne.s	.CmdJump			; If not, branch
00001CBE 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001CC2 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CC6 60D6                       		bra.s	.Next				; Continue
00001CC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC8                            .CmdJump:
00001CC8 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CCA 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CCC 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CD0 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00001CD4 9200                       		sub.b	d0,d1				; ''
00001CD6 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CDA 60C2                       		bra.s	.Next				; Continue
00001CDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CDC                            .CmdSetAnim:
00001CDC 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CDE 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CE0 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            .CmdNextRout:
00001CE8 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CEA 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CEC 5428 0025                  		addq.b	#2,oRoutine(a0)			; Next routine
00001CF0 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001CF4 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next animation frame
00001CF8 4E75                       		rts
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            .CmdReset2ndRout:
00001CFA 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CFC 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CFE 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001D02                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001D02 4E75                       		rts
00001D04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D04                            .CmdNext2ndRout:
00001D04 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001D06 6600                       		bne.s	.CmdEnd				; If not, branch
00001D08                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001D08 4E75                       		rts
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            .CmdEnd:
00001D0A 4E75                       		rts
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; Load object DPLCs
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; PARAMETERS:
00001D0C                            ;	d4.w	- Target VRAM address
00001D0C                            ;	d6.l	- Pointer to uncompressed art
00001D0C                            ;	a2.l	- Pointer to DPLCs
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; RETURNS:
00001D0C                            ;	Nothing
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            LoadObjDPLCs:
00001D0C 7000                       		moveq	#0,d0
00001D0E 1028 0010                  		move.b	oFrame(a0),d0			; Get mapping frame
00001D12 B010                       		cmp.b	oPrevDPLC(a0),d0		; Do we need to update the art?
00001D14 6700                       		beq.s	.End				; If not, branch
00001D16 1080                       		move.b	d0,oPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001D18 D040                       		add.w	d0,d0				; Turn ID into offset
00001D1A D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001D1E 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001D20 5345                       		subq.w	#1,d5				; Subtract 1
00001D22 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D24                            
00001D24                            .ReadEntries:
00001D24 7200                       		moveq	#0,d1
00001D26 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D28 3601                       		move.w	d1,d3				; Copy that
00001D2A E04B                       		lsr.w	#8,d3				; Get tile count
00001D2C 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D30 0643 0010                  		addi.w	#$10,d3				; ''
00001D34 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D38 EB89                       		lsl.l	#5,d1				; ''
00001D3A D286                       		add.l	d6,d1				; Get pointer in art data
00001D3C 3404                       		move.w	d4,d2				; Copy VRAM address
00001D3E D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D40 D843                       		add.w	d3,d4				; ''
00001D42 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D46 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D4A                            
00001D4A                            .End:
00001D4A 4E75                       		rts
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; Move an object by it's velocity values
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; PARAMETERS:
00001D4C                            ;	a0.l	- Object space pointer
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; RETURNS:
00001D4C                            ;	Nothing
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ObjectMove:
00001D4C 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001D50 48C0                       		ext.l	d0				; ''
00001D52 E188                       		lsl.l	#8,d0				; Shift
00001D54 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D58 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D5C 48C0                       		ext.l	d0				; ''
00001D5E E188                       		lsl.l	#8,d0				; Shift
00001D60 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D64 4E75                       		rts
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; Move an object by it's velocity values (with gravity)
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; PARAMETERS:
00001D66                            ;	a0.l	- Object space pointer
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; RETURNS:
00001D66                            ;	Nothing
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ObjectMoveAndFall:
00001D66 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001D6A 48C0                       		ext.l	d0				; ''
00001D6C E188                       		lsl.l	#8,d0				; Shift
00001D6E D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D72 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D76 0668 0038 001E             		addi.w	#$38,oYVel(a0)			; Apply gravity
00001D7C 48C0                       		ext.l	d0				; ''
00001D7E E188                       		lsl.l	#8,d0				; Shift
00001D80 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D84 4E75                       		rts
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; Check if a specific object is nearby
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; PARAMETERS:
00001D86                            ;	a0.l	- Current object space pointer
00001D86                            ;	a1.l	- Range data pointer
00001D86                            ;	a2.l	- Object to check's space pointer
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; RETURNS:
00001D86                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            CheckObjInRange:
00001D86 7000                       		moveq	#0,d0
00001D88 322A 0014                  		move.w	oXPos(a2),d1			; Get other object's position
00001D8C 342A 0018                  		move.w	oYPos(a2),d2			; ''
00001D90 3628 0014                  		move.w	oXPos(a0),d3			; Get current object's position
00001D94 3828 0018                  		move.w	oYPos(a0),d4			; ''
00001D98 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D9A 3A03                       		move.w	d3,d5				; Copy
00001D9C DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D9E D859                       		add.w	(a1)+,d4			; Get top boundary
00001DA0 3C04                       		move.w	d4,d6				; Copy
00001DA2 DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001DA4 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001DA6 6500                       		blo.s	.End				; If not, branch
00001DA8 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001DAA 6400                       		bhs.s	.End				; If not, branch
00001DAC B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001DAE 6500                       		blo.s	.End				; If not, branch
00001DB0 B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001DB2 6400                       		bhs.s	.End				; If not, branch
00001DB4 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001DB6                            
00001DB6                            .End:
00001DB6 4E75                       		rts
00001DB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DB8                            ; Object manager
00001DB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DB8                            ObjectManager:
00001DB8 4A38 C7B8                  		tst.b	rObjManInit.w
00001DBC 6600                       		bne.s	ObjectManagerMain
00001DBE                            
00001DBE                            ObjectManagerInit:
00001DBE 50F8 C7B8                  		st	rObjManInit.w			; Set the init flag
00001DC2                            
00001DC2 2078 C7B4                  		movea.l	rObjPosAddr.w,a0		; Get object data pointer
00001DC6 21C8 C7BA                  		move.l	a0,rObjLoadR.w
00001DCA 21C8 C7BE                  		move.l	a0,rObjLoadL.w			; Store address of object layout
00001DCE                            
00001DCE 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001DD2                            
00001DD2 3C38 F880                  		move.w	rCamXPos.w,d6			; Camera's X position
00001DD6 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DDA 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DDC 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DDE                            
00001DDE                            .NoReset:
00001DDE 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DE2                            
00001DE2 2078 C7BA                  		movea.l	rObjLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DE6                            
00001DE6                            .ChkObjsLeft:
00001DE6 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DE8 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DEA 5C48                       		addq.w	#6,a0				; Next object
00001DEC 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEE 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DF0                            
00001DF0                            .ChkDone:
00001DF0 21C8 C7BA                  		move.l	a0,rObjLoadR.w			; Store new addresses
00001DF4 31CB C7C4                  		move.w	a3,rObjRespR.w			; ''
00001DF8                            
00001DF8 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001DFC                            
00001DFC 2078 C7BE                  		movea.l	rObjLoadL.w,a0
00001E00 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001E04 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001E06                            
00001E06                            .ChkObjsRight:
00001E06 BC50                       		cmp.w	(a0),d6				; Compate object position
00001E08 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001E0A 5C48                       		addq.w	#6,a0				; Next object
00001E0C 524B                       		addq.w	#1,a3				; Next respawn table index
00001E0E 60F6                       		bra.s	.ChkObjsRight			; Loop
00001E10                            
00001E10                            .ChkDone2:
00001E10 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001E14 31CB C7C2                  		move.w	a3,rObjRespL.w		; ''
00001E18                            
00001E18 31FC FFFF C7CA             		move.w	#-1,rObjManX.w		; Reset manager's camera X position
00001E1E 3038 F888                  		move.w	rCamYPos.w,d0			; Get camera's Y position
00001E22 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E26 31C0 C7CC                  		move.w	d0,rObjManY.w		; Store it so unnecessary Y checks shouldn't be done
00001E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E2A                            ObjectManagerMain:
00001E2A 3238 F888                  		move.w	rCamYPos.w,d1			; Get camera's Y position
00001E2E 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E32 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E36 31C1 C7C8                  		move.w	d1,rObjYCoarse.w		; Store this
00001E3A                            
00001E3A 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera's X position
00001E3E 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E42 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E46 31C1 C7C6                  		move.w	d1,rObjXCoarse.w		; Store this
00001E4A                            		
00001E4A 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E50                            
00001E50 3638 F888                  		move.w	rCamYPos.w,d3			; Get camera's Y position
00001E54 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E58 3803                       		move.w	d3,d4				; Copy
00001E5A 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E5E 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E62 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E64 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E66                            
00001E66                            .SetNoWrap:
00001E66 3A3C 0FFF                  		move.w	#$FFF,d5
00001E6A 3C38 F880                  		move.w	rCamXPos.w,d6			; Get camera's X position
00001E6E 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E72 BC78 C7CA                  		cmp.w	rObjManX.w,d6		; Check against last range
00001E76 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E7A 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E7C                            
00001E7C 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E80                            
00001E80 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E84 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E88                            
00001E88 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E8C 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E8E                            
00001E8E 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E92 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E94                            
00001E94                            .LoadLoop:
00001E94 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E98 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E9A 5D88                       		subq.l	#6,a0				; Get actual object address
00001E9C 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E9E                            
00001E9E 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001EA2 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001EA4 5D88                       		subq.l	#6,a0
00001EA6 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001EA8                            
00001EA8                            .LoadFail:
00001EA8 5C88                       		addq.l	#6,a0				; Undo object loading
00001EAA 524B                       		addq.w	#1,a3
00001EAC 6000                       		bra.s	.EndLoad
00001EAE                            .EndLoadRst:
00001EAE 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001EB2                            
00001EB2                            .EndLoad:
00001EB2 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001EB6 31CB C7C2                  		move.w	a3,rObjRespL.w
00001EBA                            
00001EBA 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001EBE 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001EC2                            
00001EC2 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EC6                            
00001EC6                            .ChkLoop:
00001EC6 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001ECA 6E00                       		bgt.s	.ChkDone			; If so, branch
00001ECC 5D88                       		subq.l	#6,a0				; Get the object before this
00001ECE 534B                       		subq.w	#1,a3				; And its respawn index
00001ED0 60F4                       		bra.s	.ChkLoop			; Check next object
00001ED2                            
00001ED2                            .ChkDone:
00001ED2 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001ED6 31CB C7C4                  		move.w	a3,rObjRespR.w
00001EDA 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EDC                            Level_LoadObjs_Forward:
00001EDC 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001EE0                            
00001EE0 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001EE4 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001EE8                            
00001EE8 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EEC                            
00001EEC 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001EF0 6700                       		beq.s	.EndLoad			; Branch if it failed
00001EF2                            
00001EF2                            .LoadLoop:
00001EF2 BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001EF4 6300                       		bls.s	.EndLoadRst			; If not, branch
00001EF6 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001EFA 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001EFC 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EFE 60F2                       		bra.s	.LoadLoop
00001F00                            
00001F00                            .EndLoadRst:
00001F00 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001F04                            
00001F04                            .EndLoad:
00001F04 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001F08 31CB C7C4                  		move.w	a3,rObjRespR.w
00001F0C                            
00001F0C 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001F10 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001F14                            
00001F14 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001F18 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001F1A                            
00001F1A                            .ChkLoop:
00001F1A BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001F1C 6300                       		bls.s	.ChkDone			; If so, branch
00001F1E 5C88                       		addq.l	#6,a0				; Get the object before this
00001F20 524B                       		addq.w	#1,a3				; And its respawn index
00001F22 60F6                       		bra.s	.ChkLoop			; Check next object
00001F24                            
00001F24                            .ChkDone:
00001F24 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001F28 31CB C7C2                  		move.w	a3,rObjRespL.w
00001F2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F2C                            Level_LoadObjs_SameXRange:
00001F2C 3C38 F888                  		move.w	rCamYPos.w,d6			; Get camera's X position
00001F30 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F34 3606                       		move.w	d6,d3				; Copy
00001F36 BC78 C7CC                  		cmp.w	rObjManY.w,d6		; Check against last range
00001F3A 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F3E 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F40                            
00001F40 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F44 6B00 0000                  		bmi.w	.LoadEnd
00001F48 6000                       		bra.s	.YCheck
00001F4A                            
00001F4A                            .MovingDown:
00001F4A 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F4E                            
00001F4E                            .YCheck:
00001F4E 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F52 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F54                            		
00001F54 3803                       		move.w	d3,d4				; Copy Y position
00001F56 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F5A 3A3C 0FFF                  		move.w	#$FFF,d5
00001F5E                            
00001F5E 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001F62 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001F66 2E38 C7BA                  		move.l	rObjLoadR.w,d7		; Get current objects on the right side of the screen
00001F6A 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F6C 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F6E 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F70                            
00001F70                            .LoadNext:
00001F70 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F72 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F74                            
00001F74 3210                       		move.w	(a0),d1				; Get object's Y position
00001F76 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F78 B243                       		cmp.w	d3,d1
00001F7A 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F7C B244                       		cmp.w	d4,d1
00001F7E 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F80                            
00001F80 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F84 3368 FFFE 0014             		move.w	-2(a0),oXPos(a1)			; Set X position
00001F8A 3210                       		move.w	(a0),d1				; Get object's Y position
00001F8C 3401                       		move.w	d1,d2				; Copy it
00001F8E C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F90 3341 0018                  		move.w	d1,oYPos(a1)			; Set Y position
00001F94                            
00001F94 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F96 0242 0003                  		andi.w	#3,d2				; ''
00001F9A 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F9E 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001FA2                            
00001FA2 1428 0002                  		move.b	2(a0),d2			; Get ID
00001FA6 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FA8 D442                       		add.w	d2,d2
00001FAA 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001FAE                            
00001FAE 1368 0003 0024             		move.b	3(a0),oSubtype(a1)		; Set subtype
00001FB4 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001FB8                            
00001FB8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001FBC 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001FBE                            
00001FBE                            .LoadFail:
00001FBE 5C88                       		addq.l	#6,a0				; Next object
00001FC0 524B                       		addq.w	#1,a3				; ''
00001FC2 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FC4 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FC6                            
00001FC6                            .LoadEndRst:
00001FC6 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001FCA                            
00001FCA                            .LoadEnd:
00001FCA 31C6 C7CC                  		move.w	d6,rObjManY.w		; Store manager's camera Y position
00001FCE 4E75                       		rts
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            ; Load an object from the object layout
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            ; PARAMETERS:
00001FD0                            ;	d3.w	- Upper boundary
00001FD0                            ;	d4.w	- Lower boundary
00001FD0                            ;	d5.w	- Y position limit
00001FD0                            ;	a0.l	- Index of object layout
00001FD0                            ;	a1.l	- Target object
00001FD0                            ;	a3.l	- Respawn table address
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            Level_LoadObject:
00001FD0 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FD2 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FD4 5C88                       		addq.l	#6,a0				; Next object
00001FD6 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FD8 4E75                       		rts
00001FDA                            
00001FDA                            .NotLoaded:
00001FDA 3E18                       		move.w	(a0)+,d7			; X position
00001FDC 3218                       		move.w	(a0)+,d1			; Y position
00001FDE 3401                       		move.w	d1,d2				; Copy
00001FE0 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FE2 C245                       		and.w	d5,d1				; Keey Y in range
00001FE4 B243                       		cmp.w	d3,d1
00001FE6 6500                       		bcs.s	.End				; Branch if in range
00001FE8 B244                       		cmp.w	d4,d1
00001FEA 6300                       		bls.s	.Spawn				; Branch if in range
00001FEC                            
00001FEC                            .End:
00001FEC 5448                       		addq.w	#2,a0				; Next objeect
00001FEE 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FF0 4E75                       		rts
00001FF2                            
00001FF2                            .LoadNoY:
00001FF2 C245                       		and.w	d5,d1				; Keey Y in range
00001FF4                            
00001FF4                            .Spawn:
00001FF4 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FF8 3347 0014                  		move.w	d7,oXPos(a1)			; Store X position
00001FFC 3341 0018                  		move.w	d1,oYPos(a1)			; Store Y position
00002000                            
00002000 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00002002 0242 0003                  		andi.w	#3,d2				; ''
00002006 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
0000200A 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
0000200E                            
0000200E 1418                       		move.b	(a0)+,d2			; Get ID
00002010 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00002012 D442                       		add.w	d2,d2
00002014 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00002018                            
00002018 1358 0024                  		move.b	(a0)+,oSubtype(a1)		; Set subtype
0000201C 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00002020                            		
00002020 6000 F9FA                  		bra.w	FindFreeObj			; Find a free object slot
00002024                            		
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Check if the object is in range on the camera. If it isn't, delete it
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	Nothing
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            CheckObjActive:
00002024 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00002028                            
00002028                            CheckObjActive2:
00002028 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
0000202C 9078 C7C6                  		sub.w	rObjXCoarse.w,d0		; Subtract the camera's coarse X position
00002030 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002034 6200                       		bhi.s	.Delete				; If so, branch
00002036 4E75                       		rts
00002038                            
00002038                            .Delete:
00002038 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table entry address
0000203C 6700                       		beq.s	.DoDelete			; If 0, branch
0000203E 3440                       		movea.w	d0,a2
00002040 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002044                            
00002044                            .DoDelete:
00002044 4EF8 1A72                  		jmp	DeleteObject.w			; Delete the object
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; Get orientation to player
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; PARAMETERS:
00002048                            ;	a0.l	- Object space pointer
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; RETURNS:
00002048                            ;	a1.l	- Player object
00002048                            ;	d0.w	- 0 if player is left from object, 2 if right
00002048                            ;	d1.w	- 0 if player is above object, 2 if below
00002048                            ;	d2.w	- Player's horizontal distance to object
00002048                            ;	d3.w	- Player's vertical distance to object
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            GetOrientToPlayer:
00002048 7000                       		moveq	#0,d0
0000204A 7200                       		moveq	#0,d1
0000204C                            
0000204C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get player object
00002050                            
00002050 3428 0014                  		move.w	oXPos(a0),d2			; Get horizonal distance
00002054 9469 0014                  		sub.w	oXPos(a1),d2			; ''
00002058 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
0000205A 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
0000205C                            
0000205C                            .GetY:
0000205C 3628 0018                  		move.w	oYPos(a0),d3			; Get vertical distance
00002060 9669 0018                  		sub.w	oYPos(a1),d3			; ''
00002064 6400                       		bhs.s	.End				; Branch if the player is above the object
00002066 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002068                            
00002068                            .End:
00002068 4E75                       		rts
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; Cap an object's speed
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; PARAMETERS:
0000206A                            ;	a0.l	- Object space pointer
0000206A                            ;	d0.w	- Max X speed
0000206A                            ;	d1.w	- Max Y speed
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; RETURNS:
0000206A                            ;	Nothing
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            CapObjSpeed:
0000206A 3428 001C                  		move.w	oXVel(a0),d2			; Get X velocity
0000206E 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
00002070 4440                       		neg.w	d0				; Get absolute speed
00002072 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002074 6400                       		bhs.s	.ChkUp				; If not, branch
00002076 3400                       		move.w	d0,d2				; Cap the speed
00002078 6000                       		bra.s	.ChkUp				; Continue
0000207A                            
0000207A                            .ChkRight:
0000207A B440                       		cmp.w	d0,d2				; Has it gone over the limit?
0000207C 6300                       		bls.s	.ChkUp				; If not, branch
0000207E 3400                       		move.w	d0,d2				; Cap the speed
00002080                            
00002080                            .ChkUp:
00002080 3628 001E                  		move.w	oYVel(a0),d3			; Get Y velocity
00002084 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002086 4441                       		neg.w	d1				; Get absolute speed
00002088 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000208A 6400                       		bhs.s	.UpdateVel			; If not, branch
0000208C 3601                       		move.w	d1,d3				; Cap the speed
0000208E 6000                       		bra.s	.UpdateVel			; Continue
00002090                            
00002090                            .ChkDown:
00002090 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002092 6300                       		bls.s	.UpdateVel			; If not, branch
00002094 3601                       		move.w	d1,d3				; Cap the speed
00002096                            
00002096                            .UpdateVel:
00002096 3142 001C                  		move.w	d2,oXVel(a0)			; Set X velocity
0000209A 3142 001E                  		move.w	d2,oYVel(a0)			; Set Y velocity
0000209E 4E75                       		rts
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; PARAMETERS:
000020A0                            ;	a2.l	- Object data
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; RETURNS:
000020A0                            ;	Nothing
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; LoadChildObject:
000020A0 6100 F97A                  		bsr.w	FindFreeObj			; Find a free object slot
000020A4 6600                       		bne.s	.End				; If there is non, branch
000020A6 301A                       		move.w	(a2)+,d0			; Get parent object SST
000020A8 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
000020AC 301A                       		move.w	(a2)+,d0			; Get child object SST
000020AE 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
000020B2 229A                       		move.l	(a2)+,oAddr(a1)			; Set object pointer
000020B4 135A 0024                  		move.b	(a2)+,oSubtype(a1)		; Set subtype
000020B8 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)			; Set X
000020BE 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)			; Set Y
000020C4                            
000020C4                            .End:
000020C4 4E75                       		rts
000020C6                            ; =========================================================================================================================================================
000020C6                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020C6                            ; =========================================================================================================================================================
000020C6                            ; Interrupt functions
000020C6                            ; =========================================================================================================================================================
000020C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C6                            ; Vertical Interrupts
000020C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C6                            VInt_Standard:
000020C6                            		intsOff					; Turn interrupts off
000020C6 007C 0700                M 	ori	#$700,sr
000020CA                            		push.l	d0-a6				; Save registers
000020CA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020CE                            		
000020CE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020D4 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020D8                            
000020D8                            .WaitForVBLANK:
000020D8 3016                       		move.w	(a6),d0				; Get VDP status
000020DA 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020DE 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020E0                            
000020E0 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
000020E6 6700                       		beq.s	.SetVScroll			; If not, branch
000020E8 303C 0700                  		move.w	#$700,d0			; Do a delay
000020EC 51C8 FFFE                  		dbf	d0,*				; ''
000020F0                            
000020F0                            .SetVScroll:
000020F0                            		dma68k	rVScroll,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020F0 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020F6 2CBC 96CA 953F           M 	move.l	#$96009500|((((rvscroll)/2)&$ff00)<<8)|(((rvscroll)/2)&$ff),(a6)
000020FC 3CBC 977F                M 	move.w	#$9700|(((rvscroll)>>17)&$7f),(a6)
00002100                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
00002100 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002104                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
00002104 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002108 3C9F                     M 	move.w	(sp)+,(a6)
0000210A                            
0000210A 4A38 C745                  		tst.b	rVINTRout.w			; Is the game lagging?
0000210E 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
00002112 4238 C748                  		clr.b	rLagCount.w			; Clear lag frame counter
00002116                            
00002116 7000                       		moveq	#0,d0
00002118 1038 C745                  		move.b	rVINTRout.w,d0		; Get V-INT routine ID
0000211C 4238 C745                  		clr.b	rVINTRout.w			; Clear V-INT routine ID
00002120 50F8 C749                  		st	rHIntFlag.w			; Allow the H-INT to run
00002124 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002128 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
0000212C                            
0000212C                            VInt_FinishUpdates:
0000212C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002132                            
00002132                            VInt_End:
00002132 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
00002136 6100 F216                  		bsr.w	RandomNumber			; Generate a random number
0000213A                            		
0000213A                            		pop.l	d0-a6				; Restore registers
0000213A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000213E                            		intsOn					; Turn interrupts on
0000213E 027C F8FF                M 	andi	#$f8ff,sr
00002142                            		lagOn					; Turn on the lag-o-meter
00002142 4E73                       		rte
00002144                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002144                            ; V-INT routines
00002144                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002144                            VInt_Routines:
00002144 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002146 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002148 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
0000214A 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
0000214C 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000214E 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
00002150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002150                            ; V-INT lag routine
00002150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002150                            VInt_Lag:
00002150 584F                       		addq.w	#4,sp				; Don't return to caller
00002152                            
00002152                            VInt_Lag_Main:
00002152 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002156 6600                       		bne.s	.WaterPal			; If so, branch
00002158                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002158 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000215E 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002164 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002168                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002168 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000216C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000216C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002170 3C9F                     M 	move.w	(sp)+,(a6)
00002172 6000                       		bra.s	.Cont				; Continue
00002174                            
00002174                            .WaterPal:
00002174                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
00002174 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000217A 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002180 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
00002184                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002184 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002188                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002188 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000218C 3C9F                     M 	move.w	(sp)+,(a6)
0000218E                            
0000218E                            .Cont:	
0000218E 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002192                            
00002192 5238 C748                  		addq.b	#1,rLagCount.w		; Increment lag counter
00002196 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            ; V-INT general routine
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            VInt_General:
0000219A 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000219E 6000 EF38                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A2                            ; V-INT level load routine
000021A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A2                            VInt_LevelLoad:
000021A2 6100 E916                  		bsr.w	ReadJoypads			; Read joypads
000021A6                            
000021A6 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000021AA 6600                       		bne.s	.WaterPal			; If so, branch
000021AC                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000021AC 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021B2 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021B8 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000021BC                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021BC 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021C0                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021C0 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021C4 3C9F                     M 	move.w	(sp)+,(a6)
000021C6 6000                       		bra.s	.Cont				; Continue
000021C8                            
000021C8                            .WaterPal:
000021C8                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021C8 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021CE 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000021D4 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000021D8                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021D8 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021DC                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021DC 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021E0 3C9F                     M 	move.w	(sp)+,(a6)
000021E2                            
000021E2                            .Cont:
000021E2 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000021E6                            		
000021E6                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000021E6 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021EC 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000021F2 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000021F6                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021F6 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021FA                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021FA 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021FE 3C9F                     M 	move.w	(sp)+,(a6)
00002200                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002200 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002206 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
0000220C 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002210                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002210 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002214                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002214 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002218 3C9F                     M 	move.w	(sp)+,(a6)
0000221A 6100 E18C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000221E                            		
0000221E 6000 EEB8                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002222                            ; V-INT level routine
00002222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002222                            VInt_Level:
00002222 43F8 F880                  		lea	rFGCam.w,a1			; Foreground level drawing variables
00002226 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Foreground column plane buffer
0000222A 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Foreground row plane buffer
0000222E 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002234 43F8 F89E                  		lea	rBGCam.w,a1			; Background level drawing variables
00002238 47F8 C424                  		lea	rBGColBuf.w,a3		; Background column plane buffer
0000223C 49F8 C322                  		lea	rBGRowBuf.w,a4		; Background row plane buffer
00002240 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002246                            
00002246 6100 E872                  		bsr.w	ReadJoypads			; Read joypads
0000224A                            
0000224A 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
0000224E 6600                       		bne.s	.WaterPal			; If so, branch
00002250                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002250 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002256 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000225C 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002260                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002260 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002264                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002264 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002268 3C9F                     M 	move.w	(sp)+,(a6)
0000226A 6000                       		bra.s	.Cont				; Continue
0000226C                            
0000226C                            .WaterPal:
0000226C                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000226C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002272 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002278 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000227C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000227C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002280                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002280 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002284 3C9F                     M 	move.w	(sp)+,(a6)
00002286                            
00002286                            .Cont:
00002286 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
0000228A                            
0000228A                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000228A 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002290 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002296 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000229A                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000229A 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000229E                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000229E 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022A2 3C9F                     M 	move.w	(sp)+,(a6)
000022A4                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000022A4 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000022AA 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
000022B0 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
000022B4                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000022B4 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000022B8                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000022B8 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000022BC 3C9F                     M 	move.w	(sp)+,(a6)
000022BE 6100 E0E8                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000022C2                            		
000022C2 0C38 005C C75F             		cmpi.b	#92,rHIntCnt.w		; Would V-INT be unable to do updates in the next frame?
000022C8 6400                       		bhs.s	.DoUpdates			; If not, branch
000022CA 50F8 C75D                  		st	rHIntUpdates.W		; Set updates in H-INT flag
000022CE 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022D0 6100 EE06                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022D4 6000 FE5C                  		bra.w	VInt_End			; Continue
000022D8                            
000022D8                            .DoUpdates:
000022D8 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022DE 6000 EDF8                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E2                            ; V-INT title screen update routine
000022E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E2                            VInt_Title:
000022E2 4E75                       		rts
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            ;		bsr.w	ReadJoypads			; Read joypads
000022E4                            ;
000022E4                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022E4                            ;		lea	rPalette.w,a0			; ''
000022E4                            ;		moveq	#$80>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WritePal:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WritePal			; ''
000022E4                            ;
000022E4                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022E4                            ;		lea	rSprites.w,a0			; ''
000022E4                            ;		move.w	#$280>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WriteSprs:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WriteSprs			; ''
000022E4                            ;
000022E4                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022E4                            ;		lea	rHScroll.w,a0			; ''
000022E4                            ;		move.w	#$380>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WriteHScrl:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WriteHScrl			; ''
000022E4                            ;		rts
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            ; Do standard updates in V-INT
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            VInt_Update:
000022E4                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022E4                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000022E4 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022EA 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022F4 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022F8 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022FE                            ; V-INT fade routine
000022FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022FE                            VInt_Fade:
000022FE 6100 E7BA                  		bsr.w	ReadJoypads			; Read joypads
00002302                            
00002302 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002306 6600                       		bne.s	.WaterPal			; If so, branch
00002308                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002308 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000230E 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002314 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002318                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002318 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000231C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000231C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002320 3C9F                     M 	move.w	(sp)+,(a6)
00002322 6000                       		bra.s	.Cont				; Continue
00002324                            
00002324                            .WaterPal:
00002324                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
00002324 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000232A 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002330 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
00002334                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002334 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002338                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002338 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000233C 3C9F                     M 	move.w	(sp)+,(a6)
0000233E                            
0000233E                            .Cont:
0000233E 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002342                            
00002342                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002342 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002348 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
0000234E 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002352                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002352 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002356                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002356 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000235A 3C9F                     M 	move.w	(sp)+,(a6)
0000235C 6000 E04A                  		bra.w	ProcessDMAQueue			; Process DMA queue
00002360                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002360                            ; V-INT routine that only runs the SMPS driver
00002360                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002360                            VInt_RunSMPS:
00002360                            		push.l	d0-a6				; Save registers
00002360 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002364                            		
00002364                            .WaitForVBLANK:
00002364 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
0000236A 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000236E 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
00002370                            
00002370 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
00002376 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002378 303C 0700                  		move.w	#$700,d0			; Do a delay
0000237C 51C8 FFFE                  		dbf	d0,*				; ''
00002380                            
00002380                            .UpdateSMPS:
00002380 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002386                            
00002386 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
0000238A 6100 EFC2                  		bsr.w	RandomNumber			; Generate a random number
0000238E                            		
0000238E                            		pop.l	d0-a6				; Restore registers
0000238E 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002392 4E73                       		rte
00002394                            
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; Wait for the vertical interrupt to run and finish
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; PARAMETERS:
00002394                            ;	Nothing
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; RETURNS:
00002394                            ;	Nothing
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            VSync:
00002394 50F8 C745                  		st	rVINTFlag.w			; Set V-INT flag
00002398                            
00002398                            VSync_Routine:
00002398                            		intsOn					; Enable interrupts
00002398 027C F8FF                M 	andi	#$f8ff,sr
0000239C                            		lagOff					; Turn off the lag-o-meter
0000239C                            
0000239C                            .Wait:
0000239C 4A38 C745                  		tst.b	rVINTFlag.w			; Has the V-INT run yet?
000023A0 66FA                       		bne.s	.Wait				; If not, wait some more
000023A2 4E75                       		rts
000023A4                            
000023A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A4                            ; Horizontal interrupt for palette swapping (for water)
000023A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A4                            HInt_Water:
000023A4                            		intsOff					; Disable interrupts
000023A4 007C 0700                M 	ori	#$700,sr
000023A8                            
000023A8 4A38 C749                  		tst.b	rHIntFlag.w			; Is the H-INT allowed to run?
000023AC 6700                       		beq.s	.End				; If not, branch
000023AE 4238 C749                  		clr.b	rHIntFlag.w			; Clear the H-INT flag
000023B2                            
000023B2                            		push.l	a0-a1				; Save registers
000023B2 48E7 00C0                M 	movem.l	a0-a1,-(sp)
000023B6                            
000023B6 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
000023BC 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
000023C2 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette
000023C6                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023C6 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023CE                            		rept	32
000023CE                            			move.l	(a0)+,(a1)		; Tranfer palette
000023CE                            		endr
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA 2298                     M 	move.l	(a0)+,(a1)
000023EC 2298                     M 	move.l	(a0)+,(a1)
000023EE 2298                     M 	move.l	(a0)+,(a1)
000023F0 2298                     M 	move.l	(a0)+,(a1)
000023F2 2298                     M 	move.l	(a0)+,(a1)
000023F4 2298                     M 	move.l	(a0)+,(a1)
000023F6 2298                     M 	move.l	(a0)+,(a1)
000023F8 2298                     M 	move.l	(a0)+,(a1)
000023FA 2298                     M 	move.l	(a0)+,(a1)
000023FC 2298                     M 	move.l	(a0)+,(a1)
000023FE 2298                     M 	move.l	(a0)+,(a1)
00002400 2298                     M 	move.l	(a0)+,(a1)
00002402 2298                     M 	move.l	(a0)+,(a1)
00002404 2298                     M 	move.l	(a0)+,(a1)
00002406 2298                     M 	move.l	(a0)+,(a1)
00002408 2298                     M 	move.l	(a0)+,(a1)
0000240A 2298                     M 	move.l	(a0)+,(a1)
0000240C 2298                     M 	move.l	(a0)+,(a1)
0000240E                            		pop.l	a0-a1				; Restore registers
0000240E 4CDF 0300                M 	movem.l	(sp)+,a0-a1
00002412                            		
00002412 4A38 C75D                  		tst.b	rHIntUpdates.w		; Do we need to do level updates in here?
00002416 6600                       		bne.s	.DoUpdates			; If so, branch
00002418                            
00002418                            .End:
00002418 4E73                       		rte
0000241A                            
0000241A                            .DoUpdates:
0000241A 4238 C75D                  		clr.b	rHIntUpdates.w		; Clear the update flag
0000241E                            		push.l	d0-a6				; Save registers
0000241E 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002422 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002428 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0000242C 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
00002432 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002438                            		pop.l	d0-a6				; Restore registers
00002438 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000243C 4E73                       		rte
0000243E                            ; =========================================================================================================================================================
0000243E                            
0000243E                            ; =========================================================================================================================================================
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            ; Opmode Main Code
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            		include	"Opmodes/Title/Main.asm"
0000243E                            ; =========================================================================================================================================================
0000243E                            ; Title splash screen
0000243E                            ; =========================================================================================================================================================
0000243E                            
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            TitleScreen:
0000243E 60FE                       		bra.s	TitleScreen
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00002440                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00002440                            ;
00002440                            ;		bsr.w	FadeToBlack			; Fade to black
00002440                            ;
00002440                            ;		intsOff					; Disable interrupts
00002440                            ;		clrRAM	rKosPVars
00002440                            ;		clrRAM	rChkpoint
00002440                            ;		clrRAM	rGameVars
00002440                            ;		clrRAM	rObjects
00002440                            ;
00002440                            ;		lea	VDP_CTRL,a5
00002440                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00002440                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
00002440                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002440                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00002440                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
00002440                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00002440                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002440                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00002440                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002440                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
00002440                            ;
00002440                            ;		bsr.w	ClearScreen			; Clear screen
00002440                            ;
00002440                            ;		lea	rDestPal.w,a0			; Fade target palette
00002440                            ;		moveq	#$80>>2-1,d0			; Size
00002440                            ;
00002440                            ;.FillPal:
00002440                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
00002440                            ;		dbf	d0,.FillPal			; Loop
00002440                            ;
00002440                            ;		bsr.w	FadeFromBlack			; Fade from black
00002440                            ;		
00002440                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
00002440                            ;
00002440                            ;TitleScreen2:
00002440                            ;		intsOff
00002440                            ;
00002440                            ;		clr.b	rArtCheat.w
00002440                            ;		clrRAM	rGameVars
00002440                            ;		clrRAM	rObjects
00002440                            ;
00002440                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
00002440                            ;		bsr.w	FadeToWhite			; Fade to white
00002440                            ;
00002440                            ;		intsOff
00002440                            ;		bsr.w	ClearScreen			; Clear screen
00002440                            ;
00002440                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$27,d1				; $28x$1C tiles
00002440                            ;		moveq	#$1B,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$E,d1				; $28x$1C tiles
00002440                            ;		moveq	#$C,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	Pal_Title,a0			; Load palette to target buffer
00002440                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
00002440                            ;		bsr.w	LoadTargetPal			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
00002440                            ;		move.w	#$20,d2				; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
00002440                            ;		move.w	#$6E00,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
00002440                            ;		move.w	#$4000,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
00002440                            ;		move.w	#$8400,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
00002440                            ;		move.w	#$8600,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;.WaitPLCs:
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002440                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
00002440                            ;		bne.s	.WaitPLCs			; If so, branch
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		
00002440                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
00002440                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
00002440                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
00002440                            ;
00002440                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
00002440                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
00002440                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
00002440                            ;
00002440                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
00002440                            ;		move.w	#224,(rObj_2+oX).w		; Set X
00002440                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
00002440                            ;
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;
00002440                            ;		clr.w	rPalCycTimer.w		; Reset palette cycle
00002440                            ;
00002440                            ;		bsr.w	FadeFromWhite			; Fade from white
00002440                            ;
00002440                            ;		lea	SampleList+$C0,a3		; Play title screen music
00002440                            ;		jsr	PlayDAC1			; ''
00002440                            ;
00002440                            ;.Loop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
00002440                            ;		bsr.w	VSync_Routine			; ''
00002440                            ;
00002440                            ;		bsr.s	Title_Updates			; Do updates
00002440                            ;		
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;
00002440                            ;		lea	FreeMove_Cheat(pc),a0
00002440                            ;		lea	rMoveCheat.w,a1
00002440                            ;		lea	rCheatEntry.w,a2
00002440                            ;		bsr.w	Title_ChkCheats
00002440                            ;		lea	Art_Cheat(pc),a0
00002440                            ;		lea	rArtCheat.w,a1
00002440                            ;		lea	rCheatEntry2.w,a2
00002440                            ;		bsr.w	Title_ChkCheats
00002440                            ;
00002440                            ;		tst.b	rArtCheat.w
00002440                            ;		bne.w	BinbowieArt
00002440                            ;
00002440                            ;		tst.b	rP1Press.w			; Has start been pressed
00002440                            ;		bpl.s	.Loop				; If so, branch
00002440                            ;
00002440                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
00002440                            ;
00002440                            ;		lea	SampleList+$E0,a3		; Punch
00002440                            ;		jsr	PlayDAC1			; ''
00002440                            ;
00002440                            ;.PunchLoop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
00002440                            ;		bsr.w	VSync_Routine			; ''
00002440                            ;
00002440                            ;		bsr.s	Title_Updates			; Do updates
00002440                            ;
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;		
00002440                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
00002440                            ;		bpl.s	.PunchLoop			; If not, loop
00002440                            ;		
00002440                            ;		st	rStartFall.w			; Set flag to start the level by falling
00002440                            ;
00002440                            ;		move.b	#gLevel,rGameMode.w		; Set game mode to "level"
00002440                            ;		jmp	Level				; Go to level
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Palette cycle
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Title_Updates:
00002440                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
00002440                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
00002440                            ;		jsr	CalcSine.w			; Get sine
00002440                            ;		asr.w	#5,d0				; ''
00002440                            ;		move.w	d0,rVScrollFG.w		; Set logo's Y position
00002440                            ;
00002440                            ;		subq.b	#1,rPalCycTimer.w		; Decrement timer
00002440                            ;		bpl.s	.End				; If it hasn't run out, branch
00002440                            ;		move.b	#6,rPalCycTimer.w		; Reset timer
00002440                            ;		
00002440                            ;		moveq	#0,d0
00002440                            ;		move.b	rPalCycIndex.w,d0		; Get index
00002440                            ;		mulu.w	#$C,d0				; Turn into offset
00002440                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
00002440                            ;		lea	(rPalette+$14).w,a1		; Palette
00002440                            ;		move.w	(a0)+,(a1)+			; Load palette
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		
00002440                            ;		addq.b	#1,rPalCycIndex.w		; Increment index
00002440                            ;		cmpi.b	#6,rPalCycIndex.w		; Has it reached the end?
00002440                            ;		bcs.s	.End				; If not, branch
00002440                            ;		clr.b	rPalCycIndex.w		; Reset index
00002440                            
00002440                            ;.End:
00002440                            ;		rts
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;PalCyc_Title:
00002440                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
00002440                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
00002440                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
00002440                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
00002440                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
00002440                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Check for cheats
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Title_ChkCheats:
00002440                            ;		tst.b	(a1)
00002440                            ;		bne.s	.End
00002440                            ;		move.w	(a2),d0
00002440                            ;		adda.w	d0,a0
00002440                            ;		move.b	rP1Press.w,d0
00002440                            ;		cmp.b	(a0),d0
00002440                            ;		bne.s	.ResetCheat
00002440                            ;		addq.w	#1,(a2)
00002440                            ;		tst.b	d0
00002440                            ;		bne.s	.End
00002440                            ;		st	(a1)
00002440                            ;		playSnd	#sRing, 2
00002440                            ;		rts
00002440                            ;
00002440                            ;.ResetCheat:
00002440                            ;		tst.b	d0
00002440                            ;		beq.s	.End
00002440                            ;		clr.w	(a2)
00002440                            ;
00002440                            ;.End:
00002440                            ;		rts
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;FreeMove_Cheat:
00002440                            ;		dc.b	1, 2, 4, 8, 0, $FF
00002440                            ;		even
00002440                            ;Art_Cheat:
00002440                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; BinBowie's art
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;BinbowieArt:
00002440                            ;		bsr.w	FadeToWhite			; Fade to white
00002440                            ;		
00002440                            ;		lea	SampleList,a3
00002440                            ;		jsr	PlayDAC1
00002440                            ;
00002440                            ;		intsOff
00002440                            ;
00002440                            ;		jsr	ClearScreen.w
00002440                            ;
00002440                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$27,d1				; $28x$1C tiles
00002440                            ;		moveq	#$1B,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
00002440                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
00002440                            ;		bsr.w	LoadTargetPal			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
00002440                            ;		move.w	#$20,d2				; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;.WaitPLCs:
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002440                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
00002440                            ;		bne.s	.WaitPLCs			; If so, branch
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;
00002440                            ;		jsr	FadeFromWhite.w
00002440                            ;
00002440                            ;		lea	SampleList+$100,a3
00002440                            ;		jsr	PlayDAC1
00002440                            ;
00002440                            ;.Loop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		move.b	rP1Press.w,d0
00002440                            ;		andi.b	#%10010000,d0
00002440                            ;		beq.s	.Loop
00002440                            ;
00002440                            ;		jmp	TitleScreen2
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Objects
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
00002440                            ;		include	"Title Screen/Objects/Bird/Code.asm"
00002440                            ;		include	"Title Screen/Objects/Glove/Code.asm"
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Art
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;ArtKosM_TitleBG:
00002440                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
00002440                            ;		even
00002440                            ;ArtKosM_TitleLogo:
00002440                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
00002440                            ;		even
00002440                            ;ArtKosM_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Plane mappings
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;MapEni_TitleBG:
00002440                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
00002440                            ;		even
00002440                            ;MapEni_TitleLogo:
00002440                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
00002440                            ;		even
00002440                            ;MapEni_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Palette
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Pal_Title:
00002440                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
00002440                            ;Pal_Title_End:
00002440                            ;		even
00002440                            ;Pal_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
00002440                            ;Pal_BinBowieArt_End:
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; SEGA FMV
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
00002440                            ; =========================================================================================================================================================
00002440                            		include	"Opmodes/Gameplay/Main.asm"
00002440                            ; =========================================================================================================================================================
00002440                            ; Level
00002440                            ; =========================================================================================================================================================
00002440                            Level:
00002440                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
00002440 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
00002446                            
00002446 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
0000244A                            
0000244A                            Level_NoFade:
0000244A                            		; --- Set up the VDP ---
0000244A                            
0000244A                            		intsOff					; Disable interrupts
0000244A 007C 0700                M 	ori	#$700,sr
0000244E                            		displayOff				; Disable display
0000244E 3038 C764                M 	move.w	rvdpreg1.w,d0
00002452 0200 00BF                M 	andi.b	#%10111111,d0
00002456 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
0000245C                            
0000245C 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
00002462 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
00002466 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
0000246A 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
0000246E 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
00002472 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
00002476 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
0000247A 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
0000247E 31C0 C766                  		move.w	d0,rWindowY.w			; ''
00002482 3A80                       		move.w	d0,(a5)				; ''
00002484 4278 9000                  		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002488 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0000248E                            
0000248E 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
00002492                            
00002492                            		; --- Clear some RAM ---
00002492                            
00002492                            		clrRAM	rKosPVars			; Clear Kosinski queue variables
00002492                          M 	local	endaddr
00002492                          M endaddr	equs	"rkospvars_End"
00002492 7000                     M 	moveq	#0,d0
00002494 43F8 994E                M 	lea	(rkospvars).w,a1
00002498 323C 0040                M 	move.w	#(((rkospvars_end)-(rkospvars))-((rkospvars)&1))>>2-1,d1
0000249C 22C0                     M .clear_134:	move.l	d0,(a1)+
0000249E 51C9 FFFC                M 	dbf	d1,.clear_134
000024A2 32C0                     M 	move.w	d0,(a1)+
000024A4                            		clrRAM	rGameVars			; Clear variables
000024A4                          M 	local	endaddr
000024A4                          M endaddr	equs	"rgamevars_End"
000024A4 7000                     M 	moveq	#0,d0
000024A6 43F8 C7D0                M 	lea	(rgamevars).w,a1
000024AA 323C 0DCB                M 	move.w	#(((rgamevars_end)-(rgamevars))-((rgamevars)&1))>>2-1,d1
000024AE 22C0                     M .clear_135:	move.l	d0,(a1)+
000024B0 51C9 FFFC                M 	dbf	d1,.clear_135
000024B4                            		clrRAM	rOscNums			; Clear oscillation data
000024B4                          M 	local	endaddr
000024B4                          M endaddr	equs	"roscnums_End"
000024B4 7000                     M 	moveq	#0,d0
000024B6 43F8 C76A                M 	lea	(roscnums).w,a1
000024BA 323C 000F                M 	move.w	#(((roscnums_end)-(roscnums))-((roscnums)&1))>>2-1,d1
000024BE 22C0                     M .clear_136:	move.l	d0,(a1)+
000024C0 51C9 FFFC                M 	dbf	d1,.clear_136
000024C4 32C0                     M 	move.w	d0,(a1)+
000024C6                            
000024C6                            		; --- Do some final initializing and play the level music ---
000024C6                            
000024C6 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Set ring animation timer
000024CC 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set floor timer
000024D2 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset palette cycle
000024D6                            
000024D6 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
000024DA 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000024DE E218                       		ror.b	#1,d0				; Turn into offset
000024E0 EE48                       		lsr.w	#7,d0				; ''
000024E2 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
000024E6 11C0 F8D6                  		move.b	d0,rLevelMusic.w		; Store it
000024EA                            		playSnd	d0, 1				; Play it
000024EA 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
000024EE                            
000024EE                            		intsOn					; Enable interrupts
000024EE 027C F8FF                M 	andi	#$f8ff,sr
000024F2                            
000024F2                            		; --- Load level data ---
000024F2                            
000024F2 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
000024F8 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
000024FC                            
000024FC 4EB8 19BE                  		jsr	InitObjectList.w
00002500                            
00002500 4EB8 1A1C                  		jsr	FindFreeObj.w
00002504 22BC 0000 0000             		move.l	#ObjPlayer,oAddr(a1)		; Load Player object
0000250A 31C9 F86C                  		move.w	a1,rPlayer1Addr.w		; Store the address
0000250E                            
0000250E 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00002512 6700                       		beq.s	.NoSurface			; If not, branch
00002514                            
00002514                            							; Load water surfaces
00002514 4EB8 1A1C                  		jsr	FindFreeObj.w
00002518 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
0000251E 337C 0060 0014             		move.w	#$60,oXPos(a1)
00002524 31C9 F87C                  		move.w	a1,rWater1Addr.w		; Store the address
00002528                            
00002528 4EB8 1A1C                  		jsr	FindFreeObj.w
0000252C 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
00002532 337C 0120 0014             		move.w	#$120,oXPos(a1)
00002538 31C9 F87E                  		move.w	a1,rWater2Addr.w		; Store the address
0000253C                            
0000253C                            .NoSurface:
0000253C 6100 0000                  		bsr.w	Level_LoadData			; Load level data
00002540                            
00002540                            .WaitPLCs:
00002540 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002546 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
0000254A 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
0000254E 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002552 4A38 9990                  		tst.b	rKosPMMods.w			; Are there still modules left?
00002556 66E8                       		bne.s	.WaitPLCs			; If so, branch
00002558                            
00002558 4238 F8F4                  		clr.b	rWaterFlag.w			; Clear the water flag
0000255C                            
0000255C 41FA 0000                  		lea	Level_WaterLevels(pc),a0	; Water heights
00002560 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002564 E218                       		ror.b	#1,d0				; Turn into offset
00002566 EC48                       		lsr.w	#6,d0				; ''
00002568 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
0000256C 6B00                       		bmi.s	.NoWater			; If it's negative, branch
0000256E 31C0 F8F6                  		move.w	d0,rWaterLvl.w		; Set the water height
00002572 31C0 F8F8                  		move.w	d0,rDestWtrLvl.w
00002576                            
00002576 50F8 F8F4                  		st	rWaterFlag.w			; Set the water flag
0000257A 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
00002582 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002586 33F8 C75E 00C0 0004        		move.w	rHIntReg.w,VDP_CTRL		; Set H-INT counter
0000258E                            
0000258E                            .NoWater:
0000258E 31FC 00A0 F8D2             		move.w	#320/2,rCamXPosCenter.w		; Set camera X center
00002594                            
00002594 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
00002598                            
00002598 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
0000259C 6100 0000                  		bsr.w	Level_InitHUD			; Initialize the HUD
000025A0 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
000025A4                            
000025A4 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025A8                            
000025A8                            		; --- Load the planes ---
000025A8                            
000025A8                            		intsOff					; Disable interrupts
000025A8 007C 0700                M 	ori	#$700,sr
000025AC 21FC 0000 2360 C74C        		move.l	#VInt_RunSMPS,rVIntAddr.w	; Swap V-INT
000025B4                            		intsOn					; Enable interrupts
000025B4 027C F8FF                M 	andi	#$f8ff,sr
000025B8 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
000025BC                            		intsOff					; Disable interrupts
000025BC 007C 0700                M 	ori	#$700,sr
000025C0 21FC 0000 20C6 C74C        		move.l	#VInt_Standard,rVIntAddr.w	; Swap V-INT
000025C8                            		intsOn					; Enable interrupts
000025C8 027C F8FF                M 	andi	#$f8ff,sr
000025CC 11FC 0006 C745             		move.b	#vLvlLoad,rVINTRout.w		; Level load V-INT routine
000025D2 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
000025D6                            
000025D6                            		; --- Load the level objects and rings ---
000025D6                            
000025D6 51F8 C7B8                  		sf	rObjManInit.w			; Reset object manager routine
000025DA 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
000025DE 4EB8 1DB8                  		jsr	ObjectManager.w			; Run the object manager
000025E2                            	runObjects
000025E2 3078 BE58                M 	movea.w	rtailnext.w,a0
000025E6 2250                     M 	move.l	oaddr(a0),a1
000025E8 4E91                     M 	jsr	(a1)
000025EA 4EB8 1ABA                  		jsr	RenderObjects.w			; Render objects
000025EE                            
000025EE 4238 F8FC                  		clr.b	rLvlReload.w			; Clear the level reload flag
000025F2                            
000025F2                            		displayOn				; Enable display
000025F2 3038 C764                M 	move.w	rvdpreg1.w,d0
000025F6 0000 0040                M 	ori.b	#%01000000,d0
000025FA 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002600 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
00002604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002604                            ; Main loop
00002604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002604                            .Loop:
00002604 11FC 0004 C745             		move.b	#vLevel,rVINTRout.w		; Level V-INT routine
0000260A 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
0000260E 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
00002612                            
00002612 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
00002616 5278 F8FA                  		addq.w	#1,rLvlFrames.w			; Increment frame counter
0000261A                            
0000261A 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
0000261E                            
0000261E 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
00002622 4EB8 1DB8                  		jsr	ObjectManager.w			; Run the object manager
00002626                            
00002626                            	runObjects
00002626 3078 BE58                M 	movea.w	rtailnext.w,a0
0000262A 2250                     M 	move.l	oaddr(a0),a1
0000262C 4E91                     M 	jsr	(a1)
0000262E                            
0000262E 4A38 F8FC                  		tst.b	rLvlReload.w			; Does the level need to be reloaded?
00002632 6600 FE0C                  		bne.w	Level				; If so, branch
00002636                            
00002636 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
0000263A 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
0000263E 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
00002642                            
00002642 4EB8 1ABA                  		jsr	RenderObjects.w			; Render objects
00002646                            
00002646 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
0000264A 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
0000264E 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
00002652 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
00002656                            
00002656 5338 F3D8                  		subq.b	#1,rRingAniTime.w		; Decrement ring animation timer
0000265A 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
0000265C 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Reset animation timer
00002662 5238 F3D7                  		addq.b	#1,rRingFrame.w			; Next ring frame
00002666 0238 0007 F3D7             		andi.b	#7,rRingFrame.w			; Limit it
0000266C                            
0000266C 7000                       		moveq	#0,d0
0000266E 1038 F3D7                  		move.b	rRingFrame.w,d0			; Get ring frame
00002672 EF48                       		lsl.w	#7,d0				; Convert to offset
00002674 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
0000267A D280                       		add.l	d0,d1				; ''
0000267C 343C D780                  		move.w	#$D780,d2			; VRAM address
00002680 363C 0040                  		move.w	#$80/2,d3			; Size
00002684 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002688                            
00002688                            .NoRingAni:
00002688 4A38 F3D9                  		tst.b	rRLossAniT.w
0000268C 6700                       		beq.s	.NoRingLossAni
0000268E 7000                       		moveq	#0,d0
00002690 1038 F3D9                  		move.b	rRLossAniT.w,d0
00002694 D078 F3DA                  		add.w	rRLossAniA.w,d0
00002698 31C0 F3DA                  		move.w	d0,rRLossAniA.w
0000269C E158                       		rol.w	#8,d0
0000269E 0240 0007                  		andi.w	#7,d0
000026A2 11C0 F3DC                  		move.b	d0,rRLossAniF.w
000026A6 5338 F3D9                  		subq.b	#1,rRLossAniT.w
000026AA                            
000026AA 7000                       		moveq	#0,d0
000026AC 1038 F3DC                  		move.b	rRLossAniF.w,d0		; Get ring frame
000026B0 EF48                       		lsl.w	#7,d0				; Convert to offset
000026B2 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
000026B8 D280                       		add.l	d0,d1				; ''
000026BA 343C D680                  		move.w	#$D680,d2			; VRAM address
000026BE 363C 0040                  		move.w	#$80/2,d3			; Size
000026C2 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
000026C6                            
000026C6                            .NoRingLossAni:
000026C6 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000026CA                            
000026CA 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Is the game mode level?
000026D0 6700 FF32                  		beq.w	.Loop				; If so, branch
000026D4 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
000026D8                            
000026D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D8                            ; Check for pausing
000026D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D8                            CheckPause:
000026D8 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game already paused?
000026DC 6600                       		bne.s	.SetPause			; If so, branch
000026DE 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000026E4 6700                       		beq.s	.End				; If not, branch
000026E6                            
000026E6                            .SetPause:
000026E6 50F8 C75C                  		st	rPauseFlag.w			; Pause the game
000026EA                            		AMPS_MUSPAUSE				; Pause the music
000026EA 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
000026F0                            
000026F0                            .PauseLoop:
000026F0 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; General V-INT routine
000026F6 6100 FCA0                  		bsr.w	VSync_Routine			; V-SYNC
000026FA 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
00002700 67EE                       		beq.s	.PauseLoop			; If not, branch
00002702                            
00002702                            		AMPS_MUSUNPAUSE				; Unpause the music
00002702 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002708 4238 C75C                  		clr.b	rPauseFlag.w			; Unpause the game
0000270C                            
0000270C                            .End:
0000270C 4E75                       		rts
0000270E                            
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; Level functions
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            		include	"Opmodes/Gameplay/Level Drawing.asm"
0000270E                            ; =========================================================================================================================================================
0000270E                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
0000270E                            ; =========================================================================================================================================================
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; Initialize the planes
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; PARAMETERS:
0000270E                            ;	Nothing
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; RETURNS:
0000270E                            ;	Nothing
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            Level_InitPlanes:
0000270E 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002712 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
00002716 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
0000271A                            
0000271A 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002722 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002726                            		
00002726 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
0000272A E218                       		ror.b	#1,d0				; Turn into offset
0000272C E648                       		lsr.w	#3,d0				; ''
0000272E 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002734 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
0000273A 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
0000273E 4E90                       		jsr	(a0)				; Jump to it
00002740                            
00002740 31E9 0008 947E             		move.w	cYPos(a1),rVScrollFG.w		; Set the V-Scroll value for the foreground
00002746                            
00002746 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
0000274A 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
0000274E 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
00002752                            		
00002752 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
0000275A 337C 0080 0016             		move.w	#$80,cLayout(a1)		; Set the offset for the level layout (background)
00002760                            		
00002760 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002764 E218                       		ror.b	#1,d0				; Turn into offset
00002766 E648                       		lsr.w	#3,d0				; ''
00002768 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
0000276E 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002774 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002778 4E90                       		jsr	(a0)				; Jump to it
0000277A                            
0000277A 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
00002780 4E75                       		rts
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            ; Update the planes
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            Level_UpdatePlanes:
00002782 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002786 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
0000278A 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
0000278E                            		
0000278E 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002792 4E90                       		jsr	(a0)				; Jump to it
00002794                            		
00002794 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
00002798 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
0000279C 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000027A0                            
000027A0 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000027A4 4E90                       		jsr	(a0)				; Jump to it
000027A6                            
000027A6 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027AA 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
000027AE 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
000027B4 31EA 0008 947E             		move.w	cYPos(a2),rVScrollFG.w		; Set the V-Scroll value for the foreground
000027BA 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
000027BE 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
000027C4 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
000027CA                            
000027CA 4E75                       		rts
000027CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027CC                            ; General foreground initialization
000027CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027CC                            General_InitFG:
000027CC 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
000027D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027D0                            ; General background initialization
000027D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027D0                            General_InitBG:
000027D0 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027D4 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
000027D6 E240                       		asr.w	#1,d0				; Divide by 2
000027D8 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
000027DA 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
000027DE E240                       		asr.w	#1,d0				; Divide by 2
000027E0 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
000027E4                            
000027E4 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
000027E8                            		
000027E8 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
000027EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027EC                            ; General foreground update
000027EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027EC                            General_UpdateFG:
000027EC 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
000027F0                            		
000027F0 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
000027F2 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
000027F4 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
000027F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027F8                            ; General background update
000027F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027F8                            General_UpdateBG:
000027F8 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027FC 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
000027FE E240                       		asr.w	#1,d0				; Divide by 2
00002800 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002802 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002806 E240                       		asr.w	#1,d0				; Divide by 2
00002808 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000280C                            
0000280C 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002810 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002812 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002814 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002818                            		
00002818 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; Draw new tiles in the level
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; PARAMETERS:
0000281C                            ;	a1.l	- Camera RAM
0000281C                            ;	a2.l	- Plane buffer for columns
0000281C                            ;	a3.l	- Plane buffer for rows
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; RETURNS:
0000281C                            ;	Nothing
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            VInt_DrawLevel:
0000281C 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002820 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002824                            
00002824 3013                       		move.w	(a3),d0				; Get high VDP command word
00002826 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
0000282A 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
0000282C 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002830                            
00002830                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002830                            
00002830 3200                       		move.w	d0,d1				; Save high VDP command
00002832 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002834 7C00                       		moveq	#0,d6
00002836 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
0000283A 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000283C                            
0000283C 3C80                       		move.w	d0,(a6)				; Set VDP command
0000283E 3C84                       		move.w	d4,(a6)				; ''
00002840 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002842                            
00002842                            .DrawCol1_1_Loop:
00002842 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002844                            
00002844                            .DrawCol1_1_Start:
00002844 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002848                            
00002848 3403                       		move.w	d3,d2				; Wrap to the top of the plane
0000284A 0642 007C                  		addi.w	#$7C,d2				; ''
0000284E C042                       		and.w	d2,d0				; ''
00002850                            
00002850 3C80                       		move.w	d0,(a6)				; Set VDP command
00002852 3C84                       		move.w	d4,(a6)				; ''
00002854                            
00002854                            .DrawCol1_2_Loop:
00002854 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002856 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
0000285A                            
0000285A                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
0000285A                            
0000285A 5441                       		addq.w	#2,d1				; Move over to the right
0000285C 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
0000285E 7C00                       		moveq	#0,d6
00002860 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002864 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002866                            
00002866 3C81                       		move.w	d1,(a6)				; Set VDP command
00002868 3C84                       		move.w	d4,(a6)				; ''
0000286A 6000                       		bra.s	.DrawCol2_1_Start		; Start
0000286C                            
0000286C                            .DrawCol2_1_Loop:
0000286C 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
0000286E                            
0000286E                            .DrawCol2_1_Start:
0000286E 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
00002872                            
00002872 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002874 0642 007E                  		addi.w	#$7E,d2				; ''
00002878 C242                       		and.w	d2,d1				; ''
0000287A                            
0000287A 3C81                       		move.w	d1,(a6)				; Set VDP command
0000287C 3C84                       		move.w	d4,(a6)				; ''
0000287E                            
0000287E                            .DrawCol2_2_Loop:
0000287E 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002880 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
00002884                            
00002884 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
00002888 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
0000288A                            
0000288A                            VInt_DrawLvlRows:
0000288A 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
0000288E 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002892                            
00002892                            VInt_DrawLvlRows2:
00002892 3014                       		move.w	(a4),d0				; Get high VDP command
00002894 6700 0000                  		beq.w	.End				; If it's 0, branch
00002898 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
0000289A                            		
0000289A                            		; --- DRAW THE FIRST HALF OF THE ROW ---
0000289A                            
0000289A 3200                       		move.w	d0,d1				; Save high VDP command
0000289C 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
0000289E 7C00                       		moveq	#0,d6
000028A0 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000028A4 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000028A6                            
000028A6 3C80                       		move.w	d0,(a6)				; Set VDP command
000028A8 3C84                       		move.w	d4,(a6)				; ''
000028AA 6000                       		bra.s	.DrawRow1_1_Start		; Start
000028AC                            
000028AC                            .DrawRow1_1_Loop:
000028AC 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028AE                            
000028AE                            .DrawRow1_1_Start:
000028AE 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
000028B2                            
000028B2 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
000028B4 0642 0F00                  		addi.w	#$F00,d2			; ''
000028B8 C042                       		and.w	d2,d0				; ''
000028BA                            
000028BA 3C80                       		move.w	d0,(a6)				; Set VDP command
000028BC 3C84                       		move.w	d4,(a6)				; ''
000028BE                            
000028BE                            .DrawRow1_2_Loop:
000028BE 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028C0 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
000028C4                            
000028C4                            		; --- DRAW THE SECOND HALF OF THE ROW ---
000028C4                            
000028C4 0641 0080                  		addi.w	#$80,d1				; Move over down
000028C8 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
000028CA 7C00                       		moveq	#0,d6
000028CC 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000028D0 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000028D2                            
000028D2 3C81                       		move.w	d1,(a6)				; Set VDP command
000028D4 3C84                       		move.w	d4,(a6)				; ''
000028D6 6000                       		bra.s	.DrawRow2_1_Start		; Start
000028D8                            
000028D8                            .DrawRow2_1_Loop:
000028D8 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028DA                            
000028DA                            .DrawRow2_1_Start:
000028DA 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
000028DE                            
000028DE 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
000028E0 0642 0F80                  		addi.w	#$F80,d2			; ''
000028E4 C242                       		and.w	d2,d1				; ''
000028E6                            
000028E6 3C81                       		move.w	d1,(a6)				; Set VDP command
000028E8 3C84                       		move.w	d4,(a6)				; ''
000028EA                            
000028EA                            .DrawRow2_2_Loop:
000028EA 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028EC 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
000028F0                            
000028F0                            .End:
000028F0 4E75                       		rts
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; Handle plane drawing
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; PARAMETERS:
000028F2                            ;	d4.w	- Number of blocks per column
000028F2                            ;	d5.w	- Number of blocks per row
000028F2                            ;	a1.l	- Camera variables
000028F2                            ;	a2.l	- Layout pointer
000028F2                            ;	a3.l	- Column plane buffer
000028F2                            ;	a4.l	- Row plane buffer
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; RETURNS:
000028F2                            ;	Nothing
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            Level_UpdatePlane:
000028F2                            		push.l	d5/a4				; Push row plane buffer address
000028F2 48E7 0408                M 	movem.l	d5/a4,-(sp)
000028F6 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
000028F8                            		pop.l	d5/a4				; Restore row plane buffer address
000028F8 4CDF 1020                M 	movem.l	(sp)+,d5/a4
000028FC 3805                       		move.w	d5,d4				; Number of blocks per column
000028FE                            		; Continue to update the plane vertically
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; Handle plane drawing (vertical redrawing only)
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; PARAMETERS:
000028FE                            ;	d4.w	- Number of blocks per row
000028FE                            ;	a1.l	- Camera variables
000028FE                            ;	a4.l	- Row plane buffer
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; RETURNS:
000028FE                            ;	Nothing
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            Level_UpdatePlaneY:
000028FE 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002902 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002906 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
0000290A 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
0000290E                            		
0000290E 9240                       		sub.w	d0,d1				; Get distance travelled
00002910 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002912 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002914                            		
00002914                            .DrawUp:
00002914 3011                       		move.w	cXPos(a1),d0			; Get X
00002916 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
0000291A 6000 0000                  		bra.w	Level_GetRow			; Draw a row
0000291E                            
0000291E                            .DrawDown:
0000291E 3011                       		move.w	cXPos(a1),d0			; Get X
00002920 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002924 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002928 6000 0000                  		bra.w	Level_GetRow			; Draw a row
0000292C                            
0000292C                            .End:
0000292C 4E75                       		rts
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; Handle plane drawing (horizontal redrawing only)
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; PARAMETERS:
0000292E                            ;	d4.w	- Number of blocks per column
0000292E                            ;	a1.l	- Camera variables
0000292E                            ;	a3.l	- Column plane buffer
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; RETURNS:
0000292E                            ;	Nothing
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            Level_UpdatePlaneX:
0000292E 3011                       		move.w	cXPos(a1),d0			; Get X
00002930 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002934 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002938 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
0000293C                            		
0000293C 9240                       		sub.w	d0,d1				; Get distance travelled
0000293E 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002940 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002942                            		
00002942                            .DrawLeft:
00002942 3011                       		move.w	cXPos(a1),d0			; Get X
00002944 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002948 6000 0000                  		bra.w	Level_GetCol			; Draw a column
0000294C                            		
0000294C                            .DrawRight:
0000294C 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002950 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
00002954 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002958 6000 0000                  		bra.w	Level_GetCol			; Draw a column
0000295C                            
0000295C                            .End:
0000295C 4E75                       		rts
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Macro to calculate the high VDP command word for the plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	a1.l	- Camera variables
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	d2.w	- The high VDP command word
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            calcHiVDP	macro
0000295E                            		move.w	d0,d2				; Copy X
0000295E                            		move.w	d1,d3				; Copy Y
0000295E                            		lsl.w	#4,d3				; Multiply Y by $10
0000295E                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
0000295E                            		lsr.w	#2,d2				; Divide X by 4
0000295E                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
0000295E                            		add.w	d3,d2				; Add Y onto X
0000295E                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
0000295E                            		endm
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Macro to get an address in chunk data relative to a position
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	d1.l	- $FFFFXXXX
0000295E                            ;	a2.l	- Layout data
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	a6.l	- Pointer in chunk data to the correct block
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            getChunk	macro
0000295E                            		move.b	(a2,d0.w),d1			; Get chunk ID
0000295E                            		andi.w	#$FF,d1				; ''
0000295E                            		lsl.w	#7,d1				; Turn into offset
0000295E                            		movea.l	d1,a6				; Store into a6
0000295E                            		endm
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Get a block row and store it in a plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	d0.w	- X position
0000295E                            ;	d1.w	- Y position
0000295E                            ;	d4.w	- Number of blocks to draw (minus 1)
0000295E                            ;	a1.l	- Camera variables
0000295E                            ;	a4.l	- Row plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	Nothing
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            Level_GetRow:
0000295E 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002962 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002966 47F8 C7D0                  		lea	rBlocks.w,a3			; Get block table address
0000296A 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
0000296E                            
0000296E                            		calcHiVDP				; Get high VDP command word
0000296E 3400                     M 	move.w	d0,d2
00002970 3601                     M 	move.w	d1,d3
00002972 E94B                     M 	lsl.w	#4,d3
00002974 0243 0F00                M 	andi.w	#$f00,d3
00002978 E44A                     M 	lsr.w	#2,d2
0000297A 0242 007C                M 	andi.w	#$7c,d2
0000297E D443                     M 	add.w	d3,d2
00002980 8469 0012                M 	or.w	cvdp(a1),d2
00002984 38C2                       		move.w	d2,(a4)+			; Store it
00002986                            
00002986 3400                       		move.w	d0,d2				; Get X
00002988 E44A                       		lsr.w	#2,d2				; Divide X by 4
0000298A 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
0000298E 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002992 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
00002994 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
00002998 E44D                       		lsr.w	#2,d5				; Divide by 4
0000299A 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
0000299E                            		
0000299E E648                       		lsr.w	#3,d0				; Get X within chunk data
000029A0 3400                       		move.w	d0,d2				; ''
000029A2 0242 000E                  		andi.w	#$E,d2				; ''
000029A6 E848                       		lsr.w	#4,d0				; Get X within layout data
000029A8 0240 007F                  		andi.w	#$7F,d0				;''
000029AC 3601                       		move.w	d1,d3				; Get Y within chunk data
000029AE 0243 0070                  		andi.w	#$70,d3				; ''
000029B2 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
000029B4                            
000029B4 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029B8 D241                       		add.w	d1,d1				; ''
000029BA D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
000029BC                            
000029BC 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
000029BE                            		getChunk				; Get chunk pointer at current location
000029BE 1232 0000                M 	move.b	(a2,d0.w),d1
000029C2 0241 00FF                M 	andi.w	#$ff,d1
000029C6 EF49                     M 	lsl.w	#7,d1
000029C8 2C41                     M 	movea.l	d1,a6
000029CA                            
000029CA                            .DrawBlock_Loop:
000029CA 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
000029CE 3C05                       		move.w	d5,d6				; ''
000029D0 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
000029D4 E74D                       		lsl.w	#3,d5				; Get offset in block data
000029D6                            		
000029D6 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
000029DA 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
000029DE                            
000029DE 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
000029E2 6700                       		beq.s	.ChkYFlip			; If not, branch
000029E4 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
000029EA 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
000029F0 4847                       		swap	d7				; ''
000029F2 4845                       		swap	d5				; ''
000029F4                            
000029F4                            .ChkYFlip:
000029F4 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
000029F8 6700                       		beq.s	.DrawBlock			; If not, branch
000029FA 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A00 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A06 CF45                       		exg.l	d7,d5				; ''
00002A08                            
00002A08                            .DrawBlock:
00002A08 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002A0A 2AC5                       		move.l	d5,(a5)+			; ''
00002A0C                            
00002A0C 5442                       		addq.w	#2,d2				; Go to the next block
00002A0E 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002A12 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A14 5240                       		addq.w	#1,d0				; Next chunk
00002A16                            		getChunk				; ''
00002A16 1232 0000                M 	move.b	(a2,d0.w),d1
00002A1A 0241 00FF                M 	andi.w	#$ff,d1
00002A1E EF49                     M 	lsl.w	#7,d1
00002A20 2C41                     M 	movea.l	d1,a6
00002A22                            
00002A22                            .DrawBlock_Cont:
00002A22 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002A24 51CC FFA4                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A28                            
00002A28 4E75                       		rts
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; Get a block column and store it in a plane buffer
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; PARAMETERS:
00002A2A                            ;	d0.w	- X position
00002A2A                            ;	d1.w	- Y position
00002A2A                            ;	d4.w	- Number of blocks to draw (minus 1)
00002A2A                            ;	a1.l	- Camera RAM
00002A2A                            ;	a3.l	- Column plane buffer
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; RETURNS:
00002A2A                            ;	Nothing
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            Level_GetCol:
00002A2A 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002A2E D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002A32 49F8 C7D0                  		lea	rBlocks.w,a4			; Get block table address
00002A36 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002A3A                            		
00002A3A                            		calcHiVDP				; Get high VDP command word
00002A3A 3400                     M 	move.w	d0,d2
00002A3C 3601                     M 	move.w	d1,d3
00002A3E E94B                     M 	lsl.w	#4,d3
00002A40 0243 0F00                M 	andi.w	#$f00,d3
00002A44 E44A                     M 	lsr.w	#2,d2
00002A46 0242 007C                M 	andi.w	#$7c,d2
00002A4A D443                     M 	add.w	d3,d2
00002A4C 8469 0012                M 	or.w	cvdp(a1),d2
00002A50 36C2                       		move.w	d2,(a3)+			; Store it
00002A52                            
00002A52 3601                       		move.w	d1,d3				; Get Y
00002A54 E94B                       		lsl.w	#4,d3				; Multiply by $10
00002A56 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002A5A 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002A5E 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002A60 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002A64 E04D                       		lsr.w	#8,d5				; Divide by $100
00002A66 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002A6A                            
00002A6A E648                       		lsr.w	#3,d0				; Get X within chunk data
00002A6C 3400                       		move.w	d0,d2				; ''
00002A6E 0242 000E                  		andi.w	#$E,d2				; ''
00002A72 E848                       		lsr.w	#4,d0				; Get X within layout data
00002A74 0240 007F                  		andi.w	#$7F,d0				;''
00002A78 3601                       		move.w	d1,d3				; Get Y within chunk data
00002A7A 0243 0070                  		andi.w	#$70,d3				; ''
00002A7E D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002A80                            
00002A80 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002A84 D241                       		add.w	d1,d1				; ''
00002A86 D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
00002A88                            
00002A88 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002A8A                            		getChunk				; Get chunk pointer at current location
00002A8A 1232 0000                M 	move.b	(a2,d0.w),d1
00002A8E 0241 00FF                M 	andi.w	#$ff,d1
00002A92 EF49                     M 	lsl.w	#7,d1
00002A94 2C41                     M 	movea.l	d1,a6
00002A96                            
00002A96                            .DrawBlock_Loop:
00002A96 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002A9A 3C05                       		move.w	d5,d6				; ''
00002A9C 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002AA0 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002AA2                            		
00002AA2 3E05                       		move.w	d5,d7				; Get block tiles
00002AA4 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002AA8 3A07                       		move.w	d7,d5				; ''
00002AAA 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002AAE 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002AB2 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002AB6                            
00002AB6 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002ABA 6700                       		beq.s	.ChkYFlip			; If not, branch
00002ABC 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002AC2 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002AC8 CF45                       		exg.l	d7,d5				; ''
00002ACA                            
00002ACA                            .ChkYFlip:
00002ACA 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002ACE 6700                       		beq.s	.DrawBlock			; If not, branch
00002AD0 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002AD6 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002ADC 4847                       		swap	d7				; ''
00002ADE 4845                       		swap	d5				; ''
00002AE0                            
00002AE0                            .DrawBlock:
00002AE0 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002AE2 2AC5                       		move.l	d5,(a5)+			; ''
00002AE4                            
00002AE4 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002AE8 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002AEC 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002AEE 0640 0100                  		addi.w	#$100,d0			; Next chunk
00002AF2                            		getChunk				; ''
00002AF2 1232 0000                M 	move.b	(a2,d0.w),d1
00002AF6 0241 00FF                M 	andi.w	#$ff,d1
00002AFA EF49                     M 	lsl.w	#7,d1
00002AFC 2C41                     M 	movea.l	d1,a6
00002AFE                            
00002AFE                            .DrawBlock_Cont:
00002AFE D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002B00 51CC FF94                  		dbf	d4,.DrawBlock_Loop		; Loop
00002B04                            
00002B04 4E75                       		rts
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; Refresh a plane
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; PARAMETERS:
00002B06                            ;	a1.l	- Camera variables
00002B06                            ;	a4.l	- Row plane buffer
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; RETURNS:
00002B06                            ;	Nothing
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            Level_RefreshPlane:
00002B06 3011                       		move.w	cXPos(a1),d0			; Get X position
00002B08 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002B0C 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002B10 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002B14                            		
00002B14 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002B18 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002B1C 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002B20 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002B24                            		
00002B24 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002B26 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002B28                            		
00002B28                            		push.l	a4				; Save plane buffer address
00002B28 2F0C                     M 	move.l	a4,-(sp)
00002B2A                            		
00002B2A                            .DrawRows:
00002B2A                            		push.w	d0/d1/d4/d6			; Save registers
00002B2A 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002B2E 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B32 6100 FE2A                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002B36 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B3A 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002B40 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002B44 6100 FD44                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002B48                            		pop.w	d0/d1/d4/d6			; Restore registers
00002B48 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002B4C                            		
00002B4C 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002B50 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002B54                            		
00002B54                            		pop.l	a4				; Restore a3
00002B54 285F                     M 	move.l	(sp)+,a4
00002B56 4E75                       		rts
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; Check if the plane needs to be redrawn
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; PARAMETERS:
00002B58                            ;	a1.l	- Camera RAM
00002B58                            ;	a3.l	- Row plane buffer
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; RETURNS:
00002B58                            ;	Nothing
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            Level_ChkRedrawPlane:
00002B58 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002B5C                            		; Comment out the following line to disable blast processing :^)
00002B5C 6700                       		beq.s	.End				; If not, branch
00002B5E 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002B62 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002B64                            
00002B64                            .End:
00002B64 4E75                       		rts
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; Scroll sections macro
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollInit	macro	label
00002B66                            SCROLL_LABEL	equs	"\label"
00002B66                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollEnd	macro
00002B66                            \SCROLL_LABEL\_End:					; End label
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollSection	macro
00002B66                            	if narg<3
00002B66                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002B66                            	else
00002B66                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002B66                            	endif
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; Do section scrolling
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; PARAMERERS:
00002B66                            ;	a1.l	- Background camera RAM
00002B66                            ;	a3.l	- Scroll section data
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; RETURNS:
00002B66                            ;	Nothing
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ScrollSections:
00002B66 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing variables
00002B6A 49F8 EFD0                  		lea	rScrlSecs.w,a4		; Deformation offset buffer
00002B6E 4BF8 90FE                  		lea	rHScroll.w,a5			; Horizontal scroll buffer
00002B72                            
00002B72 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002B74                            
00002B74 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002B76 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002B7A 48C4                       		ext.l	d4				; ''
00002B7C E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002B7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B7E                            		; Update each section offset
00002B7E                            		push.w	d0/a4				; Save registers
00002B7E 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002B82                            
00002B82                            .ScrollSects:
00002B82 361B                       		move.w	(a3)+,d3			; Get section speed
00002B84 48C3                       		ext.l	d3				; ''
00002B86                            
00002B86 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002B88 6A00                       		bpl.s	.NotAuto			; If not, branch
00002B8A 3C04                       		move.w	d4,d6				; Get camera speed
00002B8C CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002B8E E183                       		asl.l	#8,d3				; Shift section speed
00002B90 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002B92 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002B94                            
00002B94                            .NotAuto:
00002B94 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002B96                            
00002B96                            .ApplySpeed:
00002B96 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002B98 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002B9A 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002B9E                            
00002B9E                            		pop.w	d0/a4				; Restore registers
00002B9E 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002BA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BA2                            		; Set the scroll offsets on screen
00002BA2 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002BA6 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002BAA                            		
00002BAA                            .FindStart:
00002BAA 221C                       		move.l	(a4)+,d1			; Get section offset
00002BAC 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002BAE 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002BB0 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002BB4 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002BB6 4441                       		neg.w	d1				; Make it scroll the right direction
00002BB8 4841                       		swap	d1				; Fix which planes the scroll values go to
00002BBA 4441                       		neg.w	d1				; Make the background scroll the right direction
00002BBC 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002BBE                            
00002BBE                            .FoundStart:
00002BBE 4446                       		neg.w	d6				; Get remaining size of the section
00002BC0 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002BC2 4441                       		neg.w	d1				; Make it scroll the right direction
00002BC4 4841                       		swap	d1				; Fix which planes the scroll values go to
00002BC6 4441                       		neg.w	d1				; Make the background scroll the right direction
00002BC8 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002BCA                            
00002BCA                            .NextSection:
00002BCA 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002BCC 4441                       		neg.w	d1				; Make the section scroll the correct way
00002BCE 2C1C                       		move.l	(a4)+,d6			; Get section size
00002BD0                            		
00002BD0                            .CheckScroll:
00002BD0 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002BD2 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002BD4 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002BD6                            
00002BD6                            .Scroll:
00002BD6 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002BD8 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002BDC 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002BE0 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002BE2                            		
00002BE2                            .EndSection:
00002BE2 DA46                       		add.w	d6,d5				; Get remaining screen space
00002BE4                            		
00002BE4                            .LastSection:
00002BE4 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002BE6 6B00                       		bmi.s	.End				; If there are none, exit
00002BE8                            
00002BE8                            .FillScroll:
00002BE8 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002BEA 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002BEE                            
00002BEE                            .End:
00002BEE 4E75                       		rts
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; Static background scrolling (no parallax)
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; PARAMERERS:
00002BF0                            ;	a1.l	- Background camera RAM
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; RETURNS:
00002BF0                            ;	Nothing
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ScrollStaticBG:
00002BF0 45F8 F880                  		lea	rFGCam.w,a2		; Get foreground level drawing variables
00002BF4 4BF8 90FE                  		lea	rHScroll.w,a5		; Horizontal scroll buffer
00002BF8                            		
00002BF8 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002BFA 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002BFC 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002BFE 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002C00                            
00002C00 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002C04                            
00002C04                            .Scroll:
00002C04 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002C06 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002C0A 4E75                       		rts
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            ; Generate fake layer art
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            ; PARAMETERS:
00002C0C                            ;	a0.l	- Layer art data pointer
00002C0C                            ;	a1.l	- Layer tile ID mappings pointer
00002C0C                            ;	d0.w	- Layer offset
00002C0C                            ;	d1.l	- Buffer pointer
00002C0C                            ;	d2.w	- VRAM destination address
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            Level_UpdateLayer:
00002C0C                            		; Prepare for transfer
00002C0C 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002C0E 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002C10                            		
00002C10                            		; Queue a DMA transfer for later
00002C10                            		push.l	d0/d3/a1			; Save registers
00002C10 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002C14 5243                       		addq.w	#1,d3				; Get size of transfer
00002C16 E94B                       		lsl.w	#4,d3				; ''
00002C18 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002C1C                            		pop.l	d0/d3/a1			; Restore registers
00002C1C 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002C20                            
00002C20                            		; Copy the tiles for the layer
00002C20 D040                       		add.w	d0,d0				; Double it
00002C22 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002C26                            		
00002C26                            .CopyTiles:
00002C26 3219                       		move.w	(a1)+,d1			; Get tile offset
00002C28 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002C2C 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002C2E 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C30 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C32 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C34 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C36 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C38 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C3A 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C3C 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002C40                            
00002C40                            .End
00002C40 4E75                       		rts
00002C42                            ; =========================================================================================================================================================
00002C42                            		include	"Opmodes/Gameplay/Level Collision.asm"
00002C42                            ; =========================================================================================================================================================
00002C42                            ; Level collision functions
00002C42                            ; =========================================================================================================================================================
00002C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C42                            ; Check if a player object has touched any level collision
00002C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C42                            PlayerChkCollision:
00002C42 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002C48 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002C4E 6700                       		beq.s	.NotPrimary			; If not, branch
00002C50 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002C56                            
00002C56                            .NotPrimary:
00002C56 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002C5A                            		
00002C5A 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002C5E 3428 001E                  		move.w	oYVel(a0),d2			; Get Y velocity
00002C62 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
00002C66 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002C6A 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002C6E 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002C72 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002C76 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002C7A 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002C7E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002C82 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002C86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C86                            PlayerHitFloorAndWalls:
00002C86 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C8A 4A41                       		tst.w	d1				; Have we hit the wall?
00002C8C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002C8E 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C92 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C96                            
00002C96                            .NoLeftHit:
00002C96 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002C9A 4A41                       		tst.w	d1				; Have we hit the wall?
00002C9C 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002C9E D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CA2 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CA6                            
00002CA6                            .NoRightHit:
00002CA6 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002CAA 4A41                       		tst.w	d1				; Have we hit the floor?
00002CAC 6A00                       		bpl.s	.End				; If not, branch
00002CAE                            
00002CAE 1428 001E                  		move.b	oYVel(a0),d2			; Get the integer part of the Y velocity
00002CB2 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002CB4 4402                       		neg.b	d2				; Negate it since we are in the floor
00002CB6 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002CB8 6C00                       		bge.s	.TouchFloor			; If so, branch
00002CBA B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002CBC 6D00                       		blt.s	.End				; If not, branch
00002CBE                            
00002CBE                            .TouchFloor:
00002CBE 1143 0000                  		move.b	d3,oAngle(a0)			; Set the angle
00002CC2 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the floor
00002CC6 1003                       		move.b	d3,d0				; Copy angle
00002CC8 0600 0020                  		addi.b	#$20,d0				; Shift it
00002CCC 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002CD0 6600                       		bne.s	.HitWall			; If so, branch
00002CD2 1003                       		move.b	d3,d0				; Copy angle
00002CD4 0600 0010                  		addi.b	#$10,d0				; Shift it
00002CD8 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002CDC 6700                       		beq.s	.HitFloor			; If not, branch
00002CDE E0E8 001E                  		asr	oYVel(a0)			; Divide the Y velocity by 2
00002CE2 6000                       		bra.s	.HitSlope			; Continue
00002CE4                            
00002CE4                            .HitFloor:
00002CE4 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CE8 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002CEE 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002CF2                            
00002CF2                            .HitWall:
00002CF2 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
00002CF6 0C68 0FC0 001E             		cmpi.w	#$FC0,oYVel(a0)			; Cap the Y velocity at $FC0
00002CFC 6F00                       		ble.s	.HitSlope			; ''
00002CFE 317C 0FC0 001E             		move.w	#$FC0,oYVel(a0)			; ''
00002D04                            
00002D04                            .HitSlope:
00002D04 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D08 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D0E 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D10 6A00                       		bpl.s	.End				; If so, branch
00002D12 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002D16                            
00002D16                            .End:
00002D16 4E75                       		rts
00002D18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D18                            PlayerHitLWall:
00002D18 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D1C 4A41                       		tst.w	d1				; Have we hit the wall?
00002D1E 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D20 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002D24 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D28 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D2E                            
00002D2E                            .ChkCeil:
00002D2E 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D32 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D34 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D36 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002D38 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002D3C 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002D3E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D42 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D46 6A00                       		bpl.s	.End				; If not, branch
00002D48 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D4C                            
00002D4C                            .End:
00002D4C 4E75                       		rts
00002D4E                            
00002D4E                            .ChkRightWall:
00002D4E 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D52 4A41                       		tst.w	d1				; Have we hit the wall?
00002D54 6A00                       		bpl.s	.End2				; If not, branch
00002D56 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D5A 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D5E                            		
00002D5E                            .End2:
00002D5E 4E75                       		rts
00002D60                            
00002D60                            .ChkFloor:
00002D60 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D64 6B00                       		bmi.s	.End3				; If so, branch
00002D66 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D6A 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D6C 6A00                       		bpl.s	.End3				; If not, branch
00002D6E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D72 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D76 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D7A 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002D80 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002D84                            		
00002D84                            .End3:
00002D84 4E75                       		rts
00002D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D86                            PlayerHitCeilAndWalls:
00002D86 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D8A 4A41                       		tst.w	d1				; Have we hit the wall?
00002D8C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002D8E 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002D92 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D96                            
00002D96                            .NoLeftHit:
00002D96 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D9A 4A41                       		tst.w	d1				; Have we hit the wall?
00002D9C 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002D9E D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002DA2 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002DA6                            
00002DA6                            .NoRightHit:
00002DA6 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002DAA 4A41                       		tst.w	d1				; Have we hit the floor?
00002DAC 6A00                       		bpl.s	.End				; If not, branch
00002DAE 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of ceiling
00002DB2 1003                       		move.b	d3,d0				; Get angle
00002DB4 0600 0020                  		addi.b	#$20,d0				; Shift it
00002DB8 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002DBC 6600                       		bne.s	.HitWall			; If so, branch
00002DBE 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002DC2 4E75                       		rts
00002DC4                            
00002DC4                            .HitWall:
00002DC4 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002DC8 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002DCC 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002DD2 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002DD4 6A00                       		bpl.s	.End				; If so, branch
00002DD6 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002DDA                            
00002DDA                            .End:
00002DDA 4E75                       		rts
00002DDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DDC                            PlayerHitRWall:
00002DDC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002DE0 4A41                       		tst.w	d1				; Have we hit the wall?
00002DE2 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002DE4 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002DE8 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002DEC 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002DF2                            
00002DF2                            .ChkCeil:
00002DF2 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002DF6 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002DF8 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002DFA 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of the ceiling
00002DFE 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002E02 6A00                       		bpl.s	.End				; If not, branch
00002E04 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002E08                            
00002E08                            .End:
00002E08 4E75                       		rts
00002E0A                            
00002E0A                            .ChkFloor:
00002E0A 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002E0E 6B00                       		bmi.s	.End2				; If so, branch
00002E10 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002E14 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002E16 6A00                       		bpl.s	.End2				; If not, branch
00002E18 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002E1C 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002E20 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002E24 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002E2A 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002E2C                            		
00002E2C                            .End2:
00002E2C 4E75                       		rts
00002E2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E2E                            ; Reset a player object's status on the floor
00002E2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E2E                            PlayerResetOnFloor:
00002E2E 4A28 0000                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00002E32 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002E34 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002E38                            		
00002E38                            PlayerResetOnFloorPart2:
00002E38 0828 0002 0028             		btst	#2,oStatus(a0)			; Was Sonic rolling?
00002E3E 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002E40 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
00002E46 1168 0000 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00002E4C 1168 0000 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00002E52 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002E56 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align with floor
00002E5A                            
00002E5A                            PlayerResetOnFloorPart3:
00002E5A 0228 00DD 0028             		andi.b	#$DD,oStatus(a0)		; Clear "pushing", and "jumping" flag
00002E60 4228 0000                  		clr.b	oJumping(a0)			; Clear jumping flag
00002E64 4228 0000                  		clr.b	oFlipAngle(a0)			; Reset flip angle
00002E68 4228 0000                  		clr.b	oFlipTurned(a0)			; Reset flip inverted flag
00002E6C 4228 0000                  		clr.b	oFlipRemain(a0)			; Reset flips remaining
00002E70 4E75                       		rts
00002E72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E72                            ; Calculate the room in front of a player object
00002E72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E72                            PlayerCalcRoomInFront:
00002E72 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E78 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E7E 6700                       		beq.s	.NotPrimary			; If not, branch
00002E80 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E86                            
00002E86                            .NotPrimary:
00002E86 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E8A                            		
00002E8A 2628 0014                  		move.l	oXPos(a0),d3			; Get X position
00002E8E 2428 0018                  		move.l	oYPos(a0),d2			; Get Y position
00002E92 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002E96 48C1                       		ext.l	d1				; ''
00002E98 E181                       		asl.l	#8,d1				; Shift it
00002E9A D681                       		add.l	d1,d3				; Add onto X position
00002E9C 3228 001E                  		move.w	oYVel(a0),d1			; Get Y velocity
00002EA0 48C1                       		ext.l	d1				; ''
00002EA2 E181                       		asl.l	#8,d1				; Shift it
00002EA4 D481                       		add.l	d1,d2				; Add onto Y position
00002EA6 4842                       		swap	d2				; Get actual Y
00002EA8 4843                       		swap	d3				; Get actual X
00002EAA 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002EAE 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002EB2 1200                       		move.b	d0,d1				; Copy angle
00002EB4 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002EB8 6700                       		beq.s	.DownUp				; If not, branch
00002EBA 5200                       		addq.b	#1,d0				; Shift the angle
00002EBC                            
00002EBC                            .DownUp:
00002EBC 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002EC0 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002EC4 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002EC8 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002ECC 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002ED0 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002ED4 6600                       		bne.s	.ChkWall			; If not, branch
00002ED6 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002ED8                            
00002ED8                            .ChkWall:
00002ED8 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002EDC 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002EE0 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE4                            ; Calculate the room over a player object
00002EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE4                            PlayerCalcRoomOverHead:
00002EE4 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002EEA 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002EF0 6700                       		beq.s	.NotPrimary			; If not, branch
00002EF2 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002EF8                            
00002EF8                            .NotPrimary:
00002EF8 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002EFC 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002F00 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002F04                            		
00002F04 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002F08 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002F0C 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002F10 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002F14 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002F18 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002F1C 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002F20 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F24                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F24                            PlayerChkFloor:
00002F24 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F2A 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002F30 6700                       		beq.s	.NotPrimary			; If not, branch
00002F32 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F38                            
00002F38                            .NotPrimary:
00002F38 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00002F3C                            		
00002F3C                            		; Get the angle on the bottom right sensor
00002F3C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F40 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F44 7000                       		moveq	#0,d0
00002F46 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F4A 4880                       		ext.w	d0				; ''
00002F4C D440                       		add.w	d0,d2				; Add onto Y position
00002F4E 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002F52 4880                       		ext.w	d0				; ''
00002F54 D640                       		add.w	d0,d3				; Add onto X position
00002F56 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002F5A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F5E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002F60 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F64                            		push.w	d1				; Save the primary floor distance
00002F64 3F01                     M 	move.w	d1,-(sp)
00002F66                            
00002F66                            		; Get the angle on the bottom left sensor
00002F66 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F6A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F6E 7000                       		moveq	#0,d0
00002F70 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F74 4880                       		ext.w	d0				; ''
00002F76 D440                       		add.w	d0,d2				; Add onto Y position
00002F78 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002F7C 4880                       		ext.w	d0				; ''
00002F7E 9640                       		sub.w	d0,d3				; Subtract from X position
00002F80 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00002F84 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F88 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002F8A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F8E                            		
00002F8E                            		; Update the object's angle
00002F8E                            		pop.w	d0				; Restore the primary floor distance
00002F8E 301F                     M 	move.w	(sp)+,d0
00002F90 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F92                            PlayerPickAngle:
00002F92 1628 002F                  		move.b	oTilt(a0),d3			; Get secondary angle
00002F96 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002F98 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002F9A 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F9E C141                       		exg.l	d0,d1				; Switch floor distance values
00002FA0                            		
00002FA0                            .ChkSetAngle:
00002FA0 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002FA4 6700                       		beq.s	.End				; If not, branch
00002FA6 1602                       		move.b	d2,d3				; Set the new angle value
00002FA8                            		
00002FA8                            .End:
00002FA8 4E75                       		rts
00002FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAA                            ; Get the distance between the floor and the player object
00002FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAA                            PlayerChkFloorDist:
00002FAA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FAE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FB2                            
00002FB2                            PlayerChkFloorDist_Part2:
00002FB2 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00002FB6 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FBA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FBE 4246                       		clr.w	d6				; No flip bits
00002FC0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FC4 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002FC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC6                            PlayerGetPrimaryAngle:
00002FC6 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FCA 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002FCE 6700                       		beq.s	.End				; If not, branch
00002FD0 1602                       		move.b	d2,d3				; Set the new angle value
00002FD2                            		
00002FD2                            .End:
00002FD2 4E75                       		rts
00002FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD4                            sub_F846:
00002FD4 3628 0014                  		move.w	oXPos(a0),d3
00002FD8 3428 0018                  		move.w	oYPos(a0),d2
00002FDC 5942                       		subq.w	#4,d2
00002FDE 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002FE4 0C28 000D 0000             		cmpi.b	#$D,oLRBSolid(a0)		; Are we on the primary path?
00002FEA 6700                       		beq.s	.NotPrimary			; If not, branch
00002FEC 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002FF2                            
00002FF2                            .NotPrimary:
00002FF2 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FF6 4214                       		clr.b	(a4)				; Clear it
00002FF8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FFC 4246                       		clr.w	d6				; No flip bits
00002FFE 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Solidity bits
00003002 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003006 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
0000300A 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000300E 6700                       		beq.s	.End				; If not, branch
00003010 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003012                            
00003012                            .End:
00003012 4E75                       		rts
00003014                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003014                            ; Check for the edge of a floor
00003014                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003014                            PlayerChkFloorEdge:
00003014 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003018                            
00003018                            PlayerChkFloorEdge_Part2:
00003018 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000301C 7000                       		moveq	#0,d0
0000301E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003022 4880                       		ext.w	d0				; ''
00003024 D440                       		add.w	d0,d2				; Add onto Y position
00003026                            
00003026                            PlayerChkFloorEdge_Part3:
00003026 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
0000302C 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00003032 6700                       		beq.s	.NotPrimary			; If not, branch
00003034 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
0000303A                            
0000303A                            .NotPrimary:
0000303A 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000303E 4214                       		clr.b	(a4)				; Clear it
00003040 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003044 4246                       		clr.w	d6				; No flip bits
00003046 1A28 0000                  		move.b	oTopSolid(a0),d5		; Solidity bits
0000304A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000304E 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003052 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003056 6700                       		beq.s	.End				; If not, branch
00003058 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000305A                            
0000305A                            .End:
0000305A 4E75                       		rts
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ; Get the distance between the floor and an object
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ObjCheckFloorDist:
0000305C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003060                            		
00003060                            ObjCheckFloorDist_Part2:
00003060 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003064                            
00003064                            ObjCheckFloorDist_Part3:
00003064 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003068 4880                       		ext.w	d0				; ''
0000306A D440                       		add.w	d0,d2				; Add onto Y position
0000306C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003070 4214                       		clr.b	(a4)				; Clear it
00003072 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003076 4246                       		clr.w	d6				; No flip bits
00003078 7A0C                       		moveq	#$C,d5				; Solidity bits
0000307A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000307E 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003082 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003086 6700                       		beq.s	.End				; If not, branch
00003088 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000308A                            
0000308A                            .End:
0000308A 4E75                       		rts
0000308C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000308C                            ; Get the distance between a right ceiling and a player object
0000308C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000308C                            PlayerChkRightCeilDist:
0000308C                            		; Get the angle on the bottom right (rotated) sensor
0000308C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003090 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003094 7000                       		moveq	#0,d0
00003096 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
0000309A 4880                       		ext.w	d0				; ''
0000309C 9440                       		sub.w	d0,d2				; Subtract from Y position
0000309E 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
000030A2 4880                       		ext.w	d0				; ''
000030A4 D640                       		add.w	d0,d3				; Add onto X position
000030A6 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000030AA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030AE 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000030B0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000030B4                            		push.w	d1				; Save the primary floor distance
000030B4 3F01                     M 	move.w	d1,-(sp)
000030B6                            
000030B6                            		; Get the angle on the bottom left (rotated) sensor
000030B6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030BA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030BE 7000                       		moveq	#0,d0
000030C0 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
000030C4 4880                       		ext.w	d0				; ''
000030C6 D440                       		add.w	d0,d2				; Add onto Y position
000030C8 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
000030CC 4880                       		ext.w	d0				; ''
000030CE D640                       		add.w	d0,d3				; Add onto X position
000030D0 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000030D4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030D8 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000030DA 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000030DE                            
000030DE                            		; Update the object's angle
000030DE                            		pop.w	d0				; Restore the primary floor distance
000030DE 301F                     M 	move.w	(sp)+,d0
000030E0 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
000030E4 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
000030E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E8                            ; Get the distance between a right wall and a player object
000030E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E8                            PlayerChkRightWallDist:
000030E8 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030EC 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030F0                            
000030F0                            PlayerChkRightWallDist_Part2:
000030F0 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
000030F4 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000030F8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030FC 4246                       		clr.w	d6				; No flip bits
000030FE 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003102 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003106 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000310A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000310A                            ; Get the distance between a right wall and an object
0000310A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000310A                            ObjCheckRightWallDist:
0000310A D668 0014                  		add.w	oXPos(a0),d3			; Add X position
0000310E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003112 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003116 4214                       		clr.b	(a4)				; Clear it
00003118 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000311C 4246                       		clr.w	d6				; No flip bits
0000311E 7A0D                       		moveq	#$D,d5				; Solidity bits
00003120 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003124 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003128 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000312C 6700                       		beq.s	.End				; If not, branch
0000312E 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
00003132                            
00003132                            .End:
00003132 4E75                       		rts
00003134                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003134                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
00003134                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003134                            PlayerChkCeiling:
00003134                            		; Get the angle on the bottom right sensor
00003134 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003138 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000313C 7000                       		moveq	#0,d0
0000313E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003142 4880                       		ext.w	d0				; ''
00003144 9440                       		sub.w	d0,d2				; Subtract from Y position
00003146 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000314A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000314E 4880                       		ext.w	d0				; ''
00003150 D640                       		add.w	d0,d3				; Add onto X position
00003152 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003156 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000315A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000315E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003162                            		push.w	d1				; Save the primary floor distance
00003162 3F01                     M 	move.w	d1,-(sp)
00003164                            
00003164                            		; Get the angle on the bottom left sensor
00003164 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003168 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000316C 7000                       		moveq	#0,d0
0000316E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003172 4880                       		ext.w	d0				; ''
00003174 9440                       		sub.w	d0,d2				; Subtract from Y position
00003176 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000317A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000317E 4880                       		ext.w	d0				; ''
00003180 9640                       		sub.w	d0,d3				; Subtract from X position
00003182 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003186 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000318A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000318E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003192                            		
00003192                            		; Update the object's angle
00003192                            		pop.w	d0				; Restore the primary floor distance
00003192 301F                     M 	move.w	(sp)+,d0
00003194 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003198 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
0000319C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000319C                            ; Get the distance between a ceiling and a player object
0000319C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000319C                            PlayerChkCeilingDist:
0000319C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031A0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031A4                            
000031A4                            PlayerChkCeilingDist_Part2:
000031A4 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
000031A8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031AC 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031B0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031B4 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031B8 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000031BC 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031C0 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000031C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031C4                            ; Get the distance between a ceiling and an object
000031C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031C4                            ObjCheckCeilingDist:
000031C4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031C8 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031CC 7000                       		moveq	#0,d0
000031CE 1028 002D                  		move.b	oColH(a0),d0		; Get collision height
000031D2 4880                       		ext.w	d0				; ''
000031D4 9440                       		sub.w	d0,d2				; Subtract it from Y position
000031D6 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031DA 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031DE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031E2 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031E6 7A0D                       		moveq	#$D,d5				; Solidity bits
000031E8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031EC 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
000031F0 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000031F4 6700                       		beq.s	.End				; If not, branch
000031F6 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
000031FA                            
000031FA                            .End:
000031FA 4E75                       		rts
000031FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031FC                            ; Get the distance between a left ceiling and a player object
000031FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031FC                            PlayerChkLeftCeilDist:
000031FC                            		; Get the angle on the bottom right (rotated) sensor
000031FC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003200 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003204 7000                       		moveq	#0,d0
00003206 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000320A 4880                       		ext.w	d0				; ''
0000320C 9440                       		sub.w	d0,d2				; Subtract from Y position
0000320E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003212 4880                       		ext.w	d0				; ''
00003214 9640                       		sub.w	d0,d3				; Subtract from X position
00003216 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000321A 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
0000321E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003222 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003226 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000322A                            		push.w	d1				; Save the primary floor distance
0000322A 3F01                     M 	move.w	d1,-(sp)
0000322C                            
0000322C                            		; Get the angle on the bottom left (rotated) sensor
0000322C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003230 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003234 7000                       		moveq	#0,d0
00003236 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000323A 4880                       		ext.w	d0				; ''
0000323C D440                       		add.w	d0,d2				; Add onto Y position
0000323E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003242 4880                       		ext.w	d0				; ''
00003244 9640                       		sub.w	d0,d3				; Subtract from X position
00003246 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000324A 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000324E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003252 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003256 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000325A                            
0000325A                            		; Update the object's angle
0000325A                            		pop.w	d0				; Restore the primary floor distance
0000325A 301F                     M 	move.w	(sp)+,d0
0000325C 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003260 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
00003264                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003264                            ; Get the distance between a left wall and a player object
00003264                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003264                            PlayerChkLeftWallDist:
00003264 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003268 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000326C                            
0000326C                            PlayerChkLeftWallDist_Part2:
0000326C 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
00003270 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003274 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003278 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000327C 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003280 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003284 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003288 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000328C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328C                            ; Get the distance between a left wall and an object
0000328C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328C                            ObjCheckLeftWallDist:
0000328C D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003290 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003294 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003298 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000329C 4214                       		clr.b	(a4)				; Clear it
0000329E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000032A2 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000032A6 7A0D                       		moveq	#$D,d5				; Solidity bits
000032A8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000032AC 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
000032B0 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000032B4 6700                       		beq.s	.End				; If not, branch
000032B6 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
000032BA                            
000032BA                            .End:
000032BA 4E75                       		rts
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            ; Move a player object along on the ground
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            PlayerAnglePos:
000032BC 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
000032C2 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
000032C8 6700                       		beq.s	.NotPrimary			; If not, branch
000032CA 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
000032D0                            
000032D0                            .NotPrimary:
000032D0 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
000032D4 0828 0003 0028             		btst	#3,oStatus(a0)			; Are we standing on a player object?
000032DA 6700                       		beq.s	.NotOnObj			; If not, branch
000032DC 4268 002E                  		clr.w	oNextTilt(a0)			; Set the angles to 0
000032E0 4E75                       		rts
000032E2                            
000032E2                            .NotOnObj:
000032E2 317C 0303 002E             		move.w	#$0303,oNextTilt(a0)		; Set the angles to 3
000032E8                            		
000032E8                            		; Get which quadrant the object is in on the ground
000032E8                            		; This makes it so that angles:
000032E8                            		; 	$E0-$20 = Quadrant 0 (floor)
000032E8                            		;	$1F-$5F = Quadrant $40 (left wall)
000032E8                            		;	$60-$A0 = Quadrant $80 (ceiling)
000032E8                            		;	$A1-$DF = Quadrant $C0 (right wall)
000032E8 1028 0000                  		move.b	oAngle(a0),d0			; Get the angle
000032EC 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
000032F0 6700                       		beq.s	.DownUp				; If not, branch
000032F2 5200                       		addq.b	#1,d0				; Shift the angle
000032F4                            
000032F4                            .DownUp:
000032F4 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
000032F8 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
000032FC 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003300 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
00003304 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
00003308 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
0000330C 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003310 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            ; Move the object along the floor
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            PlayerMoveFloor:
00003314                            		; Get the angle on the bottom right sensor
00003314 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003318 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000331C 7000                       		moveq	#0,d0
0000331E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003322 4880                       		ext.w	d0				; ''
00003324 D440                       		add.w	d0,d2				; Add onto Y position
00003326 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000332A 4880                       		ext.w	d0				; ''
0000332C D640                       		add.w	d0,d3				; Add onto X position
0000332E 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003332 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003336 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003338 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000333C                            		push.w	d1				; Save the primary floor distance
0000333C 3F01                     M 	move.w	d1,-(sp)
0000333E                            
0000333E                            		; Get the angle on the bottom left sensor
0000333E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003342 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003346 7000                       		moveq	#0,d0
00003348 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000334C 4880                       		ext.w	d0				; ''
0000334E D440                       		add.w	d0,d2				; Add onto Y position
00003350 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003354 4880                       		ext.w	d0				; ''
00003356 9640                       		sub.w	d0,d3				; Add onto X position
00003358 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000335C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003360 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003362 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003366                            		
00003366                            		; Update the object's angle
00003366                            		pop.w	d0				; Restore the primary floor distance
00003366 301F                     M 	move.w	(sp)+,d0
00003368 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
0000336C                            		
0000336C                            		; Check if the object has hit a wall or is about to fall
0000336C 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
0000336E 6700                       		beq.s	.End				; If so, branch
00003370 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003372 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003376 6D00                       		blt.s	.End				; If so, branch
00003378 D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
0000337C                            
0000337C                            .End:
0000337C 4E75                       		rts
0000337E                            
0000337E                            .ChkFall:
0000337E 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003382 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003384 4400                       		neg.b	d0				; Force it to be positive
00003386                            
00003386                            .GetMinDist:
00003386 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003388 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000338C 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000338E 103C 000E                  		move.b	#$E,d0				; ''
00003392                            
00003392                            .ChkDist:
00003392 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003394 6E00                       		bgt.s	.SetAir				; If so, branch
00003396 D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
0000339A 4E75                       		rts
0000339C                            
0000339C                            .SetAir:
0000339C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000033A2 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000033A8 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000033AE 4E75                       		rts
000033B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B0                            ; Set the objects's angle
000033B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B0                            PlayerSetAngle:
000033B0 1428 002F                  		move.b	oTilt(a0),d2			; Get secondary angle
000033B4 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
000033B6 6F00                       		ble.s	.ChkSetAngle			; If not, branch
000033B8 1428 002E                  		move.b	oNextTilt(a0),d2		; Get primary angle
000033BC 3200                       		move.w	d0,d1				; Get primary floor distance
000033BE                            		
000033BE                            .ChkSetAngle:
000033BE 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
000033C2 6600                       		bne.s	.LatchOnFlat			; If so, branch
000033C4 1002                       		move.b	d2,d0				; Get angle change
000033C6 9028 0000                  		sub.b	oAngle(a0),d0			; ''
000033CA 6A00                       		bpl.s	.ChkDist			; ''
000033CC 4400                       		neg.b	d0				; ''
000033CE                            
000033CE                            .ChkDist:
000033CE 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
000033D2 6400                       		bhs.s	.LatchOnFlat			; If so, branch
000033D4 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
000033D8 4E75                       		rts
000033DA                            
000033DA                            .LatchOnFlat:
000033DA 1428 0000                  		move.b	oAngle(a0),d2			; Get old angle value
000033DE 0602 0020                  		addi.b	#$20,d2				; Shift the angle
000033E2 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
000033E6 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
000033EA 4E75                       		rts
000033EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EC                            ; Move the object along the right wall
000033EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EC                            PlayerMoveRWall:
000033EC                            		; Get the angle on the bottom right (rotated) sensor
000033EC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000033F0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000033F4 7000                       		moveq	#0,d0
000033F6 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000033FA 4880                       		ext.w	d0				; ''
000033FC 9440                       		sub.w	d0,d2				; Add onto Y position
000033FE 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003402 4880                       		ext.w	d0				; ''
00003404 D640                       		add.w	d0,d3				; Add onto X position
00003406 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
0000340A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000340E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003410 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003414                            		push.w	d1				; Save the primary floor distance
00003414 3F01                     M 	move.w	d1,-(sp)
00003416                            
00003416                            		; Get the angle on the bottom left (rotated) sensor
00003416 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000341A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000341E 7000                       		moveq	#0,d0
00003420 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003424 4880                       		ext.w	d0				; ''
00003426 D440                       		add.w	d0,d2				; Add onto Y position
00003428 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000342C 4880                       		ext.w	d0				; ''
0000342E D640                       		add.w	d0,d3				; Add onto X position
00003430 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003434 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003438 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000343A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000343E                            		
0000343E                            		; Update the object's angle
0000343E                            		pop.w	d0				; Restore the primary floor distance
0000343E 301F                     M 	move.w	(sp)+,d0
00003440 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003444                            
00003444                            		; Check if the object has hit a wall or is about to fall
00003444 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003446 6700                       		beq.s	.End				; If so, branch
00003448 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000344A 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000344E 6D00                       		blt.s	.End				; If so, branch
00003450 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
00003454                            
00003454                            .End:
00003454 4E75                       		rts
00003456                            
00003456                            .ChkFall:
00003456 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
0000345A 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000345C 4400                       		neg.b	d0				; Force it to be positive
0000345E                            
0000345E                            .GetMinDist:
0000345E 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003460 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003464 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003466 103C 000E                  		move.b	#$E,d0				; ''
0000346A                            
0000346A                            .ChkDist:
0000346A B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000346C 6E00                       		bgt.s	.SetAir				; If so, branch
0000346E D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
00003472 4E75                       		rts
00003474                            
00003474                            .SetAir:
00003474 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000347A 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003480 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003486 4E75                       		rts
00003488                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003488                            ; Move the object along the ceiling
00003488                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003488                            PlayerMoveCeiling:
00003488                            		; Get the angle on the bottom right (rotated) sensor
00003488 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000348C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003490 7000                       		moveq	#0,d0
00003492 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003496 4880                       		ext.w	d0				; ''
00003498 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000349A 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000349E 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034A2 4880                       		ext.w	d0				; ''
000034A4 D640                       		add.w	d0,d3				; Add onto X position
000034A6 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000034AA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034AE 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000034B2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034B6                            		push.w	d1				; Save the primary floor distance
000034B6 3F01                     M 	move.w	d1,-(sp)
000034B8                            
000034B8                            		; Get the angle on the bottom left (rotated) sensor
000034B8 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034BC 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034C0 7000                       		moveq	#0,d0
000034C2 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034C6 4880                       		ext.w	d0				; ''
000034C8 9440                       		sub.w	d0,d2				; Subtract from the Y position
000034CA 0A42 000F                  		eori.w	#$F,d2				; Flip it
000034CE 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034D2 4880                       		ext.w	d0				; ''
000034D4 9640                       		sub.w	d0,d3				; Subtract from the X position
000034D6 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000034DA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034DE 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000034E2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034E6                            		
000034E6                            		; Update the object's angle
000034E6                            		pop.w	d0				; Restore the primary floor distance
000034E6 301F                     M 	move.w	(sp)+,d0
000034E8 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
000034EC                            		
000034EC                            		; Check if the object has hit a wall or is about to fall
000034EC 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000034EE 6700                       		beq.s	.End				; If so, branch
000034F0 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000034F2 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000034F6 6D00                       		blt.s	.End				; If so, branch
000034F8 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
000034FC                            
000034FC                            .End:
000034FC 4E75                       		rts
000034FE                            
000034FE                            .ChkFall:
000034FE 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003502 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003504 4400                       		neg.b	d0				; Force it to be positive
00003506                            
00003506                            .GetMinDist:
00003506 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003508 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000350C 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000350E 103C 000E                  		move.b	#$E,d0				; ''
00003512                            
00003512                            .ChkDist:
00003512 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003514 6E00                       		bgt.s	.SetAir				; If so, branch
00003516 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
0000351A 4E75                       		rts
0000351C                            
0000351C                            .SetAir:
0000351C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003522 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003528 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000352E 4E75                       		rts
00003530                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003530                            ; Move the object along the left wall
00003530                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003530                            PlayerMoveLWall:
00003530                            		; Get the angle on the bottom right (rotated) sensor
00003530 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003534 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003538 7000                       		moveq	#0,d0
0000353A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000353E 4880                       		ext.w	d0				; ''
00003540 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003542 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003546 4880                       		ext.w	d0				; ''
00003548 9640                       		sub.w	d0,d3				; Subtract from X position
0000354A 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000354E 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003552 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003556 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000355A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000355E                            		push.w	d1				; Save the primary floor distance
0000355E 3F01                     M 	move.w	d1,-(sp)
00003560                            
00003560                            		; Get the angle on the bottom left (rotated) sensor
00003560 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003564 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003568 7000                       		moveq	#0,d0
0000356A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000356E 4880                       		ext.w	d0				; ''
00003570 D440                       		add.w	d0,d2				; Add onto Y position
00003572 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003576 4880                       		ext.w	d0				; ''
00003578 9640                       		sub.w	d0,d3				; Subtract from X position
0000357A 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000357E 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003582 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003586 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000358A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000358E                            		
0000358E                            		; Update the object's angle
0000358E                            		pop.w	d0				; Restore the primary floor distance
0000358E 301F                     M 	move.w	(sp)+,d0
00003590 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003594                            		
00003594                            		; Check if the object has hit a wall or is about to fall
00003594 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003596 6700                       		beq.s	.End				; If so, branch
00003598 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000359A 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000359E 6D00                       		blt.s	.End				; If so, branch
000035A0 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
000035A4                            
000035A4                            .End:
000035A4 4E75                       		rts
000035A6                            
000035A6                            .ChkFall:
000035A6 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000035AA 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000035AC 4400                       		neg.b	d0				; Force it to be positive
000035AE                            
000035AE                            .GetMinDist:
000035AE 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000035B0 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000035B4 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000035B6 103C 000E                  		move.b	#$E,d0				; ''
000035BA                            
000035BA                            .ChkDist:
000035BA B200                       		cmp.b	d0,d1				; Are we about to fall off?
000035BC 6E00                       		bgt.s	.SetAir				; If so, branch
000035BE 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
000035C2 4E75                       		rts
000035C4                            
000035C4                            .SetAir:
000035C4 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000035CA 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000035D0 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000035D6 4E75                       		rts
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; Find the nearest floor from the object's position
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; PARAMETERS:
000035D8                            ;	d2.w	- Y position of the object's bottom sensor
000035D8                            ;	d3.w	- X position of the object's bottom sensor
000035D8                            ;	d5.w	- Bit to chect for solidity
000035D8                            ;	d6.w	- Flip bits (for walls and ceilings)
000035D8                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
000035D8                            ;	a4.w	- Pointer to where the angle value will be stored
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; RETURNS:
000035D8                            ;	d1.w	- The distance from the object to the floor
000035D8                            ;	(a1).w	- The block ID in the chunk where the object is standing
000035D8                            ;	(a4).w	- The floor angle
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            Level_FindFloor:
000035D8 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000035DC 3011                       		move.w	(a1),d0				; Get block ID
000035DE 3800                       		move.w	d0,d4				; Copy that
000035E0 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000035E4 6700                       		beq.s	.IsBlank			; If it's blank, branch
000035E6 0B04                       		btst	d5,d4				; Is the block solid?
000035E8 6600                       		bne.s	.IsSolid			; If so, branch
000035EA                            
000035EA                            .IsBlank:
000035EA D44B                       		add.w	a3,d2				; Check below the sensor
000035EC 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
000035F0 944B                       		sub.w	a3,d2				; Restore Y position of sensor
000035F2 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
000035F6 4E75                       		rts
000035F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035F8                            .IsSolid:
000035F8 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000035FC D040                       		add.w	d0,d0				; Turn ID into offset
000035FE 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003602 0240 00FF                  		andi.w	#$FF,d0				; ''
00003606 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003608                            
00003608 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
0000360C 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003610 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003612                            
00003612 3203                       		move.w	d3,d1				; Get the object's X position
00003614 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003618 6700                       		beq.s	.NoXFlip			; If not, branch
0000361A 4641                       		not.w	d1				; Flip the X position
0000361C 4414                       		neg.b	(a4)				; Flip the angle
0000361E                            		
0000361E                            .NoXFlip:
0000361E 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003622 6700                       		beq.s	.NoYFlip			; If not, branch
00003624 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003628 4414                       		neg.b	(a4)				; ''
0000362A 0414 0040                  		subi.b	#$40,(a4)			; ''
0000362E                            
0000362E                            .NoYFlip:
0000362E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003632 D240                       		add.w	d0,d1				; Add the collision block's offset
00003634                            
00003634 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
00003638 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000363C 4880                       		ext.w	d0				; ''
0000363E BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003640 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003644 6700                       		beq.s	.NoYFlip2			; If not, branch
00003646 4440                       		neg.w	d0				; Flip the height
00003648                            
00003648                            .NoYFlip2:
00003648 4A40                       		tst.w	d0				; Check the height
0000364A 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000364C 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000364E 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003652 6700                       		beq.s	.MaxFloor			; If so, branch
00003654 3202                       		move.w	d2,d1				; Get the object's Y position
00003656 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000365A D041                       		add.w	d1,d0				; Add onto the height
0000365C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003660 9240                       		sub.w	d0,d1				; ''
00003662 4E75                       		rts
00003664                            
00003664                            .NegHeight:
00003664 3202                       		move.w	d2,d1				; Get the object's Y position
00003666 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000366A D041                       		add.w	d1,d0				; Add onto the height
0000366C 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003670                            
00003670                            .MaxFloor:
00003670 944B                       		sub.w	a3,d2				; Check above the sensor
00003672 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
00003674 D44B                       		add.w	a3,d2				; Restore Y position of sensor
00003676 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
0000367A 4E75                       		rts
0000367C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000367C                            Level_FindFloor2:
0000367C 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003680 3011                       		move.w	(a1),d0				; Get block ID
00003682 3800                       		move.w	d0,d4				; Copy that
00003684 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003688 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000368A 0B04                       		btst	d5,d4				; Is the block solid?
0000368C 6600                       		bne.s	.IsSolid			; If so, branch
0000368E                            
0000368E                            .IsBlank:
0000368E 323C 000F                  		move.w	#$F,d1				; Get max distance
00003692 3002                       		move.w	d2,d0				; Get the object's Y position
00003694 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
00003698 9240                       		sub.w	d0,d1				; Get actual distance
0000369A 4E75                       		rts
0000369C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000369C                            .IsSolid:
0000369C 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000036A0 D040                       		add.w	d0,d0				; Turn ID into offset
000036A2 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000036A6 0240 00FF                  		andi.w	#$FF,d0				; ''
000036AA 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000036AC                            
000036AC 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000036B0 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000036B4 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000036B6                            
000036B6 3203                       		move.w	d3,d1				; Get the object's X position
000036B8 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000036BC 6700                       		beq.s	.NoXFlip			; If not, branch
000036BE 4641                       		not.w	d1				; Flip the X position
000036C0 4414                       		neg.b	(a4)				; Flip the angle
000036C2                            
000036C2                            .NoXFlip:
000036C2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036C6 6700                       		beq.s	.NoYFlip			; If not, branch
000036C8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000036CC 4414                       		neg.b	(a4)				; ''
000036CE 0414 0040                  		subi.b	#$40,(a4)			; ''
000036D2                            
000036D2                            .NoYFlip:
000036D2 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000036D6 D240                       		add.w	d0,d1				; Add the collision block's offset
000036D8                            
000036D8 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
000036DC 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000036E0 4880                       		ext.w	d0				; ''
000036E2 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000036E4 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036E8 6700                       		beq.s	.NoYFlip2			; If not, branch
000036EA 4440                       		neg.w	d0				; Flip the height
000036EC                            
000036EC                            .NoYFlip2:
000036EC 4A40                       		tst.w	d0				; Check the height
000036EE 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036F0 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036F2 3202                       		move.w	d2,d1				; Get the object's Y position
000036F4 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000036F8 D041                       		add.w	d1,d0				; Add onto the height
000036FA 323C 000F                  		move.w	#$F,d1				; Get actual distance
000036FE 9240                       		sub.w	d0,d1				; ''
00003700 4E75                       		rts
00003702                            
00003702                            .NegHeight:
00003702 3202                       		move.w	d2,d1				; Get the object's Y position
00003704 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003708 D041                       		add.w	d1,d0				; Add onto the height
0000370A 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
0000370E 4641                       		not.w	d1				; Flip the height
00003710 4E75                       		rts
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; Find the nearest wall from the object's position
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; PARAMETERS:
00003712                            ;	d2.w	- Y position of the object's bottom sensor
00003712                            ;	d3.w	- X position of the object's bottom sensor
00003712                            ;	d5.w	- Bit to chect for solidity
00003712                            ;	d6.w	- Flip bits (for walls and ceilings)
00003712                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003712                            ;	a4.w	- Pointer to where the angle value will be stored
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; RETURNS:
00003712                            ;	d1.w	- The distance from the object to the floor
00003712                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003712                            ;	(a4).w	- The floor angle
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            Level_FindWall:
00003712 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003716 3011                       		move.w	(a1),d0				; Get block ID
00003718 3800                       		move.w	d0,d4				; Copy that
0000371A 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000371E 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003720 0B04                       		btst	d5,d4				; Is the block solid?
00003722 6600                       		bne.s	.IsSolid			; If so, branch
00003724                            
00003724                            .IsBlank:
00003724 D64B                       		add.w	a3,d3				; Check right to the sensor
00003726 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
0000372A 964B                       		sub.w	a3,d3				; Restore X position of sensor
0000372C 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003730 4E75                       		rts
00003732                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003732                            .IsSolid:
00003732 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003736 D040                       		add.w	d0,d0				; Turn ID into offset
00003738 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000373C 0240 00FF                  		andi.w	#$FF,d0				; ''
00003740 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003742                            
00003742 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003746 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000374A E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000374C                            
0000374C 3202                       		move.w	d2,d1				; Get the object's Y position
0000374E 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003752 6700                       		beq.s	.NoYFlip			; If not, branch
00003754 4641                       		not.w	d1				; Flip the Y position
00003756 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000375A 4414                       		neg.b	(a4)				; ''
0000375C 0414 0040                  		subi.b	#$40,(a4)			; ''
00003760                            
00003760                            .NoYFlip:
00003760 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003764 6700                       		beq.s	.NoXFlip			; If not, branch
00003766 4414                       		neg.b	(a4)				; Flip the angle
00003768                            
00003768                            .NoXFlip:
00003768 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000376C D240                       		add.w	d0,d1				; Add the collision block's offset
0000376E                            
0000376E 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
00003772 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003776 4880                       		ext.w	d0				; ''
00003778 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000377A 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
0000377E 6700                       		beq.s	.NoYFlip2			; If not, branch
00003780 4440                       		neg.w	d0				; Flip the height
00003782                            
00003782                            .NoYFlip2:
00003782 4A40                       		tst.w	d0				; Check the height
00003784 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003786 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003788 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
0000378C 6700                       		beq.s	.MaxFloor			; If so, branch
0000378E 3203                       		move.w	d3,d1				; Get the object's X position
00003790 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003794 D041                       		add.w	d1,d0				; Add onto the height
00003796 323C 000F                  		move.w	#$F,d1				; Get actual distance
0000379A 9240                       		sub.w	d0,d1				; ''
0000379C 4E75                       		rts
0000379E                            
0000379E                            .NegHeight:
0000379E 3203                       		move.w	d3,d1				; Get the object's X position
000037A0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037A4 D041                       		add.w	d1,d0				; Add onto the height
000037A6 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000037AA                            
000037AA                            .MaxFloor:
000037AA 964B                       		sub.w	a3,d3				; Check left to the sensor
000037AC 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
000037AE D64B                       		add.w	a3,d3				; Restore X position of sensor
000037B0 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000037B4 4E75                       		rts
000037B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B6                            Level_FindWall2:
000037B6 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000037BA 3011                       		move.w	(a1),d0				; Get block ID
000037BC 3800                       		move.w	d0,d4				; Copy that
000037BE 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000037C2 6700                       		beq.s	.IsBlank			; If it's blank, branch
000037C4 0B04                       		btst	d5,d4				; Is the block solid?
000037C6 6600                       		bne.s	.IsSolid			; If so, branch
000037C8                            
000037C8                            .IsBlank:
000037C8 323C 000F                  		move.w	#$F,d1				; Get max distance
000037CC 3003                       		move.w	d3,d0				; Get the object's X position
000037CE 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
000037D2 9240                       		sub.w	d0,d1				; Get actual distance
000037D4 4E75                       		rts
000037D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037D6                            .IsSolid:
000037D6 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000037DA D040                       		add.w	d0,d0				; Turn ID into offset
000037DC 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000037E0 0240 00FF                  		andi.w	#$FF,d0				; ''
000037E4 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000037E6                            
000037E6 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000037EA 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000037EE E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000037F0                            
000037F0 3202                       		move.w	d2,d1				; Get the object's Y position
000037F2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000037F6 6700                       		beq.s	.NoYFlip			; If not, branch
000037F8 4641                       		not.w	d1				; Flip the Y position
000037FA 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000037FE 4414                       		neg.b	(a4)				; ''
00003800 0414 0040                  		subi.b	#$40,(a4)			; ''
00003804                            
00003804                            .NoYFlip:
00003804 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003808 6700                       		beq.s	.NoXFlip			; If not, branch
0000380A 4414                       		neg.b	(a4)				; Flip the angle
0000380C                            
0000380C                            .NoXFlip:
0000380C 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003810 D240                       		add.w	d0,d1				; Add the collision block's offset
00003812                            
00003812 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
00003816 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000381A 4880                       		ext.w	d0				; ''
0000381C BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000381E 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003822 6700                       		beq.s	.NoYFlip2			; If not, branch
00003824 4440                       		neg.w	d0				; Flip the height
00003826                            
00003826                            .NoYFlip2:
00003826 4A40                       		tst.w	d0				; Check the height
00003828 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000382A 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000382C 3203                       		move.w	d3,d1				; Get the object's X position
0000382E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003832 D041                       		add.w	d1,d0				; Add onto the height
00003834 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003838 9240                       		sub.w	d0,d1				; ''
0000383A 4E75                       		rts
0000383C                            
0000383C                            .NegHeight:
0000383C 3203                       		move.w	d3,d1				; Get the object's X position
0000383E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003842 D041                       		add.w	d1,d0				; Add onto the height
00003844 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003848 4641                       		not.w	d1				; Flip the height
0000384A 4E75                       		rts
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; Find the nearest block in the level from the player
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; PARAMETERS:
0000384C                            ;	d2.w	- Y position of the object's sensor
0000384C                            ;	d3.w	- X position of the object's sensor
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; RETURNS:
0000384C                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            Level_FindBlock:
0000384C 3002                       		move.w	d2,d0				; Get the object's Y position
0000384E D040                       		add.w	d0,d0				; Double it
00003850 0240 0F00                  		andi.w	#$F00,d0			; Get chunk row offset
00003854 3203                       		move.w	d3,d1				; Get the object's X position
00003856 E649                       		lsr.w	#3,d1				; Divide by 8
00003858 3801                       		move.w	d1,d4				; Save for later
0000385A E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
0000385C 0241 007F                  		andi.w	#$7F,d1				; Only 128 chunks per row
00003860 D041                       		add.w	d1,d0				; Get offset in the level layout
00003862 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
00003864 4241                       		clr.w	d1				; ''
00003866 43F8 DFD0                  		lea	rLayout.w,a1			; Get layout pointer
0000386A 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
0000386E D241                       		add.w	d1,d1				; Turn into offset
00003870 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
00003874 3002                       		move.w	d2,d0				; Get the object's Y position
00003876 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
0000387A D240                       		add.w	d0,d1				; Add onto the offset
0000387C 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
00003880 D244                       		add.w	d4,d1				; Add onto the offset
00003882 2241                       		movea.l	d1,a1				; Get pointer in chunk table
00003884 4E75                       		rts
00003886                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003886                            .ChunkOffsets:
00003886 =00000000                  c		= 0
00003886                            		rept	256
00003886                            			dc.w	c
00003886                            c			= c+$80
00003886                            		endr
00003886 0000                     M 	dc.w	c
00003888 =00000080                M c	=	c+$80
00003888 0080                     M 	dc.w	c
0000388A =00000100                M c	=	c+$80
0000388A 0100                     M 	dc.w	c
0000388C =00000180                M c	=	c+$80
0000388C 0180                     M 	dc.w	c
0000388E =00000200                M c	=	c+$80
0000388E 0200                     M 	dc.w	c
00003890 =00000280                M c	=	c+$80
00003890 0280                     M 	dc.w	c
00003892 =00000300                M c	=	c+$80
00003892 0300                     M 	dc.w	c
00003894 =00000380                M c	=	c+$80
00003894 0380                     M 	dc.w	c
00003896 =00000400                M c	=	c+$80
00003896 0400                     M 	dc.w	c
00003898 =00000480                M c	=	c+$80
00003898 0480                     M 	dc.w	c
0000389A =00000500                M c	=	c+$80
0000389A 0500                     M 	dc.w	c
0000389C =00000580                M c	=	c+$80
0000389C 0580                     M 	dc.w	c
0000389E =00000600                M c	=	c+$80
0000389E 0600                     M 	dc.w	c
000038A0 =00000680                M c	=	c+$80
000038A0 0680                     M 	dc.w	c
000038A2 =00000700                M c	=	c+$80
000038A2 0700                     M 	dc.w	c
000038A4 =00000780                M c	=	c+$80
000038A4 0780                     M 	dc.w	c
000038A6 =00000800                M c	=	c+$80
000038A6 0800                     M 	dc.w	c
000038A8 =00000880                M c	=	c+$80
000038A8 0880                     M 	dc.w	c
000038AA =00000900                M c	=	c+$80
000038AA 0900                     M 	dc.w	c
000038AC =00000980                M c	=	c+$80
000038AC 0980                     M 	dc.w	c
000038AE =00000A00                M c	=	c+$80
000038AE 0A00                     M 	dc.w	c
000038B0 =00000A80                M c	=	c+$80
000038B0 0A80                     M 	dc.w	c
000038B2 =00000B00                M c	=	c+$80
000038B2 0B00                     M 	dc.w	c
000038B4 =00000B80                M c	=	c+$80
000038B4 0B80                     M 	dc.w	c
000038B6 =00000C00                M c	=	c+$80
000038B6 0C00                     M 	dc.w	c
000038B8 =00000C80                M c	=	c+$80
000038B8 0C80                     M 	dc.w	c
000038BA =00000D00                M c	=	c+$80
000038BA 0D00                     M 	dc.w	c
000038BC =00000D80                M c	=	c+$80
000038BC 0D80                     M 	dc.w	c
000038BE =00000E00                M c	=	c+$80
000038BE 0E00                     M 	dc.w	c
000038C0 =00000E80                M c	=	c+$80
000038C0 0E80                     M 	dc.w	c
000038C2 =00000F00                M c	=	c+$80
000038C2 0F00                     M 	dc.w	c
000038C4 =00000F80                M c	=	c+$80
000038C4 0F80                     M 	dc.w	c
000038C6 =00001000                M c	=	c+$80
000038C6 1000                     M 	dc.w	c
000038C8 =00001080                M c	=	c+$80
000038C8 1080                     M 	dc.w	c
000038CA =00001100                M c	=	c+$80
000038CA 1100                     M 	dc.w	c
000038CC =00001180                M c	=	c+$80
000038CC 1180                     M 	dc.w	c
000038CE =00001200                M c	=	c+$80
000038CE 1200                     M 	dc.w	c
000038D0 =00001280                M c	=	c+$80
000038D0 1280                     M 	dc.w	c
000038D2 =00001300                M c	=	c+$80
000038D2 1300                     M 	dc.w	c
000038D4 =00001380                M c	=	c+$80
000038D4 1380                     M 	dc.w	c
000038D6 =00001400                M c	=	c+$80
000038D6 1400                     M 	dc.w	c
000038D8 =00001480                M c	=	c+$80
000038D8 1480                     M 	dc.w	c
000038DA =00001500                M c	=	c+$80
000038DA 1500                     M 	dc.w	c
000038DC =00001580                M c	=	c+$80
000038DC 1580                     M 	dc.w	c
000038DE =00001600                M c	=	c+$80
000038DE 1600                     M 	dc.w	c
000038E0 =00001680                M c	=	c+$80
000038E0 1680                     M 	dc.w	c
000038E2 =00001700                M c	=	c+$80
000038E2 1700                     M 	dc.w	c
000038E4 =00001780                M c	=	c+$80
000038E4 1780                     M 	dc.w	c
000038E6 =00001800                M c	=	c+$80
000038E6 1800                     M 	dc.w	c
000038E8 =00001880                M c	=	c+$80
000038E8 1880                     M 	dc.w	c
000038EA =00001900                M c	=	c+$80
000038EA 1900                     M 	dc.w	c
000038EC =00001980                M c	=	c+$80
000038EC 1980                     M 	dc.w	c
000038EE =00001A00                M c	=	c+$80
000038EE 1A00                     M 	dc.w	c
000038F0 =00001A80                M c	=	c+$80
000038F0 1A80                     M 	dc.w	c
000038F2 =00001B00                M c	=	c+$80
000038F2 1B00                     M 	dc.w	c
000038F4 =00001B80                M c	=	c+$80
000038F4 1B80                     M 	dc.w	c
000038F6 =00001C00                M c	=	c+$80
000038F6 1C00                     M 	dc.w	c
000038F8 =00001C80                M c	=	c+$80
000038F8 1C80                     M 	dc.w	c
000038FA =00001D00                M c	=	c+$80
000038FA 1D00                     M 	dc.w	c
000038FC =00001D80                M c	=	c+$80
000038FC 1D80                     M 	dc.w	c
000038FE =00001E00                M c	=	c+$80
000038FE 1E00                     M 	dc.w	c
00003900 =00001E80                M c	=	c+$80
00003900 1E80                     M 	dc.w	c
00003902 =00001F00                M c	=	c+$80
00003902 1F00                     M 	dc.w	c
00003904 =00001F80                M c	=	c+$80
00003904 1F80                     M 	dc.w	c
00003906 =00002000                M c	=	c+$80
00003906 2000                     M 	dc.w	c
00003908 =00002080                M c	=	c+$80
00003908 2080                     M 	dc.w	c
0000390A =00002100                M c	=	c+$80
0000390A 2100                     M 	dc.w	c
0000390C =00002180                M c	=	c+$80
0000390C 2180                     M 	dc.w	c
0000390E =00002200                M c	=	c+$80
0000390E 2200                     M 	dc.w	c
00003910 =00002280                M c	=	c+$80
00003910 2280                     M 	dc.w	c
00003912 =00002300                M c	=	c+$80
00003912 2300                     M 	dc.w	c
00003914 =00002380                M c	=	c+$80
00003914 2380                     M 	dc.w	c
00003916 =00002400                M c	=	c+$80
00003916 2400                     M 	dc.w	c
00003918 =00002480                M c	=	c+$80
00003918 2480                     M 	dc.w	c
0000391A =00002500                M c	=	c+$80
0000391A 2500                     M 	dc.w	c
0000391C =00002580                M c	=	c+$80
0000391C 2580                     M 	dc.w	c
0000391E =00002600                M c	=	c+$80
0000391E 2600                     M 	dc.w	c
00003920 =00002680                M c	=	c+$80
00003920 2680                     M 	dc.w	c
00003922 =00002700                M c	=	c+$80
00003922 2700                     M 	dc.w	c
00003924 =00002780                M c	=	c+$80
00003924 2780                     M 	dc.w	c
00003926 =00002800                M c	=	c+$80
00003926 2800                     M 	dc.w	c
00003928 =00002880                M c	=	c+$80
00003928 2880                     M 	dc.w	c
0000392A =00002900                M c	=	c+$80
0000392A 2900                     M 	dc.w	c
0000392C =00002980                M c	=	c+$80
0000392C 2980                     M 	dc.w	c
0000392E =00002A00                M c	=	c+$80
0000392E 2A00                     M 	dc.w	c
00003930 =00002A80                M c	=	c+$80
00003930 2A80                     M 	dc.w	c
00003932 =00002B00                M c	=	c+$80
00003932 2B00                     M 	dc.w	c
00003934 =00002B80                M c	=	c+$80
00003934 2B80                     M 	dc.w	c
00003936 =00002C00                M c	=	c+$80
00003936 2C00                     M 	dc.w	c
00003938 =00002C80                M c	=	c+$80
00003938 2C80                     M 	dc.w	c
0000393A =00002D00                M c	=	c+$80
0000393A 2D00                     M 	dc.w	c
0000393C =00002D80                M c	=	c+$80
0000393C 2D80                     M 	dc.w	c
0000393E =00002E00                M c	=	c+$80
0000393E 2E00                     M 	dc.w	c
00003940 =00002E80                M c	=	c+$80
00003940 2E80                     M 	dc.w	c
00003942 =00002F00                M c	=	c+$80
00003942 2F00                     M 	dc.w	c
00003944 =00002F80                M c	=	c+$80
00003944 2F80                     M 	dc.w	c
00003946 =00003000                M c	=	c+$80
00003946 3000                     M 	dc.w	c
00003948 =00003080                M c	=	c+$80
00003948 3080                     M 	dc.w	c
0000394A =00003100                M c	=	c+$80
0000394A 3100                     M 	dc.w	c
0000394C =00003180                M c	=	c+$80
0000394C 3180                     M 	dc.w	c
0000394E =00003200                M c	=	c+$80
0000394E 3200                     M 	dc.w	c
00003950 =00003280                M c	=	c+$80
00003950 3280                     M 	dc.w	c
00003952 =00003300                M c	=	c+$80
00003952 3300                     M 	dc.w	c
00003954 =00003380                M c	=	c+$80
00003954 3380                     M 	dc.w	c
00003956 =00003400                M c	=	c+$80
00003956 3400                     M 	dc.w	c
00003958 =00003480                M c	=	c+$80
00003958 3480                     M 	dc.w	c
0000395A =00003500                M c	=	c+$80
0000395A 3500                     M 	dc.w	c
0000395C =00003580                M c	=	c+$80
0000395C 3580                     M 	dc.w	c
0000395E =00003600                M c	=	c+$80
0000395E 3600                     M 	dc.w	c
00003960 =00003680                M c	=	c+$80
00003960 3680                     M 	dc.w	c
00003962 =00003700                M c	=	c+$80
00003962 3700                     M 	dc.w	c
00003964 =00003780                M c	=	c+$80
00003964 3780                     M 	dc.w	c
00003966 =00003800                M c	=	c+$80
00003966 3800                     M 	dc.w	c
00003968 =00003880                M c	=	c+$80
00003968 3880                     M 	dc.w	c
0000396A =00003900                M c	=	c+$80
0000396A 3900                     M 	dc.w	c
0000396C =00003980                M c	=	c+$80
0000396C 3980                     M 	dc.w	c
0000396E =00003A00                M c	=	c+$80
0000396E 3A00                     M 	dc.w	c
00003970 =00003A80                M c	=	c+$80
00003970 3A80                     M 	dc.w	c
00003972 =00003B00                M c	=	c+$80
00003972 3B00                     M 	dc.w	c
00003974 =00003B80                M c	=	c+$80
00003974 3B80                     M 	dc.w	c
00003976 =00003C00                M c	=	c+$80
00003976 3C00                     M 	dc.w	c
00003978 =00003C80                M c	=	c+$80
00003978 3C80                     M 	dc.w	c
0000397A =00003D00                M c	=	c+$80
0000397A 3D00                     M 	dc.w	c
0000397C =00003D80                M c	=	c+$80
0000397C 3D80                     M 	dc.w	c
0000397E =00003E00                M c	=	c+$80
0000397E 3E00                     M 	dc.w	c
00003980 =00003E80                M c	=	c+$80
00003980 3E80                     M 	dc.w	c
00003982 =00003F00                M c	=	c+$80
00003982 3F00                     M 	dc.w	c
00003984 =00003F80                M c	=	c+$80
00003984 3F80                     M 	dc.w	c
00003986 =00004000                M c	=	c+$80
00003986 4000                     M 	dc.w	c
00003988 =00004080                M c	=	c+$80
00003988 4080                     M 	dc.w	c
0000398A =00004100                M c	=	c+$80
0000398A 4100                     M 	dc.w	c
0000398C =00004180                M c	=	c+$80
0000398C 4180                     M 	dc.w	c
0000398E =00004200                M c	=	c+$80
0000398E 4200                     M 	dc.w	c
00003990 =00004280                M c	=	c+$80
00003990 4280                     M 	dc.w	c
00003992 =00004300                M c	=	c+$80
00003992 4300                     M 	dc.w	c
00003994 =00004380                M c	=	c+$80
00003994 4380                     M 	dc.w	c
00003996 =00004400                M c	=	c+$80
00003996 4400                     M 	dc.w	c
00003998 =00004480                M c	=	c+$80
00003998 4480                     M 	dc.w	c
0000399A =00004500                M c	=	c+$80
0000399A 4500                     M 	dc.w	c
0000399C =00004580                M c	=	c+$80
0000399C 4580                     M 	dc.w	c
0000399E =00004600                M c	=	c+$80
0000399E 4600                     M 	dc.w	c
000039A0 =00004680                M c	=	c+$80
000039A0 4680                     M 	dc.w	c
000039A2 =00004700                M c	=	c+$80
000039A2 4700                     M 	dc.w	c
000039A4 =00004780                M c	=	c+$80
000039A4 4780                     M 	dc.w	c
000039A6 =00004800                M c	=	c+$80
000039A6 4800                     M 	dc.w	c
000039A8 =00004880                M c	=	c+$80
000039A8 4880                     M 	dc.w	c
000039AA =00004900                M c	=	c+$80
000039AA 4900                     M 	dc.w	c
000039AC =00004980                M c	=	c+$80
000039AC 4980                     M 	dc.w	c
000039AE =00004A00                M c	=	c+$80
000039AE 4A00                     M 	dc.w	c
000039B0 =00004A80                M c	=	c+$80
000039B0 4A80                     M 	dc.w	c
000039B2 =00004B00                M c	=	c+$80
000039B2 4B00                     M 	dc.w	c
000039B4 =00004B80                M c	=	c+$80
000039B4 4B80                     M 	dc.w	c
000039B6 =00004C00                M c	=	c+$80
000039B6 4C00                     M 	dc.w	c
000039B8 =00004C80                M c	=	c+$80
000039B8 4C80                     M 	dc.w	c
000039BA =00004D00                M c	=	c+$80
000039BA 4D00                     M 	dc.w	c
000039BC =00004D80                M c	=	c+$80
000039BC 4D80                     M 	dc.w	c
000039BE =00004E00                M c	=	c+$80
000039BE 4E00                     M 	dc.w	c
000039C0 =00004E80                M c	=	c+$80
000039C0 4E80                     M 	dc.w	c
000039C2 =00004F00                M c	=	c+$80
000039C2 4F00                     M 	dc.w	c
000039C4 =00004F80                M c	=	c+$80
000039C4 4F80                     M 	dc.w	c
000039C6 =00005000                M c	=	c+$80
000039C6 5000                     M 	dc.w	c
000039C8 =00005080                M c	=	c+$80
000039C8 5080                     M 	dc.w	c
000039CA =00005100                M c	=	c+$80
000039CA 5100                     M 	dc.w	c
000039CC =00005180                M c	=	c+$80
000039CC 5180                     M 	dc.w	c
000039CE =00005200                M c	=	c+$80
000039CE 5200                     M 	dc.w	c
000039D0 =00005280                M c	=	c+$80
000039D0 5280                     M 	dc.w	c
000039D2 =00005300                M c	=	c+$80
000039D2 5300                     M 	dc.w	c
000039D4 =00005380                M c	=	c+$80
000039D4 5380                     M 	dc.w	c
000039D6 =00005400                M c	=	c+$80
000039D6 5400                     M 	dc.w	c
000039D8 =00005480                M c	=	c+$80
000039D8 5480                     M 	dc.w	c
000039DA =00005500                M c	=	c+$80
000039DA 5500                     M 	dc.w	c
000039DC =00005580                M c	=	c+$80
000039DC 5580                     M 	dc.w	c
000039DE =00005600                M c	=	c+$80
000039DE 5600                     M 	dc.w	c
000039E0 =00005680                M c	=	c+$80
000039E0 5680                     M 	dc.w	c
000039E2 =00005700                M c	=	c+$80
000039E2 5700                     M 	dc.w	c
000039E4 =00005780                M c	=	c+$80
000039E4 5780                     M 	dc.w	c
000039E6 =00005800                M c	=	c+$80
000039E6 5800                     M 	dc.w	c
000039E8 =00005880                M c	=	c+$80
000039E8 5880                     M 	dc.w	c
000039EA =00005900                M c	=	c+$80
000039EA 5900                     M 	dc.w	c
000039EC =00005980                M c	=	c+$80
000039EC 5980                     M 	dc.w	c
000039EE =00005A00                M c	=	c+$80
000039EE 5A00                     M 	dc.w	c
000039F0 =00005A80                M c	=	c+$80
000039F0 5A80                     M 	dc.w	c
000039F2 =00005B00                M c	=	c+$80
000039F2 5B00                     M 	dc.w	c
000039F4 =00005B80                M c	=	c+$80
000039F4 5B80                     M 	dc.w	c
000039F6 =00005C00                M c	=	c+$80
000039F6 5C00                     M 	dc.w	c
000039F8 =00005C80                M c	=	c+$80
000039F8 5C80                     M 	dc.w	c
000039FA =00005D00                M c	=	c+$80
000039FA 5D00                     M 	dc.w	c
000039FC =00005D80                M c	=	c+$80
000039FC 5D80                     M 	dc.w	c
000039FE =00005E00                M c	=	c+$80
000039FE 5E00                     M 	dc.w	c
00003A00 =00005E80                M c	=	c+$80
00003A00 5E80                     M 	dc.w	c
00003A02 =00005F00                M c	=	c+$80
00003A02 5F00                     M 	dc.w	c
00003A04 =00005F80                M c	=	c+$80
00003A04 5F80                     M 	dc.w	c
00003A06 =00006000                M c	=	c+$80
00003A06 6000                     M 	dc.w	c
00003A08 =00006080                M c	=	c+$80
00003A08 6080                     M 	dc.w	c
00003A0A =00006100                M c	=	c+$80
00003A0A 6100                     M 	dc.w	c
00003A0C =00006180                M c	=	c+$80
00003A0C 6180                     M 	dc.w	c
00003A0E =00006200                M c	=	c+$80
00003A0E 6200                     M 	dc.w	c
00003A10 =00006280                M c	=	c+$80
00003A10 6280                     M 	dc.w	c
00003A12 =00006300                M c	=	c+$80
00003A12 6300                     M 	dc.w	c
00003A14 =00006380                M c	=	c+$80
00003A14 6380                     M 	dc.w	c
00003A16 =00006400                M c	=	c+$80
00003A16 6400                     M 	dc.w	c
00003A18 =00006480                M c	=	c+$80
00003A18 6480                     M 	dc.w	c
00003A1A =00006500                M c	=	c+$80
00003A1A 6500                     M 	dc.w	c
00003A1C =00006580                M c	=	c+$80
00003A1C 6580                     M 	dc.w	c
00003A1E =00006600                M c	=	c+$80
00003A1E 6600                     M 	dc.w	c
00003A20 =00006680                M c	=	c+$80
00003A20 6680                     M 	dc.w	c
00003A22 =00006700                M c	=	c+$80
00003A22 6700                     M 	dc.w	c
00003A24 =00006780                M c	=	c+$80
00003A24 6780                     M 	dc.w	c
00003A26 =00006800                M c	=	c+$80
00003A26 6800                     M 	dc.w	c
00003A28 =00006880                M c	=	c+$80
00003A28 6880                     M 	dc.w	c
00003A2A =00006900                M c	=	c+$80
00003A2A 6900                     M 	dc.w	c
00003A2C =00006980                M c	=	c+$80
00003A2C 6980                     M 	dc.w	c
00003A2E =00006A00                M c	=	c+$80
00003A2E 6A00                     M 	dc.w	c
00003A30 =00006A80                M c	=	c+$80
00003A30 6A80                     M 	dc.w	c
00003A32 =00006B00                M c	=	c+$80
00003A32 6B00                     M 	dc.w	c
00003A34 =00006B80                M c	=	c+$80
00003A34 6B80                     M 	dc.w	c
00003A36 =00006C00                M c	=	c+$80
00003A36 6C00                     M 	dc.w	c
00003A38 =00006C80                M c	=	c+$80
00003A38 6C80                     M 	dc.w	c
00003A3A =00006D00                M c	=	c+$80
00003A3A 6D00                     M 	dc.w	c
00003A3C =00006D80                M c	=	c+$80
00003A3C 6D80                     M 	dc.w	c
00003A3E =00006E00                M c	=	c+$80
00003A3E 6E00                     M 	dc.w	c
00003A40 =00006E80                M c	=	c+$80
00003A40 6E80                     M 	dc.w	c
00003A42 =00006F00                M c	=	c+$80
00003A42 6F00                     M 	dc.w	c
00003A44 =00006F80                M c	=	c+$80
00003A44 6F80                     M 	dc.w	c
00003A46 =00007000                M c	=	c+$80
00003A46 7000                     M 	dc.w	c
00003A48 =00007080                M c	=	c+$80
00003A48 7080                     M 	dc.w	c
00003A4A =00007100                M c	=	c+$80
00003A4A 7100                     M 	dc.w	c
00003A4C =00007180                M c	=	c+$80
00003A4C 7180                     M 	dc.w	c
00003A4E =00007200                M c	=	c+$80
00003A4E 7200                     M 	dc.w	c
00003A50 =00007280                M c	=	c+$80
00003A50 7280                     M 	dc.w	c
00003A52 =00007300                M c	=	c+$80
00003A52 7300                     M 	dc.w	c
00003A54 =00007380                M c	=	c+$80
00003A54 7380                     M 	dc.w	c
00003A56 =00007400                M c	=	c+$80
00003A56 7400                     M 	dc.w	c
00003A58 =00007480                M c	=	c+$80
00003A58 7480                     M 	dc.w	c
00003A5A =00007500                M c	=	c+$80
00003A5A 7500                     M 	dc.w	c
00003A5C =00007580                M c	=	c+$80
00003A5C 7580                     M 	dc.w	c
00003A5E =00007600                M c	=	c+$80
00003A5E 7600                     M 	dc.w	c
00003A60 =00007680                M c	=	c+$80
00003A60 7680                     M 	dc.w	c
00003A62 =00007700                M c	=	c+$80
00003A62 7700                     M 	dc.w	c
00003A64 =00007780                M c	=	c+$80
00003A64 7780                     M 	dc.w	c
00003A66 =00007800                M c	=	c+$80
00003A66 7800                     M 	dc.w	c
00003A68 =00007880                M c	=	c+$80
00003A68 7880                     M 	dc.w	c
00003A6A =00007900                M c	=	c+$80
00003A6A 7900                     M 	dc.w	c
00003A6C =00007980                M c	=	c+$80
00003A6C 7980                     M 	dc.w	c
00003A6E =00007A00                M c	=	c+$80
00003A6E 7A00                     M 	dc.w	c
00003A70 =00007A80                M c	=	c+$80
00003A70 7A80                     M 	dc.w	c
00003A72 =00007B00                M c	=	c+$80
00003A72 7B00                     M 	dc.w	c
00003A74 =00007B80                M c	=	c+$80
00003A74 7B80                     M 	dc.w	c
00003A76 =00007C00                M c	=	c+$80
00003A76 7C00                     M 	dc.w	c
00003A78 =00007C80                M c	=	c+$80
00003A78 7C80                     M 	dc.w	c
00003A7A =00007D00                M c	=	c+$80
00003A7A 7D00                     M 	dc.w	c
00003A7C =00007D80                M c	=	c+$80
00003A7C 7D80                     M 	dc.w	c
00003A7E =00007E00                M c	=	c+$80
00003A7E 7E00                     M 	dc.w	c
00003A80 =00007E80                M c	=	c+$80
00003A80 7E80                     M 	dc.w	c
00003A82 =00007F00                M c	=	c+$80
00003A82 7F00                     M 	dc.w	c
00003A84 =00007F80                M c	=	c+$80
00003A84 7F80                     M 	dc.w	c
00003A86 =00008000                M c	=	c+$80
00003A86                            ; =========================================================================================================================================================
00003A86                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003A86                            ; =========================================================================================================================================================
00003A86                            ; General level functions
00003A86                            ; =========================================================================================================================================================
00003A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A86                            ; Load level data
00003A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A86                            Level_LoadData:
00003A86                            		; --- Initialize the start position and camera ---
00003A86                            
00003A86 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003A8C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A90 E218                       		ror.b	#1,d0				; Turn into offset
00003A92 E848                       		lsr.w	#4,d0				; ''
00003A94 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A98                            
00003A98 42B8 F8C4                  		clr.l	rDestMinCam.w		; Set target minimum camera values
00003A9C 42B8 F8C8                  		clr.l	rMinCam.w			; Set minimum camera values
00003AA0 21D3 F8BC                  		move.l	(a3),rDestMaxCam.w		; Set target maximum camera values
00003AA4 21DB F8C0                  		move.l	(a3)+,rMaxCam.w		; Set maximum camera values
00003AA8                            
00003AA8 31FC 0060 F8CC             		move.w	#(224/2)-16,rCamYPosDist.w	; Set camera Y distance
00003AAE                            
00003AAE 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Player object
00003AB2 321B                       		move.w	(a3)+,d1			; Get starting X position
00003AB4 3141 0014                  		move.w	d1,oXPos(a0)			; Set the player's X position
00003AB8 3013                       		move.w	(a3),d0				; Get starting Y position
00003ABA 3140 0018                  		move.w	d0,oYPos(a0)			; Set the player's Y position
00003ABE                            
00003ABE 4A38 C7B9                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003AC2 6700                       		beq.s	.InitCam			; If not, branch
00003AC4 08E8 0002 000C             		bset	#2,oFlags(a0)
00003ACA 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003ACC 3141 0014                  		move.w	d1,oXPos(a0)			; ''
00003AD0 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003AD2 3140 0018                  		move.w	d0,oYPos(a0)			; ''
00003AD6                            
00003AD6                            .InitCam:
00003AD6 4A38 C7AE                  		tst.b	rLastChkpoint.w		; Has a checkpoint been hit?
00003ADA 6700                       		beq.s	.SetCam				; If not, branch
00003ADC 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003AE0 3228 0014                  		move.w	oXPos(a0),d1			; Get X position
00003AE4 3028 0018                  		move.w	oYPos(a0),d0			; Get Y position
00003AE8                            
00003AE8                            .SetCam:
00003AE8 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003AEC 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003AEE 7200                       		moveq	#0,d1				; Cap it
00003AF0                            
00003AF0                            .ChkMaxX:
00003AF0 3438 F8C0                  		move.w	rMaxCamX.w,d2		; Get max camera X position
00003AF4 B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003AF6 6500                       		bcs.s	.SetCamX			; If not, branch
00003AF8 3202                       		move.w	d2,d1				; Cap it
00003AFA                            
00003AFA                            .SetCamX:	
00003AFA 31C1 F880                  		move.w	d1,rCamXPos.w			; Set the camera's X position
00003AFE                            
00003AFE 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003B02 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003B04 7000                       		moveq	#0,d0				; Cap it
00003B06                            
00003B06                            .ChkMaxY:
00003B06 3438 F8C2                  		move.w	rMaxCamY.w,d2		; Get max camera Y position
00003B0A B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003B0C 6D00                       		blt.s	.SetCamY			; If not, branch
00003B0E 3002                       		move.w	d2,d0				; Cap it
00003B10                            
00003B10                            .SetCamY:	
00003B10 31C0 F888                  		move.w	d0,rCamYPos.w			; Set the camera's Y position
00003B14                            
00003B14                            		; --- Load level data ---
00003B14                            
00003B14 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003B1A 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B1E E218                       		ror.b	#1,d0				; Turn into offset
00003B20 E448                       		lsr.w	#2,d0				; ''
00003B22 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B26                            
00003B26 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003B28 43F9 00FF 0000             		lea	rChunks,a1			; Decompress into chunk table
00003B2E 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B32                            
00003B32 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003B34 43F8 C7D0                  		lea	rBlocks.w,a1			; Decompress into block table
00003B38 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B3C                            
00003B3C 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003B3E 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003B40 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003B44                            
00003B44 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003B46 3018                       		move.w	(a0)+,d0			; Size of palette data
00003B48 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003B4C                            
00003B4C 205B                       		movea.l	(a3)+,a0			; Get layout pointer
00003B4E 43F8 DFD0                  		lea	rLayout.w,a1			; Decompress into layout buffer
00003B52 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B56                            
00003B56 21DB C7B4                  		move.l	(a3)+,rObjPosAddr.w		; Set object position data pointer
00003B5A 21DB F85E                  		move.l	(a3)+,rRingPosAddr.w		; Set ring position data pointer
00003B5E 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003B60 201B                       		move.l	(a3)+,d0			; Get collision data address
00003B62 21C0 F8E0                  		move.l	d0,rColAddr.w			; Set collision address to primary
00003B66 21C0 F8D8                  		move.l	d0,r1stCol.w			; Set primary collision data pointer
00003B6A 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003B6C 21C0 F8DC                  		move.l	d0,r2ndCol.w			; Set secondary collision data pointer
00003B70 43F8 F8E6                  		lea	rAngleVals.w,a1		; Collision pointers
00003B74 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003B76 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003B78 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003B7A                            
00003B7A 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003B80 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B84 E218                       		ror.b	#1,d0				; Turn into offset
00003B86 EA48                       		lsr.w	#5,d0				; ''
00003B88 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B8C 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B90                            ; Update the water surface
00003B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B90                            Level_UpdateWaterSurface:
00003B90 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B94 6700                       		beq.s	.End				; If not, branch
00003B96 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera X position
00003B9A 0838 0000 F8FB             		btst	#0,(rLvlFrames+1).w		; Are we on an odd frame?
00003BA0 6700                       		beq.s	.SetXPos			; If not, branch
00003BA2 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003BA6                            
00003BA6                            .SetXPos:
00003BA6 3001                       		move.w	d1,d0				; Copy X postion
00003BA8 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003BAC 3078 F87C                  		movea.w	rWater1Addr.w,a0
00003BB0 3140 0014                  		move.w	d0,oXPos(a0)			; Set it
00003BB4 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003BB8 3078 F87E                  		movea.w	rWater2Addr.w,a0
00003BBC 3141 0014                  		move.w	d1,oXPos(a0)			; Set it
00003BC0                            
00003BC0                            .End:
00003BC0 4E75                       		rts
00003BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BC2                            ; Handle water height
00003BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BC2                            Level_WaterHeight:
00003BC2 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003BC6 6700                       		beq.s	.End				; If not, branch
00003BC8 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003BCC 4238 F8F5                  		clr.b	rWaterFullscr.w		; Clear water fullscreen flag
00003BD0                            
00003BD0 7201                       		moveq	#1,d1				; Water movement speed
00003BD2 3038 F8F8                  		move.w	rDestWtrLvl.w,d0		; Get destination water level
00003BD6 9078 F8F6                  		sub.w	rWaterLvl.w,d0		; Is the current water level at that destination?
00003BDA 6700                       		beq.s	.ChkOnScr			; If so, branch
00003BDC 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003BDE 4441                       		neg.w	d1				; Go up
00003BE0                            
00003BE0                            .MoveDown:
00003BE0 D378 F8F6                  		add.w	d1,rWaterLvl.w		; Move water
00003BE4                            
00003BE4                            .ChkOnScr:
00003BE4 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00003BE8 9078 F888                  		sub.w	rCamYPos.w,d0			; Get camera's Y position
00003BEC 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003BEE 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003BF0                            		
00003BF0                            .Fullscreen:
00003BF0 50F8 F8F5                  		st	rWaterFullscr.w		; Set water fullscreen flag
00003BF4 50F8 C75F                  		st	rHIntCnt.w			; Set H-INT counter to be offscreen
00003BF8 4E75                       		rts
00003BFA                            
00003BFA                            .ChkBottom:
00003BFA 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003BFE 6500                       		blo.s	.SetCounter			; If not, branch
00003C00 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003C02                            
00003C02                            .SetCounter:
00003C02 11C0 C75F                  		move.b	d0,rHIntCnt.w			; Set H-INT counter
00003C06                            
00003C06                            .End:
00003C06 4E75                       		rts
00003C08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C08                            Level_MoveWater:
00003C08 4E75                       		rts
00003C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C0A                            ; Do level palette cycling
00003C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C0A                            Level_PalCycle:
00003C0A 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003C10 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C14 E218                       		ror.b	#1,d0				; Turn into offset
00003C16 EA48                       		lsr.w	#5,d0				; ''
00003C18 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C1C 4ED0                       		jmp	(a0)				; Jump to it
00003C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1E                            ; Do level art animation
00003C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1E                            Level_AnimateArt:
00003C1E 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003C24 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C28 E218                       		ror.b	#1,d0				; Turn into offset
00003C2A EA48                       		lsr.w	#5,d0				; ''
00003C2C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C30 4ED0                       		jmp	(a0)				; Jump to it
00003C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C32                            ; Do dynamic events
00003C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C32                            Level_DynEvents:
00003C32 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003C38 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C3C E218                       		ror.b	#1,d0				; Turn into offset
00003C3E EA48                       		lsr.w	#5,d0				; ''
00003C40 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C44 4ED0                       		jmp	(a0)				; Jump to it
00003C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C46                            ; Handle the camera
00003C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C46                            Level_HandleCamera:
00003C46 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Get player object
00003C4A                            		
00003C4A 4A38 F8CE                  		tst.b	rCamLockX.w			; Is the camera locked horizontally?
00003C4E 6600                       		bne.s	.ChkY				; If so, branch
00003C50 43F8 F880                  		lea	rCamXPos.w,a1			; Get foreground level variables
00003C54 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003C56                            		
00003C56                            .ChkY:
00003C56 4A38 F8CF                  		tst.b	rCamLockY.w			; Is the camera locked vertically?
00003C5A 6600                       		bne.s	.ChkMaxY			; If not, branch
00003C5C 43F8 F888                  		lea	rCamYPos.w,a1			; Get foreground level variables
00003C60 3638 F8CC                  		move.w	rCamYPosDist.w,d3		; Get camera Y distance
00003C64 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003C68                            
00003C68                            .ChkMaxY:
00003C68 7202                       		moveq	#2,d1				; Target camera scroll speed
00003C6A 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get distance between target and actual target max camera Y position
00003C6E 9078 F8C2                  		sub.w	rMaxCamY.w,d0		; ''
00003C72 6700                       		beq.s	.End				; If it's 0, branch
00003C74 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003C76 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003C7A B078 F8BE                  		cmp.w	rDestMaxY.w,d0		; Is it past the boundary?
00003C7E 6300                       		bls.s	.ScrollUp			; If not, branch
00003C80 31C0 F8C2                  		move.w	d0,rMaxCamY.w		; Set max camera Y position
00003C84 0278 FFFE F8C2             		andi.w	#$FFFE,rMaxCamY.w		; Keep it a multiple of 2
00003C8A                            
00003C8A                            .ScrollUp:
00003C8A 9378 F8C2                  		sub.w	d1,rMaxCamY.w		; Scroll up
00003C8E 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C92                            
00003C92                            
00003C92                            .End:
00003C92 4E75                       		rts
00003C94                            
00003C94                            .MoveDown:
00003C94 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003C98 5040                       		addq.w	#8,d0				; ''
00003C9A B078 F8C2                  		cmp.w	rMaxCamY.w,d0		; Is it past the boundary?
00003C9E 6500                       		bcs.s	.ScrollDown			; If not, branch
00003CA0 0828 0001 0028             		btst	#1,oStatus(a0)		; Is the player in the air?
00003CA6 6700                       		beq.s	.ScrollDown			; If not, branch
00003CA8 D241                       		add.w	d1,d1				; Scroll down faster
00003CAA D241                       		add.w	d1,d1				; ''
00003CAC                            
00003CAC                            .ScrollDown:
00003CAC D378 F8C2                  		add.w	d1,rMaxCamY.w		; Scroll down
00003CB0 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003CB4 4E75                       		rts
00003CB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CB6                            Level_MoveCameraX:
00003CB6 3028 0014                  		move.w	oXPos(a0),d0			; Get the player's X position
00003CBA 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003CBC 9078 F8D2                  		sub.w	rCamXPosCenter.w,d0		; Subtract center
00003CC0 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003CC2 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003CC4 4E75                       		rts
00003CC6                            
00003CC6                            .MoveLeft:
00003CC6 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003CCA 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003CCC 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003CD0                            
00003CD0                            .ChkLeftBound:
00003CD0 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003CD2 B078 F8C8                  		cmp.w	rMinCamX.w,d0		; Have we gone past the left boundary?
00003CD6 6E00                       		bgt.s	.SetCamX			; If not, branch
00003CD8 3038 F8C8                  		move.w	rMinCamX.w,d0		; Cap at the left boundary
00003CDC 6000                       		bra.s	.SetCamX			; Continue
00003CDE                            
00003CDE                            .MoveRight:
00003CDE 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003CE2 6500                       		blo.s	.ChkRightBound			; If not, branch
00003CE4 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003CE8                            
00003CE8                            .ChkRightBound:
00003CE8 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003CEA B078 F8C0                  		cmp.w	rMaxCamX.w,d0		; Has the camera gone beyond the right boundary?
00003CEE 6D00                       		blt.s	.SetCamX			; If not, branch
00003CF0 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Cap at the right boundary
00003CF4                            
00003CF4                            .SetCamX:
00003CF4 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003CF6 4E75                       		rts
00003CF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CF8                            Level_MoveCameraY:
00003CF8 7200                       		moveq	#0,d1
00003CFA 3028 0018                  		move.w	oYPos(a0),d0			; Get the player's Y position
00003CFE 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003D00                            
00003D00 0828 0002 0028             		btst	#2,oStatus(a0)			; Is the player rolling?
00003D06 6700                       		beq.s	.NoRoll				; If not, branch
00003D08 5B40                       		subq.w	#5,d0				; Move up some
00003D0A                            
00003D0A                            .NoRoll:
00003D0A 0828 0001 0028             		btst	#1,oStatus(a0)			; Is the player in the air?
00003D10 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003D12                            
00003D12                            .ChkBoundCross_Air:
00003D12 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003D16 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D18 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003D1A 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003D1E 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003D20                            
00003D20 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003D24 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D26 6000                       		bra.s	.NoScroll			; Continue
00003D28                            
00003D28                            .ChkBoundCross_Ground:
00003D28 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D2A 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003D2C 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003D30 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D32                            
00003D32                            .NoScroll:
00003D32 4E75                       		rts		
00003D34                            
00003D34                            .DecideScrollType:
00003D34 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003D38 6600                       		bne.s	.ScrollSlow			; If not, branch
00003D3A                            
00003D3A 3228 0000                  		move.w	oGVel(a0),d1			; Get the players' ground velocity
00003D3E 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003D40 4441                       		neg.w	d1				; Force it to be positive
00003D42                            
00003D42                            .Positive:
00003D42 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003D46 6400                       		bhs.s	.ScrollFast			; If so, branch
00003D48                            
00003D48                            .ScrollMedium:
00003D48 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003D4C 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003D50 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D52 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003D56 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D58 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D5A                            
00003D5A                            .ScrollSlow:
00003D5A 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003D5E 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003D62 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D64 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003D68 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D6A 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D6C                            
00003D6C                            .ScrollFast:
00003D6C 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003D70 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003D74 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D76 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003D7A 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D7C 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D7E                            
00003D7E                            .ScrollMaxYChange:
00003D7E 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003D80 11C0 F8D0                  		move.b	d0,rCamMaxChg.w		; Clear the max Y boundary changing flag
00003D84                            		
00003D84                            .ScrollUpOrDown:
00003D84 7200                       		moveq	#0,d1
00003D86 3200                       		move.w	d0,d1				; Get position difference
00003D88 D251                       		add.w	(a1),d1				; Add old camera Y position
00003D8A 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003D8C 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003D8E 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003D92                            
00003D92                            .ScrollUpMax:
00003D92 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003D94 48C1                       		ext.l	d1
00003D96 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003D98 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D9A 4841                       		swap	d1				; Get the actual Y position
00003D9C                            
00003D9C                            .ScrollUp:
00003D9C B278 F8CA                  		cmp.w	rMinCamY.w,d1		; Has the camera gone beyond the upper boundary?
00003DA0 6E00                       		bgt.s	.DoScroll			; If not, branch
00003DA2 3238 F8CA                  		move.w	rMinCamY.w,d1		; Cap at upper boundary
00003DA6 6000                       		bra.s	.DoScroll			; Continue
00003DA8                            
00003DA8                            .ScrollDownMax:
00003DA8 48C1                       		ext.l	d1
00003DAA E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003DAC D291                       		add.l	(a1),d1				; Add the camera's Y position
00003DAE 4841                       		swap	d1				; Get the actual Y position
00003DB0                            
00003DB0                            .ScrollDown:
00003DB0 B278 F8C2                  		cmp.w	rMaxCamY.w,d1		; Has the camera gone beyond the lower boundary?
00003DB4 6D00                       		blt.s	.DoScroll			; If not, branch
00003DB6 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Cap at lower boundary
00003DBA                            
00003DBA                            .DoScroll:
00003DBA 4841                       		swap	d1				; Put Y coordinate in the higher word
00003DBC 2281                       		move.l	d1,(a1)				; Set Y position
00003DBE 4E75                       		rts
00003DC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DC0                            ; Level ring manager
00003DC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DC0                            Level_RingsManager:
00003DC0 7000                       		moveq	#0,d0
00003DC2 1038 F3D6                  		move.b	rRingManRout.w,d0		; Get routine
00003DC6 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003DCA 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DCE                            .Routines:
00003DCE 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003DD0 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DD2                            ; Ring manager initialization
00003DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DD2                            Level_RingsManagerInit:
00003DD2 5438 F3D6                  		addq.b	#2,rRingManRout.w		; The next time the manager is run, only go to the main routine
00003DD6                            		
00003DD6 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003DDA                            
00003DDA                            		; Set up the addresses to use in the current location of the level
00003DDA                            
00003DDA                            		; Start at the left side of the screen
00003DDA                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003DDA                            
00003DDA 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get current ring data address for the left side of the screen
00003DDE 45F8 F3DE                  		lea	rRingStat.w,a2		; Ring status table
00003DE2 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003DE6 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003DE8 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003DEA 7801                       		moveq	#1,d4				; Cap left side to 1
00003DEC 6000                       		bra.s	.CheckLeftSide			; Start checking
00003DEE                            
00003DEE                            .NextLeftRing:
00003DEE 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DF0 544A                       		addq.w	#2,a2				; Next ring in status table
00003DF2                            
00003DF2                            .CheckLeftSide:
00003DF2 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003DF4 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003DF6 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003DFA 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003DFE                            
00003DFE                            		; Now the right side of the screen
00003DFE                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003DFE                            
00003DFE 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003E02 6000                       		bra.s	.CheckRightSide			; Start checking
00003E04                            
00003E04                            .NextRightRing:
00003E04 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E06                            
00003E06                            .CheckRightSide:
00003E06 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003E08 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003E0A 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003E0E 4E75                       		rts
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            ; Ring manager main routine
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            Level_RingsManagerMain:
00003E10 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003E14                            
00003E14 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get the current starting address for the ring data
00003E18 3478 F86A                  		movea.w	rRingStatPtr.w,a2		; Get the current starting address for the status table
00003E1C                            		
00003E1C                            		; Get the new starting addresses for ring data
00003E1C                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003E1C                            		; and then going back to get the very first ring that's on screen
00003E1C                            
00003E1C 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003E20 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003E22 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003E24 7801                       		moveq	#1,d4				; Cap left side to 1
00003E26 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003E28                            
00003E28                            .NextNewLeftRing:
00003E28 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E2A 544A                       		addq.w	#2,a2				; Next ring in status table
00003E2C                            
00003E2C                            .CheckNewLeftSide:
00003E2C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003E2E 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003E30 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003E32                            
00003E32                            .NextNewLeftRing2:
00003E32 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003E34 554A                       		subq.w	#2,a2				; Previous ring in status table
00003E36                            
00003E36                            .CheckNewLeftSide2:
00003E36 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003E3A 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003E3C 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003E40 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003E44                            
00003E44                            		; Now get the new ending addresses for ring data
00003E44                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003E44                            		; and then going back to get the very first ring that's on screen on the left side
00003E44                            
00003E44 2278 F866                  		movea.l	rRingLoadR.w,a1		; Get the current ending address for the ring data
00003E48                            
00003E48 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003E4C 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003E4E                            
00003E4E                            .NextNewRightRing:
00003E4E 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E50                            
00003E50                            .CheckNewRightSide:
00003E50 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003E52 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003E54 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003E56                            
00003E56                            .NextNewRightRing2:
00003E56 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003E58                            
00003E58                            .CheckNewRightSide2:
00003E58 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003E5C 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003E5E 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003E62 4E75                       		rts
00003E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E64                            ; Handle ring collection
00003E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E64                            Level_RingsManagerDoCollect:
00003E64 45F8 F7DE                  		lea	rRingCol.w,a2			; Ring collection table
00003E68 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003E6A 5341                       		subq.w	#1,d1				; Sutbract 1
00003E6C 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003E6E                            
00003E6E                            .Loop:
00003E6E 301A                       		move.w	(a2)+,d0			; Get ring status address
00003E70 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003E72 3240                       		movea.w	d0,a1				; Save in a1
00003E74 5311                       		subq.b	#1,(a1)				; Decrement timer
00003E76 6600                       		bne.s	.Next				; If nonzero, branch
00003E78 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003E7C 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003E80                            							; Is it the last frame?
00003E80 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003E86 6600                       		bne.s	.Next				; If not, branch
00003E88 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003E8C 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003E90 5378 F7DE                  		subq.w	#1,rRingColCnt.w		; Decrement collection table count
00003E94                            
00003E94                            .Next:
00003E94 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003E98                            
00003E98                            .End:
00003E98 4E75                       		rts
00003E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E9A                            ; Set up the tables and load ring data
00003E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E9A                            Level_RingsManagerSetup:
00003E9A                            		; Clear tables
00003E9A                            		clrRAM	rRingStat
00003E9A                          M 	local	endaddr
00003E9A                          M endaddr	equs	"rringstat_End"
00003E9A 7000                     M 	moveq	#0,d0
00003E9C 43F8 F3DE                M 	lea	(rringstat).w,a1
00003EA0 323C 00FF                M 	move.w	#(((rringstat_end)-(rringstat))-((rringstat)&1))>>2-1,d1
00003EA4 22C0                     M .clear_180:	move.l	d0,(a1)+
00003EA6 51C9 FFFC                M 	dbf	d1,.clear_180
00003EAA                            		clrRAM	rRingCol
00003EAA                          M 	local	endaddr
00003EAA                          M endaddr	equs	"rringcol_End"
00003EAA 7000                     M 	moveq	#0,d0
00003EAC 43F8 F7DE                M 	lea	(rringcol).w,a1
00003EB0 323C 001F                M 	move.w	#(((rringcol_end)-(rringcol))-((rringcol)&1))>>2-1,d1
00003EB4 22C0                     M .clear_181:	move.l	d0,(a1)+
00003EB6 51C9 FFFC                M 	dbf	d1,.clear_181
00003EBA                            
00003EBA 2278 F85E                  		movea.l	rRingPosAddr.w,a1		; Get ring data pointer
00003EBE 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store address
00003EC2 5849                       		addq.w	#4,a1				; Increment address by 4
00003EC4 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003EC6 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003ECA                            
00003ECA                            .GetRingCount:
00003ECA 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003ECC 6B00                       		bmi.s	.Exit				; If so, branch
00003ECE 5245                       		addq.w	#1,d5				; Increment ring counter
00003ED0 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003ED4                            
00003ED4                            .Exit:
00003ED4 4E75                       		rts
00003ED6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ED6                            ; Do ring collision for the player
00003ED6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ED6                            PlayerRingCollision:
00003ED6 0C28 0069 0000             		cmpi.b	#105,oInvulTime(a0)		; Is the player able to collect rings while hurt?
00003EDC 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003EE0 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get starting address of ring data
00003EE4 2478 F866                  		movea.l	rRingLoadR.w,a2		; Get starting address of status table
00003EE8 B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003EEA 6700 0000                  		beq.w	.End				; If not, branch
00003EEE 3878 F86A                  		movea.w	rRingStatPtr.w,a4
00003EF2 3428 0014                  		move.w	oXPos(a0),d2			; Player's X position
00003EF6 3628 0018                  		move.w	oYPos(a0),d3			; Player's Y position
00003EFA 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003EFC 7A00                       		moveq	#0,d5
00003EFE 1A28 002D                  		move.b	oColH(a0),d5			; Player's collision height
00003F02 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003F04 9645                       		sub.w	d5,d3				; Subtract from Y
00003F06 323C 0006                  		move.w	#6,d1
00003F0A 3C3C 000C                  		move.w	#$C,d6
00003F0E 383C 0010                  		move.w	#$10,d4				; Width
00003F12 DA45                       		add.w	d5,d5				; Double the height
00003F14                            
00003F14                            .NextRing:
00003F14 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003F16 6600                       		bne.s	.GetNext			; If so, get the next ring
00003F18 3011                       		move.w	(a1),d0				; Get ring's X position
00003F1A 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003F1C 9042                       		sub.w	d2,d0				; Check collision
00003F1E 6400                       		bcc.s	.ChkCol
00003F20 D046                       		add.w	d6,d0
00003F22 6500                       		bcs.s	.ChkCol2
00003F24 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F28                            
00003F28                            .ChkCol:
00003F28 B044                       		cmp.w	d4,d0				; Check collision
00003F2A 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003F2E                            
00003F2E                            .ChkCol2:
00003F2E 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003F32 9041                       		sub.w	d1,d0
00003F34 9043                       		sub.w	d3,d0
00003F36 6400                       		bcc.s	.ChkCol3
00003F38 D046                       		add.w	d6,d0
00003F3A 6500                       		bcs.s	.Collect
00003F3C 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F40                            
00003F40                            .ChkCol3:
00003F40 B045                       		cmp.w	d5,d0
00003F42 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003F46                            
00003F46                            .Collect:
00003F46                            							; Consume the ring
00003F46 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003F4A 6100                       		bsr.s	CollectRing			; Collect it
00003F4C 47F8 F7E0                  		lea	rRingColList.w,a3		; Get collection list
00003F50                            
00003F50                            .Consume:
00003F50 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003F52 66FC                       		bne.s	.Consume			; If not, get the next one
00003F54 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003F56 5278 F7DE                  		addq.w	#1,rRingColCnt.w		; Add to the number of rings consumed
00003F5A                            
00003F5A                            .GetNext:
00003F5A 5849                       		addq.w	#4,a1				; Next ring in ring data
00003F5C 544C                       		addq.w	#2,a4				; Next ring in status table
00003F5E B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003F60 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003F64                            
00003F64                            .End:
00003F64 4E75                       		rts
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            ; Collect a ring
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            CollectRing:
00003F66 5278 F3D4                  		addq.w	#1,rRings.w			; Incremment ring count
00003F6A 50F8 F8F3                  		st	rUpdateRings.w			; Update ring counter in HUD
00003F6E                            		playSnd	#sRing, 2			; Play ring sound
00003F6E 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003F74 4E75                       		rts
00003F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F76                            ; Render the HUD
00003F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F76                            Level_RenderHUDAndRings:
00003F76 7C00                       		moveq	#0,d6				; Clear render flags
00003F78 7802                       		moveq	#1*2,d4				; Standard frame
00003F7A 4A78 F3D4                  		tst.w	rRings.w			; Do we have 0 rings?
00003F7E 6600                       		bne.s	.Not0Rings			; If not, branch
00003F80 0838 0003 F8FB             		btst	#3,(rLvlFrames+1).w		; Can the timer blink?
00003F86 6600                       		bne.s	.Not0Rings			; If not, branch
00003F88 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003F8A                            
00003F8A                            .Not0Rings:
00003F8A 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003F8E                            		
00003F8E 303C 0090                  		move.w	#16+128,d0			; X position
00003F92 323C 0088                  		move.w	#8+128,d1			; Y position
00003F96 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003F9A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003F9E 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003FA0 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003FA2 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
00003FA6                            
00003FA6                            .RenderRings:
00003FA6 2078 F862                  		movea.l	rRingLoadL.w,a0			; Get starting address of ring data
00003FAA 2438 F866                  		move.l	rRingLoadR.w,d2			; Get ending address of ring data
00003FAE 9488                       		sub.l	a0,d2				; Get length of the data to read
00003FB0 6700                       		beq.s	.End				; If zero length, branch
00003FB2 3878 F86A                  		movea.w	rRingStatPtr.w,a4		; Get starting address of status table
00003FB6 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00003FBA 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00003FBE                            		
00003FBE                            .Loop:
00003FBE 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00003FC0 6B00                       		bmi.s	.Next				; If so, branch
00003FC2 3228 0002                  		move.w	2(a0),d1			; Get Y position
00003FC6 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00003FCA 5041                       		addq.w	#8,d1				; Add 8
00003FCC B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00003FCE 6400                       		bhs.s	.Next				; If so, branch
00003FD0 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00003FD4 3010                       		move.w	(a0),d0				; Get X position
00003FD6 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00003FD8 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00003FDC 7C00                       		moveq	#0,d6
00003FDE 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00003FE2                            
00003FE2                            .Draw:
00003FE2 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00003FE4 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00003FE8 D25A                       		add.w	(a2)+,d1			; Add Y offset
00003FEA 3CC1                       		move.w	d1,(a6)+			; Save Y position
00003FEC 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00003FEE 1C86                       		move.b	d6,(a6)				; Save it
00003FF0 544E                       		addq.w	#2,a6				; Skip link value
00003FF2 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00003FF4 D05A                       		add.w	(a2)+,d0			; Add X offset
00003FF6 3CC0                       		move.w	d0,(a6)+			; Save X position
00003FF8 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00003FFA                            
00003FFA                            .Next:
00003FFA 5848                       		addq.w	#4,a0				; Next ring in ring data
00003FFC 5942                       		subq.w	#4,d2				; Decrement the ring count
00003FFE 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00004000                            
00004000                            .End:
00004000 4E75                       		rts
00004002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004002                            ; Custom mappings format.
00004002                            ; Differences include...
00004002                            ;	No offset table (each sprite assumed to be 8 bytes)
00004002                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00004002                            ;	Sign-extended Y-pos value
00004002                            ;	Sign-extended sprite size value
00004002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004002                            CMap_Ring:
00004002                            		; Main ring frame
00004002 FFF8                       		dc.w	$FFF8
00004004 0005                       		dc.w	$0005
00004006 26BC                       		dc.w	$0000+$26BC
00004008 FFF8                       		dc.w	$FFF8
0000400A                            
0000400A                            CMap_Ring_Sparkle:
0000400A                            		; Ring sparkle frame 1
0000400A FFF8                       		dc.w	$FFF8
0000400C 0005                       		dc.w	$0005
0000400E 26B8                       		dc.w	$0000+$26B8
00004010 FFF8                       		dc.w	$FFF8
00004012                            		; Ring sparkle frame 2
00004012 FFF8                       		dc.w	$FFF8
00004014 0005                       		dc.w	$0005
00004016 3EB8                       		dc.w	($0000+$26B8)|$1800
00004018 FFF8                       		dc.w	$FFF8
0000401A                            		; Ring sparkle frame 3
0000401A FFF8                       		dc.w	$FFF8
0000401C 0005                       		dc.w	$0005
0000401E 2EB8                       		dc.w	($0000+$26B8)|$800
00004020 FFF8                       		dc.w	$FFF8
00004022                            		; Ring sparkle frame 4
00004022 FFF8                       		dc.w	$FFF8
00004024 0005                       		dc.w	$0005
00004026 36B8                       		dc.w	($0000+$26B8)|$1000
00004028 FFF8                       		dc.w	$FFF8
0000402A                            CMap_Ring_Sparkle_Last:
0000402A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402A                            ; HUD mappings
0000402A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402A                            Map_HUD:	include	"Objects/HUD/Mappings.asm"
0000402A                            ; --------------------------------------------------------------------------------
0000402A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000402A                            ; --------------------------------------------------------------------------------
0000402A                            
0000402A                            SME_dLu6r:	
0000402A 0000 0000                  		dc.w SME_dLu6r4-SME_dLu6r, SME_dLu6r18-SME_dLu6r	
0000402E 0003                       SME_dLu6r4:	dc.b 0, 3	
00004030 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00004036 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
0000403C 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00004042 0003                       SME_dLu6r18:	dc.b 0, 3	
00004044 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
0000404A 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00004050 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00004056                            		even
00004056                            		even
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; Update the HUD
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; PARAMETERS:
00004056                            ;	a5.l	- VDP data port
00004056                            ;	a6.l	- VDP control port
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; RETURNS:
00004056                            ;	Nothing
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            Level_UpdateHUD:
00004056 4A38 F8F3                  		tst.b	rUpdateRings.w		; Does the ring counter need to be updated?
0000405A 6700                       		beq.s	.End				; If not, branch
0000405C 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
0000405E 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00004062                            
00004062                            .DontZero:
00004062 4238 F8F3                  		clr.b	rUpdateRings.w		; Clear update value
00004066                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00004066 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
0000406C 7200                       		moveq	#0,d1
0000406E 3238 F3D4                  		move.w	rRings.w,d1			; Ring count
00004072 6000                       		bra.s	.UpdateRings			; Update the rings counter
00004074                            
00004074                            .End
00004074 4E75                       		rts
00004076                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004076                            .UpdateRings:
00004076 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00004078 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
0000407E 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00004080 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers
00004084                            		
00004084                            .LoadDigit_Loop:
00004084 7400                       		moveq	#0,d2				; Reset the digit
00004086 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
00004088                            		
00004088                            .GetDigit:
00004088 9283                       		sub.l	d3,d1				; Subtract
0000408A 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
0000408C 5242                       		addq.w	#1,d2				; Increment digit
0000408E 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004090                            
00004090                            .InitDrawDigit:
00004090 D283                       		add.l	d3,d1				; Add back
00004092 4A42                       		tst.w	d2				; Is the digit 0?
00004094 6700                       		beq.s	.DrawDigit			; If so, branch
00004096 50C4                       		st	d4				; Set the "draw digit" flag
00004098                            
00004098                            .DrawDigit:
00004098 4A04                       		tst.b	d4				; Should we draw the digit?
0000409A 6700                       		beq.s	.NextDigit			; If not, branch
0000409C ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
0000409E 2C80                       		move.l	d0,(a6)				; Set the VDP command
000040A0 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
000040A4                            		rept	16
000040A4                            			move.l	(a3)+,(a5)		; Load the digit art
000040A4                            		endr
000040A4 2A9B                     M 	move.l	(a3)+,(a5)
000040A6 2A9B                     M 	move.l	(a3)+,(a5)
000040A8 2A9B                     M 	move.l	(a3)+,(a5)
000040AA 2A9B                     M 	move.l	(a3)+,(a5)
000040AC 2A9B                     M 	move.l	(a3)+,(a5)
000040AE 2A9B                     M 	move.l	(a3)+,(a5)
000040B0 2A9B                     M 	move.l	(a3)+,(a5)
000040B2 2A9B                     M 	move.l	(a3)+,(a5)
000040B4 2A9B                     M 	move.l	(a3)+,(a5)
000040B6 2A9B                     M 	move.l	(a3)+,(a5)
000040B8 2A9B                     M 	move.l	(a3)+,(a5)
000040BA 2A9B                     M 	move.l	(a3)+,(a5)
000040BC 2A9B                     M 	move.l	(a3)+,(a5)
000040BE 2A9B                     M 	move.l	(a3)+,(a5)
000040C0 2A9B                     M 	move.l	(a3)+,(a5)
000040C2 2A9B                     M 	move.l	(a3)+,(a5)
000040C4                            		
000040C4                            .NextDigit:
000040C4 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
000040CA 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
000040CE 4E75                       		rts
000040D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040D0 0000 0064                  HUDMod_100:	dc.l	100
000040D4 0000 000A                  HUDMod_10:	dc.l	10
000040D8 0000 0001                  HUDMod_1:	dc.l	1
000040DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040DC                            ; Initialize the HUD
000040DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040DC                            Level_InitHUD:
000040DC 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
000040E2 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
000040E6                            		
000040E6                            Level_HUDResetRings:
000040E6                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
000040E6 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
000040EC 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
000040F0 343C 0002                  		move.w	#3-1,d2				; Length
000040F4                            
000040F4 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers art
000040F8                            
000040F8                            .LoadTiles:
000040F8 101A                       		move.b	(a2)+,d0			; Get digit
000040FA 4880                       		ext.w	d0
000040FC ED48                       		lsl.w	#6,d0				; Turn into offset
000040FE 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004102                            
00004102                            		rept	8*2
00004102                            			move.l	(a3)+,(a5)		; Load art
00004102                            		endr
00004102 2A9B                     M 	move.l	(a3)+,(a5)
00004104 2A9B                     M 	move.l	(a3)+,(a5)
00004106 2A9B                     M 	move.l	(a3)+,(a5)
00004108 2A9B                     M 	move.l	(a3)+,(a5)
0000410A 2A9B                     M 	move.l	(a3)+,(a5)
0000410C 2A9B                     M 	move.l	(a3)+,(a5)
0000410E 2A9B                     M 	move.l	(a3)+,(a5)
00004110 2A9B                     M 	move.l	(a3)+,(a5)
00004112 2A9B                     M 	move.l	(a3)+,(a5)
00004114 2A9B                     M 	move.l	(a3)+,(a5)
00004116 2A9B                     M 	move.l	(a3)+,(a5)
00004118 2A9B                     M 	move.l	(a3)+,(a5)
0000411A 2A9B                     M 	move.l	(a3)+,(a5)
0000411C 2A9B                     M 	move.l	(a3)+,(a5)
0000411E 2A9B                     M 	move.l	(a3)+,(a5)
00004120 2A9B                     M 	move.l	(a3)+,(a5)
00004122                            
00004122 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
00004126                            
00004126 4E75                       		rts
00004128                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004128                            HUD_RingsBase:
00004128 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
0000412C 00                         		even
0000412C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000412C                            ; HUD art
0000412C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000412C                            ArtUnc_HUDNumbers:
0000412C                            		incbin	"Objects/HUD/Art - HUD Numbers.unc.bin"
000043AC 0000 0000 0000 0000 0000+  		dcb.l	16, 0
000043EC                            		even
000043EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EC                            ; Animate the level art
000043EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EC                            ; LEVEL ANIMATION SCRIPTS
000043EC                            ;
000043EC                            ; The AniArt_DoAnimate subroutine uses these scripts to reload certain tiles,
000043EC                            ; thus animating them. All the relevant art must be uncompressed, because
000043EC                            ; otherwise the subroutine would spend so much time waiting for the art to be
000043EC                            ; decompressed that the VBLANK window would close before all the animating was done.
000043EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EC                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
000043EC                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
000043EC                            ;		ArtUnc_Flowers1		Source address
000043EC                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
000043EC                            ;		6			Number of frames
000043EC                            ;		2			Number of tiles to load into VRAM for each frame
000043EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EC                            ;	dc.b   0,$7F			Start of the script proper
000043EC                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
000043EC                            ;		$7F			Frame duration. Only here if global duration is -1
000043EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EC                            AniArt_DoAnimate:
000043EC 47F8 F902                  		lea	rAnimCnts.w,a3		; Level art animation counters
000043F0 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
000043F2 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
000043F4 4E75                       		rts
000043F6                            
000043F6                            .ListNotEmpty:
000043F6                            .Loop:
000043F6 5313                       		subq.b	#1,(a3)				; Tick down frame duration
000043F8 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
000043FA                            
000043FA                            .NextFrame:
000043FA 7000                       		moveq	#0,d0
000043FC 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004400 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
00004404 6500                       		blo.s	.NotLastFrame			; If not, branch
00004406 7000                       		moveq	#0,d0				; If so, reset to first frame
00004408 1740 0001                  		move.b	d0,1(a3)			; ''
0000440C                            
0000440C                            .NotLastFrame:
0000440C 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004410 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004412 6A00                       		bpl.s	.GlobalDuration
00004414 D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
00004416 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
0000441A                            
0000441A                            .GlobalDuration:
0000441A 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
0000441E EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004420 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
00004424 2212                       		move.l	(a2),d1				; Get ROM source address
00004426 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
0000442C D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
0000442E 7600                       		moveq	#0,d3
00004430 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
00004434 E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
00004436 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
0000443A                            
0000443A                            .NextScript:
0000443A 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
0000443E 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
00004440 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
00004442 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
00004444                            
00004444                            .GlobalDuration2:
00004444 5200                       		addq.b	#1,d0
00004446 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
0000444A 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
0000444E 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
00004450 51CE FFA4                  		dbf	d6,.Loop			; Loop
00004454 4E75                       		rts
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            ; Set an object as solid and check for collision
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For oStatus):
00004456                            ;	XXPXSXAX
00004456                            ;	X	- Unused
00004456                            ;	P	- Pushing flag
00004456                            ;	S	- Standing on flag
00004456                            ;	A	- In air flag (for the player)
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
00004456                            ;	XXXTXBXS
00004456                            ;	X	- Unused
00004456                            ;	T	- Touch top flag
00004456                            ;	B	- Touch bottom flag
00004456                            ;	S	- Touch side flag
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            ; PARAMETERS:
00004456                            ;	d1.w	- Object width
00004456                            ;	d2.w	- Object height / 2 (when jumping)
00004456                            ;	d3.w	- Object height / 2 (when walking)
00004456                            ;	d4.w	- Object x-axis position
00004456                            ;	a0.l	- Object space pointer
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            ; RETURNS:
00004456                            ;	See object collision return values above
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            SolidObject:
00004456 7C00                       		moveq	#0,d6				; Clear collision flag register
00004458 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
0000445C 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004462 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
00004466 3401                       		move.w	d1,d2				; Copy object width
00004468 D442                       		add.w	d2,d2				; Double it
0000446A 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004470 6600                       		bne.s	.NotOnTop			; If so, branch
00004472 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004476 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000447A D041                       		add.w	d1,d0				; Add width
0000447C 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
0000447E B042                       		cmp.w	d2,d0				; Compare with the width
00004480 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004482                            
00004482                            .NotOnTop:
00004482 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
00004488 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
0000448E 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004494 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004498 7800                       		moveq	#0,d4				; Set collision status to 0
0000449A 4E75                       		rts
0000449C                            
0000449C                            .IsOnTop:
0000449C 3404                       		move.w	d4,d2				; Copy X position to d2
0000449E 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000044A2 7800                       		moveq	#0,d4				; Set collision status to 0
000044A4 4E75                       		rts
000044A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044A6                            ; Set an object as solid and check for collision (even if off screen)
000044A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044A6                            ; PARAMETERS:
000044A6                            ;	d1.w	- Object width
000044A6                            ;	d2.w	- Object height / 2 (when jumping)
000044A6                            ;	d3.w	- Object height / 2 (when walking)
000044A6                            ;	d4.w	- Object x-axis position
000044A6                            ;	a0.l	- Object space pointer
000044A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044A6                            ; RETURNS:
000044A6                            ;	See object collision return values above
000044A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044A6                            SolidObject_Always:
000044A6 7C00                       		moveq	#0,d6				; Clear collision flag register
000044A8 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000044AC 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000044B2 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
000044B6 3401                       		move.w	d1,d2				; Copy object width
000044B8 D442                       		add.w	d2,d2				; Double it
000044BA 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000044C0 6600                       		bne.s	.NotOnTop			; If so, branch
000044C2 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000044C6 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000044CA D041                       		add.w	d1,d0				; Add width
000044CC 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000044CE B042                       		cmp.w	d2,d0				; Compare with the width
000044D0 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000044D2                            
000044D2                            .NotOnTop:
000044D2 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
000044D8 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000044DE 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000044E4 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000044E8 7800                       		moveq	#0,d4				; Set collision status to 0
000044EA 4E75                       		rts
000044EC                            
000044EC                            .IsOnTop:
000044EC 3404                       		move.w	d4,d2				; Copy X position to d2
000044EE 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000044F2 7800                       		moveq	#0,d4				; Set collision status to 0
000044F4 4E75                       		rts
000044F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044F6                            ; Set an object as a solid slope and check for collision
000044F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044F6                            ; PARAMETERS:
000044F6                            ;	d1.w	- Object width
000044F6                            ;	d2.w	- Object height / 2 (when jumping)
000044F6                            ;	d3.w	- Object height / 2 (when walking)
000044F6                            ;	d4.w	- Object x-axis position
000044F6                            ;	a0.l	- Object space pointer
000044F6                            ;	a2.l	- Slope height data pointer
000044F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044F6                            ; RETURNS:
000044F6                            ;	See object collision return values above
000044F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044F6                            SlopedSolid:
000044F6 7C00                       		moveq	#0,d6				; Clear collision flag register
000044F8 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000044FC 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004502 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
00004506 3401                       		move.w	d1,d2				; Copy object width
00004508 D442                       		add.w	d2,d2				; Double it
0000450A 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004510 6600                       		bne.s	.NotOnTop			; If so, branch
00004512 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004516 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000451A D041                       		add.w	d1,d0				; Add width
0000451C 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
0000451E B042                       		cmp.w	d2,d0				; Compare with the width
00004520 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004522                            
00004522                            .NotOnTop:
00004522 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
00004528 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
0000452E 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004534 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004538 7800                       		moveq	#0,d4				; Set collision status to 0
0000453A 4E75                       		rts
0000453C                            
0000453C                            .IsOnTop:
0000453C 3404                       		move.w	d4,d2				; Copy X position to d2
0000453E 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
00004542 7800                       		moveq	#0,d4				; Set collision status to 0
00004544 4E75                       		rts
00004546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004546                            SlopedSolid_ChkCollision:
00004546 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000454A 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract current object's X position
0000454E D041                       		add.w	d1,d0				; Add width to it
00004550 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004554 3601                       		move.w	d1,d3				; Copy width to d3
00004556 D643                       		add.w	d3,d3				; Double it
00004558 B043                       		cmp.w	d3,d0				; Compare to the X position
0000455A 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
0000455E 3A00                       		move.w	d0,d5				; Copy the X position to d5
00004560 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X-flipped?
00004566 6700                       		beq.s	.NoFlip				; If not, branch
00004568 4645                       		not.w	d5				; Logical notation on d5
0000456A DA43                       		add.w	d3,d5				; Add width
0000456C                            
0000456C                            .NoFlip:
0000456C E24D                       		lsr.w	#1,d5				; Divide by 2
0000456E 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
00004572 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
00004574 4883                       		ext.w	d3				; Sign extend to word
00004576 3A28 0018                  		move.w	oYPos(a0),d5			; Get the current object's Y position
0000457A 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
0000457C 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
00004580 4883                       		ext.w	d3				; Sign extend to word
00004582 D443                       		add.w	d3,d2				; Add collision height to the object height
00004584 3629 0018                  		move.w	oYPos(a1),d3			; Get the player's Y position
00004588 9645                       		sub.w	d5,d3				; Subtract d5
0000458A 5843                       		addq.w	#4,d3				; Add 4
0000458C D642                       		add.w	d2,d3				; Add height and collision height
0000458E 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004592 3802                       		move.w	d2,d4				; Copy height and collision height
00004594 D844                       		add.w	d4,d4				; Double it
00004596 B644                       		cmp.w	d4,d3				; Compare to Y position
00004598 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
0000459C 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
000045A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A0                            SolidObject_ChkColOnScr:
000045A0 4A28 000D                  		tst.b	oRender(a0)			; Is the object on screen?
000045A4 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
000045A8                            
000045A8                            SolidObject_ChkCollision:
000045A8 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000045AC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000045B0 D041                       		add.w	d1,d0				; Add width
000045B2 3601                       		move.w	d1,d3				; Copy width
000045B4 D643                       		add.w	d3,d3				; Double it
000045B6 B043                       		cmp.w	d3,d0				; Compare with the X position
000045B8 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000045BC                            		
000045BC 1829 0000                  		move.b	oInitColH(a1),d4		; Get the player's default collision height
000045C0 4884                       		ext.w	d4				; Sign extend to word
000045C2 D842                       		add.w	d2,d4				; Add height
000045C4 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
000045C8 4883                       		ext.w	d3				; Sign extend to word
000045CA D443                       		add.w	d3,d2				; Add to height
000045CC 3629 0018                  		move.w	oYPos(a1),d3			; Get player's Y position
000045D0 9668 0018                  		sub.w	oYPos(a0),d3			; Subtract the current object's Y position
000045D4 5843                       		addq.w	#4,d3				; Add 4
000045D6 D642                       		add.w	d2,d3				; Add height
000045D8 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
000045DC D842                       		add.w	d2,d4				; Add height
000045DE B644                       		cmp.w	d4,d3				; Compare with the Y position
000045E0 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            SolidObject_ChkBounds:
000045E4 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
000045E8 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
000045EC 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
000045F2 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
000045F6 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
000045FA 6600 0000                  		bne.w	SolidObject_End			; If so, branch
000045FE                            
000045FE 3A00                       		move.w	d0,d5				; Copy X offset
00004600 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004602 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
00004604 D241                       		add.w	d1,d1				; Double collision width
00004606 9041                       		sub.w	d1,d0				; Subtract from X offset
00004608 3A00                       		move.w	d0,d5				; Copy X offset
0000460A 4445                       		neg.w	d5				; Negate offset
0000460C                            
0000460C                            .IsLeft:
0000460C 3203                       		move.w	d3,d1				; Copy Y offset
0000460E B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004610 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004612 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
00004614 9644                       		sub.w	d4,d3				; Subtract height from the collision height
00004616 3203                       		move.w	d3,d1				; Copy Y offset
00004618 4441                       		neg.w	d1				; Negate offset
0000461A                            
0000461A                            .IsAbove:
0000461A BA41                       		cmp.w	d1,d5
0000461C 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004620 0C41 0004                  		cmpi.w	#4,d1
00004624 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
00004628                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004628                            SolidObject_Sides:
00004628 4A40                       		tst.w	d0
0000462A 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
0000462C 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
0000462E 4A69 001C                  		tst.w	oXVel(a1)			; Is the player moving left?
00004632 6B00                       		bmi.s	.AlignPlayer			; If so, branch
00004634 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
00004636                            
00004636                            .ChkRight:
00004636 4A69 001C                  		tst.w	oXVel(a1)
0000463A 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
0000463C                            
0000463C                            .ClearGroundVel:
0000463C 4269 0000                  		clr.w	oGVel(a1)			; Stop the player from moving
00004640 4269 001C                  		clr.w	oXVel(a1)			; Clear the player's X velocity
00004644                            
00004644                            .AlignPlayer:
00004644 9169 0014                  		sub.w	d0,oXPos(a1)			; Align player to the side of the object
00004648 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
0000464E 6600                       		bne.s	.InAir				; If so, branch
00004650 08E8 0005 0028             		bset	#cPushBit,oStatus(a0)		; Set the pushing bit
00004656 08E9 0005 0028             		bset	#cPushBit,oStatus(a1)		; Set the player's pushing bit
0000465C 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004660 7801                       		moveq	#1,d4				; Set collision status to 1
00004662 4E75                       		rts
00004664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004664                            .InAir:
00004664 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
00004666 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
0000466A 7801                       		moveq	#1,d4				; Set collision status to 1
0000466C 4E75                       		rts
0000466E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000466E                            SolidObject_TestClearPush:
0000466E 0828 0005 0028             		btst	#cPushBit,oStatus(a0)		; Is the player pushing this object?
00004674 6700                       		beq.s	SolidObject_End			; If not, branch
00004676 0C29 0002 0020             		cmpi.b	#2,oAni(a1)			; Is the player jumping/rolling?
0000467C 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000467E 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)			; Is the player in using the drowning animation
00004684 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004686 0C29 001A 0020             		cmpi.b	#$1A,oAni(a1)			; Is the player in using the hurt animation
0000468C 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000468E 337C 0001 0020             		move.w	#1,oAni(a1)			; Make the player use the walking animation
00004694                            
00004694                            SolidObject_ClearPush:
00004694 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear the pushing bit
0000469A 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; Clear the player's pushing bit
000046A0                            
000046A0                            SolidObject_End:
000046A0 7800                       		moveq	#0,d4				; Set collision status to 0
000046A2 4E75                       		rts
000046A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A4                            SolidObject_UpDown:
000046A4 4A43                       		tst.w	d3				; Is the player below the middle of the object?
000046A6 6B00                       		bmi.s	SolidObject_Below		; If so, branch
000046A8 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
000046AC 6500                       		bcs.s	SolidObject_Above		; If so, branch
000046AE 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
000046B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046B0                            SolidObject_Below:
000046B0 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving vertically?
000046B4 6700                       		beq.s	.CheckCrush			; If so, branch
000046B6 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
000046B8 4A43                       		tst.w	d3				; Is the player above the middle of the object?
000046BA 6A00                       		bpl.s	.SetY				; If so, branch
000046BC 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
000046C0                            
000046C0                            .SetY:
000046C0 9769 0018                  		sub.w	d3,oYPos(a1)			; Push the player below the object
000046C4 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000046C8 78FE                       		moveq	#-2,d4				; Set the collision status to -2
000046CA 4E75                       		rts
000046CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046CC                            .CheckCrush:
000046CC 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000046D2 66EC                       		bne.s	.SetY				; If so, branch
000046D4 3800                       		move.w	d0,d4				; Get x offset
000046D6 6A00                       		bpl.s	.NoNeg				; If it's positive branch
000046D8 4444                       		neg.w	d4				; Negate it (absolute value)
000046DA                            
000046DA                            .NoNeg:
000046DA 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
000046DE 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
000046E2                            		
000046E2                            		push.l	a0				; Store the current object's address
000046E2 2F08                     M 	move.l	a0,-(sp)
000046E4 2049                       		movea.l	a1,a0				; Replace with the player's address
000046E6 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
000046EC                            		pop.l	a0				; Restore the current object's address
000046EC 205F                     M 	move.l	(sp)+,a0
000046EE 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000046F2 78FE                       		moveq	#-2,d4				; Set collision status to -2
000046F4 4E75                       		rts
000046F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046F6                            SolidObject_Above:
000046F6 5943                       		subq.w	#4,d3				; Get the sub Y offset
000046F8                            		
000046F8                            		; This next bit ensures the player does not collide with the top when next to the walls
000046F8                            		; recalculates object width.
000046F8                            
000046F8 7200                       		moveq	#0,d1
000046FA 1228 002C                  		move.b	oColW(a0),d1			; Get the current object's width
000046FE 3401                       		move.w	d1,d2				; Copy it
00004700 D442                       		add.w	d2,d2				; Double it
00004702                            		
00004702 D269 0014                  		add.w	oXPos(a1),d1			; Add the player's X position
00004706 9268 0014                  		sub.w	oXPos(a0),d1			; Subtract the current object's X position
0000470A 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
0000470C                            		
0000470C B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
0000470E 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004710                            		
00004710 5369 0018                  		subq.w	#1,oYPos(a1)			; Subtract 1 from the player's Y position
00004714 9769 0018                  		sub.w	d3,oYPos(a1)			; Move the player above the object
00004718 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
0000471C 6B00                       		bmi.s	.NoCollision			; If so, branch
0000471E 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004722 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
00004726 78FF                       		moveq	#-1,d4				; Set collision status to -1
00004728 4E75                       		rts
0000472A                            
0000472A                            .NoCollision:
0000472A 7800                       		moveq	#0,d4				; Set collision status to 0
0000472C 4E75                       		rts
0000472E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000472E                            ; Set an object as a platform and check for collision
0000472E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000472E                            ; PARAMETERS:
0000472E                            ;	d1.w	- Object's width
0000472E                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
0000472E                            ;	d3.w	- Object's height
0000472E                            ;	d4.w	- Object x-axis position
0000472E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000472E                            ; RETURNS:
0000472E                            ;	See object collision return values above (side and bottom collision doesn't apply here)
0000472E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000472E                            PlatformObject:
0000472E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004730 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
00004734 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
0000473A 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
0000473E 3401                       		move.w	d1,d2				; Copy the object's width
00004740 D442                       		add.w	d2,d2				; Double it
00004742 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004748 6600                       		bne.s	.NotOnTop			; If so, branch
0000474A 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
0000474E 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
00004752 D041                       		add.w	d1,d0				; Add width
00004754 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
00004756 B042                       		cmp.w	d2,d0				; Compare with the width
00004758 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
0000475A                            
0000475A                            .NotOnTop:
0000475A 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
00004760 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004766 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
0000476C 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004770 7800                       		moveq	#0,d4				; Set the collision status to 0
00004772 4E75                       		rts
00004774                            
00004774                            .OnTop:
00004774 3404                       		move.w	d4,d2				; Copy X position
00004776 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
0000477A 7800                       		moveq	#0,d4				; Set the collision status to 0
0000477C 4E75                       		rts
0000477E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000477E                            Platform_ChkBridgeCol:
0000477E 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004782 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004786 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
0000478A 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
0000478E D041                       		add.w	d1,d0				; Add width
00004790 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004794 B042                       		cmp.w	d2,d0				; Compare with width
00004796 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
0000479A 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
0000479C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000479C                            Platform_ChkCollision:
0000479C 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000047A0 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000047A4 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000047A8 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000047AC D041                       		add.w	d1,d0				; Add width
000047AE 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000047B2 D241                       		add.w	d1,d1				; Double width
000047B4 B041                       		cmp.w	d1,d0				; Compare with width
000047B6 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000047BA                            
000047BA                            Platform_ChkCol_Cont:
000047BA 3028 0018                  		move.w	oYPos(a0),d0			; Get the object's Y position
000047BE 9043                       		sub.w	d3,d0				; Subtract the height from it
000047C0                            
000047C0                            PlatformObject_ChkYRange:
000047C0 3429 0018                  		move.w	oYPos(a1),d2			; Get the player's Y position
000047C4 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
000047C8 4881                       		ext.w	d1				; Sign extend it
000047CA D242                       		add.w	d2,d1				; Add the Y position to the collision height
000047CC 5841                       		addq.w	#4,d1				; Add 4
000047CE 9041                       		sub.w	d1,d0				; Subract the result from the Y position
000047D0 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
000047D4 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
000047D8 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
000047DC 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
000047E0 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
000047E4 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
000047E8 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000047EC 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)		; Is the player dead?
000047F2 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
000047F6 D440                       		add.w	d0,d2				; Add the previous result to the Y position
000047F8 5642                       		addq.w	#3,d2				; Add 3
000047FA 3342 0018                  		move.w	d2,oYPos(a1)			; Add to the player's Y position
000047FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047FE                            ; Set the player on top of the object
000047FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047FE                            ; PARAMETERS:
000047FE                            ;	a0.l	- Object space pointer
000047FE                            ;	a1.l	- Player object space pointer
000047FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047FE                            ; RETURNS:
000047FE                            ;	Nothing
000047FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047FE                            RideObject_SetRide:
000047FE 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
00004804 6700                       		beq.s	.IsStanding			; If not, branch
00004806 3669 0000                  		movea.w	oInteract(a1),a3		; Get the object the player is standing on
0000480A 08AB 0003 0028             		bclr	#cStandBit,oStatus(a3)		; Clear its standing on object bit
00004810 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004814                            
00004814                            .IsStanding:
00004814 3348 0000                  		move.w	a0,oInteract(a1)		; Set it as the object the player is standing on
00004818 4229 0000                  		clr.b	oAngle(a1)			; Clear the player's angle
0000481C 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004820 3369 001C 0000             		move.w	oXVel(a1),oGVel(a1)		; Set the player's X velocity as its ground velocity
00004826 08E9 0003 0028             		bset	#cStandBit,oStatus(a1)		; Set the player's standing on object bit
0000482C 08E8 0003 0028             		bset	#cStandBit,oStatus(a0)		; Set the player standing on this object bir
00004832 08A9 0001 0028             		bclr	#1,oStatus(a1)			; Clear the player's in midair bit
00004838 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
0000483A 2F08                       		move.l	a0,-(sp)			; Store the current object's address
0000483C 2049                       		movea.l	a1,a0				; Replace it with the player's address
0000483E 6100 E5EE                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
00004842 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
00004844                            
00004844                            PlatformObject_End:
00004844 4E75                       		rts
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            ; Set an object as a solid slope and check for collision
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            ; PARAMETERS:
00004846                            ;	d1.w	- Object width
00004846                            ;	d3.w	- Object height
00004846                            ;	d4.w	- Object x-axis position
00004846                            ;	a0.l	- Object space pointer
00004846                            ;	a2.l	- Slope height data pointer
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            ; RETURNS:
00004846                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            SlopedPlatform:
00004846 7C00                       		moveq	#0,d6				; Clear collision flag register
00004848 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
0000484C 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
00004852 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
00004856 3401                       		move.w	d1,d2				; Copy the object's width
00004858 D442                       		add.w	d2,d2				; Double it
0000485A 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004860 6600                       		bne.s	.NotOnTop			; If so, branch
00004862 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004866 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
0000486A D041                       		add.w	d1,d0				; Add width
0000486C 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000486E B042                       		cmp.w	d2,d0				; Compare with the width
00004870 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004872                            
00004872                            .NotOnTop:
00004872 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
00004878 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
0000487E 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004884 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004888 7800                       		moveq	#0,d4				; Set the collision status to 0
0000488A 4E75                       		rts
0000488C                            
0000488C                            .OnTop:
0000488C 3404                       		move.w	d4,d2				; Copy X position
0000488E 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
00004892 7800                       		moveq	#0,d4				; Set the collision status to 0
00004894 4E75                       		rts
00004896                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004896                            SlopedPlarform_ChkCol:
00004896 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
0000489A 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
0000489E 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000048A2 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000048A6 D041                       		add.w	d1,d0				; Add width
000048A8 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000048AC D241                       		add.w	d1,d1				; Double width
000048AE B041                       		cmp.w	d1,d0				; Compare with width
000048B0 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000048B4 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
000048BA 6700                       		beq.s	.NoXFlip			; If not, skip
000048BC 4640                       		not.w	d0				; Logical notation
000048BE D041                       		add.w	d1,d0				; Add width
000048C0                            
000048C0                            .NoXFlip:
000048C0 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
000048C2 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
000048C6 4883                       		ext.w	d3				; Sign extend to word
000048C8 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
000048CC 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
000048CE 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
000048D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048D2                            ; Move the player along a platform/solid object
000048D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048D2                            ; PARAMETERS:
000048D2                            ;	d2.w	- X position of the platform
000048D2                            ;	d3.w	- Height of the platform
000048D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048D2                            ; RETURNS:
000048D2                            ;	Nothing
000048D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048D2                            PlayerMoveOnPtfm:
000048D2 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
000048D6 9043                       		sub.w	d3,d0				; Subtract height
000048D8 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
000048DC 6B00                       		bmi.s	.End				; If so, branch
000048DE 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
000048E4 6400                       		bcc.s	.End				; If so, branch
000048E6 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
000048EA 6600                       		bne.s	.End				; If so, branch
000048EC 7200                       		moveq	#0,d1
000048EE 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
000048F2 9041                       		sub.w	d1,d0				; Subtract from the Y position
000048F4 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
000048F8 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
000048FC 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004900                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004900                            		;beq.s	.End				; If not branch
00004900                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004900                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004900                            
00004900                            .End:
00004900 4E75                       		rts
00004902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004902                            ; Move the player along a sloped platform/solid object
00004902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004902                            ; PARAMETERS:
00004902                            ;	d3.w	- Height of the platform
00004902                            ;	d4.w	- X position of the platform
00004902                            ;	a2.l	- Slope height data pointer
00004902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004902                            ; RETURNS:
00004902                            ;	Nothing
00004902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004902                            PlayerMoveOnSlope:
00004902 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
00004908 6700                       		beq.s	.End				; If not, branch
0000490A 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
0000490E 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004912 D041                       		add.w	d1,d0				; Add width
00004914 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004916 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
0000491C 6700                       		beq.s	.NoXFlip			; If not, branch
0000491E 4640                       		not.w	d0				; Logical notation on d0
00004920 D041                       		add.w	d1,d0				; Add width
00004922                            
00004922                            .NoXFlip:
00004922 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
00004926 4881                       		ext.w	d1				; Sign extend to word
00004928 3028 0018                  		move.w	oYPos(a0),d0			; Get current object's Y position
0000492C 9041                       		sub.w	d1,d0				; Subtract the Y offset
0000492E 7200                       		moveq	#0,d1
00004930 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004934 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004936 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000493A 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
0000493E 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004942                            
00004942                            .End:
00004942 4E75                       		rts
00004944                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004944                            ; Do object collision for the player object
00004944                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004944                            PlayerDoObjCollision:
00004944 4EB8 3ED6                  		jsr	PlayerRingCollision		; Do ring collision
00004948                            		
00004948 3428 0014                  		move.w	oXPos(a0),d2			; Get X position
0000494C 3628 0018                  		move.w	oYPos(a0),d3			; Get Y position
00004950 5142                       		subq.w	#8,d2				; Get left sensor X
00004952 7A00                       		moveq	#0,d5
00004954 1A28 002D                  		move.b	oColH(a0),d5			; Get collision height
00004958 5705                       		subq.b	#3,d5				; Subtract 3
0000495A 9645                       		sub.w	d5,d3				; Get left sensor Y
0000495C 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
00004960 DA45                       		add.w	d5,d5				; Get right sensor delta Y
00004962                            
00004962 49F8 F354                  		lea	rColList.w,a4			; Get collision response list
00004966 3C1C                       		move.w	(a4)+,d6			; Get count
00004968 6700                       		beq.s	.End				; If there are no objects to test, branch
0000496A                            
0000496A                            .ObjLoop:
0000496A 325C                       		movea.w	(a4)+,a1			; Get object
0000496C 1029 002A                  		move.b	oColType(a1),d0			; Does touching it do anything?
00004970 6600                       		bne.s	.ChkPosition			; If so, branch
00004972                            
00004972                            .NextObj:
00004972 5546                       		subq.w	#2,d6				; Decrement count
00004974 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
00004976 7000                       		moveq	#0,d0				; Reset d0
00004978                            
00004978                            .End:
00004978 4278 F354                  		clr.w	rColList.w			; Clear the collision response list count
0000497C 4E75                       		rts
0000497E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000497E                            .ChkPosition:
0000497E 7200                       		moveq	#0,d1
00004980 1229 002C                  		move.b	oColW(a1),d1			; Get object width
00004984 3029 0014                  		move.w	oXPos(a1),d0			; Get object X position
00004988 9041                       		sub.w	d1,d0				; Get left side of object
0000498A 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
0000498C 6400                       		bcc.s	.ChkRightSide			; If so, branch
0000498E D241                       		add.w	d1,d1				; Get right side delta X
00004990 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004992 6500                       		bcs.s	.ChkHeight			; If not, branch
00004994 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
00004996                            
00004996                            .ChkRightSide:
00004996 B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
00004998 62D8                       		bhi.s	.NextObj			; If not, branch
0000499A                            
0000499A                            .ChkHeight:
0000499A 7200                       		moveq	#0,d1
0000499C 1229 002D                  		move.b	oColH(a1),d1			; Get object height
000049A0 3029 0018                  		move.w	oYPos(a1),d0			; Get object Y position
000049A4 9041                       		sub.w	d1,d0				; Get top of object
000049A6 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
000049A8 6400                       		bcc.s	.ChkBottom			; If so, branch
000049AA D241                       		add.w	d1,d1				; Get bottom delta Y
000049AC D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
000049AE 6500                       		bcs.s	.ChkType			; If not, branch
000049B0 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
000049B2                            
000049B2                            .ChkBottom:
000049B2 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
000049B4 62BC                       		bhi.s	.NextObj			; If not, branch
000049B6                            
000049B6                            .ChkType:
000049B6 7000                       		moveq	#0,d0
000049B8 1029 002A                  		move.b	oColType(a1),d0			; Get collision type
000049BC 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
000049C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049C0                            .CollisionTypes:
000049C0 6000                       		bra.s	.Enemy				; Enemy
000049C2 6000                       		bra.s	.Indestructable			; Indestructable
000049C4 6000                       		bra.s	.Monitor			; Monitor
000049C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049C6                            .Enemy:
000049C6 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
000049CC 6600 0000                  		bne.w	.ChkHurt			; If not, branch
000049D0                            
000049D0                            .ChkBoss:
000049D0 4A29 002B                  		tst.b	oHitCnt(a1)			; Do we have a hit count?
000049D4 6700                       		beq.s	.Kill				; If not, branch
000049D6 4468 001C                  		neg.w	oXVel(a0)			; Bounce backwards
000049DA 4468 001E                  		neg.w	oYVel(a0)			; ''
000049DE 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
000049E2 5329 002B                  		subq.b	#1,oHitCnt(a1)			; Decrement hit count
000049E6 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
000049E8 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
000049EE                            
000049EE                            .BossEnd:
000049EE 4E75                       		rts
000049F0                            
000049F0                            .Kill:
000049F0 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
000049F6 22BC 0000 0000             		move.l	#ObjExplosion,oAddr(a1)		; Change into an explosion
000049FC 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004A00 4229 0025                  		clr.b	oRoutine(a1)			; Reset the routine ID
00004A04 4A68 001E                  		tst.w	oYVel(a0)			; Are we going up?
00004A08 6B00                       		bmi.s	.MoveDown			; If so, branch
00004A0A 3028 0018                  		move.w	oYPos(a0),d0			; Are we below the object?
00004A0E B069 0018                  		cmp.w	oYPos(a1),d0			; ''
00004A12 6400                       		bhs.s	.MoveUp				; If so, branch
00004A14 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
00004A18 4E75                       		rts
00004A1A                            
00004A1A                            .MoveDown:
00004A1A 0668 0100 001E             		addi.w	#$100,oYVel(a0)			; Move down
00004A20 4E75                       		rts
00004A22                            
00004A22                            .MoveUp:
00004A22 0468 0100 001E             		subi.w	#$100,oYVel(a0)			; Move up
00004A28 4E75                       		rts
00004A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A2A                            .Indestructable:
00004A2A 6000                       		bra.s	.ChkHurt			; Get hurt
00004A2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A2C                            .Monitor:
00004A2C 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00004A30 6A00                       		bpl.s	.ChkDestroy			; If it's falling or staying still, branch
00004A32 3028 0018                  		move.w	oYPos(a0),d0			; Get player's Y position
00004A36 0440 0010                  		subi.w	#$10,d0				; Subtract 16
00004A3A B069 0018                  		cmp.w	oYPos(a1),d0			; Is the plyaer hitting the bottom of the object?
00004A3E 6500                       		blo.s	.MonitorEnd			; If not, branch
00004A40 337C FE80 001E             		move.w	#-$180,oYVel(a1)		; Bounce the monitor up
00004A46 4A29 0000                  		tst.b	oMonFall(a1)			; Is it already falling?
00004A4A 6600                       		bne.s	.MonitorEnd			; If so, branch
00004A4C 50E9 0000                  		st	oMonFall(a1)			; Set the fall flag
00004A50 4E75                       		rts
00004A52                            
00004A52                            .ChkDestroy:
00004A52 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
00004A58 6600                       		bne.s	.MonitorEnd			; If not, branch
00004A5A 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
00004A5E 22BC 0000 0000             		move.l	#ObjMonitorBreakOpen,oAddr(a1)	; Set to destroyed routine
00004A64                            		
00004A64                            .MonitorEnd:
00004A64 4E75                       		rts
00004A66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A66                            .ChkHurt:
00004A66 4A68 0000                  		tst.w	oInvulTime(a0)			; Are we invulnerable?
00004A6A 6600                       		bne.s	.NoHurt				; If so, branch
00004A6C 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
00004A6E 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
00004A74                            
00004A74                            .NoHurt:
00004A74 4E75                       		rts
00004A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A76                            ; Add a new entry to the collision response list
00004A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A76                            AddToColResponse:
00004A76 43F8 F354                  		lea	rColList.w,a1			; Get collision response list
00004A7A 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
00004A7E 6400                       		bhs.s	.End				; If so, branch
00004A80 5451                       		addq.w	#2,(a1)				; Add a new entry
00004A82 D2D1                       		adda.w	(a1),a1				; Get entry pointer
00004A84 3288                       		move.w	a0,(a1)				; Store entry
00004A86                            
00004A86                            .End:
00004A86 4E75                       		rts
00004A88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A88                            ; Save some info in a level (mainly for checkpoints)
00004A88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A88                            ; PARAMETERS:
00004A88                            ;	a0.l	- Object space pointer
00004A88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A88                            ; RETURNS:
00004A88                            ;	Nothing
00004A88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A88                            Level_SaveInfo:
00004A88 31E8 0014 C7B0             		move.w	oXPos(a0),rSavedXPos.w		; Save X position
00004A8E 31E8 0018 C7B2             		move.w	oYPos(a0),rSavedYPos.w		; Save Y position
00004A94 4E75                       		rts
00004A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A96                            ; Load some info in a level (mainly for checkpoints)
00004A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A96                            ; PARAMETERS:
00004A96                            ;	a0.l	- Object space pointer
00004A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A96                            ; RETURNS:
00004A96                            ;	Nothing
00004A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A96                            Level_LoadSavedInfo:
00004A96 3178 C7B0 0014             		move.w	rSavedXPos.w,oXPos(a0)		; Load X position
00004A9C 3178 C7B2 0018             		move.w	rSavedYPos.w,oYPos(a0)		; Load Y position
00004AA2 4E75                       		rts
00004AA4                            ; =========================================================================================================================================================
00004AA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA4                            ; Music IDs
00004AA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA4                            Level_MusicIDs:
00004AA4 0B0B                       		dc.b	mWWZ, mWWZ
00004AA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA6                            ; Level water heights (-1 for no water)
00004AA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA6                            Level_WaterLevels:
00004AA6                            		;dc.w	$490, -1			; Wacky Workbench
00004AA6 FFFF FFFF                  		dc.w	-1, -1
00004AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AAA                            ; Level data pointers
00004AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AAA                            ; FORMAT:
00004AAA                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004AAA                            ;	dc.l	LAYOUT, OBJECTS, RINGS, COLLISION
00004AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AAA                            Level_DataPointers:
00004AAA 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004ABA 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004ACA 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004ADA 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004AEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AEA                            ; Size and start position data
00004AEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AEA                            Level_SizeStartPos:
00004AEA 3000 0580                  		dc.w	$3000, $580
00004AEE                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004AF2 3000 0580                  		dc.w	$3000, $580
00004AF6                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004AFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AFA                            ; Dynamic events routines
00004AFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AFA                            Level_DynEvenRouts:
00004AFA 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004AFE 0000 0000                  		dc.l	DynEv_WWZ
00004B02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B02                            ; Wacky Workbench dynamic events routine
00004B02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B02                            DynEv_WWZ:
00004B02 7000                       		moveq	#0,d0
00004B04 1038 F8FE                  		move.b	rDynEvRout.w,d0
00004B08 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004B0C 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004B10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B10                            .Index:
00004B10 0000                       		dc.w	.WaitBoss-.Index
00004B12 0000                       		dc.w	.Done-.Index
00004B14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B14                            .WaitBoss:
00004B14 0C78 2EE0 F880             		cmpi.w	#$2EE0,rCamXPos.w
00004B1A 6D00                       		blt.s	.Done
00004B1C 31FC 0340 F8CA             		move.w	#$340,rMinCamY.w
00004B22 31FC 0340 F8BE             		move.w	#$340,rDestMaxY.w
00004B28 31FC 2EE0 F8C8             		move.w	#$2EE0,rMinCamX.w
00004B2E 31FC 2EE0 F8C0             		move.w	#$2EE0,rMaxCamX.w
00004B34 5438 F8FE                  		addq.b	#2,rDynEvRout.w
00004B38                            
00004B38                            .Done:
00004B38 4E75                       		rts
00004B3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B3A                            ; Palette cycle routines
00004B3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B3A                            Level_PalCycRouts:
00004B3A 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004B3E 0000 0000                  		dc.l	PalCycle_WWZ
00004B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B42                            ; Wacky Workbench palette cycle routine
00004B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B42                            PalCycle_WWZ:
00004B42 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
00004B46 6600                       		bne.s	.Flash				; If so, branch
00004B48                            
00004B48 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004B4C 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004B4E 50F8 F8FF                  		st	rFloorActive.w		; Set the floor active flag
00004B52 31FC 00B4 F900             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004B58                            
00004B58                            .ResetPal:
00004B58 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset the palette cycle
00004B5C 31FC 0C28 9930             		move.w	#$C28,(rPalette+$62).w		; Set the floor color to be deactivated
00004B62 31FC 0E48 98B0             		move.w	#$E48,(rWaterPal+$62).w	; ''
00004B68 4E75                       		rts
00004B6A                            
00004B6A                            .Flash:
00004B6A 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004B6E 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004B70 4238 F8FF                  		clr.b	rFloorActive.w		; Clear the floor active flag
00004B74 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004B7A                            
00004B7A                            .UpdatePal:
00004B7A 5338 C7CE                  		subq.b	#1,rPalCycTimer.w		; Decrement the palette cycle timer
00004B7E 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004B80 11FC 0001 C7CE             		move.b	#1,rPalCycTimer.w		; Reset the palette cycle timer
00004B86                            
00004B86 7000                       		moveq	#0,d0
00004B88 1038 C7CF                  		move.b	rPalCycIndex.w,d0		; Get the palette cycle index
00004B8C D040                       		add.w	d0,d0				; Turn into offset
00004B8E                            							; Set the floor color
00004B8E 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(rPalette+$62).w
00004B94 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(rWaterPal+$62).w
00004B9A                            
00004B9A 5238 C7CF                  		addq.b	#1,rPalCycIndex.w		; Increment the palette cycle index
00004B9E 0C38 0005 C7CF             		cmpi.b	#5,rPalCycIndex.w		; Has it reached the end of the cycle?
00004BA4 6500                       		bcs.s	.End				; If not, branch
00004BA6 4238 C7CF                  		clr.b	rPalCycIndex.w		; Reset the palette cycle index
00004BAA                            
00004BAA                            .End:
00004BAA 4E75                       		rts
00004BAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BAC                            PalCyc_WWZFloor:
00004BAC 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004BB6                            PalCyc_WWZFloorUW:
00004BB6 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004BC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC0                            ; Animated art routines
00004BC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC0                            Level_AniArtRouts:
00004BC0 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004BC4 0000 0000                  		dc.l	AniArt_WWZ
00004BC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC8                            ; Wacky Workbench animated art routine
00004BC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC8                            AniArt_WWZ:
00004BC8 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004BCC 6000 F81E                  		bra.w	AniArt_DoAnimate		; Handle animations
00004BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD0                            .AniData:
00004BD0 0002                       		dc.w	2
00004BD2                            
00004BD2                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004BD2 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004BD6 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004BD8 0408                     M 	dc.b	4,8
00004BDA 0008 1018                  		dc.b	0, 8, $10, $18
00004BDE                            
00004BDE                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004BDE 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004BE2 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004BE4 0E04                     M 	dc.b	$e,4
00004BE6 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004BF4                            
00004BF4                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004BF4 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004BF8 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004BFA 0804                     M 	dc.b	8,4
00004BFC 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004C04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C04                            ; Level drawing initialization and update routines
00004C04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C04                            ; PARAMETERS:
00004C04                            ;	a1.l	- Camera RAM
00004C04                            ;	a3.l	- Row plane buffer
00004C04                            ;	a4.l	- Column plane buffer
00004C04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C04                            ; RETURNS:
00004C04                            ;	Nothing
00004C04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C04                            Level_RenderRouts:
00004C04 0000 27CC                  		dc.l	General_InitFG			; Wacky Workbench
00004C08 0000 0000                  		dc.l	WWZ_InitBG
00004C0C 0000 27EC                  		dc.l	General_UpdateFG
00004C10 0000 0000                  		dc.l	WWZ_UpdateBG
00004C14 0000 27CC                  		dc.l	General_InitFG
00004C18 0000 0000                  		dc.l	WWZ_InitBG
00004C1C 0000 27EC                  		dc.l	General_UpdateFG
00004C20 0000 0000                  		dc.l	WWZ_UpdateBG
00004C24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C24                            ; Wacky Workbench background initialization
00004C24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C24                            WWZ_InitBG:
00004C24 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004C28 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004C2C E440                       		asr.w	#2,d0				; Divide by $20
00004C2E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004C32                            
00004C32 6100 DED2                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004C36                            
00004C36 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004C3A 6000 DF2A                  		bra.w	ScrollSections			; Scroll the planes
00004C3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C3E                            ; Wacky Workbench background update
00004C3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C3E                            WWZ_UpdateBG:
00004C3E 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004C42 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004C46 E440                       		asr.w	#2,d0				; Divide by $20
00004C48 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004C4C                            
00004C4C 6100 DF0A                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004C50 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004C52 6100 DCAA                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004C56                            
00004C56 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004C5A 6000 DF0A                  		bra.w	ScrollSections			; Scroll the planes
00004C5E                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004C5E                            		scrollInit WWZ_Scroll
00004C5E                          M scroll_label	equs	"wwz_scroll"
00004C5E 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004C60                            
00004C60                            		; CEILING LIGHTS
00004C60                            		scrollSection	 48, $80
00004C60 0080 0000 0030           M 	dc.w	$80,0,48
00004C66                            		scrollSection	 32, $60
00004C66 0060 0000 0020           M 	dc.w	$60,0,32
00004C6C                            		scrollSection	 32, $50
00004C6C 0050 0000 0020           M 	dc.w	$50,0,32
00004C72                            		scrollSection	 24, $40
00004C72 0040 0000 0018           M 	dc.w	$40,0,24
00004C78                            		scrollSection	 24, $38
00004C78 0038 0000 0018           M 	dc.w	$38,0,24
00004C7E                            		scrollSection	 16, $30
00004C7E 0030 0000 0010           M 	dc.w	$30,0,16
00004C84                            		scrollSection	 16, $2C
00004C84 002C 0000 0010           M 	dc.w	$2c,0,16
00004C8A                            		scrollSection	 16, $28
00004C8A 0028 0000 0010           M 	dc.w	$28,0,16
00004C90                            		scrollSection	 16, $24
00004C90 0024 0000 0010           M 	dc.w	$24,0,16
00004C96                            		scrollSection	 16, $20
00004C96 0020 0000 0010           M 	dc.w	$20,0,16
00004C9C                            
00004C9C                            		; BACK WALL
00004C9C                            		scrollSection	160, $40
00004C9C 0040 0000 00A0           M 	dc.w	$40,0,160
00004CA2                            
00004CA2                            		; FRONT WALL
00004CA2                            		scrollSection	368, $80
00004CA2 0080 0000 0170           M 	dc.w	$80,0,368
00004CA8                            
00004CA8                            		scrollEnd
00004CA8                          M wwz_scroll_end:
00004CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA8                            ; Wacky Workbench level data
00004CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA8                            WWZ_Layout:
00004CA8                            		incbin	"Zones/Wacky Workbench/Layout.bin"
00004E86                            		even
00004E86                            WWZ_Chunks:
00004E86                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
000058D6                            		even
000058D6                            WWZ_Blocks:
000058D6                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
00005F9C                            		even
00005F9C                            WWZ_Tiles:
00005F9C                            		incbin	"Zones/Wacky Workbench/Tiles.kosm.bin"
000076CA                            		even
000076CA FFFF 0000 0000             		dc.w	$FFFF, 0, 0
000076D0                            WWZ_Objects:
000076D0                            		incbin	"Zones/Wacky Workbench/Objects.bin"
0000788C                            		even
0000788C                            WWZ_Rings:
0000788C                            		incbin	"Zones/Wacky Workbench/Rings.bin"
00007B5C                            		even
00007B5C                            WWZ_Pal:
00007B5C 007F                       		dc.w	$100>>1-1
00007B5E                            		incbin	"Zones/Wacky Workbench/Palette.pal.bin"
00007BDE                            		incbin	"Zones/Wacky Workbench/Palette (Water).pal.bin"
00007C5E                            		even
00007C5E                            WWZ_Collision:
00007C5E 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
00007C6E                            .ColData:
00007C6E                            		incbin	"Zones/Wacky Workbench/Collision.bin"
0000826E                            		even
0000826E                            .Angles:
0000826E                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
0000836E                            		even
0000836E                            .Heights:
0000836E                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
0000936E                            		even
0000936E                            .HeightsR:
0000936E                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
0000A36E                            		even
0000A36E                            ArtUnc_Electricity:
0000A36E                            		incbin	"Zones/Wacky Workbench/Electricity.bin"
0000A76E                            		even
0000A76E                            ArtUnc_ElectricOrbs:
0000A76E                            		incbin	"Zones/Wacky Workbench/Electric Orbs.bin"
0000A96E                            		even
0000A96E                            ArtUnc_Sirens:
0000A96E                            		incbin	"Zones/Wacky Workbench/Sirens.bin"
0000AB6E                            		even
0000AB6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB6E                            ; Main level PLCs
0000AB6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB6E                            PLC_LevelMain:
0000AB6E 000A                       		dc.w	$A
0000AB70 0000 0000                  		dc.l	ArtKosM_Chkpoint
0000AB74 AFC0                       		dc.w	$AFC0
0000AB76 0000 0000                  		dc.l	ArtKosM_Monitor
0000AB7A B100                       		dc.w	$B100
0000AB7C 0000 0000                  		dc.l	ArtKosM_SpringH
0000AB80 B740                       		dc.w	$B740
0000AB82 0000 0000                  		dc.l	ArtKosM_SpringV
0000AB86 B940                       		dc.w	$B940
0000AB88 0000 0000                  		dc.l	ArtKosM_SpringD
0000AB8C BB20                       		dc.w	$BB20
0000AB8E 0000 0000                  		dc.l	ArtKosM_HUD
0000AB92 D000                       		dc.w	$D000
0000AB94 0000 0000                  		dc.l	ArtKosM_WaterSurface
0000AB98 D200                       		dc.w	$D200
0000AB9A 0000 0000                  		dc.l	ArtKosM_SpikesN
0000AB9E D500                       		dc.w	$D500
0000ABA0 0000 0000                  		dc.l	ArtKosM_SpikesS
0000ABA4 D580                       		dc.w	$D580
0000ABA6 0000 0000                  		dc.l	ArtKosM_RingSparkle
0000ABAA D700                       		dc.w	$D700
0000ABAC 0000 0000                  		dc.l	ArtKosM_Explosion
0000ABB0 D800                       		dc.w	$D800
0000ABB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABB2                            ; Level PLCs
0000ABB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABB2                            Level_PLCs:
0000ABB2 0000 0000                  		dc.l	PLC_WWZ
0000ABB6 0000 0000                  		dc.l	PLC_WWZ
0000ABBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABBA                            ; Wacky Workbench PLCs
0000ABBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABBA                            PLC_WWZ:
0000ABBA 0000                       		dc.w	0
0000ABBC 0000 0000                  		dc.l	ArtKosM_Bumper
0000ABC0 6B60                       		dc.w	$6B60
0000ABC2                            	;	dc.l	ArtKosM_Orbinaut
0000ABC2                            	;	dc.w	$71A0
0000ABC2                            	;	dc.l	ArtKosM_Diamond
0000ABC2                            	;	dc.w	$7580
0000ABC2                            	;	dc.l	ArtKosM_CNZBarrel
0000ABC2                            	;	dc.w	$7A00
0000ABC2                            	;	dc.l	ArtKosM_Slicer
0000ABC2                            	;	dc.w	$8000
0000ABC2                            	;	dc.l	ArtKosM_ShlCrker
0000ABC2                            	;	dc.w	$8400
0000ABC2                            	;	dc.l	ArtKosM_Asteron
0000ABC2                            	;	dc.w	$8880
0000ABC2                            	;	dc.l	ArtKosM_Harpoon
0000ABC2                            	;	dc.w	$8A60
0000ABC2                            	;	dc.l	ArtKosM_WFZBoss
0000ABC2                            	;	dc.w	$9000
0000ABC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABC2                            ; Art
0000ABC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000ABC2                            ArtKosM_HUD:
0000ABC2                            		incbin	"Objects/HUD/Art - HUD Base.kosm.bin"
0000AC38                            		even
0000AC38                            ArtKosM_RingSparkle:
0000AC38                            		incbin	"Objects/Ring/Art - Sparkle.kosm.bin"
0000AC84 00                         		even
0000AC84                            ArtUnc_Ring:
0000AC84                            		incbin	"Objects/Ring/Art - Ring.unc.bin"
0000B084                            		even
0000B084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B084                            ; Object index
0000B084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B084                            Level_ObjIndex:
0000B084 0000 0000                  		dc.l	ObjMonitor
0000B088 0000 0000                  		dc.l	ObjSpike
0000B08C 0000 0000                  		dc.l	ObjSpring
0000B090 0000 0000                  		dc.l	ObjCheckpoint
0000B094 0000 0000                  		dc.l	ObjNull			;ObjSlicer
0000B098 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
0000B09C 0000 0000                  		dc.l	ObjNull			;ObjAsteron
0000B0A0 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
0000B0A4 0000 0000                  		dc.l	ObjWallSpring
0000B0A8 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
0000B0AC 0000 0000                  		dc.l	ObjBallMode
0000B0B0 0000 0000                  		dc.l	ObjBumper
0000B0B4 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
0000B0B8 0000 0000                  		dc.l	ObjNull			;ObjDiamond
0000B0BC 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
0000B0C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C0                            ; Objects
0000B0C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C0                            ObjNull:
0000B0C0 4EF8 1A72                  		jmp	DeleteObject
0000B0C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C4                            		include	"Objects/Player/Code.asm"		; Player object
0000B0C4                            ; =========================================================================================================================================================
0000B0C4                            ; Sonic object
0000B0C4                            ; =========================================================================================================================================================
0000B0C4 =00000600                  TOP_SPD		EQU	$600				; Top speed
0000B0C4 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
0000B0C4 =00000080                  DEC_SPD		EQU	$80				; Deceleration
0000B0C4 =00000680                  JUMP_HEIGHT	EQU	$680				; Jump height
0000B0C4 =00000400                  MIN_JMP_HEIGHT	EQU	$400				; Minimum jump height
0000B0C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C4                            		rsset	oLvlSSTs
0000B0C4 =00000030                  oInitColH	rs.b	1				; Initial collision height
0000B0C4 =00000031                  oInitColW	rs.b	1				; Initial collision width
0000B0C4 =00000032                  oTopSolid	rs.b	1				; Top solid bit
0000B0C4 =00000033                  oLRBSolid	rs.b	1				; LRB solid bit
0000B0C4 =00000034                  oTopSpd		rs.w	1				; Top speed
0000B0C4 =00000036                  oAcc		rs.w	1				; Acceleration
0000B0C4 =00000038                  oDec		rs.w	1				; Deceleration
0000B0C4 =0000003A                  oFlipDir	rs.w	0				; Flip direction
0000B0C4 =0000003A                  oGVel		rs.w	1				; Ground velocity
0000B0C4 =0000003C                  oInteract	rs.w	1				; Interacted object space pointer
0000B0C4 =0000003E                  oAirTimer	rs.b	1				; Air timer
0000B0C4 =0000003F                  oMoveLock	rs.b	1				; Move lock timer
0000B0C4 =00000040                  oJumping	rs.b	1				; Jumping flag
0000B0C4 =00000041                  oAngle		rs.b	1				; Angle
0000B0C4 =00000042                  oInvulTime	rs.b	1				; Invulnerability timer
0000B0C4 =00000043                  oDeathTimer	rs.b	1				; Death timer
0000B0C4 =00000044                  oScrlDelay	rs.b	1				; Look up and down scroll delay counter
0000B0C4 =00000045                  oDashFlag	rs.b	1				; Dash flags
0000B0C4 =00000046                  oDashTimer	rs.b	1				; Dash timer
0000B0C4 =00000047                  oFlipAngle	rs.b	1				; Flip angle about the X axis
0000B0C4 =00000048                  oFlipTurned	rs.b	1				; Inverted flip flag
0000B0C4 =00000049                  oFlipRemain	rs.b	1				; Remaining flips to do
0000B0C4 =0000004A                  oFlipSpeed	rs.b	1				; Flip speed
0000B0C4 =0000004B                  oBallMode	rs.b	1				; Ball mode flag
0000B0C4 =0000004C                  oHangAniTime	rs.b	1				; Hang animation timer
0000B0C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C4                            ObjPlayer:
0000B0C4 7000                       		moveq	#0,d0
0000B0C6 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0000B0CA 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0000B0CE                            	nextObject
0000B0CE 3068 0004                M 	movea.w	onext(a0),a0
0000B0D2 2250                     M 	move.l	oaddr(a0),a1
0000B0D4 4ED1                     M 	jmp	(a1)
0000B0D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0D6                            .Index:
0000B0D6 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
0000B0DA 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
0000B0DE 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
0000B0E2 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
0000B0E6 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
0000B0EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0EA                            ; Initialization routine
0000B0EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0EA                            ObjPlayer_Init:
0000B0EA 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0000B0EE                            
0000B0EE 117C 0009 002C             		move.b	#9,oColW(a0)			; Collision width
0000B0F4 117C 0013 002D             		move.b	#$13,oColH(a0)			; Collision height
0000B0FA 1168 002C 0031             		move.b	oColW(a0),oInitColW(a0)		; Set initial collision width
0000B100 1168 002D 0030             		move.b	oColH(a0),oInitColH(a0)		; Set initial collision height
0000B106 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,oMap(a0)		; Mappings
0000B10E 317C 0780 000E             		move.w	#$780,oVRAM(a0)			; Sprite tile properties
0000B114                            	displaySprite	2,a0,a1,0			; Priority
0000B114 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000B11A 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000B11E 3149 000A                M 	move.w	a1,odrawprev(a0)
0000B122 3348 0008                M 	move.w	a0,odrawnext(a1)
0000B126 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000B12A                          M .no_205
0000B12A 117C 0018 0017             		move.b	#$18,oDrawW(a0)			; Sprite width
0000B130 117C 0018 001B             		move.b	#$18,oDrawH(a0)			; Sprite height
0000B136 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0000B13C                            
0000B13C 117C 000C 0032             		move.b	#$C,oTopSolid(a0)		; Top solid bit
0000B142 117C 000D 0033             		move.b	#$D,oLRBSolid(a0)		; LRB solid bit
0000B148 117C 001E 003E             		move.b	#$1E,oAirTimer(a0)		; Set air timer
0000B14E 50D0                       		st	oPrevDPLC(a0)			; Reset saved DPLC frame
0000B150 4228 0049                  		clr.b	oFlipRemain(a0)			; No flips remaining
0000B154 117C 0004 004A             		move.b	#4,oFlipSpeed(a0)		; Flip speed
0000B15A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B15A                            ; Main routine
0000B15A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B15A                            ObjPlayer_Main:
0000B15A 4A38 C768                  		tst.b	rMoveCheat.w
0000B15E 6700                       		beq.s	.NoPlacementEnter
0000B160 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000B166 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000B168 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000B16E 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000B174 4E75                       		rts
0000B176                            
0000B176                            .NoPlacementEnter:
0000B176 0828 0002 000C             		btst	#2,oFlags(a0)			; Are the controls locked?
0000B17C 6600                       		bne.s	.Update				; If so, branch
0000B17E 31F8 C740 F8D4             		move.w	rP1Data.w,rCtrl.w		; Set the player's control data
0000B184                            
0000B184                            .Update:
0000B184                            	;	btst	#1,oStatus(a0)
0000B184                            	;	bne.s	.NotOnGround
0000B184                            
0000B184                            ;.NotOnGround:
0000B184 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
0000B188 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
0000B18C 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
0000B190 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
0000B194 4EB8 4944                  		jsr	PlayerDoObjCollision		; Do object collision
0000B198                            
0000B198 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
0000B19C 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
0000B1A0 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000B1A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1A4                            ; Handle the extended camera
0000B1A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1A4                            ObjPlayer_ExtendedCam:
0000B1A4 3238 F8D2                  		move.w	rCamXPosCenter.w,d1		; Get camera X center
0000B1A8 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B1AC 6A00                       		bpl.s	.PosGVel			; Get absolute value
0000B1AE 4440                       		neg.w	d0				; ''
0000B1B0                            
0000B1B0                            .PosGVel:
0000B1B0 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
0000B1B4 6500                       		bcs.s	.ResetXShift			; If not, branch
0000B1B6 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000B1BA 6A00                       		bpl.s	.MoveRight			; If so, branch
0000B1BC 5441                       		addq.w	#2,d1				; Move right
0000B1BE 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
0000B1C2 6500                       		bcs.s	.SetShift			; ''
0000B1C4 323C 00E0                  		move.w	#$E0,d1				; ''
0000B1C8 6000                       		bra.s	.SetShift			; Continue
0000B1CA                            
0000B1CA                            .MoveRight:
0000B1CA 5541                       		subq.w	#2,d1				; Move left
0000B1CC 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
0000B1D0 6400                       		bcc.s	.SetShift			; ''
0000B1D2 323C 0060                  		move.w	#$60,d1				; ''
0000B1D6 6000                       		bra.s	.SetShift			; Continue
0000B1D8                            
0000B1D8                            .ResetXShift:
0000B1D8 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
0000B1DC 6700                       		beq.s	.SetShift			; If so, branch
0000B1DE 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
0000B1E0 5441                       		addq.w	#2,d1				; Move back right
0000B1E2 6000                       		bra.s	.SetShift			; Continue
0000B1E4                            
0000B1E4                            .ReduceShift:
0000B1E4 5541                       		subq.w	#2,d1				; Move back left
0000B1E6                            
0000B1E6                            .SetShift:
0000B1E6 31C1 F8D2                  		move.w	d1,rCamXPosCenter.w		; Set camera X center
0000B1EA 4E75                       		rts
0000B1EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1EC                            ; Update Sonic's physics
0000B1EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1EC                            ObjPlayer_GetPhysics:
0000B1EC 7000                       		moveq	#0,d0
0000B1EE 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000B1F4 6700                       		beq.s	.GetOffset			; If not, branch
0000B1F6 7008                       		moveq	#8,d0				; Set the underwater bit
0000B1F8                            
0000B1F8                            .GetOffset:
0000B1F8 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
0000B1FC 2159 0034                  		move.l	(a1)+,oTopSpd(a0)		; Set top speed and acceleration
0000B200 3151 0038                  		move.w	(a1),oDec(a0)			; Set deceleration
0000B204 4E75                       		rts
0000B206                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B206                            ; Physics values
0000B206                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B206                            ; FORMAT:
0000B206                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
0000B206                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B206                            ObjPlayer_Physics:
0000B206 0600 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
0000B20E 0300 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
0000B216                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B216                            ; Handle Sonic in the water
0000B216                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B216                            ObjPlayer_Water:
0000B216 4A38 F8F4                  	tst.b	rWaterFlag.w			; Is there water in the level?
0000B21A 6600                       	bne.s	.HandleWater			; If so, branch
0000B21C                            
0000B21C                            .End:
0000B21C 4E75                       	rts
0000B21E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B21E                            .HandleWater:
0000B21E 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
0000B222 B068 0018                  		cmp.w	oYPos(a0),d0			; Is Lover in the water?
0000B226 6C00                       		bge.s	.NotInWater			; If not, branch
0000B228                            
0000B228 08E8 0006 0028             		bset	#6,oStatus(a0)			; Set the "in water" flag
0000B22E 66EC                       		bne.s	.End				; If Lover is already in the water, branch
0000B230                            
0000B230 E0E8 001C                  		asr.w	oXVel(a0)			; Make Lover move slower
0000B234 E0E8 001E                  		asr.w	oYVel(a0)
0000B238 E0E8 001E                  		asr.w	oYVel(a0)
0000B23C 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
0000B23E                            
0000B23E                            		playSnd	#sSplash, 2			; Play splash sound
0000B23E 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B244 4E75                       		rts
0000B246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B246                            .NotInWater:
0000B246 08A8 0006 0028             		bclr	#6,oStatus(a0)			; Clear "in water" flag
0000B24C 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
0000B24E                            
0000B24E 0C28 0010 0025             		cmpi.b	#$10,oRoutine(a0)			; Is Lover falling back from getting hurt?
0000B254 6700                       		beq.s	.ChkSplash			; If so, branch
0000B256 E1E8 001E                  		asl	oYVel(a0)			; Make Lover move faster vertically
0000B25A                            
0000B25A                            .ChkSplash:
0000B25A 4A68 001E                  		tst.w	oYVel(a0)			; Does a splash need to be created?
0000B25E 67BC                       		beq.s	.End				; If not, branch
0000B260                            
0000B260 0C68 F000 001E             		cmpi.w	#-$1000,oYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
0000B266 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
0000B268 317C F000 001E             		move.w	#-$1000,oYVel(a0)		; Cap the speed
0000B26E                            
0000B26E                            .PlaySplashSnd:
0000B26E                            		playSnd	#sSplash, 2			; Play splash sound
0000B26E 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B274 4E75                       		rts
0000B276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B276                            ; Do Sonic's modes
0000B276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B276                            ObjPlayer_DoModes:
0000B276 0828 0000 000C             		btst	#0,oFlags(a0)			; Is running Sonic's mode disabled?
0000B27C 6600                       		bne.s	.NoMode				; If so, branch
0000B27E                            
0000B27E 7000                       		moveq	#0,d0
0000B280 1028 0028                  		move.b	oStatus(a0),d0			; Get status
0000B284 0240 0006                  		andi.w	#6,d0				; Only get mode bits
0000B288 D040                       		add.w	d0,d0
0000B28A 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
0000B28E                            
0000B28E 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
0000B292 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
0000B296 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
0000B29A 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
0000B29E                            
0000B29E                            .NoMode:
0000B29E 4E75                       		rts
0000B2A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2A0                            ; Sonic's modes
0000B2A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2A0                            ObjPlayer_Modes:
0000B2A0 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
0000B2A4 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
0000B2A8 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
0000B2AC 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
0000B2B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2B0                            ; Ground mode
0000B2B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2B0                            ObjPlayer_MdGround:
0000B2B0 6100 0000                  		bsr.w	ObjPlayer_Peelout		; Handle the peelout
0000B2B4 6100 0000                  		bsr.w	ObjPlayer_Spindash		; Handle the spindash
0000B2B8 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
0000B2BC 6100 0000                  		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
0000B2C0 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
0000B2C4 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
0000B2C8 4EB8 32BC                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B2CC                            
0000B2CC 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
0000B2D0 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B2D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2D4                            ; Misc. updates
0000B2D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2D4                            ObjPlayer_MiscUpdates:
0000B2D4 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer finished?
0000B2D8 6700                       		beq.s	.NoMoveLock			; If so, branch
0000B2DA 5328 003F                  		subq.b	#1,oMoveLock(a0)		; Decrement the timer
0000B2DE                            
0000B2DE                            .NoMoveLock:
0000B2DE 4EB8 2FD4                  		jsr	sub_F846
0000B2E2 4A41                       		tst.w	d1
0000B2E4 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
0000B2E8 4EB8 3264                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
0000B2EC 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B2EE 6A00                       		bpl.s	.ChkRight			; If not, branch
0000B2F0 9368 0014                  		sub.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B2F4                            
0000B2F4                            .ChkRight:
0000B2F4 4EB8 30E8                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
0000B2F8 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B2FA 6A00                       		bpl.s	.End				; If not, branch
0000B2FC D368 0014                  		add.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B300                            
0000B300                            .End:
0000B300 4E75                       		rts
0000B302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B302                            ; Air and jump modes
0000B302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B302                            ObjPlayer_MdJump:
0000B302                            ObjPlayer_MdAir:
0000B302 4268 003C                  		clr.w	oInteract(a0)			; Sonic cannot be interacting with objects while in midair
0000B306 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; ''
0000B30C                            
0000B30C 0828 0003 000C             		btst	#3,oFlags(a0)			; Is Sonic hanging?
0000B312 6700                       		beq.s	.DoModes			; If not, branch
0000B314 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
0000B318 6000                       		bra.s	.DoCol				; Continue
0000B31A                            
0000B31A                            .DoModes:
0000B31A 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
0000B31E 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
0000B322 4EB8 1D66                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000B326 0C68 1000 001E             		cmpi.w	#$1000,oYVel(a0)		; Is Sonic moving down too fasr?
0000B32C 6F00                       		ble.s	.NoCap				; If not, branch
0000B32E 317C 1000 001E             		move.w	#$1000,oYVel(a0)		; Cap the downward speed
0000B334                            
0000B334                            .NoCap:
0000B334 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
0000B338                            
0000B338                            .DoCol:
0000B338 0828 0006 0028             		btst	#6,oStatus(a0)
0000B33E 6700                       		beq.s	.NoWater
0000B340 0468 0028 001E             		subi.w	#$28,oYVel(a0)
0000B346                            
0000B346                            .NoWater:
0000B346 4EB8 2C42                  		jsr	PlayerChkCollision		; Check for level collision
0000B34A 6088                       		bra.s	ObjPlayer_MiscUpdates
0000B34C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B34C                            ; Roll mode
0000B34C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B34C                            ObjPlayer_MdRoll:
0000B34C 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B350 6600                       		bne.s	.NoJump				; If so, branch
0000B352 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
0000B356                            
0000B356                            .NoJump:
0000B356 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
0000B35A 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
0000B35E 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
0000B362 4EB8 32BC                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B366                            
0000B366 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B36A 6000 FF68                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
0000B36E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B36E                            ; Do movement on the ground
0000B36E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B36E                            ObjPlayer_MoveGround:
0000B36E 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B372 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B376 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B37A                            
0000B37A 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B37E 6600 0000                  		bne.w	.ResetScr			; If so, branch
0000B382                            
0000B382 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left held?
0000B388 6700                       		beq.s	.NotLeft			; If so, branch
0000B38A 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
0000B38E                            
0000B38E                            .NotLeft:
0000B38E 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right held?
0000B394 6700                       		beq.s	.NotRight			; If so, branch
0000B396 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
0000B39A                            
0000B39A                            .NotRight:
0000B39A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B39E 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B3A2 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000B3A6 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
0000B3AA 4A68 003A                  		tst.w	oGVel(a0)			; Has Sonic already been halted?
0000B3AE 6600 0000                  		bne.w	.ResetScr			; If not, branch
0000B3B2                            
0000B3B2 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B3B8 117C 0005 0020             		move.b	#5,oAni(a0)			; Set to ducking animation
0000B3BE                            
0000B3BE 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is Sonic standing on an object?
0000B3C4 6700 0000                  		beq.w	.ChkBalance			; If not, branch
0000B3C8 3268 003C                  		movea.w	oInteract(a0),a1		; Get interacted object
0000B3CC 4A29 0028                  		tst.b	oStatus(a1)			; Is Sonic standing on it?
0000B3D0 6B00                       		bmi.s	.ChkLookUp			; If not, branch
0000B3D2 7200                       		moveq	#0,d1
0000B3D4 1229 002C                  		move.b	oColW(a1),d1			; Get width of object
0000B3D8 3401                       		move.w	d1,d2				; Copy it
0000B3DA D442                       		add.w	d2,d2				; Double the copy
0000B3DC 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
0000B3DE D268 0014                  		add.w	oXPos(a0),d1			; Add Sonic's X position
0000B3E2 9269 0014                  		sub.w	oXPos(a1),d1			; Subtract the object's X position
0000B3E6 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
0000B3EA 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
0000B3EC B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
0000B3EE 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
0000B3F0 6000                       		bra.s	.ChkLookUp			; Continue
0000B3F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3F2                            .ChkBalance:
0000B3F2 4EB8 2FAA                  		jsr	PlayerChkFloorDist		; Get floor distance
0000B3F6 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
0000B3FA 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000B3FC 0C28 0003 002E             		cmpi.b	#3,oNextTilt(a0)		; Is Sonic balancing on the right side?
0000B402 6600                       		bne.s	.ChkLeftBalance			; If not, branch
0000B404                            
0000B404                            .BalanceOnObjRight:
0000B404 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B40A 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000B40C                            
0000B40C                            .ChkLeftBalance:
0000B40C 0C28 0003 002F             		cmpi.b	#3,oTilt(a0)			; Is Sonic balancing on the left side?
0000B412 6600                       		bne.s	.ChkLookUp			; If not, branch
0000B414                            
0000B414                            .BalanceOnObjLeft:
0000B414 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B41A                            
0000B41A                            .SetBalanceAnim:
0000B41A 117C 0006 0020             		move.b	#6,oAni(a0)			; Set balancing animation
0000B420 6000                       		bra.s	.ResetScr			; Continue
0000B422                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B422                            .ChkLookUp:
0000B422 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is the up button being held?
0000B428 6700                       		beq.s	.ChkDown			; If not, branch
0000B42A 117C 0007 0020             		move.b	#7,oAni(a0)			; Set to looking up animation
0000B430                            
0000B430 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B434 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B43A 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B43C 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B442 0C78 00C8 F8CC             		cmpi.w	#200,rCamYPosDist.w		; Has the camera finished scrolling?
0000B448 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B44A 5478 F8CC                  		addq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B44E 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B450                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B450                            .ChkDown:
0000B450 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is the down button being held?
0000B456 6700                       		beq.s	.ResetScr			; If not, branch
0000B458 117C 0008 0020             		move.b	#8,oAni(a0)			; Set to ducking animation
0000B45E                            
0000B45E 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B462 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B468 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B46A 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B470 0C78 0008 F8CC             		cmpi.w	#8,rCamYPosDist.w		; Has the camera finished scrolling?
0000B476 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B478 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B47C 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B47E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B47E                            .ResetScr:
0000B47E 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000B482                            
0000B482                            .ResetScrPart2:
0000B482 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B488 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B48A 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B48C 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B490                            
0000B490                            .ScrollUp:
0000B490 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B494                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B494                            .UpdateSpdOnGround:
0000B494 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000B498 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000B49C 6600                       		bne.s	.ApplySpeed			; If so, branch
0000B49E                            
0000B49E 3028 003A                  		move.w	oGVel(a0),d0			; Get current ground velocity
0000B4A2 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
0000B4A4 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
0000B4A6                            
0000B4A6                            .SettleRight:
0000B4A6 9045                       		sub.w	d5,d0				; Slow down
0000B4A8 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
0000B4AA 7000                       		moveq	#0,d0				; Stop the movement
0000B4AC 6000                       		bra.s	.SetSpeed			; Continue
0000B4AE                            
0000B4AE                            .SettleLeft:
0000B4AE D045                       		add.w	d5,d0				; Slow down
0000B4B0 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
0000B4B2 7000                       		moveq	#0,d0				; Stop the movement
0000B4B4                            
0000B4B4                            .SetSpeed:
0000B4B4 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B4B8                            
0000B4B8                            .ApplySpeed:
0000B4B8 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B4BC 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
0000B4C0 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B4C4 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B4C8 E081                       		asr.l	#8,d1				; Shift the values over
0000B4CA E080                       		asr.l	#8,d0				; ''
0000B4CC 3141 001C                  		move.w	d1,oXVel(a0)			; Set the X velocity
0000B4D0 3140 001E                  		move.w	d0,oYVel(a0)			; Set the Y velocity
0000B4D4                            
0000B4D4                            ObjPlayer_CheckWalls:
0000B4D4 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B4D8 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
0000B4DC 6700                       		beq.s	.Skip				; If not, branch
0000B4DE 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B4E2 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
0000B4E6 6B00                       		bmi.s	.End				; If so, branch
0000B4E8                            
0000B4E8                            .Skip:
0000B4E8 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
0000B4EA 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000B4EE 6700                       		beq.s	.End				; Branch if not moving
0000B4F0 6B00                       		bmi.s	.CheckPush			; Branch if going left
0000B4F2 4441                       		neg.w	d1				; Negate the modifier
0000B4F4                            
0000B4F4                            .CheckPush:
0000B4F4 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B4F8 D001                       		add.b	d1,d0				; Add modifier
0000B4FA                            		push.w	d0				; Save it
0000B4FA 3F00                     M 	move.w	d0,-(sp)
0000B4FC 4EB8 2E72                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
0000B500                            		pop.w	d0				; Restore angle
0000B500 301F                     M 	move.w	(sp)+,d0
0000B502 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
0000B504 6A00                       		bpl.s	.End				; If not, branch
0000B506 E141                       		asl.w	#8,d1				; Shift distance inside the collision
0000B508 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000B50C 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
0000B510 6700                       		beq.s	.PushCeiling			; If so, branch
0000B512 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
0000B516 6700                       		beq.s	.PushRightWall			; If so, branch
0000B518 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000B51C 6700                       		beq.s	.PushFloor			; If so, branch
0000B51E D368 001C                  		add.w	d1,oXVel(a0)			; Push out to the right
0000B522 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B526 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing right?
0000B52C 6600                       		bne.s	.End				; If not, branch
0000B52E 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B534 4E75                       		rts
0000B536                            
0000B536                            .PushFloor:
0000B536 9368 001E                  		sub.w	d1,oYVel(a0)			; Push out upwards
0000B53A 4E75                       		rts
0000B53C                            
0000B53C                            .PushRightWall:
0000B53C 9368 001C                  		sub.w	d1,oXVel(a0)			; Push out to the left
0000B540 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B544 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B54A 6700                       		beq.s	.End				; If not, branch
0000B54C 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B552 4E75                       		rts
0000B554                            
0000B554                            .PushCeiling:
0000B554 D368 001E                  		add.w	d1,oYVel(a0)			; Push out downwards
0000B558                            
0000B558                            .End:
0000B558 4E75                       		rts
0000B55A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B55A                            ; Move left on the ground
0000B55A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B55A                            ObjPlayer_MoveLeft:
0000B55A 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B55E 6700                       		beq.s	.SetFlip			; If not moving yet, branch
0000B560 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
0000B562                            
0000B562                            .SetFlip:
0000B562 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B568 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000B56A 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B570 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B576                            
0000B576                            .MoveLeft:
0000B576 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B578 3206                       		move.w	d6,d1				; Get top speed
0000B57A 4441                       		neg.w	d1				; Negate it
0000B57C B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
0000B57E 6E00                       		bgt.s	.SetSpeed			; If not, branch
0000B580 D045                       		add.w	d5,d0				; Add acceleration back
0000B582 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
0000B584 6F00                       		ble.s	.SetSpeed			; If not, branch
0000B586 3001                       		move.w	d1,d0				; Cap at the top speed
0000B588                            
0000B588                            .SetSpeed:
0000B588 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B58C 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B590                            
0000B590                            .End:
0000B590 4E75                       		rts
0000B592                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B592                            .Skid:
0000B592 9044                       		sub.w	d4,d0				; Subtract deceleration
0000B594 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B596                            
0000B596                            .Compare:
0000B596 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B598 6C00                       		bge.s	.SetSkidSpeed			; If not branch
0000B59A 7080                       		moveq	#-$80,d0			; Set speed to -$80
0000B59C                            
0000B59C                            .SetSkidSpeed:
0000B59C 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B5A0 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B5A4 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B5A8 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B5AC 66E2                       		bne.s	.End				; If so, branch
0000B5AE 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
0000B5B2 6DDC                       		blt.s	.End				; If not, branch
0000B5B4 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B5BA 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B5C0                            		playSnd	#sSkid, 2			; Play skid sound
0000B5C0 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B5C6 4E75                       		rts
0000B5C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B5C8                            ; Move right on the ground
0000B5C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B5C8                            ObjPlayer_MoveRight:
0000B5C8 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B5CC 6B00                       		bmi.s	.Skid				; If it's negative, skid
0000B5CE 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B5D4 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
0000B5D6 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B5DC 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B5E2                            
0000B5E2                            .MoveRight:
0000B5E2 D045                       		add.w	d5,d0				; Add acceleration
0000B5E4 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B5E6 6D00                       		blt.s	.SetSpeed			; If not, branch
0000B5E8 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B5EA B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
0000B5EC 6C00                       		bge.s	.SetSpeed			; If not, branch
0000B5EE 3006                       		move.w	d6,d0				; Cap at top speed
0000B5F0                            
0000B5F0                            .SetSpeed:
0000B5F0 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B5F4 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B5F8                            
0000B5F8                            .End:
0000B5F8 4E75                       		rts
0000B5FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B5FA                            .Skid:
0000B5FA D044                       		add.w	d4,d0				; Add deceleration
0000B5FC 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B5FE                            
0000B5FE                            .Compare:
0000B5FE B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B600 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
0000B602 303C 0080                  		move.w	#$80,d0				; Set speed to $80
0000B606                            
0000B606                            .SetSkidSpeed:
0000B606 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B60A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B60E 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B612 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B616 66E0                       		bne.s	.End				; If so, branch
0000B618 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000B61C 6EDA                       		bgt.s	.End				; If not, branch
0000B61E 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B624 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B62A                            		playSnd	#sSkid, 2			; Play skid sound
0000B62A 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B630 4E75                       		rts
0000B632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B632                            ; Do movement while rolling
0000B632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B632                            ObjPlayer_MoveRoll:
0000B632 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B636 E346                       		asl.w	#1,d6				; ''
0000B638 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B63C E245                       		asr.w	#1,d5				; ''
0000B63E 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B642 E444                       		asr.w	#2,d4				; ''
0000B644                            
0000B644 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B648 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000B64C                            
0000B64C 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B652 6700                       		beq.s	.ChkRight			; If not, branch
0000B654 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
0000B658                            
0000B658                            .ChkRight:
0000B658 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B65E 6700                       		beq.s	.Decelerate			; If not, branch
0000B660 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
0000B664                            
0000B664                            .Decelerate:
0000B664 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B668 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
0000B66A 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000B66C                            
0000B66C 9045                       		sub.w	d5,d0				; Decelerate
0000B66E 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B670 7000                       		moveq	#0,d0				; Cap at 0
0000B672                            
0000B672                            .SetGVel:
0000B672 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B676 6000                       		bra.s	.ChkStop			; Continue
0000B678                            
0000B678                            .DecLeft:
0000B678 D045                       		add.w	d5,d0				; Decelerate
0000B67A 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000B67C 7000                       		moveq	#0,d0				; Cap at 0
0000B67E                            
0000B67E                            .SetGVel2:
0000B67E 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B682                            
0000B682                            .ChkStop:
0000B682 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic still moving?
0000B686 6600                       		bne.s	.UpdateSpd			; If so, branch
0000B688                            
0000B688 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B68C 6600                       		bne.s	.KeepRoll			; If so, branch
0000B68E 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Stop rolling
0000B694 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B69A 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B6A0 117C 0005 0020             		move.b	#5,oAni(a0)			; Use standing animation
0000B6A6 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B6AA 6000                       		bra.s	.UpdateSpd			; Continue
0000B6AC                            
0000B6AC                            .KeepRoll:
0000B6AC 317C 0400 003A             		move.w	#$400,oGVel(a0)			; Speed up again
0000B6B2 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing right?
0000B6B8 6700                       		beq.s	.UpdateSpd			; If so, branch
0000B6BA 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B6BE                            
0000B6BE                            .UpdateSpd:
0000B6BE 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B6C2 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
0000B6C6 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B6CA E080                       		asr.l	#8,d0				; Shift over
0000B6CC 3140 001E                  		move.w	d0,oYVel(a0)			; Set Y velocity
0000B6D0 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B6D4 E081                       		asr.l	#8,d1				; Shift over
0000B6D6                            
0000B6D6 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
0000B6DA 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000B6DC 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000B6E0                            
0000B6E0                            .ChkLeftSpd:
0000B6E0 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
0000B6E4 6C00                       		bge.s	.SetXVel			; If not, branch
0000B6E6 323C F000                  		move.w	#-$1000,d1			; Cap the speed
0000B6EA                            
0000B6EA                            .SetXVel:
0000B6EA 3141 001C                  		move.w	d1,oXVel(a0)			; Set X velocity
0000B6EE 6000 FDE4                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
0000B6F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B6F2                            ; Handle left movement for rolling
0000B6F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B6F2                            ObjPlayer_RollLeft:
0000B6F2 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B6F6 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
0000B6F8 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
0000B6FA                            
0000B6FA                            .SetLeft:
0000B6FA 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B700 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B706 4E75                       		rts
0000B708                            
0000B708                            .Dec:
0000B708 9044                       		sub.w	d4,d0				; Decelerate
0000B70A 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B70C 303C FF80                  		move.w	#-$80,d0			; Set new speed
0000B710                            
0000B710                            .SetGVel:
0000B710 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B714 4E75                       		rts
0000B716                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B716                            ; Handle left movement for rolling
0000B716                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B716                            ObjPlayer_RollRight:
0000B716 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B71A 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
0000B71C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B722 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B728 4E75                       		rts
0000B72A                            
0000B72A                            .Dec:
0000B72A D044                       		add.w	d4,d0				; Decelerate
0000B72C 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B72E 303C 0080                  		move.w	#$80,d0				; Set new speed
0000B732                            
0000B732                            .SetGVel:
0000B732 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B736 4E75                       		rts
0000B738                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B738                            ; Do movement in the air
0000B738                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B738                            ObjPlayer_MoveAir:
0000B738 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B73C 3A28 0036                  		move.w	oAcc(a0),d5			; Get accleration
0000B740 DA45                       		add.w	d5,d5				; Double it
0000B742 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B746                            
0000B746 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B74C 6700                       		beq.s	.NotLeft			; If not, branch
0000B74E 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B754 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B756 3206                       		move.w	d6,d1				; Get top speed
0000B758 4441                       		neg.w	d1				; Negate it
0000B75A B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000B75C 6E00                       		bgt.s	.NotLeft			; If not, branch
0000B75E D045                       		add.w	d5,d0				; Add acceleration back
0000B760 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000B762 6F00                       		ble.s	.NotLeft			; If not, branch
0000B764 3001                       		move.w	d1,d0				; Cap at top speed
0000B766                            
0000B766                            .NotLeft:
0000B766 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B76C 6700                       		beq.s	.NotRight			; If not, branch
0000B76E 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B774 D045                       		add.w	d5,d0				; Add acceleration
0000B776 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B778 6D00                       		blt.s	.NotRight			; If not, branch
0000B77A 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B77C B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000B77E 6C00                       		bge.s	.NotRight			; If not, branch
0000B780 3006                       		move.w	d6,d0				; Cap at top speed
0000B782                            
0000B782                            .NotRight:
0000B782 3140 001C                  		move.w	d0,oXVel(a0)			; Set X velocity
0000B786                            
0000B786                            .ResetScr
0000B786 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B78C 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000B78E 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B790 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B794                            
0000B794                            .ScrollUp:
0000B794 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B798                            
0000B798                            .DecelerateAtPeak:
0000B798 0C68 FC00 001E             		cmpi.w	#-$400,oYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000B79E 6500                       		bcs.s	.End				; If not, branch
0000B7A0 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B7A4 3200                       		move.w	d0,d1				; Save it
0000B7A6 EA41                       		asr.w	#5,d1				; Turn it into the acceleration
0000B7A8 6700                       		beq.s	.End				; If it's 0, branch
0000B7AA 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000B7AC                            
0000B7AC                            .DecRight:
0000B7AC 9041                       		sub.w	d1,d0				; Subtract accleration
0000B7AE 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000B7B0 7000                       		moveq	#0,d0				; Cap at 0
0000B7B2 6000                       		bra.s	.DecSetSpeed			; Continue
0000B7B4                            
0000B7B4                            .DecLeft:
0000B7B4 9041                       		sub.w	d1,d0				; Subtract acceleration
0000B7B6 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
0000B7B8 7000                       		moveq	#0,d0				; Cap at 0
0000B7BA                            
0000B7BA                            .DecSetSpeed:
0000B7BA 3140 001C                  		move.w	d0,oXVel(a0)			; Set thhe X velocity
0000B7BE                            
0000B7BE                            .End:
0000B7BE 4E75                       		rts
0000B7C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7C0                            ; Handle level boundaries
0000B7C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7C0                            ObjPlayer_LvlBound:
0000B7C0 4A68 001E                  		tst.w	oYVel(a0)
0000B7C4 6A00                       		bpl.s	.XBound
0000B7C6 3228 0018                  		move.w	oYPos(a0),d1
0000B7CA 0641 0010                  		addi.w	#$10,d1
0000B7CE 3038 F8CA                  		move.w	rMinCamY.w,d0		; Get upper boundary position
0000B7D2 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
0000B7D4 6F00                       		ble.s	.XBound				; If so, branch
0000B7D6 3140 0018                  		move.w	d0,oYPos(a0)
0000B7DA 4268 001E                  		clr.w	oYVel(a0)
0000B7DE 4268 003A                  		clr.w	oGVel(a0)
0000B7E2                            
0000B7E2                            .XBound:
0000B7E2 2228 0014                  		move.l	oXPos(a0),d1			; Get X position
0000B7E6 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B7EA 48C0                       		ext.l	d0
0000B7EC E180                       		asl.l	#8,d0				; Shift it
0000B7EE D280                       		add.l	d0,d1				; Add to X position
0000B7F0 4841                       		swap	d1				; Get actual X position
0000B7F2 3038 F8C8                  		move.w	rMinCamX.w,d0		; Get left boundary position
0000B7F6 0640 0010                  		addi.w	#$10,d0				; ''
0000B7FA B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
0000B7FC 6E00                       		bgt.s	.TouchedSide			; If so, branch
0000B7FE 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Get max camera X position
0000B802 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000B806 B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
0000B808 6F00                       		ble.s	.TouchedSide			; If so, branch
0000B80A                            
0000B80A                            .ChkBottom:
0000B80A 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
0000B80E 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
0000B812 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000B816 6D00                       		blt.s	.TouchedBottom			; If so, branch
0000B818 4E75                       		rts
0000B81A                            
0000B81A                            .TouchedBottom:
0000B81A 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get target max camera Y position
0000B81E 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Get current max camera Y position
0000B822 B240                       		cmp.w	d0,d1				; Are they the same?
0000B824 6D00                       		blt.s	.NoKill				; If not, branch
0000B826 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
0000B82A                            
0000B82A                            .NoKill:
0000B82A 4E75                       		rts
0000B82C                            
0000B82C                            .TouchedSide:
0000B82C 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
0000B830 3140 0014                  		move.w	d0,oXPos(a0)			; Move Sonic out of the boundary
0000B834 4228 0016                  		clr.b	oXPos+2(a0)			; Clear the subpixel of the X position
0000B838 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B83C 60CC                       		bra.s	.ChkBottom			; Continue
0000B83E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B83E                            ; Handle peelout
0000B83E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B83E                            ObjPlayer_Peelout:
0000B83E 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the peelout?
0000B842 6700                       		beq.s	.ChkUp				; If not, branch
0000B844 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000B846 4E75                       		rts
0000B848                            
0000B848                            .ChkUp:
0000B848 0C28 0007 0020             		cmpi.b	#7,oAni(a0)			; Is Sonic looking up?
0000B84E 6600 0000                  		bne.w	.End				; If not, branch
0000B852 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B856 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B85A 6700 0000                  		beq.w	.End				; If not, branch
0000B85E                            
0000B85E 4228 0020                  		clr.b	oAni(a0)			; Set to peelout charge animation
0000B862 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B866 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B86C 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B872 6700                       		beq.s	.SetAni				; If so, branch
0000B874 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B878                            
0000B878                            .SetAni:
0000B878                            		playSnd	#sCharge, 2			; Play charge sound
0000B878 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B87E                            
0000B87E 588F                       		addq.l	#4,sp				; Don't return to caller
0000B880 50E8 0045                  		st	oDashFlag(a0)			; Set the peelout flag
0000B884 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B888                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B888                            .ChkLaunch:
0000B888 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is up being held?
0000B88E 6600 0000                  		bne.w	.Charge				; If so, branch
0000B892 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B896                            
0000B896 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged up enough?
0000B89C 6600                       		bne.s	.StopSound			; If not, branch
0000B89E                            
0000B89E 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000B8A2 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B8A8 0828 0006 0028             		btst	#6,oStatus(a0)
0000B8AE 6700                       		beq.s	.NoWater
0000B8B0 E2E8 003A                  		lsr.w	oGVel(a0)
0000B8B4                            
0000B8B4                            .NoWater:
0000B8B4 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B8BA 6700                       		beq.s	.FinishDash			; If not, branch
0000B8BC 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B8C0                            
0000B8C0                            .FinishDash:
0000B8C0                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B8C0 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B8C6                            
0000B8C6 6000                       		bra.s	.DoUpdates			; Continue
0000B8C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8C8                            .Charge:
0000B8C8 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged enough?
0000B8CE 6700                       		beq.s	.DoUpdates			; If so, branch
0000B8D0 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B8D4 0668 0066 003A             		addi.w	#$66,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B8DA 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B8E0 6700                       		beq.s	.DoUpdates			; If so, branch
0000B8E2 0468 00CC 003A             		subi.w	#$66*2,oGVel(a0)		; Go the other way
0000B8E8 6000                       		bra.s	.DoUpdates			; Continue
0000B8EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8EA                            .StopSound:
0000B8EA 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B8EE                            
0000B8EE                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B8EE 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B8F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8F4                            .DoUpdates:
0000B8F4 588F                       		addq.l	#4,sp				; Don't return to caller
0000B8F6 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B8FC 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B8FE 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B900 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B904                            
0000B904                            .ScrollUp:
0000B904 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B908                            
0000B908                            .FinishUpdates:
0000B908 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B90C                            
0000B90C                            .End:
0000B90C 4E75                       		rts
0000B90E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B90E                            ; Handle spindash
0000B90E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B90E                            ObjPlayer_Spindash:
0000B90E 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the spindash?
0000B912 6700                       		beq.s	.ChkDown			; If not, branch
0000B914 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000B916 4E75                       		rts
0000B918                            
0000B918                            .ChkDown:
0000B918 0C28 0008 0020             		cmpi.b	#8,oAni(a0)			; Is Sonic ducking?
0000B91E 6600 0000                  		bne.w	.End				; If not, branch
0000B922 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B926 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B92A 6700 0000                  		beq.w	.End				; If not, branch
0000B92E                            
0000B92E 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B932 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B938 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B93E 6700                       		beq.s	.SetAni				; If so, branch
0000B940 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B944                            
0000B944                            .SetAni:
0000B944 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B94A 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B950 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B954 117C 0002 0020             		move.b	#2,oAni(a0)			; Set to spin animation
0000B95A                            
0000B95A                            		playSnd	#sCharge, 2			; Play charge sound
0000B95A 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B960                            
0000B960 588F                       		addq.l	#4,sp				; Don't return to caller
0000B962 117C 0001 0045             		move.b	#1,oDashFlag(a0)		; Set the spindash flag
0000B968 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B96C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B96C                            .ChkLaunch:
0000B96C 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000B972 6600 0000                  		bne.w	.Charge				; If so, branch
0000B976 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B97A                            
0000B97A 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged up enough?
0000B980 6600                       		bne.s	.StopSound			; If not, branch
0000B982                            
0000B982 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set the roll flag
0000B988 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B98E 0828 0006 0028             		btst	#6,oStatus(a0)
0000B994 6700                       		beq.s	.NoWater
0000B996 E2E8 003A                  		lsr.w	oGVel(a0)
0000B99A                            
0000B99A                            .NoWater:
0000B99A 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B9A0 6700                       		beq.s	.FinishDash			; If not, branch
0000B9A2 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B9A6                            
0000B9A6                            .FinishDash:
0000B9A6                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B9A6 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B9AC                            
0000B9AC 6000                       		bra.s	.DoUpdates			; Continue
0000B9AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9AE                            .Charge:
0000B9AE 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged enough?
0000B9B4 6700                       		beq.s	.DoUpdates			; If so, branch
0000B9B6 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B9BA 0668 0046 003A             		addi.w	#$46,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B9C0 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B9C6 6700                       		beq.s	.DoUpdates			; If so, branch
0000B9C8 0468 008C 003A             		subi.w	#$46*2,oGVel(a0)		; Go the other way
0000B9CE 6000                       		bra.s	.DoUpdates			; Continue
0000B9D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9D0                            .StopSound:
0000B9D0 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B9D4 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B9DA 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B9E0 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B9E4                            
0000B9E4                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B9E4 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B9EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9EA                            .DoUpdates:
0000B9EA 588F                       		addq.l	#4,sp				; Don't return to caller
0000B9EC 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B9F2 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B9F4 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B9F6 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B9FA                            
0000B9FA                            .ScrollUp:
0000B9FA 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B9FE                            
0000B9FE                            .FinishUpdates:
0000B9FE 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000BA02                            
0000BA02                            .End:
0000BA02 4E75                       		rts
0000BA04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA04                            ; Check for jumping
0000BA04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA04                            ObjPlayer_ChkJump:
0000BA04 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get pressed buttons
0000BA08 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000BA0C 4A38 C768                  		tst.b	rMoveCheat.w
0000BA10 6700                       		beq.s	.NoDebug
0000BA12 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000BA16                            
0000BA16                            .NoDebug:
0000BA16 4A00                       		tst.b	d0
0000BA18 6700 0000                  		beq.w	.End				; If not, branch
0000BA1C                            
0000BA1C 7000                       		moveq	#0,d0
0000BA1E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BA22 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
0000BA26 4EB8 2EE4                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000BA2A 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
0000BA2E 6D00 0000                  		blt.w	.End				; If not, branch
0000BA32                            
0000BA32 343C 0680                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
0000BA36 0828 0006 0028             		btst	#6,oStatus(a0)
0000BA3C 6700                       		beq.s	.NoWater
0000BA3E 0442 0300                  		subi.w	#$300,d2
0000BA42                            
0000BA42                            .NoWater:
0000BA42 7000                       		moveq	#0,d0
0000BA44 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BA48 0400 0040                  		subi.b	#$40,d0				; Shift it
0000BA4C 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
0000BA50 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
0000BA52 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
0000BA54 E081                       		asr.l	#8,d1				; Shift the values over
0000BA56 E080                       		asr.l	#8,d0				; ''
0000BA58 D368 001C                  		add.w	d1,oXVel(a0)			; Add to X velocity
0000BA5C D168 001E                  		add.w	d0,oYVel(a0)			; Add to Y velocity
0000BA60 0028 0006 0028             		ori.b	#6,oStatus(a0)			; Set "in air" and roll flags
0000BA66 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000BA6C 584F                       		addq.w	#4,sp				; Do not return to collaer
0000BA6E 50E8 0040                  		st	oJumping(a0)			; Set the jumping flag
0000BA72                            		playSnd	#sLeap, 2			; Play jump sound
0000BA72 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
0000BA78 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BA7E 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BA84 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BA88 117C 0002 0020             		move.b	#2,oAni(a0)			; Set jumping animation
0000BA8E                            
0000BA8E                            .End:
0000BA8E 4E75                       		rts
0000BA90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA90                            ; Handle variable jumping
0000BA90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA90                            ObjPlayer_JumpHeight:
0000BA90 4A28 0040                  		tst.b	oJumping(a0)			; Is Sonic jumping?
0000BA94 6700                       		beq.s	.UpVelCap			; If not, branch
0000BA96                            
0000BA96 323C FC00                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
0000BA9A B268 001E                  		cmp.w	oYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000BA9E 6F00                       		ble.s	.End				; If not, branch
0000BAA0 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BAA4 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000BAA8 4A38 C768                  		tst.b	rMoveCheat.w
0000BAAC 6700                       		beq.s	.NoDebug
0000BAAE 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000BAB2                            
0000BAB2                            .NoDebug:
0000BAB2 4A00                       		tst.b	d0
0000BAB4 6600                       		bne.s	.End				; If not, branch
0000BAB6 3141 001E                  		move.w	d1,oYVel(a0)			; Set to minimum height
0000BABA                            
0000BABA                            .End:
0000BABA 4E75                       		rts
0000BABC                            
0000BABC                            .UpVelCap:
0000BABC 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000BAC0 66F8                       		bne.s	.End				; If so, branch
0000BAC2 0C68 F040 001E             		cmpi.w	#-$FC0,oYVel(a0)		; Cap Y velocity at -$FC0 when going up
0000BAC8 6CF0                       		bge.s	.End				; ''
0000BACA 317C F040 001E             		move.w	#-$FC0,oYVel(a0)		; ''
0000BAD0 4E75                       		rts
0000BAD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD2                            ; Gradually reset Sonic's angle in mid air
0000BAD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD2                            ObjPlayer_JumpAngle:
0000BAD2 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BAD6 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
0000BAD8 6A00                       		bpl.s	.Decrease			; If it's positive, branch
0000BADA                            
0000BADA                            .Increase:
0000BADA 5400                       		addq.b	#2,d0				; Increase angle
0000BADC 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
0000BADE 7000                       		moveq	#0,d0				; Reset the angle
0000BAE0 6000                       		bra.s	.SetAngle
0000BAE2                            
0000BAE2                            .Decrease:
0000BAE2 5500                       		subq.b	#2,d0				; Decrease angle
0000BAE4 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000BAE6 7000                       		moveq	#0,d0				; Reset the angle
0000BAE8                            
0000BAE8                            .SetAngle:
0000BAE8 1140 0041                  		move.b	d0,oAngle(a0)			; Set the new angle
0000BAEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAEC                            ; Update Sonic's angle while he's tumbling in the air
0000BAEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAEC                            ObjPlayer_JumpFlip:
0000BAEC 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000BAF0 6700                       		beq.s	.End				; If it's 0, branch
0000BAF2 4A68 003A                  		tst.w	oFlipDir(a0)			; Is Sonic flipping left?
0000BAF6 6B00                       		bmi.s	.FlipLeft			; IF so, branch
0000BAF8                            
0000BAF8                            .FlipRight:
0000BAF8 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BAFC D001                       		add.b	d1,d0				; Add to angle
0000BAFE 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BB00 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BB04 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BB06 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BB0A 7000                       		moveq	#0,d0				; Reset angle
0000BB0C 6000                       		bra.s	.FlipSet			; Continue
0000BB0E                            
0000BB0E                            .FlipLeft:
0000BB0E 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is the flipping inverted?
0000BB12 66E4                       		bne.s	.FlipRight			; If so, branch
0000BB14 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BB18 9001                       		sub.b	d1,d0				; Subtract from angle
0000BB1A 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BB1C 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BB20 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BB22 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BB26 7000                       		moveq	#0,d0				; Reset angle
0000BB28                            
0000BB28                            .FlipSet:
0000BB28 1140 0047                  		move.b	d0,oFlipAngle(a0)		; Update the angle
0000BB2C                            
0000BB2C                            .End:
0000BB2C 4E75                       		rts
0000BB2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB2E                            ; Check for rolling
0000BB2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB2E                            ObjPlayer_ChkRoll:
0000BB2E 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000BB32 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000BB34 4440                       		neg.w	d0				; ''
0000BB36                            
0000BB36                            .ChkSpd:
0000BB36 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
0000BB3A 6500                       		bcs.s	.NoRoll				; If not, branch
0000BB3C 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BB40 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000BB44 6600                       		bne.s	.NoRoll				; If not, branch
0000BB46 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000BB4C 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
0000BB4E                            
0000BB4E                            .NoRoll:
0000BB4E 4E75                       		rts
0000BB50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB50                            ; Make Sonic roll
0000BB50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB50                            ObjPlayer_DoRoll:
0000BB50 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BB56 6600                       		bne.s	.End				; If so, branch
0000BB58 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BB5E                            
0000BB5E 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BB64 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BB6A 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BB6E 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BB74                            
0000BB74 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving already?
0000BB78 6600                       		bne.s	.End				; IF not, branch
0000BB7A 317C 0200 003A             		move.w	#$200,oGVel(a0)			; Set speed
0000BB80                            
0000BB80                            .End:
0000BB80 4E75                       		rts
0000BB82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB82                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
0000BB82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB82                            ObjPlayer_SlopePush:
0000BB82 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB86 0600 0060                  		addi.b	#$60,d0				; Shift it
0000BB8A 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
0000BB8E 6400                       		bcc.s	.End				; If not, branch
0000BB90 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB94 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
0000BB98 C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000BB9C E080                       		asr.l	#8,d0				; Shift it
0000BB9E 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000BBA2 6700                       		beq.s	.End				; If Sonic is not moving, branch
0000BBA4 D168 003A                  		add.w	d0,oGVel(a0)			; Add to ground velocity
0000BBA8                            
0000BBA8                            .End:
0000BBA8 4E75                       		rts
0000BBAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BBAA                            ; Check if Sonic is to fall off a slope
0000BBAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BBAA                            ObjPlayer_FallOffSlope:
0000BBAA 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer, active?
0000BBAE 6600                       		bne.s	.End				; If so, branch
0000BBB0 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BBB4 0600 0020                  		addi.b	#$20,d0				; Shift it
0000BBB8 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000BBBC 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000BBBE 3028 003A                  		move.w	oGVel(a0),d0			; Get speed
0000BBC2 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
0000BBC4 4440                       		neg.w	d0				; Force it to be positive
0000BBC6                            
0000BBC6                            .ChkSpeed:
0000BBC6 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
0000BBCA 6400                       		bcc.s	.End				; If so, branch
0000BBCC 4268 003A                  		clr.w	oGVel(a0)			; Stop movement
0000BBD0 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000BBD6 117C 001E 003F             		move.b	#$1E,oMoveLock(a0)		; Set move lock timer
0000BBDC                            
0000BBDC                            .End:
0000BBDC 4E75                       		rts
0000BBDE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BBDE                            ; Affect Sonic's speed on slopes while rolling
0000BBDE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BBDE                            ObjPlayer_RollSlopePush:
0000BBDE 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BBE2 0600 0060                  		addi.b	#$60,d0				; ''
0000BBE6 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000BBEA 6400                       		bcc.s	.End				; If not, branch
0000BBEC                            
0000BBEC 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BBF0 4EB8 1374                  		jsr	CalcSine.w			; Get sine
0000BBF4 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
0000BBF8 E080                       		asr.l	#8,d0				; Shift over
0000BBFA                            
0000BBFA 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000BBFE 6B00                       		bmi.s	.PushLeft			; If not, branch
0000BC00 4A40                       		tst.w	d0				; Is the push speed positive?
0000BC02 6A00                       		bpl.s	.Push				; If so, branch
0000BC04 E480                       		asr.l	#2,d0				; Shift over more
0000BC06                            
0000BC06                            .Push:
0000BC06 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BC0A 4E75                       		rts
0000BC0C                            
0000BC0C                            .PushLeft:
0000BC0C 4A40                       		tst.w	d0				; Is the push speed negative?
0000BC0E 6B00                       		bmi.s	.Push2				; If so, branch
0000BC10 E480                       		asr.l	#2,d0				; Shift over more
0000BC12                            
0000BC12                            .Push2:
0000BC12 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BC16                            
0000BC16                            .End:
0000BC16 4E75                       		rts
0000BC18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BC18                            ; Check for bouncy floor collision
0000BC18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BC18                            ObjPlayer_ChkBounce:
0000BC18 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
0000BC1C 6700 0000                  		beq.w	.End				; If so, branch
0000BC20                            
0000BC20 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic in the air?
0000BC26 6700                       		beq.s	.ChkDown			; If not, branch
0000BC28                            
0000BC28 4A68 001E                  		tst.w	oYVel(a0)			; Is Sonic falling?
0000BC2C 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
0000BC30 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
0000BC34                            
0000BC34                            .ChkDown:
0000BC34 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BC38 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC3C 4880                       		ext.w	d0				; ''
0000BC3E D440                       		add.w	d0,d2				; ''
0000BC40 5442                       		addq.w	#2,d2				; ''
0000BC42 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BC46 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC4A 4880                       		ext.w	d0				; ''
0000BC4C 9640                       		sub.w	d0,d3				; ''
0000BC4E 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BC52 3011                       		move.w	(a1),d0				; ''
0000BC54 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC58 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC5C 6700                       		beq.s	.Bounce				; If so, branch
0000BC5E                            
0000BC5E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BC62 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC66 4880                       		ext.w	d0				; ''
0000BC68 D440                       		add.w	d0,d2				; ''
0000BC6A 5442                       		addq.w	#2,d2				; ''
0000BC6C 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BC70 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC74 4880                       		ext.w	d0				; ''
0000BC76 D640                       		add.w	d0,d3				; ''
0000BC78 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BC7C 3011                       		move.w	(a1),d0				; ''
0000BC7E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC82 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC86 6600                       		bne.s	.End				; If not, branch
0000BC88                            
0000BC88                            .Bounce:
0000BC88 317C EA00 001E             		move.w	#-$1600,oYVel(a0)		; Bounce Sonic up
0000BC8E 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BC94 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BC98 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BC9C 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BCA0                            
0000BCA0                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BCA0 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BCA6                            
0000BCA6 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BCAC 6600                       		bne.s	.End				; If so, branch
0000BCAE 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BCB4 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BCBA 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BCC0 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BCC4 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BCCA                            
0000BCCA                            .End:
0000BCCA 4E75                       		rts
0000BCCC                            
0000BCCC                            .ChkBounceUp:
0000BCCC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BCD0 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BCD4 4880                       		ext.w	d0				; ''
0000BCD6 9440                       		sub.w	d0,d2				; ''
0000BCD8 5542                       		subq.w	#2,d2				; ''
0000BCDA 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BCDE 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BCE2 4880                       		ext.w	d0				; ''
0000BCE4 9640                       		sub.w	d0,d3				; ''
0000BCE6 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BCEA 3011                       		move.w	(a1),d0				; ''
0000BCEC 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BCF0 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BCF4 6700                       		beq.s	.BounceUp			; If so, branch
0000BCF6                            
0000BCF6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BCFA 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BCFE 4880                       		ext.w	d0				; ''
0000BD00 9440                       		sub.w	d0,d2				; ''
0000BD02 5542                       		subq.w	#2,d2				; ''
0000BD04 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BD08 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BD0C 4880                       		ext.w	d0				; ''
0000BD0E D640                       		add.w	d0,d3				; ''
0000BD10 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BD14 3011                       		move.w	(a1),d0				; ''
0000BD16 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD1A 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BD1E 66AA                       		bne.s	.End				; If not, branch
0000BD20                            
0000BD20                            .BounceUp:
0000BD20 588F                       		addq.l	#4,sp				; Don't return to caller
0000BD22                            
0000BD22 317C 1600 001E             		move.w	#$1600,oYVel(a0)		; Bounce Sonic up
0000BD28 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BD2E 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BD32 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BD36 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BD3A                            
0000BD3A                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BD3A 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BD40                            
0000BD40 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BD46 6600                       		bne.s	.End2				; If so, branch
0000BD48 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BD4E 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BD54 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BD5A 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BD5E 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BD64                            
0000BD64                            .End2:
0000BD64 4E75                       		rts
0000BD66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD66                            ; Check for bars to hang on to
0000BD66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD66                            ObjPlayer_ChkHang:
0000BD66 0828 0003 000C             		btst	#3,oFlags(a0)			; Are we already hanging?
0000BD6C 6600                       		bne.s	.End				; If so, branch
0000BD6E                            
0000BD6E 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BD72 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BD76 0442 0018                  		subi.w	#$18,d2				; ''
0000BD7A 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BD7E 3011                       		move.w	(a1),d0				; ''
0000BD80 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD84 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BD88 6600                       		bne.s	.End				; If not, branch
0000BD8A                            
0000BD8A 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
0000BD90 42A8 001C                  		clr.l	oXVel(a0)			; Stop movement
0000BD94 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BD98 08E8 0003 000C             		bset	#3,oFlags(a0)			; Set hanging flag
0000BD9E 117C 000A 0020             		move.b	#$A,oAni(a0)			; Set hanging animation
0000BDA4 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Animation timer
0000BDAA 3028 0018                  		move.w	oYPos(a0),d0			; Align with bar
0000BDAE 0440 0018                  		subi.w	#$18,d0				; ''
0000BDB2 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
0000BDB6 0640 0018                  		addi.w	#$18,d0				; ''
0000BDBA 3140 0018                  		move.w	d0,oYPos(a0)			; ''
0000BDBE 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000BDC2 08A8 0001 000D             		bclr	#1,oRender(a0)			; ''
0000BDC8                            
0000BDC8                            .End:
0000BDC8 4E75                       		rts
0000BDCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDCA                            ; Hang onto the bars
0000BDCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDCA                            ObjPlayer_Hang:
0000BDCA 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BDCE 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BDD2 0442 0018                  		subi.w	#$18,d2				; ''
0000BDD6 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BDDA 3011                       		move.w	(a1),d0				; ''
0000BDDC 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BDE0 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BDE4 6600                       		bne.s	.FallOff			; If not, branch
0000BDE6 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get control press bits
0000BDEA 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
0000BDEE 6700                       		beq.s	.MoveX				; If not, branch
0000BDF0                            
0000BDF0                            .FallOff:
0000BDF0 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BDF6 0668 0010 0018             		addi.w	#$10,oYPos(a0)			; Fall off
0000BDFC 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000BE02 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000BE08 4E75                       		rts
0000BE0A                            
0000BE0A                            .MoveX:
0000BE0A 7002                       		moveq	#2,d0				; X speed
0000BE0C 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Are we going left?
0000BE12 6700                       		beq.s	.ChkRight			; If not, branch
0000BE14 4440                       		neg.w	d0				; Go the other way
0000BE16 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face to the left
0000BE1C 08E8 0000 000D             		bset	#0,oRender(a0)			; ''
0000BE22 6000                       		bra.s	.DoMove				; Continue
0000BE24                            
0000BE24                            .ChkRight:
0000BE24 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Are we going left?
0000BE2A 6700                       		beq.s	.ResetScr			; If not, branch
0000BE2C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face to the right
0000BE32 08A8 0000 000D             		bclr	#0,oRender(a0)			; ''
0000BE38                            
0000BE38                            .DoMove:
0000BE38 D168 0014                  		add.w	d0,oXPos(a0)			; Move
0000BE3C 5328 004C                  		subq.b	#1,oHangAniTime(a0)		; Decrement animation timer
0000BE40 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
0000BE42 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Reset timer
0000BE48 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Increment animation frame
0000BE4C 0C28 0004 0022             		cmpi.b	#4,oAniFrame(a0)		; Have we reached the last one?
0000BE52 6500                       		bcs.s	.ResetScr			; If not, branch
0000BE54 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation frame
0000BE58                            
0000BE58                            .ResetScr:
0000BE58 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BE5C 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BE62 6700                       		beq.s	.End				; If so, branch
0000BE64 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BE66 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BE6A                            
0000BE6A                            .ScrollUp:
0000BE6A 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BE6E                            
0000BE6E                            .End:
0000BE6E 4E75                       		rts
0000BE70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE70                            ; Check for electricity
0000BE70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE70                            ObjPlayer_ChkElectric:
0000BE70 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BE74 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BE78 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000BE7C 3011                       		move.w	(a1),d0				; ''
0000BE7E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BE82                            
0000BE82 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
0000BE86 7C02                       		moveq	#2,d6				; ''
0000BE88                            
0000BE88                            .ChkBlocks:
0000BE88 B059                       		cmp.w	(a1)+,d0			; have we touched this block?
0000BE8A 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
0000BE8C 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000BE90 4E75                       		rts
0000BE92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE92 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
0000BE98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE98                            ; Get Sonic hurt
0000BE98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE98                            ObjPlayer_GetHurt:
0000BE98                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BE98 4A68 0008                M 	tst.w	odrawnext(a0)
0000BE9C 6600                     M 	bne.s	.no_221
0000BE9E 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BEA4 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BEA8 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BEAC 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BEB0 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BEB4                          M .no_221
0000BEB4 4A28 0042                  		tst.b	oInvulTime(a0)			; Are we invulnerable?
0000BEB8 6600 0000                  		bne.w	.End				; If so, branch
0000BEBC 4A78 F3D4                  		tst.w	rRings.w			; Does Sonic have any rings?
0000BEC0 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
0000BEC4 4EB8 1A1C                  		jsr	FindFreeObj.w
0000BEC8 6700                       		beq.s	.Hurt
0000BECA 22BC 0000 0000             		move.l	#ObjRingLoss,oAddr(a1)
0000BED0 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0000BED6 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000BEDC                            
0000BEDC                            .Hurt:
0000BEDC 117C 0008 0025             		move.b	#8,oRoutine(a0)			; Set to hurt routine
0000BEE2 4EB8 2E38                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BEE6 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BEEA 08A8 0000 000C             		bclr	#0,oFlags(a0)			; Allow modes
0000BEF0 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BEF6 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BEFC 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Set to hurt animation
0000BF02 117C 0078 0042             		move.b	#$78,oInvulTime(a0)		; Set invulnerable timer
0000BF08                            
0000BF08 317C FC00 001E             		move.w	#-$400,oYVel(a0)		; Make Sonic bounce away
0000BF0E 317C FE00 001C             		move.w	#-$200,oXVel(a0)		; ''
0000BF14 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BF1A 6700                       		beq.s	.ChkReverse			; If not, branch
0000BF1C 317C FE00 001E             		move.w	#-$200,oYVel(a0)		; Make Sonic bounce away slower
0000BF22 317C FF00 001C             		move.w	#-$100,oXVel(a0)
0000BF28                            
0000BF28                            .ChkReverse:
0000BF28 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0000BF2C B06A 0014                  		cmp.w	oXPos(a2),d0			; Is Sonic left of the object that hurt him?
0000BF30 6500                       		bcs.s	.ChkSnd				; If so, branch
0000BF32 4468 001C                  		neg.w	oXVel(a0)			; Make Sonic bounce the other way if on the right side
0000BF36                            
0000BF36                            .ChkSnd:
0000BF36 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000BF3A                            
0000BF3A                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BF3A                            	;	beq.s	.End				; If not, branch
0000BF3A                            		playSnd	#sHurt, 2			; Play hurt sound
0000BF3A 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
0000BF40                            
0000BF40                            .End:
0000BF40 70FF                       		moveq	#-1,d0				; Set return status
0000BF42 4E75                       		rts
0000BF44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF44                            ; Hurt routine
0000BF44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF44                            ObjPlayer_Hurt:
0000BF44 4A38 C768                  		tst.b	rMoveCheat.w
0000BF48 6700                       		beq.s	.NoPlacementEnter
0000BF4A 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BF50 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BF52 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BF58 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BF5E 4E75                       		rts
0000BF60                            
0000BF60                            .NoPlacementEnter:
0000BF60 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
0000BF64 0668 0030 001E             		addi.w	#$30,oYVel(a0)			; Apply gravity
0000BF6A 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BF70 6700                       		beq.s	.NotWater			; If not, branch
0000BF72 0468 0020 001E             		subi.w	#$20,oYVel(a0)			; Reduce gravity underwater
0000BF78                            
0000BF78                            .NotWater:
0000BF78 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Force the hurt animation
0000BF7E 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000BF80                            
0000BF80 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BF86 6700                       		beq.s	.Cont				; If so, branch
0000BF88 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BF8A 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BF8E                            
0000BF8E                            .ScrollUp:
0000BF8E 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BF92                            
0000BF92                            .Cont:
0000BF92 6100 F82C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
0000BF96 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
0000BF9A 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000BF9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF9E                            .ChkStop:
0000BF9E 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BFA2 0640 00E0                  		addi.w	#224,d0				; ''
0000BFA6 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BFAA 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
0000BFAC                            
0000BFAC 4EB8 2C42                  		jsr	PlayerChkCollision		; Check for level collision
0000BFB0 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic still in midair?
0000BFB6 6600                       		bne.s	.End				; If so, branch
0000BFB8                            
0000BFB8 7000                       		moveq	#0,d0
0000BFBA 3140 001E                  		move.w	d0,oYVel(a0)			; Stop Sonic's movement
0000BFBE 3140 001C                  		move.w	d0,oXVel(a0)			; ''
0000BFC2 3140 003A                  		move.w	d0,oGVel(a0)			; ''
0000BFC6 1140 000C                  		move.b	d0,oFlags(a0)			; Allow Sonic to move
0000BFCA 1140 0020                  		move.b	d0,oAni(a0)			; Reset animation
0000BFCE 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set back to main routine
0000BFD4                            
0000BFD4                            .End:
0000BFD4 4E75                       		rts
0000BFD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFD6                            ; Get Sonic killed
0000BFD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFD6                            ObjPlayer_GetKilled:
0000BFD6                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BFD6 4A68 0008                M 	tst.w	odrawnext(a0)
0000BFDA 6600                     M 	bne.s	.no_223
0000BFDC 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BFE2 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BFE6 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BFEA 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BFEE 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BFF2                          M .no_223
0000BFF2 117C 000C 0025             		move.b	#$C,oRoutine(a0)			; Set to the death routine
0000BFF8 4EB8 2E38                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BFFC 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000C000 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000C006 117C 0018 0020             		move.b	#$18,oAni(a0)			; Set to death animation
0000C00C                            
0000C00C 317C F900 001E             		move.w	#-$700,oYVel(a0)		; Make Sonic bounce up
0000C012 4268 001C                  		clr.w	oXVel(a0)			; Lock Sonic horizontally
0000C016 4268 003A                  		clr.w	oGVel(a0)			; ''
0000C01A 31FC FFFF F8CE             		move.w	#$FFFF,rCamLocked.w		; Lock the camera
0000C020                            
0000C020                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000C020                            	;	beq.s	.End				; If not, branch
0000C020                            		playSnd	#sDeath,2			; Play death sound
0000C020 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
0000C026                            
0000C026                            .End:
0000C026 70FF                       		moveq	#-1,d0				; Set return status
0000C028 4E75                       		rts
0000C02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C02A                            ; Death routine
0000C02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C02A                            ObjPlayer_Dead:
0000C02A 4A38 C768                  		tst.b	rMoveCheat.w
0000C02E 6700                       		beq.s	.NoPlacementEnter
0000C030 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000C036 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000C038 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000C03E 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000C044 4E75                       		rts
0000C046                            
0000C046                            .NoPlacementEnter:
0000C046 117C 0018 0020             		move.b	#$18,oAni(a0)			; Force the death animation
0000C04C 0068 8000 000E             		ori.w	#$8000,oVRAM(a0)		; Force high priority
0000C052 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
0000C054 4EB8 1D66                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000C058 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
0000C05C 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000C060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C060                            ObjPlayer_ChkBound:
0000C060 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000C064 0640 0100                  		addi.w	#$100,d0			; ''
0000C068 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000C06C 6C00                       		bge.s	.End				; If not, branch
0000C06E                            
0000C06E 117C 0010 0025             		move.b	#$10,oRoutine(a0)			; Go to gone routine
0000C074 117C 003C 0043             		move.b	#60,oDeathTimer(a0)		; Set death timer to 1 second
0000C07A                            
0000C07A                            .End:
0000C07A 4E75                       		rts
0000C07C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C07C                            ; Wait for level reload or game/time over
0000C07C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C07C                            ObjPlayer_Gone:
0000C07C 4A28 0043                  		tst.b	oDeathTimer(a0)
0000C080 6700                       		beq.s	.End
0000C082 5328 0043                  		subq.b	#1,oDeathTimer(a0)		; Decrement the death counter
0000C086 6600                       		bne.s	.End				; If it hasn't run out, branch
0000C088 50F8 F8FC                  		st	rLvlReload.w			; Reload the level
0000C08C                            
0000C08C                            .End:
0000C08C 4E75                       		rts
0000C08E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C08E                            ; Display Sonic's sprite
0000C08E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C08E                            ObjPlayer_Display:
0000C08E 1028 0042                  		move.b	oInvulTime(a0),d0		; Get invulnerability timer
0000C092 6700                       		beq.s	.Display			; If it's 0, branch
0000C094 5328 0042                  		subq.b	#1,oInvulTime(a0)		; Decrement invulnerability timer
0000C098 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
0000C09A 6500                       		bcs.s	.Display			; If so, branch
0000C09C                            	removeSprite	a0,a1,1				; Remove sprite if displayed
0000C09C 4A68 0008                M 	tst.w	odrawnext(a0)
0000C0A0 6700                     M 	beq.s	.yes_225
0000C0A2 3268 000A                M 	move.w	odrawprev(a0),a1
0000C0A6 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
0000C0AC 3268 0008                M 	move.w	odrawnext(a0),a1
0000C0B0 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
0000C0B6                          M .no_225
0000C0B6 42A8 0008                M 	clr.l	odrawnext(a0)
0000C0BA                          M .yes_225
0000C0BA 4E75                       		rts
0000C0BC                            
0000C0BC                            .Display:
0000C0BC                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
0000C0BC 4A68 0008                M 	tst.w	odrawnext(a0)
0000C0C0 6600                     M 	bne.s	.no_226
0000C0C2 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C0C8 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000C0CC 3149 000A                M 	move.w	a1,odrawprev(a0)
0000C0D0 3348 0008                M 	move.w	a0,odrawnext(a1)
0000C0D4 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C0D8                          M .no_226
0000C0D8 4E75                       		rts
0000C0DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0DA                            ; Load Sonic's DPLCs
0000C0DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0DA                            ObjPlayer_LoadDPLCs:
0000C0DA 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
0000C0E0 383C F000                  		move.w	#$F000,d4			; VRAM location
0000C0E4 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
0000C0EA 4EF8 1D0C                  		jmp	LoadObjDPLCs.w			; Load DPLCs
0000C0EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0EE                            ; Animate Sonic's sprite
0000C0EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0EE                            ObjPlayer_Animate:
0000C0EE 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
0000C0F4 7000                       		moveq	#0,d0
0000C0F6 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
0000C0FA B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
0000C0FE 6700                       		beq.s	.Run				; If not, branch
0000C100 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
0000C104 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C108 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C10C 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000C112                            
0000C112                            .Run:
0000C112 D040                       		add.w	d0,d0				; Turn ID into offset
0000C114 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
0000C118 1011                       		move.b	(a1),d0				; Get first byte
0000C11A 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
0000C11C 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C120 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
0000C124 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C12A 8328 000D                  		or.b	d1,oRender(a0)			; Set flip bits
0000C12E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C132 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C134 1140 0023                  		move.b	d0,oAniTimer(a0)		; Set new animation timer
0000C138                            
0000C138                            .GetFrame:
0000C138 7200                       		moveq	#0,d1
0000C13A 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
0000C13E 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
0000C142 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
0000C146 6400                       		bhs.s	.CmdReset			; If so, branch
0000C148                            
0000C148                            .Next:
0000C148 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
0000C14C 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
0000C150                            
0000C150                            .Wait:
0000C150 4E75                       		rts
0000C152                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C152                            .CmdReset:
0000C152 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
0000C154 6600                       		bne.s	.CmdJump			; If not, branch
0000C156 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C15A 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
0000C15E 60E8                       		bra.s	.Next				; Continue
0000C160                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C160                            .CmdJump:
0000C160 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
0000C162 6600                       		bne.s	.CmdSetAnim			; If not, branch
0000C164 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
0000C168 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
0000C16C 9200                       		sub.b	d0,d1				; ''
0000C16E 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
0000C172 60D4                       		bra.s	.Next				; Continue
0000C174                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C174                            .CmdSetAnim:
0000C174 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
0000C176 6600                       		bne.s	.CmdEnd				; If not, branch
0000C178 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
0000C17E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C17E                            .CmdEnd:
0000C17E 4E75                       		rts
0000C180                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C180                            .WalkRunAnim:
0000C180 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C184 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C186 5200                       		addq.b	#1,d0				; Is the animation walking/running?
0000C188 6600 0000                  		bne.w	.RollAnim			; If not, branch
0000C18C                            
0000C18C 7000                       		moveq	#0,d0
0000C18E 1028 0047                  		move.b	oFlipAngle(a0),d0		; Is Sonic tumbling in the air?
0000C192 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
0000C196                            
0000C196 7200                       		moveq	#0,d1				; Intial flip bits
0000C198 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000C19C 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
0000C19E 6700                       		beq.s	.ChkStatus			; If it's zero, branch
0000C1A0 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
0000C1A2                            
0000C1A2                            .ChkStatus:
0000C1A2 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C1A6 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
0000C1AA 6600                       		bne.s	.ChkFlip			; If so, branch
0000C1AC 4600                       		not.b	d0				; Reverse angle
0000C1AE                            
0000C1AE                            .ChkFlip:
0000C1AE 0600 0010                  		addi.b	#$10,d0				; Shift angle
0000C1B2 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
0000C1B4 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
0000C1B6                            
0000C1B6                            .SetFlags:
0000C1B6 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits
0000C1BC B302                       		eor.b	d1,d2				; Flip
0000C1BE 8528 000D                  		or.b	d2,oRender(a0)			; Set in render flags
0000C1C2                            
0000C1C2 0828 0005 0028             		btst	#5,oStatus(a0)			; Is Sonic pushing?
0000C1C8 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
0000C1CC                            
0000C1CC E808                       		lsr.b	#4,d0				; Divide angle by $10
0000C1CE 0200 0006                  		andi.b	#6,d0				; Get angle section
0000C1D2                            
0000C1D2 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C1D6 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
0000C1D8 4442                       		neg.w	d2				; Force it to be positive
0000C1DA                            
0000C1DA                            .GetAnim:
0000C1DA 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
0000C1E0 4A00                       		tst.b	d0
0000C1E2 6600                       		bne.s	.ChkRun
0000C1E4 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
0000C1E8 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C1EA                            
0000C1EA                            .ChkRun:
0000C1EA 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
0000C1F0 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
0000C1F4 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C1F6 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
0000C1FC 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
0000C1FE E209                       		lsr.b	#1,d1				; ''
0000C200 D001                       		add.b	d1,d0				; ''
0000C202                            
0000C202                            .SkipWalk:
0000C202 D000                       		add.b	d0,d0				; Double the offset
0000C204 1600                       		move.b	d0,d3				; Copy the oofset
0000C206 4442                       		neg.w	d2				; Get animation speed
0000C208 0642 0800                  		addi.w	#$800,d2			; ''
0000C20C 6A00                       		bpl.s	.SetTimer			; ''
0000C20E 7400                       		moveq	#0,d2				; ''
0000C210                            
0000C210                            .SetTimer:
0000C210 E04A                       		lsr.w	#8,d2				; ''
0000C212 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C216 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
0000C21A D728 0010                  		add.b	d3,oFrame(a0)			; Add angle offset
0000C21E 4E75                       		rts
0000C220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C220                            .TumbleAnim:
0000C220 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000C224 7200                       		moveq	#0,d1
0000C226 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C22A 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
0000C22E 6600                       		bne.s	.TumbleLeft			; If so, branch
0000C230                            
0000C230 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C236 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C23A 80FC 0016                  		divu.w	#$16,d0				; ''
0000C23E 0600 0068                  		addi.b	#$68,d0				; ''
0000C242 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C246 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C24A 4E75                       		rts
0000C24C                            
0000C24C                            .TumbleLeft:
0000C24C 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C252 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is flipping inverted?
0000C256 6700                       		beq.s	.NotInverted			; If not, branch
0000C258 0028 0001 000D             		ori.b	#1,oRender(a0)			; Face left
0000C25E 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C262 6000                       		bra.s	.SetLeftFrame			; Continue
0000C264                            
0000C264                            .NotInverted:
0000C264 0028 0003 000D             		ori.b	#3,oRender(a0)			; Face left and be upside down
0000C26A 4400                       		neg.b	d0				; Get map frame
0000C26C 0600 008F                  		addi.b	#$8F,d0				; ''
0000C270                            
0000C270                            .SetLeftFrame:
0000C270 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
0000C274 0600 0068                  		addi.b	#$68,d0				; ''
0000C278 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C27C 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C280 4E75                       		rts
0000C282                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C282                            .RollAnim:
0000C282 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C284 6600                       		bne.s	.PushAnim			; If not, branch
0000C286                            
0000C286 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C28A 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
0000C28C 4442                       		neg.w	d2				; Force it to be negative
0000C28E                            
0000C28E                            .GetAnim2:
0000C28E 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
0000C294 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
0000C298 6400                       		bcc.s	.PrepareTimer			; If so, branch
0000C29A 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
0000C2A0                            
0000C2A0                            .PrepareTimer:
0000C2A0 4442                       		neg.w	d2				; Get animation speed
0000C2A2 0642 0400                  		addi.w	#$400,d2			; ''
0000C2A6 6A00                       		bpl.s	.SetTimer2			; ''
0000C2A8 7400                       		moveq	#0,d2				; ''
0000C2AA                            
0000C2AA                            .SetTimer2:
0000C2AA E04A                       		lsr.w	#8,d2				; ''
0000C2AC 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C2B0                            
0000C2B0 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C2B4 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
0000C2B8 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits in render flags
0000C2BE 8328 000D                  		or.b	d1,oRender(a0)			; Set new flip bits
0000C2C2                            
0000C2C2 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
0000C2C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2C6                            .PushAnim:
0000C2C6 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C2C8 6600                       		bne.s	.HangAnim			; If not, branch
0000C2CA                            
0000C2CA                            .DoPushAnim:
0000C2CA 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C2CE 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
0000C2D0 4442                       		neg.w	d2				; Force it to be negative
0000C2D2                            
0000C2D2                            .GetAnim3:
0000C2D2 0642 0800                  		addi.w	#$800,d2			; Get animation speed
0000C2D6 6A00                       		bpl.s	.SetTimer3			; ''
0000C2D8 7400                       		moveq	#0,d2				; ''
0000C2DA                            
0000C2DA                            .SetTimer3:
0000C2DA EC4A                       		lsr.w	#6,d2				; ''
0000C2DC 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C2E0 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000C2E6 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
0000C2EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2EA                            .HangAnim:
0000C2EA 7200                       		moveq	#0,d1
0000C2EC 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation frame
0000C2F0 1171 1001 0010             		move.b	1(a1,d1.w),oFrame(a0)		; Set map frame
0000C2F6 4228 0023                  		clr.b	oAniTimer(a0)			; Clear animation timer
0000C2FA 4E75                       		rts
0000C2FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2FC                            ; Handle debug placement mode
0000C2FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2FC                            DebugPlacement:
0000C2FC 7000                       		moveq	#0,d0
0000C2FE 1038 F8D1                  		move.b	rDebugMode.w,d0		; Get debug placement mode routine
0000C302 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000C306 D040                       		add.w	d0,d0				; Double it
0000C308 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
0000C30C                            	nextObject
0000C30C 3068 0004                M 	movea.w	onext(a0),a0
0000C310 2250                     M 	move.l	oaddr(a0),a1
0000C312 4ED1                     M 	jmp	(a1)
0000C314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C314                            .Routines:
0000C314 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
0000C318 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
0000C31C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C31C                            Debug_Init:
0000C31C 5438 F8D1                  		addq.b	#2,rDebugMode.w		; Next routine
0000C320 4228 0010                  		clr.b	oFrame(a0)			; Reset mapping frame
0000C324 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000C328 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000C32C 4278 F8CE                  		clr.w	rCamLocked.w			; Unlock the camera
0000C330 4228 004B                  		clr.b	oBallMode(a0)			; Reset ball mode
0000C334 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000C338 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set routine to main
0000C33E                            
0000C33E 3028 003C                  		move.w	oInteract(a0),d0		; Get object interacted with last
0000C342 6700                       		beq.s	.NoInteract			; If there is none, branch
0000C344 3240                       		movea.w	d0,a1
0000C346 08A9 0003 0028             		bclr	#3,oStatus(a1)			; Clear flags
0000C34C 08A9 0005 0028             		bclr	#5,oStatus(a1)			; ''
0000C352 4268 003C                  		clr.w	oInteract(a0)			; No more interaction
0000C356                            
0000C356                            .NoInteract:
0000C356 4228 000C                  		clr.b	oFlags(a0)			; Reset flags
0000C35A 4228 0028                  		clr.b	oStatus(a0)			; Reset status
0000C35E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C364 117C 0001 0010             		move.b	#1,oFrame(a0)			; Display the standing frame
0000C36A 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000C36E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C36E                            Debug_Main:
0000C36E 6100 EE34                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
0000C372 6100                       		bsr.s	Debug_Control			; Control
0000C374                            	displaySprite	2,a0,a2,1
0000C374 4A68 0008                M 	tst.w	odrawnext(a0)
0000C378 6600                     M 	bne.s	.no_228
0000C37A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C380 3478 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a2
0000C384 314A 000A                M 	move.w	a2,odrawprev(a0)
0000C388 3548 0008                M 	move.w	a0,odrawnext(a2)
0000C38C 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C390                          M .no_228
0000C390 4E75                       		rts
0000C392                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C392                            Debug_Control:
0000C392 7006                       		moveq	#6,d0				; Speed
0000C394 0838 0000 C740             		btst	#0,rP1Hold.w			; Is up being held?
0000C39A 6700                       		beq.s	.NoUp				; If not, branch
0000C39C 9168 0018                  		sub.w	d0,oYPos(a0)			; Move up
0000C3A0                            
0000C3A0                            .NoUp:
0000C3A0 0838 0001 C740             		btst	#1,rP1Hold.w			; Is down being held?
0000C3A6 6700                       		beq.s	.NoDown				; If not, branch
0000C3A8 D168 0018                  		add.w	d0,oYPos(a0)			; Move down
0000C3AC                            
0000C3AC                            .NoDown:
0000C3AC 0838 0002 C740             		btst	#2,rP1Hold.w			; Is left being held?
0000C3B2 6700                       		beq.s	.NoLeft				; If not, branch
0000C3B4 9168 0014                  		sub.w	d0,oXPos(a0)			; Move left
0000C3B8                            
0000C3B8                            .NoLeft:
0000C3B8 0838 0003 C740             		btst	#3,rP1Hold.w			; Is right being held?
0000C3BE 6700                       		beq.s	.NoRight			; If not, branch
0000C3C0 D168 0014                  		add.w	d0,oXPos(a0)			; Move right
0000C3C4                            
0000C3C4                            .NoRight:
0000C3C4 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000C3CA 6700                       		beq.s	.ChkWrap			; If not, branch
0000C3CC 7000                       		moveq	#0,d0
0000C3CE 11C0 F8D1                  		move.b	d0,rDebugMode.w		; Disable debug placement mode
0000C3D2 1140 0016                  		move.b	d0,oXPos+2(a0)			; Reset X subpixel
0000C3D6 1140 001A                  		move.b	d0,oYPos+2(a0)			; Reset Y subpixel
0000C3DA 3140 001C                  		move.w	d0,oXVel(a0)			; Reset X velocity
0000C3DE 3140 001E                  		move.w	d0,oYVel(a0)			; Reset Y velocity
0000C3E2 3140 003A                  		move.w	d0,oGVel(a0)			; Reset ground velocity
0000C3E6 0228 0001 0028             		andi.b	#1,oStatus(a0)			; Reset status
0000C3EC 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000C3F2 20BC 0000 B0C4             		move.l	#ObjPlayer,oAddr(a0)		; Use normal Sonic object
0000C3F8 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000C3FE 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000C404                            
0000C404                            .ChkWrap:
0000C404 4E75                       		rts
0000C406                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C406                            ; Data
0000C406                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C406                            ArtUnc_Sonic:
0000C406                            		incbin	"Objects/Player/Art.unc.bin"
00017EC6                            		even
00017EC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00017EC6                            Map_ObjPlayer:
00017EC6                            		include	"Objects/Player/Mappings.asm"
00017EC6                            ; --------------------------------------------------------------------------------
00017EC6                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00017EC6                            ; --------------------------------------------------------------------------------
00017EC6                            
00017EC6                            SME_lde97:	
00017EC6 0000 0000                  		dc.w SME_lde97_FC-SME_lde97, SME_lde97_FE-SME_lde97	
00017ECA 0000 0000                  		dc.w SME_lde97_118-SME_lde97, SME_lde97_12C-SME_lde97	
00017ECE 0000 0000                  		dc.w SME_lde97_140-SME_lde97, SME_lde97_154-SME_lde97	
00017ED2 0000 0000                  		dc.w SME_lde97_168-SME_lde97, SME_lde97_182-SME_lde97	
00017ED6 0000 0000                  		dc.w SME_lde97_190-SME_lde97, SME_lde97_19E-SME_lde97	
00017EDA 0000 0000                  		dc.w SME_lde97_1B8-SME_lde97, SME_lde97_1C6-SME_lde97	
00017EDE 0000 0000                  		dc.w SME_lde97_1DA-SME_lde97, SME_lde97_1FA-SME_lde97	
00017EE2 0000 0000                  		dc.w SME_lde97_220-SME_lde97, SME_lde97_23A-SME_lde97	
00017EE6 0000 0000                  		dc.w SME_lde97_25A-SME_lde97, SME_lde97_274-SME_lde97	
00017EEA 0000 0000                  		dc.w SME_lde97_294-SME_lde97, SME_lde97_2AE-SME_lde97	
00017EEE 0000 0000                  		dc.w SME_lde97_2BC-SME_lde97, SME_lde97_2CA-SME_lde97	
00017EF2 0000 0000                  		dc.w SME_lde97_2E4-SME_lde97, SME_lde97_2F2-SME_lde97	
00017EF6 0000 0000                  		dc.w SME_lde97_306-SME_lde97, SME_lde97_32C-SME_lde97	
00017EFA 0000 0000                  		dc.w SME_lde97_352-SME_lde97, SME_lde97_36C-SME_lde97	
00017EFE 0000 0000                  		dc.w SME_lde97_38C-SME_lde97, SME_lde97_3A6-SME_lde97	
00017F02 0000 0000                  		dc.w SME_lde97_3C6-SME_lde97, SME_lde97_3D4-SME_lde97	
00017F06 0000 0000                  		dc.w SME_lde97_3E2-SME_lde97, SME_lde97_3F0-SME_lde97	
00017F0A 0000 0000                  		dc.w SME_lde97_3FE-SME_lde97, SME_lde97_418-SME_lde97	
00017F0E 0000 0000                  		dc.w SME_lde97_42C-SME_lde97, SME_lde97_446-SME_lde97	
00017F12 0000 0000                  		dc.w SME_lde97_45A-SME_lde97, SME_lde97_468-SME_lde97	
00017F16 0000 0000                  		dc.w SME_lde97_476-SME_lde97, SME_lde97_484-SME_lde97	
00017F1A 0000 0000                  		dc.w SME_lde97_492-SME_lde97, SME_lde97_4AC-SME_lde97	
00017F1E 0000 0000                  		dc.w SME_lde97_4BA-SME_lde97, SME_lde97_4D4-SME_lde97	
00017F22 0000 0000                  		dc.w SME_lde97_4E2-SME_lde97, SME_lde97_4EA-SME_lde97	
00017F26 0000 0000                  		dc.w SME_lde97_4F2-SME_lde97, SME_lde97_4FA-SME_lde97	
00017F2A 0000 0000                  		dc.w SME_lde97_502-SME_lde97, SME_lde97_50A-SME_lde97	
00017F2E 0000 0000                  		dc.w SME_lde97_50C-SME_lde97, SME_lde97_50E-SME_lde97	
00017F32 0000 0000                  		dc.w SME_lde97_510-SME_lde97, SME_lde97_512-SME_lde97	
00017F36 0000 0000                  		dc.w SME_lde97_520-SME_lde97, SME_lde97_53A-SME_lde97	
00017F3A 0000 0000                  		dc.w SME_lde97_554-SME_lde97, SME_lde97_568-SME_lde97	
00017F3E 0000 0000                  		dc.w SME_lde97_57C-SME_lde97, SME_lde97_590-SME_lde97	
00017F42 0000 0000                  		dc.w SME_lde97_59E-SME_lde97, SME_lde97_5B2-SME_lde97	
00017F46 0000 0000                  		dc.w SME_lde97_5C6-SME_lde97, SME_lde97_5DA-SME_lde97	
00017F4A 0000 0000                  		dc.w SME_lde97_5F4-SME_lde97, SME_lde97_60E-SME_lde97	
00017F4E 0000 0000                  		dc.w SME_lde97_610-SME_lde97, SME_lde97_612-SME_lde97	
00017F52 0000 0000                  		dc.w SME_lde97_620-SME_lde97, SME_lde97_634-SME_lde97	
00017F56 0000 0000                  		dc.w SME_lde97_642-SME_lde97, SME_lde97_656-SME_lde97	
00017F5A 0000 0000                  		dc.w SME_lde97_658-SME_lde97, SME_lde97_65A-SME_lde97	
00017F5E 0000 0000                  		dc.w SME_lde97_65C-SME_lde97, SME_lde97_67C-SME_lde97	
00017F62 0000 0000                  		dc.w SME_lde97_69C-SME_lde97, SME_lde97_69E-SME_lde97	
00017F66 0000 0000                  		dc.w SME_lde97_6A0-SME_lde97, SME_lde97_6A2-SME_lde97	
00017F6A 0000 0000                  		dc.w SME_lde97_6A4-SME_lde97, SME_lde97_6A6-SME_lde97	
00017F6E 0000 0000                  		dc.w SME_lde97_6BA-SME_lde97, SME_lde97_6CE-SME_lde97	
00017F72 0000 0000                  		dc.w SME_lde97_6E2-SME_lde97, SME_lde97_6F6-SME_lde97	
00017F76 0000 0000                  		dc.w SME_lde97_704-SME_lde97, SME_lde97_712-SME_lde97	
00017F7A 0000 0000                  		dc.w SME_lde97_720-SME_lde97, SME_lde97_72E-SME_lde97	
00017F7E 0000 0000                  		dc.w SME_lde97_73C-SME_lde97, SME_lde97_73E-SME_lde97	
00017F82 0000 0000                  		dc.w SME_lde97_740-SME_lde97, SME_lde97_742-SME_lde97	
00017F86 0000 0000                  		dc.w SME_lde97_744-SME_lde97, SME_lde97_746-SME_lde97	
00017F8A 0000 0000                  		dc.w SME_lde97_748-SME_lde97, SME_lde97_74A-SME_lde97	
00017F8E 0000 0000                  		dc.w SME_lde97_74C-SME_lde97, SME_lde97_74E-SME_lde97	
00017F92 0000 0000                  		dc.w SME_lde97_750-SME_lde97, SME_lde97_752-SME_lde97	
00017F96 0000 0000                  		dc.w SME_lde97_754-SME_lde97, SME_lde97_768-SME_lde97	
00017F9A 0000 0000                  		dc.w SME_lde97_77C-SME_lde97, SME_lde97_78A-SME_lde97	
00017F9E 0000 0000                  		dc.w SME_lde97_792-SME_lde97, SME_lde97_7A0-SME_lde97	
00017FA2 0000 0000                  		dc.w SME_lde97_7B4-SME_lde97, SME_lde97_7C8-SME_lde97	
00017FA6 0000 0000                  		dc.w SME_lde97_7DC-SME_lde97, SME_lde97_7EA-SME_lde97	
00017FAA 0000 0000                  		dc.w SME_lde97_7F8-SME_lde97, SME_lde97_80C-SME_lde97	
00017FAE 0000 0000                  		dc.w SME_lde97_81A-SME_lde97, SME_lde97_828-SME_lde97	
00017FB2 0000 0000                  		dc.w SME_lde97_836-SME_lde97, SME_lde97_844-SME_lde97	
00017FB6 0000 0000                  		dc.w SME_lde97_858-SME_lde97, SME_lde97_86C-SME_lde97	
00017FBA 0000 0000                  		dc.w SME_lde97_880-SME_lde97, SME_lde97_89A-SME_lde97	
00017FBE 0000 0000                  		dc.w SME_lde97_8B4-SME_lde97, SME_lde97_8CE-SME_lde97	
00017FC2 0000                       SME_lde97_FC:	dc.b 0, 0	
00017FC4 0004                       SME_lde97_FE:	dc.b 0, 4	
00017FC6 EC08 0000 FFF0             		dc.b $EC, 8, 0, 0, $FF, $F0	
00017FCC F40D 0003 FFF0             		dc.b $F4, $D, 0, 3, $FF, $F0	
00017FD2 0408 000B FFF0             		dc.b 4, 8, 0, $B, $FF, $F0	
00017FD8 0C08 000E FFF8             		dc.b $C, 8, 0, $E, $FF, $F8	
00017FDE 0003                       SME_lde97_118:	dc.b 0, 3	
00017FE0 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017FE6 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017FEC 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017FF2 0003                       SME_lde97_12C:	dc.b 0, 3	
00017FF4 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017FFA FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00018000 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00018006 0003                       SME_lde97_140:	dc.b 0, 3	
00018008 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
0001800E FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00018014 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
0001801A 0003                       SME_lde97_154:	dc.b 0, 3	
0001801C EC0A 0000 FFF0             		dc.b $EC, $A, 0, 0, $FF, $F0	
00018022 0408 0009 FFF0             		dc.b 4, 8, 0, 9, $FF, $F0	
00018028 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
0001802E 0004                       SME_lde97_168:	dc.b 0, 4	
00018030 EB0D 0000 FFEC             		dc.b $EB, $D, 0, 0, $FF, $EC	
00018036 FB09 0008 FFEC             		dc.b $FB, 9, 0, 8, $FF, $EC	
0001803C FB06 000E 0004             		dc.b $FB, 6, 0, $E, 0, 4	
00018042 0B04 0014 FFEC             		dc.b $B, 4, 0, $14, $FF, $EC	
00018048 0002                       SME_lde97_182:	dc.b 0, 2	
0001804A EC0D 0000 FFED             		dc.b $EC, $D, 0, 0, $FF, $ED	
00018050 FC0E 0008 FFF5             		dc.b $FC, $E, 0, 8, $FF, $F5	
00018056 0002                       SME_lde97_190:	dc.b 0, 2	
00018058 ED09 0000 FFF3             		dc.b $ED, 9, 0, 0, $FF, $F3	
0001805E FD0A 0006 FFF3             		dc.b $FD, $A, 0, 6, $FF, $F3	
00018064 0004                       SME_lde97_19E:	dc.b 0, 4	
00018066 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
0001806C FB09 0006 FFEC             		dc.b $FB, 9, 0, 6, $FF, $EC	
00018072 FB06 000C 0004             		dc.b $FB, 6, 0, $C, 0, 4	
00018078 0B04 0012 FFEC             		dc.b $B, 4, 0, $12, $FF, $EC	
0001807E 0002                       SME_lde97_1B8:	dc.b 0, 2	
00018080 EC09 0000 FFF3             		dc.b $EC, 9, 0, 0, $FF, $F3	
00018086 FC0E 0006 FFEB             		dc.b $FC, $E, 0, 6, $FF, $EB	
0001808C 0003                       SME_lde97_1C6:	dc.b 0, 3	
0001808E ED0D 0000 FFEC             		dc.b $ED, $D, 0, 0, $FF, $EC	
00018094 FD0C 0008 FFF4             		dc.b $FD, $C, 0, 8, $FF, $F4	
0001809A 0509 000C FFF4             		dc.b 5, 9, 0, $C, $FF, $F4	
000180A0 0005                       SME_lde97_1DA:	dc.b 0, 5	
000180A2 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
000180A8 EB06 0006 0003             		dc.b $EB, 6, 0, 6, 0, 3	
000180AE FB08 000C FFEB             		dc.b $FB, 8, 0, $C, $FF, $EB	
000180B4 0309 000F FFF3             		dc.b 3, 9, 0, $F, $FF, $F3	
000180BA 1300 0015 FFFB             		dc.b $13, 0, 0, $15, $FF, $FB	
000180C0 0006                       SME_lde97_1FA:	dc.b 0, 6	
000180C2 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
000180C8 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
000180CE FC0C 0008 FFEC             		dc.b $FC, $C, 0, 8, $FF, $EC	
000180D4 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
000180DA FC05 0012 000C             		dc.b $FC, 5, 0, $12, 0, $C	
000180E0 F400 0016 0014             		dc.b $F4, 0, 0, $16, 0, $14	
000180E6 0004                       SME_lde97_220:	dc.b 0, 4	
000180E8 ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
000180EE ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
000180F4 FD0D 0008 FFF5             		dc.b $FD, $D, 0, 8, $FF, $F5	
000180FA 0D08 0010 FFFD             		dc.b $D, 8, 0, $10, $FF, $FD	
00018100 0005                       SME_lde97_23A:	dc.b 0, 5	
00018102 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
00018108 EB05 0006 0003             		dc.b $EB, 5, 0, 6, 0, 3	
0001810E FB0D 000A FFF3             		dc.b $FB, $D, 0, $A, $FF, $F3	
00018114 0B08 0012 FFF3             		dc.b $B, 8, 0, $12, $FF, $F3	
0001811A 1304 0015 FFFB             		dc.b $13, 4, 0, $15, $FF, $FB	
00018120 0004                       SME_lde97_25A:	dc.b 0, 4	
00018122 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
00018128 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
0001812E FC0D 0008 FFF4             		dc.b $FC, $D, 0, 8, $FF, $F4	
00018134 0C08 0010 FFFC             		dc.b $C, 8, 0, $10, $FF, $FC	
0001813A 0005                       SME_lde97_274:	dc.b 0, 5	
0001813C ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00018142 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
00018148 FD00 0008 FFED             		dc.b $FD, 0, 0, 8, $FF, $ED	
0001814E FD0D 0009 FFF5             		dc.b $FD, $D, 0, 9, $FF, $F5	
00018154 0D08 0011 FFFD             		dc.b $D, 8, 0, $11, $FF, $FD	
0001815A 0004                       SME_lde97_294:	dc.b 0, 4	
0001815C F407 0000 FFEB             		dc.b $F4, 7, 0, 0, $FF, $EB	
00018162 EC09 0008 FFFB             		dc.b $EC, 9, 0, 8, $FF, $FB	
00018168 FC04 000E FFFB             		dc.b $FC, 4, 0, $E, $FF, $FB	
0001816E 0409 0010 FFFB             		dc.b 4, 9, 0, $10, $FF, $FB	
00018174 0002                       SME_lde97_2AE:	dc.b 0, 2	
00018176 F407 0000 FFEC             		dc.b $F4, 7, 0, 0, $FF, $EC	
0001817C EC0B 0008 FFFC             		dc.b $EC, $B, 0, 8, $FF, $FC	
00018182 0002                       SME_lde97_2BC:	dc.b 0, 2	
00018184 F406 0000 FFED             		dc.b $F4, 6, 0, 0, $FF, $ED	
0001818A F40A 0006 FFFD             		dc.b $F4, $A, 0, 6, $FF, $FD	
00018190 0004                       SME_lde97_2CA:	dc.b 0, 4	
00018192 F406 0000 FFEB             		dc.b $F4, 6, 0, 0, $FF, $EB	
00018198 EC09 0006 FFFB             		dc.b $EC, 9, 0, 6, $FF, $FB	
0001819E FC04 000C FFFB             		dc.b $FC, 4, 0, $C, $FF, $FB	
000181A4 0409 000E FFFB             		dc.b 4, 9, 0, $E, $FF, $FB	
000181AA 0002                       SME_lde97_2E4:	dc.b 0, 2	
000181AC F406 0000 FFEC             		dc.b $F4, 6, 0, 0, $FF, $EC	
000181B2 F40B 0006 FFFC             		dc.b $F4, $B, 0, 6, $FF, $FC	
000181B8 0003                       SME_lde97_2F2:	dc.b 0, 3	
000181BA F407 0000 FFED             		dc.b $F4, 7, 0, 0, $FF, $ED	
000181C0 EC00 0008 FFFD             		dc.b $EC, 0, 0, 8, $FF, $FD	
000181C6 F40A 0009 FFFD             		dc.b $F4, $A, 0, 9, $FF, $FD	
000181CC 0006                       SME_lde97_306:	dc.b 0, 6	
000181CE FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
000181D4 ED04 0006 FFF3             		dc.b $ED, 4, 0, 6, $FF, $F3	
000181DA F504 0008 FFEB             		dc.b $F5, 4, 0, 8, $FF, $EB	
000181E0 F50A 000A FFFB             		dc.b $F5, $A, 0, $A, $FF, $FB	
000181E6 0D00 0013 FFFB             		dc.b $D, 0, 0, $13, $FF, $FB	
000181EC FD00 0014 0013             		dc.b $FD, 0, 0, $14, 0, $13	
000181F2 0006                       SME_lde97_32C:	dc.b 0, 6	
000181F4 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
000181FA E408 0006 FFF4             		dc.b $E4, 8, 0, 6, $FF, $F4	
00018200 EC04 0009 FFFC             		dc.b $EC, 4, 0, 9, $FF, $FC	
00018206 F404 000B FFEC             		dc.b $F4, 4, 0, $B, $FF, $EC	
0001820C F40A 000D FFFC             		dc.b $F4, $A, 0, $D, $FF, $FC	
00018212 0C00 0016 FFFC             		dc.b $C, 0, 0, $16, $FF, $FC	
00018218 0004                       SME_lde97_352:	dc.b 0, 4	
0001821A FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00018220 F304 0006 FFED             		dc.b $F3, 4, 0, 6, $FF, $ED	
00018226 EB0A 0008 FFFD             		dc.b $EB, $A, 0, 8, $FF, $FD	
0001822C 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00018232 0005                       SME_lde97_36C:	dc.b 0, 5	
00018234 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
0001823A ED08 0006 FFF3             		dc.b $ED, 8, 0, 6, $FF, $F3	
00018240 F504 0009 FFEB             		dc.b $F5, 4, 0, 9, $FF, $EB	
00018246 F50D 000B FFFB             		dc.b $F5, $D, 0, $B, $FF, $FB	
0001824C 0508 0013 FFFB             		dc.b 5, 8, 0, $13, $FF, $FB	
00018252 0004                       SME_lde97_38C:	dc.b 0, 4	
00018254 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
0001825A F404 0006 FFEC             		dc.b $F4, 4, 0, 6, $FF, $EC	
00018260 EC0A 0008 FFFC             		dc.b $EC, $A, 0, 8, $FF, $FC	
00018266 0404 0011 FFFC             		dc.b 4, 4, 0, $11, $FF, $FC	
0001826C 0005                       SME_lde97_3A6:	dc.b 0, 5	
0001826E FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00018274 EB0A 0006 FFFD             		dc.b $EB, $A, 0, 6, $FF, $FD	
0001827A F304 000F FFED             		dc.b $F3, 4, 0, $F, $FF, $ED	
00018280 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00018286 0B00 0013 FFFD             		dc.b $B, 0, 0, $13, $FF, $FD	
0001828C 0002                       SME_lde97_3C6:	dc.b 0, 2	
0001828E EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018294 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
0001829A 0002                       SME_lde97_3D4:	dc.b 0, 2	
0001829C EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000182A2 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000182A8 0002                       SME_lde97_3E2:	dc.b 0, 2	
000182AA EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000182B0 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000182B6 0002                       SME_lde97_3F0:	dc.b 0, 2	
000182B8 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000182BE FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000182C4 0004                       SME_lde97_3FE:	dc.b 0, 4	
000182C6 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182CC EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000182D2 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000182D8 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
000182DE 0003                       SME_lde97_418:	dc.b 0, 3	
000182E0 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182E6 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000182EC FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000182F2 0004                       SME_lde97_42C:	dc.b 0, 4	
000182F4 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182FA EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018300 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018306 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
0001830C 0003                       SME_lde97_446:	dc.b 0, 3	
0001830E EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018314 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
0001831A FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018320 0002                       SME_lde97_45A:	dc.b 0, 2	
00018322 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018328 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0001832E 0002                       SME_lde97_468:	dc.b 0, 2	
00018330 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018336 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0001833C 0002                       SME_lde97_476:	dc.b 0, 2	
0001833E F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018344 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0001834A 0002                       SME_lde97_484:	dc.b 0, 2	
0001834C F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018352 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00018358 0004                       SME_lde97_492:	dc.b 0, 4	
0001835A FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
00018360 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
00018366 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
0001836C 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
00018372 0002                       SME_lde97_4AC:	dc.b 0, 2	
00018374 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
0001837A EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00018380 0004                       SME_lde97_4BA:	dc.b 0, 4	
00018382 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
00018388 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
0001838E EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00018394 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
0001839A 0002                       SME_lde97_4D4:	dc.b 0, 2	
0001839C F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
000183A2 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000183A8 0001                       SME_lde97_4E2:	dc.b 0, 1	
000183AA F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000183B0 0001                       SME_lde97_4EA:	dc.b 0, 1	
000183B2 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000183B8 0001                       SME_lde97_4F2:	dc.b 0, 1	
000183BA F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000183C0 0001                       SME_lde97_4FA:	dc.b 0, 1	
000183C2 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000183C8 0001                       SME_lde97_502:	dc.b 0, 1	
000183CA F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000183D0 0000                       SME_lde97_50A:	dc.b 0, 0	
000183D2 0000                       SME_lde97_50C:	dc.b 0, 0	
000183D4 0000                       SME_lde97_50E:	dc.b 0, 0	
000183D6 0000                       SME_lde97_510:	dc.b 0, 0	
000183D8 0002                       SME_lde97_512:	dc.b 0, 2	
000183DA ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
000183E0 FD0E 0006 FFF0             		dc.b $FD, $E, 0, 6, $FF, $F0	
000183E6 0004                       SME_lde97_520:	dc.b 0, 4	
000183E8 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
000183EE FD0D 0006 FFF0             		dc.b $FD, $D, 0, 6, $FF, $F0	
000183F4 0D04 000E 0000             		dc.b $D, 4, 0, $E, 0, 0	
000183FA 0500 0010 FFE8             		dc.b 5, 0, 0, $10, $FF, $E8	
00018400 0004                       SME_lde97_53A:	dc.b 0, 4	
00018402 F404 0000 FFFC             		dc.b $F4, 4, 0, 0, $FF, $FC	
00018408 FC0D 0002 FFF4             		dc.b $FC, $D, 0, 2, $FF, $F4	
0001840E 0C08 000A FFF4             		dc.b $C, 8, 0, $A, $FF, $F4	
00018414 0400 000D FFEC             		dc.b 4, 0, 0, $D, $FF, $EC	
0001841A 0003                       SME_lde97_554:	dc.b 0, 3	
0001841C EC08 0800 FFE8             		dc.b $EC, 8, 8, 0, $FF, $E8	
00018422 F402 0803 0000             		dc.b $F4, 2, 8, 3, 0, 0	
00018428 F40F 0806 FFE0             		dc.b $F4, $F, 8, 6, $FF, $E0	
0001842E 0003                       SME_lde97_568:	dc.b 0, 3	
00018430 EC0E 0800 FFE8             		dc.b $EC, $E, 8, 0, $FF, $E8	
00018436 040D 080C FFE0             		dc.b 4, $D, 8, $C, $FF, $E0	
0001843C 0C00 1814 0000             		dc.b $C, 0, $18, $14, 0, 0	
00018442 0003                       SME_lde97_57C:	dc.b 0, 3	
00018444 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
0001844A FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
00018450 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
00018456 0002                       SME_lde97_590:	dc.b 0, 2	
00018458 F40A 0000 FFE8             		dc.b $F4, $A, 0, 0, $FF, $E8	
0001845E F40A 0800 0000             		dc.b $F4, $A, 8, 0, 0, 0	
00018464 0003                       SME_lde97_59E:	dc.b 0, 3	
00018466 F40D 0000 FFE4             		dc.b $F4, $D, 0, 0, $FF, $E4	
0001846C FC00 0008 0004             		dc.b $FC, 0, 0, 8, 0, 4	
00018472 040C 0009 FFEC             		dc.b 4, $C, 0, 9, $FF, $EC	
00018478 0003                       SME_lde97_5B2:	dc.b 0, 3	
0001847A F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
00018480 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
00018486 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
0001848C 0003                       SME_lde97_5C6:	dc.b 0, 3	
0001848E E80B 0000 FFF0             		dc.b $E8, $B, 0, 0, $FF, $F0	
00018494 0804 000C FFF8             		dc.b 8, 4, 0, $C, $FF, $F8	
0001849A 1000 000E FFF8             		dc.b $10, 0, 0, $E, $FF, $F8	
000184A0 0004                       SME_lde97_5DA:	dc.b 0, 4	
000184A2 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
000184A8 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
000184AE F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
000184B4 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
000184BA 0004                       SME_lde97_5F4:	dc.b 0, 4	
000184BC F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
000184C2 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
000184C8 F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
000184CE F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
000184D4 0000                       SME_lde97_60E:	dc.b 0, 0	
000184D6 0000                       SME_lde97_610:	dc.b 0, 0	
000184D8 0002                       SME_lde97_612:	dc.b 0, 2	
000184DA ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
000184E0 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
000184E6 0003                       SME_lde97_620:	dc.b 0, 3	
000184E8 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
000184EE 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
000184F4 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
000184FA 0002                       SME_lde97_634:	dc.b 0, 2	
000184FC ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00018502 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
00018508 0003                       SME_lde97_642:	dc.b 0, 3	
0001850A EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
00018510 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
00018516 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
0001851C 0000                       SME_lde97_656:	dc.b 0, 0	
0001851E 0000                       SME_lde97_658:	dc.b 0, 0	
00018520 0000                       SME_lde97_65A:	dc.b 0, 0	
00018522 0005                       SME_lde97_65C:	dc.b 0, 5	
00018524 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
0001852A E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
00018530 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00018536 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
0001853C 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
00018542 0005                       SME_lde97_67C:	dc.b 0, 5	
00018544 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
0001854A E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
00018550 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00018556 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
0001855C 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
00018562 0000                       SME_lde97_69C:	dc.b 0, 0	
00018564 0000                       SME_lde97_69E:	dc.b 0, 0	
00018566 0000                       SME_lde97_6A0:	dc.b 0, 0	
00018568 0000                       SME_lde97_6A2:	dc.b 0, 0	
0001856A 0000                       SME_lde97_6A4:	dc.b 0, 0	
0001856C 0003                       SME_lde97_6A6:	dc.b 0, 3	
0001856E F40D 0800 FFE4             		dc.b $F4, $D, 8, 0, $FF, $E4	
00018574 FC05 0808 0004             		dc.b $FC, 5, 8, 8, 0, 4	
0001857A 0408 080C FFEC             		dc.b 4, 8, 8, $C, $FF, $EC	
00018580 0003                       SME_lde97_6BA:	dc.b 0, 3	
00018582 F40D 0800 FFFC             		dc.b $F4, $D, 8, 0, $FF, $FC	
00018588 FC00 0808 FFF4             		dc.b $FC, 0, 8, 8, $FF, $F4	
0001858E 040C 0809 FFF4             		dc.b 4, $C, 8, 9, $FF, $F4	
00018594 0003                       SME_lde97_6CE:	dc.b 0, 3	
00018596 F00E 0000 FFEC             		dc.b $F0, $E, 0, 0, $FF, $EC	
0001859C F801 000C 000C             		dc.b $F8, 1, 0, $C, 0, $C	
000185A2 080C 000E FFF4             		dc.b 8, $C, 0, $E, $FF, $F4	
000185A8 0003                       SME_lde97_6E2:	dc.b 0, 3	
000185AA EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
000185B0 FB0E 0006 FFEC             		dc.b $FB, $E, 0, 6, $FF, $EC	
000185B6 0301 0012 000C             		dc.b 3, 1, 0, $12, 0, $C	
000185BC 0002                       SME_lde97_6F6:	dc.b 0, 2	
000185BE F00F 0000 FFEC             		dc.b $F0, $F, 0, 0, $FF, $EC	
000185C4 F802 0010 000C             		dc.b $F8, 2, 0, $10, 0, $C	
000185CA 0002                       SME_lde97_704:	dc.b 0, 2	
000185CC F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000185D2 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000185D8 0002                       SME_lde97_712:	dc.b 0, 2	
000185DA F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000185E0 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000185E6 0002                       SME_lde97_720:	dc.b 0, 2	
000185E8 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000185EE FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000185F4 0002                       SME_lde97_72E:	dc.b 0, 2	
000185F6 F40F 0000 FFF5             		dc.b $F4, $F, 0, 0, $FF, $F5	
000185FC FC01 0010 FFED             		dc.b $FC, 1, 0, $10, $FF, $ED	
00018602 0000                       SME_lde97_73C:	dc.b 0, 0	
00018604 0000                       SME_lde97_73E:	dc.b 0, 0	
00018606 0000                       SME_lde97_740:	dc.b 0, 0	
00018608 0000                       SME_lde97_742:	dc.b 0, 0	
0001860A 0000                       SME_lde97_744:	dc.b 0, 0	
0001860C 0000                       SME_lde97_746:	dc.b 0, 0	
0001860E 0000                       SME_lde97_748:	dc.b 0, 0	
00018610 0000                       SME_lde97_74A:	dc.b 0, 0	
00018612 0000                       SME_lde97_74C:	dc.b 0, 0	
00018614 0000                       SME_lde97_74E:	dc.b 0, 0	
00018616 0000                       SME_lde97_750:	dc.b 0, 0	
00018618 0000                       SME_lde97_752:	dc.b 0, 0	
0001861A 0003                       SME_lde97_754:	dc.b 0, 3	
0001861C E409 0000 FFF0             		dc.b $E4, 9, 0, 0, $FF, $F0	
00018622 F40B 0006 FFF0             		dc.b $F4, $B, 0, 6, $FF, $F0	
00018628 F401 0012 0008             		dc.b $F4, 1, 0, $12, 0, 8	
0001862E 0003                       SME_lde97_768:	dc.b 0, 3	
00018630 E50B 0000 FFF0             		dc.b $E5, $B, 0, 0, $FF, $F0	
00018636 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0001863C 0505 000E FFF8             		dc.b 5, 5, 0, $E, $FF, $F8	
00018642 0002                       SME_lde97_77C:	dc.b 0, 2	
00018644 EC0B 0000 FFF1             		dc.b $EC, $B, 0, 0, $FF, $F1	
0001864A FC01 000C 0009             		dc.b $FC, 1, 0, $C, 0, 9	
00018650 0001                       SME_lde97_78A:	dc.b 0, 1	
00018652 EE0F 0000 FFF0             		dc.b $EE, $F, 0, 0, $FF, $F0	
00018658 0002                       SME_lde97_792:	dc.b 0, 2	
0001865A F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00018660 FA01 000C 0008             		dc.b $FA, 1, 0, $C, 0, 8	
00018666 0003                       SME_lde97_7A0:	dc.b 0, 3	
00018668 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
0001866E E401 000C 0000             		dc.b $E4, 1, 0, $C, 0, 0	
00018674 F401 000E 0008             		dc.b $F4, 1, 0, $E, 0, 8	
0001867A 0003                       SME_lde97_7B4:	dc.b 0, 3	
0001867C E509 0000 FFF0             		dc.b $E5, 9, 0, 0, $FF, $F0	
00018682 F50B 0006 FFF0             		dc.b $F5, $B, 0, 6, $FF, $F0	
00018688 ED03 0012 0008             		dc.b $ED, 3, 0, $12, 0, 8	
0001868E 0003                       SME_lde97_7C8:	dc.b 0, 3	
00018690 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
00018696 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0001869C E405 000E FFF8             		dc.b $E4, 5, 0, $E, $FF, $F8	
000186A2 0002                       SME_lde97_7DC:	dc.b 0, 2	
000186A4 ED0B 0000 FFF0             		dc.b $ED, $B, 0, 0, $FF, $F0	
000186AA F501 000C 0008             		dc.b $F5, 1, 0, $C, 0, 8	
000186B0 0002                       SME_lde97_7EA:	dc.b 0, 2	
000186B2 F10B 0000 FFF8             		dc.b $F1, $B, 0, 0, $FF, $F8	
000186B8 F401 000C FFF0             		dc.b $F4, 1, 0, $C, $FF, $F0	
000186BE 0003                       SME_lde97_7F8:	dc.b 0, 3	
000186C0 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000186C6 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
000186CC E405 000E FFF1             		dc.b $E4, 5, 0, $E, $FF, $F1	
000186D2 0002                       SME_lde97_80C:	dc.b 0, 2	
000186D4 F10F 0000 FFF0             		dc.b $F1, $F, 0, 0, $FF, $F0	
000186DA E105 0010 FFF0             		dc.b $E1, 5, 0, $10, $FF, $F0	
000186E0 0002                       SME_lde97_81A:	dc.b 0, 2	
000186E2 EC0E 0000 FFEC             		dc.b $EC, $E, 0, 0, $FF, $EC	
000186E8 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
000186EE 0002                       SME_lde97_828:	dc.b 0, 2	
000186F0 EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
000186F6 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
000186FC 0002                       SME_lde97_836:	dc.b 0, 2	
000186FE EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
00018704 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
0001870A 0003                       SME_lde97_844:	dc.b 0, 3	
0001870C E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00018712 0008 000C FFF0             		dc.b 0, 8, 0, $C, $FF, $F0	
00018718 0809 000F FFF8             		dc.b 8, 9, 0, $F, $FF, $F8	
0001871E 0003                       SME_lde97_858:	dc.b 0, 3	
00018720 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00018726 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
0001872C 100C 0012 FFF0             		dc.b $10, $C, 0, $12, $FF, $F0	
00018732 0003                       SME_lde97_86C:	dc.b 0, 3	
00018734 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
0001873A 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
00018740 1004 0012 FFF0             		dc.b $10, 4, 0, $12, $FF, $F0	
00018746 0004                       SME_lde97_880:	dc.b 0, 4	
00018748 EC0E 0800 FFF0             		dc.b $EC, $E, 8, 0, $FF, $F0	
0001874E FC01 080C 0010             		dc.b $FC, 1, 8, $C, 0, $10	
00018754 0408 080E FFF8             		dc.b 4, 8, 8, $E, $FF, $F8	
0001875A 0C04 0811 0000             		dc.b $C, 4, 8, $11, 0, 0	
00018760 0004                       SME_lde97_89A:	dc.b 0, 4	
00018762 EC0E 0000 FFF8             		dc.b $EC, $E, 0, 0, $FF, $F8	
00018768 FC01 000C FFF0             		dc.b $FC, 1, 0, $C, $FF, $F0	
0001876E 0408 000E FFF8             		dc.b 4, 8, 0, $E, $FF, $F8	
00018774 0C04 0011 FFF8             		dc.b $C, 4, 0, $11, $FF, $F8	
0001877A 0004                       SME_lde97_8B4:	dc.b 0, 4	
0001877C FC0E 1000 FFF8             		dc.b $FC, $E, $10, 0, $FF, $F8	
00018782 F401 100C FFF0             		dc.b $F4, 1, $10, $C, $FF, $F0	
00018788 F408 100E FFF8             		dc.b $F4, 8, $10, $E, $FF, $F8	
0001878E EC04 1011 FFF8             		dc.b $EC, 4, $10, $11, $FF, $F8	
00018794 0004                       SME_lde97_8CE:	dc.b 0, 4	
00018796 FC0E 1800 FFF0             		dc.b $FC, $E, $18, 0, $FF, $F0	
0001879C F401 180C 0010             		dc.b $F4, 1, $18, $C, 0, $10	
000187A2 F408 180E FFF8             		dc.b $F4, 8, $18, $E, $FF, $F8	
000187A8 EC04 1811 0000             		dc.b $EC, 4, $18, $11, 0, 0	
000187AE                            		even
000187AE                            		even
000187AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000187AE                            DPLC_ObjPlayer:
000187AE                            		include	"Objects/Player/DPLCs.asm"
000187AE                            ; --------------------------------------------------------------------------------
000187AE                            ; Dynamic Pattern Loading Cues - output from SonMapEd - Sonic 3 & Knuckles format; --------------------------------------------------------------------------------
000187AE                            
000187AE                            SME_CfLJT:	
000187AE 0000 0000                  		dc.w SME_CfLJT_FC-SME_CfLJT, SME_CfLJT_FE-SME_CfLJT	
000187B2 0000 0000                  		dc.w SME_CfLJT_108-SME_CfLJT, SME_CfLJT_110-SME_CfLJT	
000187B6 0000 0000                  		dc.w SME_CfLJT_118-SME_CfLJT, SME_CfLJT_120-SME_CfLJT	
000187BA 0000 0000                  		dc.w SME_CfLJT_128-SME_CfLJT, SME_CfLJT_132-SME_CfLJT	
000187BE 0000 0000                  		dc.w SME_CfLJT_138-SME_CfLJT, SME_CfLJT_13E-SME_CfLJT	
000187C2 0000 0000                  		dc.w SME_CfLJT_148-SME_CfLJT, SME_CfLJT_14E-SME_CfLJT	
000187C6 0000 0000                  		dc.w SME_CfLJT_156-SME_CfLJT, SME_CfLJT_162-SME_CfLJT	
000187CA 0000 0000                  		dc.w SME_CfLJT_170-SME_CfLJT, SME_CfLJT_17A-SME_CfLJT	
000187CE 0000 0000                  		dc.w SME_CfLJT_186-SME_CfLJT, SME_CfLJT_190-SME_CfLJT	
000187D2 0000 0000                  		dc.w SME_CfLJT_19C-SME_CfLJT, SME_CfLJT_1A6-SME_CfLJT	
000187D6 0000 0000                  		dc.w SME_CfLJT_1AC-SME_CfLJT, SME_CfLJT_1B2-SME_CfLJT	
000187DA 0000 0000                  		dc.w SME_CfLJT_1BC-SME_CfLJT, SME_CfLJT_1C2-SME_CfLJT	
000187DE 0000 0000                  		dc.w SME_CfLJT_1CA-SME_CfLJT, SME_CfLJT_1D8-SME_CfLJT	
000187E2 0000 0000                  		dc.w SME_CfLJT_1E6-SME_CfLJT, SME_CfLJT_1F0-SME_CfLJT	
000187E6 0000 0000                  		dc.w SME_CfLJT_1FC-SME_CfLJT, SME_CfLJT_206-SME_CfLJT	
000187EA 0000 0000                  		dc.w SME_CfLJT_212-SME_CfLJT, SME_CfLJT_218-SME_CfLJT	
000187EE 0000 0000                  		dc.w SME_CfLJT_21E-SME_CfLJT, SME_CfLJT_224-SME_CfLJT	
000187F2 0000 0000                  		dc.w SME_CfLJT_22A-SME_CfLJT, SME_CfLJT_234-SME_CfLJT	
000187F6 0000 0000                  		dc.w SME_CfLJT_23C-SME_CfLJT, SME_CfLJT_246-SME_CfLJT	
000187FA 0000 0000                  		dc.w SME_CfLJT_24E-SME_CfLJT, SME_CfLJT_254-SME_CfLJT	
000187FE 0000 0000                  		dc.w SME_CfLJT_25A-SME_CfLJT, SME_CfLJT_260-SME_CfLJT	
00018802 0000 0000                  		dc.w SME_CfLJT_266-SME_CfLJT, SME_CfLJT_270-SME_CfLJT	
00018806 0000 0000                  		dc.w SME_CfLJT_276-SME_CfLJT, SME_CfLJT_280-SME_CfLJT	
0001880A 0000 0000                  		dc.w SME_CfLJT_286-SME_CfLJT, SME_CfLJT_28A-SME_CfLJT	
0001880E 0000 0000                  		dc.w SME_CfLJT_28E-SME_CfLJT, SME_CfLJT_292-SME_CfLJT	
00018812 0000 0000                  		dc.w SME_CfLJT_296-SME_CfLJT, SME_CfLJT_29A-SME_CfLJT	
00018816 0000 0000                  		dc.w SME_CfLJT_29C-SME_CfLJT, SME_CfLJT_29E-SME_CfLJT	
0001881A 0000 0000                  		dc.w SME_CfLJT_2A0-SME_CfLJT, SME_CfLJT_2A2-SME_CfLJT	
0001881E 0000 0000                  		dc.w SME_CfLJT_2A8-SME_CfLJT, SME_CfLJT_2B2-SME_CfLJT	
00018822 0000 0000                  		dc.w SME_CfLJT_2BC-SME_CfLJT, SME_CfLJT_2C4-SME_CfLJT	
00018826 0000 0000                  		dc.w SME_CfLJT_2CC-SME_CfLJT, SME_CfLJT_2D4-SME_CfLJT	
0001882A 0000 0000                  		dc.w SME_CfLJT_2D8-SME_CfLJT, SME_CfLJT_2E0-SME_CfLJT	
0001882E 0000 0000                  		dc.w SME_CfLJT_2E8-SME_CfLJT, SME_CfLJT_2F0-SME_CfLJT	
00018832 0000 0000                  		dc.w SME_CfLJT_2FA-SME_CfLJT, SME_CfLJT_304-SME_CfLJT	
00018836 0000 0000                  		dc.w SME_CfLJT_306-SME_CfLJT, SME_CfLJT_308-SME_CfLJT	
0001883A 0000 0000                  		dc.w SME_CfLJT_30E-SME_CfLJT, SME_CfLJT_316-SME_CfLJT	
0001883E 0000 0000                  		dc.w SME_CfLJT_31C-SME_CfLJT, SME_CfLJT_324-SME_CfLJT	
00018842 0000 0000                  		dc.w SME_CfLJT_326-SME_CfLJT, SME_CfLJT_328-SME_CfLJT	
00018846 0000 0000                  		dc.w SME_CfLJT_32A-SME_CfLJT, SME_CfLJT_336-SME_CfLJT	
0001884A 0000 0000                  		dc.w SME_CfLJT_342-SME_CfLJT, SME_CfLJT_344-SME_CfLJT	
0001884E 0000 0000                  		dc.w SME_CfLJT_346-SME_CfLJT, SME_CfLJT_348-SME_CfLJT	
00018852 0000 0000                  		dc.w SME_CfLJT_34A-SME_CfLJT, SME_CfLJT_34C-SME_CfLJT	
00018856 0000 0000                  		dc.w SME_CfLJT_354-SME_CfLJT, SME_CfLJT_35C-SME_CfLJT	
0001885A 0000 0000                  		dc.w SME_CfLJT_364-SME_CfLJT, SME_CfLJT_36C-SME_CfLJT	
0001885E 0000 0000                  		dc.w SME_CfLJT_372-SME_CfLJT, SME_CfLJT_378-SME_CfLJT	
00018862 0000 0000                  		dc.w SME_CfLJT_37E-SME_CfLJT, SME_CfLJT_384-SME_CfLJT	
00018866 0000 0000                  		dc.w SME_CfLJT_38A-SME_CfLJT, SME_CfLJT_38C-SME_CfLJT	
0001886A 0000 0000                  		dc.w SME_CfLJT_38E-SME_CfLJT, SME_CfLJT_390-SME_CfLJT	
0001886E 0000 0000                  		dc.w SME_CfLJT_392-SME_CfLJT, SME_CfLJT_394-SME_CfLJT	
00018872 0000 0000                  		dc.w SME_CfLJT_396-SME_CfLJT, SME_CfLJT_398-SME_CfLJT	
00018876 0000 0000                  		dc.w SME_CfLJT_39A-SME_CfLJT, SME_CfLJT_39C-SME_CfLJT	
0001887A 0000 0000                  		dc.w SME_CfLJT_39E-SME_CfLJT, SME_CfLJT_3A0-SME_CfLJT	
0001887E 0000 0000                  		dc.w SME_CfLJT_3A2-SME_CfLJT, SME_CfLJT_3AA-SME_CfLJT	
00018882 0000 0000                  		dc.w SME_CfLJT_3B2-SME_CfLJT, SME_CfLJT_3B8-SME_CfLJT	
00018886 0000 0000                  		dc.w SME_CfLJT_3BC-SME_CfLJT, SME_CfLJT_3C2-SME_CfLJT	
0001888A 0000 0000                  		dc.w SME_CfLJT_3CA-SME_CfLJT, SME_CfLJT_3D2-SME_CfLJT	
0001888E 0000 0000                  		dc.w SME_CfLJT_3DA-SME_CfLJT, SME_CfLJT_3E0-SME_CfLJT	
00018892 0000 0000                  		dc.w SME_CfLJT_3E6-SME_CfLJT, SME_CfLJT_3EE-SME_CfLJT	
00018896 0000 0000                  		dc.w SME_CfLJT_3F4-SME_CfLJT, SME_CfLJT_3FA-SME_CfLJT	
0001889A 0000 0000                  		dc.w SME_CfLJT_400-SME_CfLJT, SME_CfLJT_406-SME_CfLJT	
0001889E 0000 0000                  		dc.w SME_CfLJT_40E-SME_CfLJT, SME_CfLJT_416-SME_CfLJT	
000188A2 0000 0000                  		dc.w SME_CfLJT_41E-SME_CfLJT, SME_CfLJT_428-SME_CfLJT	
000188A6 0000 0000                  		dc.w SME_CfLJT_432-SME_CfLJT, SME_CfLJT_43C-SME_CfLJT	
000188AA 0000                       SME_CfLJT_FC:	dc.b 0, 0	
000188AC 0004 2000 7003 200B 200E   SME_CfLJT_FE:	dc.b 0, 4, $20, 0, $70, 3, $20, $B, $20, $E	
000188B6 0003 5011 5017 201D        SME_CfLJT_108:	dc.b 0, 3, $50, $11, $50, $17, $20, $1D	
000188BE 0003 5020 5017 201D        SME_CfLJT_110:	dc.b 0, 3, $50, $20, $50, $17, $20, $1D	
000188C6 0003 5020 5017 2026        SME_CfLJT_118:	dc.b 0, 3, $50, $20, $50, $17, $20, $26	
000188CE 0003 8029 200B 200E        SME_CfLJT_120:	dc.b 0, 3, $80, $29, $20, $B, $20, $E	
000188D6 0004 7032 503A 5040 1046   SME_CfLJT_128:	dc.b 0, 4, $70, $32, $50, $3A, $50, $40, $10, $46	
000188E0 0002 7032 B048             SME_CfLJT_132:	dc.b 0, 2, $70, $32, $B0, $48	
000188E6 0002 5054 805A             SME_CfLJT_138:	dc.b 0, 2, $50, $54, $80, $5A	
000188EC 0004 5054 5063 5069 106F   SME_CfLJT_13E:	dc.b 0, 4, $50, $54, $50, $63, $50, $69, $10, $6F	
000188F6 0002 5054 B071             SME_CfLJT_148:	dc.b 0, 2, $50, $54, $B0, $71	
000188FC 0003 7032 307D 5081        SME_CfLJT_14E:	dc.b 0, 3, $70, $32, $30, $7D, $50, $81	
00018904 0005 5087 508D 2093 5096+  SME_CfLJT_156:	dc.b 0, 5, $50, $87, $50, $8D, $20, $93, $50, $96, 0, $9C	
00018910 0006 5087 109D 309F 50A3+  SME_CfLJT_162:	dc.b 0, 6, $50, $87, $10, $9D, $30, $9F, $50, $A3, $30, $A9, 0, $AD	
0001891E 0004 50AE 10B4 70B6 20BE   SME_CfLJT_170:	dc.b 0, 4, $50, $AE, $10, $B4, $70, $B6, $20, $BE	
00018928 0005 50C1 30C7 70CB 20D3+  SME_CfLJT_17A:	dc.b 0, 5, $50, $C1, $30, $C7, $70, $CB, $20, $D3, $10, $D6	
00018934 0004 50C1 10D8 70DA 20E2   SME_CfLJT_186:	dc.b 0, 4, $50, $C1, $10, $D8, $70, $DA, $20, $E2	
0001893E 0005 5087 109D 0093 70E5+  SME_CfLJT_190:	dc.b 0, 5, $50, $87, $10, $9D, 0, $93, $70, $E5, $20, $ED	
0001894A 0004 70F0 50F8 10FE 5100   SME_CfLJT_19C:	dc.b 0, 4, $70, $F0, $50, $F8, $10, $FE, $51, 0	
00018954 0002 70F0 B106             SME_CfLJT_1A6:	dc.b 0, 2, $70, $F0, $B1, 6	
0001895A 0002 5112 8118             SME_CfLJT_1AC:	dc.b 0, 2, $51, $12, $81, $18	
00018960 0004 5112 5121 1127 5129   SME_CfLJT_1B2:	dc.b 0, 4, $51, $12, $51, $21, $11, $27, $51, $29	
0001896A 0002 5112 B12F             SME_CfLJT_1BC:	dc.b 0, 2, $51, $12, $B1, $2F	
00018970 0003 70F0 0106 813B        SME_CfLJT_1C2:	dc.b 0, 3, $70, $F0, 1, 6, $81, $3B	
00018978 0006 5144 114A 114C 814E+  SME_CfLJT_1CA:	dc.b 0, 6, $51, $44, $11, $4A, $11, $4C, $81, $4E, 1, $57, 1, $58	
00018986 0006 5144 2159 115C 115E+  SME_CfLJT_1D8:	dc.b 0, 6, $51, $44, $21, $59, $11, $5C, $11, $5E, $81, $60, 1, $57	
00018994 0004 5169 116F 8171 117A   SME_CfLJT_1E6:	dc.b 0, 4, $51, $69, $11, $6F, $81, $71, $11, $7A	
0001899E 0005 517C 2182 1185 7187+  SME_CfLJT_1F0:	dc.b 0, 5, $51, $7C, $21, $82, $11, $85, $71, $87, $21, $8F	
000189AA 0004 517C 1192 8194 119D   SME_CfLJT_1FC:	dc.b 0, 4, $51, $7C, $11, $92, $81, $94, $11, $9D	
000189B4 0005 5144 819F 115E 11A8+  SME_CfLJT_206:	dc.b 0, 5, $51, $44, $81, $9F, $11, $5E, $11, $A8, 1, $57	
000189C0 0002 51AA B1B0             SME_CfLJT_212:	dc.b 0, 2, $51, $AA, $B1, $B0	
000189C6 0002 5054 B1BC             SME_CfLJT_218:	dc.b 0, 2, $50, $54, $B1, $BC	
000189CC 0002 51AA B1C8             SME_CfLJT_21E:	dc.b 0, 2, $51, $AA, $B1, $C8	
000189D2 0002 5054 B1D4             SME_CfLJT_224:	dc.b 0, 2, $50, $54, $B1, $D4	
000189D8 0004 51E0 11E6 B1E8 01F4   SME_CfLJT_22A:	dc.b 0, 4, $51, $E0, $11, $E6, $B1, $E8, 1, $F4	
000189E2 0003 51F5 11FB B1FD        SME_CfLJT_234:	dc.b 0, 3, $51, $F5, $11, $FB, $B1, $FD	
000189EA 0004 51E0 1209 B20B 01F4   SME_CfLJT_23C:	dc.b 0, 4, $51, $E0, $12, 9, $B2, $B, 1, $F4	
000189F4 0003 51F5 11FB B217        SME_CfLJT_246:	dc.b 0, 3, $51, $F5, $11, $FB, $B2, $17	
000189FC 0002 5223 B229             SME_CfLJT_24E:	dc.b 0, 2, $52, $23, $B2, $29	
00018A02 0002 5112 B235             SME_CfLJT_254:	dc.b 0, 2, $51, $12, $B2, $35	
00018A08 0002 5223 B241             SME_CfLJT_25A:	dc.b 0, 2, $52, $23, $B2, $41	
00018A0E 0002 5112 B24D             SME_CfLJT_260:	dc.b 0, 2, $51, $12, $B2, $4D	
00018A14 0004 5259 125F B261 026D   SME_CfLJT_266:	dc.b 0, 4, $52, $59, $12, $5F, $B2, $61, 2, $6D	
00018A1E 0002 726E B276             SME_CfLJT_270:	dc.b 0, 2, $72, $6E, $B2, $76	
00018A24 0004 5259 1282 B284 026D   SME_CfLJT_276:	dc.b 0, 4, $52, $59, $12, $82, $B2, $84, 2, $6D	
00018A2E 0002 726E B290             SME_CfLJT_280:	dc.b 0, 2, $72, $6E, $B2, $90	
00018A34 0001 F29C                  SME_CfLJT_286:	dc.b 0, 1, $F2, $9C	
00018A38 0001 F2AC                  SME_CfLJT_28A:	dc.b 0, 1, $F2, $AC	
00018A3C 0001 F2BC                  SME_CfLJT_28E:	dc.b 0, 1, $F2, $BC	
00018A40 0001 F2CC                  SME_CfLJT_292:	dc.b 0, 1, $F2, $CC	
00018A44 0001 F2DC                  SME_CfLJT_296:	dc.b 0, 1, $F2, $DC	
00018A48 0000                       SME_CfLJT_29A:	dc.b 0, 0	
00018A4A 0000                       SME_CfLJT_29C:	dc.b 0, 0	
00018A4C 0000                       SME_CfLJT_29E:	dc.b 0, 0	
00018A4E 0000                       SME_CfLJT_2A0:	dc.b 0, 0	
00018A50 0002 52EC B2F2             SME_CfLJT_2A2:	dc.b 0, 2, $52, $EC, $B2, $F2	
00018A56 0004 52FE 7304 130C 030E   SME_CfLJT_2A8:	dc.b 0, 4, $52, $FE, $73, 4, $13, $C, 3, $E	
00018A60 0004 130F 7311 2319 031C   SME_CfLJT_2B2:	dc.b 0, 4, $13, $F, $73, $11, $23, $19, 3, $1C	
00018A6A 0003 231D 2320 F323        SME_CfLJT_2BC:	dc.b 0, 3, $23, $1D, $23, $20, $F3, $23	
00018A72 0003 B333 733F 0071        SME_CfLJT_2C4:	dc.b 0, 3, $B3, $33, $73, $3F, 0, $71	
00018A7A 0003 7347 334F 2353        SME_CfLJT_2CC:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018A82 0001 8356                  SME_CfLJT_2D4:	dc.b 0, 1, $83, $56	
00018A86 0003 735F 0367 3368        SME_CfLJT_2D8:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018A8E 0003 736C 3374 2378        SME_CfLJT_2E0:	dc.b 0, 3, $73, $6C, $33, $74, $23, $78	
00018A96 0003 B37B 1387 0389        SME_CfLJT_2E8:	dc.b 0, 3, $B3, $7B, $13, $87, 3, $89	
00018A9E 0004 B38A 3396 039A 039B   SME_CfLJT_2F0:	dc.b 0, 4, $B3, $8A, $33, $96, 3, $9A, 3, $9B	
00018AA8 0004 B39C 33A8 03AC 03AD   SME_CfLJT_2FA:	dc.b 0, 4, $B3, $9C, $33, $A8, 3, $AC, 3, $AD	
00018AB2 0000                       SME_CfLJT_304:	dc.b 0, 0	
00018AB4 0000                       SME_CfLJT_306:	dc.b 0, 0	
00018AB6 0002 83AE 73B7             SME_CfLJT_308:	dc.b 0, 2, $83, $AE, $73, $B7	
00018ABC 0003 83BF 23C8 13CB        SME_CfLJT_30E:	dc.b 0, 3, $83, $BF, $23, $C8, $13, $CB	
00018AC4 0002 83CD 73D6             SME_CfLJT_316:	dc.b 0, 2, $83, $CD, $73, $D6	
00018ACA 0003 83BF 23DE 13E1        SME_CfLJT_31C:	dc.b 0, 3, $83, $BF, $23, $DE, $13, $E1	
00018AD2 0000                       SME_CfLJT_324:	dc.b 0, 0	
00018AD4 0000                       SME_CfLJT_326:	dc.b 0, 0	
00018AD6 0000                       SME_CfLJT_328:	dc.b 0, 0	
00018AD8 0005 73E3 13EB 53ED 33F3+  SME_CfLJT_32A:	dc.b 0, 5, $73, $E3, $13, $EB, $53, $ED, $33, $F3, 3, $F7	
00018AE4 0005 73F8 13EB 5400 33F3+  SME_CfLJT_336:	dc.b 0, 5, $73, $F8, $13, $EB, $54, 0, $33, $F3, 3, $F7	
00018AF0 0000                       SME_CfLJT_342:	dc.b 0, 0	
00018AF2 0000                       SME_CfLJT_344:	dc.b 0, 0	
00018AF4 0000                       SME_CfLJT_346:	dc.b 0, 0	
00018AF6 0000                       SME_CfLJT_348:	dc.b 0, 0	
00018AF8 0000                       SME_CfLJT_34A:	dc.b 0, 0	
00018AFA 0003 7347 334F 2353        SME_CfLJT_34C:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018B02 0003 735F 0367 3368        SME_CfLJT_354:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018B0A 0003 B406 1412 3414        SME_CfLJT_35C:	dc.b 0, 3, $B4, 6, $14, $12, $34, $14	
00018B12 0003 5418 B41E 106D        SME_CfLJT_364:	dc.b 0, 3, $54, $18, $B4, $1E, $10, $6D	
00018B1A 0002 F42A 243A             SME_CfLJT_36C:	dc.b 0, 2, $F4, $2A, $24, $3A	
00018B20 0002 F43D 244D             SME_CfLJT_372:	dc.b 0, 2, $F4, $3D, $24, $4D	
00018B26 0002 F450 2460             SME_CfLJT_378:	dc.b 0, 2, $F4, $50, $24, $60	
00018B2C 0002 F463 2473             SME_CfLJT_37E:	dc.b 0, 2, $F4, $63, $24, $73	
00018B32 0002 F476 1486             SME_CfLJT_384:	dc.b 0, 2, $F4, $76, $14, $86	
00018B38 0000                       SME_CfLJT_38A:	dc.b 0, 0	
00018B3A 0000                       SME_CfLJT_38C:	dc.b 0, 0	
00018B3C 0000                       SME_CfLJT_38E:	dc.b 0, 0	
00018B3E 0000                       SME_CfLJT_390:	dc.b 0, 0	
00018B40 0000                       SME_CfLJT_392:	dc.b 0, 0	
00018B42 0000                       SME_CfLJT_394:	dc.b 0, 0	
00018B44 0000                       SME_CfLJT_396:	dc.b 0, 0	
00018B46 0000                       SME_CfLJT_398:	dc.b 0, 0	
00018B48 0000                       SME_CfLJT_39A:	dc.b 0, 0	
00018B4A 0000                       SME_CfLJT_39C:	dc.b 0, 0	
00018B4C 0000                       SME_CfLJT_39E:	dc.b 0, 0	
00018B4E 0000                       SME_CfLJT_3A0:	dc.b 0, 0	
00018B50 0003 5488 B48E 149A        SME_CfLJT_3A2:	dc.b 0, 3, $54, $88, $B4, $8E, $14, $9A	
00018B58 0003 B49C 14A8 34AA        SME_CfLJT_3AA:	dc.b 0, 3, $B4, $9C, $14, $A8, $34, $AA	
00018B60 0002 B4AE 14BA             SME_CfLJT_3B2:	dc.b 0, 2, $B4, $AE, $14, $BA	
00018B66 0001 F4BC                  SME_CfLJT_3B8:	dc.b 0, 1, $F4, $BC	
00018B6A 0002 B4CC 14D8             SME_CfLJT_3BC:	dc.b 0, 2, $B4, $CC, $14, $D8	
00018B70 0003 B4DA 14E6 14E8        SME_CfLJT_3C2:	dc.b 0, 3, $B4, $DA, $14, $E6, $14, $E8	
00018B78 0003 54EA B4F0 34FC        SME_CfLJT_3CA:	dc.b 0, 3, $54, $EA, $B4, $F0, $34, $FC	
00018B80 0003 B500 150C 350E        SME_CfLJT_3D2:	dc.b 0, 3, $B5, 0, $15, $C, $35, $E	
00018B88 0002 B512 151E             SME_CfLJT_3DA:	dc.b 0, 2, $B5, $12, $15, $1E	
00018B8E 0002 B520 152C             SME_CfLJT_3E0:	dc.b 0, 2, $B5, $20, $15, $2C	
00018B94 0003 B52E 153A 353C        SME_CfLJT_3E6:	dc.b 0, 3, $B5, $2E, $15, $3A, $35, $3C	
00018B9C 0002 F540 3550             SME_CfLJT_3EE:	dc.b 0, 2, $F5, $40, $35, $50	
00018BA2 0002 B554 5560             SME_CfLJT_3F4:	dc.b 0, 2, $B5, $54, $55, $60	
00018BA8 0002 B566 2572             SME_CfLJT_3FA:	dc.b 0, 2, $B5, $66, $25, $72	
00018BAE 0002 B575 2581             SME_CfLJT_400:	dc.b 0, 2, $B5, $75, $25, $81	
00018BB4 0003 B584 2590 5593        SME_CfLJT_406:	dc.b 0, 3, $B5, $84, $25, $90, $55, $93	
00018BBC 0003 B599 55A5 35AB        SME_CfLJT_40E:	dc.b 0, 3, $B5, $99, $55, $A5, $35, $AB	
00018BC4 0003 B5AF 55BB 15C1        SME_CfLJT_416:	dc.b 0, 3, $B5, $AF, $55, $BB, $15, $C1	
00018BCC 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_41E:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BD6 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_428:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BE0 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_432:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BEA 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_43C:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BF4                            		even
00018BF4                            		even
00018BF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018BF4                            Ani_ObjPlayer:
00018BF4                            		include	"Objects/Player/Animations.asm"
00018BF4                            ; ---------------------------------------------------------------------------
00018BF4                            ; Animation script - Sonic
00018BF4                            ; ---------------------------------------------------------------------------
00018BF4                            SonicAniData:
00018BF4 0000                       		dc.w SonicAni_Walk-SonicAniData
00018BF6 0000                       		dc.w SonicAni_Run-SonicAniData
00018BF8 0000                       		dc.w SonicAni_Roll-SonicAniData
00018BFA 0000                       		dc.w SonicAni_Roll2-SonicAniData
00018BFC 0000                       		dc.w SonicAni_Push-SonicAniData
00018BFE 0000                       		dc.w SonicAni_Wait-SonicAniData
00018C00 0000                       		dc.w SonicAni_Balance-SonicAniData
00018C02 0000                       		dc.w SonicAni_LookUp-SonicAniData
00018C04 0000                       		dc.w SonicAni_Duck-SonicAniData
00018C06 0000                       		dc.w SonicAni_Sprint-SonicAniData
00018C08 0000                       		dc.w SonicAni_Hang-SonicAniData
00018C0A 0000                       		dc.w SonicAni_Seizure-SonicAniData
00018C0C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C0E 0000                       		dc.w SonicAni_Skid-SonicAniData
00018C10 0000                       		dc.w SonicAni_Float1-SonicAniData
00018C12 0000                       		dc.w SonicAni_Float2-SonicAniData
00018C14 0000                       		dc.w SonicAni_Spring-SonicAniData
00018C16 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C18 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C1A 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C1C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C1E 0000                       		dc.w SonicAni_Bubble-SonicAniData
00018C20 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C22 0000                       		dc.w SonicAni_Drown-SonicAniData
00018C24 0000                       		dc.w SonicAni_Death-SonicAniData
00018C26 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C28 0000                       		dc.w SonicAni_Hurt-SonicAniData
00018C2A 0000                       		dc.w SonicAni_Slide-SonicAniData
00018C2C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018C2E 0000                       		dc.w SonicAni_Float3-SonicAniData
00018C30 0000                       		dc.w SonicAni_Float4-SonicAniData
00018C32 0100 FD00                  SonicAni_Blank:		dc.b 1, 0, $FD, 0
00018C36 FF08 090A 0B06 07FF        SonicAni_Walk:		dc.b $FF, $08, $09, $0A, $0B, $06, $07, $FF
00018C3E FF1E 1F20 21FF FFFF        SonicAni_Run:		dc.b $FF, $1E, $1F, $20, $21, $FF, $FF,	$FF
00018C46 FF58 595A 5BFF FFFF        SonicAni_Sprint:	dc.b $FF, $58, $59, $5A, $5B, $FF, $FF, $FF
00018C4E FE2E 2F30 3132 FFFF        SonicAni_Roll:		dc.b $FE, $2E, $2F, $30, $31, $32, $FF,	$FF
00018C56 FE2E 2F32 3031 32FF        SonicAni_Roll2:		dc.b $FE, $2E, $2F, $32, $30, $31, $32,	$FF
00018C5E FD45 4647 48FF FFFF        SonicAni_Push:		dc.b $FD, $45, $46, $47, $48, $FF, $FF,	$FF
00018C66 1701 0101 0101 0101 0101+  SonicAni_Wait:		dc.b $17, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 3, 2, 2, 2, 3, 4, $FE, 2, 0
00018C7C 1F3A 3BFF                  SonicAni_Balance:	dc.b $1F, $3A, $3B, $FF
00018C80 3F05 FF00                  SonicAni_LookUp:	dc.b $3F, 5, $FF, 0
00018C84 3F39 FF00                  SonicAni_Duck:		dc.b $3F, $39, $FF, 0
00018C88 0737 38FF                  SonicAni_Skid:		dc.b 7,	$37, $38, $FF
00018C8C 073C 3FFF                  SonicAni_Float1:	dc.b 7,	$3C, $3F, $FF
00018C90 073C 3D53 3E54 FF00        SonicAni_Float2:	dc.b 7,	$3C, $3D, $53, $3E, $54, $FF, 0
00018C98 2F40 FD00                  SonicAni_Spring:	dc.b $2F, $40, $FD, 0
00018C9C FC78 7978 77FF             SonicAni_Hang:		dc.b $FC, $78, $79, $78, $77, $FF
00018CA2 0B56 560A 0BFD 0000        SonicAni_Bubble:	dc.b $B, $56, $56, $A, $B, $FD,	0, 0
00018CAA 2F4C FF00                  SonicAni_Drown:		dc.b $2F, $4C, $FF, 0
00018CAE 034D FF00                  SonicAni_Death:		dc.b 3,	$4D, $FF, 0
00018CB2 0355 FF00                  SonicAni_Hurt:		dc.b 3,	$55, $FF, 0
00018CB6 0755 57FF                  SonicAni_Slide:		dc.b 7, $55, $57, $FF
00018CBA 033C 3D53 3E54 FF00        SonicAni_Float3:	dc.b 3,	$3C, $3D, $53, $3E, $54, $FF, 0
00018CC2 033C FD00                  SonicAni_Float4:	dc.b 3,	$3C, $FD, 0
00018CC6 027A 7B7C 7DFF             SonicAni_Seizure:	dc.b 2, $7A, $7B, $7C, $7D, $FF
00018CCC                            		even
00018CCC                            		even
00018CCC                            ; =========================================================================================================================================================
00018CCC                            		include	"Objects/Ring/Code.asm"		; Ring loss object
00018CCC                            ; =========================================================================================================================================================
00018CCC                            ; Water surface object
00018CCC                            ; =========================================================================================================================================================
00018CCC                            		rsset	oLvlSSTs
00018CCC                            
00018CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018CCC                            ObjRingLoss:
00018CCC 2248                       		movea.l	a0,a1
00018CCE 7A00                       		moveq	#0,d5
00018CD0 3A38 F3D4                  		move.w	rRings.w,d5
00018CD4 7020                       		moveq	#32,d0
00018CD6 BA40                       		cmp.w	d0,d5
00018CD8 6500                       		bcs.s	.BelowMax
00018CDA 3A00                       		move.w	d0,d5
00018CDC                            
00018CDC                            .BelowMax:
00018CDC 5345                       		subq.w	#1,d5
00018CDE 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00018CE4 6000                       		bra.s	.MakeRings
00018CE6                            
00018CE6                            .Loop:
00018CE6 4EB8 1A1C                  		jsr	FindFreeObj.w
00018CEA 6700                       		beq.s	.ResetCounter
00018CEC                            
00018CEC                            .MakeRings:
00018CEC 22BC 0000 0000             		move.l	#ObjLostRing,oAddr(a1)
00018CF2 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00018CF8 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00018CFE 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,oMap(a1)	; Mappings
00018D06 337C 26B4 000E             		move.w	#$26B4,oVRAM(a1)		; Tile properties
00018D0C 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00018D12                            	displaySprite	3,a1,a2,0			; Priority
00018D12 337C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a1)
00018D18 3478 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a2
00018D1C 334A 000A                M 	move.w	a2,odrawprev(a1)
00018D20 3549 0008                M 	move.w	a1,odrawnext(a2)
00018D24 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00018D28                          M .no_229
00018D28 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00018D2E 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00018D34 137C 0008 002C             		move.b	#8,oColW(a1)			; Collision width
00018D3A 137C 0008 002D             		move.b	#8,oColH(a1)			; Collision height
00018D40 335B 001C                  		move.w	(a3)+,oXVel(a1)
00018D44 335B 001E                  		move.w	(a3)+,oYVel(a1)
00018D48 51CD FF9C                  		dbf	d5,.Loop
00018D4C 11FC 00FF F3D9             		move.b	#-1,rRLossAniT.w
00018D52                            
00018D52                            .ResetCounter:
00018D52 4278 F3D4                  		clr.w	rRings.w
00018D56 11FC 0001 F8F3             		move.b	#1,rUpdateRings.w
00018D5C                            		playSnd	#sRingLoss, 2
00018D5C 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00018D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D62                            ObjLostRing:
00018D62 4EB8 1D4C                  		jsr	ObjectMove.w
00018D66 0668 0018 001E             		addi.w	#$18,oYVel(a0)
00018D6C 6B00                       		bmi.s	.ChkCol
00018D6E 1038 C759                  		move.b	(rFrameCnt+3).w,d0
00018D72 D048                       		add.w	a0,d0
00018D74 0200 0006                  		andi.b	#6,d0
00018D78 6600                       		bne.s	.ChkCol
00018D7A 4EB8 305C                  		jsr	ObjCheckFloorDist
00018D7E 4A41                       		tst.w	d1
00018D80 6A00                       		bpl.s	.ChkCol
00018D82 D368 0018                  		add.w	d1,oYPos(a0)
00018D86 3028 001E                  		move.w	oYVel(a0),d0
00018D8A E440                       		asr.w	#2,d0
00018D8C 9168 001E                  		sub.w	d0,oYVel(a0)
00018D90 4468 001E                  		neg.w	oYVel(a0)
00018D94                            
00018D94                            .ChkCol:
00018D94 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00018D98 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00018D9C 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
00018DA0 4A40                       		tst.w	d0				; ''
00018DA2 6700                       		beq.s	.ChkDel				; If not, branch
00018DA4 0C2A 0069 0042             		cmpi.b	#105,oInvulTime(a2)
00018DAA 6400                       		bhs.s	.ChkDel
00018DAC 6000                       		bra.s	ObjLostRing_Collect
00018DAE                            
00018DAE                            .ChkDel:
00018DAE 4A38 F3D9                  		tst.b	rRLossAniT.w
00018DB2 6700 0000                  		beq.w	ObjLostRing_Delete
00018DB6 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
00018DBA 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00018DBE B068 0018                  		cmp.w	oYPos(a0),d0			; Have we touched the bottom boundary?
00018DC2 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00018DC4                            	nextObject
00018DC4 3068 0004                M 	movea.w	onext(a0),a0
00018DC8 2250                     M 	move.l	oaddr(a0),a1
00018DCA 4ED1                     M 	jmp	(a1)
00018DCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018DCC                            .RangeData:
00018DCC FFF0 0020                  		dc.w	-$10, $20
00018DD0 FFF0 0020                  		dc.w	-$10, $20
00018DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018DD4                            ObjLostRing_Collect:
00018DD4                            	removeSprite	a0,a1,0
00018DD4 3268 000A                M 	move.w	odrawprev(a0),a1
00018DD8 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00018DDE 3268 0008                M 	move.w	odrawnext(a0),a1
00018DE2 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00018DE8                          M .no_232
00018DE8 42A8 0008                M 	clr.l	odrawnext(a0)
00018DEC                          M .yes_232
00018DEC                            	displaySprite	1,a0,a1,0
00018DEC 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018DF2 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018DF6 3149 000A                M 	move.w	a1,odrawprev(a0)
00018DFA 3348 0008                M 	move.w	a0,odrawnext(a1)
00018DFE 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018E02                          M .no_233
00018E02 4EB8 3F66                  		jsr	CollectRing
00018E06 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00018E0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E0C                            ObjLostRing_Sparkle:
00018E0C 43F9 0000 0000             		lea	Ani_ObjRing,a1
00018E12 4EB8 1C66                  		jsr	AnimateObject.w
00018E16 4A28 0025                  		tst.b	oRoutine(a0)
00018E1A 6600                       		bne.s	ObjLostRing_Delete
00018E1C                            	nextObject
00018E1C 3068 0004                M 	movea.w	onext(a0),a0
00018E20 2250                     M 	move.l	oaddr(a0),a1
00018E22 4ED1                     M 	jmp	(a1)
00018E24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E24                            ObjLostRing_Delete:
00018E24 4EB8 1A72                  		jsr	DeleteObject.w
00018E28                            	nextObject
00018E28 3068 0004                M 	movea.w	onext(a0),a0
00018E2C 2250                     M 	move.l	oaddr(a0),a1
00018E2E 4ED1                     M 	jmp	(a1)
00018E30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E30                            ; Ring Spawn Array
00018E30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E30                            ObjLostRing_Speeds:
00018E30 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00018E40 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00018E50 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00018E60 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00018E70 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00018E80 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00018E90 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00018EA0 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00018EB0                            		even
00018EB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EB0                            ; Data
00018EB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EB0                            Map_ObjLostRing:
00018EB0                            		include	"Objects/Ring/Mappings.asm"
00018EB0                            ; --------------------------------------------------------------------------------
00018EB0                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00018EB0                            ; --------------------------------------------------------------------------------
00018EB0                            
00018EB0                            SME_k4ulR:	
00018EB0 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00018EB4 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00018EB8 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00018EBA 0001                       SME_k4ulrA:	dc.b 0, 1	
00018EBC F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00018EC2 0001                       SME_k4ulrC:	dc.b 0, 1	
00018EC4 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018ECA 0001                       SME_k4ulr14:	dc.b 0, 1	
00018ECC F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018ED2 0001                       SME_k4ulr1C:	dc.b 0, 1	
00018ED4 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00018EDA 0001                       SME_k4ulr24:	dc.b 0, 1	
00018EDC F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00018EE2                            		even
00018EE2                            		even
00018EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EE2                            Ani_ObjRing:
00018EE2 0000                       		dc.w	.Ani0-Ani_ObjRing
00018EE4 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00018EEA                            		even
00018EEA                            ; =========================================================================================================================================================
00018EEA                            		include	"Objects/Explosion/Code.asm"	; Explosion object
00018EEA                            ; =========================================================================================================================================================
00018EEA                            ; Explosion object
00018EEA                            ; =========================================================================================================================================================
00018EEA =00000003                  EXPLODE_ANI	EQU	3
00018EEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EEA                            ObjBossExplode:
00018EEA                            		playSnd	#sBomb, 2			; Play explosion sound
00018EEA 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00018EF0 6000                       		bra.s	ObjExplosion_Init		; Continue
00018EF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EF2                            ObjExplosion:
00018EF2                            		playSnd	#sBreakItem, 2			; Play explosion sound
00018EF2 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00018EF8                            
00018EF8                            ObjExplosion_Init:
00018EF8 20BC 0000 0000             		move.l	#ObjExplosion_Main,oAddr(a0)	; Next routine
00018EFE 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00018F04 317C 86C0 000E             		move.w	#$86C0,oVRAM(a0)		; Tile properties
00018F0A 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,oMap(a0)	; Mappings
00018F12                            	displaySprite	1,a0,a1,0			; Priority
00018F12 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018F18 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018F1C 3149 000A                M 	move.w	a1,odrawprev(a0)
00018F20 3348 0008                M 	move.w	a0,odrawnext(a1)
00018F24 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018F28                          M .no_238
00018F28 117C 000C 0017             		move.b	#$C,oDrawW(a0)			; Sprite width
00018F2E 117C 000C 001B             		move.b	#$C,oDrawH(a0)			; Sprite height
00018F34 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Animation timer
00018F3A 4228 0010                  		clr.b	oFrame(a0)			; Mapping frame
00018F3E                            		
00018F3E                            ObjExplosion_Main:
00018F3E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00018F42 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00018F44 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Reset animation timer
00018F4A 5228 0010                  		addq.b	#1,oFrame(a0)			; Next frame
00018F4E 0C28 0005 0010             		cmpi.b	#5,oFrame(a0)			; Has it reached the last frame?
00018F54 6600                       		bne.s	.Display			; If not, branch
00018F56 4EB8 1A72                  		jsr	DeleteObject.w
00018F5A                            		
00018F5A                            .Display:
00018F5A                            	nextObject
00018F5A 3068 0004                M 	movea.w	onext(a0),a0
00018F5E 2250                     M 	move.l	oaddr(a0),a1
00018F60 4ED1                     M 	jmp	(a1)
00018F62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018F62                            ; Data
00018F62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018F62                            ArtKosM_Explosion:
00018F62                            		incbin	"Objects/Explosion/Art.kosm.bin"
000193F4                            		even
000193F4                            Map_ObjExplosion:
000193F4                            		include	"Objects/Explosion/Mappings.asm"
000193F4                            ; --------------------------------------------------------------------------------
000193F4                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000193F4                            ; --------------------------------------------------------------------------------
000193F4                            
000193F4                            SME_PS_OI:	
000193F4 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
000193F8 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
000193FC 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
000193FE 0001                       SME_PS_OI_A:	dc.b 0, 1	
00019400 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
00019406 0001                       SME_PS_OI_12:	dc.b 0, 1	
00019408 F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
0001940E 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00019410 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
00019416 0004                       SME_PS_OI_22:	dc.b 0, 4	
00019418 EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
0001941E EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
00019424 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
0001942A FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00019430 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00019432 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
00019438 EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
0001943E 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
00019444 FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
0001944A                            		even
0001944A                            		even
0001944A                            ; =========================================================================================================================================================
0001944A                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
0001944A                            ; =========================================================================================================================================================
0001944A                            ; Water surface object
0001944A                            ; =========================================================================================================================================================
0001944A                            		rsset	oLvlSSTs
0001944A =00000030                  oSurfPause	rs.b	1			; Animation stop flag
0001944A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001944A                            ObjWaterSurface:
0001944A 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,oAddr(a0)	; Next routine
00019450 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,oMap(a0)	; Mappings
00019458 317C 8690 000E             		move.w	#$8690,oVRAM(a0)		; Tile properties
0001945E 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00019464                            	displaySprite	0,a0,a1,0			; Priority
00019464 317C BE5A 0008           M 	move.w	#rdispinput+(0*dsize),odrawnext(a0)
0001946A 3278 BE64                M 	move.w	rdispinput+dprev+(0*dsize).w,a1
0001946E 3149 000A                M 	move.w	a1,odrawprev(a0)
00019472 3348 0008                M 	move.w	a0,odrawnext(a1)
00019476 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
0001947A                          M .no_240
0001947A 117C 0080 0017             		move.b	#$80,oDrawW(a0)			; Sprite width
00019480 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
00019486                            
00019486                            ObjWaterSurface_Main:
00019486 3238 F8F6                  		move.w	rWaterLvl.w,d1		; Get water height
0001948A 5D41                       		subq.w	#6,d1				; Shift it
0001948C 3141 0018                  		move.w	d1,oYPos(a0)			; Set Y position
00019490                            
00019490 4A28 0030                  		tst.b	oSurfPause(a0)			; Is the animation paused?
00019494 6600                       		bne.s	.ChkUnpause			; If so, branch
00019496 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
0001949C 6700                       		beq.s	.Animate			; If not, branch
0001949E 5628 0010                  		addq.b	#3,oFrame(a0)			; Use different frames
000194A2 50E8 0030                  		st	oSurfPause(a0)			; Pause the animation
000194A6 6000                       		bra.s	.Animate			; Continue
000194A8                            
000194A8                            .ChkUnpause:
000194A8 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game paused?
000194AC 6600                       		bne.s	.Animate			; If so, branch
000194AE 4228 0030                  		clr.b	oSurfPause(a0)			; Resume animation
000194B2 5728 0010                  		subq.b	#3,oFrame(a0)			; Use normal frames
000194B6                            
000194B6                            .Animate:
000194B6 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
000194BA 7200                       		moveq	#0,d1
000194BC 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation script frame
000194C0 1171 1000 0010             		move.b	(a1,d1.w),oFrame(a0)		; Set mapping frame
000194C6 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next frame in animation script
000194CA 0228 003F 0022             		andi.b	#$3F,oAniFrame(a0)		; Loop in necessary
000194D0                            	nextObject
000194D0 3068 0004                M 	movea.w	onext(a0),a0
000194D4 2250                     M 	move.l	oaddr(a0),a1
000194D6 4ED1                     M 	jmp	(a1)
000194D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000194D8                            .AniScript:
000194D8 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
000194E8 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
000194F8 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
00019508 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00019518 00                         		even
00019518                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019518                            ; Data
00019518                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019518                            Map_ObjWaterSurface:
00019518                            		include	"Objects/Water Surface/Mappings.asm"
00019518                            MapConv_obj1B:
00019518 0000                       	dc.w	byte_11178-MapConv_obj1B
0001951A 0000                       	dc.w	byte_11188-MapConv_obj1B
0001951C 0000                       	dc.w	byte_11198-MapConv_obj1B
0001951E 0000                       	dc.w	byte_111A8-MapConv_obj1B
00019520 0000                       	dc.w	byte_111C7-MapConv_obj1B
00019522 0000                       	dc.w	byte_111E6-MapConv_obj1B
00019524                            
00019524 0003                       byte_11178:	dc.w 3
00019526 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
0001952C FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00019532 FD0D 0000 0020             	dc.w $FD0D, 0, $20
00019538                            
00019538 0003                       byte_11188:	dc.w 3
0001953A FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00019540 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00019546 FD0D 0008 0020             	dc.w $FD0D, 8, $20
0001954C                            
0001954C 0003                       byte_11198:	dc.w 3
0001954E FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00019554 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
0001955A FD0D 0800 0020             	dc.w $FD0D, $800, $20
00019560                            
00019560 0006                       byte_111A8:	dc.w 6
00019562 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00019568 FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
0001956E FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00019574 FD0D 0000 0000             	dc.w $FD0D, 0, 0
0001957A FD0D 0000 0020             	dc.w $FD0D, 0, $20
00019580 FD0D 0000 0040             	dc.w $FD0D, 0, $40
00019586                            
00019586 0006                       byte_111C7:	dc.w 6
00019588 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
0001958E FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
00019594 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
0001959A FD0D 0008 0000             	dc.w $FD0D, 8, 0
000195A0 FD0D 0008 0020             	dc.w $FD0D, 8, $20
000195A6 FD0D 0008 0040             	dc.w $FD0D, 8, $40
000195AC                            
000195AC 0006                       byte_111E6:	dc.w 6
000195AE FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000195B4 FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
000195BA FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000195C0 FD0D 0800 0000             	dc.w $FD0D, $800, 0
000195C6 FD0D 0800 0020             	dc.w $FD0D, $800, $20
000195CC FD0D 0800 0040             	dc.w $FD0D, $800, $40
000195D2                            
000195D2                            	even
000195D2                            		even
000195D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000195D2                            ArtKosM_WaterSurface:
000195D2                            		incbin	"Objects/Water Surface/Art.kosm.bin"
0001972C                            		even
0001972C                            ; =========================================================================================================================================================
0001972C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001972C                            		include	"Objects/Monitor/Code.asm"	; Monitor object
0001972C                            ; =========================================================================================================================================================
0001972C                            ; Monitor object
0001972C                            ; =========================================================================================================================================================
0001972C                            		rsset	oLvlSSTs
0001972C =00000030                  oMonFall	rs.b	1				; Fall flag
0001972C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001972C                            ObjMonitor:
0001972C 20BC 0000 0000             		move.l	#ObjMonitorMain,oAddr(a0)
00019732 117C 000E 002D             		move.b	#$E,oColH(a0)
00019738 117C 000E 002C             		move.b	#$E,oColW(a0)
0001973E 217C 0000 0000 0010        		move.l	#Map_ObjMonitor,oMap(a0)
00019746 317C 0588 000E             		move.w	#$588,oVRAM(a0)
0001974C 117C 0004 000D             		move.b	#4,oRender(a0)
00019752                            	displaySprite	3,a0,a1,0			; Priority
00019752 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
00019758 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
0001975C 3149 000A                M 	move.w	a1,odrawprev(a0)
00019760 3348 0008                M 	move.w	a0,odrawnext(a1)
00019764 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
00019768                          M .no_242
00019768 117C 000F 0017             		move.b	#$F,oDrawW(a0)
0001976E 117C 000F 001B             		move.b	#$F,oDrawH(a0)
00019774 3028 0026                  		move.w	oRespawn(a0),d0
00019778 6700                       		beq.s	ObjMonitorNotBroken
0001977A 3440                       		movea.w	d0,a2
0001977C 0812 0000                  		btst	#0,(a2)				; has monitor been broken?
00019780 6700                       		beq.s	ObjMonitorNotBroken		; if not, branch
00019782 117C 0007 0010             		move.b	#7,oFrame(a0)		; use broken monitor frame
00019788 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
0001978E                            	nextObject
0001978E 3068 0004                M 	movea.w	onext(a0),a0
00019792 2250                     M 	move.l	oaddr(a0),a1
00019794 4ED1                     M 	jmp	(a1)
00019796                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019796                            ObjMonitorNotBroken:
00019796 117C 0006 002A             		move.b	#6,oColType(a0)
0001979C 1168 0024 0020             		move.b	oSubtype(a0),oAni(a0)
000197A2                            
000197A2                            ObjMonitorMain:
000197A2 6100                       		bsr.s	ObjMonitorFall
000197A4 323C 0019                  		move.w	#$19,d1
000197A8 343C 0010                  		move.w	#$10,d2
000197AC 3602                       		move.w	d2,d3
000197AE 3828 0014                  		move.w	oXPos(a0),d4
000197B2 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000197B6 6100                       		bsr.s	SolidObject_Monitor
000197B8                            
000197B8 3038 F8C2                  		move.w	rMaxCamY.w,d0
000197BC 0640 00E0                  		addi.w	#$E0,d0
000197C0 B068 0018                  		cmp.w	oYPos(a0),d0
000197C4 6D00                       		blt.s	ObjMonitorDelete
000197C6                            
000197C6 4EB8 4A76                  		jsr	AddToColResponse
000197CA 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
000197CE 4EB8 1C66                  		jsr	AnimateObject.w
000197D2 4EB8 2024                  		jsr	CheckObjActive.w
000197D6                            	nextObject
000197D6 3068 0004                M 	movea.w	onext(a0),a0
000197DA 2250                     M 	move.l	oaddr(a0),a1
000197DC 4ED1                     M 	jmp	(a1)
000197DE                            
000197DE                            ObjMonitorDelete:
000197DE 4EB8 1A72                  		jsr	DeleteObject.w
000197E2                            	nextObject
000197E2 3068 0004                M 	movea.w	onext(a0),a0
000197E6 2250                     M 	move.l	oaddr(a0),a1
000197E8 4ED1                     M 	jmp	(a1)
000197EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197EA                            ObjMonitorAnimate:
000197EA 0C28 0007 0010             		cmpi.b	#7,oFrame(a0)
000197F0 6500                       		bcs.s	.NotBroken
000197F2 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
000197F8                            
000197F8                            .NotBroken:
000197F8 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
000197FC 4EB8 1C66                  		jsr	AnimateObject.w
00019800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019800                            ObjMonitorCheckActive:
00019800 4EB8 2024                  		jsr	CheckObjActive.w
00019804                            	nextObject
00019804 3068 0004                M 	movea.w	onext(a0),a0
00019808 2250                     M 	move.l	oaddr(a0),a1
0001980A 4ED1                     M 	jmp	(a1)
0001980C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001980C                            ObjMonitorFall:
0001980C 1028 0030                  		move.b	oMonFall(a0),d0
00019810 6700                       		beq.s	.End
00019812 4EB8 1D66                  		jsr	ObjectMoveAndFall.w
00019816 4A68 001E                  		tst.w	oYVel(a0)
0001981A 6B00                       		bmi.s	.End
0001981C 4EB8 305C                  		jsr	ObjCheckFloorDist
00019820 4A41                       		tst.w	d1
00019822 6700                       		beq.s	.InGround
00019824 6A00                       		bpl.s	.End
00019826                            
00019826                            .InGround:
00019826 D368 0018                  		add.w	d1,oYPos(a0)
0001982A 4268 001E                  		clr.w	oYVel(a0)
0001982E 4228 0030                  		clr.b	oMonFall(a0)
00019832                            
00019832                            .End:
00019832 4E75                       		rts
00019834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019834                            SolidObject_Monitor:
00019834 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
0001983A 6600                       		bne.s	ObjMonitorChkOverEdge
0001983C 0C29 0002 0020             		cmpi.b	#2,oAni(a1)
00019842 6700                       		beq.s	.End
00019844 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)		; check if in drowning animation
0001984A 6600                       		bne.s	.SetSolid
0001984C                            
0001984C                            .End:
0001984C 4E75                       		rts
0001984E                            
0001984E                            .SetSolid:
0001984E 4EF8 45A8                  		jmp	SolidObject_ChkCollision
00019852                            
00019852                            ObjMonitorChkOverEdge:
00019852 3401                       		move.w	d1,d2
00019854 D442                       		add.w	d2,d2
00019856 0829 0001 0028             		btst	#1,oStatus(a1)
0001985C 6600                       		bne.s	.NotOnMonitor
0001985E 3029 0014                  		move.w	oXPos(a1),d0
00019862 9068 0014                  		sub.w	oXPos(a0),d0
00019866 D041                       		add.w	d1,d0
00019868 6B00                       		bmi.s	.NotOnMonitor
0001986A B042                       		cmp.w	d2,d0
0001986C 6500                       		blo.s	ObjMonitorCharStandOn
0001986E                            
0001986E                            .NotOnMonitor:
0001986E 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)
00019874 08E9 0001 0028             		bset	#1,oStatus(a1)
0001987A 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)
00019880 7800                       		moveq	#0,d4
00019882 4E75                       		rts
00019884                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019884                            ObjMonitorCharStandOn:
00019884 3404                       		move.w	d4,d2
00019886 4EB8 48D2                  		jsr	PlayerMoveOnPtfm
0001988A 7800                       		moveq	#0,d4
0001988C 4E75                       		rts
0001988E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001988E                            ObjMonitorBreakOpen:
0001988E                            		playSnd	#sBreakItem, 2			; Play destroy sound
0001988E 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00019894                            		
00019894 1028 0028                  		move.b	oStatus(a0),d0
00019898 0200 0028                  		andi.b	#cStand|cPush,d0
0001989C 6700                       		beq.s	ObjMonitorSpawnIcon
0001989E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000198A2 0229 00D7 0028             		andi.b	#$D7,oStatus(a1)
000198A8 0029 0002 0028             		ori.b	#2,oStatus(a1)
000198AE                            
000198AE                            ObjMonitorSpawnIcon:
000198AE 4228 0028                  		clr.b	oStatus(a0)
000198B2 117C 0000 002A             		move.b	#0,oColType(a0)
000198B8 4EB8 1A1C                  		jsr	FindFreeObj.w
000198BC 6700                       		beq.s	.SkipIconCreation
000198BE 22BC 0000 0000             		move.l	#ObjMonitorContents,oAddr(a1)		; load monitor contents	object
000198C4 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
000198CA 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
000198D0 1368 0020 0020             		move.b	oAni(a0),oAni(a1)
000198D6 1368 000D 000D             		move.b	oRender(a0),oRender(a1)
000198DC 1368 0028 0028             		move.b	oStatus(a0),oStatus(a1)
000198E2                            
000198E2                            .SkipIconCreation:
000198E2 4EB8 1A1C                  		jsr	FindFreeObj.w
000198E6 6700                       		beq.s	.SkipExplosionCreation
000198E8 22BC 0001 8EF2             		move.l	#ObjExplosion,oAddr(a1)			; load explosion object
000198EE 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
000198F4 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
000198FA                            
000198FA                            .SkipExplosionCreation:
000198FA 3028 0026                  		move.w	oRespawn(a0),d0
000198FE 6700                       		beq.s	.NotRemembered
00019900 3440                       		movea.w	d0,a2
00019902 08D2 0000                  		bset	#0,(a2)
00019906                            
00019906                            .NotRemembered:
00019906 117C 0006 0020             		move.b	#6,oAni(a0)
0001990C 20BC 0001 97EA             		move.l	#ObjMonitorAnimate,oAddr(a0)
00019912                            	nextObject
00019912 3068 0004                M 	movea.w	onext(a0),a0
00019916 2250                     M 	move.l	oaddr(a0),a1
00019918 4ED1                     M 	jmp	(a1)
0001991A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001991A                            ; Contents of monitor object
0001991A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001991A                            ObjMonitorContents:
0001991A 7000                       		moveq	#0,d0
0001991C 1028 0025                  		move.b	oRoutine(a0),d0
00019920 4EBB 0000                  		jsr	ObjMonitorContents_Index(pc,d0.w)
00019924                            	nextObject
00019924 3068 0004                M 	movea.w	onext(a0),a0
00019928 2250                     M 	move.l	oaddr(a0),a1
0001992A 4ED1                     M 	jmp	(a1)
0001992C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001992C                            ObjMonitorContents_Index:
0001992C 6000                       		bra.s	ObjMonitorContents_Main
0001992E 6000                       		bra.s	ObjMonitorContents_Move
00019930 6000 0000                  		bra.w	ObjMonitorContents_Delete
00019934                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019934                            ObjMonitorContents_Main:
00019934 5428 0025                  		addq.b	#2,oRoutine(a0)
00019938 317C 8588 000E             		move.w	#$8588,oVRAM(a0)
0001993E 117C 0024 000D             		move.b	#$24,oRender(a0)
00019944                            	displaySprite	3,a0,a1,0			; Priority
00019944 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0001994A 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
0001994E 3149 000A                M 	move.w	a1,odrawprev(a0)
00019952 3348 0008                M 	move.w	a0,odrawnext(a1)
00019956 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0001995A                          M .no_250
0001995A 117C 0008 0017             		move.b	#8,oDrawW(a0)
00019960 117C 0008 001B             		move.b	#8,oDrawH(a0)
00019966 317C FD00 001E             		move.w	#-$300,oYVel(a0)
0001996C 7000                       		moveq	#0,d0
0001996E 1028 0020                  		move.b	oAni(a0),d0
00019972 5200                       		addq.b	#1,d0
00019974 227C 0000 0000             		movea.l	#Map_ObjMonitor,a1
0001997A D000                       		add.b	d0,d0
0001997C D2F1 0000                  		adda.w	(a1,d0.w),a1
00019980 5449                       		addq.w	#2,a1
00019982 2149 0010                  		move.l	a1,oMap(a0)
00019986                            
00019986 1028 0020                  		move.b	oAni(a0),d0
0001998A 5200                       		addq.b	#1,d0
0001998C 1140 0010                  		move.b	d0,oFrame(a0)
00019990                            
00019990                            ObjMonitorContents_Move:
00019990 4A68 001E                  		tst.w	oYVel(a0)			; is object moving?
00019994 6A00 0000                  		bpl.w	ObjMonitorContents_GetType	; if not, branch
00019998 4EB8 1D4C                  		jsr	ObjectMove.w
0001999C 0668 0018 001E             		addi.w	#$18,oYVel(a0)			; reduce object	speed
000199A2 4E75                       		rts
000199A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199A4                            ObjMonitorContents_GetType:
000199A4 5428 0025                  		addq.b	#2,oRoutine(a0)
000199A8 117C 001D 0023             		move.b	#29,oAniTimer(a0)
000199AE 1028 0020                  		move.b	oAni(a0),d0
000199B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199B2 0C00 0001                  		cmpi.b	#1,d0
000199B6 6600                       		bne.s	.ChkRings
000199B8                            		push.l	a0
000199B8 2F08                     M 	move.l	a0,-(sp)
000199BA 2448                       		movea.l	a0,a2
000199BC 3078 F86C                  		movea.w	rPlayer1Addr.w,a0
000199C0 4EB9 0000 BE98             		jsr	ObjPlayer_GetHurt
000199C6                            		pop.l	a0
000199C6 205F                     M 	move.l	(sp)+,a0
000199C8 4E75                       		rts
000199CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199CA                            .ChkRings:
000199CA 0C00 0002                  		cmpi.b	#2,d0
000199CE 6600                       		bne.s	.Display
000199D0 0678 000A F3D4             		addi.w	#10,rRings.w 				; add 10 rings to the number of rings you have
000199D6 0038 0001 F8F3             		ori.b	#1,rUpdateRings.w 			; update the ring counter
000199DC                            		playSnd	#sRing, 2				; Play ring sound
000199DC 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
000199E2                            
000199E2                            .Display:
000199E2 4E75                       		rts
000199E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199E4                            ObjMonitorContents_Delete:
000199E4 5328 0023                  		subq.b	#1,oAniTimer(a0)
000199E8 6A00                       		bpl.s	.NoDelete
000199EA 4EF8 1A72                  		jmp	DeleteObject.w
000199EE                            
000199EE                            .NoDelete:
000199EE 4E75                       		rts
000199F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199F0                            ; Data
000199F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199F0                            ArtKosM_Monitor:
000199F0                            		incbin	"Objects/Monitor/Art.kosm.bin"
00019D12 00                         		even
00019D12                            Map_ObjMonitor:
00019D12                            		include	"Objects/Monitor/Mappings.asm"
00019D12                            ; --------------------------------------------------------------------------------
00019D12                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019D12                            ; --------------------------------------------------------------------------------
00019D12                            
00019D12                            SME_7TKK1:	
00019D12 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00019D16 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00019D1A 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
00019D1E 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00019D22 0001                       SME_7TKK1_10:	dc.b 0, 1	
00019D24 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D2A 0002                       SME_7TKK1_18:	dc.b 0, 2	
00019D2C F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00019D32 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D38 0002                       SME_7TKK1_26:	dc.b 0, 2	
00019D3A F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00019D40 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D46 0002                       SME_7TKK1_34:	dc.b 0, 2	
00019D48 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
00019D4E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D54 0002                       SME_7TKK1_42:	dc.b 0, 2	
00019D56 F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
00019D5C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D62 0002                       SME_7TKK1_50:	dc.b 0, 2	
00019D64 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
00019D6A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D70 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00019D72 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00019D78 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D7E 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00019D80 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
00019D86                            		even
00019D86                            Ani_ObjMonitor:
00019D86                            		include	"Objects/Monitor/Animations.asm"
00019D86                            ; ---------------------------------------------------------------------------
00019D86                            ; Animation script - monitors
00019D86                            ; ---------------------------------------------------------------------------
00019D86 0000                       		dc.w .Static-Ani_ObjMonitor
00019D88 0000                       		dc.w .Eggman-Ani_ObjMonitor
00019D8A 0000                       		dc.w .Rings-Ani_ObjMonitor
00019D8C 0000                       		dc.w .Shoes-Ani_ObjMonitor
00019D8E 0000                       		dc.w .Shield-Ani_ObjMonitor
00019D90 0000                       		dc.w .Stars-Ani_ObjMonitor
00019D92 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00019D94 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00019D99 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00019DA2 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00019DAB 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
00019DB4 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00019DBD 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
00019DC6 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00019DCE 00                         		even
00019DCE                            ; =========================================================================================================================================================
00019DCE                            		include	"Objects/Spikes/Code.asm"		; Spike object
00019DCE                            ; ===========================================================================
00019DCE                            ; Spike object
00019DCE                            ; ===========================================================================
00019DCE                            		rsset	oLvlSSTs
00019DCE =00000030                  oSpikeX		rs.w	1
00019DCE =00000032                  oSpikeY		rs.w	1
00019DCE =00000034                  oSpkMvOff	rs.w	1
00019DCE =00000036                  oSpkMvState	rs.w	1
00019DCE =00000038                  oSpkMvTime	rs.w	1
00019DCE                            ; ===========================================================================
00019DCE                            ObjSpike:
00019DCE 7000                       		moveq	#0,d0
00019DD0 1028 0025                  		move.b	oRoutine(a0),d0
00019DD4 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00019DD8                            	nextObject
00019DD8 3068 0004                M 	movea.w	onext(a0),a0
00019DDC 2250                     M 	move.l	oaddr(a0),a1
00019DDE 4ED1                     M 	jmp	(a1)
00019DE0                            ; ===========================================================================
00019DE0                            ObjSpike_Index:
00019DE0 6000 0000                  		bra.w ObjSpike_Init
00019DE4 6000 0000                  		bra.w ObjSpike_Upright
00019DE8 6000 0000                  		bra.w ObjSpike_Sideways
00019DEC 6000 0000                  		bra.w ObjSpike_UpsideDown
00019DF0                            ; ===========================================================================
00019DF0                            ;ObjSpike_InitData:
00019DF0                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00019DF0                            ;		dc.b $10,$10	; 2	- Sideways spikes
00019DF0                            ; ===========================================================================
00019DF0                            ObjSpike_Init:
00019DF0 5828 0025                  		addq.b	#4,oRoutine(a0)
00019DF4 217C 0000 0000 0010        		move.l	#Map_ObjSpike,oMap(a0)
00019DFC 317C 06A8 000E             		move.w	#$6A8,oVRAM(a0)
00019E02 0028 0004 000D             		ori.b	#4,oRender(a0)
00019E08                            	displaySprite	4,a0,a1,0			; Priority
00019E08 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
00019E0E 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
00019E12 3149 000A                M 	move.w	a1,odrawprev(a0)
00019E16 3348 0008                M 	move.w	a0,odrawnext(a1)
00019E1A 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00019E1E                          M .no_255
00019E1E 1028 0024                  		move.b	oSubtype(a0),d0
00019E22 0228 000F 0024             		andi.b	#$F,oSubtype(a0)
00019E28 0240 00F0                  		andi.w	#$F0,d0
00019E2C 7210                       		moveq	#$10,d1
00019E2E 1141 0017                  		move.b	d1,oDrawW(a0)
00019E32 1141 002C                  		move.b	d1,oColW(a0)
00019E36 1141 001B                  		move.b	d1,oDrawH(a0)
00019E3A 1141 002D                  		move.b	d1,oColH(a0)
00019E3E E848                       		lsr.w	#4,d0
00019E40 1140 0010                  		move.b	d0,oFrame(a0)
00019E44 0C00 0001                  		cmpi.b	#1,d0
00019E48 6600                       		bne.s	.ChkUpsideDown
00019E4A 5828 0025                  		addq.b	#4,oRoutine(a0)
00019E4E 317C 06AC 000E             		move.w	#$6AC,oVRAM(a0)
00019E54                            
00019E54                            .ChkUpsideDown:
00019E54 0828 0001 0028             		btst	#1,oStatus(a0)
00019E5A 6700                       		beq.s	.SavePos
00019E5C 117C 000C 0025             		move.b	#$C,oRoutine(a0)
00019E62                            
00019E62                            .SavePos:
00019E62 3168 0014 0030             		move.w	oXPos(a0),oSpikeX(a0)
00019E68 3168 0018 0032             		move.w	oYPos(a0),oSpikeY(a0)
00019E6E                            
00019E6E 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00019E72 0C28 0001 0010             		cmpi.b	#1,oFrame(a0)		; is object type $1x ?
00019E78 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00019E7A                            ; ===========================================================================
00019E7A                            ; Upright spikes
00019E7A                            ; ===========================================================================
00019E7A                            ObjSpike_Upright:
00019E7A 6100 0000                  		bsr.w	MoveSpikes
00019E7E 7200                       		moveq	#0,d1
00019E80 1228 0017                  		move.b	oDrawW(a0),d1
00019E84 0641 000B                  		addi.w	#$B,d1
00019E88 7400                       		moveq	#0,d2
00019E8A 1428 001B                  		move.b	oDrawH(a0),d2
00019E8E 3602                       		move.w	d2,d3
00019E90 5243                       		addq.w	#1,d3
00019E92 3828 0014                  		move.w	oXPos(a0),d4
00019E96 4EB8 4456                  		jsr	SolidObject
00019E9A 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
00019EA0 6700                       		beq.s	ObjSpike_UprightEnd
00019EA2 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019EA6 6100 0000                  		bsr.w	Touch_ChkHurt2
00019EAA                            
00019EAA                            ObjSpike_UprightEnd:
00019EAA 3028 0030                  		move.w	oSpikeX(a0),d0
00019EAE 4EF8 2024                  		jmp	CheckObjActive.w
00019EB2                            ; ===========================================================================
00019EB2                            ; Sideways spikes
00019EB2                            ; ===========================================================================
00019EB2                            ObjSpike_Sideways:
00019EB2 3F28 0014                  		move.w	oXPos(a0),-(sp)	
00019EB6 6100 0000                  		bsr.w	MoveSpikes
00019EBA 7200                       		moveq	#0,d1
00019EBC 1228 0017                  		move.b	oDrawW(a0),d1
00019EC0 0641 000B                  		addi.w	#$B,d1
00019EC4 7400                       		moveq	#0,d2
00019EC6 1428 001B                  		move.b	oDrawH(a0),d2
00019ECA 3602                       		move.w	d2,d3
00019ECC 5243                       		addq.w	#1,d3
00019ECE 381F                       		move.w	(sp)+,d4
00019ED0 4EB8 4456                  		jsr	SolidObject
00019ED4 0806 0000                  		btst	#cTouchSideBit,d6
00019ED8 6700                       		beq.s	ObjSpike_SidewaysEnd
00019EDA 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019EDE 6100 0000                  		bsr.w	Touch_ChkHurt2
00019EE2                            
00019EE2                            ObjSpike_SidewaysEnd:
00019EE2 3028 0030                  		move.w	oSpikeX(a0),d0
00019EE6 4EF8 2024                  		jmp	CheckObjActive.w
00019EEA                            ; ===========================================================================
00019EEA                            ; Upside down spikes
00019EEA                            ; ===========================================================================
00019EEA                            ObjSpike_UpsideDown:
00019EEA 6100 0000                  		bsr.w	MoveSpikes
00019EEE 7200                       		moveq	#0,d1
00019EF0 1228 0017                  		move.b	oDrawW(a0),d1
00019EF4 0641 000B                  		addi.w	#$B,d1
00019EF8 7400                       		moveq	#0,d2
00019EFA 1428 001B                  		move.b	oDrawH(a0),d2
00019EFE 3602                       		move.w	d2,d3
00019F00 5243                       		addq.w	#1,d3
00019F02 3828 0014                  		move.w	oXPos(a0),d4
00019F06 4EB8 4456                  		jsr	SolidObject
00019F0A 0806 0002                  		btst	#cTouchBtmBit,d6
00019F0E 6700                       		beq.s	ObjSpike_UpsideDownEnd
00019F10 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019F14 6100 0000                  		bsr.w	Touch_ChkHurt2
00019F18                            
00019F18                            ObjSpike_UpsideDownEnd:
00019F18 3028 0030                  		move.w	oSpikeX(a0),d0
00019F1C 4EF8 2024                  		jmp	CheckObjActive.w
00019F20                            ; ===========================================================================
00019F20                            Touch_ChkHurt2:
00019F20 4A29 0042                  		tst.b	oInvulTime(a1)			; is Sonic invincible?
00019F24 6600                       		bne.s	.End				; if yes, branch
00019F26 0C29 0008 0025             		cmpi.b	#8,oRoutine(a1)
00019F2C 6700                       		beq.s	.End
00019F2E 2629 0018                  		move.l	oYPos(a1),d3
00019F32 3029 001E                  		move.w	oYVel(a1),d0
00019F36 48C0                       		ext.l	d0
00019F38 E180                       		asl.l	#8,d0
00019F3A 9680                       		sub.l	d0,d3
00019F3C 2343 0018                  		move.l	d3,oYPos(a1)
00019F40 2448                       		movea.l	a0,a2
00019F42 2049                       		movea.l	a1,a0
00019F44 4EB9 0000 BE98             		jsr	ObjPlayer_GetHurt
00019F4A 204A                       		movea.l	a2,a0
00019F4C                            
00019F4C                            .End:
00019F4C 4E75                       		rts
00019F4E                            ; ===========================================================================
00019F4E                            MoveSpikes:	
00019F4E 7000                       		moveq	#0,d0
00019F50 1028 0024                  		move.b	oSubtype(a0),d0
00019F54 D040                       		add.w	d0,d0
00019F56 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00019F5A                            ; ===========================================================================
00019F5A                            MoveSpikes_Behaviors:
00019F5A 6000                       		bra.s MoveSpikes_Still
00019F5C 6000                       		bra.s MoveSpikes_Vertical
00019F5E 6000                       		bra.s MoveSpikes_Horizontal
00019F60                            ; ===========================================================================
00019F60                            MoveSpikes_Still:
00019F60 4E75                       		rts			; don't move the object
00019F62                            ; ===========================================================================
00019F62                            MoveSpikes_Vertical:
00019F62 6100 0000                  		bsr.w	MoveSpikes_Delay
00019F66 7000                       		moveq	#0,d0
00019F68 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019F6C D068 0032                  		add.w	oSpikeY(a0),d0
00019F70 3140 0018                  		move.w	d0,oYPos(a0)	; move the object vertically
00019F74 4E75                       		rts
00019F76                            ; ===========================================================================
00019F76                            MoveSpikes_Horizontal:
00019F76 6100 0000                  		bsr.w	MoveSpikes_Delay
00019F7A 7000                       		moveq	#0,d0
00019F7C 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019F80 D068 0030                  		add.w	oSpikeX(a0),d0
00019F84 3140 0014                  		move.w	d0,oXPos(a0)	; move the object horizontally
00019F88 4E75                       		rts
00019F8A                            ; ===========================================================================
00019F8A                            MoveSpikes_Delay:
00019F8A 4A68 0038                  		tst.w	oSpkMvTime(a0)		; is time delay	= zero?
00019F8E 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00019F90 5368 0038                  		subq.w	#1,oSpkMvTime(a0)	; subtract 1 from time delay
00019F94 6600                       		bne.s	locret_CFE6
00019F96 4A28 000D                  		tst.b	oRender(a0)
00019F9A 6A00                       		bpl.s	locret_CFE6
00019F9C                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00019F9C 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00019FA2 6000                       		bra.s	locret_CFE6
00019FA4                            ; ===========================================================================
00019FA4                            MoveSpikes_ChkDir:
00019FA4 4A68 0036                  		tst.w	oSpkMvState(a0)
00019FA8 6700                       		beq.s	MoveSpikes_Retract
00019FAA 0468 0800 0034             		subi.w	#$800,oSpkMvOff(a0)
00019FB0 6400                       		bcc.s	locret_CFE6
00019FB2 317C 0000 0034             		move.w	#0,oSpkMvOff(a0)
00019FB8 317C 0000 0036             		move.w	#0,oSpkMvState(a0)
00019FBE 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019FC4 6000                       		bra.s	locret_CFE6
00019FC6                            ; ===========================================================================
00019FC6                            MoveSpikes_Retract:
00019FC6 0668 0800 0034             		addi.w	#$800,oSpkMvOff(a0)
00019FCC 0C68 2000 0034             		cmpi.w	#$2000,oSpkMvOff(a0)
00019FD2 6500                       		bcs.s	locret_CFE6
00019FD4 317C 2000 0034             		move.w	#$2000,oSpkMvOff(a0)
00019FDA 317C 0001 0036             		move.w	#1,oSpkMvState(a0)
00019FE0 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019FE6                            
00019FE6                            locret_CFE6:
00019FE6 4E75                       		rts
00019FE8                            ; ===========================================================================
00019FE8                            ; Spike object mappings
00019FE8                            ; ===========================================================================
00019FE8                            Map_ObjSpike:
00019FE8                            	include "Objects/Spikes/Mappings.asm"
00019FE8                            ; --------------------------------------------------------------------------------
00019FE8                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019FE8                            ; --------------------------------------------------------------------------------
00019FE8                            
00019FE8                            SME_5AG23:	
00019FE8 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00019FEC 0004                       SME_5AG23_4:	dc.b 0, 4	
00019FEE F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
00019FF4 F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00019FFA F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
0001A000 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
0001A006 0004                       SME_5AG23_1E:	dc.b 0, 4	
0001A008 F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
0001A00E F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A014 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
0001A01A 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
0001A020                            		even
0001A020                            ; ===========================================================================
0001A020                            ArtKosM_SpikesN:
0001A020                            		incbin	"Objects/Spikes/Art - Normal.kosm.bin"
0001A060                            		even
0001A060                            ; ===========================================================================
0001A060                            ArtKosM_SpikesS:
0001A060                            		incbin	"Objects/Spikes/Art - Sideways.kosm.bin"
0001A0A2 00                         		even
0001A0A2                            ; ===========================================================================
0001A0A2                            		include	"Objects/Spring/Code.asm"		; Spring object
0001A0A2                            ; =========================================================================================================================================================
0001A0A2                            ; Spring object
0001A0A2                            ; =========================================================================================================================================================
0001A0A2                            		rsset	oLvlSSTs
0001A0A2 =00000030                  oSprSpd		rs.w	1				; Spring strength
0001A0A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0A2                            ObjSpring:
0001A0A2 217C 0000 0000 0010        		move.l	#Map_ObjSpring,oMap(a0)		; Mappings
0001A0AA 317C 05BA 000E             		move.w	#$5BA,oVRAM(a0)			; Tile properties
0001A0B0 0028 0004 000D             		ori.b	#4,oRender(a0)			; Render flags
0001A0B6 117C 0010 0017             		move.b	#$10,oDrawW(a0)			; Sprite width
0001A0BC 117C 0008 001B             		move.b	#8,oDrawH(a0)			; Sprite height
0001A0C2 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A0C8                            	displaySprite	4,a0,a1,0			; Priority
0001A0C8 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
0001A0CE 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
0001A0D2 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A0D6 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A0DA 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0001A0DE                          M .no_257
0001A0DE                            		
0001A0DE 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A0E2 E648                       		lsr.w	#3,d0				; Turn into offset
0001A0E4 0240 000E                  		andi.w	#$E,d0				; ''
0001A0E8 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
0001A0EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0EC                            .Subtypes:
0001A0EC 6000                       		bra.s .Init_Up				; Up
0001A0EE 6000                       		bra.s .Init_Horizontal			; Horizontal
0001A0F0 6000                       		bra.s .Init_Down			; Down
0001A0F2 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
0001A0F4 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
0001A0F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0F6                            .Init_Horizontal:
0001A0F6 117C 0002 0020             		move.b	#2,oAni(a0)			; Animation
0001A0FC 117C 0002 0010             		move.b	#2,oFrame(a0)			; Mapping frame
0001A102 317C 05CA 000E             		move.w	#$5CA,oVRAM(a0)			; Tile properties
0001A108 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A10E 117C 0010 001B             		move.b	#$10,oDrawH(a0)			; Sprite height
0001A114 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A11A 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,oAddr(a0)	; Next routine
0001A120 6000                       		bra.s	.Init_Common			; Continue
0001A122                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A122                            .Init_Down:
0001A122 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A128 20BC 0000 0000             		move.l	#ObjSpring_Down,oAddr(a0)	; Next routine
0001A12E 6000                       		bra.s	.Init_Common			; Continue
0001A130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A130                            .Init_DiagonallyUp:
0001A130 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A136 117C 0004 0010             		move.b	#4,oFrame(a0)			; Map frame
0001A13C 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A142 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,oAddr(a0); Next routine
0001A148 6000                       		bra.s	.Init_Common			; Continue
0001A14A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A14A                            .Init_DiagonallyDown:
0001A14A 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A150 117C 0006 0010             		move.b	#6,oFrame(a0)			; Map frame
0001A156 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A15C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A162 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,oAddr(a0); Next routine
0001A168 6000                       		bra.s	.Init_Common			; Continue
0001A16A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A16A                            .Init_Up:
0001A16A 20BC 0000 0000             		move.l	#ObjSpring_Up,oAddr(a0)		; Next routine
0001A170                            
0001A170                            .Init_Common:
0001A170 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A174 0240 0002                  		andi.w	#2,d0				; Turn into offset
0001A178 317B 0000 0030             		move.w	.Strengths(pc,d0.w),oSprSpd(a0)	; Get spring strength
0001A17E 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
0001A182 6700                       		beq.s	.NotYellow			; If not, branch
0001A184 08E8 0005 000E             		bset	#5,oVRAM(a0)			; Make the spring yellow
0001A18A                            
0001A18A                            .NotYellow:
0001A18A                            	nextObject
0001A18A 3068 0004                M 	movea.w	onext(a0),a0
0001A18E 2250                     M 	move.l	oaddr(a0),a1
0001A190 4ED1                     M 	jmp	(a1)
0001A192                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A192                            .Strengths:
0001A192 F000                       		dc.w	-$1000				; Strength of red spring
0001A194 F600                       		dc.w	-$A00				; Strength of yellow spring
0001A196                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A196                            ObjSpring_Up:
0001A196 323C 001A                  		move.w	#27-1,d1			; Width
0001A19A 343C 0008                  		move.w	#16/2,d2			; Height
0001A19E 3602                       		move.w	d2,d3				; ''
0001A1A0 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A1A4 4EB8 44A6                  		jsr	SolidObject_Always		; Set object as solid
0001A1A8 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the top of the of spring?
0001A1AE 6700                       		beq.s	.Display			; If not, branch
0001A1B0 6100                       		bsr.s	.Bounce				; Bounce the player up
0001A1B2                            
0001A1B2                            .Display:
0001A1B2 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A1B6 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001A1BA 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0001A1BE                            	nextObject
0001A1BE 3068 0004                M 	movea.w	onext(a0),a0
0001A1C2 2250                     M 	move.l	oaddr(a0),a1
0001A1C4 4ED1                     M 	jmp	(a1)
0001A1C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1C6                            .Bounce:
0001A1C6 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A1CC 5069 0018                  		addq.w	#8,oYPos(a1)			; Align player to spring
0001A1D0 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A1D6 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A1DC 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A1E2 4229 0040                  		clr.b	oJumping(a1)			; Clear the player's jump flag
0001A1E6 137C 0010 0020             		move.b	#$10,oAni(a1)			; Set the player's animation to the spring animation
0001A1EC 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A1F2                            		
0001A1F2 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A1F6 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A1F8 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A1FC                            
0001A1FC                            .ChkPath1:
0001A1FC 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A200 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A204 6600                       		bne.s	.ChkPath2			; If not, branch
0001A206 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A20C 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A212                            
0001A212                            .ChkPath2:
0001A212 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A216 6600                       		bne.s	.PlaySound			; If not, branch
0001A218 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A21E 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A224                            
0001A224                            .PlaySound:
0001A224                            		playSnd	#sSpring, 2			; Play spring sound
0001A224 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A22A 4E75                       		rts
0001A22C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A22C                            ObjSpring_Horizontal:
0001A22C 323C 0013                  		move.w	#20-1,d1			; Width
0001A230 343C 000E                  		move.w	#28/2,d2			; Height
0001A234 3602                       		move.w	d2,d3				; ''
0001A236 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A23A 4EB8 44A6                  		jsr	SolidObject_Always		; Set object as solid
0001A23E 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
0001A242 6700                       		beq.s	.Display			; If not, branch
0001A244 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001A248 3028 0014                  		move.w	oXPos(a0),d0			; Get which side of the spring the player is facing
0001A24C 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001A250 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
0001A252 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
0001A256                            
0001A256                            .NoFlip:
0001A256 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
0001A25A 6600                       		bne.s	.Display			; If not, branch
0001A25C 6100                       		bsr.s	.Bounce				; Bounce the player
0001A25E                            
0001A25E                            .Display:
0001A25E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A262 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001A266 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0001A26A                            	nextObject
0001A26A 3068 0004                M 	movea.w	onext(a0),a0
0001A26E 2250                     M 	move.l	oaddr(a0),a1
0001A270 4ED1                     M 	jmp	(a1)
0001A272                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A272                            .Bounce:	
0001A272 317C 0300 0020             		move.w	#$300,oAni(a0)			; Reset animation
0001A278 5069 0014                  		addq.w	#8,oXPos(a1)			; Align player to spring
0001A27C 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)		; Set the player's X velocity
0001A282 08E9 0000 0028             		bset	#0,oStatus(a1)			; Make the player face the left
0001A288 0828 0000 0028             		btst	#0,oStatus(a0)			; Is this spring facing the left?
0001A28E 6600                       		bne.s	.SetMoveLock			; If so, branch
0001A290 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Make the player face the right
0001A296 0469 0010 0014             		subi.w	#$10,oXPos(a1)			; Align player to spring
0001A29C 4469 001C                  		neg.w	oXVel(a1)			; Move the player to the right
0001A2A0                            
0001A2A0                            .SetMoveLock:
0001A2A0 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Lock the player's movement for a bit
0001A2A6 3369 001C 003A             		move.w	oXVel(a1),oGVel(a1)		; Set the player's ground velocity
0001A2AC                            		
0001A2AC 0829 0002 0028             		btst	#2,oStatus(a1)			; Is the player jumping?
0001A2B2 6600                       		bne.s	.ChkYStop			; If so, branch
0001A2B4 4229 0020                  		clr.b	oAni(a1)			; Set the animation to the walking animation
0001A2B8                            		
0001A2B8                            .ChkYStop:
0001A2B8 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A2BC 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
0001A2BE 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's Y movement
0001A2C2                            
0001A2C2                            .ChkPath1:
0001A2C2 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A2C6 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A2CA 6600                       		bne.s	.ChkPath2			; If not, branch
0001A2CC 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A2D2 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A2D8                            
0001A2D8                            .ChkPath2:
0001A2D8 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A2DC 6600                       		bne.s	.PlaySound			; If not, branch
0001A2DE 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A2E4 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A2EA                            
0001A2EA                            .PlaySound:
0001A2EA 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear "push" flags
0001A2F0 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001A2F6                            		playSnd	#sSpring, 2			; Play spring sound
0001A2F6 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A2FC 4E75                       		rts
0001A2FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A2FE                            ObjSpring_Down:
0001A2FE 323C 0012                  		move.w	#19-1,d1			; Width
0001A302 343C 0008                  		move.w	#16/2,d2			; Height
0001A306 3602                       		move.w	d2,d3				; ''
0001A308 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A30C 4EB8 44A6                  		jsr	SolidObject_Always		; Set object as solid
0001A310 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
0001A314 6600                       		bne.s	.Display			; If not, branch
0001A316 6100                       		bsr.s	.Bounce				; Bounce the player
0001A318                            
0001A318                            .Display:
0001A318 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A31C 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001A320 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0001A324                            	nextObject
0001A324 3068 0004                M 	movea.w	onext(a0),a0
0001A328 2250                     M 	move.l	oaddr(a0),a1
0001A32A 4ED1                     M 	jmp	(a1)
0001A32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A32C                            .Bounce:
0001A32C 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A332 5169 0018                  		subq.w	#8,oYPos(a1)			; Align player with the spring
0001A336 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A33C 4469 001E                  		neg.w	oYVel(a1)			; Move the player down
0001A340                            		
0001A340 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A344 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A346 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A34A                            
0001A34A                            .ChkPath1:
0001A34A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A34E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A352 6600                       		bne.s	.ChkPath2			; If not, branch
0001A354 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A35A 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A360                            
0001A360                            .ChkPath2:
0001A360 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A364 6600                       		bne.s	.PlaySound			; If not, branch
0001A366 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A36C 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A372                            
0001A372                            .PlaySound:
0001A372 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A378 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A37E 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A384                            		playSnd	#sSpring, 2			; Play spring sound
0001A384 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A38A 4E75                       		rts
0001A38C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A38C                            ObjSpring_DiagonallyUp:
0001A38C 323C 0019                  		move.w	#26-1,d1			; Width
0001A390 343C 0010                  		move.w	#32/2,d2			; Height
0001A394 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A398 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
0001A39C 4EB8 44F6                  		jsr	SlopedSolid			; Set object as a solid slope
0001A3A0                            		
0001A3A0 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the spring?
0001A3A6 6700                       		beq.s	.End				; If not, branch
0001A3A8 6100                       		bsr.s	.Bounce				; Bounce the player
0001A3AA                            
0001A3AA                            .End:
0001A3AA 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A3AE 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001A3B2 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0001A3B6                            	nextObject
0001A3B6 3068 0004                M 	movea.w	onext(a0),a0
0001A3BA 2250                     M 	move.l	oaddr(a0),a1
0001A3BC 4ED1                     M 	jmp	(a1)
0001A3BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3BE                            .Bounce:
0001A3BE 0828 0000 0028             		btst	#0,oStatus(a0)			; Is the spring facing left?
0001A3C4 6600                       		bne.s	.FaceLeft			; If so, branch
0001A3C6 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0001A3CA 5940                       		subq.w	#4,d0				; Subtract 4
0001A3CC B069 0014                  		cmp.w	oXPos(a1),d0			; Is the player
0001A3D0 6500                       		blo.s	.DoBounce
0001A3D2 4E75                       		rts
0001A3D4                            
0001A3D4                            .FaceLeft:
0001A3D4 3028 0014                  		move.w	oXPos(a0),d0
0001A3D8 5840                       		addq.w	#4,d0
0001A3DA B069 0014                  		cmp.w	oXPos(a1),d0
0001A3DE 6400                       		bhs.s	.DoBounce
0001A3E0 4E75                       		rts
0001A3E2                            
0001A3E2                            .DoBounce:
0001A3E2 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A3E8 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A3EE 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A3F4 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A3F8 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A3FC 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A402 0828 0000 0028             		btst	#0,oStatus(a0)
0001A408 6600                       		bne.s	.SetAni
0001A40A 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A410 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A416 4469 001C                  		neg.w	oXVel(a1)
0001A41A                            
0001A41A                            .SetAni:
0001A41A 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A420 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A426 137C 0010 0020             		move.b	#$10,oAni(a1)
0001A42C 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A432                            
0001A432 1028 0024                  		move.b	oSubtype(a0),d0
0001A436 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A43A 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A43E 6600                       		bne.s	.ChkPath2			; If not, branch
0001A440 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A446 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A44C                            
0001A44C                            .ChkPath2:
0001A44C 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A450 6600                       		bne.s	.PlaySound			; If not, branch
0001A452 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A458 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A45E                            
0001A45E                            .PlaySound:
0001A45E                            		playSnd	#sSpring, 2			; Play spring sound
0001A45E 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A464 4E75                       		rts
0001A466                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A466                            .SlopeData:
0001A466 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
0001A46D 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
0001A474 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
0001A47B FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
0001A482                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A482                            ObjSpring_DiagonallyDown:
0001A482 323C 0019                  		move.w	#26-1,d1			; Width
0001A486 343C 0010                  		move.w	#32/2,d2
0001A48A 3828 0014                  		move.w	oXPos(a0),d4
0001A48E 45FA 0000                  		lea	.SlopeData(pc),a2
0001A492 4EB8 44F6                  		jsr	SlopedSolid			; Set object as a solid slope
0001A496 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
0001A49A 6600                       		bne.s	.End				; If not, branch
0001A49C 6100                       		bsr.s	.Bounce				; Bounce the player
0001A49E                            
0001A49E                            .End:
0001A49E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A4A2 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001A4A6 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0001A4AA                            	nextObject
0001A4AA 3068 0004                M 	movea.w	onext(a0),a0
0001A4AE 2250                     M 	move.l	oaddr(a0),a1
0001A4B0 4ED1                     M 	jmp	(a1)
0001A4B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4B2                            .Bounce:
0001A4B2 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A4B8 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A4BE 4469 001E                  		neg.w	oYVel(a1)
0001A4C2 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A4C8 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A4CC 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A4D0 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A4D6 0828 0000 0028             		btst	#0,oStatus(a0)
0001A4DC 6600                       		bne.s	.SetAni
0001A4DE 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A4E4 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A4EA 4469 001C                  		neg.w	oXVel(a1)
0001A4EE                            
0001A4EE                            .SetAni:
0001A4EE 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A4F4 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A4FA 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A500                            
0001A500 1028 0024                  		move.b	oSubtype(a0),d0
0001A504 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A508 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A50C 6600                       		bne.s	.ChkPath2			; If not, branch
0001A50E 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A514 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A51A                            
0001A51A                            .ChkPath2:
0001A51A 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A51E 6600                       		bne.s	.PlaySound			; If not, branch
0001A520 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A526 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A52C                            
0001A52C                            .PlaySound:
0001A52C                            		playSnd	#sSpring, 2			; Play spring sound
0001A52C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A532 4E75                       		rts
0001A534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A534                            .SlopeData:
0001A534 F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
0001A53B F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
0001A542 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
0001A549 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
0001A550                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A550                            ; Data
0001A550                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A550                            Ani_ObjSpring:
0001A550                            		include	"Objects/Spring/Animations.asm"
0001A550                            ; ---------------------------------------------------------------------------
0001A550                            ; Animation script - springs
0001A550                            ; ---------------------------------------------------------------------------
0001A550 0000                       		dc.w byte_18FEE-Ani_ObjSpring
0001A552 0000                       		dc.w byte_18FF1-Ani_ObjSpring
0001A554 0000                       		dc.w byte_18FFD-Ani_ObjSpring
0001A556 0000                       		dc.w byte_19000-Ani_ObjSpring
0001A558 0000                       		dc.w byte_1900C-Ani_ObjSpring
0001A55A 0000                       		dc.w byte_1900F-Ani_ObjSpring
0001A55C                            byte_18FEE:
0001A55C 0F00 FF                    		dc.b  $F, 0, $FF
0001A560 00                         		even
0001A560                            byte_18FF1:
0001A560 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
0001A56A 00                         		even
0001A56A                            byte_18FFD:
0001A56A 0F02 FF                    		dc.b $F, 2, $FF
0001A56E 00                         		even
0001A56E                            byte_19000:
0001A56E 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
0001A578 00                         		even
0001A578                            byte_1900C:
0001A578 0F04 FF                    		dc.b $F, 4, $FF
0001A57C 00                         		even
0001A57C                            byte_1900F:
0001A57C 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
0001A586 00                         		even
0001A586                            Map_ObjSpring:
0001A586                            		include	"Objects/Spring/Mappings.asm"
0001A586                            ; --------------------------------------------------------------------------------
0001A586                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001A586                            ; --------------------------------------------------------------------------------
0001A586                            
0001A586                            SME_q_6K9:	
0001A586 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
0001A58A 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
0001A58E 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
0001A592 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
0001A594 0002                       SME_q_6K9_E:	dc.b 0, 2	
0001A596 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A59C 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
0001A5A2 0005                       SME_q_6K9_1C:	dc.b 0, 5	
0001A5A4 E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
0001A5AA E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
0001A5B0 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
0001A5B6 F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
0001A5BC 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
0001A5C2 0001                       SME_q_6K9_3C:	dc.b 0, 1	
0001A5C4 E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
0001A5CA 0007                       SME_q_6K9_44:	dc.b 0, 7	
0001A5CC E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
0001A5D2 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
0001A5D8 F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
0001A5DE F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
0001A5E4 F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
0001A5EA E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
0001A5F0 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
0001A5F6 0002                       SME_q_6K9_70:	dc.b 0, 2	
0001A5F8 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0001A5FE FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
0001A604 0005                       SME_q_6K9_7E:	dc.b 0, 5	
0001A606 E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
0001A60C EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
0001A612 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
0001A618 FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
0001A61E 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
0001A624 0002                       SME_q_6K9_9E:	dc.b 0, 2	
0001A626 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
0001A62C 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
0001A632                            		even
0001A632                            ArtKosM_SpringH:
0001A632                            		incbin	"Objects/Spring/Art - Horizontal.kosm.bin"
0001A70E 00                         		even
0001A70E                            ArtKosM_SpringV:
0001A70E                            		incbin	"Objects/Spring/Art - Vertical.kosm.bin"
0001A7F4 00                         		even
0001A7F4                            ArtKosM_SpringD:
0001A7F4                            		incbin	"Objects/Spring/Art - Diagonal.kosm.bin"
0001AA0E 00                         		even
0001AA0E                            ; =========================================================================================================================================================
0001AA0E                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
0001AA0E                            ; =========================================================================================================================================================
0001AA0E                            ; Checkpoint object
0001AA0E                            ; =========================================================================================================================================================
0001AA0E                            		rsset	oLvlSSTs
0001AA0E =00000030                  oDongleX	rs.w	1				; Ball dongle X
0001AA0E =00000032                  oDongleY	rs.w	1				; Ball dongle Y
0001AA0E =00000034                  oDongleTime	rs.w	1				; Ball dongle timer
0001AA0E =00000036                  oDonglePar	rs.w	1				; Ball dongle parent
0001AA0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA0E                            ObjCheckpoint:
0001AA0E 7000                       		moveq	#0,d0
0001AA10 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0001AA14 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0001AA18                            	nextObject
0001AA18 3068 0004                M 	movea.w	onext(a0),a0
0001AA1C 2250                     M 	move.l	oaddr(a0),a1
0001AA1E 4ED1                     M 	jmp	(a1)
0001AA20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA20                            .Index:
0001AA20 6000 0000                  		bra.w	ObjChkpoint_Init
0001AA24 6000 0000                  		bra.w	ObjChkpoint_Main
0001AA28 6000 0000                  		bra.w	ObjChkpoint_Animate
0001AA2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA2C                            ObjChkpoint_Init:
0001AA2C 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0001AA30                            		
0001AA30 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,oMap(a0)	; Mappings
0001AA38 317C 057E 000E             		move.w	#$57E,oVRAM(a0)			; Tile properties
0001AA3E 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AA44 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001AA4A 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
0001AA50                            	displaySprite	5,a0,a1,0			; Priority
0001AA50 317C BE82 0008           M 	move.w	#rdispinput+(5*dsize),odrawnext(a0)
0001AA56 3278 BE8C                M 	move.w	rdispinput+dprev+(5*dsize).w,a1
0001AA5A 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AA5E 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AA62 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
0001AA66                          M .no_270
0001AA66                            		
0001AA66 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AA6A 3440                       		movea.w	d0,a2				; ''
0001AA6C 0812 0000                  		btst	#0,(a2)				; Is it already set?
0001AA70 6600                       		bne.s	.AlreadySet			; If so, branch
0001AA72                            
0001AA72 1228 0024                  		move.b	oSubtype(a0),d1			; Get checkpoint ID
0001AA76 B238 C7AE                  		cmp.b	rLastChkpoint.w,d1		; Has a later checkpoint already been hit?
0001AA7A 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
0001AA7C                            
0001AA7C                            .AlreadySet:
0001AA7C 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AA80 117C 0002 0020             		move.b	#2,oAni(a0)			; ''
0001AA86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA86                            ObjChkpoint_Main:
0001AA86 4A38 F8D1                  		tst.b	rDebugMode.w			; Are we in debug placement mode?
0001AA8A 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
0001AA8E                            		
0001AA8E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Player object
0001AA92 1238 C7AE                  		move.b	rLastChkpoint.w,d1		; Get last checkpoint hit
0001AA96 B228 0024                  		cmp.b	oSubtype(a0),d1			; Has a later checkpoint already been hit?
0001AA9A 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
0001AA9E                            
0001AA9E 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0001AAA2 9068 0014                  		sub.w	oXPos(a0),d0			; Get delta X from current position
0001AAA6 5040                       		addq.w	#8,d0				; Add 8
0001AAA8 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
0001AAAC 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AAB0 3029 0018                  		move.w	oYPos(a1),d0			; Get player's Y position
0001AAB4 9068 0018                  		sub.w	oYPos(a0),d0			; Get delta Y from current position
0001AAB8 0640 0040                  		addi.w	#$40,d0				; Add $40
0001AABC 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
0001AAC0 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AAC4                            		
0001AAC4                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0001AAC4 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
0001AACA                            
0001AACA 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
0001AACE 6700                       		beq.s	.SetPoint			; If there is none, branch
0001AAD0 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,oAddr(a1)	; Load the checkpoint ball dongle object
0001AAD6 3368 0014 0030             		move.w	oXPos(a0),oDongleX(a1)		; Dongle X
0001AADC 3368 0018 0032             		move.w	oYPos(a0),oDongleY(a1)		; Dongle Y
0001AAE2 0469 0014 0032             		subi.w	#$14,oDongleY(a1)		; ''
0001AAE8 2368 0010 0010             		move.l	oMap(a0),oMap(a1)		; Mappings
0001AAEE 3368 000E 000E             		move.w	oVRAM(a0),oVRAM(a1)		; Tile properties
0001AAF4 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
0001AAFA 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
0001AB00 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
0001AB06                            	displaySprite	4,a1,a2,0			; Priority
0001AB06 337C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a1)
0001AB0C 3478 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a2
0001AB10 334A 000A                M 	move.w	a2,odrawprev(a1)
0001AB14 3549 0008                M 	move.w	a1,odrawnext(a2)
0001AB18 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
0001AB1C                          M .no_272
0001AB1C 137C 0002 0010             		move.b	#2,oFrame(a1)			; Map frame
0001AB22 337C 0020 0034             		move.w	#$20,oDongleTime(a1)		; Dongle timer
0001AB28 3348 0036                  		move.w	a0,oDonglePar(a1)		; Dongle parent
0001AB2C                            
0001AB2C                            .SetPoint:
0001AB2C 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AB30 3440                       		movea.w	d0,a2				; ''
0001AB32 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AB36                            		
0001AB36 117C 0001 0020             		move.b	#1,oAni(a0)			; Use dongling animation
0001AB3C 11E8 0024 C7AE             		move.b	oSubtype(a0),rLastChkpoint.w	; Set checkpoint ID
0001AB42                            
0001AB42 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AB46 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
0001AB4C 4EF8 4A88                  		jmp	Level_SaveInfo			; Save data
0001AB50                            		
0001AB50                            .ChkSetAnim:
0001AB50 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AB54 4A28 0020                  		tst.b	oAni(a0)			; Are we still unset?
0001AB58 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
0001AB5A 117C 0002 0020             		move.b	#2,oAni(a0)			; Use the set animation
0001AB60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AB60                            ObjChkpoint_Animate:
0001AB60 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0001AB66 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0001AB6A 4EF8 2024                  		jmp	CheckObjActive.w		; Display
0001AB6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AB6E                            ; Ball dongle object
0001AB6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AB6E                            ObjChkPoint_Dongle:
0001AB6E 5368 0034                  		subq.w	#1,oDongleTime(a0)		; Decrement timer
0001AB72 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0001AB74 3268 0036                  		movea.w	oDonglePar(a0),a1		; Get parent
0001AB78 137C 0002 0020             		move.b	#2,oAni(a1)			; Set set animation for parent
0001AB7E 4229 0010                  		clr.b	oFrame(a1)			; Reset map frame for parent
0001AB82 4EB8 1A72                  		jsr	DeleteObject.w			; Delete ourselves
0001AB86                            	nextObject
0001AB86 3068 0004                M 	movea.w	onext(a0),a0
0001AB8A 2250                     M 	move.l	oaddr(a0),a1
0001AB8C 4ED1                     M 	jmp	(a1)
0001AB8E                            
0001AB8E                            .MoveDongle:
0001AB8E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0001AB92 0428 0010 0041             		subi.b	#$10,oAngle(a0)			; Decrement angle
0001AB98 0400 0040                  		subi.b	#$40,d0				; Subtract $40
0001AB9C 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
0001ABA0 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
0001ABA4 4841                       		swap	d1				; Get high word
0001ABA6 D268 0030                  		add.w	oDongleX(a0),d1			; Add dongle X
0001ABAA 3141 0014                  		move.w	d1,oXPos(a0)			; Set actual X
0001ABAE C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
0001ABB2 4840                       		swap	d0				; Get high word
0001ABB4 D068 0032                  		add.w	oDongleY(a0),d0			; Add dongle X
0001ABB8 3140 0018                  		move.w	d0,oYPos(a0)			; Set actual X
0001ABBC 4EB8 2024                  		jsr	CheckObjActive.w		; Display
0001ABC0                            	nextObject
0001ABC0 3068 0004                M 	movea.w	onext(a0),a0
0001ABC4 2250                     M 	move.l	oaddr(a0),a1
0001ABC6 4ED1                     M 	jmp	(a1)
0001ABC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ABC8                            ; Data
0001ABC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ABC8                            ArtKosM_Chkpoint:
0001ABC8                            		incbin	"Objects/Checkpoint/Art.kosm.bin"
0001ACC8 00                         		even
0001ACC8                            Ani_ObjChkpoint:
0001ACC8 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
0001ACCA 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
0001ACCC 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
0001ACCE 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
0001ACD2 00                         		even
0001ACD2 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
0001ACD6 00                         		even
0001ACD6 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
0001ACDA                            		even
0001ACDA                            Map_ObjChkpoint:
0001ACDA                            		include	"Objects/Checkpoint/Mappings.asm"
0001ACDA                            ; --------------------------------------------------------------------------------
0001ACDA                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001ACDA                            ; --------------------------------------------------------------------------------
0001ACDA                            
0001ACDA                            SME_JjCUP:	
0001ACDA 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
0001ACDE 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
0001ACE2 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
0001ACE4 0004                       SME_JjCUP_A:	dc.b 0, 4	
0001ACE6 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001ACEC F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001ACF2 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001ACF8 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
0001ACFE 0003                       SME_JjCUP_24:	dc.b 0, 3	
0001AD00 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AD06 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AD0C F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AD12 0001                       SME_JjCUP_38:	dc.b 0, 1	
0001AD14 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
0001AD1A 0001                       SME_JjCUP_40:	dc.b 0, 1	
0001AD1C F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0001AD22 0004                       SME_JjCUP_48:	dc.b 0, 4	
0001AD24 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AD2A F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AD30 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AD36 D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
0001AD3C                            		even
0001AD3C                            ; =========================================================================================================================================================
0001AD3C                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
0001AD3C                            ; =========================================================================================================================================================
0001AD3C                            ; Wall spring object
0001AD3C                            ; =========================================================================================================================================================
0001AD3C                            ObjWallSpring:
0001AD3C 20BC 0000 0000             		move.l	#ObjWallSpring_Main,oAddr(a0)	; Next routine
0001AD42                            	;	move.l	#Map_ObjWallSpring,oMap(a0)	; Mappings
0001AD42                            	;	clr.w	oVRAM(a0)			; Tile properties
0001AD42                            	;	ori.b	#4,oRender(a0)			; Render flags
0001AD42                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0001AD42                            	;	move.b	#8,oDrawW(a0)			; Sprite width
0001AD42                            	;	move.b	#$40,oDrawH(a0)			; Sprite height
0001AD42 117C 0008 002C             		move.b	#8,oColW(a0)			; Collision width
0001AD48 117C 0040 002D             		move.b	#$40,oColH(a0)			; Collision height
0001AD4E                            
0001AD4E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001AD52 E808                       		lsr.b	#4,d0				; Get map frame
0001AD54 0200 0007                  		andi.b	#7,d0				; ''
0001AD58 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0001AD5C 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
0001AD5E                            	;	move.b	#$80,oDrawH(a0)			; Larger sprite height
0001AD5E 117C 0080 002D             		move.b	#$80,oColH(a0)			; Larger collision height
0001AD64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AD64                            ObjWallSpring_Main:
0001AD64 7208                       		moveq	#8,d1				; Width
0001AD66 7400                       		moveq	#0,d2
0001AD68 1428 002D                  		move.b	oColH(a0),d2			; Height
0001AD6C 3602                       		move.w	d2,d3				; ''
0001AD6E 5243                       		addq.w	#1,d3				; ''
0001AD70 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001AD74 4EB8 44A6                  		jsr	SolidObject_Always		; Make us solid
0001AD78                            
0001AD78 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
0001AD7C 6700                       		beq.s	.Display			; If not, branch
0001AD7E 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set in air
0001AD84 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001AD88 3028 0014                  		move.w	oXPos(a0),d0			; Get distance between us and Sonic
0001AD8C 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001AD90 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
0001AD92 0A01 0001                  		eori.b	#1,d1				; Go the other way
0001AD96                            
0001AD96                            .ChkXStat:
0001AD96 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
0001AD9A 6600                       		bne.s	.Display			; If not, branch
0001AD9C 6100                       		bsr.s	.Bounce
0001AD9E                            
0001AD9E                            .Display:
0001AD9E 4EB8 2024                  		jsr	CheckObjActive.w		; Delete if inactive
0001ADA2                            	nextObject
0001ADA2 3068 0004                M 	movea.w	onext(a0),a0
0001ADA6 2250                     M 	move.l	oaddr(a0),a1
0001ADA8 4ED1                     M 	jmp	(a1)
0001ADAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADAA                            .Bounce:
0001ADAA 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is Sonic dead?
0001ADB0 6500                       		blo.s	.DoBounce			; If not, branch
0001ADB2 4E75                       		rts
0001ADB4                            
0001ADB4                            .DoBounce:
0001ADB4 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Make Sonic not hurt if he is
0001ADBA 337C F800 001C             		move.w	#-$800,oXVel(a1)		; Bounce left
0001ADC0 337C F800 001E             		move.w	#-$800,oYVel(a1)		; Bounce up
0001ADC6 08E9 0000 0028             		bset	#0,oStatus(a1)			; Face left
0001ADCC 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing left?
0001ADD2 6600                       		bne.s	.MoveLock			; If so, branch
0001ADD4 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Face right
0001ADDA 4469 001C                  		neg.w	oXVel(a1)			; Go right
0001ADDE                            
0001ADDE                            .MoveLock:
0001ADDE 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Set move lock timer
0001ADE4 0829 0002 0028             		btst	#2,oStatus(a1)			; Was Sonic jumping?
0001ADEA 6600                       		bne.s	.ChkNoYVel			; If so, branch
0001ADEC 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001ADF0                            
0001ADF0                            .ChkNoYVel:
0001ADF0 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001ADF4 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0001ADF6 4229 001E                  		clr.b	oYVel(a1)			; Stop Y velocity
0001ADFA                            
0001ADFA                            .ChkFlip:
0001ADFA 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
0001ADFE 6700                       		beq.s	.PlaySnd			; If not, branch
0001AE00 337C 0001 003A             		move.w	#1,oFlipDir(a1)			; Set flip direction
0001AE06 137C 0001 0047             		move.b	#1,oFlipAngle(a1)		; Set flip angle
0001AE0C 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AE10 137C 0001 0049             		move.b	#1,oFlipRemain(a1)		; Set flips remaining
0001AE16 137C 0008 004A             		move.b	#8,oFlipSpeed(a1)		; Set flip speed
0001AE1C 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
0001AE20 6600                       		bne.s	.ChkDir				; If not, branch
0001AE22 137C 0003 0049             		move.b	#3,oFlipRemain(a1)		; Do 3 flips isntead
0001AE28                            
0001AE28                            .ChkDir:
0001AE28 0829 0000 0028             		btst	#0,oStatus(a1)			; Was Sonic facing left?
0001AE2E 6700                       		beq.s	.PlaySnd			; If not, branch
0001AE30 4429 0047                  		neg.b	oFlipAngle(a1)			; Flip the other way
0001AE34 4469 003A                  		neg.w	oFlipDir(a1)			; ''
0001AE38                            
0001AE38                            .PlaySnd:
0001AE38 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Stop pushing
0001AE3E 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001AE44                            		playSnd	#sSpring, 2			; Play spring sound
0001AE44 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001AE4A 4E75                       		rts
0001AE4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE4C                            ; Data
0001AE4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE4C                            Map_ObjWallSpring:
0001AE4C                            		include	"Objects/Wall Spring/Mappings.asm"
0001AE4C                            ; --------------------------------------------------------------------------------
0001AE4C                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AE4C                            ; --------------------------------------------------------------------------------
0001AE4C                            
0001AE4C                            SME_ReVf5:	
0001AE4C 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
0001AE50 0002                       SME_ReVf5_4:	dc.b 0, 2	
0001AE52 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
0001AE58 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
0001AE5E 0002                       SME_ReVf5_12:	dc.b 0, 2	
0001AE60 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0001AE66 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
0001AE6C                            		even
0001AE6C                            		even
0001AE6C                            ; =========================================================================================================================================================
0001AE6C                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
0001AE6C                            ; =========================================================================================================================================================
0001AE6C                            ; Ball mode enable/disable object
0001AE6C                            ; =========================================================================================================================================================
0001AE6C                            		rsset	oLvlSSTs
0001AE6C =00000030                  oBModeTouch	rs.b	1				; Touched flag
0001AE6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE6C                            ObjBallMode:
0001AE6C                            	;	move.l	#ObjBallMode_Main,oAddr(a0)	; Next routine
0001AE6C                            	;	move.l	#Map_ObjMonitor,oMap(a0)	; Mappings
0001AE6C                            	;	clr.w	oVRAM(a0)			; Tile properties
0001AE6C                            	;	ori.b	#4,oRender(a0)			; Render flags
0001AE6C                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
0001AE6C                            	;	move.b	#$10,oDrawW(a0)			; Sprite width
0001AE6C                            	;	move.b	#$10,oDrawH(a0)			; Sprite height
0001AE6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE6C                            ObjBallMode_Main:
0001AE6C 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AE70 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AE74 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AE78 4A40                       		tst.w	d0				; ''
0001AE7A 6700                       		beq.s	.NotTouched			; If not, branch
0001AE7C                            
0001AE7C 08AA 0002 000C             		bclr	#2,oFlags(a2)
0001AE82                            		
0001AE82 4A28 0024                  		tst.b	oSubtype(a0)			; Should we force Sonic out of ball mode?
0001AE86 6B00                       		bmi.s	.NoBallMode			; If so, branch
0001AE88 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
0001AE8A                            
0001AE8A 4A28 0030                  		tst.b	oBModeTouch(a0)			; Have we already been touched?
0001AE8E 6600                       		bne.s	.End				; If so, branch
0001AE90 50E8 0030                  		st	oBModeTouch(a0)			; Touched
0001AE94                            
0001AE94 462A 004B                  		not.b	oBallMode(a2)			; Switch ball mode for Sonic
0001AE98 6700                       		beq.s	.End				; If it's not set, branch
0001AE9A                            
0001AE9A                            .MakeSonicRoll:
0001AE9A 2248                       		movea.l	a0,a1				; Save a0
0001AE9C 204A                       		movea.l	a2,a0				; Make Sonic roll
0001AE9E 4EB9 0000 BB50             		jsr	ObjPlayer_DoRoll			; ''
0001AEA4 2049                       		movea.l	a1,a0				; Restore a0
0001AEA6                            	nextObject
0001AEA6 3068 0004                M 	movea.w	onext(a0),a0
0001AEAA 2250                     M 	move.l	oaddr(a0),a1
0001AEAC 4ED1                     M 	jmp	(a1)
0001AEAE                            
0001AEAE                            .NotTouched:
0001AEAE 4228 0030                  		clr.b	oBModeTouch(a0)			; Not touched
0001AEB2                            	nextObject
0001AEB2 3068 0004                M 	movea.w	onext(a0),a0
0001AEB6 2250                     M 	move.l	oaddr(a0),a1
0001AEB8 4ED1                     M 	jmp	(a1)
0001AEBA                            
0001AEBA                            .BallMode:
0001AEBA 50EA 004B                  		st	oBallMode(a2)			; Get in to ball mode
0001AEBE 60DA                       		bra.s	.MakeSonicRoll			; ''
0001AEC0                            
0001AEC0                            .NoBallMode:
0001AEC0 422A 004B                  		clr.b	oBallMode(a2)			; Get out of ball mode
0001AEC4                            
0001AEC4                            .End:
0001AEC4                            	nextObject
0001AEC4 3068 0004                M 	movea.w	onext(a0),a0
0001AEC8 2250                     M 	move.l	oaddr(a0),a1
0001AECA 4ED1                     M 	jmp	(a1)
0001AECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AECC                            .RangeData:
0001AECC FFF0 0020                  		dc.w	-$10, $20
0001AED0 FFF0 0020                  		dc.w	-$10, $20
0001AED4                            ; =========================================================================================================================================================
0001AED4                            		include	"Objects/Bumper/Code.asm"		; Bumper object
0001AED4                            ; =========================================================================================================================================================
0001AED4                            ; Water surface object
0001AED4                            ; =========================================================================================================================================================
0001AED4                            		rsset	oLvlSSTs
0001AED4                            
0001AED4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AED4                            ObjBumper:
0001AED4 20BC 0000 0000             		move.l	#ObjBumperMain,oAddr(a0)	; Next routine
0001AEDA 217C 0000 0000 0010        		move.l	#Map_ObjBumper,oMap(a0)		; Mappings
0001AEE2 317C 035B 000E             		move.w	#$35B,oVRAM(a0)			; Tile properties
0001AEE8 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AEEE                            	displaySprite	1,a0,a1,0			; Priority
0001AEEE 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
0001AEF4 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
0001AEF8 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AEFC 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AF00 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
0001AF04                          M .no_280
0001AF04 7210                       		moveq	#$10,d1
0001AF06 1141 0017                  		move.b	d1,oDrawW(a0)
0001AF0A 1141 002C                  		move.b	d1,oColW(a0)
0001AF0E 1141 001B                  		move.b	d1,oDrawH(a0)
0001AF12 1141 002D                  		move.b	d1,oColH(a0)
0001AF16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF16                            ObjBumperMain:
0001AF16 4A38 F8D1                  		tst.b	rDebugMode.w
0001AF1A 6600 0000                  		bne.w	.Display
0001AF1E                            
0001AF1E 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AF22 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AF26 0C2A 000C 0025             		cmpi.b	#$C,oRoutine(a2)
0001AF2C 6400 0000                  		bcc.w	.Display
0001AF30 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AF34 4A40                       		tst.w	d0				; ''
0001AF36 6700                       		beq.s	.Display			; If not, branch
0001AF38                            
0001AF38 3228 0014                  		move.w	oXPos(a0),d1
0001AF3C 3428 0018                  		move.w	oYPos(a0),d2
0001AF40 926A 0014                  		sub.w	oXPos(a2),d1
0001AF44 946A 0018                  		sub.w	oYPos(a2),d2
0001AF48 4EB8 1786                  		jsr	CalcArcTan.w
0001AF4C 1238 C759                  		move.b	(rFrameCnt+3).w,d1
0001AF50 0241 0003                  		andi.w	#3,d1
0001AF54 D041                       		add.w	d1,d0
0001AF56 4EB8 1374                  		jsr	CalcSine.w
0001AF5A C3FC F900                  		muls.w	#-$700,d1
0001AF5E E081                       		asr.l	#8,d1
0001AF60 3541 001C                  		move.w	d1,oXVel(a2)
0001AF64 C1FC F900                  		muls.w	#-$700,d0
0001AF68 E080                       		asr.l	#8,d0
0001AF6A 3540 001E                  		move.w	d0,oYVel(a2)
0001AF6E 0C2A 0008 0025             		cmpi.b	#8,oRoutine(a2)
0001AF74 6600                       		bne.s	.NotHurt
0001AF76 157C 0002 0020             		move.b	#2,oAni(a2)
0001AF7C 5A6A 0018                  		addq.w	#5,oYPos(a2)
0001AF80 157C 000E 002D             		move.b	#$E,oColH(a2)
0001AF86 157C 0007 002C             		move.b	#7,oColW(a2)
0001AF8C 08EA 0002 0028             		bset	#2,oStatus(a2)
0001AF92                            
0001AF92                            .NotHurt:
0001AF92 157C 0004 0025             		move.b	#4,oRoutine(a2)
0001AF98 08EA 0001 0028             		bset	#1,oStatus(a2)
0001AF9E 08AA 0005 0028             		bclr	#5,oStatus(a2)
0001AFA4 422A 0040                  		clr.b	oJumping(a2)
0001AFA8 117C 0001 0020             		move.b	#1,oAni(a0)
0001AFAE                            		playSnd	#sBumper, 2
0001AFAE 11FC 0091 C4BD           M 	move.b	#sbumper,(mqueue+((2)-1)).w
0001AFB4                            
0001AFB4                            .Display:
0001AFB4 43FA 0000                  		lea	Ani_ObjBumper(pc),a1
0001AFB8 4EB8 1C66                  		jsr	AnimateObject.w
0001AFBC 4EB8 2024                  		jsr	CheckObjActive.w		; Display
0001AFC0 4EB8 4A76                  		jsr	AddToColResponse		; Allow collision
0001AFC4                            	nextObject
0001AFC4 3068 0004                M 	movea.w	onext(a0),a0
0001AFC8 2250                     M 	move.l	oaddr(a0),a1
0001AFCA 4ED1                     M 	jmp	(a1)
0001AFCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AFCC                            .RangeData:
0001AFCC FFE8 0030                  		dc.w	-$18, $30
0001AFD0 FFE8 0030                  		dc.w	-$18, $30
0001AFD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AFD4                            ; Data
0001AFD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AFD4                            Map_ObjBumper:
0001AFD4                            		include	"Objects/Bumper/Mappings.asm"
0001AFD4                            ; --------------------------------------------------------------------------------
0001AFD4                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AFD4                            ; --------------------------------------------------------------------------------
0001AFD4                            
0001AFD4                            SME_3VuTU:	
0001AFD4 0000 0000                  		dc.w SME_3VuTU_6-SME_3VuTU, SME_3VuTU_E-SME_3VuTU	
0001AFD8 0000                       		dc.w SME_3VuTU_16-SME_3VuTU	
0001AFDA 0001                       SME_3VuTU_6:	dc.b 0, 1	
0001AFDC F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001AFE2 0001                       SME_3VuTU_E:	dc.b 0, 1	
0001AFE4 F40A 0029 FFF4             		dc.b $F4, $A, 0, $29, $FF, $F4	
0001AFEA 0004                       SME_3VuTU_16:	dc.b 0, 4	
0001AFEC EC0F 0010 FFEC             		dc.b $EC, $F, 0, $10, $FF, $EC	
0001AFF2 EC03 0020 000C             		dc.b $EC, 3, 0, $20, 0, $C	
0001AFF8 0C0C 0024 FFEC             		dc.b $C, $C, 0, $24, $FF, $EC	
0001AFFE 0C00 0028 000C             		dc.b $C, 0, 0, $28, 0, $C	
0001B004                            		even
0001B004                            		even
0001B004                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B004                            Ani_ObjBumper:
0001B004 0000                       		dc.w	.Ani0-Ani_ObjBumper
0001B006 0000                       		dc.w	.Ani1-Ani_ObjBumper
0001B008 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
0001B00C 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0001B014 00                         		even
0001B014                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B014                            ArtKosM_Bumper:
0001B014                            		incbin	"Objects/Bumper/Art.kosm.bin"
0001B2E2 00                         		even
0001B2E2                            ; =========================================================================================================================================================
0001B2E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E2                            ; Unused/Temporary
0001B2E2                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
0001B2E2                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
0001B2E2                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
0001B2E2                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0001B2E2                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
0001B2E2                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0001B2E2                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
0001B2E2                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
0001B2E2                            ; =========================================================================================================================================================
0001B2E2                            		include	"Opmodes/Ending/Main.asm"
0001B2E2                            ; =========================================================================================================================================================
0001B2E2                            ; End splash screen
0001B2E2                            ; =========================================================================================================================================================
0001B2E2                            
0001B2E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E2                            Ending:
0001B2E2 60FE                       		bra.s	Ending
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ;		playSnd	#Mus_Stop, 1			; Stop sound
0001B2E4                            ;
0001B2E4                            ;		intsOff					; Disable interrupts
0001B2E4                            ;
0001B2E4                            ;		lea	VDP_CTRL,a5
0001B2E4                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0001B2E4                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
0001B2E4                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
0001B2E4                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0001B2E4                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
0001B2E4                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
0001B2E4                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
0001B2E4                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0001B2E4                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
0001B2E4                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0001B2E4                            ;
0001B2E4                            ;		jsr	ClearScreen.w			; Clear screen
0001B2E4                            ;
0001B2E4                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
0001B2E4                            ;		lea	rBuffer,a1			; Decompress into RAM
0001B2E4                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0001B2E4                            ;		jsr	EniDec.w			; Decompress!
0001B2E4                            ;
0001B2E4                            ;		lea	rBuffer,a1			; Load mappings
0001B2E4                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
0001B2E4                            ;		moveq	#$27,d1				; $28x$1C tiles
0001B2E4                            ;		moveq	#$1B,d2				; ''
0001B2E4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0001B2E4                            ;		jsr	LoadPlaneMap.w			; Load the map
0001B2E4                            ;
0001B2E4                            ;		lea	ArtKosM_End,a1			; Load background art
0001B2E4                            ;		move.w	#$20,d2				; ''
0001B2E4                            ;		jsr	QueueKosMData.w			; ''
0001B2E4                            ;
0001B2E4                            ;.WaitPLCs:
0001B2E4                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B2E4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0001B2E4                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B2E4                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0001B2E4                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
0001B2E4                            ;		bne.s	.WaitPLCs			; If so, branch
0001B2E4                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B2E4                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B2E4                            ;
0001B2E4                            ;		lea	SampleList+$F0,a3
0001B2E4                            ;		jsr	PlayDAC1
0001B2E4                            ;
0001B2E4                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
0001B2E4                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
0001B2E4                            ;		jsr	LoadPalette.w			; ''
0001B2E4                            ;
0001B2E4                            ;		displayOn
0001B2E4                            ;
0001B2E4                            ;.Loop:
0001B2E4                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
0001B2E4                            ;		jsr	VSync_Routine.w			; ''
0001B2E4                            ;		bra.s	.Loop
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ; Art
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ;ArtKosM_End:
0001B2E4                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
0001B2E4                            ;		even
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ; Plane mappings
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ;MapEni_End:
0001B2E4                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
0001B2E4                            ;		even
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ; Palette
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ;Pal_End:
0001B2E4                            ;		incbin	"Ending/Data/Palette.pal.bin"
0001B2E4                            ;Pal_End_End:
0001B2E4                            ;		even
0001B2E4                            ; =========================================================================================================================================================
0001B2E4                            
0001B2E4                            ; =========================================================================================================================================================
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            ; Sound driver
0001B2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E4                            		include	"Sound/amps/code/68k.asm"
0001B2E4                            	opt oz+					; enable zero-offset optimization
0001B2E4                            	opt l.					; local lables are dots
0001B2E4                            	opt ae+					; enable automatic even's
0001B2E4                            
0001B2E4                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Note timout handler macro
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dNoteToutHandler	macro
0001B2E4                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0001B2E4                            		beq.s	.endt			; if is, do not timeout
0001B2E4                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0001B2E4                            		bne.s	.endt			; if still not 0, branch
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Note timout handler macro for DAC
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dNoteToutDAC	macro
0001B2E4                            	dNoteToutHandler			; include timeout handler
0001B2E4                            		moveq	#0,d0			; play stop sample
0001B2E4                            		bra.w	dNoteOnDAC2		; ''
0001B2E4                            .endt
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Note timout handler macro for FM
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dNoteToutFM	macro
0001B2E4                            	dNoteToutHandler			; include timeout handler
0001B2E4                            		bset	#cfbRest,(a5)		; set track to resting
0001B2E4                            		bsr.w	dKeyOffFM		; key off FM
0001B2E4                            		bra.\0	.next			; jump to next track
0001B2E4                            .endt
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Note timout handler macro for PSG
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dNoteToutPSG	macro
0001B2E4                            	dNoteToutHandler			; include timeout handler
0001B2E4                            		bset	#cfbRest,(a5)		; set track to resting
0001B2E4                            		bsr.w	dMutePSGmus		; mute PSG channel
0001B2E4                            		bra.s	.next			; jump to next track
0001B2E4                            .endt
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for calculating the current frequency (without modulation) into d6.
0001B2E4                            ; Used if user wants to add extra pitch effects such as pitch slides.
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dCalcFreq	macro
0001B2E4                            		move.b	cDetune(a5),d6		; get detune value to d6
0001B2E4                            		ext.w	d6			; extend to word
0001B2E4                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for generating frequency modulation code
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dModulate	macro jump,loop,type
0001B2E4                            		btst	#cfbMod,(a5)		; check if modulation is active
0001B2E4                            		beq.s	.noret			; if not, update volume and return
0001B2E4                            		tst.b	cModDelay(a5)		; check if there is delay left
0001B2E4                            		beq.s	.started		; if not, modulate!
0001B2E4                            		subq.b	#1,cModDelay(a5)	; decrease delay
0001B2E4                            .noret
0001B2E4                            	if narg>0
0001B2E4                            		if narg=3
0001B2E4                            			if type<2
0001B2E4                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2E4                            				beq.s	.noupdatevol		; if not, skip
0001B2E4                            				jsr	dUpdateVolFM(pc)	; update FM volume
0001B2E4                            			.noupdatevol:
0001B2E4                            			endif
0001B2E4                            			if type>=4
0001B2E4                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2E4                            				beq.s	.noupdatevol		; if not, skip
0001B2E4                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0001B2E4                            			.noupdatevol:
0001B2E4                            			endif
0001B2E4                            			if \type<>5
0001B2E4                            				dbf	d7,\loop		; loop for all channels
0001B2E4                            			endif
0001B2E4                            		endif
0001B2E4                            		bra.w	\jump			; jump to next routine
0001B2E4                            	else
0001B2E4                            		bra.s	.endm			; jump to the next .endm routine
0001B2E4                            	endif
0001B2E4                            .started
0001B2E4                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0001B2E4                            		bne.s	.noret			; if there's still delay left, update vol and return
0001B2E4                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0001B2E4                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0001B2E4                            		tst.b	cModCount(a5)		; check if this was the last step
0001B2E4                            		bne.s	.norev			; if was not, do not reverse
0001B2E4                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0001B2E4                            		neg.b	cModStep(a5)		; negate step amount
0001B2E4                            .norev
0001B2E4                            		subq.b	#1,cModCount(a5)	; decrease step counter
0001B2E4                            		move.b	cModStep(a5),d5		; get step offset into d5
0001B2E4                            		ext.w	d5			; extend to word
0001B2E4                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0001B2E4                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0001B2E4                            		add.w	d5,d6			; add to channel base frequency
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for processing the tracker
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dDoTracker	macro
0001B2E4                            		movea.l	cData(a5),a4		; grab tracker address
0001B2E4                            	if safe=1
0001B2E4                            		AMPS_Debug_TrackUpd		; check if this address is valid
0001B2E4                            	endif
0001B2E4                            .data
0001B2E4                            		moveq	#0,d5
0001B2E4                            		move.b	(a4)+,d5		; get a byte from tracker
0001B2E4                            		cmpi.b	#$E0,d5			; is this a command?
0001B2E4                            		blo.s	.notcomm		; if not, continue
0001B2E4                            		jsr	dCommands(pc)		; run the condition flag
0001B2E4                            		bra.s	.data			; for most commands, use this branch to loop
0001B2E4                            		bra.s	.next			; however, for example sStop will make us return here.
0001B2E4                            .notcomm
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for playing a note, and setting up for it (software updates only)
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dProcNote	macro sfx, psg
0001B2E4                            		move.l	a4,cData(a5)		; save tracker address
0001B2E4                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0001B2E4                            		btst	#cfbHold,(a5)		; check if we are holding
0001B2E4                            		bne.s	.endpn			; if we are, branch
0001B2E4                            	if sfx=0
0001B2E4                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0001B2E4                            	endif
0001B2E4                            	if psg<>0
0001B2E4                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0001B2E4                            	endif
0001B2E4                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0001B2E4                            		beq.s	.endpn			; if not, branch
0001B2E4                            		movea.l	cMod(a5),a1		; get modulation data address
0001B2E4                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0001B2E4                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0001B2E4                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0001B2E4                            		move.b	(a1),d0			; get number of steps
0001B2E4                            		lsr.b	#1,d0			; halve it
0001B2E4                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0001B2E4                            		clr.w	cModFreq(a5)		; clear frequency offset
0001B2E4                            .endpn
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for processing a note in DAC channel
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dTrackNoteDAC	macro
0001B2E4                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0001B2E4                            		bne.s	.pitch			; if so, load pitch
0001B2E4                            		move.b	d5,cSample(a5)		; else, save as a sample
0001B2E4                            		bra.s	.cont
0001B2E4                            .pitch
0001B2E4                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001B2E4                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0001B2E4                            		moveq	#0,d0			; play stop sample
0001B2E4                            		bsr.w	dNoteOnDAC2		; ''
0001B2E4                            		moveq	#-$80,d6		; tell the code we are resting
0001B2E4                            		bra.s	.cont
0001B2E4                            .noprest
0001B2E4                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2E4                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2E4                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001B2E4                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2E4                            .cont
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for doing keying-on FM channel
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dKeyOnFM	macro
0001B2E4                            		btst	#cfbHold,(a5)		; check if note is held
0001B2E4                            		bne.s	.k			; if so, do not note on
0001B2E4                            		btst	#cfbRest,(a5)		; check if channel is resting
0001B2E4                            		bne.s	.k			; if so, do not note on
0001B2E4                            	if narg=0
0001B2E4                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0001B2E4                            		bne.s	.k			; if so, do not note on
0001B2E4                            	endif
0001B2E4                            		moveq	#$28,d0			; YM command: Key on
0001B2E4                            		move.b	cType(a5),d1		; get channel type bits
0001B2E4                            		ori.b	#$F0,d1			; turn all FM operators on
0001B2E4                            		bsr.w	WriteYM_Pt1		; send note-on event
0001B2E4                            .k
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Macro for processing a note in PSG channel
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            dGetFreqPSG	macro
0001B2E4                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0001B2E4                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0001B2E4                            		bset	#cfbRest,(a5)		; set channel to resting
0001B2E4                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0001B2E4                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0001B2E4                            		bra.s	.freqgot
0001B2E4                            .norest
0001B2E4                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2E4                            		andi.w	#$7F,d5			; keep within $80 notes
0001B2E4                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2E4                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2E4                            	if safe=1
0001B2E4                            		AMPS_Debug_NotePSG		; check if the note was valid
0001B2E4                            	endif
0001B2E4                            .freqgot
0001B2E4                                endm
0001B2E4                            ; ===========================================================================
0001B2E4                            	include "Sound/amps/code/debug.asm"	; debug data blob
0001B2E4                            ; ===========================================================================
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            ; Routine for loading the Dual PCM driver into Z80 RAM
0001B2E4                            ; ---------------------------------------------------------------------------
0001B2E4                            
0001B2E4                            LoadDualPCM:
0001B2E4 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0001B2EC 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B2F4                            
0001B2F4 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0001B2FA 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0001B300 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0001B304                            
0001B304                            .z80
0001B304 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0001B30C 66F6                       		bne.s	.z80			; if not, wait more
0001B30E                            
0001B30E                            .load
0001B30E 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0001B310 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0001B314                            
0001B314 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0001B318 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0001B31E                            
0001B31E                            	rept 6
0001B31E                            		move.b	(a0)+,(a1)+		; copy all required data
0001B31E                            	endr
0001B31E 12D8                     M 	move.b	(a0)+,(a1)+
0001B320 12D8                     M 	move.b	(a0)+,(a1)+
0001B322 12D8                     M 	move.b	(a0)+,(a1)+
0001B324 12D8                     M 	move.b	(a0)+,(a1)+
0001B326 12D8                     M 	move.b	(a0)+,(a1)+
0001B328 12D8                     M 	move.b	(a0)+,(a1)+
0001B32A                            
0001B32A 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0001B32C 0838 0006 C744             		btst	#6,rHWVersion.w	; is this a PAL Mega Drive?
0001B332 6700                       		beq.s	.ntsc			; if not, branch
0001B334 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0001B336                            .ntsc
0001B336 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0001B33C                            
0001B33C 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0001B344 727F                       		moveq	#$7F,d1			; wait for a little bit
0001B346 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0001B34A                            
0001B34A 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0001B352 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B35A 4E75                       		rts
0001B35C                            ; ---------------------------------------------------------------------------
0001B35C                            ; Play DAC
0001B35C                            ; ---------------------------------------------------------------------------
0001B35C                            
0001B35C                            PlayDAC2:
0001B35C 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B362                            	StopZ80					; wait for Z80 to stop
0001B362 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B36A                          M 	waitz80stop
0001B36A 0839 0000 00A1 1100      M .wait_284:	btst	#0,z80_bus_req
0001B372 66F6                     M 	bne.s	.wait_284
0001B374                            	rept 12
0001B374                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B374                            	endr
0001B374 12DB                     M 	move.b	(a3)+,(a1)+
0001B376 12DB                     M 	move.b	(a3)+,(a1)+
0001B378 12DB                     M 	move.b	(a3)+,(a1)+
0001B37A 12DB                     M 	move.b	(a3)+,(a1)+
0001B37C 12DB                     M 	move.b	(a3)+,(a1)+
0001B37E 12DB                     M 	move.b	(a3)+,(a1)+
0001B380 12DB                     M 	move.b	(a3)+,(a1)+
0001B382 12DB                     M 	move.b	(a3)+,(a1)+
0001B384 12DB                     M 	move.b	(a3)+,(a1)+
0001B386 12DB                     M 	move.b	(a3)+,(a1)+
0001B388 12DB                     M 	move.b	(a3)+,(a1)+
0001B38A 12DB                     M 	move.b	(a3)+,(a1)+
0001B38C 101B                       		move.b	(a3)+,d0
0001B38E 5200                       		addq.b	#1,d0
0001B390 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0001B396 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0001B39C 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B3A4                            
0001B3A4 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001B3AC                            	StartZ80				; enable Z80 execution
0001B3AC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B3B4 4E75                       		rts
0001B3B6                            
0001B3B6                            ; ---------------------------------------------------------------------------
0001B3B6                            
0001B3B6                            PlayDAC1:
0001B3B6 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0001B3BC                            	StopZ80					; wait for Z80 to stop
0001B3BC 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B3C4                          M 	waitz80stop
0001B3C4 0839 0000 00A1 1100      M .wait_287:	btst	#0,z80_bus_req
0001B3CC 66F6                     M 	bne.s	.wait_287
0001B3CE                            	rept 12
0001B3CE                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B3CE                            	endr
0001B3CE 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D0 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D2 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D4 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D6 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D8 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DA 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DC 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DE 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E0 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E2 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E4 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E6 101B                       		move.b	(a3)+,d0
0001B3E8 5200                       		addq.b	#1,d0
0001B3EA 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0001B3F0 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0001B3F6 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B3FE                            
0001B3FE 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B406                            	StartZ80				; enable Z80 execution
0001B406 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B40E 4E75                       		rts
0001B410                            ; ===========================================================================
0001B410                            ; ---------------------------------------------------------------------------
0001B410                            ; Handle Dual PCM YM Cue correctly
0001B410                            ; ---------------------------------------------------------------------------
0001B410                            
0001B410                            UpdateAMPS:
0001B410                            	StopZ80					; wait for Z80 to stop
0001B410 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B418                          M 	waitz80stop
0001B418 0839 0000 00A1 1100      M .wait_290:	btst	#0,z80_bus_req
0001B420 66F6                     M 	bne.s	.wait_290
0001B422 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0001B428                            	StartZ80				; enable Z80 execution
0001B428 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B430                            
0001B430 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0001B436 4A00                       		tst.b	d0			; check buffer to use
0001B438 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0001B43A D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0001B43E                            
0001B43E                            .gotbuffer
0001B43E 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0001B440                            
0001B440                            	StopZ80					; wait for Z80 to stop
0001B440 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B448                          M 	waitz80stop
0001B448 0839 0000 00A1 1100      M .wait_293:	btst	#0,z80_bus_req
0001B450 66F6                     M 	bne.s	.wait_293
0001B452 50D0                       		st	(a0)			; make sure cue is marked as completed
0001B454                            	StartZ80				; enable Z80 execution
0001B454 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B45C                            
0001B45C                            dPaused:
0001B45C 4E75                       		rts
0001B45E                            ; ===========================================================================
0001B45E                            ; ---------------------------------------------------------------------------
0001B45E                            ; Main routine for updating the AMPS driver
0001B45E                            ; ---------------------------------------------------------------------------
0001B45E                            
0001B45E                            dUpdateAllAMPS:
0001B45E 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0001B462 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0001B466 6BF4                       		bmi.s	dPaused			; if yes, branch
0001B468                            ; ---------------------------------------------------------------------------
0001B468                            ; This is the new fading feature I created, to make custom fading
0001B468                            ; types easier to program. You can define series of 3 bytes, each
0001B468                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0001B468                            ; once per frame. If the first value in a frame is a command flag,
0001B468                            ; instead its code is executed. Additionally, no fade program may
0001B468                            ; appear before ROM offset $10000, or else it will never be executed.
0001B468                            ; ---------------------------------------------------------------------------
0001B468                            
0001B468 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001B46C 6700                       		beq.s	.chkregion		; branch if not
0001B46E                            
0001B46E 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0001B472 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0001B476                            
0001B476 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0001B478 7000                       		moveq	#0,d0
0001B47A 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0001B47C 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0001B47E                            
0001B47E 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0001B482 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0001B486 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0001B48A 6000                       		bra.s	.chkregion		; go check the region
0001B48C                            
0001B48C                            .nofadeend
0001B48C B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0001B490 6700                       		beq.s	.fadedac		; if did not, branch
0001B492 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0001B496 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0001B49A                            
0001B49A                            .fadedac
0001B49A 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0001B49C B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0001B4A0 6700                       		beq.s	.fadepsg		; if did not, branch
0001B4A2 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0001B4A6                            
0001B4A6 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001B4A6                            	rept Mus_DAC				; do for all music DAC channels
0001B4A6                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4A6                            .ch =		.ch+cSize			; go to next channel
0001B4A6                            	endr
0001B4A6 8338 C4C4                M 	or.b	d1,.ch.w
0001B4AA =FFFFC4F0                M .ch	=	.ch+csize
0001B4AA 8338 C4F0                M 	or.b	d1,.ch.w
0001B4AE =FFFFC51C                M .ch	=	.ch+csize
0001B4AE 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0001B4B2                            
0001B4B2                            .fadepsg
0001B4B2 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0001B4B4 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0001B4B8 6700                       		beq.s	.chkregion		; if did not, branch
0001B4BA 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0001B4BE                            
0001B4BE =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001B4BE                            	rept Mus_PSG				; do for all music PSG channels
0001B4BE                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4BE                            .ch =		.ch+cSize			; go to next channel
0001B4BE                            	endr
0001B4BE 8338 C5F8                M 	or.b	d1,.ch.w
0001B4C2 =FFFFC624                M .ch	=	.ch+csize
0001B4C2 8338 C624                M 	or.b	d1,.ch.w
0001B4C6 =FFFFC650                M .ch	=	.ch+csize
0001B4C6 8338 C650                M 	or.b	d1,.ch.w
0001B4CA =FFFFC67C                M .ch	=	.ch+csize
0001B4CA                            
0001B4CA =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001B4CA                            	rept SFX_PSG				; do for all SFX PSG channels
0001B4CA                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4CA                            .ch =		.ch+cSizeSFX			; go to next channel
0001B4CA                            	endr
0001B4CA 8338 C6EC                M 	or.b	d1,.ch.w
0001B4CE =FFFFC708                M .ch	=	.ch+csizesfx
0001B4CE 8338 C708                M 	or.b	d1,.ch.w
0001B4D2 =FFFFC724                M .ch	=	.ch+csizesfx
0001B4D2 8338 C724                M 	or.b	d1,.ch.w
0001B4D6 =FFFFC740                M .ch	=	.ch+csizesfx
0001B4D6                            ; ---------------------------------------------------------------------------
0001B4D6                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0001B4D6                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0001B4D6                            ; on PAL systems. This will cause issues with some songs that rely on
0001B4D6                            ; game engine to seem "in sync". Because of that, I added a flag to
0001B4D6                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0001B4D6                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0001B4D6                            ; play at the exact right speed, instead of slightly too slow.
0001B4D6                            ; ---------------------------------------------------------------------------
0001B4D6                            
0001B4D6 0838 0006 C744             .chkregion	btst	#6,rHWVersion.w	; is this PAL system?
0001B4DC 6700                       		beq.s	.driver			; if not, branch
0001B4DE 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0001B4E2 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0001B4E4                            
0001B4E4 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0001B4EA 6600                       		bne.s	.nofix			; if yes, run music and SFX
0001B4EC 6100                       		bsr.s	.nosfx			; run the sound driver
0001B4EE                            
0001B4EE                            .nofix
0001B4EE 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0001B4F4                            .driver
0001B4F4 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0001B4F8                            
0001B4F8                            .nosfx		; continue to run sound driver again
0001B4F8                            ; ---------------------------------------------------------------------------
0001B4F8                            ; There are 2 methods of handling tempo adjustments in SMPS,
0001B4F8                            ; overflow (where a value is added to the accumulator, and when it
0001B4F8                            ; range overflows, tick of delay is added), and counter (where a
0001B4F8                            ; counter is copied to the tempo, which is then decreased each frame,
0001B4F8                            ; until it becomes 0, after which a tick of delay is added). AMPS
0001B4F8                            ; supports these both too, because there is no single right answer,
0001B4F8                            ; and users may prefer one over the other. The overflow method is
0001B4F8                            ; really good for low values, as it provides very fine control over
0001B4F8                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0001B4F8                            ; method isn't as good for small values, but for large value it works
0001B4F8                            ; better. You may choose this setting in the macro.asm file,
0001B4F8                            ; ---------------------------------------------------------------------------
0001B4F8                            
0001B4F8 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0001B4FC D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0001B500 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0001B502                            
0001B502                            
0001B502 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0001B502                            	rept Mus_Ch				; loop through all music channels
0001B502                            		addq.b	#1,.ch.w		; add 1 to duration
0001B502                            .ch =		.ch+cSize			; go to next channel
0001B502                            	endr
0001B502 5238 C4D0                M 	addq.b	#1,.ch.w
0001B506 =FFFFC4FC                M .ch	=	.ch+csize
0001B506 5238 C4FC                M 	addq.b	#1,.ch.w
0001B50A =FFFFC528                M .ch	=	.ch+csize
0001B50A 5238 C528                M 	addq.b	#1,.ch.w
0001B50E =FFFFC554                M .ch	=	.ch+csize
0001B50E 5238 C554                M 	addq.b	#1,.ch.w
0001B512 =FFFFC580                M .ch	=	.ch+csize
0001B512 5238 C580                M 	addq.b	#1,.ch.w
0001B516 =FFFFC5AC                M .ch	=	.ch+csize
0001B516 5238 C5AC                M 	addq.b	#1,.ch.w
0001B51A =FFFFC5D8                M .ch	=	.ch+csize
0001B51A 5238 C5D8                M 	addq.b	#1,.ch.w
0001B51E =FFFFC604                M .ch	=	.ch+csize
0001B51E 5238 C604                M 	addq.b	#1,.ch.w
0001B522 =FFFFC630                M .ch	=	.ch+csize
0001B522 5238 C630                M 	addq.b	#1,.ch.w
0001B526 =FFFFC65C                M .ch	=	.ch+csize
0001B526 5238 C65C                M 	addq.b	#1,.ch.w
0001B52A =FFFFC688                M .ch	=	.ch+csize
0001B52A                            ; ===========================================================================
0001B52A                            ; ---------------------------------------------------------------------------
0001B52A                            ; Process music DAC channels
0001B52A                            ; ---------------------------------------------------------------------------
0001B52A                            
0001B52A                            dAMPSdoAll:
0001B52A 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B52E 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0001B532 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0001B534                            
0001B534                            dAMPSdoDAC:
0001B534 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0001B538 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B53A 6A00 0000                  		bpl.w	.next			; if not, branch
0001B53E 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B542 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B546                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0001B546                          M 	dnotetouthandler
0001B546 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001B54A 6700                     M 	beq.s	.endt
0001B54C 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001B550 6600                     M 	bne.s	.endt
0001B552 7000                     M 	moveq	#0,d0
0001B554 6000 0000                M 	bra.w	dnoteondac2
0001B558                          M .endt
0001B558                            
0001B558                            	dCalcFreq				; calculate channel base frequency
0001B558 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B55C 4886                     M 	ext.w	d6
0001B55E DC6D 000E                M 	add.w	cfreq(a5),d6
0001B562                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0001B562 0815 0003                M 	btst	#cfbmod,(a5)
0001B566 6700                     M 	beq.s	.noret
0001B568 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B56C 6700                     M 	beq.s	.started
0001B56E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B572                          M .noret
0001B572 0895 0005                M 	bclr	#cfbvol,(a5)
0001B576 6700                     M 	beq.s	.noupdatevol
0001B578 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B57C                          M 	.noupdatevol:
0001B57C 51CF FFB6                M 	dbf	d7,dampsdodac
0001B580 6000 0000                M 	bra.w	dampsdofm
0001B584                          M .started
0001B584 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B588 66E8                     M 	bne.s	.noret
0001B58A 226D 0010                M 	movea.l	cmod(a5),a1
0001B58E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B594 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B598 6600                     M 	bne.s	.norev
0001B59A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B5A0 442D 0017                M 	neg.b	cmodstep(a5)
0001B5A4                          M .norev
0001B5A4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B5A8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B5AC 4885                     M 	ext.w	d5
0001B5AE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B5B2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B5B6 DC45                     M 	add.w	d5,d6
0001B5B8 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0001B5BC                            
0001B5BC 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B5C0 6700                       		beq.s	.next			; if not, skip
0001B5C2 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0001B5C6                            
0001B5C6                            .next
0001B5C6 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B5CA 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0001B5CE                            
0001B5CE                            .update
0001B5CE 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B5D2                            	dDoTracker				; process tracker
0001B5D2 286D 0002                M 	movea.l	cdata(a5),a4
0001B5D6                          M .data
0001B5D6 7A00                     M 	moveq	#0,d5
0001B5D8 1A1C                     M 	move.b	(a4)+,d5
0001B5DA 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B5DE 6500                     M 	blo.s	.notcomm
0001B5E0 4EBA 0000                M 	jsr	dcommands(pc)
0001B5E4 60F0                     M 	bra.s	.data
0001B5E6 60DE                     M 	bra.s	.next
0001B5E8                          M .notcomm
0001B5E8 7C00                       		moveq	#0,d6			; clear rest flag
0001B5EA 4A05                       		tst.b	d5			; check if note is being played
0001B5EC 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B5EE                            
0001B5EE                            	dTrackNoteDAC				; calculate frequency or update sample
0001B5EE 0815 0000                M 	btst	#cfbmode,(a5)
0001B5F2 6600                     M 	bne.s	.pitch
0001B5F4 1B45 000B                M 	move.b	d5,csample(a5)
0001B5F8 6000                     M 	bra.s	.cont
0001B5FA                          M .pitch
0001B5FA 0405 0080                M 	subi.b	#$80,d5
0001B5FE 6600                     M 	bne.s	.noprest
0001B600 7000                     M 	moveq	#0,d0
0001B602 6100 0000                M 	bsr.w	dnoteondac2
0001B606 7C80                     M 	moveq	#-$80,d6
0001B608 6000                     M 	bra.s	.cont
0001B60A                          M .noprest
0001B60A DA2D 0008                M 	add.b	cpitch(a5),d5
0001B60E DA45                     M 	add.w	d5,d5
0001B610 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B614 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B61A                          M .cont
0001B61A 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B61C 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B61E 534C                       		subq.w	#1,a4			; else, undo the increment
0001B620 6000                       		bra.s	.pcnote			; do not calculate duration
0001B622                            
0001B622                            .timer
0001B622 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0001B626                            .pcnote
0001B626                            	dProcNote 0, 0				; reset necessary channel memory
0001B626 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B62A 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B630 0815 0002                M 	btst	#cfbhold,(a5)
0001B634 6600                     M 	bne.s	.endpn
0001B636 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001B63C 0815 0003                M 	btst	#cfbmod,(a5)
0001B640 6700                     M 	beq.s	.endpn
0001B642 226D 0010                M 	movea.l	cmod(a5),a1
0001B646 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B64A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B64E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B652 1011                     M 	move.b	(a1),d0
0001B654 E208                     M 	lsr.b	#1,d0
0001B656 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B65A 426D 0014                M 	clr.w	cmodfreq(a5)
0001B65E                          M .endpn
0001B65E                            
0001B65E 4A06                       		tst.b	d6			; check if channel was resting
0001B660 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B662 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0001B664                            
0001B664 51CF FECE                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B668 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0001B66C                            ; ===========================================================================
0001B66C                            ; ---------------------------------------------------------------------------
0001B66C                            ; Write DAC sample information to Dual PCM
0001B66C                            ; ---------------------------------------------------------------------------
0001B66C                            
0001B66C                            dNoteOnDAC2:
0001B66C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B670 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0001B672 4E75                       		rts
0001B674                            
0001B674                            dNoteOnDAC:
0001B674 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B678 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0001B67A                            
0001B67A 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B67C 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B680 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B684 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001B688 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0001B68C                            
0001B68C                            dNoteOnDAC3:
0001B68C E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B68E 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0001B692                            
0001B692 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0001B696 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B69C 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0001B69E                            ; ---------------------------------------------------------------------------
0001B69E                            ; This code is for updating the note to Dual PCM. We have tracker commands
0001B69E                            ; for also playing notes on DAC channels, which is why the code seems a
0001B69E                            ; little weird.
0001B69E                            ; ---------------------------------------------------------------------------
0001B69E                            
0001B69E                            dNoteWriteDAC2:
0001B69E 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B6A4 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0001B6AA 6000                       		bra.s	dNoteOnDAC4
0001B6AC                            
0001B6AC                            dNoteWriteDAC1:
0001B6AC                            
0001B6AC 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0001B6B2 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0001B6B8                            
0001B6B8                            dNoteOnDAC4:
0001B6B8                            	StopZ80					; wait for Z80 to stop
0001B6B8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B6C0                          M 	waitz80stop
0001B6C0 0839 0000 00A1 1100      M .wait_303:	btst	#0,z80_bus_req
0001B6C8 66F6                     M 	bne.s	.wait_303
0001B6CA                            	rept 12
0001B6CA                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B6CA                            	endr
0001B6CA 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CC 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CE 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D0 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D2 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D4 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D6 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D8 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DA 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DC 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DE 12DB                     M 	move.b	(a3)+,(a1)+
0001B6E0 12DB                     M 	move.b	(a3)+,(a1)+
0001B6E2                            
0001B6E2 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0001B6E6                            	StartZ80				; enable Z80 execution
0001B6E6 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B6EE                            
0001B6EE                            locret_dNoteOnDAC4:
0001B6EE 4E75                       		rts
0001B6F0                            ; ===========================================================================
0001B6F0                            ; ---------------------------------------------------------------------------
0001B6F0                            ; Write DAC frequency to Dual PCM
0001B6F0                            ; ---------------------------------------------------------------------------
0001B6F0                            
0001B6F0                            dUpdateFreqOffDAC2:
0001B6F0 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B6F2 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0001B6F6                            
0001B6F6                            dUpdateFreqOffDAC:
0001B6F6 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001B6FA DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0001B6FC                            
0001B6FC 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0001B700 4880                       		ext.w	d0			; extend to word
0001B702 DC40                       		add.w	d0,d6			; add it to d6
0001B704                            
0001B704 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001B708 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0001B70A DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001B70E 6000                       		bra.s	dUpdateFreqDAC3
0001B710                            
0001B710                            dUpdateFreqDAC:
0001B710 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B714 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0001B716                            
0001B716                            dUpdateFreqDAC2:
0001B716 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B718 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B71C 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B720 E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0001B722 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0001B726                            
0001B726                            dUpdateFreqDAC3:
0001B726                            
0001B726 1006                       		move.b	d6,d0			; copy the frequency to d0
0001B728 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0001B72A 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0001B730 6700                       		beq.s	dFreqDAC1		; if is, branch
0001B732                            
0001B732                            	StopZ80					; wait for Z80 to stop
0001B732 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B73A                          M 	waitz80stop
0001B73A 0839 0000 00A1 1100      M .wait_306:	btst	#0,z80_bus_req
0001B742 66F6                     M 	bne.s	.wait_306
0001B744 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0001B74A 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0001B750 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B758                            	StartZ80				; enable Z80 execution
0001B758 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B760                            
0001B760                            locret_UpdFreqDAC;
0001B760 4E75                       		rts
0001B762                            
0001B762                            dFreqDAC1:
0001B762                            	StopZ80					; wait for Z80 to stop
0001B762 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B76A                          M 	waitz80stop
0001B76A 0839 0000 00A1 1100      M .wait_309:	btst	#0,z80_bus_req
0001B772 66F6                     M 	bne.s	.wait_309
0001B774 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0001B77A 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0001B780 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B788                            	StartZ80				; enable Z80 execution
0001B788 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B790 4E75                       		rts
0001B792                            ; ===========================================================================
0001B792                            ; ---------------------------------------------------------------------------
0001B792                            ; Routine to multiply duration by tick rate
0001B792                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0001B792                            ; around the loop will be faster than a single mulu instruction
0001B792                            ; ---------------------------------------------------------------------------
0001B792                            
0001B792                            dCalcDuration:
0001B792 7000                       		moveq	#0,d0			; clear duration
0001B794 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0001B796 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0001B79A                            
0001B79A D005                       .multiply	add.b	d5,d0			; add duration value to d0
0001B79C 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0001B7A0                            
0001B7A0 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0001B7A4 4E75                       		rts				; get copied to duration by later code
0001B7A6                            ; ===========================================================================
0001B7A6                            ; ---------------------------------------------------------------------------
0001B7A6                            ; Process SFX DAC channels
0001B7A6                            ; ---------------------------------------------------------------------------
0001B7A6                            
0001B7A6                            dAMPSdoSFX:
0001B7A6 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0001B7AA                            
0001B7AA                            dAMPSdoDACSFX:
0001B7AA DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001B7AE 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B7B0 6A00                       		bpl.s	.next			; if not, branch
0001B7B2                            
0001B7B2 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B7B6 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B7BA 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B7BE                            
0001B7BE                            	dCalcFreq				; calculate channel base frequency
0001B7BE 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B7C2 4886                     M 	ext.w	d6
0001B7C4 DC6D 000E                M 	add.w	cfreq(a5),d6
0001B7C8                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0001B7C8 0815 0003                M 	btst	#cfbmod,(a5)
0001B7CC 6700                     M 	beq.s	.noret
0001B7CE 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B7D2 6700                     M 	beq.s	.started
0001B7D4 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B7D8                          M .noret
0001B7D8 0895 0005                M 	bclr	#cfbvol,(a5)
0001B7DC 6700                     M 	beq.s	.noupdatevol
0001B7DE 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B7E2                          M 	.noupdatevol:
0001B7E2 6000 0000                M 	bra.w	dampsdofmsfx
0001B7E6                          M .started
0001B7E6 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B7EA 66EC                     M 	bne.s	.noret
0001B7EC 226D 0010                M 	movea.l	cmod(a5),a1
0001B7F0 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B7F6 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B7FA 6600                     M 	bne.s	.norev
0001B7FC 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B802 442D 0017                M 	neg.b	cmodstep(a5)
0001B806                          M .norev
0001B806 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B80A 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B80E 4885                     M 	ext.w	d5
0001B810 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B814 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B818 DC45                     M 	add.w	d5,d6
0001B81A 6100 FEFA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0001B81E                            
0001B81E 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B822 6700                       		beq.s	.next			; if not, skip
0001B824 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0001B828                            
0001B828                            .next
0001B828 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B82C                            
0001B82C                            .update
0001B82C 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B830                            	dDoTracker				; process tracker
0001B830 286D 0002                M 	movea.l	cdata(a5),a4
0001B834                          M .data
0001B834 7A00                     M 	moveq	#0,d5
0001B836 1A1C                     M 	move.b	(a4)+,d5
0001B838 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B83C 6500                     M 	blo.s	.notcomm
0001B83E 4EBA 0000                M 	jsr	dcommands(pc)
0001B842 60F0                     M 	bra.s	.data
0001B844 60E2                     M 	bra.s	.next
0001B846                          M .notcomm
0001B846 7C00                       		moveq	#0,d6			; clear rest flag
0001B848 4A05                       		tst.b	d5			; check if note is being played
0001B84A 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B84C                            
0001B84C                            	dTrackNoteDAC				; calculate frequency or update sample
0001B84C 0815 0000                M 	btst	#cfbmode,(a5)
0001B850 6600                     M 	bne.s	.pitch
0001B852 1B45 000B                M 	move.b	d5,csample(a5)
0001B856 6000                     M 	bra.s	.cont
0001B858                          M .pitch
0001B858 0405 0080                M 	subi.b	#$80,d5
0001B85C 6600                     M 	bne.s	.noprest
0001B85E 7000                     M 	moveq	#0,d0
0001B860 6100 FE0A                M 	bsr.w	dnoteondac2
0001B864 7C80                     M 	moveq	#-$80,d6
0001B866 6000                     M 	bra.s	.cont
0001B868                          M .noprest
0001B868 DA2D 0008                M 	add.b	cpitch(a5),d5
0001B86C DA45                     M 	add.w	d5,d5
0001B86E 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B872 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B878                          M .cont
0001B878 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B87A 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B87C 534C                       		subq.w	#1,a4			; else, undo the increment
0001B87E 6000                       		bra.s	.pcnote			; do not calculate duration
0001B880                            
0001B880                            .timer
0001B880 4EBA FF10                  		jsr	dCalcDuration(pc)	; calculate duration
0001B884                            .pcnote
0001B884                            	dProcNote 1, 0				; reset necessary channel memory
0001B884 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B888 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B88E 0815 0002                M 	btst	#cfbhold,(a5)
0001B892 6600                     M 	bne.s	.endpn
0001B894 0815 0003                M 	btst	#cfbmod,(a5)
0001B898 6700                     M 	beq.s	.endpn
0001B89A 226D 0010                M 	movea.l	cmod(a5),a1
0001B89E 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B8A2 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B8A6 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B8AA 1011                     M 	move.b	(a1),d0
0001B8AC E208                     M 	lsr.b	#1,d0
0001B8AE 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B8B2 426D 0014                M 	clr.w	cmodfreq(a5)
0001B8B6                          M .endpn
0001B8B6 4A06                       		tst.b	d6			; check if channel was resting
0001B8B8 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B8BA 6100 FDB8                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0001B8BE                            
0001B8BE                            .noplay
0001B8BE 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B8C2                            ; ===========================================================================
0001B8C2                            ; ---------------------------------------------------------------------------
0001B8C2                            ; Write DAC volume to Dual PCM
0001B8C2                            ; ---------------------------------------------------------------------------
0001B8C2                            
0001B8C2                            dUpdateVolDAC:
0001B8C2 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B8C6 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0001B8C8                            
0001B8C8                            dUpdateVolDAC2:
0001B8C8 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0001B8CC D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0001B8D0 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0001B8D2 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0001B8D4                            
0001B8D4                            .gotvol
0001B8D4                            	StopZ80					; wait for Z80 to stop
0001B8D4 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B8DC                          M 	waitz80stop
0001B8DC 0839 0000 00A1 1100      M .wait_317:	btst	#0,z80_bus_req
0001B8E4 66F6                     M 	bne.s	.wait_317
0001B8E6 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0001B8EE                            
0001B8EE 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B8F4 6700                       		beq.s	.dac1			; if is, branch
0001B8F6 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0001B8FC                            	StartZ80				; enable Z80 execution
0001B8FC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B904 4E75                       		rts
0001B906                            
0001B906                            .dac1
0001B906 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0001B90C                            	StartZ80				; enable Z80 execution
0001B90C 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B914                            
0001B914                            locret_VolDAC:
0001B914 4E75                       		rts
0001B916                            ; ===========================================================================
0001B916                            ; ---------------------------------------------------------------------------
0001B916                            ; Routine for unpausing the sound driver
0001B916                            ; ---------------------------------------------------------------------------
0001B916                            
0001B916                            dPlaySnd_Unpause:
0001B916 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0001B91C 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0001B91E                            ; ---------------------------------------------------------------------------
0001B91E                            ; The following code will reset the panning values for each running
0001B91E                            ; channel. It also makes sure that the channel is not interrupted
0001B91E                            ; by sound effects, and that each running sound effect channel gets
0001B91E                            ; updated. We do not handle key on's, since that could potentially
0001B91E                            ; cause issues if notes are half-done. The next time tracker plays
0001B91E                            ; notes, they start being audible again.
0001B91E                            ; ---------------------------------------------------------------------------
0001B91E                            
0001B91E 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001B922 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0001B924 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0001B926                            
0001B926                            .musloop
0001B926 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B928 6A00                       		bpl.s	.skipmus		; if not, do not update
0001B92A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B92E 6600                       		bne.s	.skipmus		; if is, do not update
0001B930                            
0001B930 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B932 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B936 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B93A                            
0001B93A                            .skipmus
0001B93A DAC3                       		adda.w	d3,a5			; go to next channel
0001B93C 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0001B940                            
0001B940 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0001B944 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0001B946 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0001B948                            
0001B948                            .sfxloop
0001B948 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B94A 6A00                       		bpl.s	.skipsfx		; if not, do not update
0001B94C                            
0001B94C 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B94E 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B952 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B956                            
0001B956                            .skipsfx
0001B956 DAC3                       		adda.w  d3,a5			; go to next channel
0001B958 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0001B95C                            ; ---------------------------------------------------------------------------
0001B95C                            ; Since the DAC channels have or based panning behavior, we need this
0001B95C                            ; piece of code to update its panning
0001B95C                            ; ---------------------------------------------------------------------------
0001B95C                            
0001B95C 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001B960 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001B966 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001B968 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001B96C                            
0001B96C                            .nodacsfx
0001B96C 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001B970 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001B972 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001B976                            ; ===========================================================================
0001B976                            ; ---------------------------------------------------------------------------
0001B976                            ; Routine for pausing the sound driver
0001B976                            ; ---------------------------------------------------------------------------
0001B976                            
0001B976                            dPlaySnd_Pause:
0001B976 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0001B97C 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0001B97E                            ; ---------------------------------------------------------------------------
0001B97E                            ; The following code will set channel panning to none for all FM channels.
0001B97E                            ; This will ensure they are muted while we are pausing.
0001B97E                            ; ---------------------------------------------------------------------------
0001B97E                            
0001B97E 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0001B980 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B982 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0001B984                            
0001B984                            .muteFM
0001B984 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B988 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001B98C 5200                       		addq.b	#1,d0			; go to next FM channel
0001B98E 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0001B992                            ; ---------------------------------------------------------------------------
0001B992                            ; The following code will key off all FM channels. There is a special
0001B992                            ; behavior in that, we must write all channels into part 1, and we
0001B992                            ; control the channel we are writing in the data portion.
0001B992                            ; 4 bits are reserved for which operators are active (in this case,
0001B992                            ; none), and 3 bits are reserved for the channel we want to affect.
0001B992                            ; ---------------------------------------------------------------------------
0001B992                            
0001B992 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001B994 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001B996                            
0001B996                            .note
0001B996 1203                       		move.b	d3,d1			; copy value into d1
0001B998 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B99C 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001B99E 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001B9A2 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0001B9A6                            
0001B9A6 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0001B9AA                            	; continue to mute all DAC channels
0001B9AA                            ; ===========================================================================
0001B9AA                            ; ---------------------------------------------------------------------------
0001B9AA                            ; Routine for muting all DAC channels
0001B9AA                            ; ---------------------------------------------------------------------------
0001B9AA                            
0001B9AA                            dMuteDAC:
0001B9AA                            	StopZ80					; wait for Z80 to stop
0001B9AA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B9B2                          M 	waitz80stop
0001B9B2 0839 0000 00A1 1100      M .wait_321:	btst	#0,z80_bus_req
0001B9BA 66F6                     M 	bne.s	.wait_321
0001B9BC 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9C0 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0001B9C6                            
0001B9C6                            	rept 12
0001B9C6                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9C6                            	endr
0001B9C6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DE                            
0001B9DE 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B9E6                            
0001B9E6 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9EA 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0001B9F0                            
0001B9F0                            	rept 12
0001B9F0                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9F0                            	endr
0001B9F0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FE 12DA                     M 	move.b	(a2)+,(a1)+
0001BA00 12DA                     M 	move.b	(a2)+,(a1)+
0001BA02 12DA                     M 	move.b	(a2)+,(a1)+
0001BA04 12DA                     M 	move.b	(a2)+,(a1)+
0001BA06 12DA                     M 	move.b	(a2)+,(a1)+
0001BA08                            
0001BA08 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001BA10                            	StartZ80				; enable Z80 execution
0001BA10 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BA18                            
0001BA18                            locret_MuteDAC:
0001BA18 4E75                       		rts
0001BA1A                            ; ===========================================================================
0001BA1A                            ; ---------------------------------------------------------------------------
0001BA1A                            ; Subroutine to play any queued music tracks, sound effects or commands
0001BA1A                            ; ---------------------------------------------------------------------------
0001BA1A                            
0001BA1A                            dPlaySnd:
0001BA1A 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0001BA1E 7E00                       		moveq	#0,d7
0001BA20 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA22 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA24 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA26 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA28 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA2A 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0001BA2C                            
0001BA2C                            .found
0001BA2C 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0001BA30 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0001BA34 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0001BA38 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0001BA3C 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0001BA40                            	; it was music, handle it below
0001BA40                            ; ===========================================================================
0001BA40                            ; ---------------------------------------------------------------------------
0001BA40                            ; Subroutine to play a queued music track
0001BA40                            ; ---------------------------------------------------------------------------
0001BA40                            
0001BA40                            dPlaySnd_Music:
0001BA40 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0001BA44 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0001BA48                            ; ---------------------------------------------------------------------------
0001BA48                            ; To save few cycles, we don't directly substract the music offset from
0001BA48                            ; the ID, and instead offset the table position. In practice this will
0001BA48                            ; have the same effect, but saves us 8 cycles overall.
0001BA48                            ; ---------------------------------------------------------------------------
0001BA48                            
0001BA48 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0001BA4C DE47                       		add.w	d7,d7			; quadruple music ID
0001BA4E DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BA50 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0001BA56 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0001BA5A                            
0001BA5A                            
0001BA5A 264C                       		move.l	a4,a3			; copy pointer to a3
0001BA5C 584C                       		addq.w	#4,a4			; go to DAC1 data section
0001BA5E                            
0001BA5E 7000                       		moveq	#0,d0
0001BA60 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0001BA64 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0001BA68 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0001BA6E 6700                       		beq.s	.tempogot		; if not, use main tempo
0001BA70 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0001BA74                            
0001BA74                            .tempogot
0001BA74 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0001BA78 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0001BA7C 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0001BA82                            ; ---------------------------------------------------------------------------
0001BA82                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0001BA82                            ; disabled. I know, very weird place to put it, but we dont have
0001BA82                            ; much free room in the song header
0001BA82                            ; ---------------------------------------------------------------------------
0001BA82                            
0001BA82 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0001BA84 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0001BA86 0244 007F                  		and.w	#$7F,d4			; keep value in range
0001BA8A 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0001BA90                            
0001BA90                            .noPAL
0001BA90 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0001BA92 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0001BA94 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0001BA96 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0001BA98                            
0001BA98 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0001BA9C 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0001BAA0 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0001BAA2 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0001BAA6                            
0001BAA6                            .loopDAC
0001BAA6 1282                       		move.b	d2,(a1)			; save channel flags
0001BAA8 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BAAC 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BAB0 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BAB4 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAB8 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BABC 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0001BAC0                            
0001BAC0 7000                       		moveq	#0,d0
0001BAC2 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BAC4 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BAC6 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BACA                            
0001BACA 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0001BACE 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0001BAD2 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0001BAD4 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0001BAD8                            
0001BAD8                            .sampmode
0001BAD8 D2C6                       		add.w	d6,a1			; go to the next channel
0001BADA 51CF FFCA                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0001BADE                            
0001BADE 7E00                       		moveq	#0,d7
0001BAE0 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0001BAE2 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0001BAE6 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0001BAE8                            
0001BAE8                            .loopFM
0001BAE8 1282                       		move.b	d2,(a1)			; save channel flags
0001BAEA 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BAEE 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BAF2 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BAF6 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAFA 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BAFE                            
0001BAFE 7000                       		moveq	#0,d0
0001BB00 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BB02 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BB04 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BB08                            
0001BB08 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BB0C D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB0E 51CF FFD8                  		dbf	d7,.loopFM		; repeat for all FM channels
0001BB12                            
0001BB12                            .doPSG
0001BB12 7E00                       		moveq	#0,d7
0001BB14 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0001BB18 6B00                       		bmi.s	.intSFX			; if no PSG channels are loaded, branch
0001BB1A                            ; ---------------------------------------------------------------------------
0001BB1A                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BB1A                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BB1A                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BB1A                            ; is controlled by the 68000, we would be off by a single frame without
0001BB1A                            ; this fix.
0001BB1A                            ; ---------------------------------------------------------------------------
0001BB1A                            
0001BB1A 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0001BB1C 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0001BB20 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0001BB24                            
0001BB24                            .loopPSG
0001BB24 1282                       		move.b	d2,(a1)			; save channel flags
0001BB26 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BB2A 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BB2E 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BB32 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BB36                            
0001BB36 7000                       		moveq	#0,d0
0001BB38 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BB3A D08B                       		add.l	a3,d0			; add music header offset to d0
0001BB3C 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BB40                            
0001BB40 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BB44 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0001BB48 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0001BB4C D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB4E 51CF FFD4                  		dbf	d7,.loopPSG		; repeat for all FM channels
0001BB52                            
0001BB52                            .intSFX
0001BB52                            ; ---------------------------------------------------------------------------
0001BB52                            ; Now follows initializing FM6 to be ready for PCM streaming,
0001BB52                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0001BB52                            ; clears some YM registers.
0001BB52                            ; ---------------------------------------------------------------------------
0001BB52                            
0001BB52 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BB54 7206                       		moveq	#6,d1			; FM6, all operators off
0001BB56 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BB5A                            
0001BB5A 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BB5C 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0001BB5E 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB62 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0001BB64 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB68 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0001BB6A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB6E 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0001BB70 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB74                            
0001BB74 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BB76 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001BB78 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB7C                            
0001BB7C 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0001BB80 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0001BB84                            ; ---------------------------------------------------------------------------
0001BB84                            ; This piece of code here handles SFX overriding our newly loaded
0001BB84                            ; music channels. Since we did not do this at the initialization
0001BB84                            ; step, we will handle it here instead.
0001BB84                            ; ---------------------------------------------------------------------------
0001BB84                            
0001BB84 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0001BB88 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0001BB8C 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0001BB8E 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BB90                            
0001BB90                            .loopSFX
0001BB90 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0001BB92 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0001BB94                            
0001BB94 7000                       		moveq	#0,d0
0001BB96 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0001BB9A 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0001BB9C                            
0001BB9C 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0001BBA0 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0001BBA2 D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0001BBA4 6000                       		bra.s	.override
0001BBA6                            ; ---------------------------------------------------------------------------
0001BBA6                            
0001BBA6                            .SFXPSG
0001BBA6 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0001BBA8                            .override
0001BBA8 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0001BBAC 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0001BBB0                            
0001BBB0                            .nextSFX
0001BBB0 D2C6                       		adda.w	d6,a1			; go to the next channel
0001BBB2 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0001BBB6                            ; ---------------------------------------------------------------------------
0001BBB6                            ; Here we mute all non-interrupted FM and PSG channels
0001BBB6                            ; ---------------------------------------------------------------------------
0001BBB6                            
0001BBB6 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001BBBA 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0001BBBC                            .stopFM
0001BBBC 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0001BBC0 DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBC2 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0001BBC6                            
0001BBC6 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0001BBC8                            .mutePSG
0001BBC8 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0001BBCC DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBCE 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0001BBD2 4E75                       		rts
0001BBD4                            
0001BBD4                            ; ===========================================================================
0001BBD4                            ; ---------------------------------------------------------------------------
0001BBD4                            ; Type values for different channels. Used for playing music
0001BBD4                            ; ---------------------------------------------------------------------------
0001BBD4 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0001BBD6 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0001BBDB 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0001BBDE                            		even
0001BBDE                            ; ===========================================================================
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            ; Subroutine to play a queued sound effect
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            
0001BBDE                            dPlaySnd_SFX:
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            ; This is a little special case with Sonic 1 - 3K, where the ring
0001BBDE                            ; sound effect would change panning each time it is played. AMPS
0001BBDE                            ; emulates this behavior like the original drivers did, by
0001BBDE                            ; playing a different sound effect ID.
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            
0001BBDE                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0001BBDE                            		;bne.s	.noring			; if not, skip
0001BBDE                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0001BBDE                            		;beq.s	.noring			; if was not, do not change sound effect
0001BBDE                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            ; To save few cycles, we don't directly substract the SFX offset from
0001BBDE                            ; the ID, and instead offset the table position. In practice this will
0001BBDE                            ; have the same effect, but saves us 8 cycles overall.
0001BBDE                            ; ---------------------------------------------------------------------------
0001BBDE                            
0001BBDE                            .noring
0001BBDE 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0001BBE2 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0001BBE4 DE47                       		add.w	d7,d7			; quadruple sfx ID
0001BBE6 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BBE8 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0001BBEC                            
0001BBEC                            ; ---------------------------------------------------------------------------
0001BBEC                            ; Continous SFX is a very special type of sound effect. Unlike other
0001BBEC                            ; sound effects, when a continous SFX is played, it will run a loop
0001BBEC                            ; again, until it is no longer queued. This is very useful for sound
0001BBEC                            ; effects that need to be queued very often, but that really do not
0001BBEC                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0001BBEC                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0001BBEC                            ; but the code was not quite as matured as this here. Only one continous
0001BBEC                            ; SFX may be running at once, when other type is loaded, the earlier one
0001BBEC                            ; is stopped and replaced.
0001BBEC                            ; ---------------------------------------------------------------------------
0001BBEC                            
0001BBEC 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0001BBF0 6A00                       		bpl.s	.nocont			; if not, skip
0001BBF2 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0001BBF8 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0001BBFC 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0001BBFE 4E75                       		rts
0001BC00                            
0001BC00                            .setcont
0001BC00 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0001BC04                            .nocont
0001BC04 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0001BC06                            
0001BC06 7E00                       		moveq	#0,d7
0001BC08 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0001BC0C 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0001BC10 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0001BC12 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0001BC14 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BC16                            ; ---------------------------------------------------------------------------
0001BC16                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BC16                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BC16                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BC16                            ; is controlled by the 68000, we would be off by a single frame without
0001BC16                            ; this fix.
0001BC16                            ; ---------------------------------------------------------------------------
0001BC16                            
0001BC16                            .loopSFX
0001BC16 7600                       		moveq	#0,d3
0001BC18 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0001BC1A 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0001BC1E 1803                       		move.b	d3,d4			; copy type to d4
0001BC20 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0001BC22                            
0001BC22 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001BC26 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001BC28 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001BC2A                            
0001BC2A 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC2E BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC32 6500                       		blo.s	.skip			; if not, we can not override it
0001BC34                            
0001BC34 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC38 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC3C 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0001BC3E 6000                       		bra.s	.clearCh
0001BC40                            ; ---------------------------------------------------------------------------
0001BC40                            
0001BC40                            .skip
0001BC40 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0001BC42 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BC46 4E75                       		rts
0001BC48                            ; ---------------------------------------------------------------------------
0001BC48                            
0001BC48                            .chPSG
0001BC48 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0001BC4A 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC4E BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC52 65EC                       		blo.s	.skip			; if not, we can not override it
0001BC54                            
0001BC54 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC58 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC5C 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0001BC60 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0001BC66                            
0001BC66 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0001BC6A 6600                       		bne.s	.clearCh		; if not, skip
0001BC6C 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0001BC74                            
0001BC74                            .clearCh
0001BC74 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0001BC76 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0001BC78                            .clear
0001BC78 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0001BC7A 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0001BC7E                            
0001BC7E                            
0001BC7E 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0001BC80 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0001BC84 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0001BC88                            
0001BC88 7000                       		moveq	#0,d0
0001BC8A 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0001BC8C D08C                       		add.l	a4,d0			; add music header offset to d0
0001BC8E 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0001BC92                            
0001BC92 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0001BC96 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0001BC98 6B00                       		bmi.s	.loop			; if is, skip over this
0001BC9A                            
0001BC9A 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BC9C 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0001BCA0 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BCA2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0001BCA6                            
0001BCA6 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0001BCAA 6600                       		bne.s	.fm			; if not, branch
0001BCAC 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0001BCB2                            
0001BCB2                            .loop
0001BCB2 51CF FF62                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BCB6 4E75                       		rts
0001BCB8                            ; ---------------------------------------------------------------------------
0001BCB8                            ; The instant release for FM channels behavior was not in the Sonic 1
0001BCB8                            ; SMPS driver by default, but it has been added since it fixes an
0001BCB8                            ; issue with YM2612, where sometimes subsequent sound effect activations
0001BCB8                            ; would sound different over time. This fix will help to mitigate that.
0001BCB8                            ; ---------------------------------------------------------------------------
0001BCB8                            
0001BCB8                            .fm
0001BCB8 720F                       		moveq	#$F,d1			; set to release note instantly
0001BCBA 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0001BCBC 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCC0 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0001BCC2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCC6 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0001BCC8 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCCC 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0001BCCE 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCD2                            
0001BCD2 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BCD4 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0001BCD8 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0001BCDC                            
0001BCDC 51CF FF38                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BCE0 4E75                       		rts
0001BCE2                            ; ===========================================================================
0001BCE2                            ; ---------------------------------------------------------------------------
0001BCE2                            ; pointers for music channels SFX can override and addresses of SFX channels
0001BCE2                            ; ---------------------------------------------------------------------------
0001BCE2                            
0001BCE2 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0001BCE4 C67C                       		dc.w mSFXDAC1			; DAC1
0001BCE6 C6B4                       		dc.w mSFXFM4			; FM4
0001BCE8 C6D0                       		dc.w mSFXFM5			; FM5
0001BCEA C6EC                       		dc.w mSFXPSG1			; PSG1
0001BCEC C708                       		dc.w mSFXPSG2			; PSG2
0001BCEE C724                       		dc.w mSFXPSG3			; PSG3
0001BCF0 C724                       		dc.w mSFXPSG3			; PSG4
0001BCF2                            
0001BCF2 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0001BCF4 C4C4                       		dc.w mDAC1			; SFX DAC1
0001BCF6 C5A0                       		dc.w mFM4			; SFX FM4
0001BCF8 C5CC                       		dc.w mFM5			; SFX FM5
0001BCFA C5F8                       		dc.w mPSG1			; SFX PSG1
0001BCFC C624                       		dc.w mPSG2			; SFX PSG2
0001BCFE C650                       		dc.w mPSG3			; SFX PSG3
0001BD00 C650                       		dc.w mPSG3			; SFX PSG4
0001BD02                            ; ===========================================================================
0001BD02                            ; ---------------------------------------------------------------------------
0001BD02                            ; Play queued command
0001BD02                            ; ---------------------------------------------------------------------------
0001BD02                            
0001BD02                            dPlaySnd_Comm:
0001BD02                            
0001BD02 DE47                       		add.w	d7,d7			; quadruple ID
0001BD04 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0001BD06 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0001BD0A                            
0001BD0A                            ; ---------------------------------------------------------------------------
0001BD0A                            dSoundCommands:
0001BD0A 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0001BD0E 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0001BD12 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0001BD16 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0001BD1A 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0001BD1E 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0001BD22 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0001BD26 6000 FC4E                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0001BD2A 6000 FBEA                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0001BD2E                            dSoundCommands_End:
0001BD2E                            ; ===========================================================================
0001BD2E                            ; ---------------------------------------------------------------------------
0001BD2E                            ; Commands for what to do after a volume fade
0001BD2E                            ; ---------------------------------------------------------------------------
0001BD2E                            
0001BD2E                            dFadeCommands:
0001BD2E 4E75                       		rts				; 80 - Do nothing
0001BD30 4E75                       		rts
0001BD32 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0001BD34 4E75                       		rts
0001BD36 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0001BD3A 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0001BD3C 60F4                       		bra.s	.stop
0001BD3E                            ; ===========================================================================
0001BD3E                            ; ---------------------------------------------------------------------------
0001BD3E                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0001BD3E                            ; ---------------------------------------------------------------------------
0001BD3E                            
0001BD3E                            dPlaySnd_Stop:
0001BD3E                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0001BD3E                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0001BD3E                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD3E                            
0001BD3E 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0001BD40 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0001BD42 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD46                            
0001BD46 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0001BD4A                            
0001BD4A                            	rept (mSize-mSFXDAC1)/4
0001BD4A                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0001BD4A                            	endr
0001BD4A 4299                     M 	clr.l	(a1)+
0001BD4C 4299                     M 	clr.l	(a1)+
0001BD4E 4299                     M 	clr.l	(a1)+
0001BD50 4299                     M 	clr.l	(a1)+
0001BD52 4299                     M 	clr.l	(a1)+
0001BD54 4299                     M 	clr.l	(a1)+
0001BD56 4299                     M 	clr.l	(a1)+
0001BD58 4299                     M 	clr.l	(a1)+
0001BD5A 4299                     M 	clr.l	(a1)+
0001BD5C 4299                     M 	clr.l	(a1)+
0001BD5E 4299                     M 	clr.l	(a1)+
0001BD60 4299                     M 	clr.l	(a1)+
0001BD62 4299                     M 	clr.l	(a1)+
0001BD64 4299                     M 	clr.l	(a1)+
0001BD66 4299                     M 	clr.l	(a1)+
0001BD68 4299                     M 	clr.l	(a1)+
0001BD6A 4299                     M 	clr.l	(a1)+
0001BD6C 4299                     M 	clr.l	(a1)+
0001BD6E 4299                     M 	clr.l	(a1)+
0001BD70 4299                     M 	clr.l	(a1)+
0001BD72 4299                     M 	clr.l	(a1)+
0001BD74 4299                     M 	clr.l	(a1)+
0001BD76 4299                     M 	clr.l	(a1)+
0001BD78 4299                     M 	clr.l	(a1)+
0001BD7A 4299                     M 	clr.l	(a1)+
0001BD7C 4299                     M 	clr.l	(a1)+
0001BD7E 4299                     M 	clr.l	(a1)+
0001BD80 4299                     M 	clr.l	(a1)+
0001BD82 4299                     M 	clr.l	(a1)+
0001BD84 4299                     M 	clr.l	(a1)+
0001BD86 4299                     M 	clr.l	(a1)+
0001BD88 4299                     M 	clr.l	(a1)+
0001BD8A 4299                     M 	clr.l	(a1)+
0001BD8C 4299                     M 	clr.l	(a1)+
0001BD8E 4299                     M 	clr.l	(a1)+
0001BD90 4299                     M 	clr.l	(a1)+
0001BD92 4299                     M 	clr.l	(a1)+
0001BD94 4299                     M 	clr.l	(a1)+
0001BD96 4299                     M 	clr.l	(a1)+
0001BD98 4299                     M 	clr.l	(a1)+
0001BD9A 4299                     M 	clr.l	(a1)+
0001BD9C 4299                     M 	clr.l	(a1)+
0001BD9E 4299                     M 	clr.l	(a1)+
0001BDA0 4299                     M 	clr.l	(a1)+
0001BDA2 4299                     M 	clr.l	(a1)+
0001BDA4 4299                     M 	clr.l	(a1)+
0001BDA6 4299                     M 	clr.l	(a1)+
0001BDA8 4299                     M 	clr.l	(a1)+
0001BDAA 4299                     M 	clr.l	(a1)+
0001BDAC                            
0001BDAC                            	; continue straight to stopping music
0001BDAC                            ; ===========================================================================
0001BDAC                            ; ---------------------------------------------------------------------------
0001BDAC                            ; Stop music from playing, reset driver memory and mute hardware
0001BDAC                            ; ---------------------------------------------------------------------------
0001BDAC                            
0001BDAC                            dStopMusic:
0001BDAC 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0001BDB0 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0001BDB2 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0001BDB6 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0001BDBA 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0001BDC0                            
0001BDC0                            	rept (mSFXDAC1-mFlags)/4
0001BDC0                            		clr.l	(a1)+			; clear driver and music channel memory
0001BDC0                            	endr
0001BDC0 4299                     M 	clr.l	(a1)+
0001BDC2 4299                     M 	clr.l	(a1)+
0001BDC4 4299                     M 	clr.l	(a1)+
0001BDC6 4299                     M 	clr.l	(a1)+
0001BDC8 4299                     M 	clr.l	(a1)+
0001BDCA 4299                     M 	clr.l	(a1)+
0001BDCC 4299                     M 	clr.l	(a1)+
0001BDCE 4299                     M 	clr.l	(a1)+
0001BDD0 4299                     M 	clr.l	(a1)+
0001BDD2 4299                     M 	clr.l	(a1)+
0001BDD4 4299                     M 	clr.l	(a1)+
0001BDD6 4299                     M 	clr.l	(a1)+
0001BDD8 4299                     M 	clr.l	(a1)+
0001BDDA 4299                     M 	clr.l	(a1)+
0001BDDC 4299                     M 	clr.l	(a1)+
0001BDDE 4299                     M 	clr.l	(a1)+
0001BDE0 4299                     M 	clr.l	(a1)+
0001BDE2 4299                     M 	clr.l	(a1)+
0001BDE4 4299                     M 	clr.l	(a1)+
0001BDE6 4299                     M 	clr.l	(a1)+
0001BDE8 4299                     M 	clr.l	(a1)+
0001BDEA 4299                     M 	clr.l	(a1)+
0001BDEC 4299                     M 	clr.l	(a1)+
0001BDEE 4299                     M 	clr.l	(a1)+
0001BDF0 4299                     M 	clr.l	(a1)+
0001BDF2 4299                     M 	clr.l	(a1)+
0001BDF4 4299                     M 	clr.l	(a1)+
0001BDF6 4299                     M 	clr.l	(a1)+
0001BDF8 4299                     M 	clr.l	(a1)+
0001BDFA 4299                     M 	clr.l	(a1)+
0001BDFC 4299                     M 	clr.l	(a1)+
0001BDFE 4299                     M 	clr.l	(a1)+
0001BE00 4299                     M 	clr.l	(a1)+
0001BE02 4299                     M 	clr.l	(a1)+
0001BE04 4299                     M 	clr.l	(a1)+
0001BE06 4299                     M 	clr.l	(a1)+
0001BE08 4299                     M 	clr.l	(a1)+
0001BE0A 4299                     M 	clr.l	(a1)+
0001BE0C 4299                     M 	clr.l	(a1)+
0001BE0E 4299                     M 	clr.l	(a1)+
0001BE10 4299                     M 	clr.l	(a1)+
0001BE12 4299                     M 	clr.l	(a1)+
0001BE14 4299                     M 	clr.l	(a1)+
0001BE16 4299                     M 	clr.l	(a1)+
0001BE18 4299                     M 	clr.l	(a1)+
0001BE1A 4299                     M 	clr.l	(a1)+
0001BE1C 4299                     M 	clr.l	(a1)+
0001BE1E 4299                     M 	clr.l	(a1)+
0001BE20 4299                     M 	clr.l	(a1)+
0001BE22 4299                     M 	clr.l	(a1)+
0001BE24 4299                     M 	clr.l	(a1)+
0001BE26 4299                     M 	clr.l	(a1)+
0001BE28 4299                     M 	clr.l	(a1)+
0001BE2A 4299                     M 	clr.l	(a1)+
0001BE2C 4299                     M 	clr.l	(a1)+
0001BE2E 4299                     M 	clr.l	(a1)+
0001BE30 4299                     M 	clr.l	(a1)+
0001BE32 4299                     M 	clr.l	(a1)+
0001BE34 4299                     M 	clr.l	(a1)+
0001BE36 4299                     M 	clr.l	(a1)+
0001BE38 4299                     M 	clr.l	(a1)+
0001BE3A 4299                     M 	clr.l	(a1)+
0001BE3C 4299                     M 	clr.l	(a1)+
0001BE3E 4299                     M 	clr.l	(a1)+
0001BE40 4299                     M 	clr.l	(a1)+
0001BE42 4299                     M 	clr.l	(a1)+
0001BE44 4299                     M 	clr.l	(a1)+
0001BE46 4299                     M 	clr.l	(a1)+
0001BE48 4299                     M 	clr.l	(a1)+
0001BE4A 4299                     M 	clr.l	(a1)+
0001BE4C 4299                     M 	clr.l	(a1)+
0001BE4E 4299                     M 	clr.l	(a1)+
0001BE50 4299                     M 	clr.l	(a1)+
0001BE52 4299                     M 	clr.l	(a1)+
0001BE54 4299                     M 	clr.l	(a1)+
0001BE56 4299                     M 	clr.l	(a1)+
0001BE58 4299                     M 	clr.l	(a1)+
0001BE5A 4299                     M 	clr.l	(a1)+
0001BE5C 4299                     M 	clr.l	(a1)+
0001BE5E 4299                     M 	clr.l	(a1)+
0001BE60 4299                     M 	clr.l	(a1)+
0001BE62 4299                     M 	clr.l	(a1)+
0001BE64 4299                     M 	clr.l	(a1)+
0001BE66 4299                     M 	clr.l	(a1)+
0001BE68 4299                     M 	clr.l	(a1)+
0001BE6A 4299                     M 	clr.l	(a1)+
0001BE6C 4299                     M 	clr.l	(a1)+
0001BE6E 4299                     M 	clr.l	(a1)+
0001BE70 4299                     M 	clr.l	(a1)+
0001BE72 4299                     M 	clr.l	(a1)+
0001BE74 4299                     M 	clr.l	(a1)+
0001BE76 4299                     M 	clr.l	(a1)+
0001BE78 4299                     M 	clr.l	(a1)+
0001BE7A 4299                     M 	clr.l	(a1)+
0001BE7C 4299                     M 	clr.l	(a1)+
0001BE7E 4299                     M 	clr.l	(a1)+
0001BE80 4299                     M 	clr.l	(a1)+
0001BE82 4299                     M 	clr.l	(a1)+
0001BE84 4299                     M 	clr.l	(a1)+
0001BE86 4299                     M 	clr.l	(a1)+
0001BE88 4299                     M 	clr.l	(a1)+
0001BE8A 4299                     M 	clr.l	(a1)+
0001BE8C 4299                     M 	clr.l	(a1)+
0001BE8E 4299                     M 	clr.l	(a1)+
0001BE90 4299                     M 	clr.l	(a1)+
0001BE92 4299                     M 	clr.l	(a1)+
0001BE94 4299                     M 	clr.l	(a1)+
0001BE96 4299                     M 	clr.l	(a1)+
0001BE98 4299                     M 	clr.l	(a1)+
0001BE9A 4299                     M 	clr.l	(a1)+
0001BE9C 4299                     M 	clr.l	(a1)+
0001BE9E 4299                     M 	clr.l	(a1)+
0001BEA0 4299                     M 	clr.l	(a1)+
0001BEA2 4299                     M 	clr.l	(a1)+
0001BEA4 4299                     M 	clr.l	(a1)+
0001BEA6 4299                     M 	clr.l	(a1)+
0001BEA8 4299                     M 	clr.l	(a1)+
0001BEAA                            
0001BEAA 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0001BEAC                            
0001BEAC 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0001BEB0 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0001BEB4 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0001BEB8 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0001BEBE                            
0001BEBE 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0001BEC0 4EBA FAE8                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0001BEC4                            	; continue straight to hardware muting FM
0001BEC4                            ; ===========================================================================
0001BEC4                            ; ---------------------------------------------------------------------------
0001BEC4                            ; Mute all FM channels
0001BEC4                            ; ---------------------------------------------------------------------------
0001BEC4                            
0001BEC4                            dMuteFM:
0001BEC4 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BEC6 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001BEC8                            
0001BEC8                            .noteoff
0001BEC8 1203                       		move.b	d3,d1			; copy value into d1
0001BECA 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BECE 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001BED0 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BED4 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0001BED8                            
0001BED8 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0001BEDA 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BEDC 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0001BEDE                            
0001BEDE                            .chloop
0001BEDE 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0001BEE0 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0001BEE2                            
0001BEE2                            .oploop
0001BEE2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BEE6 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BEEA 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0001BEEC 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0001BEF0                            
0001BEF0 9005                       		sub.b	d5,d0			; go to next FM channel
0001BEF2 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0001BEF6 4E75                       		rts
0001BEF8                            ; ===========================================================================
0001BEF8                            ; ---------------------------------------------------------------------------
0001BEF8                            ; Routine for muting all PSG channels
0001BEF8                            ; ---------------------------------------------------------------------------
0001BEF8                            
0001BEF8                            dMutePSG:
0001BEF8 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0001BEFE 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0001BF02 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0001BF06 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0001BF0A 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0001BF0E 4E75                       		rts
0001BF10                            ; ===========================================================================
0001BF10                            ; ---------------------------------------------------------------------------
0001BF10                            ; Normal fade out data
0001BF10                            ; ---------------------------------------------------------------------------
0001BF10                            
0001BF10                            dFadeOutDataLog:
0001BF10 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0001BF1C 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0001BF28 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0001BF34 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0001BF40 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0001BF4C 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0001BF58 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0001BF64 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0001BF70 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0001BF7A                            
0001BF7A                            ;dFadeOutDataLinear:
0001BF7A                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0001BF7A                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0001BF7A                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0001BF7A                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0001BF7A                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0001BF7A                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0001BF7A                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0001BF7A                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0001BF7A                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0001BF7A                            	even
0001BF7A                            ; ===========================================================================
0001BF7A                            ; ---------------------------------------------------------------------------
0001BF7A                            ; Subroutine for initializing a fade effect.
0001BF7A                            ; Since the driver allows for such an extensive and customizable
0001BF7A                            ; fading code, we may hit a snag if we use fades too fast. It is
0001BF7A                            ; possible, for example, to fade out, then in the middle of that,
0001BF7A                            ; start fading in. This would normally cause a quick jump in the
0001BF7A                            ; volume level from maybe half to completely mute. This routine
0001BF7A                            ; aims to combat this by actually searching for the closest FM
0001BF7A                            ; volume level in the fade program, and to start the new fade from
0001BF7A                            ; where that byte appears. This can alter how long a volume fade
0001BF7A                            ; lasts however, and if PSG and DAC volume are not correct faded,
0001BF7A                            ; it may still cause a jump in their volume (especially if only,
0001BF7A                            ; say, DAC fades volume). In the future, there might be a fix for
0001BF7A                            ; that.
0001BF7A                            ; ---------------------------------------------------------------------------
0001BF7A                            
0001BF7A                            dPlaySnd_FadeOut:
0001BF7A 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0001BF7E                            
0001BF7E                            dLoadFade:
0001BF7E 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0001BF82 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001BF86 6700                       		beq.s	.nofade			; if not, load fade as is
0001BF88                            
0001BF88 2449                       		move.l	a1,a2			; copy fade program address to a2
0001BF8A 74FF                       		moveq	#-1,d2			; prepare max byter difference
0001BF8C                            
0001BF8C                            .find
0001BF8C 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0001BF8E 6A00                       		bpl.s	.search			; branch if this is not a command
0001BF90                            
0001BF90                            .nofade
0001BF90 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0001BF94 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0001BF98 4E75                       		rts
0001BF9A                            
0001BF9A                            .search
0001BF9A 568A                       		addq.l	#3,a2			; skip over the current volume group
0001BF9C 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0001BF9E 6A00                       		bpl.s	.abs			; if positive, do not negate
0001BFA0 4401                       		neg.b	d1			; negative to positive
0001BFA2                            
0001BFA2                            .abs
0001BFA2 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0001BFA4 64E6                       		bhs.s	.find			; if not, read next group
0001BFA6                            
0001BFA6 1401                       		move.b	d1,d2			; else save the new difference
0001BFA8 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0001BFAA 60E0                       		bra.s	.find			; loop through each group in the program
0001BFAC                            ; ===========================================================================
0001BFAC                            ; ---------------------------------------------------------------------------
0001BFAC                            ; Routine for loading a volume filter into Dual PCM ROM.
0001BFAC                            ; This routine will actually write the bank number the volume filter
0001BFAC                            ; is in. This requires volume filters are aligned to Z80 banks, and
0001BFAC                            ; just because we can, we write 9 bits (yeah its not necessary, but
0001BFAC                            ; what the hell, you have to have fun sometimes!)
0001BFAC                            ; ---------------------------------------------------------------------------
0001BFAC                            
0001BFAC                            dSetFilter:
0001BFAC 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0001BFB2 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0001BFB4 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0001BFB6                            	StopZ80					; wait for Z80 to stop
0001BFB6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001BFBE                          M 	waitz80stop
0001BFBE 0839 0000 00A1 1100      M .wait_324:	btst	#0,z80_bus_req
0001BFC6 66F6                     M 	bne.s	.wait_324
0001BFC8                            ; ---------------------------------------------------------------------------
0001BFC8                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0001BFC8                            ; a register AND the carry to another register. What this means, is if
0001BFC8                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0001BFC8                            ; of $74 into the carry, making us able to switch between the Z80
0001BFC8                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0001BFC8                            ; Dual PCM to bank switch into the appropriate bank.
0001BFC8                            ; ---------------------------------------------------------------------------
0001BFC8                            
0001BFC8                            .loop
0001BFC8 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0001BFCA E248                       		lsr.w	#1,d0			; shift lsb into carry
0001BFCC D701                       		addx.b	d1,d3			; add instruction and carry into d3
0001BFCE                            
0001BFCE 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0001BFD0 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0001BFD4                            	StartZ80				; enable Z80 execution
0001BFD4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BFDC 4E75                       		rts
0001BFDE                            
0001BFDE                            ; ===========================================================================
0001BFDE                            ; ---------------------------------------------------------------------------
0001BFDE                            ; Routine for resetting master volumes, filters and disabling fading
0001BFDE                            ; ---------------------------------------------------------------------------
0001BFDE                            
0001BFDE                            dResetVolume:
0001BFDE 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0001BFE2 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0001BFE6 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0001BFEA 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0001BFEE 61BC                       		bsr.s	dSetFilter		; load filter instructions
0001BFF0                            
0001BFF0                            dUpdateVolumeAll:
0001BFF0 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0001BFF2 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0001BFF6                            
0001BFF6 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001BFF6                            	rept Mus_DAC				; loop through all music DAC channels
0001BFF6                            		or.b	d0,.ch.w		; request channel volume update
0001BFF6                            .ch =		.ch+cSize			; go to next channel
0001BFF6                            	endr
0001BFF6 8138 C4C4                M 	or.b	d0,.ch.w
0001BFFA =FFFFC4F0                M .ch	=	.ch+csize
0001BFFA 8138 C4F0                M 	or.b	d0,.ch.w
0001BFFE =FFFFC51C                M .ch	=	.ch+csize
0001BFFE                            
0001BFFE =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001BFFE                            	rept Mus_PSG				; loop through all music PSG channels
0001BFFE                            		or.b	d0,.ch.w		; request channel volume update
0001BFFE                            .ch =		.ch+cSize			; go to next channel
0001BFFE                            	endr
0001BFFE 8138 C5F8                M 	or.b	d0,.ch.w
0001C002 =FFFFC624                M .ch	=	.ch+csize
0001C002 8138 C624                M 	or.b	d0,.ch.w
0001C006 =FFFFC650                M .ch	=	.ch+csize
0001C006 8138 C650                M 	or.b	d0,.ch.w
0001C00A =FFFFC67C                M .ch	=	.ch+csize
0001C00A                            
0001C00A =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001C00A                            	rept SFX_PSG				; loop through all SFX PSG channels
0001C00A                            		or.b	d0,.ch.w		; request channel volume update
0001C00A                            .ch =		.ch+cSizeSFX			; go to next channel
0001C00A                            	endr
0001C00A 8138 C6EC                M 	or.b	d0,.ch.w
0001C00E =FFFFC708                M .ch	=	.ch+csizesfx
0001C00E 8138 C708                M 	or.b	d0,.ch.w
0001C012 =FFFFC724                M .ch	=	.ch+csizesfx
0001C012 8138 C724                M 	or.b	d0,.ch.w
0001C016 =FFFFC740                M .ch	=	.ch+csizesfx
0001C016 4E75                       		rts
0001C018                            ; ===========================================================================
0001C018                            ; ---------------------------------------------------------------------------
0001C018                            ; Enable speed shoes mode
0001C018                            ; ---------------------------------------------------------------------------
0001C018                            
0001C018                            dPlaySnd_ShoesOn:
0001C018 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0001C01E 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0001C024 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0001C02A 4E75                       		rts
0001C02C                            ; ===========================================================================
0001C02C                            ; ---------------------------------------------------------------------------
0001C02C                            ; Reset music flags (underwater mode and tempo mode)
0001C02C                            ; ---------------------------------------------------------------------------
0001C02C                            
0001C02C                            dPlaySnd_Reset:
0001C02C 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0001C02E                            ; ===========================================================================
0001C02E                            ; ---------------------------------------------------------------------------
0001C02E                            ; Disable speed shoes mode
0001C02E                            ; ---------------------------------------------------------------------------
0001C02E                            
0001C02E                            dPlaySnd_ShoesOff:
0001C02E 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0001C034 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0001C03A 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0001C040 4E75                       		rts
0001C042                            ; ===========================================================================
0001C042                            ; ---------------------------------------------------------------------------
0001C042                            ; Enable Underwater mode
0001C042                            ; ---------------------------------------------------------------------------
0001C042                            
0001C042                            dPlaySnd_ToWater:
0001C042 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0001C048 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0001C04A                            ; ===========================================================================
0001C04A                            ; ---------------------------------------------------------------------------
0001C04A                            ; Disable Underwater mode
0001C04A                            ; ---------------------------------------------------------------------------
0001C04A                            
0001C04A                            dPlaySnd_OutWater:
0001C04A 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0001C050                            ; ===========================================================================
0001C050                            ; ---------------------------------------------------------------------------
0001C050                            ; force volume update on all FM channels
0001C050                            ; ---------------------------------------------------------------------------
0001C050                            
0001C050                            dReqVolUpFM;
0001C050 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0001C052 =FFFFC51C                  .ch =	mFM1					; start at FM1
0001C052                            	rept Mus_FM				; loop through all music FM channels
0001C052                            		or.b	d0,.ch.w		; request channel volume update
0001C052                            .ch =		.ch+cSize			; go to next channel
0001C052                            	endr
0001C052 8138 C51C                M 	or.b	d0,.ch.w
0001C056 =FFFFC548                M .ch	=	.ch+csize
0001C056 8138 C548                M 	or.b	d0,.ch.w
0001C05A =FFFFC574                M .ch	=	.ch+csize
0001C05A 8138 C574                M 	or.b	d0,.ch.w
0001C05E =FFFFC5A0                M .ch	=	.ch+csize
0001C05E 8138 C5A0                M 	or.b	d0,.ch.w
0001C062 =FFFFC5CC                M .ch	=	.ch+csize
0001C062 8138 C5CC                M 	or.b	d0,.ch.w
0001C066 =FFFFC5F8                M .ch	=	.ch+csize
0001C066                            
0001C066 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0001C066                            	rept SFX_FM				; loop through all SFX FM channels
0001C066                            		or.b	d0,.ch.w		; request channel volume update
0001C066                            .ch =		.ch+cSizeSFX			; go to next channel
0001C066                            	endr
0001C066 8138 C698                M 	or.b	d0,.ch.w
0001C06A =FFFFC6B4                M .ch	=	.ch+csizesfx
0001C06A 8138 C6B4                M 	or.b	d0,.ch.w
0001C06E =FFFFC6D0                M .ch	=	.ch+csizesfx
0001C06E 8138 C6D0                M 	or.b	d0,.ch.w
0001C072 =FFFFC6EC                M .ch	=	.ch+csizesfx
0001C072 4E75                       		rts
0001C074                            ; ===========================================================================
0001C074                            ; ---------------------------------------------------------------------------
0001C074                            ; Subroutine for updating Total Levels for FM channel
0001C074                            ; ---------------------------------------------------------------------------
0001C074                            
0001C074                            dUpdateVolFM:
0001C074 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C078 6600                       		bne.s	locret_VolFM		; if yes, do not update
0001C07A                            
0001C07A 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001C07E D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001C082 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001C084 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001C086                            
0001C086                            .noover
0001C086 7000                       		moveq	#0,d0
0001C088 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001C08C 224E                       		move.l	a6,a1			; copy music voice table address to a1
0001C08E                            
0001C08E                            	dCALC_VOICE				; get address of the specific voice to a1
0001C08E EB48                     M 	lsl.w	#5,d0
0001C090 D2C0                     M 	add.w	d0,a1
0001C092 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0001C094 7C00                       		moveq	#0,d6			; reset the modulator offset
0001C096                            
0001C096 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001C09C 6700                       		beq.s	.uwdone			; if not, skip
0001C09E 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0001C0A0 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001C0A4 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001C0A6 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0001C0A8                            
0001C0A8                            .uwdone
0001C0A8 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001C0AA D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0001C0AE 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0001C0B2                            
0001C0B2                            .tlloop
0001C0B2 101A                       		move.b	(a2)+,d0		; load YM address to write to
0001C0B4 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001C0B6 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001C0B8                            
0001C0B8 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001C0BA 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001C0BC 727F                       		moveq	#$7F,d1			; cap to silent volume
0001C0BE 6000                       		bra.s	.slot
0001C0C0                            
0001C0C0                            .noslot
0001C0C0 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001C0C2                            .slot
0001C0C2 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0001C0C6                            .ignore
0001C0C6 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001C0CA                            
0001C0CA                            
0001C0CA                            locret_VolFM:
0001C0CA 4E75                       		rts
0001C0CC                            ; ===========================================================================
0001C0CC                            ; ---------------------------------------------------------------------------
0001C0CC                            ; YM2612 register update list
0001C0CC                            ; ---------------------------------------------------------------------------
0001C0CC                            
0001C0CC 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0001C0D0 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0001C0D4 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0001C0D8 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0001C0DC 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0001C0E0 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0001C0E4 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0001C0E8                            ; ===========================================================================
0001C0E8                            ; ---------------------------------------------------------------------------
0001C0E8                            ; Process SFX FM channels
0001C0E8                            ; ---------------------------------------------------------------------------
0001C0E8                            
0001C0E8                            dAMPSdoFMSFX:
0001C0E8 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0001C0EC 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0001C0EE                            
0001C0EE                            dAMPSnextFMSFX:
0001C0EE DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C0F2 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C0F4 6A00 0000                  		bpl.w	.next			; if not, branch
0001C0F8 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C0FC 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C100                            
0001C100                            	dCalcFreq				; calculate channel base frequency
0001C100 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C104 4886                     M 	ext.w	d6
0001C106 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C10A                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0001C10A 0815 0003                M 	btst	#cfbmod,(a5)
0001C10E 6700                     M 	beq.s	.noret
0001C110 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C114 6700                     M 	beq.s	.started
0001C116 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C11A                          M .noret
0001C11A 0895 0005                M 	bclr	#cfbvol,(a5)
0001C11E 6700                     M 	beq.s	.noupdatevol
0001C120 4EBA FF52                M 	jsr	dupdatevolfm(pc)
0001C124                          M 	.noupdatevol:
0001C124 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0001C128 6000 0000                M 	bra.w	dampsdopsgsfx
0001C12C                          M .started
0001C12C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C130 66E8                     M 	bne.s	.noret
0001C132 226D 0010                M 	movea.l	cmod(a5),a1
0001C136 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C13C 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C140 6600                     M 	bne.s	.norev
0001C142 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C148 442D 0017                M 	neg.b	cmodstep(a5)
0001C14C                          M .norev
0001C14C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C150 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C154 4885                     M 	ext.w	d5
0001C156 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C15A 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C15E DC45                     M 	add.w	d5,d6
0001C160 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0001C164                            
0001C164 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C168 6700                       		beq.s	.next			; if not, skip
0001C16A 4EBA FF08                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C16E                            
0001C16E                            .next
0001C16E 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C172 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C176                            
0001C176                            .update
0001C176 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C17A                            	dDoTracker				; process tracker
0001C17A 286D 0002                M 	movea.l	cdata(a5),a4
0001C17E                          M .data
0001C17E 7A00                     M 	moveq	#0,d5
0001C180 1A1C                     M 	move.b	(a4)+,d5
0001C182 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C186 6500                     M 	blo.s	.notcomm
0001C188 4EBA 0000                M 	jsr	dcommands(pc)
0001C18C 60F0                     M 	bra.s	.data
0001C18E 60DE                     M 	bra.s	.next
0001C190                          M .notcomm
0001C190 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0001C194 4A05                       		tst.b	d5			; check if note is being played
0001C196 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C198                            
0001C198 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C19C 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C19E 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C1A0 534C                       		subq.w	#1,a4			; if not, then return back
0001C1A2 6000                       		bra.s	.pcnote			; do some extra clearing
0001C1A4                            
0001C1A4                            .timer
0001C1A4 4EBA F5EC                  		jsr	dCalcDuration(pc)	; calculate duration
0001C1A8                            .pcnote
0001C1A8                            	dProcNote 1, 0				; reset necessary channel memory
0001C1A8 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C1AC 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C1B2 0815 0002                M 	btst	#cfbhold,(a5)
0001C1B6 6600                     M 	bne.s	.endpn
0001C1B8 0815 0003                M 	btst	#cfbmod,(a5)
0001C1BC 6700                     M 	beq.s	.endpn
0001C1BE 226D 0010                M 	movea.l	cmod(a5),a1
0001C1C2 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C1C6 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C1CA 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C1CE 1011                     M 	move.b	(a1),d0
0001C1D0 E208                     M 	lsr.b	#1,d0
0001C1D2 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C1D6 426D 0014                M 	clr.w	cmodfreq(a5)
0001C1DA                          M .endpn
0001C1DA 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0001C1DE                            	dKeyOnFM 1				; send key-on command to YM
0001C1DE 0815 0002                M 	btst	#cfbhold,(a5)
0001C1E2 6600                     M 	bne.s	.k
0001C1E4 0815 0000                M 	btst	#cfbrest,(a5)
0001C1E8 6600                     M 	bne.s	.k
0001C1EA 7028                     M 	moveq	#$28,d0
0001C1EC 122D 0001                M 	move.b	ctype(a5),d1
0001C1F0 0001 00F0                M 	ori.b	#$f0,d1
0001C1F4 6100 0000                M 	bsr.w	writeym_pt1
0001C1F8                          M .k
0001C1F8                            
0001C1F8 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C1FC 6700                       		beq.s	.noupdate		; if not, branch
0001C1FE 4EBA FE74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C202                            
0001C202 51CF FEEA                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C206 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C20A                            ; ===========================================================================
0001C20A                            ; ---------------------------------------------------------------------------
0001C20A                            ; Process music FM channels
0001C20A                            ; ---------------------------------------------------------------------------
0001C20A                            
0001C20A                            dAMPSdoFM:
0001C20A 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0001C20E 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0001C210                            
0001C210                            dAMPSnextFM:
0001C210 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0001C214 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C216 6A00 0000                  		bpl.w	.next			; if not, branch
0001C21A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C21E 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C222                            
0001C222                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0001C222                          M 	dnotetouthandler
0001C222 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C226 6700                     M 	beq.s	.endt
0001C228 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C22C 6600                     M 	bne.s	.endt
0001C22E 08D5 0000                M 	bset	#cfbrest,(a5)
0001C232 6100 0000                M 	bsr.w	dkeyofffm
0001C236 6000 0000                M 	bra.w	.next
0001C23A                          M .endt
0001C23A                            	dCalcFreq				; calculate channel base frequency
0001C23A 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C23E 4886                     M 	ext.w	d6
0001C240 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C244                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0001C244 0815 0003                M 	btst	#cfbmod,(a5)
0001C248 6700                     M 	beq.s	.noret
0001C24A 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C24E 6700                     M 	beq.s	.started
0001C250 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C254                          M .noret
0001C254 0895 0005                M 	bclr	#cfbvol,(a5)
0001C258 6700                     M 	beq.s	.noupdatevol
0001C25A 4EBA FE18                M 	jsr	dupdatevolfm(pc)
0001C25E                          M 	.noupdatevol:
0001C25E 51CF FFB0                M 	dbf	d7,dampsnextfm
0001C262 6000 0000                M 	bra.w	dampsdopsg
0001C266                          M .started
0001C266 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C26A 66E8                     M 	bne.s	.noret
0001C26C 226D 0010                M 	movea.l	cmod(a5),a1
0001C270 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C276 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C27A 6600                     M 	bne.s	.norev
0001C27C 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C282 442D 0017                M 	neg.b	cmodstep(a5)
0001C286                          M .norev
0001C286 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C28A 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C28E 4885                     M 	ext.w	d5
0001C290 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C294 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C298 DC45                     M 	add.w	d5,d6
0001C29A 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0001C29E                            
0001C29E 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C2A2 6700                       		beq.s	.next			; if not, skip
0001C2A4 4EBA FDCE                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C2A8                            
0001C2A8                            .next
0001C2A8 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C2AC 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C2B0                            
0001C2B0                            .update
0001C2B0 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C2B4                            	dDoTracker				; process tracker
0001C2B4 286D 0002                M 	movea.l	cdata(a5),a4
0001C2B8                          M .data
0001C2B8 7A00                     M 	moveq	#0,d5
0001C2BA 1A1C                     M 	move.b	(a4)+,d5
0001C2BC 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C2C0 6500                     M 	blo.s	.notcomm
0001C2C2 4EBA 0000                M 	jsr	dcommands(pc)
0001C2C6 60F0                     M 	bra.s	.data
0001C2C8 60DE                     M 	bra.s	.next
0001C2CA                          M .notcomm
0001C2CA 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001C2CE 4A05                       		tst.b	d5			; check if note is being played
0001C2D0 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C2D2                            
0001C2D2 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C2D6 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C2D8 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C2DA 534C                       		subq.w	#1,a4			; if not, then return back
0001C2DC 6000                       		bra.s	.pcnote			; do some extra clearing
0001C2DE                            
0001C2DE                            .timer
0001C2DE 4EBA F4B2                  		jsr	dCalcDuration(pc)	; calculate duration
0001C2E2                            .pcnote
0001C2E2                            	dProcNote 0, 0				; reset necessary channel memory
0001C2E2 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C2E6 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C2EC 0815 0002                M 	btst	#cfbhold,(a5)
0001C2F0 6600                     M 	bne.s	.endpn
0001C2F2 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C2F8 0815 0003                M 	btst	#cfbmod,(a5)
0001C2FC 6700                     M 	beq.s	.endpn
0001C2FE 226D 0010                M 	movea.l	cmod(a5),a1
0001C302 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C306 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C30A 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C30E 1011                     M 	move.b	(a1),d0
0001C310 E208                     M 	lsr.b	#1,d0
0001C312 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C316 426D 0014                M 	clr.w	cmodfreq(a5)
0001C31A                          M .endpn
0001C31A 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0001C31C                            	dKeyOnFM				; send key-on command to YM
0001C31C 0815 0002                M 	btst	#cfbhold,(a5)
0001C320 6600                     M 	bne.s	.k
0001C322 0815 0000                M 	btst	#cfbrest,(a5)
0001C326 6600                     M 	bne.s	.k
0001C328 0815 0001                M 	btst	#cfbint,(a5)
0001C32C 6600                     M 	bne.s	.k
0001C32E 7028                     M 	moveq	#$28,d0
0001C330 122D 0001                M 	move.b	ctype(a5),d1
0001C334 0001 00F0                M 	ori.b	#$f0,d1
0001C338 6100 0000                M 	bsr.w	writeym_pt1
0001C33C                          M .k
0001C33C                            
0001C33C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C340 6700                       		beq.s	.noupdate		; if not, branch
0001C342 4EBA FD30                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C346                            
0001C346                            .noupdate
0001C346 51CF FEC8                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C34A 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C34E                            ; ===========================================================================
0001C34E                            ; ---------------------------------------------------------------------------
0001C34E                            ; Write FM frequency to Dual PCM YMCue
0001C34E                            ; ---------------------------------------------------------------------------
0001C34E                            
0001C34E                            dUpdateFreqFM:
0001C34E 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C352 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0001C354 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0001C358 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0001C35A                            
0001C35A 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C35E 4880                       		ext.w	d0			; extend to word
0001C360 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C362                            
0001C362 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C366 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0001C368 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0001C36C                            
0001C36C                            dUpdateFreqFM2:
0001C36C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C370 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0001C372                            
0001C372                            dUpdateFreqFM3:
0001C372 3206                       		move.w	d6,d1			; copy frequency to d1
0001C374 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0001C376 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0001C378 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001C37C                            
0001C37C 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0001C37E 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0001C382 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001C386                            
0001C386                            dUpdFreqFMrest:
0001C386 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C38A                            
0001C38A                            locret_UpdFreqFM:
0001C38A 4E75                       		rts
0001C38C                            ; ===========================================================================
0001C38C                            ; ---------------------------------------------------------------------------
0001C38C                            ; Process a note in FM channel (enable resting or get frequency)
0001C38C                            ; ---------------------------------------------------------------------------
0001C38C                            
0001C38C                            dGetFreqFM:
0001C38C 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001C390 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0001C392 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C396 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0001C39A 4E75                       		rts
0001C39C                            
0001C39C                            .norest
0001C39C DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0001C3A0 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0001C3A4 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0001C3A6                            
0001C3A6 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0001C3AA 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001C3B0                            
0001C3B0 4E75                       		rts
0001C3B2                            ; ===========================================================================
0001C3B2                            ; ---------------------------------------------------------------------------
0001C3B2                            ; Subroutine for doing keying-off FM channel
0001C3B2                            ; ---------------------------------------------------------------------------
0001C3B2                            
0001C3B2                            dKeyOffFM:
0001C3B2 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0001C3B6 66D2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3B8                            
0001C3B8                            dKeyOffFM2:
0001C3B8 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001C3BC 66CC                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3BE                            
0001C3BE 7028                       		moveq	#$28,d0			; YM command: Key on
0001C3C0 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0001C3C4 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0001C3C6                            ; ===========================================================================
0001C3C6                            ; ---------------------------------------------------------------------------
0001C3C6                            ; Write to YMCue according to channel and check if interrupted by sfx
0001C3C6                            ; ---------------------------------------------------------------------------
0001C3C6                            
0001C3C6                            dWriteYMchnInt:
0001C3C6 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0001C3CA 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0001C3CC                            ; ===========================================================================
0001C3CC                            ; ---------------------------------------------------------------------------
0001C3CC                            ; Write to YMCue according to channel
0001C3CC                            ; ---------------------------------------------------------------------------
0001C3CC                            
0001C3CC                            WriteChYM:
0001C3CC 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0001C3D2 6600                       		bne.s	WriteChYM2		; if part 2, branch
0001C3D4 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0001C3D8                            ; ===========================================================================
0001C3D8                            ; ---------------------------------------------------------------------------
0001C3D8                            ; Write to YMCue using part 1
0001C3D8                            ; ---------------------------------------------------------------------------
0001C3D8                            
0001C3D8                            WriteYM_Pt1:
0001C3D8                            	StopZ80					; wait for Z80 to stop
0001C3D8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C3E0                          M 	waitz80stop
0001C3E0 0839 0000 00A1 1100      M .wait_340:	btst	#0,z80_bus_req
0001C3E8 66F6                     M 	bne.s	.wait_340
0001C3EA 51D8                       		sf	(a0)+			; set YM port address as 0
0001C3EC 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C3EE 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C3F0                            	;	st	(a0)			; mark as the end of the cue data
0001C3F0                            	StartZ80				; enable Z80 execution
0001C3F0 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C3F8                            
0001C3F8                            WriteYM_Pt1_rts:
0001C3F8 4E75                       		rts
0001C3FA                            ; ===========================================================================
0001C3FA                            ; ---------------------------------------------------------------------------
0001C3FA                            ; Write to YMCue according to channel in part 2
0001C3FA                            ; ---------------------------------------------------------------------------
0001C3FA                            
0001C3FA                            WriteChYM2:
0001C3FA 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0001C3FE 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0001C402 D002                       		add.b	d2,d0			; add to YM address
0001C404                            ; ===========================================================================
0001C404                            ; ---------------------------------------------------------------------------
0001C404                            ; Write to YMCue using part 2
0001C404                            ; ---------------------------------------------------------------------------
0001C404                            
0001C404                            WriteYM_Pt2:
0001C404                            	StopZ80					; wait for Z80 to stop
0001C404 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C40C                          M 	waitz80stop
0001C40C 0839 0000 00A1 1100      M .wait_343:	btst	#0,z80_bus_req
0001C414 66F6                     M 	bne.s	.wait_343
0001C416 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0001C41A 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C41C 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C41E                            	;	st	(a0)			; mark as the end of the cue data
0001C41E                            	StartZ80				; enable Z80 execution
0001C41E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C426 4E75                       		rts
0001C428                            ; ===========================================================================
0001C428                            ; ---------------------------------------------------------------------------
0001C428                            ; Note to FM frequency conversion table
0001C428                            ; ---------------------------------------------------------------------------
0001C428                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C428 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0001C42A 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0001C442 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0001C45A 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0001C472 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0001C48A 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0001C4A2 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0001C4BA 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0001C4D2 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0001C4E8                            dFreqFM_:
0001C4E8                            ; ===========================================================================
0001C4E8                            ; ---------------------------------------------------------------------------
0001C4E8                            ; Note to Dual PCM frequency conversion table
0001C4E8                            ; ---------------------------------------------------------------------------
0001C4E8                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C4E8 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0001C4EA 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0001C502 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0001C51A 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0001C532 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0001C54A 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0001C562 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0001C57A 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0001C592 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0001C5AA 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0001C5C2 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0001C5DA 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0001C5E8                            
0001C5E8 F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0001C5F8 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0001C610 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0001C628 F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0001C640 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0001C658 FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0001C670 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0001C688 FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0001C6A0 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0001C6B8 FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0001C6D0 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0001C6E8                            ; ===========================================================================
0001C6E8                            ; ---------------------------------------------------------------------------
0001C6E8                            ; Note to PSG frequency conversion table
0001C6E8                            ; ---------------------------------------------------------------------------
0001C6E8                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C6E8 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0001C700 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0001C718 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0001C730 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0001C748 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0001C760 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0001C772 0000                       	dc.w  $0000								     ; Note (C6)
0001C774                            dFreqPSG_:
0001C774                            ; ===========================================================================
0001C774                            ; ---------------------------------------------------------------------------
0001C774                            ; Process SFX PSG channels
0001C774                            ; ---------------------------------------------------------------------------
0001C774                            
0001C774                            dAMPSdoPSGSFX:
0001C774 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0001C776 4DFA FF70                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C77A                            
0001C77A                            dAMPSnextPSGSFX:
0001C77A DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C77E 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C780 6A00                       		bpl.s	.next			; if not, branch
0001C782 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C786 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C78A                            
0001C78A                            	dCalcFreq				; calculate channel base frequency
0001C78A 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C78E 4886                     M 	ext.w	d6
0001C790 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C794                            	dModulate				; run modulation code
0001C794 0815 0003                M 	btst	#cfbmod,(a5)
0001C798 6700                     M 	beq.s	.noret
0001C79A 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C79E 6700                     M 	beq.s	.started
0001C7A0 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C7A4                          M .noret
0001C7A4 6000                     M 	bra.s	.endm
0001C7A6                          M .started
0001C7A6 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C7AA 66F8                     M 	bne.s	.noret
0001C7AC 226D 0010                M 	movea.l	cmod(a5),a1
0001C7B0 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C7B6 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C7BA 6600                     M 	bne.s	.norev
0001C7BC 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C7C2 442D 0017                M 	neg.b	cmodstep(a5)
0001C7C6                          M .norev
0001C7C6 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C7CA 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C7CE 4885                     M 	ext.w	d5
0001C7D0 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C7D4 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C7D8 DC45                     M 	add.w	d5,d6
0001C7DA 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0001C7DE                            
0001C7DE                            .endm
0001C7DE 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C7E2                            .next
0001C7E2 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C7E6 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0001C7EA                            
0001C7EA                            .update
0001C7EA 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C7EE                            	dDoTracker				; process tracker
0001C7EE 286D 0002                M 	movea.l	cdata(a5),a4
0001C7F2                          M .data
0001C7F2 7A00                     M 	moveq	#0,d5
0001C7F4 1A1C                     M 	move.b	(a4)+,d5
0001C7F6 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C7FA 6500                     M 	blo.s	.notcomm
0001C7FC 4EBA 0000                M 	jsr	dcommands(pc)
0001C800 60F0                     M 	bra.s	.data
0001C802 60DE                     M 	bra.s	.next
0001C804                          M .notcomm
0001C804 4A05                       		tst.b	d5			; check if note is being played
0001C806 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C808                            
0001C808                            	dGetFreqPSG				; get PSG frequency
0001C808 0405 0081                M 	subi.b	#$81,d5
0001C80C 6400                     M 	bhs.s	.norest
0001C80E 08D5 0000                M 	bset	#cfbrest,(a5)
0001C812 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C818 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C81C 6000                     M 	bra.s	.freqgot
0001C81E                          M .norest
0001C81E DA2D 0008                M 	add.b	cpitch(a5),d5
0001C822 0245 007F                M 	andi.w	#$7f,d5
0001C826 DA45                     M 	add.w	d5,d5
0001C828 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C82E                          M .freqgot
0001C82E 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C830 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C832 534C                       		subq.w	#1,a4			; else, undo the increment
0001C834 6000                       		bra.s	.pcnote			; do not calculate duration
0001C836                            
0001C836                            .timer
0001C836 4EBA EF5A                  		jsr	dCalcDuration(pc)	; calculate duration
0001C83A                            .pcnote
0001C83A                            	dProcNote 1, 1				; reset necessary channel memory
0001C83A 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C83E 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C844 0815 0002                M 	btst	#cfbhold,(a5)
0001C848 6600                     M 	bne.s	.endpn
0001C84A 422D 0006                M 	clr.b	cenvpos(a5)
0001C84E 0815 0003                M 	btst	#cfbmod,(a5)
0001C852 6700                     M 	beq.s	.endpn
0001C854 226D 0010                M 	movea.l	cmod(a5),a1
0001C858 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C85C 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C860 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C864 1011                     M 	move.b	(a1),d0
0001C866 E208                     M 	lsr.b	#1,d0
0001C868 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C86C 426D 0014                M 	clr.w	cmodfreq(a5)
0001C870                          M .endpn
0001C870                            
0001C870 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0001C874 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C878 51CF FF00                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C87C                            	; continue to check tracker and end loop
0001C87C                            ; ===========================================================================
0001C87C                            ; ---------------------------------------------------------------------------
0001C87C                            ; End channel loop and check if tracker debugger should be opened
0001C87C                            ; ---------------------------------------------------------------------------
0001C87C                            
0001C87C                            dCheckTracker:
0001C87C                            .rts
0001C87C 4E75                       		rts
0001C87E                            ; ===========================================================================
0001C87E                            ; ---------------------------------------------------------------------------
0001C87E                            ; Music PSG channel loop
0001C87E                            ; ---------------------------------------------------------------------------
0001C87E                            
0001C87E                            dAMPSdoPSG:
0001C87E 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0001C880 4DFA FE66                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C884                            
0001C884                            dAMPSnextPSG:
0001C884 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0001C888 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C88A 6A00 0000                  		bpl.w	.next			; if not, branch
0001C88E 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C892 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C896                            
0001C896                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0001C896                          M 	dnotetouthandler
0001C896 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C89A 6700                     M 	beq.s	.endt
0001C89C 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C8A0 6600                     M 	bne.s	.endt
0001C8A2 08D5 0000                M 	bset	#cfbrest,(a5)
0001C8A6 6100 0000                M 	bsr.w	dmutepsgmus
0001C8AA 6000                     M 	bra.s	.next
0001C8AC                          M .endt
0001C8AC                            	dCalcFreq				; calculate channel base frequency
0001C8AC 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C8B0 4886                     M 	ext.w	d6
0001C8B2 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C8B6                            	dModulate				; run modulation code
0001C8B6 0815 0003                M 	btst	#cfbmod,(a5)
0001C8BA 6700                     M 	beq.s	.noret
0001C8BC 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C8C0 6700                     M 	beq.s	.started
0001C8C2 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C8C6                          M .noret
0001C8C6 6000                     M 	bra.s	.endm
0001C8C8                          M .started
0001C8C8 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C8CC 66F8                     M 	bne.s	.noret
0001C8CE 226D 0010                M 	movea.l	cmod(a5),a1
0001C8D2 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C8D8 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C8DC 6600                     M 	bne.s	.norev
0001C8DE 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C8E4 442D 0017                M 	neg.b	cmodstep(a5)
0001C8E8                          M .norev
0001C8E8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C8EC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C8F0 4885                     M 	ext.w	d5
0001C8F2 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C8F6 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C8FA DC45                     M 	add.w	d5,d6
0001C8FC 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0001C900                            
0001C900                            .endm
0001C900 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C904                            .next
0001C904 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C908 4EFA EEA0                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C90C                            
0001C90C                            .update
0001C90C 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C910                            	dDoTracker				; process tracker
0001C910 286D 0002                M 	movea.l	cdata(a5),a4
0001C914                          M .data
0001C914 7A00                     M 	moveq	#0,d5
0001C916 1A1C                     M 	move.b	(a4)+,d5
0001C918 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C91C 6500                     M 	blo.s	.notcomm
0001C91E 4EBA 0000                M 	jsr	dcommands(pc)
0001C922 60F0                     M 	bra.s	.data
0001C924 60DE                     M 	bra.s	.next
0001C926                          M .notcomm
0001C926 4A05                       		tst.b	d5			; check if note is being played
0001C928 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C92A                            
0001C92A                            	dGetFreqPSG				; get PSG frequency
0001C92A 0405 0081                M 	subi.b	#$81,d5
0001C92E 6400                     M 	bhs.s	.norest
0001C930 08D5 0000                M 	bset	#cfbrest,(a5)
0001C934 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C93A 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C93E 6000                     M 	bra.s	.freqgot
0001C940                          M .norest
0001C940 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C944 0245 007F                M 	andi.w	#$7f,d5
0001C948 DA45                     M 	add.w	d5,d5
0001C94A 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C950                          M .freqgot
0001C950 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C952 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C954 534C                       		subq.w	#1,a4			; else, undo the increment
0001C956 6000                       		bra.s	.pcnote			; do not calculate duration
0001C958                            
0001C958                            .timer
0001C958 4EBA EE38                  		jsr	dCalcDuration(pc)	; calculate duration
0001C95C                            .pcnote
0001C95C                            	dProcNote 0, 1				; reset necessary channel memory
0001C95C 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C960 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C966 0815 0002                M 	btst	#cfbhold,(a5)
0001C96A 6600                     M 	bne.s	.endpn
0001C96C 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C972 422D 0006                M 	clr.b	cenvpos(a5)
0001C976 0815 0003                M 	btst	#cfbmod,(a5)
0001C97A 6700                     M 	beq.s	.endpn
0001C97C 226D 0010                M 	movea.l	cmod(a5),a1
0001C980 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C984 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C988 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C98C 1011                     M 	move.b	(a1),d0
0001C98E E208                     M 	lsr.b	#1,d0
0001C990 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C994 426D 0014                M 	clr.w	cmodfreq(a5)
0001C998                          M .endpn
0001C998                            
0001C998 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0001C99A 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C99E 51CF FEE4                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C9A2 4EFA EE06                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C9A6                            ; ===========================================================================
0001C9A6                            ; ---------------------------------------------------------------------------
0001C9A6                            ; Write PSG frequency to hardware
0001C9A6                            ; ---------------------------------------------------------------------------
0001C9A6                            
0001C9A6                            dUpdateFreqPSG:
0001C9A6 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001C9AA 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0001C9AC 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C9B0 4E75                       		rts
0001C9B2                            
0001C9B2                            .detune
0001C9B2 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C9B6 4880                       		ext.w	d0			; extend to word
0001C9B8 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C9BA                            
0001C9BA 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C9BE 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001C9C0 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001C9C4                            
0001C9C4                            dUpdateFreqPSG2:
0001C9C4 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001C9C8 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9CA                            
0001C9CA                            dUpdateFreqPSG3:
0001C9CA 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C9CE 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9D0                            
0001C9D0 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0001C9D4 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0001C9D8 6600                       		bne.s	.notPSG4		; if not, branch
0001C9DA 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001C9DC                            
0001C9DC                            .notPSG4
0001C9DC 3206                       		move.w	d6,d1			; copy frequency to d1
0001C9DE 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001C9E2 8001                       		or.b	d1,d0			; combine with channel type
0001C9E4                            ; ---------------------------------------------------------------------------
0001C9E4                            ; Note about the and instruction below: If this instruction is
0001C9E4                            ; not commented out, the instashield SFX will not sound correct.
0001C9E4                            ; This instruction was removed in Sonic 3K because of this, but
0001C9E4                            ; this can cause issues when values overflow the valid range of
0001C9E4                            ; PSG frequency. This may cause erroneous behavior if not anded,
0001C9E4                            ; but will also make the instashield SFX not sound correctly.
0001C9E4                            ; Comment out the instruction with caution, if you are planning
0001C9E4                            ; to port said sound effect to this driver. This has not caused
0001C9E4                            ; any issues for me, and if you are careful you can avoid any
0001C9E4                            ; such case, but beware of this issue!
0001C9E4                            ; ---------------------------------------------------------------------------
0001C9E4                            
0001C9E4 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0001C9E6 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001C9EA 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001C9F0 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0001C9F6                            
0001C9F6                            locret_dUpdateFreqPSG:
0001C9F6 4E75                       		rts
0001C9F8                            ; ===========================================================================
0001C9F8                            ; ---------------------------------------------------------------------------
0001C9F8                            ; Routine for running envelope programs
0001C9F8                            ; ---------------------------------------------------------------------------
0001C9F8                            
0001C9F8                            dEnvProgPSG:
0001C9F8 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001C9FC DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CA00                            
0001CA00 7800                       		moveq	#0,d4
0001CA02 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CA06 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0001CA08 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001CA0A                            
0001CA0A                            dEnvelopePSG:
0001CA0A 7800                       		moveq	#0,d4
0001CA0C 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CA10 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001CA12                            
0001CA12 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001CA16 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CA1A                            
0001CA1A                            dEnvProgPSG2:
0001CA1A                            
0001CA1A 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0001CA1E D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001CA20 D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001CA22 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0001CA26                            
0001CA26 7200                       		moveq	#0,d1
0001CA28 7000                       		moveq	#0,d0
0001CA2A                            
0001CA2A                            dEnvProgPSG3:
0001CA2A 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0001CA2E 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001CA32 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001CA34                            
0001CA34 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0001CA38 DA00                       		add.b	d0,d5			; add envelope volume to d5
0001CA3A                            	; continue to update PSG volume
0001CA3A                            ; ===========================================================================
0001CA3A                            ; ---------------------------------------------------------------------------
0001CA3A                            ; Routine for updating PSG volume to hardware
0001CA3A                            ; ---------------------------------------------------------------------------
0001CA3A                            
0001CA3A                            dUpdateVolPSG2:
0001CA3A 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0001CA3E 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001CA40 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001CA42                            
0001CA42                            dUpdateVolPSG:
0001CA42 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001CA46 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA48 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001CA4C 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA4E                            
0001CA4E 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001CA52 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA54 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0001CA58 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0001CA5A                            
0001CA5A 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0001CA5E 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA60 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001CA64 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0001CA66                            
0001CA66                            dUpdVolPSGset:
0001CA66 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0001CA6A 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0001CA6E 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001CA74                            
0001CA74                            locret_UpdVolPSG:
0001CA74 4E75                       		rts
0001CA76                            ; ===========================================================================
0001CA76                            ; ---------------------------------------------------------------------------
0001CA76                            ; Subroutine for handling volume envelope commands
0001CA76                            ; ---------------------------------------------------------------------------
0001CA76                            
0001CA76                            dEnvCommand:
0001CA76                            
0001CA76 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001CA7A                            
0001CA7A                            .comm
0001CA7A 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001CA7C 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001CA7E 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001CA80                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001CA80                            ; ---------------------------------------------------------------------------
0001CA80                            
0001CA80                            .stop
0001CA80 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0001CA84 6000                       		bra.s	dMutePSGmus		; nute the channel
0001CA86                            ; ---------------------------------------------------------------------------
0001CA86                            
0001CA86                            .hold
0001CA86 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001CA8A 4EFA FF9E                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001CA8E                            ; ---------------------------------------------------------------------------
0001CA8E                            
0001CA8E                            .reset
0001CA8E 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0001CA92 4EFA FF96                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CA96                            ; ---------------------------------------------------------------------------
0001CA96                            
0001CA96                            .loop
0001CA96 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001CA9C 4EFA FF8C                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CAA0                            ; ===========================================================================
0001CAA0                            ; ---------------------------------------------------------------------------
0001CAA0                            ; Routine for hardware muting a PSG channel
0001CAA0                            ; ---------------------------------------------------------------------------
0001CAA0                            
0001CAA0                            dMutePSGmus:
0001CAA0 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0001CAA4 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0001CAA6                            
0001CAA6                            dMutePSGsfx:
0001CAA6 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001CAA8 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001CAAC 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0001CAB2                            
0001CAB2                            locret_MutePSG:
0001CAB2 4E75                       		rts
0001CAB4                            
0001CAB4 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001CABC                            ; ===========================================================================
0001CABC                            ; ---------------------------------------------------------------------------
0001CABC                            ; Routine to execute tracker commands
0001CABC                            ;
0001CABC                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001CABC                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001CABC                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001CABC                            ; but it may be helpful with speed anyway.
0001CABC                            ; ---------------------------------------------------------------------------
0001CABC                            
0001CABC                            dCommands:
0001CABC DA05                       		add.b	d5,d5			; quadruple command ID
0001CABE DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001CAC0                            
0001CAC0 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0001CAC4 6600 0000                  		bne.w	.falsecomm		; branch if false
0001CAC8 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001CACC                            ; ===========================================================================
0001CACC                            ; ---------------------------------------------------------------------------
0001CACC                            ; Command handlers for normal execution
0001CACC                            ; ---------------------------------------------------------------------------
0001CACC                            
0001CACC                            .comm
0001CACC 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CAD0 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0001CAD4 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001CAD8 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CADC 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CAE0 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CAE4 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CAE8 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CAEC 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CAF0 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0001CAF4 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CAF8 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CAFC 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CB00 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CB04 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CB08 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CB0C 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0001CB10 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CB14 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CB18 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001CB1C 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0001CB20 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0001CB24 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001CB28 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CB2C 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CB30 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0001CB34 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CB38 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CB3C 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001CB40 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CB44 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0001CB48                            				; FF - META
0001CB48                            ; ===========================================================================
0001CB48                            ; ---------------------------------------------------------------------------
0001CB48                            ; Routine to execute tracker meta and false condition commands
0001CB48                            ; ---------------------------------------------------------------------------
0001CB48                            
0001CB48                            .metacall
0001CB48 1A1C                       		move.b	(a4)+,d5		; get next command byte
0001CB4A DA45                       		add.w	d5,d5			; quadruple ID
0001CB4C DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001CB4E 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0001CB52                            
0001CB52                            .falsecomm
0001CB52 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0001CB56                            ; ===========================================================================
0001CB56                            ; ---------------------------------------------------------------------------
0001CB56                            ; Command handlers for meta commands
0001CB56                            ; ---------------------------------------------------------------------------
0001CB56                            
0001CB56                            .meta
0001CB56 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0001CB5A 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001CB5E 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0001CB62 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0001CB66 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001CB6A 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001CB6E 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0001CB72 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CB76 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001CB7A 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001CB7E 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0001CB82 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0001CB86 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001CB8A 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001CB8E                            
0001CB8E                            ; ===========================================================================
0001CB8E                            ; ---------------------------------------------------------------------------
0001CB8E                            ; Command handlers for false condition execution
0001CB8E                            ; ---------------------------------------------------------------------------
0001CB8E                            
0001CB8E                            .false
0001CB8E 524C                       	addq.w	#1,a4
0001CB90 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CB92 524C                       	addq.w	#1,a4
0001CB94 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001CB96 524C                       	addq.w	#1,a4
0001CB98 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0001CB9A 524C                       	addq.w	#1,a4
0001CB9C 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CB9E 524C                       	addq.w	#1,a4
0001CBA0 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CBA2 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CBA6 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CBAA 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CBAE 524C                       	addq.w	#1,a4
0001CBB0 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CBB2 524C                       	addq.w	#1,a4
0001CBB4 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CBB6 524C                       	addq.w	#1,a4
0001CBB8 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CBBA 4E75                       	rts
0001CBBC 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CBBE 4E75                       	rts
0001CBC0 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CBC2 524C                       	addq.w	#1,a4
0001CBC4 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CBC6 524C                       	addq.w	#1,a4
0001CBC8 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CBCA 524C                       	addq.w	#1,a4
0001CBCC 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CBCE 584C                       	addq.w	#4,a4
0001CBD0 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001CBD2 4E75                       	rts
0001CBD4 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CBD6 4E75                       	rts
0001CBD8 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CBDA 524C                       	addq.w	#1,a4
0001CBDC 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0001CBDE 544C                       	addq.w	#2,a4
0001CBE0 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001CBE2 4E75                       	rts
0001CBE4 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0001CBE6 544C                       	addq.w	#2,a4
0001CBE8 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0001CBEA 584C                       	addq.w	#4,a4
0001CBEC 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CBEE 544C                       	addq.w	#2,a4
0001CBF0 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CBF2 4E75                       	rts
0001CBF4 4E75                       	rts			; F9 - Return (RETURN)
0001CBF6 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CBFA 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CBFE 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001CC02 524C                       	addq.w	#1,a4
0001CC04 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CC06 524C                       	addq.w	#1,a4
0001CC08 4E75                       	rts			; FE - YM command (YMCMD)
0001CC0A 6000 FF3C                  	bra.w	.metacall	; FF - META
0001CC0E                            ; ===========================================================================
0001CC0E                            ; ---------------------------------------------------------------------------
0001CC0E                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0001CC0E                            ; Note that this will override any DAC already being played,
0001CC0E                            ; and in turn trackers may override these DAC samples at any
0001CC0E                            ; time. Use with caution!
0001CC0E                            ; ---------------------------------------------------------------------------
0001CC0E                            
0001CC0E                            dcWriteDAC1:
0001CC0E 7000                       		moveq	#0,d0
0001CC10 101C                       		move.b	(a4)+,d0		; get note to write
0001CC12 4EFA EA98                  		jmp	dNoteWriteDAC1(pc)	; note-on
0001CC16                            
0001CC16                            dcWriteDAC2:
0001CC16 7000                       		moveq	#0,d0
0001CC18 101C                       		move.b	(a4)+,d0		; get note to write
0001CC1A 4EFA EA82                  		jmp	dNoteWriteDAC2(pc)	; note-on
0001CC1E                            ; ===========================================================================
0001CC1E                            ; ---------------------------------------------------------------------------
0001CC1E                            ; Tracker commands for handling spindash revving.
0001CC1E                            ; The way spindash revving works, is it actually just
0001CC1E                            ; increments a counter each time, and this counter is
0001CC1E                            ; added into the channel pitch offset.
0001CC1E                            ; ---------------------------------------------------------------------------
0001CC1E                            
0001CC1E                            dcSpRev:
0001CC1E 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001CC22 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001CC26 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0001CC2A                            
0001CC2A 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0001CC2E 6500                       		blo.s	.rts			; if not, skip
0001CC30 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001CC34                            
0001CC34                            .rts
0001CC34 4E75                       		rts
0001CC36                            
0001CC36                            dcSpReset:
0001CC36 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0001CC3A 4E75                       		rts
0001CC3C                            ; ===========================================================================
0001CC3C                            ; ---------------------------------------------------------------------------
0001CC3C                            ; Tracker command for changing channel panning
0001CC3C                            ; ---------------------------------------------------------------------------
0001CC3C                            
0001CC3C                            dcPan:
0001CC3C                            
0001CC3C 7237                       		moveq	#$37,d1			; prepare bits to keep
0001CC3E C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001CC42 821C                       		or.b	(a4)+,d1		; or panning value
0001CC44 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001CC48                            
0001CC48 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001CC4A 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CC50 6700 F774                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001CC54                            ; ---------------------------------------------------------------------------
0001CC54                            ; Since the DAC channels have or based panning behavior, we need this
0001CC54                            ; piece of code to update its panning
0001CC54                            ; ---------------------------------------------------------------------------
0001CC54                            
0001CC54 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001CC58 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001CC5E 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001CC60 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001CC64                            
0001CC64                            .nodacsfx
0001CC64 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001CC68 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001CC6A 4EFA F798                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001CC6E                            ; ===========================================================================
0001CC6E                            ; ---------------------------------------------------------------------------
0001CC6E                            ; Tracker commands for changing detune offset
0001CC6E                            ; ---------------------------------------------------------------------------
0001CC6E                            
0001CC6E                            dcaDetune:
0001CC6E 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0001CC70 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001CC74 4E75                       		rts
0001CC76                            
0001CC76                            dcsDetune:
0001CC76 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001CC7A 4E75                       		rts
0001CC7C                            ; ===========================================================================
0001CC7C                            ; ---------------------------------------------------------------------------
0001CC7C                            ; Tracker command for changing channel volume
0001CC7C                            ; ---------------------------------------------------------------------------
0001CC7C                            
0001CC7C                            dcsVolume:
0001CC7C 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001CC80 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC84 4E75                       		rts
0001CC86                            
0001CC86                            dcaVolume:
0001CC86 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001CC88 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001CC8C 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC90 4E75                       		rts
0001CC92                            ; ===========================================================================
0001CC92                            ; ---------------------------------------------------------------------------
0001CC92                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001CC92                            ; ---------------------------------------------------------------------------
0001CC92                            
0001CC92                            dcSampDAC:
0001CC92 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
0001CC98 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001CC9C 4E75                       		rts
0001CC9E                            ; ===========================================================================
0001CC9E                            ; ---------------------------------------------------------------------------
0001CC9E                            ; Tracker command for setting DAC to pitch mode
0001CC9E                            ; ---------------------------------------------------------------------------
0001CC9E                            
0001CC9E                            dcPitchDAC:
0001CC9E 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001CCA2 4E75                       		rts
0001CCA4                            ; ===========================================================================
0001CCA4                            ; ---------------------------------------------------------------------------
0001CCA4                            ; Tracker commands for changing channel tick multiplier
0001CCA4                            ; ---------------------------------------------------------------------------
0001CCA4                            
0001CCA4                            dcsTmulCh:
0001CCA4 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
0001CCA8 4E75                       		rts
0001CCAA                            
0001CCAA                            dcsTmul:
0001CCAA 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001CCAC =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001CCAC                            	rept Mus_Ch				; do for all music channels
0001CCAC                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001CCAC                            .x =		.x+cSize			; go to next channel
0001CCAC                            	endr
0001CCAC 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001CCB0 =FFFFC4F0                M .x	=	.x+csize
0001CCB0 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001CCB4 =FFFFC51C                M .x	=	.x+csize
0001CCB4 11C0 C526                M 	move.b	d0,ctick+.x.w
0001CCB8 =FFFFC548                M .x	=	.x+csize
0001CCB8 11C0 C552                M 	move.b	d0,ctick+.x.w
0001CCBC =FFFFC574                M .x	=	.x+csize
0001CCBC 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001CCC0 =FFFFC5A0                M .x	=	.x+csize
0001CCC0 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001CCC4 =FFFFC5CC                M .x	=	.x+csize
0001CCC4 11C0 C5D6                M 	move.b	d0,ctick+.x.w
0001CCC8 =FFFFC5F8                M .x	=	.x+csize
0001CCC8 11C0 C602                M 	move.b	d0,ctick+.x.w
0001CCCC =FFFFC624                M .x	=	.x+csize
0001CCCC 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001CCD0 =FFFFC650                M .x	=	.x+csize
0001CCD0 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001CCD4 =FFFFC67C                M .x	=	.x+csize
0001CCD4 4E75                       		rts
0001CCD6                            ; ===========================================================================
0001CCD6                            ; ---------------------------------------------------------------------------
0001CCD6                            ; Tracker command for enabling or disabling the hold flag
0001CCD6                            ; ---------------------------------------------------------------------------
0001CCD6                            
0001CCD6                            dcHold:
0001CCD6 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
0001CCDA 4E75                       		rts
0001CCDC                            ; ===========================================================================
0001CCDC                            ; ---------------------------------------------------------------------------
0001CCDC                            ; Tracker command for enabling or disabling note timeout
0001CCDC                            ; ---------------------------------------------------------------------------
0001CCDC                            
0001CCDC                            dcTimeout:
0001CCDC                            
0001CCDC 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001CCE0 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001CCE4 4E75                       		rts
0001CCE6                            ; ===========================================================================
0001CCE6                            ; ---------------------------------------------------------------------------
0001CCE6                            ; Tracker commands for changing channel pitch
0001CCE6                            ; ---------------------------------------------------------------------------
0001CCE6                            
0001CCE6                            dcaTransp:
0001CCE6 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
0001CCE8 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
0001CCEC 4E75                       		rts
0001CCEE                            
0001CCEE                            dcsTransp:
0001CCEE 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001CCF2 4E75                       		rts
0001CCF4                            ; ===========================================================================
0001CCF4                            ; ---------------------------------------------------------------------------
0001CCF4                            ; Tracker commands for tempo control
0001CCF4                            ; ---------------------------------------------------------------------------
0001CCF4                            
0001CCF4                            dcsTempoShoes:
0001CCF4 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CCF6 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
0001CCFA 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD00 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001CD02 4E75                       		rts
0001CD04                            
0001CD04                            dcsTempo:
0001CD04 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD06 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
0001CD0A 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD10 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001CD12                            
0001CD12                            dcsTempoCur:
0001CD12 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
0001CD16                            
0001CD16                            locret_Tempo:
0001CD16 4E75                       		rts
0001CD18                            
0001CD18                            dcaTempoShoes:
0001CD18 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD1A D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001CD1E 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD24 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
0001CD26 4E75                       		rts
0001CD28                            
0001CD28                            dcaTempo:
0001CD28 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD2A D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001CD2E 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD34 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
0001CD36                            
0001CD36                            dcaTempoCur:
0001CD36 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
0001CD3A 4E75                       		rts
0001CD3C                            ; ===========================================================================
0001CD3C                            ; ---------------------------------------------------------------------------
0001CD3C                            ; Tracker command for enabling or disabling PSG4 noise mode
0001CD3C                            ; ---------------------------------------------------------------------------
0001CD3C                            
0001CD3C                            dcNoisePSG:
0001CD3C 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001CD40 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001CD42 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001CD48 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001CD4E 4E75                       		rts
0001CD50                            
0001CD50                            .psg3
0001CD50 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001CD56 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001CD5E 524C                       		addq.w	#1,a4			; skip param
0001CD60 4E75                       		rts
0001CD62                            ; ===========================================================================
0001CD62                            ; ---------------------------------------------------------------------------
0001CD62                            ; Tracker command for playing another music or SFX
0001CD62                            ; ---------------------------------------------------------------------------
0001CD62                            
0001CD62                            dcSound:
0001CD62 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001CD66                            
0001CD66                            Return_dcSound:
0001CD66 4E75                       		rts
0001CD68                            ; ===========================================================================
0001CD68                            ; ---------------------------------------------------------------------------
0001CD68                            ; Tracker command for setting DAC filter bank
0001CD68                            ; ---------------------------------------------------------------------------
0001CD68                            
0001CD68                            dcFilter:
0001CD68 7000                       		moveq	#0,d0
0001CD6A 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001CD6C 4EFA F23E                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001CD70                            ; ===========================================================================
0001CD70                            ; ---------------------------------------------------------------------------
0001CD70                            ; Tracker command for writing a YM command to YMCue
0001CD70                            ; ---------------------------------------------------------------------------
0001CD70                            
0001CD70                            dcYM:
0001CD70 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
0001CD72 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
0001CD74 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001CD78 66EC                       		bne.s	Return_dcSound		; if so, skip
0001CD7A                            
0001CD7A 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001CD7E 6500 F658                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD82                            
0001CD82 1400                       		move.b	d0,d2			; copy address to d2
0001CD84 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001CD88 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001CD8C 6500 F64A                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD90 4EFA F63A                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001CD94                            ; ===========================================================================
0001CD94                            ; ---------------------------------------------------------------------------
0001CD94                            ; Tracker command for setting channel base frequency
0001CD94                            ; ---------------------------------------------------------------------------
0001CD94                            
0001CD94                            dcsFreq:
0001CD94 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001CD98 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001CD9C                            
0001CD9C                            .rts
0001CD9C 4E75                       		rts
0001CD9E                            ; ===========================================================================
0001CD9E                            ; ---------------------------------------------------------------------------
0001CD9E                            ; Tracker command for setting channel base frequency from the note table
0001CD9E                            ; ---------------------------------------------------------------------------
0001CD9E                            
0001CD9E                            dcsFreqNote:
0001CD9E 7000                       		moveq	#0,d0
0001CDA0 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001CDA2 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001CDA6 D040                       		add.w	d0,d0			; double offset (each entry is a word)
0001CDA8                            
0001CDA8 43FA F73E                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001CDAC 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
0001CDB2                            
0001CDB2                            .rts
0001CDB2 4E75                       		rts
0001CDB4                            ; ===========================================================================
0001CDB4                            ; ---------------------------------------------------------------------------
0001CDB4                            ; Tracker command for doing a continous SFX loop
0001CDB4                            ; ---------------------------------------------------------------------------
0001CDB4                            
0001CDB4                            dcCont:
0001CDB4 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001CDB8 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001CDBA 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
0001CDBE 544C                       		addq.w	#2,a4			; skip over jump offset
0001CDC0 4E75                       		rts
0001CDC2                            ; ===========================================================================
0001CDC2                            ; ---------------------------------------------------------------------------
0001CDC2                            ; Tracker command for calling a tracker subroutine
0001CDC2                            ; ---------------------------------------------------------------------------
0001CDC2                            
0001CDC2                            dcCall:
0001CDC2                            
0001CDC2 7000                       		moveq	#0,d0
0001CDC4 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CDC8 5900                       		subq.b	#4,d0			; allocate space for another routine
0001CDCA                            
0001CDCA 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
0001CDCE 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CDD2                            ; ===========================================================================
0001CDD2                            ; ---------------------------------------------------------------------------
0001CDD2                            ; Tracker command for jumping to another tracker location
0001CDD2                            ; ---------------------------------------------------------------------------
0001CDD2                            
0001CDD2                            dcJump:
0001CDD2                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001CDD2 1E9C                     M 	move.b	(a4)+,(sp)
0001CDD4 3017                     M 	move.w	(sp),d0
0001CDD6 1014                     M 	move.b	(a4),d0
0001CDD8 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001CDDA 4E75                       		rts
0001CDDC                            ; ===========================================================================
0001CDDC                            ; ---------------------------------------------------------------------------
0001CDDC                            ; Tracker command for handling loops
0001CDDC                            ; ---------------------------------------------------------------------------
0001CDDC                            
0001CDDC                            dcLoop:
0001CDDC 7000                       		moveq	#0,d0
0001CDDE 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001CDE0                            
0001CDE0 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001CDE4 6600                       		bne.s	.loopok			; if nonzero, branch
0001CDE6 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
0001CDEC                            
0001CDEC                            .loopok
0001CDEC 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001CDF0 66E0                       		bne.s	dcJump			; if not 0, jump to routine
0001CDF2 564C                       		addq.w	#3,a4			; skip over jump offset
0001CDF4 4E75                       		rts
0001CDF6                            ; ===========================================================================
0001CDF6                            ; ---------------------------------------------------------------------------
0001CDF6                            ; Tracker command for initializing modulation
0001CDF6                            ; ---------------------------------------------------------------------------
0001CDF6                            
0001CDF6                            dcMod68K:
0001CDF6 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
0001CDFA 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
0001CDFE 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001CE02 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001CE06                            
0001CE06 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001CE08 E208                       		lsr.b	#1,d0			; halve it
0001CE0A 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
0001CE0E 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001CE12                            	; continue to enabling modulation
0001CE12                            ; ===========================================================================
0001CE12                            ; ---------------------------------------------------------------------------
0001CE12                            ; Tracker commands for enabling and disabling modulation
0001CE12                            ; ---------------------------------------------------------------------------
0001CE12                            
0001CE12                            dcModOn:
0001CE12 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001CE16 4E75                       		rts
0001CE18                            
0001CE18                            dcModOff:
0001CE18 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
0001CE1C 4E75                       		rts
0001CE1E                            ; ===========================================================================
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            ; Tracker command for returning from tracker subroutine
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            
0001CE1E                            dcReturn:
0001CE1E 7000                       		moveq	#0,d0
0001CE20 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CE24 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
0001CE28                            
0001CE28 544C                       		addq.w	#2,a4			; skip the call address parameter
0001CE2A 5800                       		addq.b	#4,d0			; deallocate stack space
0001CE2C 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CE30                            
0001CE30 4E75                       		rts
0001CE32                            ; ===========================================================================
0001CE32                            ; ---------------------------------------------------------------------------
0001CE32                            ; Tracker command for initializing special FM3 mode
0001CE32                            ; ---------------------------------------------------------------------------
0001CE32                            
0001CE32                            dcSpecFM3:
0001CE32 4E75                       		rts
0001CE34                            ; ===========================================================================
0001CE34                            ; ---------------------------------------------------------------------------
0001CE34                            ; Tracker command for enabling raw frequency mode
0001CE34                            ; ---------------------------------------------------------------------------
0001CE34                            
0001CE34                            dcFreqOn:
0001CE34 4E75                       		rts
0001CE36                            ; ===========================================================================
0001CE36                            ; ---------------------------------------------------------------------------
0001CE36                            ; Tracker command for disabling raw frequency mode
0001CE36                            ; ---------------------------------------------------------------------------
0001CE36                            
0001CE36                            dcFreqOff:
0001CE36                            
0001CE36                            locret_FreqOff:
0001CE36 4E75                       		rts
0001CE38                            ; ===========================================================================
0001CE38                            ; ---------------------------------------------------------------------------
0001CE38                            ; Tracker command for changing voice, volume envelope or sample
0001CE38                            ; ---------------------------------------------------------------------------
0001CE38                            
0001CE38                            dcVoice:
0001CE38 7000                       		moveq	#0,d0
0001CE3A 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
0001CE3C 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001CE40                            
0001CE40 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001CE44 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001CE46 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CE4C 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001CE4E                            
0001CE4E 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001CE52 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001CE54 224E                       		move.l	a6,a1			; load voice table to a1
0001CE56                            	; continue to send FM voice
0001CE56                            ; ===========================================================================
0001CE56                            ; ---------------------------------------------------------------------------
0001CE56                            ; Subroutine for sending the FM voice to YM2612
0001CE56                            ; This routine is speed optimized in a way that allows Dual PCM
0001CE56                            ; to only be stopped for as long as it must be. This will waste
0001CE56                            ; some cycles for 68000, but it will help improve DAC quality.
0001CE56                            ; ---------------------------------------------------------------------------
0001CE56                            
0001CE56                            dUpdateVoiceFM:
0001CE56                            	dCALC_VOICE				; get address of the specific voice to a1
0001CE56 EB48                     M 	lsl.w	#5,d0
0001CE58 D2C0                     M 	add.w	d0,a1
0001CE5A 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001CE5E 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001CE60                            
0001CE60 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001CE62 16C4                       		move.b	d4,(a3)+		; save it to free space
0001CE64 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001CE68                            
0001CE68 45FA F262                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001CE6C                            	rept VoiceRegs-5
0001CE6C                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001CE6C                            		move.b	(a2)+,(a3)+		; copy each command
0001CE6C                            	endr
0001CE6C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE6E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE70 16D9                     M 	move.b	(a1)+,(a3)+
0001CE72 16DA                     M 	move.b	(a2)+,(a3)+
0001CE74 16D9                     M 	move.b	(a1)+,(a3)+
0001CE76 16DA                     M 	move.b	(a2)+,(a3)+
0001CE78 16D9                     M 	move.b	(a1)+,(a3)+
0001CE7A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE7C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE7E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE80 16D9                     M 	move.b	(a1)+,(a3)+
0001CE82 16DA                     M 	move.b	(a2)+,(a3)+
0001CE84 16D9                     M 	move.b	(a1)+,(a3)+
0001CE86 16DA                     M 	move.b	(a2)+,(a3)+
0001CE88 16D9                     M 	move.b	(a1)+,(a3)+
0001CE8A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE8C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE8E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE90 16D9                     M 	move.b	(a1)+,(a3)+
0001CE92 16DA                     M 	move.b	(a2)+,(a3)+
0001CE94 16D9                     M 	move.b	(a1)+,(a3)+
0001CE96 16DA                     M 	move.b	(a2)+,(a3)+
0001CE98 16D9                     M 	move.b	(a1)+,(a3)+
0001CE9A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE9C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE9E 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA0 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA2 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA4 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA6 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA8 16D9                     M 	move.b	(a1)+,(a3)+
0001CEAA 16DA                     M 	move.b	(a2)+,(a3)+
0001CEAC 16D9                     M 	move.b	(a1)+,(a3)+
0001CEAE 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB0 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB2 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB4 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB6 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB8 16D9                     M 	move.b	(a1)+,(a3)+
0001CEBA 16DA                     M 	move.b	(a2)+,(a3)+
0001CEBC 16D9                     M 	move.b	(a1)+,(a3)+
0001CEBE 16DA                     M 	move.b	(a2)+,(a3)+
0001CEC0 16D9                     M 	move.b	(a1)+,(a3)+
0001CEC2 16DA                     M 	move.b	(a2)+,(a3)+
0001CEC4 16D9                     M 	move.b	(a1)+,(a3)+
0001CEC6 16DA                     M 	move.b	(a2)+,(a3)+
0001CEC8 16D9                     M 	move.b	(a1)+,(a3)+
0001CECA 16DA                     M 	move.b	(a2)+,(a3)+
0001CECC                            
0001CECC 7C00                       		moveq	#0,d6			; reset the modulator offset
0001CECE 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001CED2 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001CED6 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001CED8 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001CEDA                            
0001CEDA                            .noover
0001CEDA 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001CEE0 6700                       		beq.s	.uwdone			; if not, skip
0001CEE2 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001CEE4 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001CEE8 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001CEEA 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001CEEC                            
0001CEEC                            .uwdone
0001CEEC 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001CEEE                            
0001CEEE                            .tlloop
0001CEEE 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001CEF0 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001CEF2                            
0001CEF2 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001CEF4 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001CEF6 727F                       		moveq	#$7F,d1			; cap to silent volume
0001CEF8 6000                       		bra.s	.slot
0001CEFA                            
0001CEFA                            .noslot
0001CEFA D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001CEFC                            .slot
0001CEFC 16C1                       		move.b	d1,(a3)+		; save the Total Level value
0001CEFE 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
0001CF00 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001CF04                            
0001CF04                            
0001CF04 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001CF08 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001CF0C 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001CF10                            
0001CF10 7400                       		moveq	#0,d2			; prepare part 1 value
0001CF12 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001CF16 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001CF1A 6700                       		beq.s	.ptok			; if so, branch
0001CF1C 0203 0003                  		and.b	#3,d3			; get channel offset only
0001CF20 7402                       		moveq	#2,d2			; prepare part 2 value
0001CF22                            
0001CF22                            .ptok
0001CF22 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001CF24 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001CF26                            	StopZ80					; wait for Z80 to stop
0001CF26 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001CF2E                          M 	waitz80stop
0001CF2E 0839 0000 00A1 1100      M .wait_360:	btst	#0,z80_bus_req
0001CF36 66F6                     M 	bne.s	.wait_360
0001CF38                            
0001CF38                            .write
0001CF38 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
0001CF3A 10DB                       		move.b	(a3)+,(a0)+		; write command values
0001CF3C                            
0001CF3C 101B                       		move.b	(a3)+,d0		; load YM command
0001CF3E 8003                       		or.b	d3,d0			; add the channel offset to command
0001CF40 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001CF42 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001CF46 50D0                       		st	(a0)			; mark as end of the cue
0001CF48                            
0001CF48                            	StartZ80				; enable Z80 execution
0001CF48 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001CF50 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001CF54 4E75                       		rts
0001CF56                            ; ===========================================================================
0001CF56                            ; ---------------------------------------------------------------------------
0001CF56                            ; Tracker command for stopping the current channel
0001CF56                            ; ---------------------------------------------------------------------------
0001CF56                            
0001CF56                            dcStop:
0001CF56 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
0001CF5A 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001CF5E 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001CF60                            
0001CF60 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001CF66 6600                       		bne.s	.cont			; if we are, skip
0001CF68 4EBA F448                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001CF6C 6000                       		bra.s	.cont
0001CF6E                            ; ---------------------------------------------------------------------------
0001CF6E                            
0001CF6E                            .mutePSG
0001CF6E 4EBA FB30                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001CF72                            
0001CF72                            .cont
0001CF72 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001CF76 6500                       		blo.s	.exit			; if not, skip all this mess
0001CF78 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001CF7C                            
0001CF7C 43FA ED74                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001CF80 7600                       		moveq	#0,d3
0001CF82 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
0001CF86 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001CF88 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001CF8A                            
0001CF8A 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001CF8E 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001CF90 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001CF92 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
0001CF96                            
0001CF96                            .dacdone
0001CF96 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001CF98 6A00                       		bpl.s	.fixch			; if not, branch
0001CF9A                            
0001CF9A 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
0001CF9E 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
0001CFA2 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001CFA8 6600                       		bne.s	.fixch			; if yes, skip
0001CFAA                            
0001CFAA 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
0001CFAE 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
0001CFB2 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CFB6 4EBA FE9E                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001CFBA                            
0001CFBA                            .fixch
0001CFBA 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001CFBC                            .exit
0001CFBC 5497                       		addq.l	#2,(sp)			; go to next channel immediately
0001CFBE 4E75                       		rts
0001CFC0                            ; ---------------------------------------------------------------------------
0001CFC0                            ; There is nothing that would break even if the channel is not
0001CFC0                            ; running a tracker, so we do not bother checking
0001CFC0                            ; ---------------------------------------------------------------------------
0001CFC0                            
0001CFC0                            .psg
0001CFC0 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
0001CFC2 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001CFC6 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001CFCA 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
0001CFCE                            
0001CFCE 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001CFD4 66E6                       		bne.s	.exit			; if not, skip
0001CFD6 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
0001CFDE 60DC                       		bra.s	.exit
0001CFE0                            ; ===========================================================================
0001CFE0                            ; ---------------------------------------------------------------------------
0001CFE0                            ; Tracker command for enabling LFO
0001CFE0                            ; ---------------------------------------------------------------------------
0001CFE0                            
0001CFE0                            dcsLFO:
0001CFE0 7000                       		moveq	#0,d0
0001CFE2 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CFE6 224E                       		move.l	a6,a1			; load voice table to a1
0001CFE8                            
0001CFE8                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001CFE8 EB48                     M 	lsl.w	#5,d0
0001CFEA 0640 0009                M 	add.w	#9,d0
0001CFEE D2C0                     M 	add.w	d0,a1
0001CFF0 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
0001CFF2 45FA F0E0                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001CFF6 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001CFF8                            
0001CFF8                            .decayloop
0001CFF8 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001CFFA 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001CFFC                            
0001CFFC D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
0001CFFE 6400                       		bcc.s	.noLFO			; if not, skip
0001D000 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001D004 4EBA F3C6                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001D008                            
0001D008                            .noLFO
0001D008 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001D00C                            
0001D00C 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001D00E 7022                       		moveq	#$22,d0			; YM command: LFO
0001D010 4EBA F3C6                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001D014                            
0001D014 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001D016 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
0001D01A                            
0001D01A 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001D01C 4EFA F3A8                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001D020                            ; ===========================================================================
0001D020                            ; ---------------------------------------------------------------------------
0001D020                            ; Tracker command for resetting condition
0001D020                            ; ---------------------------------------------------------------------------
0001D020                            
0001D020                            dcResetCond:
0001D020 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001D024 4E75                       		rts
0001D026                            ; ===========================================================================
0001D026                            ; ---------------------------------------------------------------------------
0001D026                            ; Tracker command for writing to communications flags
0001D026                            ; ---------------------------------------------------------------------------
0001D026                            
0001D026                            dcsComm:
0001D026 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D02A 7000                       		moveq	#0,d0
0001D02C 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001D02E 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001D032 4E75                       		rts
0001D034                            ; ===========================================================================
0001D034                            ; ---------------------------------------------------------------------------
0001D034                            ; RAM addresses for special condition code
0001D034                            ; ---------------------------------------------------------------------------
0001D034                            
0001D034                            dcCondRegTable:
0001D034 C744 C4A6                  	dc.w rHWVersion, mFlags	; 0
0001D038 C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
0001D03C 0000 0000                  	dc.w 0, 0			; 4
0001D040 0000 0000                  	dc.w 0, 0			; 6
0001D044 0000 0000                  	dc.w 0, 0			; 8
0001D048 0000 0000                  	dc.w 0, 0			; $A
0001D04C 0000 0000                  	dc.w 0, 0			; $C
0001D050 0000 0001                  	dc.w 0, cType			; $E
0001D054                            ; ===========================================================================
0001D054                            ; ---------------------------------------------------------------------------
0001D054                            ; Tracker command for checking special RAM addresses
0001D054                            ; ---------------------------------------------------------------------------
0001D054                            
0001D054                            dcCondReg:
0001D054 101C                       		move.b	(a4)+,d0		; get value from tracker
0001D056 1200                       		move.b	d0,d1			; copy to d1
0001D058                            
0001D058 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
0001D05C D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001D05E 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001D062 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
0001D064 D04D                       		add.w	a5,d0			; else it was a channel offset
0001D066                            
0001D066                            .gotit
0001D066 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
0001D068 1011                       		move.b	(a1),d0			; read byte from it
0001D06A 6000                       		bra.s	dcCondCom
0001D06C                            ; ===========================================================================
0001D06C                            ; ---------------------------------------------------------------------------
0001D06C                            ; Tracker command for checking communications bytes
0001D06C                            ; ---------------------------------------------------------------------------
0001D06C                            
0001D06C                            dcCond:
0001D06C 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D070 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001D072 1200                       		move.b	d0,d1			; copy to d1
0001D074 0240 000F                  		and.w	#$F,d0			; get offset only
0001D078 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
0001D07C                            
0001D07C                            dcCondCom:
0001D07C 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001D080 0241 00F0                  		and.w	#$F0,d1			; get condition value only
0001D084 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
0001D086 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
0001D088 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
0001D08C                            ; ===========================================================================
0001D08C                            ; ---------------------------------------------------------------------------
0001D08C                            ; Code for setting the condition flag
0001D08C                            ; ---------------------------------------------------------------------------
0001D08C                            
0001D08C                            .c	macro x
0001D08C                            	\x	.false
0001D08C                            	rts
0001D08C                                 endm
0001D08C                            
0001D08C                            .false
0001D08C 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001D090                            
0001D090 4E75                       .cond	rts		; T
0001D092 4E75                       	rts
0001D094                            	.c bra.s	; F
0001D094 60F6                     M 	bra.s	.false
0001D096 4E75                     M 	rts
0001D098                            	.c bls.s	; HI
0001D098 63F2                     M 	bls.s	.false
0001D09A 4E75                     M 	rts
0001D09C                            	.c bhi.s	; LS
0001D09C 62EE                     M 	bhi.s	.false
0001D09E 4E75                     M 	rts
0001D0A0                            	.c blo.s	; HS/CC
0001D0A0 65EA                     M 	blo.s	.false
0001D0A2 4E75                     M 	rts
0001D0A4                            	.c bhs.s	; LO/CS
0001D0A4 64E6                     M 	bhs.s	.false
0001D0A6 4E75                     M 	rts
0001D0A8                            	.c beq.s	; NE
0001D0A8 67E2                     M 	beq.s	.false
0001D0AA 4E75                     M 	rts
0001D0AC                            	.c bne.s	; EQ
0001D0AC 66DE                     M 	bne.s	.false
0001D0AE 4E75                     M 	rts
0001D0B0                            	.c bvs.s	; VC
0001D0B0 69DA                     M 	bvs.s	.false
0001D0B2 4E75                     M 	rts
0001D0B4                            	.c bvc.s	; VS
0001D0B4 68D6                     M 	bvc.s	.false
0001D0B6 4E75                     M 	rts
0001D0B8                            	.c bmi.s	; PL
0001D0B8 6BD2                     M 	bmi.s	.false
0001D0BA 4E75                     M 	rts
0001D0BC                            	.c bpl.s	; MI
0001D0BC 6ACE                     M 	bpl.s	.false
0001D0BE 4E75                     M 	rts
0001D0C0                            	.c blt.s	; GE
0001D0C0 6DCA                     M 	blt.s	.false
0001D0C2 4E75                     M 	rts
0001D0C4                            	.c bge.s	; LT
0001D0C4 6CC6                     M 	bge.s	.false
0001D0C6 4E75                     M 	rts
0001D0C8                            	.c ble.s	; GT
0001D0C8 6FC2                     M 	ble.s	.false
0001D0CA 4E75                     M 	rts
0001D0CC                            	.c bgt.s	; LE
0001D0CC 6EBE                     M 	bgt.s	.false
0001D0CE 4E75                     M 	rts
0001D0D0                            ; ===========================================================================
0001D0D0                            ; ---------------------------------------------------------------------------
0001D0D0                            ; Tracker command for freezing the CPU. DEBUG FLAG
0001D0D0                            ; ---------------------------------------------------------------------------
0001D0D0                            
0001D0D0                            ; ===========================================================================
0001D0D0                            ; ---------------------------------------------------------------------------
0001D0D0                            ; Check if a song is playing
0001D0D0                            ; ---------------------------------------------------------------------------
0001D0D0                            
0001D0D0                            dChkSongPlay:
0001D0D0 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
0001D0D4 7209                       	moveq	#Mus_Ch-1,d1
0001D0D6                            
0001D0D6                            .ChkTracks:
0001D0D6 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
0001D0D8 6B00                       	bmi.s	.Playing		; If so, branch
0001D0DA 43E9 002C                  	lea	cSize(a1),a1		; Next track
0001D0DE 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
0001D0E2 7200                       	moveq	#0,d1
0001D0E4 4E75                       	rts
0001D0E6                            
0001D0E6                            .Playing:
0001D0E6 50C1                       	st	d1
0001D0E8 4E75                       	rts
0001D0EA                            ; ===========================================================================
0001D0EA                            ; ---------------------------------------------------------------------------
0001D0EA                            ; Define music and SFX
0001D0EA                            ; ---------------------------------------------------------------------------
0001D0EA                            
0001D0EA                            	opt oz-				; disable zero-offset optimization
000C3988                            	list				; continue source listing
000C3988                            ; ===========================================================================
000C3988                            DualPCM:
000C3988                            		z80prog	0
000C3988                          M 	pusho
000C3988                          M 	opt	ae-
000C3988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_Fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_Fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000C54BF =00000000                M z80prg	=	0
000C54BF                          M 	mexit
000C54BF                            
000C54BF                            ; =========================================================================================================================================================
000C54BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            ; Error handler
000C54BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            		include	"Config/Error/error.asm"
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Vladikcomper's debugger
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            
000C54BF                            exBus	EQU	ICD_BLK
000C54BF                            exAddr	EQU	ICD_BLK
000C54BF                            exIll	EQU	ICD_BLK
000C54BF                            exDiv	EQU	ICD_BLK
000C54BF                            exChk	EQU	ICD_BLK
000C54BF                            Trapv	EQU	ICD_BLK
000C54BF                            exPriv	EQU	ICD_BLK
000C54BF                            exTrace	EQU	ICD_BLK
000C54BF                            exLineA	EQU	ICD_BLK
000C54BF                            exLineF	EQU	ICD_BLK
000C54BF                            exMisc	EQU	ICD_BLK
000C54BF                            
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; =========================================================================================================================================================
