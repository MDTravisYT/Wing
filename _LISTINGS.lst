00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000001                  DEBUG_BUILD	equ	1				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000001                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000001                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            		moveq	#0,d0
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	objExecFirst.w,a0				; load first object slot into a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	_objNext(a0),a0				; load the next object address to a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	#objDisplay+(\layer*dSize),_objDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	objDisplay+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	#objDisplay+(\layer*dSize),objDisplay+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	layer,_objDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	_objDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,_objDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	_objDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,_objDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            		move.w	_objDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	_objDrawNext(\obj),_objDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	_objDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	_objDrawPrev(\obj),_objDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            ;		cmp.w	_objDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,_objDrawNext(\fre)				; else, change to point to same address
00000000                            .no\@
00000000                            		clr.l	_objDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  _objPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  _objAddress	rs.l	1				; Pointer to object code
00000000 =00000004                  _objNext	rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  _objPrev	rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  _objDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  _objDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  _objFlags	rs.b	1				; Object flags
00000000 =0000000D                  _objRender	rs.b	1				; Render flags
00000000 =0000000E                  _objVRAM	rs.w	1				; Sprite tile properties
00000000 =00000010                  _objFrame	rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  _objMapping	rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  _objXPos	rs.l	1				; X position
00000000 =00000017                  _objDrawW	equ	__rs-1				; Sprite width
00000000 =00000018                  _objYPos	rs.l	1				; Y position
00000000 =0000001B                  _objDrawH	equ	__rs-1				; Sprite height
00000000 =0000001C                  _objXVel	rs.w	1				; X velocity
00000000 =0000001E                  _objYVel	rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  _objAnim	rs.b	1				; Animation ID
00000000 =00000021                  _objPrevAnim	rs.b	1				; Saved animation ID
00000000 =00000022                  _objAnimFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  _objAnimTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  _objSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  _objRoutine	rs.b	1				; Routine ID
00000000 =00000026                  _objRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  _objStatus	rs.b	1				; Status flags
00000000 =00000029                  _objShield	rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  _objDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  _objSize	rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objDynSSTs
00000000 =0000002A                  _objColType	rs.b	1				; Collision type
00000000 =0000002B                  _objColStat	rs.b	1				; Collision status
00000000 =0000002B                  _objHitCnt	equ	_objColStat			; Boss hit count
00000000 =0000002C                  _objColW	rs.b	1				; Collision width
00000000 =0000002D                  _objColH	rs.b	1				; Collision height
00000000 =0000002E                  _objNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  _objTilt	rs.b	1				; Tilt value
00000000 =00000030                  _objLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  _objSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  _objSubCnt	rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  _objSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            _objSub\$ct\XPos	rs.w	1			; Sub sprite X position
00000000                            _objSub\$ct\YPos	rs.w	1			; Sub sprite Y position
00000000                            _objSub\$ct\Free	rs.b	1			; Sub sprite free byte
00000000                            _objSub\$ct\Frame	rs.b	1			; Sub sprite mapping frame
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M _objsub0xpos	rs.w	1
00000000 =00000032                M _objsub0ypos	rs.w	1
00000000 =00000034                M _objsub0free	rs.b	1
00000000 =00000035                M _objsub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M _objsub1xpos	rs.w	1
00000000 =00000038                M _objsub1ypos	rs.w	1
00000000 =0000003A                M _objsub1free	rs.b	1
00000000 =0000003B                M _objsub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M _objsub2xpos	rs.w	1
00000000 =0000003E                M _objsub2ypos	rs.w	1
00000000 =00000040                M _objsub2free	rs.b	1
00000000 =00000041                M _objsub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M _objsub3xpos	rs.w	1
00000000 =00000044                M _objsub3ypos	rs.w	1
00000000 =00000046                M _objsub3free	rs.b	1
00000000 =00000047                M _objsub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M _objsub4xpos	rs.w	1
00000000 =0000004A                M _objsub4ypos	rs.w	1
00000000 =0000004C                M _objsub4free	rs.b	1
00000000 =0000004D                M _objsub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M _objsub5xpos	rs.w	1
00000000 =00000050                M _objsub5ypos	rs.w	1
00000000 =00000052                M _objsub5free	rs.b	1
00000000 =00000053                M _objsub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M _objsub6xpos	rs.w	1
00000000 =00000056                M _objsub6ypos	rs.w	1
00000000 =00000058                M _objsub6free	rs.b	1
00000000 =00000059                M _objsub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M _objsub7xpos	rs.w	1
00000000 =0000005C                M _objsub7ypos	rs.w	1
00000000 =0000005E                M _objsub7free	rs.b	1
00000000 =0000005F                M _objsub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset _objDrawPrev-6			; this awkward thing will make dPrev == _objDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	_objSize
00000000                            curobj_size		=	curobj_size+_objSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  miscBuff	rs.b	0				; General buffer
00000000 =00FF0000                  chunkData	rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  miscBuff_End	rs.b	0
00000000                            
00000000                            		rsset	RAM_WORD_START
00000000                            
00000000 =FFFF8000                  kosMBuff	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  dmaQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  dmaSlot		rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  hScrollBuff	rs.b	$380				; HScroll table
00000000 =FFFF947E                  hScrollBuff_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  vScrollBuff	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  vScrollBuff_End	rs.b	0				; ''
00000000 =FFFF947E                  vScrollBuffFG	EQU	vScrollBuff			; VScroll foreground value
00000000 =FFFF9480                  vScrollBuffBG	EQU	vScrollBuff+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  spriteBuff	rs.b	$280				; Sprite table
00000000 =FFFF974E                  spriteBuff_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;palFadeBuffAlt	equ	spriteBuff_End-$100		; Target water palette buffer
00000000                            ;palFadeBuff	equ	spriteBuff_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  palFadeBuffAlt	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  palFadeBuff	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  paletteBuffAlt	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  paletteBuff	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  kosVars		rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  kosCount	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  kosRegisters	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  kosStatusReg	rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  kosBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  kosList		rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  kosSource	equ	kosList				; ''
00000000 =FFFF9974                  kosDestination	equ	kosList+4			; ''
00000000 =FFFF9990                  kosList_End	rs.b	0				; ''
00000000 =FFFF9990                  kosMModules	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  kosMLastSize	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  kosMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  kosMSource	equ	kosMList			; ''
00000000 =FFFF9998                  kosMDestination	equ	kosMList+4			; ''
00000000 =FFFF9A54                  kosMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  kosVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  objRespawn	rs.b	$300				; Object respawn table
00000000 =FFFF9D54                  objRespawn_End	rs.b	0				; ''
00000000                            
00000000 =FFFF9D54                  objMemory	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9D54                M robj_0	rs.b	_objsize
00000000 =00000060                M curobj_size	=	curobj_size+_objsize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_1	rs.b	_objsize
00000000 =000000C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_2	rs.b	_objsize
00000000 =00000120                M curobj_size	=	curobj_size+_objsize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_3	rs.b	_objsize
00000000 =00000180                M curobj_size	=	curobj_size+_objsize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_4	rs.b	_objsize
00000000 =000001E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_5	rs.b	_objsize
00000000 =00000240                M curobj_size	=	curobj_size+_objsize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_6	rs.b	_objsize
00000000 =000002A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_7	rs.b	_objsize
00000000 =00000300                M curobj_size	=	curobj_size+_objsize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_8	rs.b	_objsize
00000000 =00000360                M curobj_size	=	curobj_size+_objsize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_9	rs.b	_objsize
00000000 =000003C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_a	rs.b	_objsize
00000000 =00000420                M curobj_size	=	curobj_size+_objsize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_b	rs.b	_objsize
00000000 =00000480                M curobj_size	=	curobj_size+_objsize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_c	rs.b	_objsize
00000000 =000004E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_d	rs.b	_objsize
00000000 =00000540                M curobj_size	=	curobj_size+_objsize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_e	rs.b	_objsize
00000000 =000005A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_f	rs.b	_objsize
00000000 =00000600                M curobj_size	=	curobj_size+_objsize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_10	rs.b	_objsize
00000000 =00000660                M curobj_size	=	curobj_size+_objsize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_11	rs.b	_objsize
00000000 =000006C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_12	rs.b	_objsize
00000000 =00000720                M curobj_size	=	curobj_size+_objsize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_13	rs.b	_objsize
00000000 =00000780                M curobj_size	=	curobj_size+_objsize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_14	rs.b	_objsize
00000000 =000007E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_15	rs.b	_objsize
00000000 =00000840                M curobj_size	=	curobj_size+_objsize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_16	rs.b	_objsize
00000000 =000008A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_17	rs.b	_objsize
00000000 =00000900                M curobj_size	=	curobj_size+_objsize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_18	rs.b	_objsize
00000000 =00000960                M curobj_size	=	curobj_size+_objsize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_19	rs.b	_objsize
00000000 =000009C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_1a	rs.b	_objsize
00000000 =00000A20                M curobj_size	=	curobj_size+_objsize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_1b	rs.b	_objsize
00000000 =00000A80                M curobj_size	=	curobj_size+_objsize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_1c	rs.b	_objsize
00000000 =00000AE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_1d	rs.b	_objsize
00000000 =00000B40                M curobj_size	=	curobj_size+_objsize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_1e	rs.b	_objsize
00000000 =00000BA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_1f	rs.b	_objsize
00000000 =00000C00                M curobj_size	=	curobj_size+_objsize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_20	rs.b	_objsize
00000000 =00000C60                M curobj_size	=	curobj_size+_objsize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_21	rs.b	_objsize
00000000 =00000CC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_22	rs.b	_objsize
00000000 =00000D20                M curobj_size	=	curobj_size+_objsize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_23	rs.b	_objsize
00000000 =00000D80                M curobj_size	=	curobj_size+_objsize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_24	rs.b	_objsize
00000000 =00000DE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_25	rs.b	_objsize
00000000 =00000E40                M curobj_size	=	curobj_size+_objsize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_26	rs.b	_objsize
00000000 =00000EA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_27	rs.b	_objsize
00000000 =00000F00                M curobj_size	=	curobj_size+_objsize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_28	rs.b	_objsize
00000000 =00000F60                M curobj_size	=	curobj_size+_objsize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_29	rs.b	_objsize
00000000 =00000FC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_2a	rs.b	_objsize
00000000 =00001020                M curobj_size	=	curobj_size+_objsize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_2b	rs.b	_objsize
00000000 =00001080                M curobj_size	=	curobj_size+_objsize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_2c	rs.b	_objsize
00000000 =000010E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_2d	rs.b	_objsize
00000000 =00001140                M curobj_size	=	curobj_size+_objsize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_2e	rs.b	_objsize
00000000 =000011A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_2f	rs.b	_objsize
00000000 =00001200                M curobj_size	=	curobj_size+_objsize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_30	rs.b	_objsize
00000000 =00001260                M curobj_size	=	curobj_size+_objsize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_31	rs.b	_objsize
00000000 =000012C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_32	rs.b	_objsize
00000000 =00001320                M curobj_size	=	curobj_size+_objsize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_33	rs.b	_objsize
00000000 =00001380                M curobj_size	=	curobj_size+_objsize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_34	rs.b	_objsize
00000000 =000013E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_35	rs.b	_objsize
00000000 =00001440                M curobj_size	=	curobj_size+_objsize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_36	rs.b	_objsize
00000000 =000014A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_37	rs.b	_objsize
00000000 =00001500                M curobj_size	=	curobj_size+_objsize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_38	rs.b	_objsize
00000000 =00001560                M curobj_size	=	curobj_size+_objsize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_39	rs.b	_objsize
00000000 =000015C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_3a	rs.b	_objsize
00000000 =00001620                M curobj_size	=	curobj_size+_objsize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_3b	rs.b	_objsize
00000000 =00001680                M curobj_size	=	curobj_size+_objsize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_3c	rs.b	_objsize
00000000 =000016E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_3d	rs.b	_objsize
00000000 =00001740                M curobj_size	=	curobj_size+_objsize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_3e	rs.b	_objsize
00000000 =000017A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_3f	rs.b	_objsize
00000000 =00001800                M curobj_size	=	curobj_size+_objsize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_40	rs.b	_objsize
00000000 =00001860                M curobj_size	=	curobj_size+_objsize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_41	rs.b	_objsize
00000000 =000018C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_42	rs.b	_objsize
00000000 =00001920                M curobj_size	=	curobj_size+_objsize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_43	rs.b	_objsize
00000000 =00001980                M curobj_size	=	curobj_size+_objsize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_44	rs.b	_objsize
00000000 =000019E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_45	rs.b	_objsize
00000000 =00001A40                M curobj_size	=	curobj_size+_objsize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_46	rs.b	_objsize
00000000 =00001AA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_47	rs.b	_objsize
00000000 =00001B00                M curobj_size	=	curobj_size+_objsize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_48	rs.b	_objsize
00000000 =00001B60                M curobj_size	=	curobj_size+_objsize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_49	rs.b	_objsize
00000000 =00001BC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_4a	rs.b	_objsize
00000000 =00001C20                M curobj_size	=	curobj_size+_objsize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_4b	rs.b	_objsize
00000000 =00001C80                M curobj_size	=	curobj_size+_objsize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_4c	rs.b	_objsize
00000000 =00001CE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_4d	rs.b	_objsize
00000000 =00001D40                M curobj_size	=	curobj_size+_objsize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_4e	rs.b	_objsize
00000000 =00001DA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_4f	rs.b	_objsize
00000000 =00001E00                M curobj_size	=	curobj_size+_objsize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_50	rs.b	_objsize
00000000 =00001E60                M curobj_size	=	curobj_size+_objsize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_51	rs.b	_objsize
00000000 =00001EC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_52	rs.b	_objsize
00000000 =00001F20                M curobj_size	=	curobj_size+_objsize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_53	rs.b	_objsize
00000000 =00001F80                M curobj_size	=	curobj_size+_objsize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_54	rs.b	_objsize
00000000 =00001FE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_55	rs.b	_objsize
00000000 =00002040                M curobj_size	=	curobj_size+_objsize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_56	rs.b	_objsize
00000000 =000020A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_57	rs.b	_objsize
00000000 =00002100                M curobj_size	=	curobj_size+_objsize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBE54                M robj_58	rs.b	_objsize
00000000 =00002160                M curobj_size	=	curobj_size+_objsize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBEB4                M robj_59	rs.b	_objsize
00000000 =000021C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBF14                M robj_5a	rs.b	_objsize
00000000 =00002220                M curobj_size	=	curobj_size+_objsize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBF74                M robj_5b	rs.b	_objsize
00000000 =00002280                M curobj_size	=	curobj_size+_objsize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBFD4                M robj_5c	rs.b	_objsize
00000000 =000022E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFC034                M robj_5d	rs.b	_objsize
00000000 =00002340                M curobj_size	=	curobj_size+_objsize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFC094                M robj_5e	rs.b	_objsize
00000000 =000023A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFC0F4                M robj_5f	rs.b	_objsize
00000000 =00002400                M curobj_size	=	curobj_size+_objsize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFC154                  objMemory_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(objMemory_End-objMemory)/_objSize
00000000                            
00000000 =FFFFC154                  objExecute	rs.b	0				; Object execution list variables (DO NOT REARRANGE THE ORDER OF THESE!)
00000000 =FFFFC154                  objExecExit	rs.l	1				; Pointer to a return intstruction that will exit object execution
00000000 =FFFFC158                  objExecFirst	rs.w	1				; Pointer to the first object to be executed in the list
00000000 =FFFFC15A                  objExecLast	rs.w	1				; Pointer to the last object to be executed in the list
00000000 =FFFFC15C                  objExecFree	rs.w	1				; Pointer to the next free slot in object memory
00000000 =FFFFC15E                  objExecute_End	rs.b	0
00000000                            
00000000 =FFFFC15A                  objDisplay	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFC19E                  objDisplay_End	rs.b	0				; 
00000000                            
00000000 =FFFFC19E                  fgRowBuff	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  fgColBuff	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  bgRowBuff	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  bgColBuff	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  ampsVars		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000 =FFFFC740                  msChktracker	rs.b 1		; safe mode only: If set, bring up debugger
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC742                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC742                  ctrlDataP1	rs.b	0				; Controller 1 data
00000000 =FFFFC742                  ctrlHoldP1	rs.b	1				; Controller 1 held button data
00000000 =FFFFC743                  ctrlPressP1	rs.b	1				; Controller 1 pressed button data
00000000                            
00000000 =FFFFC744                  ctrlDataP2	rs.b	0				; Controller 2 data
00000000 =FFFFC744                  ctrlHoldP2	rs.b	1				; Controller 2 held button data
00000000 =FFFFC745                  ctrlPressP2	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC746                  hwVersion	rs.b	1				; Hardware version
00000000 =FFFFC747                  vIntFlag	rs.b	0				; V-INT flag
00000000 =FFFFC747                  vIntRoutine	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC748                  palFadeVars	rs.b	0				; Palette fade properties
00000000 =FFFFC748                  palFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC749                  palFadeLength	rs.b	1				; Palette fade size
00000000 =FFFFC74A                  palFadeVars_End	rs.b	0
00000000                            
00000000 =FFFFC74A                  lagCounter	rs.b	1				; Lag frame counter
00000000 =FFFFC74B                  hIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74C                  vIntJump	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74E                  vIntAddress	rs.l	1				; V-INT address
00000000                            
00000000 =FFFFC752                  hIntJump	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC754                  hIntAddress	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC758                  frameCounter	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75C                  opmode		rs.b	1				; Game opmode ID
00000000 =FFFFC75D                  spriteCount	rs.b	1				; Sprite count
00000000 =FFFFC75E                  pauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75F                  hIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC760                  hIntCounter	rs.b	0
00000000 =FFFFC760                  hIntCntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC761                  hIntCntValue	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC762                  randomSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC766                  vdpReg1		rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC768                  vdpWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC76A                  moveCheat	rs.b	1
00000000 =FFFFC76B                  artCheat	rs.b	1
00000000                            
00000000 =FFFFC76C                  oscillators	rs.b	0				; Oscillation numbers
00000000 =FFFFC76C                  oscControl	rs.w	1				; Oscillation control
00000000 =FFFFC76E                  oscValues	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AE                  oscillators_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AE                  levelID		rs.b	0				; Level ID
00000000 =FFFFC7AE                  zoneID		rs.b	1				; Zone ID
00000000 =FFFFC7AF                  actID		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7B0                  checkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7B0                  chkIDLast	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B2                  chkSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B4                  chkSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B6                  checkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B6                  objManager	rs.b	0
00000000 =FFFFC7B6                  objMgrInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B7                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7B8                  objMgrLayout	rs.l	1				; Object position data pointer
00000000 =FFFFC7BC                  objMgrLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7C0                  objMgrLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C4                  objMgrRespR	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C6                  objMgrRespL	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C8                  objMgrCoarseX	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7CA                  objMgrCoarseY	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CC                  objMgrCameraX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CE                  objMgrCameraY	rs.w	1				; Object manager's camera Y position
00000000 =FFFFC7D0                  objManager_End	rs.b	0
00000000                            
00000000 =FFFFC7D0                  palCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7D1                  palCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D2                  opmodeVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  opmodeVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  stackSpace	rs.b	$100				; Stack space
00000000 =00000000                  stack		rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000 =FFFFC7D2                  blockData	rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD2                  ringStatus	rs.b	$400				; Ring status table
00000000 =FFFFE3D2                  ringStatus_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE3D2                  ringCollect	rs.b	0				; Ring collection table
00000000 =FFFFE3D2                  ringColCount	rs.w	1				; Ring collection count
00000000 =FFFFE3D4                  ringColList	rs.b	$7E				; Ring collection list
00000000 =FFFFE452                  ringCollect_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE452                  scrollSects	rs.b	$384				; Scroll sections
00000000 =FFFFE7D6                  scrollSects_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE7D6                  collideList	rs.b	$80				; Collision response list
00000000 =FFFFE856                  collideList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE856                  lvlLayout	rs.b	0				; Level layout ROM addresses
00000000 =FFFFE856                  lvlLayoutFG	rs.l	1				
00000000 =FFFFE85A                  lvlLayoutBG	rs.l	1				
00000000                            
00000000 =FFFFE85E                  ringCount	rs.w	1				; Ring count
00000000 =FFFFE860                  ringAnimFrame	rs.b	1				; Ring animation frame
00000000 =FFFFE861                  ringAnimTime	rs.b	1				; Ring animation timer
00000000                            
00000000 =FFFFE862                  ringLossAnimA	rs.w	1
00000000 =FFFFE864                  ringLossAnimT	rs.b	1
00000000 =FFFFE865                  ringLossAnimF	rs.b	1
00000000                            
00000000 =FFFFE866                  ringMgrRoutine	rs.b	1				; Ring manager routine
00000000 =FFFFE867                  hudUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFE868                  ringMgrLayout	rs.l	1				; Ring position data pointer
00000000 =FFFFE86C                  ringMgrLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFE870                  ringMgrLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFE874                  ringMgrStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFE876                  playerPtrP1	rs.w	1				; Player 1 object address
00000000 =FFFFE878                  shieldPtrP1	rs.w	1				; Player 1 shield address
00000000 =FFFFE87A                  invincPtrP1	rs.w	1				; Player 1 invincibility address
00000000 =FFFFE87C                  afterImgPtrP1	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFE87E                  playerPtrP2	rs.w	1				; Player 2 object address
00000000 =FFFFE880                  shieldPtrP2	rs.w	1				; Player 2 shield address
00000000 =FFFFE882                  invincPtrP2	rs.w	1				; Player 2 invincibility address
00000000 =FFFFE884                  afterImgPtrP2	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFE886                  waterObjPtr1	rs.w	1				; Water surface 1 address
00000000 =FFFFE888                  waterObjPtr2	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFE88A                  cameraVars	rs.b	0				; Camera RAM
00000000 =FFFFE88A                  fgCamVars	rs.b	cSize2				; Foreground variables
00000000 =FFFFE8A8                  bgCamVars	rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFE8C6                  targetMaxCamPos	rs.b	0				; Target maximum camera positions
00000000 =FFFFE8C6                  targetMaxCamX	rs.w	1				; Target maximum camera X position
00000000 =FFFFE8C8                  targetMaxCamY	rs.w	1				; Target maximum camera Y position
00000000                            
00000000 =FFFFE8CA                  maxCamPos	rs.b	0				; Maximum camera positions
00000000 =FFFFE8CA                  maxCamXPos	rs.w	1				; Maximum camera X position
00000000 =FFFFE8CC                  maxCamYPos	rs.w	1				; Maximum camera Y position
00000000                            
00000000 =FFFFE8CE                  targetMinCamPos	rs.b	0				; Target minimum camera positions
00000000 =FFFFE8CE                  targetMinCamX	rs.w	1				; Target minimum camera X position
00000000 =FFFFE8D0                  targetMinCamY	rs.w	1				; Target minimum camera Y position
00000000                            
00000000 =FFFFE8D2                  minCamPos	rs.b	0				; Minimum camera positions
00000000 =FFFFE8D2                  minCamXPos	rs.w	1				; Minimum camera X position
00000000 =FFFFE8D4                  minCamYPos	rs.w	1				; Minimum camera Y position
00000000                            
00000000 =FFFFE8D6                  panCamPos	rs.b	0
00000000 =FFFFE8D6                  panCamXPos	rs.w	1				; Camera X center
00000000 =FFFFE8D8                  panCamYPos	rs.w	1				; Distance from the player's Y position and the camera's
00000000                            
00000000 =FFFFE8DA                  camLocked	rs.b	0				; Camera locked flags
00000000 =FFFFE8DA                  camLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFE8DB                  camLockY	rs.b	1				; Camera locked vertically flag
00000000                            
00000000 =FFFFE8DC                  chgCamMaxY	rs.b	1				; Camera max Y position changing flag
00000000 =FFFFE8DD                  cameraVars_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFE8DD                  debugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFE8DE                  plrCtrlData	rs.b	0				; Player control data
00000000 =FFFFE8DE                  plrCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFE8DF                  plrCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFE8E0                  lvlMusic	rs.b	1				; Level music ID
00000000 =FFFFE8E1                  bossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFE8E2                  primaryColPtr	rs.l	1				; Primary level collision data pointer
00000000 =FFFFE8E6                  secondaryColPtr	rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFE8EA                  currentColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFE8EE                  layerPosition	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFE8F0                  angleValPtr	rs.l	1				; Angle value array pointer
00000000 =FFFFE8F4                  normColArrayPtr	rs.l	1				; Normal height map array pointer
00000000 =FFFFE8F8                  rotColArrayPtr	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFE8FC                  got_objNextLvl	rs.b	1				; Flag to go to the next level
00000000 =FFFFE8FD                  bossDefeated	rs.b	1
00000000                            
00000000 =FFFFE8FE                  lvlHasWater	rs.b	1				; Water in level flag
00000000 =FFFFE8FF                  waterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFE900                  waterYPos	rs.w	1				; Water height
00000000 =FFFFE902                  destWaterYPos	rs.w	1				; Target water height
00000000                            
00000000 =FFFFE904                  lvlFrameCnt	rs.w	1				; Level frame counter
00000000 =FFFFE906                  lvlReload	rs.b	1				; Level reload flag
00000000 =FFFFE907                  timeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFE908                  dynEventRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFE909                  rFlooactIDive	rs.b	1				; Floor active flag
00000000 =FFFFE90A                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFE90C                  lvlAnimCntrs	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFE88A                  fgCamXPos	equ	fgCamVars+cXPos			; Camera X position
00000000 =FFFFE892                  fgCamYPos	equ	fgCamVars+cYPos			; Camera Y position
00000000 =FFFFE8A8                  bgCamXPos	equ	bgCamVars+cXPos			; Background camera X position
00000000 =FFFFE8B0                  bgCamYPos	equ	bgCamVars+cYPos			; Background camera Y position
00000000 =FFFFE8A6                  fgRedraw	equ	fgCamVars+cRedraw		; Foreground redraw flag
00000000 =FFFFE8C4                  bgRedraw	equ	bgCamVars+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74C                  vInterrupt	equ	vIntJump			; V-INT
00000000 =FFFFC752                  hInterrupt	equ	hIntJump			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C752                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74C                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	stack.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C746                  		move.b	d0,hwVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74C                  		move.w	d0,vIntJump.w				; Set the "JMP" command for V-INT
000001F6 31C0 C752                  		move.w	d0,hIntJump.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74E        		move.l	#VInt_Standard,vIntAddress.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C754        		move.l	#HInt_Water,hIntAddress.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	dmaQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0000 C75C             		move.b	#gTitle,opmode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	TitleScreen					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75C                  		move.b	opmode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C766             		move.w	#$8134,vdpReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C760             		move.w	#$8AFF,hIntCntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	hScrollBuff, vScrollBuff_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"vscrollbuff_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(hscrollbuff).w,a1
0000027A 323C 00F3                M 	move.w	#(((vscrollbuff_end)-(hscrollbuff))-((hscrollbuff)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	dmaSlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#dmaSlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,dmaSlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#dmaSlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,dmaSlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	dmaQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,dmaSlot.w
000003B0                            
000003B0                            		rept (dmaSlot-dmaQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,dmaQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	dmaQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,dmaSlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (dmaSlot-dmaQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	paletteBuff.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	paletteBuffAlt.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000057C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
00000592 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000604 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
00000620 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000686 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000069C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000722 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000073E 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000786 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
000007B4 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
000007D0 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	spriteBuff.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C742                  	lea	ctrlDataP1.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	kosMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,kosMModules.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,kosMModules.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,kosMLastSize.w
00000FA0 31C2 9998                  		move.w	d2,kosMDestination.w
00000FA4 21C9 9994                  		move.l	a1,kosMSource.w
00000FA8 5238 9990                  		addq.b	#1,kosMModules.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	kosMModules.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(kosList_End-kosList)/8,kosCount.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	kosMList.w,a1
00000FC4 45F8 8000                  		lea	kosMBuff.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,kosMModules.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	kosCount.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,kosMModules.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,kosMModules.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	kosMLastSize.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	kosMDestination.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,kosMDestination.w		; Set new destination
00000FFE 2038 9994                  		move.l	kosMList.w,d0
00001002 2238 9970                  		move.l	kosList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,kosMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#kosMBuff,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	kosMModules.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	kosMList.w,a0
0000102A 43F8 999A                  		lea	(kosMList+6).w,a1
0000102E                            	rept (kosMList_End-kosMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	kosMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	kosMDestination.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	kosCount.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	kosList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,kosCount.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	kosCount.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),kosBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	kosCount.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,kosCount.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	kosList.w,a0
00001118 2278 9974                  		movea.l	kosDestination.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,kosList.w
000012E6 21C9 9974                  		move.l	a1,kosDestination.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,kosCount.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,kosCount.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	kosList.w,a0
000012FA 43F8 9978                  		lea	(kosList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (kosList_End-kosList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	kosRegisters.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(kosRegisters+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	kosBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	kosStatusReg.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,kosStatusReg.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,kosRegisters.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(kosRegisters+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C762                  		move.l	randomSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C762                  		move.l	d1,randomSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76C                  		lea	oscillators.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76C                  		lea	oscillators.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76C                  		move.w	d3,oscControl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	objRespawn,objMemory_End		; Clear respawn table and object memory
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"objmemory_end"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 9A54                M 	lea	(objrespawn).w,a1
000019C4 323C 09BF                M 	move.w	#(((objmemory_end)-(objrespawn))-((objrespawn)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC C154 C158             		move.w	#objExecExit,objExecFirst.w		; set the first object as the tail object
000019D4 31FC C154 C15A             		move.w	#objExecExit,objExecLast.w		; set the last object as the tail object
000019DA 21FC 0000 0000 C154        		move.l	#.rts,objExecExit.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9D54                  		lea	objMemory.w,a0			; load the objects list into a0
000019E6 31C8 C15C                  		move.w	a0,objExecFree.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#_objSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,_objPrev-_objSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	_objDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	_objPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 C156                  		lea	objDisplay-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 C15C                  		move.w	objExecFree.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 C15C             		move.w	_objPrev(a1),objExecFree.w		; copy the next free object pointer to list start
00001A2A                            
00001A2A 3478 C15A                  		move.w	objExecLast.w,a2			; load last object to a2
00001A2E 31C9 C15A                  		move.w	a1,objExecLast.w			; save as the new last object
00001A32 336A 0004 0004             		move.w	_objNext(a2),_objNext(a1)		; copy the next pointer from old tail to new object
00001A38 3549 0004                  		move.w	a1,_objNext(a2)			; save new object as next pointer for old tail
00001A3C 334A 0006                  		move.w	a2,_objPrev(a1)			; save old tail as prev pointer for new object
00001A40                            
00001A40                            .rts:
00001A40 4E75                       		rts
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; Delete another object
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; PARAMETERS:
00001A42                            ;	a1.l	- Pointer to object space to clear
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; RETURNS:
00001A42                            ;	a1.l	- Trashed
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            DeleteOtherObj:
00001A42 4850                       		pea	(a0)
00001A44 2049                       		move.l	a1,a0
00001A46 6100                       		bsr.s	DeleteObject
00001A48                            		pop.l	a0
00001A48 205F                     M 	move.l	(sp)+,a0
00001A4A 4E75                       		rts
00001A4C                            
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; Delete the current object
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; PARAMETERS:
00001A4C                            ;	Nothing
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; RETURNS:
00001A4C                            ;	a1.l	- Trashed
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            DeleteObject:
00001A4C                            	removeSprite	a0, a1, 1			; remove object display
00001A4C 4A68 0008                M 	tst.w	_objdrawnext(a0)
00001A50 6700                     M 	beq.s	.yes_67
00001A52 3268 000A                M 	move.w	_objdrawprev(a0),a1
00001A56 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00001A5C 3268 0008                M 	move.w	_objdrawnext(a0),a1
00001A60 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00001A66                          M .no_67
00001A66 42A8 0008                M 	clr.l	_objdrawnext(a0)
00001A6A                          M .yes_67
00001A6A 3268 0006                  		move.w	_objPrev(a0),a1			; copy previous pointer to a1
00001A6E 3368 0004 0004             		move.w	_objNext(a0),_objNext(a1)		; copy next pointer to previous object
00001A74 3268 0004                  		move.w	_objNext(a0),a1			; get next object to a1
00001A78 3368 0006 0006             		move.w	_objPrev(a0),_objPrev(a1)		; copy previous pointer
00001A7E                            
00001A7E 3178 C15C 0006             		move.w	objExecFree.w,_objPrev(a0)		; get the head of the free list to previous pointer of this object
00001A84 31C8 C15C                  		move.w	a0,objExecFree.w			; save as the new head of free list
00001A88                            
00001A88                            ; clear object memory
00001A88 7000                       		moveq	#0,d0				; clear d0
00001A8A 7214                       		moveq	#(((_objSize-_objDrawPrev)>>2)-1),d1	; set loop count
00001A8C                            
00001A8C 4852                       		pea	(a2)				; backup a2
00001A8E 45E8 000A                  		lea	_objDrawPrev(a0),a2		; load the first property to clear to a2
00001A92                            		
00001A92                            .clrLoop:
00001A92 24C0                       		move.l	d0,(a2)+			; clear a longword of the object slot's memory
00001A94 51C9 FFFC                  		dbf	d1,.clrLoop			; loop through to clear all object properties
00001A98                            
00001A98 34C0                       		move.w	d0,(a2)+			; clear the last word of data if the object ram per slot does not divide evenly by 4
00001A9A                            
00001A9A                            		pop.l	a2				; restore a2
00001A9A 245F                     M 	move.l	(sp)+,a2
00001A9C 4E75                       		rts
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; Render object sprites
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; PARAMETERS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; RETURNS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            RendeobjMemory:
00001A9E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001AA0 7C00                       		moveq	#0,d6				; Render flags
00001AA2                            
00001AA2 47F8 E88A                  		lea	fgCamVars.w,a3			; Foreground camera variables
00001AA6 4BF8 C15E                  		lea	objDisplay+dNext.w,a5	; Sprite input table
00001AAA 4DF8 94CE                  		lea	spriteBuff.w,a6			; Sprite table buffer
00001AAE                            
00001AAE 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Are we in level mode?
00001AB4                            ;		bne.s	.PrioLvlLoop			; If not, branch
00001AB4                            ;		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AB4                            
00001AB4                            .PrioLvlLoop:
00001AB4 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001AB6 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001AB8 4A68 0008                  		tst.w	_objDrawNext(a0)			; Is the next pointer for a valid object?
00001ABC 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AC0                            
00001AC0                            .ObjectLoop:
00001AC0                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AC0 4A90                       		tst.l	_objAddress(a0)			; Is this object slot used?
00001AC2 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AC6                            
00001AC6 0228 007F 000D             		andi.b	#$7F,_objRender(a0)		; Clear on-screen flag
00001ACC 1C28 000D                  		move.b	_objRender(a0),d6			; Store render flags
00001AD0 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00001AD4 3228 0018                  		move.w	_objYPos(a0),d1			; Get Y position
00001AD8                            
00001AD8 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001ADC 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001AE0 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001AE4 6700                       		beq.s	.Render				; If not, branch
00001AE6                            
00001AE6 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AE8 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AEC                            
00001AEC                            .Render:
00001AEC 7400                       		moveq	#0,d2
00001AEE 1428 0017                  		move.b	_objDrawW(a0),d2			; Get sprite width
00001AF2 3600                       		move.w	d0,d3				; Get sprite X position
00001AF4 D642                       		add.w	d2,d3				; Add width
00001AF6 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AF8 3600                       		move.w	d0,d3				; Get sprite X position
00001AFA 9642                       		sub.w	d2,d3				; Subtract width
00001AFC 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B00 6C00                       		bge.s	.NextObject			; If so, branch
00001B02 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B06                            
00001B06 7400                       		moveq	#0,d2
00001B08 1428 001B                  		move.b	_objDrawH(a0),d2			; Get sprite height
00001B0C 3601                       		move.w	d1,d3				; Get sprite Y position
00001B0E D642                       		add.w	d2,d3				; Add height
00001B10 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B12 3601                       		move.w	d1,d3				; Get sprite Y position
00001B14 9642                       		sub.w	d2,d3				; Subtract height
00001B16 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B1A 6C00                       		bge.s	.NextObject			; If so, branch
00001B1C 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B20                            
00001B20 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001B26 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B28 6B00                       		bmi.s	.NextObject			; If not, branch
00001B2A                            
00001B2A 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001B2E 6700                       		beq.s	.NextObject			; If blank, branch
00001B30 2244                       		movea.l	d4,a1				; Store it
00001B32 7800                       		moveq	#0,d4
00001B34 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B38 6600                       		bne.s	.Static				; If so, branch
00001B3A 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001B3E D844                       		add.w	d4,d4				; Turn into offset
00001B40 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B44 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B46 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B48 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B4A                            
00001B4A                            .Static:
00001B4A 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001B4E 6100 ED02                  		bsr.w	DrawSprite			; Draw the sprites
00001B52                            
00001B52                            .NextObject:	
00001B52 3068 0008                  		move.w	_objDrawNext(a0),a0		; Load next object to a0
00001B56 4A68 0008                  		tst.w	_objDrawNext(a0)			; Check the next pointer for valid object
00001B5A 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B5E                            
00001B5E                            .NextPrioLvl:
00001B5E BAFC C19E                  		cmpa.w	#objDisplay_End,a5		; Are we at the end of the input table?
00001B62 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B66                            
00001B66 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B68 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B6A 7000                       		moveq	#0,d0
00001B6C                            
00001B6C                            .FillRest:
00001B6C 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B6E 504E                       		addq.w	#8,a6				; Next sprite
00001B70 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B74                            
00001B74                            .SetDrawnSprites:
00001B74 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B78 4446                       		neg.w	d6				; ''
00001B7A 11C6 C75D                  		move.b	d6,spriteCount.w		; Store it
00001B7E                            
00001B7E 4E75                       		rts
00001B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B80                            .MultiDraw:
00001B80 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B84 6700                       		beq.s	.RenderMain			; If not, branch
00001B86                            
00001B86 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B88 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B8C                            
00001B8C                            .RenderMain:
00001B8C 7400                       		moveq	#0,d2
00001B8E 1428 0017                  		move.b	_objDrawW(a0),d2			; Get main sprite width
00001B92 3600                       		move.w	d0,d3				; Get main sprite X position
00001B94 D642                       		add.w	d2,d3				; Add width
00001B96 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B98 3600                       		move.w	d0,d3				; Get main sprite X position
00001B9A 9642                       		sub.w	d2,d3				; Subtract width
00001B9C 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BA0 6CB0                       		bge.s	.NextObject			; If so, branch
00001BA2 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BA6                            
00001BA6 1428 001B                  		move.b	_objDrawH(a0),d2			; Get main sprite height
00001BAA 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BAC D642                       		add.w	d2,d3				; Add height
00001BAE 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BB0 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BB2 9642                       		sub.w	d2,d3				; Subtract height
00001BB4 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BB8 6C98                       		bge.s	.NextObject			; If so, branch
00001BBA 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BBE                            
00001BBE 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001BC4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BC6 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BCA                            
00001BCA 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001BCE 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001BD2 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BD6 2444                       		movea.l	d4,a2				; Store it
00001BD8 7800                       		moveq	#0,d4
00001BDA 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001BDE D844                       		add.w	d4,d4				; Turn into offset
00001BE0 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BE2 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BE6 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BE8 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BEA 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BEC 3606                       		move.w	d6,d3				; Store render flags
00001BEE 6100 ED46                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BF2 3C03                       		move.w	d3,d6				; Restore render flags
00001BF4                            
00001BF4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BF6 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BFA                            
00001BFA                            .RenderSubSprites:
00001BFA 3628 002E                  		move.w	_objSubCnt(a0),d3			; Get sub sprite count
00001BFE 5343                       		subq.w	#1,d3				; Subtract 1
00001C00 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C04 41E8 0030                  		lea	_objSubStart(a0),a0		; Get sub sprite SSTs start
00001C08                            
00001C08                            .RenderSubSprs_Loop:
00001C08 3018                       		move.w	(a0)+,d0			; Get X position
00001C0A 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C0E 3218                       		move.w	(a0)+,d1			; Get Y position
00001C10 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C14                            
00001C14 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C18 6700                       		beq.s	.RenderSub			; If not, branch
00001C1A                            
00001C1A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C1C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C20                            
00001C20                            .RenderSub:
00001C20 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C22 D844                       		add.w	d4,d4				; Turn into offset
00001C24 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C26 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C2A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C2C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C2E 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C30                            		push.w	d6				; Store render flags
00001C30 3F06                     M 	move.w	d6,-(sp)
00001C32 6100 ED02                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C36                            		pop.w	d6				; Restore render flags
00001C36 3C1F                     M 	move.w	(sp)+,d6
00001C38                            
00001C38                            .RenderSubSprs_ChkLoop:
00001C38 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C3A 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C3E 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; Animate an object's sprite
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; PARAMETERS:
00001C42                            ;	a0.l	- Object space pointer
00001C42                            ;	a1.l	- Animation script pointer
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; RETURNS:
00001C42                            ;	Nothing
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            AnimateObject:
00001C42 7000                       		moveq	#0,d0
00001C44 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00001C48 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00001C4C 6700                       		beq.s	.Run				; If not, branch
00001C4E 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00001C52 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C56 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001C5A                            
00001C5A                            .Run:
00001C5A 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00001C5E 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C60 D040                       		add.w	d0,d0				; Turn ID into offset
00001C62 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C66 1151 0023                  		move.b	(a1),_objAnimTimer(a0)		; Set new animation timer
00001C6A                            
00001C6A 7200                       		moveq	#0,d1
00001C6C 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00001C70 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C74 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C78 6400                       		bhs.s	.CmdReset			; If so, branch
00001C7A                            
00001C7A                            .Next:
00001C7A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00001C7E 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00001C82 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C86 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00001C8C 8128 000D                  		or.b	d0,_objRender(a0)			; Set flip bits
00001C90 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00001C94                            
00001C94                            .Wait:
00001C94 4E75                       		rts
00001C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C96                            .CmdReset:
00001C96 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C98 6600                       		bne.s	.CmdJump			; If not, branch
00001C9A 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C9E 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CA2 60D6                       		bra.s	.Next				; Continue
00001CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA4                            .CmdJump:
00001CA4 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CA6 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CA8 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CAC 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00001CB0 9200                       		sub.b	d0,d1				; ''
00001CB2 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CB6 60C2                       		bra.s	.Next				; Continue
00001CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB8                            .CmdSetAnim:
00001CB8 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CBA 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CBC 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00001CC2 4E75                       		rts
00001CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC4                            .CmdNextRout:
00001CC4 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CC6 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CC8 5428 0025                  		addq.b	#2,_objRoutine(a0)			; Next routine
00001CCC 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CD0 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next animation frame
00001CD4 4E75                       		rts
00001CD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CD6                            .CmdReset2ndRout:
00001CD6 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CD8 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CDA 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CDE                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001CDE 4E75                       		rts
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            .CmdNext2ndRout:
00001CE0 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001CE2 6600                       		bne.s	.CmdEnd				; If not, branch
00001CE4                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001CE4 4E75                       		rts
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            .CmdEnd:
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; Load object DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; PARAMETERS:
00001CE8                            ;	d4.w	- Target VRAM address
00001CE8                            ;	d6.l	- Pointer to uncompressed art
00001CE8                            ;	a2.l	- Pointer to DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; RETURNS:
00001CE8                            ;	Nothing
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            LoadObjDPLCs:
00001CE8 7000                       		moveq	#0,d0
00001CEA 1028 0010                  		move.b	_objFrame(a0),d0			; Get mapping frame
00001CEE B010                       		cmp.b	_objPrevDPLC(a0),d0		; Do we need to update the art?
00001CF0 6700                       		beq.s	.End				; If not, branch
00001CF2 1080                       		move.b	d0,_objPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CF4 D040                       		add.w	d0,d0				; Turn ID into offset
00001CF6 D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CFA 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CFC 5345                       		subq.w	#1,d5				; Subtract 1
00001CFE 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D00                            
00001D00                            .ReadEntries:
00001D00 7200                       		moveq	#0,d1
00001D02 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D04 3601                       		move.w	d1,d3				; Copy that
00001D06 E04B                       		lsr.w	#8,d3				; Get tile count
00001D08 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D0C 0643 0010                  		addi.w	#$10,d3				; ''
00001D10 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D14 EB89                       		lsl.l	#5,d1				; ''
00001D16 D286                       		add.l	d6,d1				; Get pointer in art data
00001D18 3404                       		move.w	d4,d2				; Copy VRAM address
00001D1A D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D1C D843                       		add.w	d3,d4				; ''
00001D1E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D22 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D26                            
00001D26                            .End:
00001D26 4E75                       		rts
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; Move an object by it's velocity values
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; PARAMETERS:
00001D28                            ;	a0.l	- Object space pointer
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; RETURNS:
00001D28                            ;	Nothing
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ObjectMove:
00001D28 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D2C 48C0                       		ext.l	d0				; ''
00001D2E E188                       		lsl.l	#8,d0				; Shift
00001D30 D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D34 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D38 48C0                       		ext.l	d0				; ''
00001D3A E188                       		lsl.l	#8,d0				; Shift
00001D3C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D40 4E75                       		rts
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; Move an object by it's velocity values (with gravity)
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; PARAMETERS:
00001D42                            ;	a0.l	- Object space pointer
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; RETURNS:
00001D42                            ;	Nothing
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ObjectMoveAndFall:
00001D42 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D46 48C0                       		ext.l	d0				; ''
00001D48 E188                       		lsl.l	#8,d0				; Shift
00001D4A D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D4E 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D52 0668 000C 001E             		addi.w	#$0C,_objYVel(a0)			; Apply gravity
00001D58 48C0                       		ext.l	d0				; ''
00001D5A E188                       		lsl.l	#8,d0				; Shift
00001D5C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D60 4E75                       		rts
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; Check if a specific object is nearby
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; PARAMETERS:
00001D62                            ;	a0.l	- Current object space pointer
00001D62                            ;	a1.l	- Range data pointer
00001D62                            ;	a2.l	- Object to check's space pointer
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; RETURNS:
00001D62                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            CheckObjInRange:
00001D62 7000                       		moveq	#0,d0
00001D64 322A 0014                  		move.w	_objXPos(a2),d1			; Get other object's position
00001D68 342A 0018                  		move.w	_objYPos(a2),d2			; ''
00001D6C 3628 0014                  		move.w	_objXPos(a0),d3			; Get current object's position
00001D70 3828 0018                  		move.w	_objYPos(a0),d4			; ''
00001D74 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D76 3A03                       		move.w	d3,d5				; Copy
00001D78 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D7A D859                       		add.w	(a1)+,d4			; Get top boundary
00001D7C 3C04                       		move.w	d4,d6				; Copy
00001D7E DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D80 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D82 6500                       		blo.s	.End				; If not, branch
00001D84 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D86 6400                       		bhs.s	.End				; If not, branch
00001D88 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D8A 6500                       		blo.s	.End				; If not, branch
00001D8C B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D8E 6400                       		bhs.s	.End				; If not, branch
00001D90 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D92                            
00001D92                            .End:
00001D92 4E75                       		rts
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ; Object manager
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ObjectManager:
00001D94 4A38 C7B6                  		tst.b	objMgrInit.w
00001D98 6600                       		bne.s	ObjectManagerMain
00001D9A                            
00001D9A                            ObjectManagerInit:
00001D9A 50F8 C7B6                  		st	objMgrInit.w			; Set the init flag
00001D9E                            
00001D9E 2078 C7B8                  		movea.l	objMgrLayout.w,a0		; Get object data pointer
00001DA2 21C8 C7BC                  		move.l	a0,objMgrLoadR.w
00001DA6 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store address of object layout
00001DAA                            
00001DAA 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DAE                            
00001DAE 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Camera's X position
00001DB2 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DB6 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DB8 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DBA                            
00001DBA                            .NoReset:
00001DBA 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DBE                            
00001DBE 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DC2                            
00001DC2                            .ChkObjsLeft:
00001DC2 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DC4 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DC6 5C48                       		addq.w	#6,a0				; Next object
00001DC8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DCA 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DCC                            
00001DCC                            .ChkDone:
00001DCC 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001DD0 31CB C7C6                  		move.w	a3,objMgrRespL.w			; ''
00001DD4                            
00001DD4 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DD8                            
00001DD8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0
00001DDC 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001DE0 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001DE2                            
00001DE2                            .ChkObjsRight:
00001DE2 BC50                       		cmp.w	(a0),d6				; Compate object position
00001DE4 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001DE6 5C48                       		addq.w	#6,a0				; Next object
00001DE8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEA 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DEC                            
00001DEC                            .ChkDone2:
00001DEC 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001DF0 31CB C7C4                  		move.w	a3,objMgrRespR.w			; ''
00001DF4                            
00001DF4 31FC FFFF C7CC             		move.w	#-1,objMgrCameraX.w			; Reset manager's camera X position
00001DFA 3038 E892                  		move.w	fgCamYPos.w,d0			; Get camera's Y position
00001DFE 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E02 31C0 C7CE                  		move.w	d0,objMgrCameraY.w			; Store it so unnecessary Y checks shouldn't be done
00001E06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E06                            ObjectManagerMain:
00001E06 3238 E892                  		move.w	fgCamYPos.w,d1			; Get camera's Y position
00001E0A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E0E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E12 31C1 C7CA                  		move.w	d1,objMgrCoarseY.w		; Store this
00001E16                            
00001E16 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera's X position
00001E1A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E1E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E22 31C1 C7C8                  		move.w	d1,objMgrCoarseX.w		; Store this
00001E26                            		
00001E26 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E2C                            
00001E2C 3638 E892                  		move.w	fgCamYPos.w,d3			; Get camera's Y position
00001E30 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E34 3803                       		move.w	d3,d4				; Copy
00001E36 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E3A 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E3E 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E40 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E42                            
00001E42                            .SetNoWrap:
00001E42 3A3C 0FFF                  		move.w	#$FFF,d5
00001E46 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Get camera's X position
00001E4A 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E4E BC78 C7CC                  		cmp.w	objMgrCameraX.w,d6			; Check against last range
00001E52 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E56 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E58                            
00001E58 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001E5C                            
00001E5C 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001E60 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001E64                            
00001E64 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E68 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E6A                            
00001E6A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E6E 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E70                            
00001E70                            .LoadLoop:
00001E70 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E74 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E76 5D88                       		subq.l	#6,a0				; Get actual object address
00001E78 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E7A                            
00001E7A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E7E 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E80 5D88                       		subq.l	#6,a0
00001E82 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E84                            
00001E84                            .LoadFail:
00001E84 5C88                       		addq.l	#6,a0				; Undo object loading
00001E86 524B                       		addq.w	#1,a3
00001E88 6000                       		bra.s	.EndLoad
00001E8A                            .EndLoadRst:
00001E8A 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001E8E                            
00001E8E                            .EndLoad:
00001E8E 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001E92 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001E96                            
00001E96 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001E9A 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001E9E                            
00001E9E 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EA2                            
00001EA2                            .ChkLoop:
00001EA2 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001EA6 6E00                       		bgt.s	.ChkDone			; If so, branch
00001EA8 5D88                       		subq.l	#6,a0				; Get the object before this
00001EAA 534B                       		subq.w	#1,a3				; And its respawn index
00001EAC 60F4                       		bra.s	.ChkLoop			; Check next object
00001EAE                            
00001EAE                            .ChkDone:
00001EAE 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EB2 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EB6 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EB8                            Level_LoadObjs_Forward:
00001EB8 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001EBC                            
00001EBC 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001EC0 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001EC4                            
00001EC4 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EC8                            
00001EC8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001ECC 6700                       		beq.s	.EndLoad			; Branch if it failed
00001ECE                            
00001ECE                            .LoadLoop:
00001ECE BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001ED0 6300                       		bls.s	.EndLoadRst			; If not, branch
00001ED2 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001ED6 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001ED8 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EDA 60F2                       		bra.s	.LoadLoop
00001EDC                            
00001EDC                            .EndLoadRst:
00001EDC 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001EE0                            
00001EE0                            .EndLoad:
00001EE0 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EE4 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EE8                            
00001EE8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001EEC 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001EF0                            
00001EF0 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EF4 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EF6                            
00001EF6                            .ChkLoop:
00001EF6 BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EF8 6300                       		bls.s	.ChkDone			; If so, branch
00001EFA 5C88                       		addq.l	#6,a0				; Get the object before this
00001EFC 524B                       		addq.w	#1,a3				; And its respawn index
00001EFE 60F6                       		bra.s	.ChkLoop			; Check next object
00001F00                            
00001F00                            .ChkDone:
00001F00 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001F04 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F08                            Level_LoadObjs_SameXRange:
00001F08 3C38 E892                  		move.w	fgCamYPos.w,d6			; Get camera's X position
00001F0C 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F10 3606                       		move.w	d6,d3				; Copy
00001F12 BC78 C7CE                  		cmp.w	objMgrCameraY.w,d6			; Check against last range
00001F16 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F1A 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F1C                            
00001F1C 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F20 6B00 0000                  		bmi.w	.LoadEnd
00001F24 6000                       		bra.s	.YCheck
00001F26                            
00001F26                            .MovingDown:
00001F26 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F2A                            
00001F2A                            .YCheck:
00001F2A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F2E 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F30                            		
00001F30 3803                       		move.w	d3,d4				; Copy Y position
00001F32 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F36 3A3C 0FFF                  		move.w	#$FFF,d5
00001F3A                            
00001F3A 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001F3E 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001F42 2E38 C7BC                  		move.l	objMgrLoadR.w,d7			; Get current objects on the right side of the screen
00001F46 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F48 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F4A 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F4C                            
00001F4C                            .LoadNext:
00001F4C 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F4E 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F50                            
00001F50 3210                       		move.w	(a0),d1				; Get object's Y position
00001F52 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F54 B243                       		cmp.w	d3,d1
00001F56 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F58 B244                       		cmp.w	d4,d1
00001F5A 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F5C                            
00001F5C 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F60 3368 FFFE 0014             		move.w	-2(a0),_objXPos(a1)			; Set X position
00001F66 3210                       		move.w	(a0),d1				; Get object's Y position
00001F68 3401                       		move.w	d1,d2				; Copy it
00001F6A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F6C 3341 0018                  		move.w	d1,_objYPos(a1)			; Set Y position
00001F70                            
00001F70 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F72 0242 0003                  		andi.w	#3,d2				; ''
00001F76 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001F7A 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001F7E                            
00001F7E 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F82 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F84 D442                       		add.w	d2,d2
00001F86 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001F8A                            
00001F8A 1368 0003 0024             		move.b	3(a0),_objSubtype(a1)		; Set subtype
00001F90 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001F94                            
00001F94 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001F98 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F9A                            
00001F9A                            .LoadFail:
00001F9A 5C88                       		addq.l	#6,a0				; Next object
00001F9C 524B                       		addq.w	#1,a3				; ''
00001F9E 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FA0 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FA2                            
00001FA2                            .LoadEndRst:
00001FA2 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001FA6                            
00001FA6                            .LoadEnd:
00001FA6 31C6 C7CE                  		move.w	d6,objMgrCameraY.w		; Store manager's camera Y position
00001FAA 4E75                       		rts
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; Load an object from the object layout
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; PARAMETERS:
00001FAC                            ;	d3.w	- Upper boundary
00001FAC                            ;	d4.w	- Lower boundary
00001FAC                            ;	d5.w	- Y position limit
00001FAC                            ;	a0.l	- Index of object layout
00001FAC                            ;	a1.l	- Target object
00001FAC                            ;	a3.l	- Respawn table address
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            Level_LoadObject:
00001FAC 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FAE 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FB0 5C88                       		addq.l	#6,a0				; Next object
00001FB2 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FB4 4E75                       		rts
00001FB6                            
00001FB6                            .NotLoaded:
00001FB6 3E18                       		move.w	(a0)+,d7			; X position
00001FB8 3218                       		move.w	(a0)+,d1			; Y position
00001FBA 3401                       		move.w	d1,d2				; Copy
00001FBC 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FBE C245                       		and.w	d5,d1				; Keey Y in range
00001FC0 B243                       		cmp.w	d3,d1
00001FC2 6500                       		bcs.s	.End				; Branch if in range
00001FC4 B244                       		cmp.w	d4,d1
00001FC6 6300                       		bls.s	.Spawn				; Branch if in range
00001FC8                            
00001FC8                            .End:
00001FC8 5448                       		addq.w	#2,a0				; Next objeect
00001FCA 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FCC 4E75                       		rts
00001FCE                            
00001FCE                            .LoadNoY:
00001FCE C245                       		and.w	d5,d1				; Keey Y in range
00001FD0                            
00001FD0                            .Spawn:
00001FD0 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FD4 3347 0014                  		move.w	d7,_objXPos(a1)			; Store X position
00001FD8 3341 0018                  		move.w	d1,_objYPos(a1)			; Store Y position
00001FDC                            
00001FDC E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001FDE 0242 0003                  		andi.w	#3,d2				; ''
00001FE2 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001FE6 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001FEA                            
00001FEA 1418                       		move.b	(a0)+,d2			; Get ID
00001FEC D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FEE D442                       		add.w	d2,d2
00001FF0 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001FF4                            
00001FF4 1358 0024                  		move.b	(a0)+,_objSubtype(a1)		; Set subtype
00001FF8 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001FFC                            		
00001FFC 6000 FA1E                  		bra.w	FindFreeObj			; Find a free object slot
00002000                            		
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; Check if the object is in range on the camera. If it isn't, delete it
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; PARAMETERS:
00002000                            ;	a0.l	- Object space pointer
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; RETURNS:
00002000                            ;	Nothing
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            CheckObjActive:
00002000 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00002004                            
00002004                            CheckObjActive2:
00002004 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00002008 9078 C7C8                  		sub.w	objMgrCoarseX.w,d0		; Subtract the camera's coarse X position
0000200C 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002010 6200                       		bhi.s	.Delete				; If so, branch
00002012 4E75                       		rts
00002014                            
00002014                            .Delete:
00002014 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table entry address
00002018 6700                       		beq.s	.DoDelete			; If 0, branch
0000201A 3440                       		movea.w	d0,a2
0000201C 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002020                            
00002020                            .DoDelete:
00002020 4EF8 1A4C                  		jmp	DeleteObject.w			; Delete the object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Get orientation to player
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	a1.l	- Player object
00002024                            ;	d0.w	- 0 if player is left from object, 2 if right
00002024                            ;	d1.w	- 0 if player is above object, 2 if below
00002024                            ;	d2.w	- Player's horizontal distance to object
00002024                            ;	d3.w	- Player's vertical distance to object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            GetOrientToPlayer:
00002024 7000                       		moveq	#0,d0
00002026 7200                       		moveq	#0,d1
00002028                            
00002028 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get player object
0000202C                            
0000202C 3428 0014                  		move.w	_objXPos(a0),d2			; Get horizonal distance
00002030 9469 0014                  		sub.w	_objXPos(a1),d2			; ''
00002034 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00002036 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00002038                            
00002038                            .GetY:
00002038 3628 0018                  		move.w	_objYPos(a0),d3			; Get vertical distance
0000203C 9669 0018                  		sub.w	_objYPos(a1),d3			; ''
00002040 6400                       		bhs.s	.End				; Branch if the player is above the object
00002042 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002044                            
00002044                            .End:
00002044 4E75                       		rts
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; Cap an object's speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; PARAMETERS:
00002046                            ;	a0.l	- Object space pointer
00002046                            ;	d0.w	- Max X speed
00002046                            ;	d1.w	- Max Y speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; RETURNS:
00002046                            ;	Nothing
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            CapObjSpeed:
00002046 3428 001C                  		move.w	_objXVel(a0),d2			; Get X velocity
0000204A 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
0000204C 4440                       		neg.w	d0				; Get absolute speed
0000204E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002050 6400                       		bhs.s	.ChkUp				; If not, branch
00002052 3400                       		move.w	d0,d2				; Cap the speed
00002054 6000                       		bra.s	.ChkUp				; Continue
00002056                            
00002056                            .ChkRight:
00002056 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002058 6300                       		bls.s	.ChkUp				; If not, branch
0000205A 3400                       		move.w	d0,d2				; Cap the speed
0000205C                            
0000205C                            .ChkUp:
0000205C 3628 001E                  		move.w	_objYVel(a0),d3			; Get Y velocity
00002060 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002062 4441                       		neg.w	d1				; Get absolute speed
00002064 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002066 6400                       		bhs.s	.UpdateVel			; If not, branch
00002068 3601                       		move.w	d1,d3				; Cap the speed
0000206A 6000                       		bra.s	.UpdateVel			; Continue
0000206C                            
0000206C                            .ChkDown:
0000206C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000206E 6300                       		bls.s	.UpdateVel			; If not, branch
00002070 3601                       		move.w	d1,d3				; Cap the speed
00002072                            
00002072                            .UpdateVel:
00002072 3142 001C                  		move.w	d2,_objXVel(a0)			; Set X velocity
00002076 3142 001E                  		move.w	d2,_objYVel(a0)			; Set Y velocity
0000207A 4E75                       		rts
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; PARAMETERS:
0000207C                            ;	a2.l	- Object data
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; RETURNS:
0000207C                            ;	Nothing
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; LoadChildObject:
0000207C 6100 F99E                  		bsr.w	FindFreeObj			; Find a free object slot
00002080 6600                       		bne.s	.End				; If there is non, branch
00002082 301A                       		move.w	(a2)+,d0			; Get parent object SST
00002084 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002088 301A                       		move.w	(a2)+,d0			; Get child object SST
0000208A 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
0000208E 229A                       		move.l	(a2)+,_objAddress(a1)			; Set object pointer
00002090 135A 0024                  		move.b	(a2)+,_objSubtype(a1)		; Set subtype
00002094 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)			; Set X
0000209A 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)			; Set Y
000020A0                            
000020A0                            .End:
000020A0 4E75                       		rts
000020A2                            ; =========================================================================================================================================================
000020A2                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            ; Vertical Interrupts
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            VInt_Standard:
000020A2                            		intsOff					; Turn interrupts off
000020A2 007C 0700                M 	ori	#$700,sr
000020A6                            		push.l	d0-a6				; Save registers
000020A6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020AA                            		
000020AA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020B0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020B4                            
000020B4                            .WaitForVBLANK:
000020B4 3016                       		move.w	(a6),d0				; Get VDP status
000020B6 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020BA 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020BC                            
000020BC 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
000020C2 6700                       		beq.s	.SetVScroll			; If not, branch
000020C4 303C 0700                  		move.w	#$700,d0			; Do a delay
000020C8 51C8 FFFE                  		dbf	d0,*				; ''
000020CC                            
000020CC                            .SetVScroll:
000020CC                            		dma68k	vScrollBuff,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020CC 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020D2 2CBC 96CA 953F           M 	move.l	#$96009500|((((vscrollbuff)/2)&$ff00)<<8)|(((vscrollbuff)/2)&$ff),(a6)
000020D8 3CBC 977F                M 	move.w	#$9700|(((vscrollbuff)>>17)&$7f),(a6)
000020DC                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
000020DC 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000020E0                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
000020E0 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000020E4 3C9F                     M 	move.w	(sp)+,(a6)
000020E6                            
000020E6 4A38 C747                  		tst.b	vIntRoutine.w			; Is the game lagging?
000020EA 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
000020EE 4238 C74A                  		clr.b	lagCounter.w			; Clear lag frame counter
000020F2                            
000020F2 7000                       		moveq	#0,d0
000020F4 1038 C747                  		move.b	vIntRoutine.w,d0		; Get V-INT routine ID
000020F8 4238 C747                  		clr.b	vIntRoutine.w			; Clear V-INT routine ID
000020FC 50F8 C74B                  		st	hIntFlag.w			; Allow the H-INT to run
00002100 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002104 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002108                            
00002108                            VInt_FinishUpdates:
00002108 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0000210E                            
0000210E                            VInt_End:
0000210E 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002112 6100 F23A                  		bsr.w	RandomNumber			; Generate a random number
00002116                            		
00002116                            		pop.l	d0-a6				; Restore registers
00002116 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000211A                            		intsOn					; Turn interrupts on
0000211A 027C F8FF                M 	andi	#$f8ff,sr
0000211E                            		lagOn					; Turn on the lag-o-meter
0000211E 4E73                       		rte
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            ; V-INT routines
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            VInt_Routines:
00002120 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002122 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002124 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
00002126 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
00002128 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000212A 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            ; V-INT lag routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            VInt_Lag:
0000212C 584F                       		addq.w	#4,sp				; Don't return to caller
0000212E                            
0000212E                            VInt_Lag_Main:
0000212E 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002132 6600                       		bne.s	.WaterPal			; If so, branch
00002134                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002134 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000213A 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002140 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002144                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002144 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002148                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002148 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000214C 3C9F                     M 	move.w	(sp)+,(a6)
0000214E 6000                       		bra.s	.Cont				; Continue
00002150                            
00002150                            .WaterPal:
00002150                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002150 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002156 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000215C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002160                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002160 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002164                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002164 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002168 3C9F                     M 	move.w	(sp)+,(a6)
0000216A                            
0000216A                            .Cont:	
0000216A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000216E                            
0000216E 5238 C74A                  		addq.b	#1,lagCounter.w		; Increment lag counter
00002172 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            ; V-INT general routine
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            VInt_General:
00002176 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000217A 6000 EF5C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            ; V-INT level load routine
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            VInt_LevelLoad:
0000217E 6100 E93A                  		bsr.w	ReadJoypads			; Read joypads
00002182                            
00002182 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002186 6600                       		bne.s	.WaterPal			; If so, branch
00002188                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002188 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000218E 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002194 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002198                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002198 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000219C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000219C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021A0 3C9F                     M 	move.w	(sp)+,(a6)
000021A2 6000                       		bra.s	.Cont				; Continue
000021A4                            
000021A4                            .WaterPal:
000021A4                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
000021A4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021AA 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
000021B0 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
000021B4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021B4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021B8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021B8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021BC 3C9F                     M 	move.w	(sp)+,(a6)
000021BE                            
000021BE                            .Cont:
000021BE 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
000021C2                            		
000021C2                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000021C2 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021C8 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000021CE 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000021D2                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021D2 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021D6                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021D6 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021DA 3C9F                     M 	move.w	(sp)+,(a6)
000021DC                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000021DC 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000021E2 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
000021E8 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
000021EC                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000021EC 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000021F0                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000021F0 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000021F4 3C9F                     M 	move.w	(sp)+,(a6)
000021F6 6100 E1B0                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000021FA                            		
000021FA 6000 EEDC                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            ; V-INT level routine
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            VInt_Level:
000021FE 43F8 E88A                  		lea	fgCamVars.w,a1			; Foreground level drawing variables
00002202 47F8 C2A0                  		lea	fgColBuff.w,a3		; Foreground column plane buffer
00002206 49F8 C19E                  		lea	fgRowBuff.w,a4		; Foreground row plane buffer
0000220A 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002210 43F8 E8A8                  		lea	bgCamVars.w,a1			; Background level drawing variables
00002214 47F8 C424                  		lea	bgColBuff.w,a3		; Background column plane buffer
00002218 49F8 C322                  		lea	bgRowBuff.w,a4		; Background row plane buffer
0000221C 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002222                            
00002222 6100 E896                  		bsr.w	ReadJoypads			; Read joypads
00002226                            
00002226 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
0000222A 6600                       		bne.s	.WaterPal			; If so, branch
0000222C                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
0000222C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002232 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002238 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
0000223C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000223C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002240                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002240 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002244 3C9F                     M 	move.w	(sp)+,(a6)
00002246 6000                       		bra.s	.Cont				; Continue
00002248                            
00002248                            .WaterPal:
00002248                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002248 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000224E 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
00002254 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002258                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002258 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000225C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000225C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002260 3C9F                     M 	move.w	(sp)+,(a6)
00002262                            
00002262                            .Cont:
00002262 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
00002266                            
00002266                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
00002266 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000226C 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
00002272 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
00002276                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002276 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000227A                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000227A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
0000227E 3C9F                     M 	move.w	(sp)+,(a6)
00002280                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002280 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002286 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000228C 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
00002290                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002290 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002294                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002294 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002298 3C9F                     M 	move.w	(sp)+,(a6)
0000229A 6100 E10C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000229E                            		
0000229E 0C38 005C C761             		cmpi.b	#92,hIntCntValue.w		; Would V-INT be unable to do updates in the next frame?
000022A4 6400                       		bhs.s	.DoUpdates			; If not, branch
000022A6 50F8 C75F                  		st	hIntUpdates.W		; Set updates in H-INT flag
000022AA 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022AC 6100 EE2A                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022B0 6000 FE5C                  		bra.w	VInt_End			; Continue
000022B4                            
000022B4                            .DoUpdates:
000022B4 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022BA 6000 EE1C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            ; V-INT title screen update routine
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            VInt_Title:
000022BE 4E75                       		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ;		bsr.w	ReadJoypads			; Read joypads
000022C0                            ;
000022C0                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022C0                            ;		lea	paletteBuff.w,a0			; ''
000022C0                            ;		moveq	#$80>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WritePal:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WritePal			; ''
000022C0                            ;
000022C0                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022C0                            ;		lea	spriteBuff.w,a0			; ''
000022C0                            ;		move.w	#$280>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteSprs:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteSprs			; ''
000022C0                            ;
000022C0                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022C0                            ;		lea	hScrollBuff.w,a0			; ''
000022C0                            ;		move.w	#$380>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteHScrl:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteHScrl			; ''
000022C0                            ;		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ; Do standard updates in V-INT
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            VInt_Update:
000022C0                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022C0                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000022C0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022C6 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000022CC 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000022D0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022D0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022D4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022D4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022D8 3C9F                     M 	move.w	(sp)+,(a6)
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            ; V-INT fade routine
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            VInt_Fade:
000022DA 6100 E7DE                  		bsr.w	ReadJoypads			; Read joypads
000022DE                            
000022DE 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
000022E2 6600                       		bne.s	.WaterPal			; If so, branch
000022E4                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
000022E4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022EA 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022F4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022F8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE 6000                       		bra.s	.Cont				; Continue
00002300                            
00002300                            .WaterPal:
00002300                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002300 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002306 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000230C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002310                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002310 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002314                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002314 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002318 3C9F                     M 	move.w	(sp)+,(a6)
0000231A                            
0000231A                            .Cont:
0000231A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000231E                            
0000231E                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
0000231E 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002324 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000232A 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
0000232E                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
0000232E 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002332                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002332 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002336 3C9F                     M 	move.w	(sp)+,(a6)
00002338 6000 E06E                  		bra.w	ProcessDMAQueue			; Process DMA queue
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            ; V-INT routine that only runs the SMPS driver
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            VInt_RunSMPS:
0000233C                            		push.l	d0-a6				; Save registers
0000233C 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002340                            		
00002340                            .WaitForVBLANK:
00002340 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
00002346 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000234A 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
0000234C                            
0000234C 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
00002352 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002354 303C 0700                  		move.w	#$700,d0			; Do a delay
00002358 51C8 FFFE                  		dbf	d0,*				; ''
0000235C                            
0000235C                            .UpdateSMPS:
0000235C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002362                            
00002362 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002366 6100 EFE6                  		bsr.w	RandomNumber			; Generate a random number
0000236A                            		
0000236A                            		pop.l	d0-a6				; Restore registers
0000236A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000236E 4E73                       		rte
00002370                            
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; Wait for the vertical interrupt to run and finish
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; PARAMETERS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; RETURNS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            VSync:
00002370 50F8 C747                  		st	vIntFlag.w			; Set V-INT flag
00002374                            
00002374                            VSync_Routine:
00002374                            		intsOn					; Enable interrupts
00002374 027C F8FF                M 	andi	#$f8ff,sr
00002378                            		lagOff					; Turn off the lag-o-meter
00002378                            
00002378                            .Wait:
00002378 4A38 C747                  		tst.b	vIntFlag.w			; Has the V-INT run yet?
0000237C 66FA                       		bne.s	.Wait				; If not, wait some more
0000237E 4E75                       		rts
00002380                            
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            ; Horizontal interrupt for palette swapping (for water)
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            HInt_Water:
00002380                            		intsOff					; Disable interrupts
00002380 007C 0700                M 	ori	#$700,sr
00002384                            
00002384 4A38 C74B                  		tst.b	hIntFlag.w			; Is the H-INT allowed to run?
00002388 6700                       		beq.s	.End				; If not, branch
0000238A 4238 C74B                  		clr.b	hIntFlag.w			; Clear the H-INT flag
0000238E                            
0000238E                            		push.l	a0-a1				; Save registers
0000238E 48E7 00C0                M 	movem.l	a0-a1,-(sp)
00002392                            
00002392 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
00002398 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0000239E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette
000023A2                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023A2 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023AA                            		rept	32
000023AA                            			move.l	(a0)+,(a1)		; Tranfer palette
000023AA                            		endr
000023AA 2298                     M 	move.l	(a0)+,(a1)
000023AC 2298                     M 	move.l	(a0)+,(a1)
000023AE 2298                     M 	move.l	(a0)+,(a1)
000023B0 2298                     M 	move.l	(a0)+,(a1)
000023B2 2298                     M 	move.l	(a0)+,(a1)
000023B4 2298                     M 	move.l	(a0)+,(a1)
000023B6 2298                     M 	move.l	(a0)+,(a1)
000023B8 2298                     M 	move.l	(a0)+,(a1)
000023BA 2298                     M 	move.l	(a0)+,(a1)
000023BC 2298                     M 	move.l	(a0)+,(a1)
000023BE 2298                     M 	move.l	(a0)+,(a1)
000023C0 2298                     M 	move.l	(a0)+,(a1)
000023C2 2298                     M 	move.l	(a0)+,(a1)
000023C4 2298                     M 	move.l	(a0)+,(a1)
000023C6 2298                     M 	move.l	(a0)+,(a1)
000023C8 2298                     M 	move.l	(a0)+,(a1)
000023CA 2298                     M 	move.l	(a0)+,(a1)
000023CC 2298                     M 	move.l	(a0)+,(a1)
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA                            		pop.l	a0-a1				; Restore registers
000023EA 4CDF 0300                M 	movem.l	(sp)+,a0-a1
000023EE                            		
000023EE 4A38 C75F                  		tst.b	hIntUpdates.w		; Do we need to do level updates in here?
000023F2 6600                       		bne.s	.DoUpdates			; If so, branch
000023F4                            
000023F4                            .End:
000023F4 4E73                       		rte
000023F6                            
000023F6                            .DoUpdates:
000023F6 4238 C75F                  		clr.b	hIntUpdates.w		; Clear the update flag
000023FA                            		push.l	d0-a6				; Save registers
000023FA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023FE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002404 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002408 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
0000240E 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002414                            		pop.l	d0-a6				; Restore registers
00002414 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002418 4E73                       		rte
0000241A                            ; =========================================================================================================================================================
0000241A                            
0000241A                            ; =========================================================================================================================================================
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            ; Opmode Main Code
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            		include	"Opmodes/Title/Main.asm"
0000241A                            ; =========================================================================================================================================================
0000241A                            ; Title splash screen
0000241A                            ; =========================================================================================================================================================
0000241A                            locVRAM:	macro loc,controlport
0000241A                            		move.l	#($40000000+(((loc)&$3FFF)<<16)+(((loc)&$C000)>>14)),(VDP_CTRL).l
0000241A                            		endm
0000241A                            
0000241A                            copyTilemap:	macro source,destination,width,height
0000241A                            		lea	(source).l,a1
0000241A                            		locVRAM	destination,d0
0000241A                            		moveq	#width,d1
0000241A                            		moveq	#height,d2
0000241A                            		bsr.w	TilemapToVRAM
0000241A                            		endm
0000241A                            
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            TitleScreen:
0000241A                            		intsOff					; Disable interrupts
0000241A 007C 0700                M 	ori	#$700,sr
0000241E                            		clrRAM	kosVars
0000241E                          M 	local	endaddr
0000241E                          M endaddr	equs	"kosvars_End"
0000241E 7000                     M 	moveq	#0,d0
00002420 43F8 994E                M 	lea	(kosvars).w,a1
00002424 323C 0040                M 	move.w	#(((kosvars_end)-(kosvars))-((kosvars)&1))>>2-1,d1
00002428 22C0                     M .clear_132:	move.l	d0,(a1)+
0000242A 51C9 FFFC                M 	dbf	d1,.clear_132
0000242E 32C0                     M 	move.w	d0,(a1)+
00002430                            		clrRAM	checkpoint
00002430                          M 	local	endaddr
00002430                          M endaddr	equs	"checkpoint_End"
00002430 7000                     M 	moveq	#0,d0
00002432 43F8 C7B0                M 	lea	(checkpoint).w,a1
00002436 323C 0000                M 	move.w	#(((checkpoint_end)-(checkpoint))-((checkpoint)&1))>>2-1,d1
0000243A 22C0                     M .clear_133:	move.l	d0,(a1)+
0000243C 51C9 FFFC                M 	dbf	d1,.clear_133
00002440 32C0                     M 	move.w	d0,(a1)+
00002442                            		clrRAM	opmodeVars
00002442                          M 	local	endaddr
00002442                          M endaddr	equs	"opmodevars_End"
00002442 7000                     M 	moveq	#0,d0
00002444 43F8 C7D2                M 	lea	(opmodevars).w,a1
00002448 323C 0DCA                M 	move.w	#(((opmodevars_end)-(opmodevars))-((opmodevars)&1))>>2-1,d1
0000244C 22C0                     M .clear_134:	move.l	d0,(a1)+
0000244E 51C9 FFFC                M 	dbf	d1,.clear_134
00002452 32C0                     M 	move.w	d0,(a1)+
00002454                            		clrRAM	objMemory
00002454                          M 	local	endaddr
00002454                          M endaddr	equs	"objmemory_End"
00002454 7000                     M 	moveq	#0,d0
00002456 43F8 9D54                M 	lea	(objmemory).w,a1
0000245A 323C 08FF                M 	move.w	#(((objmemory_end)-(objmemory))-((objmemory)&1))>>2-1,d1
0000245E 22C0                     M .clear_135:	move.l	d0,(a1)+
00002460 51C9 FFFC                M 	dbf	d1,.clear_135
00002464                            
00002464                                    playSnd #Mus_Stop,  1
00002464 11FC 0003 C4BC           M 	move.b	#mus_stop,(mqueue+((1)-1)).w
0000246A 6100 E0E6                          bsr.w    FadeToBlack
0000246E 4BF9 00C0 0004             		lea	VDP_CTRL,a5
00002474 3ABC 8004                  		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00002478 3ABC 8174                  		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
0000247C 3ABC 8230                  		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002480 3ABC 8407                  		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00002484 3ABC 9011                  		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
00002488 3ABC 9200                  		move.w	#$9200,(a5)			; $9200 - Window V position at default
0000248C 3ABC 8B00                  		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002490 3ABC 8700                  		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00002494 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00002498 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
0000249E                            
0000249E 6100 DDA8                          bsr.w   ClearScreen
000024A2                            
000024A2 43F9 00FF 0000                     lea miscbuff,  a1
000024A8 41F9 0000 0000                     lea (Eni_SegaLogo).l,   a0
000024AE 303C 0000                          move.w  #0, d0
000024B2 6100 E91A                          bsr.w   EniDec
000024B6                            
000024B6 43F9 00FF 0000             		lea	miscbuff,a1
000024BC 203C 451C 0003             		move.l	#$451C0003,d0			; At (0, 0) on plane A
000024C2 720B                       		moveq	#$B,d1
000024C4 7403                       		moveq	#$3,d2
000024C6 7600                       		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000024C8 6100 DDBE                  		bsr.w	LoadPlaneMap
000024CC                            
000024CC 43F9 0000 0000             		lea	KosM_SegaLogo,a1		; Load background art
000024D2 343C 0000                  		move.w	#$0,d2				; ''
000024D6 6100 EA84                  		bsr.w	QueueKosMData			; ''
000024DA                                    
000024DA                            .WaitPLCs:
000024DA 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000024E0 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
000024E4 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
000024E8 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000024EC 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
000024F0 66E8                       		bne.s	.WaitPLCs			; If so, branch
000024F2                            
000024F2 41F9 0000 0000             		lea	WWZ_Pal,a0			; Load palette to target buffer
000024F8 303C 0000                  		move.w	#(WWZ_Pal_End-WWZ_Pal)>>1-1,d0
000024FC 6100 E03C                  		bsr.w	LoadTargetPal			; ''
00002500                            
00002500 6100 E0CC                          bsr.w   FadeFromBlack
00002504 13FC 003C 00FF 0000                move.b  #60,    miscbuff
0000250C                                .loop:
0000250C 11FC 0008 C747             		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00002512 6100 FE60                  		bsr.w	VSync_Routine			; ''
00002516 5339 00FF 0000                     sub.b   #1, miscbuff
0000251C 4A39 00FF 0000                     tst.b   miscbuff
00002522 66E8                       		bne.s	.loop
00002524                            
00002524 11FC 0004 C75C             		move.b	#gLevel,opmode.w			; Set game mode to "title"
0000252A 4EF9 0000 0000             		jmp	Level					; Go to the title screen
00002530                            
00002530                            KosM_SegaLogo:
00002530                                    incbin  "Opmodes/Title/Sega Art.bin"
00002888                            
00002888                            Eni_SegaLogo:
00002888                                    incbin  "Opmodes/Title/Sega Map.bin"
00002894                            
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00002894                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00002894                            ;
00002894                            ;		bsr.w	FadeToBlack			; Fade to black
00002894                            ;
00002894                            ;		intsOff					; Disable interrupts
00002894                            ;		clrRAM	kosVars
00002894                            ;		clrRAM	checkpoint
00002894                            ;		clrRAM	opmodeVars
00002894                            ;		clrRAM	objMemory
00002894                            ;
00002894                            ;		lea	VDP_CTRL,a5
00002894                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00002894                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
00002894                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002894                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00002894                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
00002894                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00002894                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002894                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00002894                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00002894                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00002894                            ;
00002894                            ;		bsr.w	ClearScreen			; Clear screen
00002894                            ;
00002894                            ;		lea	palFadeBuff.w,a0			; Fade target palette
00002894                            ;		moveq	#$80>>2-1,d0			; Size
00002894                            ;
00002894                            ;.FillPal:
00002894                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
00002894                            ;		dbf	d0,.FillPal			; Loop
00002894                            ;
00002894                            ;		bsr.w	FadeFromBlack			; Fade from black
00002894                            ;		
00002894                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
00002894                            ;
00002894                            ;TitleScreen2:
00002894                            ;		intsOff
00002894                            ;
00002894                            ;		clr.b	artCheat.w
00002894                            ;		clrRAM	opmodeVars
00002894                            ;		clrRAM	objMemory
00002894                            ;
00002894                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
00002894                            ;		bsr.w	FadeToWhite			; Fade to white
00002894                            ;
00002894                            ;		intsOff
00002894                            ;		bsr.w	ClearScreen			; Clear screen
00002894                            ;
00002894                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
00002894                            ;		lea	miscBuff,a1			; Decompress into RAM
00002894                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002894                            ;		bsr.w	EniDec				; Decompress!
00002894                            ;
00002894                            ;		lea	miscBuff,a1			; Load mappings
00002894                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00002894                            ;		moveq	#$27,d1				; $28x$1C tiles
00002894                            ;		moveq	#$1B,d2				; ''
00002894                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002894                            ;		bsr.w	LoadPlaneMap			; Load the map
00002894                            ;
00002894                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
00002894                            ;		lea	miscBuff,a1			; Decompress into RAM
00002894                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
00002894                            ;		bsr.w	EniDec				; Decompress!
00002894                            ;
00002894                            ;		lea	miscBuff,a1			; Load mappings
00002894                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
00002894                            ;		moveq	#$E,d1				; $28x$1C tiles
00002894                            ;		moveq	#$C,d2				; ''
00002894                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002894                            ;		bsr.w	LoadPlaneMap			; Load the map
00002894                            ;
00002894                            ;		lea	Pal_Title,a0			; Load palette to target buffer
00002894                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
00002894                            ;		bsr.w	LoadTargetPal			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
00002894                            ;		move.w	#$20,d2				; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
00002894                            ;		move.w	#$6E00,d2			; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
00002894                            ;		move.w	#$4000,d2			; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
00002894                            ;		move.w	#$8400,d2			; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
00002894                            ;		move.w	#$8600,d2			; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;.WaitPLCs:
00002894                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002894                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002894                            ;		jsr	VSync_Routine.w			; V-SYNC
00002894                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002894                            ;		tst.b	kosMModules.w			; Are there still modules left?
00002894                            ;		bne.s	.WaitPLCs			; If so, branch
00002894                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002894                            ;		jsr	VSync_Routine.w			; V-SYNC
00002894                            ;		
00002894                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
00002894                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
00002894                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
00002894                            ;
00002894                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
00002894                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
00002894                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
00002894                            ;
00002894                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
00002894                            ;		move.w	#224,(rObj_2+oX).w		; Set X
00002894                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
00002894                            ;
00002894                            ;		jsr	RunObjects.w			; Run objects
00002894                            ;		jsr	RendeobjMemory.w			; Render objects
00002894                            ;
00002894                            ;		clr.w	palCycTimer.w		; Reset palette cycle
00002894                            ;
00002894                            ;		bsr.w	FadeFromWhite			; Fade from white
00002894                            ;
00002894                            ;		lea	SampleList+$C0,a3		; Play title screen music
00002894                            ;		jsr	PlayDAC1			; ''
00002894                            ;
00002894                            ;.Loop:
00002894                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00002894                            ;		bsr.w	VSync_Routine			; ''
00002894                            ;
00002894                            ;		bsr.s	Title_Updates			; Do updates
00002894                            ;		
00002894                            ;		jsr	RunObjects.w			; Run objects
00002894                            ;		jsr	RendeobjMemory.w			; Render objects
00002894                            ;
00002894                            ;		lea	FreeMove_Cheat(pc),a0
00002894                            ;		lea	moveCheat.w,a1
00002894                            ;		lea	rCheatEntry.w,a2
00002894                            ;		bsr.w	Title_ChkCheats
00002894                            ;		lea	Art_Cheat(pc),a0
00002894                            ;		lea	artCheat.w,a1
00002894                            ;		lea	rCheatEntry2.w,a2
00002894                            ;		bsr.w	Title_ChkCheats
00002894                            ;
00002894                            ;		tst.b	artCheat.w
00002894                            ;		bne.w	BinbowieArt
00002894                            ;
00002894                            ;		tst.b	ctrlPressP1.w			; Has start been pressed
00002894                            ;		bpl.s	.Loop				; If so, branch
00002894                            ;
00002894                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
00002894                            ;
00002894                            ;		lea	SampleList+$E0,a3		; Punch
00002894                            ;		jsr	PlayDAC1			; ''
00002894                            ;
00002894                            ;.PunchLoop:
00002894                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00002894                            ;		bsr.w	VSync_Routine			; ''
00002894                            ;
00002894                            ;		bsr.s	Title_Updates			; Do updates
00002894                            ;
00002894                            ;		jsr	RunObjects.w			; Run objects
00002894                            ;		jsr	RendeobjMemory.w			; Render objects
00002894                            ;		
00002894                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
00002894                            ;		bpl.s	.PunchLoop			; If not, loop
00002894                            ;		
00002894                            ;		st	rStartFall.w			; Set flag to start the level by falling
00002894                            ;
00002894                            ;		move.b	#gLevel,opmode.w		; Set game mode to "level"
00002894                            ;		jmp	Level				; Go to level
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Palette cycle
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;Title_Updates:
00002894                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
00002894                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
00002894                            ;		jsr	CalcSine.w			; Get sine
00002894                            ;		asr.w	#5,d0				; ''
00002894                            ;		move.w	d0,vScrollBuffFG.w		; Set logo's Y position
00002894                            ;
00002894                            ;		subq.b	#1,palCycTimer.w		; Decrement timer
00002894                            ;		bpl.s	.End				; If it hasn't run out, branch
00002894                            ;		move.b	#6,palCycTimer.w		; Reset timer
00002894                            ;		
00002894                            ;		moveq	#0,d0
00002894                            ;		move.b	palCycIndex.w,d0		; Get index
00002894                            ;		mulu.w	#$C,d0				; Turn into offset
00002894                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
00002894                            ;		lea	(paletteBuff+$14).w,a1		; Palette
00002894                            ;		move.w	(a0)+,(a1)+			; Load palette
00002894                            ;		move.w	(a0)+,(a1)+			; ''
00002894                            ;		move.w	(a0)+,(a1)+			; ''
00002894                            ;		move.w	(a0)+,(a1)+			; ''
00002894                            ;		move.w	(a0)+,(a1)+			; ''
00002894                            ;		move.w	(a0)+,(a1)+			; ''
00002894                            ;		
00002894                            ;		addq.b	#1,palCycIndex.w		; Increment index
00002894                            ;		cmpi.b	#6,palCycIndex.w		; Has it reached the end?
00002894                            ;		bcs.s	.End				; If not, branch
00002894                            ;		clr.b	palCycIndex.w		; Reset index
00002894                            
00002894                            ;.End:
00002894                            ;		rts
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;PalCyc_Title:
00002894                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
00002894                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
00002894                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
00002894                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
00002894                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
00002894                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Check for cheats
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;Title_ChkCheats:
00002894                            ;		tst.b	(a1)
00002894                            ;		bne.s	.End
00002894                            ;		move.w	(a2),d0
00002894                            ;		adda.w	d0,a0
00002894                            ;		move.b	ctrlPressP1.w,d0
00002894                            ;		cmp.b	(a0),d0
00002894                            ;		bne.s	.ResetCheat
00002894                            ;		addq.w	#1,(a2)
00002894                            ;		tst.b	d0
00002894                            ;		bne.s	.End
00002894                            ;		st	(a1)
00002894                            ;		playSnd	#sRing, 2
00002894                            ;		rts
00002894                            ;
00002894                            ;.ResetCheat:
00002894                            ;		tst.b	d0
00002894                            ;		beq.s	.End
00002894                            ;		clr.w	(a2)
00002894                            ;
00002894                            ;.End:
00002894                            ;		rts
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;FreeMove_Cheat:
00002894                            ;		dc.b	1, 2, 4, 8, 0, $FF
00002894                            ;		even
00002894                            ;Art_Cheat:
00002894                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
00002894                            ;		even
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; BinBowie's art
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;BinbowieArt:
00002894                            ;		bsr.w	FadeToWhite			; Fade to white
00002894                            ;		
00002894                            ;		lea	SampleList,a3
00002894                            ;		jsr	PlayDAC1
00002894                            ;
00002894                            ;		intsOff
00002894                            ;
00002894                            ;		jsr	ClearScreen.w
00002894                            ;
00002894                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
00002894                            ;		lea	miscBuff,a1			; Decompress into RAM
00002894                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002894                            ;		bsr.w	EniDec				; Decompress!
00002894                            ;
00002894                            ;		lea	miscBuff,a1			; Load mappings
00002894                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
00002894                            ;		moveq	#$27,d1				; $28x$1C tiles
00002894                            ;		moveq	#$1B,d2				; ''
00002894                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002894                            ;		bsr.w	LoadPlaneMap			; Load the map
00002894                            ;
00002894                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
00002894                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
00002894                            ;		bsr.w	LoadTargetPal			; ''
00002894                            ;
00002894                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
00002894                            ;		move.w	#$20,d2				; ''
00002894                            ;		bsr.w	QueueKosMData			; ''
00002894                            ;
00002894                            ;.WaitPLCs:
00002894                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002894                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002894                            ;		jsr	VSync_Routine.w			; V-SYNC
00002894                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002894                            ;		tst.b	kosMModules.w			; Are there still modules left?
00002894                            ;		bne.s	.WaitPLCs			; If so, branch
00002894                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002894                            ;		jsr	VSync_Routine.w			; V-SYNC
00002894                            ;
00002894                            ;		jsr	FadeFromWhite.w
00002894                            ;
00002894                            ;		lea	SampleList+$100,a3
00002894                            ;		jsr	PlayDAC1
00002894                            ;
00002894                            ;.Loop:
00002894                            ;		move.b	#vTitle,vIntRoutine.w		; Level load V-INT routine
00002894                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002894                            ;		move.b	ctrlPressP1.w,d0
00002894                            ;		andi.b	#%10010000,d0
00002894                            ;		beq.s	.Loop
00002894                            ;
00002894                            ;		jmp	TitleScreen2
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Objects
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
00002894                            ;		include	"Title Screen/Objects/Bird/Code.asm"
00002894                            ;		include	"Title Screen/Objects/Glove/Code.asm"
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Art
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;ArtKosM_TitleBG:
00002894                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
00002894                            ;		even
00002894                            ;ArtKosM_TitleLogo:
00002894                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
00002894                            ;		even
00002894                            ;ArtKosM_BinBowieArt:
00002894                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
00002894                            ;		even
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Plane mappings
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;MapEni_TitleBG:
00002894                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
00002894                            ;		even
00002894                            ;MapEni_TitleLogo:
00002894                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
00002894                            ;		even
00002894                            ;MapEni_BinBowieArt:
00002894                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
00002894                            ;		even
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Palette
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;Pal_Title:
00002894                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
00002894                            ;Pal_Title_End:
00002894                            ;		even
00002894                            ;Pal_BinBowieArt:
00002894                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
00002894                            ;Pal_BinBowieArt_End:
00002894                            ;		even
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; SEGA FMV
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
00002894                            ; =========================================================================================================================================================
00002894                            		include	"Opmodes/Gameplay/Main.asm"
00002894                            ; =========================================================================================================================================================
00002894                            ; Level
00002894                            ; =========================================================================================================================================================
00002894                            Level:
00002894                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
00002894 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
0000289A                            
0000289A 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
0000289E                            
0000289E                            Level_NoFade:
0000289E                            		; --- Set up the VDP ---
0000289E                            
0000289E                            		intsOff					; Disable interrupts
0000289E 007C 0700                M 	ori	#$700,sr
000028A2                            		displayOff				; Disable display
000028A2 3038 C766                M 	move.w	vdpreg1.w,d0
000028A6 0200 00BF                M 	andi.b	#%10111111,d0
000028AA 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000028B0                            
000028B0 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
000028B6 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
000028BA 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
000028BE 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
000028C2 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
000028C6 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
000028CA 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
000028CE 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
000028D2 31C0 C768                  		move.w	d0,vdpWindowY.w			; ''
000028D6 3A80                       		move.w	d0,(a5)				; ''
000028D8 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
000028DC 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
000028E2                            
000028E2 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
000028E6                            
000028E6                            		; --- Clear some RAM ---
000028E6                            
000028E6                            		clrRAM	kosVars			; Clear Kosinski queue variables
000028E6                          M 	local	endaddr
000028E6                          M endaddr	equs	"kosvars_End"
000028E6 7000                     M 	moveq	#0,d0
000028E8 43F8 994E                M 	lea	(kosvars).w,a1
000028EC 323C 0040                M 	move.w	#(((kosvars_end)-(kosvars))-((kosvars)&1))>>2-1,d1
000028F0 22C0                     M .clear_140:	move.l	d0,(a1)+
000028F2 51C9 FFFC                M 	dbf	d1,.clear_140
000028F6 32C0                     M 	move.w	d0,(a1)+
000028F8                            		clrRAM	opmodeVars			; Clear variables
000028F8                          M 	local	endaddr
000028F8                          M endaddr	equs	"opmodevars_End"
000028F8 7000                     M 	moveq	#0,d0
000028FA 43F8 C7D2                M 	lea	(opmodevars).w,a1
000028FE 323C 0DCA                M 	move.w	#(((opmodevars_end)-(opmodevars))-((opmodevars)&1))>>2-1,d1
00002902 22C0                     M .clear_141:	move.l	d0,(a1)+
00002904 51C9 FFFC                M 	dbf	d1,.clear_141
00002908 32C0                     M 	move.w	d0,(a1)+
0000290A                            		clrRAM	oscillators			; Clear oscillation data
0000290A                          M 	local	endaddr
0000290A                          M endaddr	equs	"oscillators_End"
0000290A 7000                     M 	moveq	#0,d0
0000290C 43F8 C76C                M 	lea	(oscillators).w,a1
00002910 323C 000F                M 	move.w	#(((oscillators_end)-(oscillators))-((oscillators)&1))>>2-1,d1
00002914 22C0                     M .clear_142:	move.l	d0,(a1)+
00002916 51C9 FFFC                M 	dbf	d1,.clear_142
0000291A 32C0                     M 	move.w	d0,(a1)+
0000291C                            
0000291C                            		; --- Do some final initializing and play the level music ---
0000291C                            
0000291C 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Set ring animation timer
00002922 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set floor timer
00002928 4278 C7D0                  		clr.w	palCycTimer.w		; Reset palette cycle
0000292C                            
0000292C 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002930 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002934 E218                       		ror.b	#1,d0				; Turn into offset
00002936 EE48                       		lsr.w	#7,d0				; ''
00002938 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
0000293C 11C0 E8E0                  		move.b	d0,lvlMusic.w		; Store it
00002940                            		playSnd	d0, 1				; Play it
00002940 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
00002944                            
00002944                            		intsOn					; Enable interrupts
00002944 027C F8FF                M 	andi	#$f8ff,sr
00002948                            
00002948                            		; --- Load level data ---
00002948                            
00002948 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
0000294E 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
00002952                            
00002952 4EB8 19BE                  		jsr	InitObjectList.w
00002956                            
00002956 4EB8 1A1C                  		jsr	FindFreeObj.w
0000295A 22BC 0000 0000             		move.l	#ObjPlayer,_objAddress(a1)		; Load Player object
00002960 31C9 E876                  		move.w	a1,playerPtrP1.w		; Store the address
00002964                            
00002964 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00002968 6700                       		beq.s	.NoSurface			; If not, branch
0000296A                            
0000296A                            							; Load water surfaces
0000296A 4EB8 1A1C                  		jsr	FindFreeObj.w
0000296E 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
00002974 337C 0060 0014             		move.w	#$60,_objXPos(a1)
0000297A 31C9 E886                  		move.w	a1,waterObjPtr1.w		; Store the address
0000297E                            
0000297E 4EB8 1A1C                  		jsr	FindFreeObj.w
00002982 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
00002988 337C 0120 0014             		move.w	#$120,_objXPos(a1)
0000298E 31C9 E888                  		move.w	a1,waterObjPtr2.w		; Store the address
00002992                            
00002992                            .NoSurface:
00002992 6100 0000                  		bsr.w	Level_LoadData			; Load level data
00002996                            
00002996                            .WaitPLCs:
00002996 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
0000299C 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
000029A0 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
000029A4 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000029A8 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
000029AC 66E8                       		bne.s	.WaitPLCs			; If so, branch
000029AE                            
000029AE 4238 E8FE                  		clr.b	lvlHasWater.w			; Clear the water flag
000029B2                            
000029B2 41FA 0000                  		lea	Level_WatelevelIDs(pc),a0	; Water heights
000029B6 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
000029BA E218                       		ror.b	#1,d0				; Turn into offset
000029BC EC48                       		lsr.w	#6,d0				; ''
000029BE 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
000029C2 6B00                       		bmi.s	.NoWater			; If it's negative, branch
000029C4 31C0 E900                  		move.w	d0,waterYPos.w		; Set the water height
000029C8 31C0 E902                  		move.w	d0,destWaterYPos.w
000029CC                            
000029CC 50F8 E8FE                  		st	lvlHasWater.w			; Set the water flag
000029D0 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
000029D8 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000029DC 33F8 C760 00C0 0004        		move.w	hIntCntReg.w,VDP_CTRL		; Set H-INT counter
000029E4                            
000029E4                            .NoWater:
000029E4 31FC 00A0 E8D6             		move.w	#320/2,panCamXPos.w		; Set camera X center
000029EA                            
000029EA 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
000029EE                            
000029EE 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
000029F2                            	;	bsr.w	Level_InitHUD			; Initialize the HUD
000029F2 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
000029F6                            
000029F6 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000029FA                            
000029FA                            		; --- Load the planes ---
000029FA                            
000029FA                            		intsOff					; Disable interrupts
000029FA 007C 0700                M 	ori	#$700,sr
000029FE 21FC 0000 233C C74E        		move.l	#VInt_RunSMPS,vIntAddress.w	; Swap V-INT
00002A06                            		intsOn					; Enable interrupts
00002A06 027C F8FF                M 	andi	#$f8ff,sr
00002A0A 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
00002A0E                            		intsOff					; Disable interrupts
00002A0E 007C 0700                M 	ori	#$700,sr
00002A12 21FC 0000 20A2 C74E        		move.l	#VInt_Standard,vIntAddress.w	; Swap V-INT
00002A1A                            		intsOn					; Enable interrupts
00002A1A 027C F8FF                M 	andi	#$f8ff,sr
00002A1E 11FC 0006 C747             		move.b	#vLvlLoad,vIntRoutine.w		; Level load V-INT routine
00002A24 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002A28                            
00002A28                            		; --- Load the level objects and rings ---
00002A28                            
00002A28 51F8 C7B6                  		sf	objMgrInit.w			; Reset object manager routine
00002A2C 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
00002A30 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
00002A34                            	runObjects
00002A34 3078 C158                M 	movea.w	objexecfirst.w,a0
00002A38 2250                     M 	move.l	_objaddress(a0),a1
00002A3A 4E91                     M 	jsr	(a1)
00002A3C 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
00002A40                            
00002A40 4238 E906                  		clr.b	lvlReload.w			; Clear the level reload flag
00002A44                            
00002A44                            		displayOn				; Enable display
00002A44 3038 C766                M 	move.w	vdpreg1.w,d0
00002A48 0000 0040                M 	ori.b	#%01000000,d0
00002A4C 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002A52 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
00002A56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A56                            ; Main loop
00002A56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A56                            .Loop:
00002A56 11FC 0004 C747             		move.b	#vLevel,vIntRoutine.w		; Level V-INT routine
00002A5C 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002A60 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002A64                            
00002A64 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
00002A68 5278 E904                  		addq.w	#1,lvlFrameCnt.w			; Increment frame counter
00002A6C                            
00002A6C 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
00002A70                            
00002A70 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
00002A74 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
00002A78                            
00002A78                            	runObjects
00002A78 3078 C158                M 	movea.w	objexecfirst.w,a0
00002A7C 2250                     M 	move.l	_objaddress(a0),a1
00002A7E 4E91                     M 	jsr	(a1)
00002A80                            
00002A80 4A38 E906                  		tst.b	lvlReload.w			; Does the level need to be reloaded?
00002A84 6600 FE0E                  		bne.w	Level				; If so, branch
00002A88                            
00002A88 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
00002A8C 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
00002A90 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
00002A94                            
00002A94 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
00002A98                            
00002A98 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002A9C 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002AA0 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
00002AA4 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
00002AA8                            
00002AA8 5338 E861                  		subq.b	#1,ringAnimTime.w		; Decrement ring animation timer
00002AAC 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
00002AAE 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Reset animation timer
00002AB4 5238 E860                  		addq.b	#1,ringAnimFrame.w			; Next ring frame
00002AB8 0238 0007 E860             		andi.b	#7,ringAnimFrame.w			; Limit it
00002ABE                            
00002ABE 7000                       		moveq	#0,d0
00002AC0 1038 E860                  		move.b	ringAnimFrame.w,d0			; Get ring frame
00002AC4 EF48                       		lsl.w	#7,d0				; Convert to offset
00002AC6 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002ACC D280                       		add.l	d0,d1				; ''
00002ACE 343C D780                  		move.w	#$D780,d2			; VRAM address
00002AD2 363C 0040                  		move.w	#$80/2,d3			; Size
00002AD6 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002ADA                            
00002ADA                            .NoRingAni:
00002ADA 4A38 E864                  		tst.b	ringLossAnimT.w
00002ADE 6700                       		beq.s	.NoRingLossAni
00002AE0 7000                       		moveq	#0,d0
00002AE2 1038 E864                  		move.b	ringLossAnimT.w,d0
00002AE6 D078 E862                  		add.w	ringLossAnimA.w,d0
00002AEA 31C0 E862                  		move.w	d0,ringLossAnimA.w
00002AEE E158                       		rol.w	#8,d0
00002AF0 0240 0007                  		andi.w	#7,d0
00002AF4 11C0 E865                  		move.b	d0,ringLossAnimF.w
00002AF8 5338 E864                  		subq.b	#1,ringLossAnimT.w
00002AFC                            
00002AFC 7000                       		moveq	#0,d0
00002AFE 1038 E865                  		move.b	ringLossAnimF.w,d0		; Get ring frame
00002B02 EF48                       		lsl.w	#7,d0				; Convert to offset
00002B04 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002B0A D280                       		add.l	d0,d1				; ''
00002B0C 343C D680                  		move.w	#$D680,d2			; VRAM address
00002B10 363C 0040                  		move.w	#$80/2,d3			; Size
00002B14 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002B18                            
00002B18                            .NoRingLossAni:
00002B18 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002B1C                            
00002B1C 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Is the game mode level?
00002B22 6700 FF32                  		beq.w	.Loop				; If so, branch
00002B26 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002B2A                            
00002B2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B2A                            ; Check for pausing
00002B2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B2A                            CheckPause:
00002B2A 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game already paused?
00002B2E 6600                       		bne.s	.SetPause			; If so, branch
00002B30 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002B36 6700                       		beq.s	.End				; If not, branch
00002B38                            
00002B38                            .SetPause:
00002B38 50F8 C75E                  		st	pauseFlag.w			; Pause the game
00002B3C                            		AMPS_MUSPAUSE				; Pause the music
00002B3C 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
00002B42                            
00002B42                            .PauseLoop:
00002B42 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; General V-INT routine
00002B48 6100 F82A                  		bsr.w	VSync_Routine			; V-SYNC
00002B4C 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002B52 67EE                       		beq.s	.PauseLoop			; If not, branch
00002B54                            
00002B54                            		AMPS_MUSUNPAUSE				; Unpause the music
00002B54 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002B5A 4238 C75E                  		clr.b	pauseFlag.w			; Unpause the game
00002B5E                            
00002B5E                            .End:
00002B5E 4E75                       		rts
00002B60                            
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            ; Level functions
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            		include	"Opmodes/Gameplay/Level Drawing.asm"
00002B60                            ; =========================================================================================================================================================
00002B60                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002B60                            ; =========================================================================================================================================================
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            ; Initialize the planes
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            ; PARAMETERS:
00002B60                            ;	Nothing
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            ; RETURNS:
00002B60                            ;	Nothing
00002B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B60                            Level_InitPlanes:
00002B60 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002B64 47F8 C2A0                  		lea	fgColBuff.w,a3			; Get foreground column plane buffer
00002B68 49F8 C19E                  		lea	fgRowBuff.w,a4			; Get foreground row plane buffer
00002B6C                            
00002B6C 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002B74 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002B78                            		
00002B78 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002B7C E218                       		ror.b	#1,d0				; Turn into offset
00002B7E E648                       		lsr.w	#3,d0				; ''
00002B80 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002B86 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002B8C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002B90 4E90                       		jsr	(a0)				; Jump to it
00002B92                            
00002B92 31E9 0008 947E             		move.w	cYPos(a1),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002B98                            
00002B98 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002B9C 47F8 C424                  		lea	bgColBuff.w,a3			; Get background column plane buffer
00002BA0 49F8 C322                  		lea	bgRowBuff.w,a4			; Get background row plane buffer
00002BA4                            		
00002BA4 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
00002BAC 337C 0004 0016             		move.w	#4,cLayout(a1)			; Set the offset for the level layout (background)
00002BB2                            		
00002BB2 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002BB6 E218                       		ror.b	#1,d0				; Turn into offset
00002BB8 E648                       		lsr.w	#3,d0				; ''
00002BBA 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
00002BC0 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002BC6 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002BCA 4E90                       		jsr	(a0)				; Jump to it
00002BCC                            
00002BCC 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002BD2 4E75                       		rts
00002BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BD4                            ; Update the planes
00002BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BD4                            Level_UpdatePlanes:
00002BD4 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002BD8 47F8 C2A0                  		lea	fgColBuff.w,a3		; Get foreground column plane buffer
00002BDC 49F8 C19E                  		lea	fgRowBuff.w,a4		; Get foreground row plane buffer
00002BE0                            		
00002BE0 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002BE4 4E90                       		jsr	(a0)				; Jump to it
00002BE6                            		
00002BE6 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002BEA 47F8 C424                  		lea	bgColBuff.w,a3		; Get background column plane buffer
00002BEE 49F8 C322                  		lea	bgRowBuff.w,a4		; Get background row plane buffer
00002BF2                            
00002BF2 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002BF6 4E90                       		jsr	(a0)				; Jump to it
00002BF8                            
00002BF8 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002BFC 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002C00 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
00002C06 31EA 0008 947E             		move.w	cYPos(a2),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002C0C 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002C10 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
00002C16 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002C1C                            
00002C1C 4E75                       		rts
00002C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C1E                            ; General foreground initialization
00002C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C1E                            General_InitFG:
00002C1E 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002C22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C22                            ; General background initialization
00002C22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C22                            General_InitBG:
00002C22 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002C26 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002C28 E240                       		asr.w	#1,d0				; Divide by 2
00002C2A 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002C2C 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002C30 E240                       		asr.w	#1,d0				; Divide by 2
00002C32 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002C36                            
00002C36 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00002C3A                            		
00002C3A 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002C3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C3E                            ; General foreground update
00002C3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C3E                            General_UpdateFG:
00002C3E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002C42                            		
00002C42 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002C44 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002C46 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
00002C4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C4A                            ; General background update
00002C4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C4A                            General_UpdateBG:
00002C4A 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002C4E 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002C50 E240                       		asr.w	#1,d0				; Divide by 2
00002C52 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002C54 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002C58 E240                       		asr.w	#1,d0				; Divide by 2
00002C5A 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002C5E                            
00002C5E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002C62 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002C64 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002C66 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002C6A                            		
00002C6A 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C6E                            ; Draw new tiles in the level
00002C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C6E                            ; PARAMETERS:
00002C6E                            ;	a1.l	- Camera RAM
00002C6E                            ;	a2.l	- Plane buffer for columns
00002C6E                            ;	a3.l	- Plane buffer for rows
00002C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C6E                            ; RETURNS:
00002C6E                            ;	Nothing
00002C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C6E                            VInt_DrawLevel:
00002C6E 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002C72 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002C76                            
00002C76 3013                       		move.w	(a3),d0				; Get high VDP command word
00002C78 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
00002C7C 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
00002C7E 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002C82                            
00002C82                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002C82                            
00002C82 3200                       		move.w	d0,d1				; Save high VDP command
00002C84 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002C86 7C00                       		moveq	#0,d6
00002C88 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002C8C 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C8E                            
00002C8E 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C90 3C84                       		move.w	d4,(a6)				; ''
00002C92 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002C94                            
00002C94                            .DrawCol1_1_Loop:
00002C94 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C96                            
00002C96                            .DrawCol1_1_Start:
00002C96 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002C9A                            
00002C9A 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002C9C 0642 007C                  		addi.w	#$7C,d2				; ''
00002CA0 C042                       		and.w	d2,d0				; ''
00002CA2                            
00002CA2 3C80                       		move.w	d0,(a6)				; Set VDP command
00002CA4 3C84                       		move.w	d4,(a6)				; ''
00002CA6                            
00002CA6                            .DrawCol1_2_Loop:
00002CA6 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002CA8 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
00002CAC                            
00002CAC                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
00002CAC                            
00002CAC 5441                       		addq.w	#2,d1				; Move over to the right
00002CAE 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002CB0 7C00                       		moveq	#0,d6
00002CB2 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002CB6 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002CB8                            
00002CB8 3C81                       		move.w	d1,(a6)				; Set VDP command
00002CBA 3C84                       		move.w	d4,(a6)				; ''
00002CBC 6000                       		bra.s	.DrawCol2_1_Start		; Start
00002CBE                            
00002CBE                            .DrawCol2_1_Loop:
00002CBE 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002CC0                            
00002CC0                            .DrawCol2_1_Start:
00002CC0 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
00002CC4                            
00002CC4 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002CC6 0642 007E                  		addi.w	#$7E,d2				; ''
00002CCA C242                       		and.w	d2,d1				; ''
00002CCC                            
00002CCC 3C81                       		move.w	d1,(a6)				; Set VDP command
00002CCE 3C84                       		move.w	d4,(a6)				; ''
00002CD0                            
00002CD0                            .DrawCol2_2_Loop:
00002CD0 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002CD2 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
00002CD6                            
00002CD6 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
00002CDA 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
00002CDC                            
00002CDC                            VInt_DrawLvlRows:
00002CDC 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002CE0 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002CE4                            
00002CE4                            VInt_DrawLvlRows2:
00002CE4 3014                       		move.w	(a4),d0				; Get high VDP command
00002CE6 6700 0000                  		beq.w	.End				; If it's 0, branch
00002CEA 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
00002CEC                            		
00002CEC                            		; --- DRAW THE FIRST HALF OF THE ROW ---
00002CEC                            
00002CEC 3200                       		move.w	d0,d1				; Save high VDP command
00002CEE 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002CF0 7C00                       		moveq	#0,d6
00002CF2 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002CF6 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002CF8                            
00002CF8 3C80                       		move.w	d0,(a6)				; Set VDP command
00002CFA 3C84                       		move.w	d4,(a6)				; ''
00002CFC 6000                       		bra.s	.DrawRow1_1_Start		; Start
00002CFE                            
00002CFE                            .DrawRow1_1_Loop:
00002CFE 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002D00                            
00002D00                            .DrawRow1_1_Start:
00002D00 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002D04                            
00002D04 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002D06 0642 0F00                  		addi.w	#$F00,d2			; ''
00002D0A C042                       		and.w	d2,d0				; ''
00002D0C                            
00002D0C 3C80                       		move.w	d0,(a6)				; Set VDP command
00002D0E 3C84                       		move.w	d4,(a6)				; ''
00002D10                            
00002D10                            .DrawRow1_2_Loop:
00002D10 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002D12 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
00002D16                            
00002D16                            		; --- DRAW THE SECOND HALF OF THE ROW ---
00002D16                            
00002D16 0641 0080                  		addi.w	#$80,d1				; Move over down
00002D1A 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002D1C 7C00                       		moveq	#0,d6
00002D1E 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002D22 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002D24                            
00002D24 3C81                       		move.w	d1,(a6)				; Set VDP command
00002D26 3C84                       		move.w	d4,(a6)				; ''
00002D28 6000                       		bra.s	.DrawRow2_1_Start		; Start
00002D2A                            
00002D2A                            .DrawRow2_1_Loop:
00002D2A 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002D2C                            
00002D2C                            .DrawRow2_1_Start:
00002D2C 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002D30                            
00002D30 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002D32 0642 0F80                  		addi.w	#$F80,d2			; ''
00002D36 C242                       		and.w	d2,d1				; ''
00002D38                            
00002D38 3C81                       		move.w	d1,(a6)				; Set VDP command
00002D3A 3C84                       		move.w	d4,(a6)				; ''
00002D3C                            
00002D3C                            .DrawRow2_2_Loop:
00002D3C 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002D3E 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002D42                            
00002D42                            .End:
00002D42 4E75                       		rts
00002D44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D44                            ; Handle plane drawing
00002D44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D44                            ; PARAMETERS:
00002D44                            ;	d4.w	- Number of blocks per column
00002D44                            ;	d5.w	- Number of blocks per row
00002D44                            ;	a1.l	- Camera variables
00002D44                            ;	a2.l	- Layout pointer
00002D44                            ;	a3.l	- Column plane buffer
00002D44                            ;	a4.l	- Row plane buffer
00002D44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D44                            ; RETURNS:
00002D44                            ;	Nothing
00002D44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D44                            Level_UpdatePlane:
00002D44                            		push.l	d5/a4				; Push row plane buffer address
00002D44 48E7 0408                M 	movem.l	d5/a4,-(sp)
00002D48 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
00002D4A                            		pop.l	d5/a4				; Restore row plane buffer address
00002D4A 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002D4E 3805                       		move.w	d5,d4				; Number of blocks per column
00002D50                            		; Continue to update the plane vertically
00002D50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D50                            ; Handle plane drawing (vertical redrawing only)
00002D50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D50                            ; PARAMETERS:
00002D50                            ;	d4.w	- Number of blocks per row
00002D50                            ;	a1.l	- Camera variables
00002D50                            ;	a4.l	- Row plane buffer
00002D50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D50                            ; RETURNS:
00002D50                            ;	Nothing
00002D50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D50                            Level_UpdatePlaneY:
00002D50 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002D54 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002D58 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002D5C 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002D60                            		
00002D60 9240                       		sub.w	d0,d1				; Get distance travelled
00002D62 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002D64 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002D66                            		
00002D66                            .DrawUp:
00002D66 3011                       		move.w	cXPos(a1),d0			; Get X
00002D68 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002D6C 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002D70                            
00002D70                            .DrawDown:
00002D70 3011                       		move.w	cXPos(a1),d0			; Get X
00002D72 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002D76 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002D7A 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002D7E                            
00002D7E                            .End:
00002D7E 4E75                       		rts
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            ; Handle plane drawing (horizontal redrawing only)
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            ; PARAMETERS:
00002D80                            ;	d4.w	- Number of blocks per column
00002D80                            ;	a1.l	- Camera variables
00002D80                            ;	a3.l	- Column plane buffer
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            ; RETURNS:
00002D80                            ;	Nothing
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            Level_UpdatePlaneX:
00002D80 3011                       		move.w	cXPos(a1),d0			; Get X
00002D82 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002D86 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002D8A 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
00002D8E                            		
00002D8E 9240                       		sub.w	d0,d1				; Get distance travelled
00002D90 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002D92 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002D94                            		
00002D94                            .DrawLeft:
00002D94 3011                       		move.w	cXPos(a1),d0			; Get X
00002D96 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002D9A 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002D9E                            		
00002D9E                            .DrawRight:
00002D9E 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002DA2 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
00002DA6 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002DAA 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002DAE                            
00002DAE                            .End:
00002DAE 4E75                       		rts
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; Macro to calculate the high VDP command word for the plane buffer
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; PARAMETERS:
00002DB0                            ;	a1.l	- Camera variables
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; RETURNS:
00002DB0                            ;	d2.w	- The high VDP command word
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            calcHiVDP	macro
00002DB0                            		move.w	d0,d2				; Copy X
00002DB0                            		move.w	d1,d3				; Copy Y
00002DB0                            		lsl.w	#4,d3				; Multiply Y by $10
00002DB0                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002DB0                            		lsr.w	#2,d2				; Divide X by 4
00002DB0                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002DB0                            		add.w	d3,d2				; Add Y onto X
00002DB0                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
00002DB0                            		endm
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; Macro to get an address in chunk data relative to a position
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; PARAMETERS:
00002DB0                            ;	d1.l	- $FFFFXXXX
00002DB0                            ;	a2.l	- Layout data
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; RETURNS:
00002DB0                            ;	a6.l	- Pointer in chunk data to the correct block
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            getChunk	macro
00002DB0                            		moveq	#-1,d1				; Prepare chunk pointer
00002DB0                            		move.b	(a2,d0.w),d1			; Get chunk ID
00002DB0                            		andi.w	#$FF,d1				; ''
00002DB0                            		lsl.w	#7,d1				; Turn into offset
00002DB0                            		movea.l	d1,a6				; Store into a6
00002DB0                            		endm
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; Get a block row and store it in a plane buffer
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; PARAMETERS:
00002DB0                            ;	d0.w	- X position
00002DB0                            ;	d1.w	- Y position
00002DB0                            ;	d4.w	- Number of blocks to draw (minus 1)
00002DB0                            ;	a1.l	- Camera variables
00002DB0                            ;	a4.l	- Row plane buffer
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            ; RETURNS:
00002DB0                            ;	Nothing
00002DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB0                            Level_GetRow:
00002DB0 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002DB4 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002DB8 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002DBA                            
00002DBA 47F8 C7D2                  		lea	blockData.w,a3			; Get block table address
00002DBE 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
00002DC2                            
00002DC2                            		calcHiVDP				; Get high VDP command word
00002DC2 3400                     M 	move.w	d0,d2
00002DC4 3601                     M 	move.w	d1,d3
00002DC6 E94B                     M 	lsl.w	#4,d3
00002DC8 0243 0F00                M 	andi.w	#$f00,d3
00002DCC E44A                     M 	lsr.w	#2,d2
00002DCE 0242 007C                M 	andi.w	#$7c,d2
00002DD2 D443                     M 	add.w	d3,d2
00002DD4 8469 0012                M 	or.w	cvdp(a1),d2
00002DD8 38C2                       		move.w	d2,(a4)+			; Store it
00002DDA                            
00002DDA 3400                       		move.w	d0,d2				; Get X
00002DDC E44A                       		lsr.w	#2,d2				; Divide X by 4
00002DDE 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002DE2 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002DE6 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
00002DE8 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
00002DEC E44D                       		lsr.w	#2,d5				; Divide by 4
00002DEE 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
00002DF2                            		
00002DF2 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002DF4 3400                       		move.w	d0,d2				; ''
00002DF6 0242 000E                  		andi.w	#$E,d2				; ''
00002DFA 3601                       		move.w	d1,d3				; Get Y within chunk data
00002DFC 0243 0070                  		andi.w	#$70,d3				; ''
00002E00 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
00002E02                            		
00002E02 E848                       		lsr.w	#4,d0				; Get X within layout data
00002E04 0240 00FF                  		andi.w	#$FF,d0				; ''
00002E08 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002E0C EC49                       		lsr.w	#6,d1				; ''
00002E0E                            
00002E0E D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002E12                            		getChunk				; Get chunk pointer at current location
00002E12 72FF                     M 	moveq	#-1,d1
00002E14 1232 0000                M 	move.b	(a2,d0.w),d1
00002E18 0241 00FF                M 	andi.w	#$ff,d1
00002E1C EF49                     M 	lsl.w	#7,d1
00002E1E 2C41                     M 	movea.l	d1,a6
00002E20                            
00002E20                            .DrawBlock_Loop:
00002E20 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002E24 3C05                       		move.w	d5,d6				; ''
00002E26 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002E2A E74D                       		lsl.w	#3,d5				; Get offset in block data
00002E2C                            		
00002E2C 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002E30 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002E34                            
00002E34 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002E38 6700                       		beq.s	.ChkYFlip			; If not, branch
00002E3A 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002E40 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002E46 4847                       		swap	d7				; ''
00002E48 4845                       		swap	d5				; ''
00002E4A                            
00002E4A                            .ChkYFlip:
00002E4A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002E4E 6700                       		beq.s	.DrawBlock			; If not, branch
00002E50 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002E56 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002E5C CF45                       		exg.l	d7,d5				; ''
00002E5E                            
00002E5E                            .DrawBlock:
00002E5E 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002E60 2AC5                       		move.l	d5,(a5)+			; ''
00002E62                            
00002E62 5442                       		addq.w	#2,d2				; Go to the next block
00002E64 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002E68 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002E6A                            		
00002E6A 5240                       		addq.w	#1,d0				; Next chunk
00002E6C                            		getChunk				; ''
00002E6C 72FF                     M 	moveq	#-1,d1
00002E6E 1232 0000                M 	move.b	(a2,d0.w),d1
00002E72 0241 00FF                M 	andi.w	#$ff,d1
00002E76 EF49                     M 	lsl.w	#7,d1
00002E78 2C41                     M 	movea.l	d1,a6
00002E7A                            
00002E7A                            .DrawBlock_Cont:
00002E7A D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002E7C 51CC FFA2                  		dbf	d4,.DrawBlock_Loop		; Loop
00002E80                            
00002E80 4E75                       		rts
00002E82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E82                            ; Get a block column and store it in a plane buffer
00002E82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E82                            ; PARAMETERS:
00002E82                            ;	d0.w	- X position
00002E82                            ;	d1.w	- Y position
00002E82                            ;	d4.w	- Number of blocks to draw (minus 1)
00002E82                            ;	a1.l	- Camera RAM
00002E82                            ;	a3.l	- Column plane buffer
00002E82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E82                            ; RETURNS:
00002E82                            ;	Nothing
00002E82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E82                            Level_GetCol:
00002E82 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002E86 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002E8A 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002E8C                            		
00002E8C 49F8 C7D2                  		lea	blockData.w,a4			; Get block table address
00002E90 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002E94                            		
00002E94                            		calcHiVDP				; Get high VDP command word
00002E94 3400                     M 	move.w	d0,d2
00002E96 3601                     M 	move.w	d1,d3
00002E98 E94B                     M 	lsl.w	#4,d3
00002E9A 0243 0F00                M 	andi.w	#$f00,d3
00002E9E E44A                     M 	lsr.w	#2,d2
00002EA0 0242 007C                M 	andi.w	#$7c,d2
00002EA4 D443                     M 	add.w	d3,d2
00002EA6 8469 0012                M 	or.w	cvdp(a1),d2
00002EAA 36C2                       		move.w	d2,(a3)+			; Store it
00002EAC                            
00002EAC 3601                       		move.w	d1,d3				; Get Y
00002EAE E94B                       		lsl.w	#4,d3				; Multiply by $10
00002EB0 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002EB4 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002EB8 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002EBA 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002EBE E04D                       		lsr.w	#8,d5				; Divide by $100
00002EC0 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002EC4                            
00002EC4 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002EC6 3400                       		move.w	d0,d2				; ''
00002EC8 0242 000E                  		andi.w	#$E,d2				; ''
00002ECC 3601                       		move.w	d1,d3				; Get Y within chunk data
00002ECE 0243 0070                  		andi.w	#$70,d3				; ''
00002ED2 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002ED4                            
00002ED4 E848                       		lsr.w	#4,d0				; Get X within layout data
00002ED6 0240 00FF                  		andi.w	#$FF,d0				; ''
00002EDA 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002EDE EC49                       		lsr.w	#6,d1				; ''				
00002EE0 48A7 C000                  		movem.w	d0-d1,-(sp)			; Backup layout X and Y 
00002EE4                            		
00002EE4 D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002EE8                            		getChunk				; Get chunk pointer at current location
00002EE8 72FF                     M 	moveq	#-1,d1
00002EEA 1232 0000                M 	move.b	(a2,d0.w),d1
00002EEE 0241 00FF                M 	andi.w	#$ff,d1
00002EF2 EF49                     M 	lsl.w	#7,d1
00002EF4 2C41                     M 	movea.l	d1,a6
00002EF6                            
00002EF6                            .DrawBlock_Loop:
00002EF6 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002EFA 3C05                       		move.w	d5,d6				; ''
00002EFC 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002F00 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002F02                            		
00002F02 3E05                       		move.w	d5,d7				; Get block tiles
00002F04 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002F08 3A07                       		move.w	d7,d5				; ''
00002F0A 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002F0E 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002F12 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002F16                            
00002F16 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002F1A 6700                       		beq.s	.ChkYFlip			; If not, branch
00002F1C 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002F22 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002F28 CF45                       		exg.l	d7,d5				; ''
00002F2A                            
00002F2A                            .ChkYFlip:
00002F2A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002F2E 6700                       		beq.s	.DrawBlock			; If not, branch
00002F30 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002F36 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002F3C 4847                       		swap	d7				; ''
00002F3E 4845                       		swap	d5				; ''
00002F40                            
00002F40                            .DrawBlock:
00002F40 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002F42 2AC5                       		move.l	d5,(a5)+			; ''
00002F44                            
00002F44 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002F48 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002F4C 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002F4E                            
00002F4E 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Get saved layout X and Y from the stack
00002F52 5441                       		addq.w	#2,d1				; Increase layout data Y offset to the next pointer
00002F54 48A7 C000                  		movem.w	d0-d1,-(sp)			; Push a backup copy back onto the stack
00002F58                            		
00002F58 D072 1002                  		add.w	2(a2,d1.w),d0			; Next chunk
00002F5C                            		getChunk				; ''
00002F5C 72FF                     M 	moveq	#-1,d1
00002F5E 1232 0000                M 	move.b	(a2,d0.w),d1
00002F62 0241 00FF                M 	andi.w	#$ff,d1
00002F66 EF49                     M 	lsl.w	#7,d1
00002F68 2C41                     M 	movea.l	d1,a6
00002F6A                            
00002F6A                            .DrawBlock_Cont:
00002F6A D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002F6C 51CC FF88                  		dbf	d4,.DrawBlock_Loop		; Loop
00002F70                            
00002F70 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Discard backup layout X and Y from the stack 
00002F74 4E75                       		rts
00002F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F76                            ; Refresh a plane
00002F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F76                            ; PARAMETERS:
00002F76                            ;	a1.l	- Camera variables
00002F76                            ;	a4.l	- Row plane buffer
00002F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F76                            ; RETURNS:
00002F76                            ;	Nothing
00002F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F76                            Level_RefreshPlane:
00002F76 3011                       		move.w	cXPos(a1),d0			; Get X position
00002F78 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002F7C 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002F80 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002F84                            		
00002F84 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002F88 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002F8C 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002F90 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002F94                            		
00002F94 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002F96 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002F98                            		
00002F98                            		push.l	a4				; Save plane buffer address
00002F98 2F0C                     M 	move.l	a4,-(sp)
00002F9A                            		
00002F9A                            .DrawRows:
00002F9A                            		push.w	d0/d1/d4/d6			; Save registers
00002F9A 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002F9E 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002FA2 6100 FE0C                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002FA6 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002FAA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002FB0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002FB4 6100 FD26                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002FB8                            		pop.w	d0/d1/d4/d6			; Restore registers
00002FB8 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002FBC                            		
00002FBC 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002FC0 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002FC4                            		
00002FC4                            		pop.l	a4				; Restore a3
00002FC4 285F                     M 	move.l	(sp)+,a4
00002FC6 4E75                       		rts
00002FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC8                            ; Check if the plane needs to be redrawn
00002FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC8                            ; PARAMETERS:
00002FC8                            ;	a1.l	- Camera RAM
00002FC8                            ;	a3.l	- Row plane buffer
00002FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC8                            ; RETURNS:
00002FC8                            ;	Nothing
00002FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC8                            Level_ChkRedrawPlane:
00002FC8 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002FCC                            		; Comment out the following line to disable blast processing :^)
00002FCC 6700                       		beq.s	.End				; If not, branch
00002FCE 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002FD2 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002FD4                            
00002FD4                            .End:
00002FD4 4E75                       		rts
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            ; Scroll sections macro
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            scrollInit	macro	label
00002FD6                            SCROLL_LABEL	equs	"\label"
00002FD6                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002FD6                            		endm
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            scrollEnd	macro
00002FD6                            \SCROLL_LABEL\_End:					; End label
00002FD6                            		endm
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            scrollSection	macro
00002FD6                            	if narg<3
00002FD6                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002FD6                            	else
00002FD6                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002FD6                            	endif
00002FD6                            		endm
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            ; Do section scrolling
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            ; PARAMERERS:
00002FD6                            ;	a1.l	- Background camera RAM
00002FD6                            ;	a3.l	- Scroll section data
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            ; RETURNS:
00002FD6                            ;	Nothing
00002FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD6                            ScrollSections:
00002FD6 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing variables
00002FDA 49F8 E452                  		lea	scrollSects.w,a4		; Deformation offset buffer
00002FDE 4BF8 90FE                  		lea	hScrollBuff.w,a5			; Horizontal scroll buffer
00002FE2                            
00002FE2 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002FE4                            
00002FE4 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002FE6 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002FEA 48C4                       		ext.l	d4				; ''
00002FEC E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002FEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FEE                            		; Update each section offset
00002FEE                            		push.w	d0/a4				; Save registers
00002FEE 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002FF2                            
00002FF2                            .ScrollSects:
00002FF2 361B                       		move.w	(a3)+,d3			; Get section speed
00002FF4 48C3                       		ext.l	d3				; ''
00002FF6                            
00002FF6 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002FF8 6A00                       		bpl.s	.NotAuto			; If not, branch
00002FFA 3C04                       		move.w	d4,d6				; Get camera speed
00002FFC CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002FFE E183                       		asl.l	#8,d3				; Shift section speed
00003000 D686                       		add.l	d6,d3				; Add camera speed to section speed
00003002 6000                       		bra.s	.ApplySpeed			; Apply that speed
00003004                            
00003004                            .NotAuto:
00003004 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00003006                            
00003006                            .ApplySpeed:
00003006 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00003008 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
0000300A 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
0000300E                            
0000300E                            		pop.w	d0/a4				; Restore registers
0000300E 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00003012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003012                            		; Set the scroll offsets on screen
00003012 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00003016 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
0000301A                            		
0000301A                            .FindStart:
0000301A 221C                       		move.l	(a4)+,d1			; Get section offset
0000301C 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
0000301E 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00003020 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00003024 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00003026 4441                       		neg.w	d1				; Make it scroll the right direction
00003028 4841                       		swap	d1				; Fix which planes the scroll values go to
0000302A 4441                       		neg.w	d1				; Make the background scroll the right direction
0000302C 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
0000302E                            
0000302E                            .FoundStart:
0000302E 4446                       		neg.w	d6				; Get remaining size of the section
00003030 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00003032 4441                       		neg.w	d1				; Make it scroll the right direction
00003034 4841                       		swap	d1				; Fix which planes the scroll values go to
00003036 4441                       		neg.w	d1				; Make the background scroll the right direction
00003038 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
0000303A                            
0000303A                            .NextSection:
0000303A 321C                       		move.w	(a4)+,d1			; Set scroll offset
0000303C 4441                       		neg.w	d1				; Make the section scroll the correct way
0000303E 2C1C                       		move.l	(a4)+,d6			; Get section size
00003040                            		
00003040                            .CheckScroll:
00003040 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00003042 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00003044 5346                       		subq.w	#1,d6				; Convert for use with dbf
00003046                            
00003046                            .Scroll:
00003046 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00003048 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
0000304C 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00003050 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00003052                            		
00003052                            .EndSection:
00003052 DA46                       		add.w	d6,d5				; Get remaining screen space
00003054                            		
00003054                            .LastSection:
00003054 5345                       		subq.w	#1,d5				; Convert to use with dbf
00003056 6B00                       		bmi.s	.End				; If there are none, exit
00003058                            
00003058                            .FillScroll:
00003058 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
0000305A 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
0000305E                            
0000305E                            .End:
0000305E 4E75                       		rts
00003060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003060                            ; Static background scrolling (no parallax)
00003060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003060                            ; PARAMERERS:
00003060                            ;	a1.l	- Background camera RAM
00003060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003060                            ; RETURNS:
00003060                            ;	Nothing
00003060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003060                            ScrollStaticBG:
00003060 45F8 E88A                  		lea	fgCamVars.w,a2		; Get foreground level drawing variables
00003064 4BF8 90FE                  		lea	hScrollBuff.w,a5		; Horizontal scroll buffer
00003068                            		
00003068 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
0000306A 4481                       		neg.l	d1				; Negate it so it scrolls properly
0000306C 3211                       		move.w	cXPos(a1),d1			; Get background X position
0000306E 4441                       		neg.w	d1				; Negate it so it scrolls properly
00003070                            
00003070 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00003074                            
00003074                            .Scroll:
00003074 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00003076 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
0000307A 4E75                       		rts
0000307C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000307C                            ; Generate fake layer art
0000307C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000307C                            ; PARAMETERS:
0000307C                            ;	a0.l	- Layer art data pointer
0000307C                            ;	a1.l	- Layer tile ID mappings pointer
0000307C                            ;	d0.w	- Layer offset
0000307C                            ;	d1.l	- Buffer pointer
0000307C                            ;	d2.w	- VRAM destination address
0000307C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000307C                            Level_UpdateLayer:
0000307C                            		; Prepare for transfer
0000307C 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
0000307E 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00003080                            		
00003080                            		; Queue a DMA transfer for later
00003080                            		push.l	d0/d3/a1			; Save registers
00003080 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00003084 5243                       		addq.w	#1,d3				; Get size of transfer
00003086 E94B                       		lsl.w	#4,d3				; ''
00003088 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
0000308C                            		pop.l	d0/d3/a1			; Restore registers
0000308C 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00003090                            
00003090                            		; Copy the tiles for the layer
00003090 D040                       		add.w	d0,d0				; Double it
00003092 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00003096                            		
00003096                            .CopyTiles:
00003096 3219                       		move.w	(a1)+,d1			; Get tile offset
00003098 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
0000309C 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
0000309E 24DB                       		move.l	(a3)+,(a2)+			; ''
000030A0 24DB                       		move.l	(a3)+,(a2)+			; ''
000030A2 24DB                       		move.l	(a3)+,(a2)+			; ''
000030A4 24DB                       		move.l	(a3)+,(a2)+			; ''
000030A6 24DB                       		move.l	(a3)+,(a2)+			; ''
000030A8 24DB                       		move.l	(a3)+,(a2)+			; ''
000030AA 24DB                       		move.l	(a3)+,(a2)+			; ''
000030AC 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
000030B0                            
000030B0                            .End
000030B0 4E75                       		rts
000030B2                            ; =========================================================================================================================================================
000030B2                            		include	"Opmodes/Gameplay/Level Collision.asm"
000030B2                            ; =========================================================================================================================================================
000030B2                            ; Level collision functions
000030B2                            ; =========================================================================================================================================================
000030B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030B2                            ; Check if a player object has touched any level collision
000030B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030B2                            PlayerChkCollision:
000030B2 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000030B8 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000030BE 6700                       		beq.s	.NotPrimary			; If not, branch
000030C0 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000030C6                            
000030C6                            .NotPrimary:
000030C6 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
000030CA                            		
000030CA 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
000030CE 3428 001E                  		move.w	_objYVel(a0),d2			; Get Y velocity
000030D2 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
000030D6 0400 0020                  		subi.b	#$20,d0				; Shift it over
000030DA 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
000030DE 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
000030E2 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
000030E6 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
000030EA 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
000030EE 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
000030F2 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
000030F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030F6                            PlayerHitFloorAndWalls:
000030F6 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
000030FA 4A41                       		tst.w	d1				; Have we hit the wall?
000030FC 6A00                       		bpl.s	.NoLeftHit			; If not, branch
000030FE 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003102 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003106                            
00003106                            .NoLeftHit:
00003106 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
0000310A 4A41                       		tst.w	d1				; Have we hit the wall?
0000310C 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000310E D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003112 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003116                            
00003116                            .NoRightHit:
00003116 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
0000311A 4A41                       		tst.w	d1				; Have we hit the floor?
0000311C 6A00                       		bpl.s	.End				; If not, branch
0000311E                            
0000311E 1428 001E                  		move.b	_objYVel(a0),d2			; Get the integer part of the Y velocity
00003122 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00003124 4402                       		neg.b	d2				; Negate it since we are in the floor
00003126 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00003128 6C00                       		bge.s	.TouchFloor			; If so, branch
0000312A B002                       		cmp.b	d2,d0				; What about the other angle that was found?
0000312C 6D00                       		blt.s	.End				; If not, branch
0000312E                            
0000312E                            .TouchFloor:
0000312E 1143 0000                  		move.b	d3,_objAngle(a0)			; Set the angle
00003132 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the floor
00003136 1003                       		move.b	d3,d0				; Copy angle
00003138 0600 0020                  		addi.b	#$20,d0				; Shift it
0000313C 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00003140 6600                       		bne.s	.HitWall			; If so, branch
00003142 1003                       		move.b	d3,d0				; Copy angle
00003144 0600 0010                  		addi.b	#$10,d0				; Shift it
00003148 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
0000314C 6700                       		beq.s	.HitFloor			; If not, branch
0000314E E0E8 001E                  		asr	_objYVel(a0)			; Divide the Y velocity by 2
00003152 6000                       		bra.s	.HitSlope			; Continue
00003154                            
00003154                            .HitFloor:
00003154 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003158 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
0000315E 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00003162                            
00003162                            .HitWall:
00003162 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00003166 0C68 0FC0 001E             		cmpi.w	#$FC0,_objYVel(a0)			; Cap the Y velocity at $FC0
0000316C 6F00                       		ble.s	.HitSlope			; ''
0000316E 317C 0FC0 001E             		move.w	#$FC0,_objYVel(a0)			; ''
00003174                            
00003174                            .HitSlope:
00003174 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00003178 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
0000317E 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00003180 6A00                       		bpl.s	.End				; If so, branch
00003182 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
00003186                            
00003186                            .End:
00003186 4E75                       		rts
00003188                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003188                            PlayerHitLWall:
00003188 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
0000318C 4A41                       		tst.w	d1				; Have we hit the wall?
0000318E 6A00                       		bpl.s	.ChkCeil			; If not, branch
00003190 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003194 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003198 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
0000319E                            
0000319E                            .ChkCeil:
0000319E 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
000031A2 4A41                       		tst.w	d1				; Have we hit the ceiling?
000031A4 6A00                       		bpl.s	.ChkFloor			; If not, branch
000031A6 4441                       		neg.w	d1				; Get the distance inside the ceiling
000031A8 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
000031AC 6400                       		bhs.s	.ChkRightWall			; If so, branch
000031AE D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
000031B2 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031B6 6A00                       		bpl.s	.End				; If not, branch
000031B8 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000031BC                            
000031BC                            .End:
000031BC 4E75                       		rts
000031BE                            
000031BE                            .ChkRightWall:
000031BE 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
000031C2 4A41                       		tst.w	d1				; Have we hit the wall?
000031C4 6A00                       		bpl.s	.End2				; If not, branch
000031C6 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
000031CA 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
000031CE                            		
000031CE                            .End2:
000031CE 4E75                       		rts
000031D0                            
000031D0                            .ChkFloor:
000031D0 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031D4 6B00                       		bmi.s	.End3				; If so, branch
000031D6 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
000031DA 4A41                       		tst.w	d1				; Have we hit the ceiling?
000031DC 6A00                       		bpl.s	.End3				; If not, branch
000031DE D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
000031E2 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
000031E6 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000031EA 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
000031F0 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
000031F4                            		
000031F4                            .End3:
000031F4 4E75                       		rts
000031F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031F6                            PlayerHitCeilAndWalls:
000031F6 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
000031FA 4A41                       		tst.w	d1				; Have we hit the wall?
000031FC 6A00                       		bpl.s	.NoLeftHit			; If not, branch
000031FE 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003202 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003206                            
00003206                            .NoLeftHit:
00003206 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
0000320A 4A41                       		tst.w	d1				; Have we hit the wall?
0000320C 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000320E D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003212 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003216                            
00003216                            .NoRightHit:
00003216 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
0000321A 4A41                       		tst.w	d1				; Have we hit the floor?
0000321C 6A00                       		bpl.s	.End				; If not, branch
0000321E 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of ceiling
00003222 1003                       		move.b	d3,d0				; Get angle
00003224 0600 0020                  		addi.b	#$20,d0				; Shift it
00003228 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
0000322C 6600                       		bne.s	.HitWall			; If so, branch
0000322E 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003232 4E75                       		rts
00003234                            
00003234                            .HitWall:
00003234 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00003238 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
0000323C 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00003242 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00003244 6A00                       		bpl.s	.End				; If so, branch
00003246 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
0000324A                            
0000324A                            .End:
0000324A 4E75                       		rts
0000324C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000324C                            PlayerHitRWall:
0000324C 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00003250 4A41                       		tst.w	d1				; Have we hit the wall?
00003252 6A00                       		bpl.s	.ChkCeil			; If not, branch
00003254 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003258 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
0000325C 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00003262                            
00003262                            .ChkCeil:
00003262 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00003266 4A41                       		tst.w	d1				; Have we hit the ceiling?
00003268 6A00                       		bpl.s	.ChkFloor			; If not, branch
0000326A 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of the ceiling
0000326E 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00003272 6A00                       		bpl.s	.End				; If not, branch
00003274 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003278                            
00003278                            .End:
00003278 4E75                       		rts
0000327A                            
0000327A                            .ChkFloor:
0000327A 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
0000327E 6B00                       		bmi.s	.End2				; If so, branch
00003280 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00003284 4A41                       		tst.w	d1				; Have we hit the ceiling?
00003286 6A00                       		bpl.s	.End2				; If not, branch
00003288 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
0000328C 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00003290 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003294 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
0000329A 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
0000329C                            		
0000329C                            .End2:
0000329C 4E75                       		rts
0000329E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000329E                            ; Reset a player object's status on the floor
0000329E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000329E                            PlayerResetOnFloor:
0000329E                            		playSnd	#sSkid, 2			; Play skid sound
0000329E 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
000032A4 4A28 0000                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000032A8 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
000032AA 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
000032AE                            		
000032AE                            PlayerResetOnFloorPart2:
000032AE 0828 0002 0028             		btst	#2,_objStatus(a0)			; Was Sonic rolling?
000032B4 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
000032B6 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
000032BC 1168 0000 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000032C2 1168 0000 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000032C8 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
000032CC                            	;	subq.w	#5,_objYPos(a0)			; Align with floor
000032CC                            
000032CC                            PlayerResetOnFloorPart3:
000032CC 0228 00DD 0028             		andi.b	#$DD,_objStatus(a0)		; Clear "pushing", and "jumping" flag
000032D2 4228 0000                  		clr.b	_objJumping(a0)			; Clear jumping flag
000032D6 4228 0000                  		clr.b	_objFlipAngle(a0)			; Reset flip angle
000032DA 4228 0000                  		clr.b	_objFlipTurned(a0)			; Reset flip inverted flag
000032DE 4228 0000                  		clr.b	_objFlipRemain(a0)			; Reset flips remaining
000032E2 4E75                       		rts
000032E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032E4                            ; Calculate the room in front of a player object
000032E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032E4                            PlayerCalcRoomInFront:
000032E4 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000032EA 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000032F0 6700                       		beq.s	.NotPrimary			; If not, branch
000032F2 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000032F8                            
000032F8                            .NotPrimary:
000032F8 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
000032FC                            		
000032FC 2628 0014                  		move.l	_objXPos(a0),d3			; Get X position
00003300 2428 0018                  		move.l	_objYPos(a0),d2			; Get Y position
00003304 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00003308 48C1                       		ext.l	d1				; ''
0000330A E181                       		asl.l	#8,d1				; Shift it
0000330C D681                       		add.l	d1,d3				; Add onto X position
0000330E 3228 001E                  		move.w	_objYVel(a0),d1			; Get Y velocity
00003312 48C1                       		ext.l	d1				; ''
00003314 E181                       		asl.l	#8,d1				; Shift it
00003316 D481                       		add.l	d1,d2				; Add onto Y position
00003318 4842                       		swap	d2				; Get actual Y
0000331A 4843                       		swap	d3				; Get actual X
0000331C 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
00003320 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00003324 1200                       		move.b	d0,d1				; Copy angle
00003326 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
0000332A 6700                       		beq.s	.DownUp				; If not, branch
0000332C 5200                       		addq.b	#1,d0				; Shift the angle
0000332E                            
0000332E                            .DownUp:
0000332E 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00003332 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00003336 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
0000333A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
0000333E 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00003342 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00003346 6600                       		bne.s	.ChkWall			; If not, branch
00003348 5042                       		addq.w	#8,d2				; Add 8 to the Y position
0000334A                            
0000334A                            .ChkWall:
0000334A 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
0000334E 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00003352 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00003356                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003356                            ; Calculate the room over a player object
00003356                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003356                            PlayerCalcRoomOverHead:
00003356 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000335C 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00003362 6700                       		beq.s	.NotPrimary			; If not, branch
00003364 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
0000336A                            
0000336A                            .NotPrimary:
0000336A 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
0000336E 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
00003372 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00003376                            		
00003376 0600 0020                  		addi.b	#$20,d0				; Shift the angle
0000337A 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000337E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00003382 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00003386 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
0000338A 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
0000338E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00003392 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00003396                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003396                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00003396                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003396                            PlayerChkFloor:
00003396 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000339C 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000033A2 6700                       		beq.s	.NotPrimary			; If not, branch
000033A4 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000033AA                            
000033AA                            .NotPrimary:
000033AA 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
000033AE                            		
000033AE                            		; Get the angle on the bottom right sensor
000033AE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000033B2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000033B6 7000                       		moveq	#0,d0
000033B8 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000033BC 4880                       		ext.w	d0				; ''
000033BE D440                       		add.w	d0,d2				; Add onto Y position
000033C0 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000033C4 4880                       		ext.w	d0				; ''
000033C6 D640                       		add.w	d0,d3				; Add onto X position
000033C8 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000033CC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033D0 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000033D2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033D6                            		push.w	d1				; Save the primary floor distance
000033D6 3F01                     M 	move.w	d1,-(sp)
000033D8                            
000033D8                            		; Get the angle on the bottom left sensor
000033D8 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000033DC 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000033E0 7000                       		moveq	#0,d0
000033E2 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000033E6 4880                       		ext.w	d0				; ''
000033E8 D440                       		add.w	d0,d2				; Add onto Y position
000033EA 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000033EE 4880                       		ext.w	d0				; ''
000033F0 9640                       		sub.w	d0,d3				; Subtract from X position
000033F2 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000033F6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033FA 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000033FC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003400                            		
00003400                            		; Update the object's angle
00003400                            		pop.w	d0				; Restore the primary floor distance
00003400 301F                     M 	move.w	(sp)+,d0
00003402 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00003404                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003404                            PlayerPickAngle:
00003404 1628 002F                  		move.b	_objTilt(a0),d3			; Get secondary angle
00003408 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
0000340A 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000340C 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003410 C141                       		exg.l	d0,d1				; Switch floor distance values
00003412                            		
00003412                            .ChkSetAngle:
00003412 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003416 6700                       		beq.s	.End				; If not, branch
00003418 1602                       		move.b	d2,d3				; Set the new angle value
0000341A                            		
0000341A                            .End:
0000341A 4E75                       		rts
0000341C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000341C                            ; Get the distance between the floor and the player object
0000341C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000341C                            PlayerChkFloorDist:
0000341C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003420 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003424                            
00003424                            PlayerChkFloorDist_Part2:
00003424 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00003428 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000342C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003430 4246                       		clr.w	d6				; No flip bits
00003432 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003436 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00003438                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003438                            PlayerGetPrimaryAngle:
00003438 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000343C 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003440 6700                       		beq.s	.End				; If not, branch
00003442 1602                       		move.b	d2,d3				; Set the new angle value
00003444                            		
00003444                            .End:
00003444 4E75                       		rts
00003446                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003446                            sub_F846:
00003446 3628 0014                  		move.w	_objXPos(a0),d3
0000344A 3428 0018                  		move.w	_objYPos(a0),d2
0000344E 5942                       		subq.w	#4,d2
00003450 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003456 0C28 000D 0000             		cmpi.b	#$D,_objLRBSolid(a0)		; Are we on the primary path?
0000345C 6700                       		beq.s	.NotPrimary			; If not, branch
0000345E 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003464                            
00003464                            .NotPrimary:
00003464 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003468 4214                       		clr.b	(a4)				; Clear it
0000346A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000346E 4246                       		clr.w	d6				; No flip bits
00003470 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Solidity bits
00003474 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003478 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000347C 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003480 6700                       		beq.s	.End				; If not, branch
00003482 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003484                            
00003484                            .End:
00003484 4E75                       		rts
00003486                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003486                            ; Check for the edge of a floor
00003486                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003486                            PlayerChkFloorEdge:
00003486 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000348A                            
0000348A                            PlayerChkFloorEdge_Part2:
0000348A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000348E 7000                       		moveq	#0,d0
00003490 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003494 4880                       		ext.w	d0				; ''
00003496 D440                       		add.w	d0,d2				; Add onto Y position
00003498                            
00003498                            PlayerChkFloorEdge_Part3:
00003498 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000349E 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000034A4 6700                       		beq.s	.NotPrimary			; If not, branch
000034A6 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000034AC                            
000034AC                            .NotPrimary:
000034AC 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000034B0 4214                       		clr.b	(a4)				; Clear it
000034B2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034B6 4246                       		clr.w	d6				; No flip bits
000034B8 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Solidity bits
000034BC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034C0 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000034C4 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000034C8 6700                       		beq.s	.End				; If not, branch
000034CA 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000034CC                            
000034CC                            .End:
000034CC 4E75                       		rts
000034CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034CE                            ; Get the distance between the floor and an object
000034CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034CE                            ObjCheckFloorDist:
000034CE 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000034D2                            		
000034D2                            ObjCheckFloorDist_Part2:
000034D2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034D6                            
000034D6                            ObjCheckFloorDist_Part3:
000034D6 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000034DA 4880                       		ext.w	d0				; ''
000034DC D440                       		add.w	d0,d2				; Add onto Y position
000034DE 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000034E2 4214                       		clr.b	(a4)				; Clear it
000034E4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034E8 4246                       		clr.w	d6				; No flip bits
000034EA 7A0C                       		moveq	#$C,d5				; Solidity bits
000034EC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034F0 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000034F4 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000034F8 6700                       		beq.s	.End				; If not, branch
000034FA 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000034FC                            
000034FC                            .End:
000034FC 4E75                       		rts
000034FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034FE                            ; Get the distance between a right ceiling and a player object
000034FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034FE                            PlayerChkRightCeilDist:
000034FE                            		; Get the angle on the bottom right (rotated) sensor
000034FE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003502 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003506 7000                       		moveq	#0,d0
00003508 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
0000350C 4880                       		ext.w	d0				; ''
0000350E 9440                       		sub.w	d0,d2				; Subtract from Y position
00003510 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
00003514 4880                       		ext.w	d0				; ''
00003516 D640                       		add.w	d0,d3				; Add onto X position
00003518 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000351C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003520 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003522 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003526                            		push.w	d1				; Save the primary floor distance
00003526 3F01                     M 	move.w	d1,-(sp)
00003528                            
00003528                            		; Get the angle on the bottom left (rotated) sensor
00003528 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000352C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003530 7000                       		moveq	#0,d0
00003532 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
00003536 4880                       		ext.w	d0				; ''
00003538 D440                       		add.w	d0,d2				; Add onto Y position
0000353A 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
0000353E 4880                       		ext.w	d0				; ''
00003540 D640                       		add.w	d0,d3				; Add onto X position
00003542 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003546 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000354A 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000354C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003550                            
00003550                            		; Update the object's angle
00003550                            		pop.w	d0				; Restore the primary floor distance
00003550 301F                     M 	move.w	(sp)+,d0
00003552 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003556 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
0000355A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000355A                            ; Get the distance between a right wall and a player object
0000355A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000355A                            PlayerChkRightWallDist:
0000355A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000355E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003562                            
00003562                            PlayerChkRightWallDist_Part2:
00003562 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
00003566 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000356A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000356E 4246                       		clr.w	d6				; No flip bits
00003570 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003574 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003578 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000357C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000357C                            ; Get the distance between a right wall and an object
0000357C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000357C                            ObjCheckRightWallDist:
0000357C D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
00003580 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003584 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003588 4214                       		clr.b	(a4)				; Clear it
0000358A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000358E 4246                       		clr.w	d6				; No flip bits
00003590 7A0D                       		moveq	#$D,d5				; Solidity bits
00003592 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003596 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000359A 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000359E 6700                       		beq.s	.End				; If not, branch
000035A0 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
000035A4                            
000035A4                            .End:
000035A4 4E75                       		rts
000035A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035A6                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
000035A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035A6                            PlayerChkCeiling:
000035A6                            		; Get the angle on the bottom right sensor
000035A6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035AA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035AE 7000                       		moveq	#0,d0
000035B0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035B4 4880                       		ext.w	d0				; ''
000035B6 9440                       		sub.w	d0,d2				; Subtract from Y position
000035B8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000035BC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035C0 4880                       		ext.w	d0				; ''
000035C2 D640                       		add.w	d0,d3				; Add onto X position
000035C4 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000035C8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035CC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000035D0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000035D4                            		push.w	d1				; Save the primary floor distance
000035D4 3F01                     M 	move.w	d1,-(sp)
000035D6                            
000035D6                            		; Get the angle on the bottom left sensor
000035D6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035DA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035DE 7000                       		moveq	#0,d0
000035E0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035E4 4880                       		ext.w	d0				; ''
000035E6 9440                       		sub.w	d0,d2				; Subtract from Y position
000035E8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000035EC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035F0 4880                       		ext.w	d0				; ''
000035F2 9640                       		sub.w	d0,d3				; Subtract from X position
000035F4 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000035F8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035FC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003600 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003604                            		
00003604                            		; Update the object's angle
00003604                            		pop.w	d0				; Restore the primary floor distance
00003604 301F                     M 	move.w	(sp)+,d0
00003606 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000360A 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
0000360E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000360E                            ; Get the distance between a ceiling and a player object
0000360E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000360E                            PlayerChkCeilingDist:
0000360E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003612 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003616                            
00003616                            PlayerChkCeilingDist_Part2:
00003616 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
0000361A 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000361E 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003622 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003626 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000362A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000362E 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003632 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003636                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003636                            ; Get the distance between a ceiling and an object
00003636                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003636                            ObjCheckCeilingDist:
00003636 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000363A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000363E 7000                       		moveq	#0,d0
00003640 1028 002D                  		move.b	_objColH(a0),d0		; Get collision height
00003644 4880                       		ext.w	d0				; ''
00003646 9440                       		sub.w	d0,d2				; Subtract it from Y position
00003648 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000364C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003650 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003654 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003658 7A0D                       		moveq	#$D,d5				; Solidity bits
0000365A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000365E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003662 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003666 6700                       		beq.s	.End				; If not, branch
00003668 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000366C                            
0000366C                            .End:
0000366C 4E75                       		rts
0000366E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000366E                            ; Get the distance between a left ceiling and a player object
0000366E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000366E                            PlayerChkLeftCeilDist:
0000366E                            		; Get the angle on the bottom right (rotated) sensor
0000366E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003672 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003676 7000                       		moveq	#0,d0
00003678 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000367C 4880                       		ext.w	d0				; ''
0000367E 9440                       		sub.w	d0,d2				; Subtract from Y position
00003680 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003684 4880                       		ext.w	d0				; ''
00003686 9640                       		sub.w	d0,d3				; Subtract from X position
00003688 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000368C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003690 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003694 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003698 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000369C                            		push.w	d1				; Save the primary floor distance
0000369C 3F01                     M 	move.w	d1,-(sp)
0000369E                            
0000369E                            		; Get the angle on the bottom left (rotated) sensor
0000369E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000036A2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000036A6 7000                       		moveq	#0,d0
000036A8 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000036AC 4880                       		ext.w	d0				; ''
000036AE D440                       		add.w	d0,d2				; Add onto Y position
000036B0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000036B4 4880                       		ext.w	d0				; ''
000036B6 9640                       		sub.w	d0,d3				; Subtract from X position
000036B8 0A43 000F                  		eori.w	#$F,d3				; Flip it
000036BC 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000036C0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000036C4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000036C8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000036CC                            
000036CC                            		; Update the object's angle
000036CC                            		pop.w	d0				; Restore the primary floor distance
000036CC 301F                     M 	move.w	(sp)+,d0
000036CE 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000036D2 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
000036D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036D6                            ; Get the distance between a left wall and a player object
000036D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036D6                            PlayerChkLeftWallDist:
000036D6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000036DA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000036DE                            
000036DE                            PlayerChkLeftWallDist_Part2:
000036DE 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
000036E2 0A43 000F                  		eori.w	#$F,d3				; Flip it
000036E6 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000036EA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000036EE 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000036F2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000036F6 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000036FA 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000036FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036FE                            ; Get the distance between a left wall and an object
000036FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036FE                            ObjCheckLeftWallDist:
000036FE D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
00003702 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003706 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000370A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000370E 4214                       		clr.b	(a4)				; Clear it
00003710 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003714 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003718 7A0D                       		moveq	#$D,d5				; Solidity bits
0000371A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000371E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003722 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003726 6700                       		beq.s	.End				; If not, branch
00003728 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000372C                            
0000372C                            .End:
0000372C 4E75                       		rts
0000372E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000372E                            ; Move a player object along on the ground
0000372E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000372E                            PlayerAnglePos:
0000372E 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003734 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000373A 6700                       		beq.s	.NotPrimary			; If not, branch
0000373C 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003742                            
00003742                            .NotPrimary:
00003742 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
00003746 0828 0003 0028             		btst	#3,_objStatus(a0)			; Are we standing on a player object?
0000374C 6700                       		beq.s	.NotOnObj			; If not, branch
0000374E 4268 002E                  		clr.w	_objNextTilt(a0)			; Set the angles to 0
00003752 4E75                       		rts
00003754                            
00003754                            .NotOnObj:
00003754 317C 0303 002E             		move.w	#$0303,_objNextTilt(a0)		; Set the angles to 3
0000375A                            		
0000375A                            		; Get which quadrant the object is in on the ground
0000375A                            		; This makes it so that angles:
0000375A                            		; 	$E0-$20 = Quadrant 0 (floor)
0000375A                            		;	$1F-$5F = Quadrant $40 (left wall)
0000375A                            		;	$60-$A0 = Quadrant $80 (ceiling)
0000375A                            		;	$A1-$DF = Quadrant $C0 (right wall)
0000375A 1028 0000                  		move.b	_objAngle(a0),d0			; Get the angle
0000375E 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003762 6700                       		beq.s	.DownUp				; If not, branch
00003764 5200                       		addq.b	#1,d0				; Shift the angle
00003766                            
00003766                            .DownUp:
00003766 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000376A 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
0000376E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003772 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
00003776 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
0000377A 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
0000377E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003782 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
00003786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003786                            ; Move the object along the floor
00003786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003786                            PlayerMoveFloor:
00003786                            		; Get the angle on the bottom right sensor
00003786 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000378A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000378E 7000                       		moveq	#0,d0
00003790 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003794 4880                       		ext.w	d0				; ''
00003796 D440                       		add.w	d0,d2				; Add onto Y position
00003798 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000379C 4880                       		ext.w	d0				; ''
0000379E D640                       		add.w	d0,d3				; Add onto X position
000037A0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000037A4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000037A8 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000037AA 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000037AE                            		push.w	d1				; Save the primary floor distance
000037AE 3F01                     M 	move.w	d1,-(sp)
000037B0                            
000037B0                            		; Get the angle on the bottom left sensor
000037B0 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000037B4 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000037B8 7000                       		moveq	#0,d0
000037BA 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000037BE 4880                       		ext.w	d0				; ''
000037C0 D440                       		add.w	d0,d2				; Add onto Y position
000037C2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000037C6 4880                       		ext.w	d0				; ''
000037C8 9640                       		sub.w	d0,d3				; Add onto X position
000037CA 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000037CE 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000037D2 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000037D4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000037D8                            		
000037D8                            		; Update the object's angle
000037D8                            		pop.w	d0				; Restore the primary floor distance
000037D8 301F                     M 	move.w	(sp)+,d0
000037DA 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
000037DE                            		
000037DE                            		; Check if the object has hit a wall or is about to fall
000037DE 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000037E0 6700                       		beq.s	.End				; If so, branch
000037E2 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000037E4 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000037E8 6D00                       		blt.s	.End				; If so, branch
000037EA D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
000037EE                            
000037EE                            .End:
000037EE 4E75                       		rts
000037F0                            
000037F0                            .ChkFall:
000037F0 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
000037F4 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000037F6 4400                       		neg.b	d0				; Force it to be positive
000037F8                            
000037F8                            .GetMinDist:
000037F8 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000037FA 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000037FE 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003800 103C 000E                  		move.b	#$E,d0				; ''
00003804                            
00003804                            .ChkDist:
00003804 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003806 6E00                       		bgt.s	.SetAir				; If so, branch
00003808 D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
0000380C 4E75                       		rts
0000380E                            
0000380E                            .SetAir:
0000380E 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003814 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
0000381A 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003820 4E75                       		rts
00003822                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003822                            ; Set the objects's angle
00003822                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003822                            PlayerSetAngle:
00003822 1428 002F                  		move.b	_objTilt(a0),d2			; Get secondary angle
00003826 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00003828 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000382A 1428 002E                  		move.b	_objNextTilt(a0),d2		; Get primary angle
0000382E 3200                       		move.w	d0,d1				; Get primary floor distance
00003830                            		
00003830                            .ChkSetAngle:
00003830 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
00003834 6600                       		bne.s	.LatchOnFlat			; If so, branch
00003836 1002                       		move.b	d2,d0				; Get angle change
00003838 9028 0000                  		sub.b	_objAngle(a0),d0			; ''
0000383C 6A00                       		bpl.s	.ChkDist			; ''
0000383E 4400                       		neg.b	d0				; ''
00003840                            
00003840                            .ChkDist:
00003840 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
00003844 6400                       		bhs.s	.LatchOnFlat			; If so, branch
00003846 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
0000384A 4E75                       		rts
0000384C                            
0000384C                            .LatchOnFlat:
0000384C 1428 0000                  		move.b	_objAngle(a0),d2			; Get old angle value
00003850 0602 0020                  		addi.b	#$20,d2				; Shift the angle
00003854 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
00003858 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
0000385C 4E75                       		rts
0000385E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000385E                            ; Move the object along the right wall
0000385E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000385E                            PlayerMoveRWall:
0000385E                            		; Get the angle on the bottom right (rotated) sensor
0000385E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003862 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003866 7000                       		moveq	#0,d0
00003868 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000386C 4880                       		ext.w	d0				; ''
0000386E 9440                       		sub.w	d0,d2				; Add onto Y position
00003870 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003874 4880                       		ext.w	d0				; ''
00003876 D640                       		add.w	d0,d3				; Add onto X position
00003878 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000387C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003880 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003882 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003886                            		push.w	d1				; Save the primary floor distance
00003886 3F01                     M 	move.w	d1,-(sp)
00003888                            
00003888                            		; Get the angle on the bottom left (rotated) sensor
00003888 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000388C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003890 7000                       		moveq	#0,d0
00003892 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003896 4880                       		ext.w	d0				; ''
00003898 D440                       		add.w	d0,d2				; Add onto Y position
0000389A 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000389E 4880                       		ext.w	d0				; ''
000038A0 D640                       		add.w	d0,d3				; Add onto X position
000038A2 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000038A6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000038AA 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000038AC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000038B0                            		
000038B0                            		; Update the object's angle
000038B0                            		pop.w	d0				; Restore the primary floor distance
000038B0 301F                     M 	move.w	(sp)+,d0
000038B2 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
000038B6                            
000038B6                            		; Check if the object has hit a wall or is about to fall
000038B6 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000038B8 6700                       		beq.s	.End				; If so, branch
000038BA 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000038BC 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000038C0 6D00                       		blt.s	.End				; If so, branch
000038C2 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
000038C6                            
000038C6                            .End:
000038C6 4E75                       		rts
000038C8                            
000038C8                            .ChkFall:
000038C8 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
000038CC 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000038CE 4400                       		neg.b	d0				; Force it to be positive
000038D0                            
000038D0                            .GetMinDist:
000038D0 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000038D2 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000038D6 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000038D8 103C 000E                  		move.b	#$E,d0				; ''
000038DC                            
000038DC                            .ChkDist:
000038DC B200                       		cmp.b	d0,d1				; Are we about to fall off?
000038DE 6E00                       		bgt.s	.SetAir				; If so, branch
000038E0 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
000038E4 4E75                       		rts
000038E6                            
000038E6                            .SetAir:
000038E6 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000038EC 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000038F2 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000038F8 4E75                       		rts
000038FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038FA                            ; Move the object along the ceiling
000038FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038FA                            PlayerMoveCeiling:
000038FA                            		; Get the angle on the bottom right (rotated) sensor
000038FA 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000038FE 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003902 7000                       		moveq	#0,d0
00003904 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003908 4880                       		ext.w	d0				; ''
0000390A 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000390C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003910 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003914 4880                       		ext.w	d0				; ''
00003916 D640                       		add.w	d0,d3				; Add onto X position
00003918 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000391C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003920 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003924 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003928                            		push.w	d1				; Save the primary floor distance
00003928 3F01                     M 	move.w	d1,-(sp)
0000392A                            
0000392A                            		; Get the angle on the bottom left (rotated) sensor
0000392A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000392E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003932 7000                       		moveq	#0,d0
00003934 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003938 4880                       		ext.w	d0				; ''
0000393A 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000393C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003940 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003944 4880                       		ext.w	d0				; ''
00003946 9640                       		sub.w	d0,d3				; Subtract from the X position
00003948 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000394C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003950 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003954 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003958                            		
00003958                            		; Update the object's angle
00003958                            		pop.w	d0				; Restore the primary floor distance
00003958 301F                     M 	move.w	(sp)+,d0
0000395A 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
0000395E                            		
0000395E                            		; Check if the object has hit a wall or is about to fall
0000395E 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003960 6700                       		beq.s	.End				; If so, branch
00003962 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003964 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003968 6D00                       		blt.s	.End				; If so, branch
0000396A 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
0000396E                            
0000396E                            .End:
0000396E 4E75                       		rts
00003970                            
00003970                            .ChkFall:
00003970 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
00003974 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003976 4400                       		neg.b	d0				; Force it to be positive
00003978                            
00003978                            .GetMinDist:
00003978 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
0000397A 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000397E 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003980 103C 000E                  		move.b	#$E,d0				; ''
00003984                            
00003984                            .ChkDist:
00003984 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003986 6E00                       		bgt.s	.SetAir				; If so, branch
00003988 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
0000398C 4E75                       		rts
0000398E                            
0000398E                            .SetAir:
0000398E 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003994 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
0000399A 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000039A0 4E75                       		rts
000039A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039A2                            ; Move the object along the left wall
000039A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039A2                            PlayerMoveLWall:
000039A2                            		; Get the angle on the bottom right (rotated) sensor
000039A2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000039A6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000039AA 7000                       		moveq	#0,d0
000039AC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000039B0 4880                       		ext.w	d0				; ''
000039B2 9440                       		sub.w	d0,d2				; Subtract from the Y position
000039B4 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000039B8 4880                       		ext.w	d0				; ''
000039BA 9640                       		sub.w	d0,d3				; Subtract from X position
000039BC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000039C0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000039C4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000039C8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000039CC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000039D0                            		push.w	d1				; Save the primary floor distance
000039D0 3F01                     M 	move.w	d1,-(sp)
000039D2                            
000039D2                            		; Get the angle on the bottom left (rotated) sensor
000039D2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000039D6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000039DA 7000                       		moveq	#0,d0
000039DC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000039E0 4880                       		ext.w	d0				; ''
000039E2 D440                       		add.w	d0,d2				; Add onto Y position
000039E4 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000039E8 4880                       		ext.w	d0				; ''
000039EA 9640                       		sub.w	d0,d3				; Subtract from X position
000039EC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000039F0 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000039F4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000039F8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000039FC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003A00                            		
00003A00                            		; Update the object's angle
00003A00                            		pop.w	d0				; Restore the primary floor distance
00003A00 301F                     M 	move.w	(sp)+,d0
00003A02 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003A06                            		
00003A06                            		; Check if the object has hit a wall or is about to fall
00003A06 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003A08 6700                       		beq.s	.End				; If so, branch
00003A0A 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003A0C 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003A10 6D00                       		blt.s	.End				; If so, branch
00003A12 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
00003A16                            
00003A16                            .End:
00003A16 4E75                       		rts
00003A18                            
00003A18                            .ChkFall:
00003A18 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
00003A1C 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003A1E 4400                       		neg.b	d0				; Force it to be positive
00003A20                            
00003A20                            .GetMinDist:
00003A20 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003A22 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003A26 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003A28 103C 000E                  		move.b	#$E,d0				; ''
00003A2C                            
00003A2C                            .ChkDist:
00003A2C B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003A2E 6E00                       		bgt.s	.SetAir				; If so, branch
00003A30 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
00003A34 4E75                       		rts
00003A36                            
00003A36                            .SetAir:
00003A36 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003A3C 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003A42 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003A48 4E75                       		rts
00003A4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A4A                            ; Find the nearest floor from the object's position
00003A4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A4A                            ; PARAMETERS:
00003A4A                            ;	d2.w	- Y position of the object's bottom sensor
00003A4A                            ;	d3.w	- X position of the object's bottom sensor
00003A4A                            ;	d5.w	- Bit to chect for solidity
00003A4A                            ;	d6.w	- Flip bits (for walls and ceilings)
00003A4A                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
00003A4A                            ;	a4.w	- Pointer to where the angle value will be stored
00003A4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A4A                            ; RETURNS:
00003A4A                            ;	d1.w	- The distance from the object to the floor
00003A4A                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003A4A                            ;	(a4).w	- The floor angle
00003A4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A4A                            Level_FindFloor:
00003A4A 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003A4E 3011                       		move.w	(a1),d0				; Get block ID
00003A50 3800                       		move.w	d0,d4				; Copy that
00003A52 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003A56 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003A58 0B04                       		btst	d5,d4				; Is the block solid?
00003A5A 6600                       		bne.s	.IsSolid			; If so, branch
00003A5C                            
00003A5C                            .IsBlank:
00003A5C D44B                       		add.w	a3,d2				; Check below the sensor
00003A5E 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003A62 944B                       		sub.w	a3,d2				; Restore Y position of sensor
00003A64 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003A68 4E75                       		rts
00003A6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A6A                            .IsSolid:
00003A6A 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003A6E D040                       		add.w	d0,d0				; Turn ID into offset
00003A70 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003A74 0240 00FF                  		andi.w	#$FF,d0				; ''
00003A78 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003A7A                            
00003A7A 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003A7E 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003A82 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003A84                            
00003A84 3203                       		move.w	d3,d1				; Get the object's X position
00003A86 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003A8A 6700                       		beq.s	.NoXFlip			; If not, branch
00003A8C 4641                       		not.w	d1				; Flip the X position
00003A8E 4414                       		neg.b	(a4)				; Flip the angle
00003A90                            		
00003A90                            .NoXFlip:
00003A90 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003A94 6700                       		beq.s	.NoYFlip			; If not, branch
00003A96 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003A9A 4414                       		neg.b	(a4)				; ''
00003A9C 0414 0040                  		subi.b	#$40,(a4)			; ''
00003AA0                            
00003AA0                            .NoYFlip:
00003AA0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003AA4 D240                       		add.w	d0,d1				; Add the collision block's offset
00003AA6                            
00003AA6 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003AAA 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003AAE 4880                       		ext.w	d0				; ''
00003AB0 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003AB2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003AB6 6700                       		beq.s	.NoYFlip2			; If not, branch
00003AB8 4440                       		neg.w	d0				; Flip the height
00003ABA                            
00003ABA                            .NoYFlip2:
00003ABA 4A40                       		tst.w	d0				; Check the height
00003ABC 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003ABE 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003AC0 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003AC4 6700                       		beq.s	.MaxFloor			; If so, branch
00003AC6 3202                       		move.w	d2,d1				; Get the object's Y position
00003AC8 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003ACC D041                       		add.w	d1,d0				; Add onto the height
00003ACE 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003AD2 9240                       		sub.w	d0,d1				; ''
00003AD4 4E75                       		rts
00003AD6                            
00003AD6                            .NegHeight:
00003AD6 3202                       		move.w	d2,d1				; Get the object's Y position
00003AD8 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003ADC D041                       		add.w	d1,d0				; Add onto the height
00003ADE 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003AE2                            
00003AE2                            .MaxFloor:
00003AE2 944B                       		sub.w	a3,d2				; Check above the sensor
00003AE4 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
00003AE6 D44B                       		add.w	a3,d2				; Restore Y position of sensor
00003AE8 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003AEC 4E75                       		rts
00003AEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AEE                            Level_FindFloor2:
00003AEE 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003AF2 3011                       		move.w	(a1),d0				; Get block ID
00003AF4 3800                       		move.w	d0,d4				; Copy that
00003AF6 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003AFA 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003AFC 0B04                       		btst	d5,d4				; Is the block solid?
00003AFE 6600                       		bne.s	.IsSolid			; If so, branch
00003B00                            
00003B00                            .IsBlank:
00003B00 323C 000F                  		move.w	#$F,d1				; Get max distance
00003B04 3002                       		move.w	d2,d0				; Get the object's Y position
00003B06 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
00003B0A 9240                       		sub.w	d0,d1				; Get actual distance
00003B0C 4E75                       		rts
00003B0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B0E                            .IsSolid:
00003B0E 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003B12 D040                       		add.w	d0,d0				; Turn ID into offset
00003B14 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003B18 0240 00FF                  		andi.w	#$FF,d0				; ''
00003B1C 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003B1E                            
00003B1E 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003B22 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003B26 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003B28                            
00003B28 3203                       		move.w	d3,d1				; Get the object's X position
00003B2A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003B2E 6700                       		beq.s	.NoXFlip			; If not, branch
00003B30 4641                       		not.w	d1				; Flip the X position
00003B32 4414                       		neg.b	(a4)				; Flip the angle
00003B34                            
00003B34                            .NoXFlip:
00003B34 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003B38 6700                       		beq.s	.NoYFlip			; If not, branch
00003B3A 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003B3E 4414                       		neg.b	(a4)				; ''
00003B40 0414 0040                  		subi.b	#$40,(a4)			; ''
00003B44                            
00003B44                            .NoYFlip:
00003B44 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003B48 D240                       		add.w	d0,d1				; Add the collision block's offset
00003B4A                            
00003B4A 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003B4E 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003B52 4880                       		ext.w	d0				; ''
00003B54 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003B56 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003B5A 6700                       		beq.s	.NoYFlip2			; If not, branch
00003B5C 4440                       		neg.w	d0				; Flip the height
00003B5E                            
00003B5E                            .NoYFlip2:
00003B5E 4A40                       		tst.w	d0				; Check the height
00003B60 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003B62 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003B64 3202                       		move.w	d2,d1				; Get the object's Y position
00003B66 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003B6A D041                       		add.w	d1,d0				; Add onto the height
00003B6C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003B70 9240                       		sub.w	d0,d1				; ''
00003B72 4E75                       		rts
00003B74                            
00003B74                            .NegHeight:
00003B74 3202                       		move.w	d2,d1				; Get the object's Y position
00003B76 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003B7A D041                       		add.w	d1,d0				; Add onto the height
00003B7C 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003B80 4641                       		not.w	d1				; Flip the height
00003B82 4E75                       		rts
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            ; Find the nearest wall from the object's position
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            ; PARAMETERS:
00003B84                            ;	d2.w	- Y position of the object's bottom sensor
00003B84                            ;	d3.w	- X position of the object's bottom sensor
00003B84                            ;	d5.w	- Bit to chect for solidity
00003B84                            ;	d6.w	- Flip bits (for walls and ceilings)
00003B84                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003B84                            ;	a4.w	- Pointer to where the angle value will be stored
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            ; RETURNS:
00003B84                            ;	d1.w	- The distance from the object to the floor
00003B84                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003B84                            ;	(a4).w	- The floor angle
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            Level_FindWall:
00003B84 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003B88 3011                       		move.w	(a1),d0				; Get block ID
00003B8A 3800                       		move.w	d0,d4				; Copy that
00003B8C 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003B90 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003B92 0B04                       		btst	d5,d4				; Is the block solid?
00003B94 6600                       		bne.s	.IsSolid			; If so, branch
00003B96                            
00003B96                            .IsBlank:
00003B96 D64B                       		add.w	a3,d3				; Check right to the sensor
00003B98 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
00003B9C 964B                       		sub.w	a3,d3				; Restore X position of sensor
00003B9E 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003BA2 4E75                       		rts
00003BA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BA4                            .IsSolid:
00003BA4 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003BA8 D040                       		add.w	d0,d0				; Turn ID into offset
00003BAA 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003BAE 0240 00FF                  		andi.w	#$FF,d0				; ''
00003BB2 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003BB4                            
00003BB4 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003BB8 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003BBC E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003BBE                            
00003BBE 3202                       		move.w	d2,d1				; Get the object's Y position
00003BC0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003BC4 6700                       		beq.s	.NoYFlip			; If not, branch
00003BC6 4641                       		not.w	d1				; Flip the Y position
00003BC8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003BCC 4414                       		neg.b	(a4)				; ''
00003BCE 0414 0040                  		subi.b	#$40,(a4)			; ''
00003BD2                            
00003BD2                            .NoYFlip:
00003BD2 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003BD6 6700                       		beq.s	.NoXFlip			; If not, branch
00003BD8 4414                       		neg.b	(a4)				; Flip the angle
00003BDA                            
00003BDA                            .NoXFlip:
00003BDA 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003BDE D240                       		add.w	d0,d1				; Add the collision block's offset
00003BE0                            
00003BE0 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003BE4 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003BE8 4880                       		ext.w	d0				; ''
00003BEA BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003BEC 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003BF0 6700                       		beq.s	.NoYFlip2			; If not, branch
00003BF2 4440                       		neg.w	d0				; Flip the height
00003BF4                            
00003BF4                            .NoYFlip2:
00003BF4 4A40                       		tst.w	d0				; Check the height
00003BF6 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003BF8 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003BFA 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003BFE 6700                       		beq.s	.MaxFloor			; If so, branch
00003C00 3203                       		move.w	d3,d1				; Get the object's X position
00003C02 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003C06 D041                       		add.w	d1,d0				; Add onto the height
00003C08 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003C0C 9240                       		sub.w	d0,d1				; ''
00003C0E 4E75                       		rts
00003C10                            
00003C10                            .NegHeight:
00003C10 3203                       		move.w	d3,d1				; Get the object's X position
00003C12 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003C16 D041                       		add.w	d1,d0				; Add onto the height
00003C18 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003C1C                            
00003C1C                            .MaxFloor:
00003C1C 964B                       		sub.w	a3,d3				; Check left to the sensor
00003C1E 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003C20 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003C22 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003C26 4E75                       		rts
00003C28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C28                            Level_FindWall2:
00003C28 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003C2C 3011                       		move.w	(a1),d0				; Get block ID
00003C2E 3800                       		move.w	d0,d4				; Copy that
00003C30 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003C34 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003C36 0B04                       		btst	d5,d4				; Is the block solid?
00003C38 6600                       		bne.s	.IsSolid			; If so, branch
00003C3A                            
00003C3A                            .IsBlank:
00003C3A 323C 000F                  		move.w	#$F,d1				; Get max distance
00003C3E 3003                       		move.w	d3,d0				; Get the object's X position
00003C40 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003C44 9240                       		sub.w	d0,d1				; Get actual distance
00003C46 4E75                       		rts
00003C48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C48                            .IsSolid:
00003C48 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003C4C D040                       		add.w	d0,d0				; Turn ID into offset
00003C4E 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003C52 0240 00FF                  		andi.w	#$FF,d0				; ''
00003C56 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003C58                            
00003C58 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003C5C 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003C60 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003C62                            
00003C62 3202                       		move.w	d2,d1				; Get the object's Y position
00003C64 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003C68 6700                       		beq.s	.NoYFlip			; If not, branch
00003C6A 4641                       		not.w	d1				; Flip the Y position
00003C6C 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003C70 4414                       		neg.b	(a4)				; ''
00003C72 0414 0040                  		subi.b	#$40,(a4)			; ''
00003C76                            
00003C76                            .NoYFlip:
00003C76 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003C7A 6700                       		beq.s	.NoXFlip			; If not, branch
00003C7C 4414                       		neg.b	(a4)				; Flip the angle
00003C7E                            
00003C7E                            .NoXFlip:
00003C7E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003C82 D240                       		add.w	d0,d1				; Add the collision block's offset
00003C84                            
00003C84 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003C88 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003C8C 4880                       		ext.w	d0				; ''
00003C8E BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003C90 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003C94 6700                       		beq.s	.NoYFlip2			; If not, branch
00003C96 4440                       		neg.w	d0				; Flip the height
00003C98                            
00003C98                            .NoYFlip2:
00003C98 4A40                       		tst.w	d0				; Check the height
00003C9A 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003C9C 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003C9E 3203                       		move.w	d3,d1				; Get the object's X position
00003CA0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003CA4 D041                       		add.w	d1,d0				; Add onto the height
00003CA6 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003CAA 9240                       		sub.w	d0,d1				; ''
00003CAC 4E75                       		rts
00003CAE                            
00003CAE                            .NegHeight:
00003CAE 3203                       		move.w	d3,d1				; Get the object's X position
00003CB0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003CB4 D041                       		add.w	d1,d0				; Add onto the height
00003CB6 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003CBA 4641                       		not.w	d1				; Flip the height
00003CBC 4E75                       		rts
00003CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CBE                            ; Find the nearest block in the level from the player
00003CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CBE                            ; PARAMETERS:
00003CBE                            ;	d2.w	- Y position of the object's sensor
00003CBE                            ;	d3.w	- X position of the object's sensor
00003CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CBE                            ; RETURNS:
00003CBE                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CBE                            Level_FindBlock:
00003CBE 2278 E856                  		movea.l	lvlLayout.w,a1			; Get level layout pointer address
00003CC2                            
00003CC2 3002                       		move.w	d2,d0				; Get the object's Y position
00003CC4 0240 0780                  		andi.w	#$780,d0			; Get Y within layout data
00003CC8 EC48                       		lsr.w	#6,d0				; ''						
00003CCA 3031 0002                  		move.w	2(a1,d0.w),d0			; Get chunk row offset
00003CCE                            		
00003CCE 3203                       		move.w	d3,d1				; Get the object's X position
00003CD0 E649                       		lsr.w	#3,d1				; Divide by 8
00003CD2 3801                       		move.w	d1,d4				; Save for later
00003CD4                            		
00003CD4 E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
00003CD6 0241 00FF                  		andi.w	#$FF,d1				; Only 256 chunks per row
00003CDA D041                       		add.w	d1,d0				; Get offset in the level layout
00003CDC                            
00003CDC 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
00003CDE 4241                       		clr.w	d1				; ''
00003CE0                            		
00003CE0 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
00003CE4 D241                       		add.w	d1,d1				; Turn into offset
00003CE6 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
00003CEA 3002                       		move.w	d2,d0				; Get the object's Y position
00003CEC                            		
00003CEC 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
00003CF0 D240                       		add.w	d0,d1				; Add onto the offset
00003CF2 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
00003CF6 D244                       		add.w	d4,d1				; Add onto the offset
00003CF8                            		
00003CF8 2241                       		movea.l	d1,a1				; Get pointer in chunk table
00003CFA 4E75                       		rts
00003CFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CFC                            .ChunkOffsets:
00003CFC =00000000                  c		= 0
00003CFC                            		rept	256
00003CFC                            			dc.w	c
00003CFC                            c			= c+$80
00003CFC                            		endr
00003CFC 0000                     M 	dc.w	c
00003CFE =00000080                M c	=	c+$80
00003CFE 0080                     M 	dc.w	c
00003D00 =00000100                M c	=	c+$80
00003D00 0100                     M 	dc.w	c
00003D02 =00000180                M c	=	c+$80
00003D02 0180                     M 	dc.w	c
00003D04 =00000200                M c	=	c+$80
00003D04 0200                     M 	dc.w	c
00003D06 =00000280                M c	=	c+$80
00003D06 0280                     M 	dc.w	c
00003D08 =00000300                M c	=	c+$80
00003D08 0300                     M 	dc.w	c
00003D0A =00000380                M c	=	c+$80
00003D0A 0380                     M 	dc.w	c
00003D0C =00000400                M c	=	c+$80
00003D0C 0400                     M 	dc.w	c
00003D0E =00000480                M c	=	c+$80
00003D0E 0480                     M 	dc.w	c
00003D10 =00000500                M c	=	c+$80
00003D10 0500                     M 	dc.w	c
00003D12 =00000580                M c	=	c+$80
00003D12 0580                     M 	dc.w	c
00003D14 =00000600                M c	=	c+$80
00003D14 0600                     M 	dc.w	c
00003D16 =00000680                M c	=	c+$80
00003D16 0680                     M 	dc.w	c
00003D18 =00000700                M c	=	c+$80
00003D18 0700                     M 	dc.w	c
00003D1A =00000780                M c	=	c+$80
00003D1A 0780                     M 	dc.w	c
00003D1C =00000800                M c	=	c+$80
00003D1C 0800                     M 	dc.w	c
00003D1E =00000880                M c	=	c+$80
00003D1E 0880                     M 	dc.w	c
00003D20 =00000900                M c	=	c+$80
00003D20 0900                     M 	dc.w	c
00003D22 =00000980                M c	=	c+$80
00003D22 0980                     M 	dc.w	c
00003D24 =00000A00                M c	=	c+$80
00003D24 0A00                     M 	dc.w	c
00003D26 =00000A80                M c	=	c+$80
00003D26 0A80                     M 	dc.w	c
00003D28 =00000B00                M c	=	c+$80
00003D28 0B00                     M 	dc.w	c
00003D2A =00000B80                M c	=	c+$80
00003D2A 0B80                     M 	dc.w	c
00003D2C =00000C00                M c	=	c+$80
00003D2C 0C00                     M 	dc.w	c
00003D2E =00000C80                M c	=	c+$80
00003D2E 0C80                     M 	dc.w	c
00003D30 =00000D00                M c	=	c+$80
00003D30 0D00                     M 	dc.w	c
00003D32 =00000D80                M c	=	c+$80
00003D32 0D80                     M 	dc.w	c
00003D34 =00000E00                M c	=	c+$80
00003D34 0E00                     M 	dc.w	c
00003D36 =00000E80                M c	=	c+$80
00003D36 0E80                     M 	dc.w	c
00003D38 =00000F00                M c	=	c+$80
00003D38 0F00                     M 	dc.w	c
00003D3A =00000F80                M c	=	c+$80
00003D3A 0F80                     M 	dc.w	c
00003D3C =00001000                M c	=	c+$80
00003D3C 1000                     M 	dc.w	c
00003D3E =00001080                M c	=	c+$80
00003D3E 1080                     M 	dc.w	c
00003D40 =00001100                M c	=	c+$80
00003D40 1100                     M 	dc.w	c
00003D42 =00001180                M c	=	c+$80
00003D42 1180                     M 	dc.w	c
00003D44 =00001200                M c	=	c+$80
00003D44 1200                     M 	dc.w	c
00003D46 =00001280                M c	=	c+$80
00003D46 1280                     M 	dc.w	c
00003D48 =00001300                M c	=	c+$80
00003D48 1300                     M 	dc.w	c
00003D4A =00001380                M c	=	c+$80
00003D4A 1380                     M 	dc.w	c
00003D4C =00001400                M c	=	c+$80
00003D4C 1400                     M 	dc.w	c
00003D4E =00001480                M c	=	c+$80
00003D4E 1480                     M 	dc.w	c
00003D50 =00001500                M c	=	c+$80
00003D50 1500                     M 	dc.w	c
00003D52 =00001580                M c	=	c+$80
00003D52 1580                     M 	dc.w	c
00003D54 =00001600                M c	=	c+$80
00003D54 1600                     M 	dc.w	c
00003D56 =00001680                M c	=	c+$80
00003D56 1680                     M 	dc.w	c
00003D58 =00001700                M c	=	c+$80
00003D58 1700                     M 	dc.w	c
00003D5A =00001780                M c	=	c+$80
00003D5A 1780                     M 	dc.w	c
00003D5C =00001800                M c	=	c+$80
00003D5C 1800                     M 	dc.w	c
00003D5E =00001880                M c	=	c+$80
00003D5E 1880                     M 	dc.w	c
00003D60 =00001900                M c	=	c+$80
00003D60 1900                     M 	dc.w	c
00003D62 =00001980                M c	=	c+$80
00003D62 1980                     M 	dc.w	c
00003D64 =00001A00                M c	=	c+$80
00003D64 1A00                     M 	dc.w	c
00003D66 =00001A80                M c	=	c+$80
00003D66 1A80                     M 	dc.w	c
00003D68 =00001B00                M c	=	c+$80
00003D68 1B00                     M 	dc.w	c
00003D6A =00001B80                M c	=	c+$80
00003D6A 1B80                     M 	dc.w	c
00003D6C =00001C00                M c	=	c+$80
00003D6C 1C00                     M 	dc.w	c
00003D6E =00001C80                M c	=	c+$80
00003D6E 1C80                     M 	dc.w	c
00003D70 =00001D00                M c	=	c+$80
00003D70 1D00                     M 	dc.w	c
00003D72 =00001D80                M c	=	c+$80
00003D72 1D80                     M 	dc.w	c
00003D74 =00001E00                M c	=	c+$80
00003D74 1E00                     M 	dc.w	c
00003D76 =00001E80                M c	=	c+$80
00003D76 1E80                     M 	dc.w	c
00003D78 =00001F00                M c	=	c+$80
00003D78 1F00                     M 	dc.w	c
00003D7A =00001F80                M c	=	c+$80
00003D7A 1F80                     M 	dc.w	c
00003D7C =00002000                M c	=	c+$80
00003D7C 2000                     M 	dc.w	c
00003D7E =00002080                M c	=	c+$80
00003D7E 2080                     M 	dc.w	c
00003D80 =00002100                M c	=	c+$80
00003D80 2100                     M 	dc.w	c
00003D82 =00002180                M c	=	c+$80
00003D82 2180                     M 	dc.w	c
00003D84 =00002200                M c	=	c+$80
00003D84 2200                     M 	dc.w	c
00003D86 =00002280                M c	=	c+$80
00003D86 2280                     M 	dc.w	c
00003D88 =00002300                M c	=	c+$80
00003D88 2300                     M 	dc.w	c
00003D8A =00002380                M c	=	c+$80
00003D8A 2380                     M 	dc.w	c
00003D8C =00002400                M c	=	c+$80
00003D8C 2400                     M 	dc.w	c
00003D8E =00002480                M c	=	c+$80
00003D8E 2480                     M 	dc.w	c
00003D90 =00002500                M c	=	c+$80
00003D90 2500                     M 	dc.w	c
00003D92 =00002580                M c	=	c+$80
00003D92 2580                     M 	dc.w	c
00003D94 =00002600                M c	=	c+$80
00003D94 2600                     M 	dc.w	c
00003D96 =00002680                M c	=	c+$80
00003D96 2680                     M 	dc.w	c
00003D98 =00002700                M c	=	c+$80
00003D98 2700                     M 	dc.w	c
00003D9A =00002780                M c	=	c+$80
00003D9A 2780                     M 	dc.w	c
00003D9C =00002800                M c	=	c+$80
00003D9C 2800                     M 	dc.w	c
00003D9E =00002880                M c	=	c+$80
00003D9E 2880                     M 	dc.w	c
00003DA0 =00002900                M c	=	c+$80
00003DA0 2900                     M 	dc.w	c
00003DA2 =00002980                M c	=	c+$80
00003DA2 2980                     M 	dc.w	c
00003DA4 =00002A00                M c	=	c+$80
00003DA4 2A00                     M 	dc.w	c
00003DA6 =00002A80                M c	=	c+$80
00003DA6 2A80                     M 	dc.w	c
00003DA8 =00002B00                M c	=	c+$80
00003DA8 2B00                     M 	dc.w	c
00003DAA =00002B80                M c	=	c+$80
00003DAA 2B80                     M 	dc.w	c
00003DAC =00002C00                M c	=	c+$80
00003DAC 2C00                     M 	dc.w	c
00003DAE =00002C80                M c	=	c+$80
00003DAE 2C80                     M 	dc.w	c
00003DB0 =00002D00                M c	=	c+$80
00003DB0 2D00                     M 	dc.w	c
00003DB2 =00002D80                M c	=	c+$80
00003DB2 2D80                     M 	dc.w	c
00003DB4 =00002E00                M c	=	c+$80
00003DB4 2E00                     M 	dc.w	c
00003DB6 =00002E80                M c	=	c+$80
00003DB6 2E80                     M 	dc.w	c
00003DB8 =00002F00                M c	=	c+$80
00003DB8 2F00                     M 	dc.w	c
00003DBA =00002F80                M c	=	c+$80
00003DBA 2F80                     M 	dc.w	c
00003DBC =00003000                M c	=	c+$80
00003DBC 3000                     M 	dc.w	c
00003DBE =00003080                M c	=	c+$80
00003DBE 3080                     M 	dc.w	c
00003DC0 =00003100                M c	=	c+$80
00003DC0 3100                     M 	dc.w	c
00003DC2 =00003180                M c	=	c+$80
00003DC2 3180                     M 	dc.w	c
00003DC4 =00003200                M c	=	c+$80
00003DC4 3200                     M 	dc.w	c
00003DC6 =00003280                M c	=	c+$80
00003DC6 3280                     M 	dc.w	c
00003DC8 =00003300                M c	=	c+$80
00003DC8 3300                     M 	dc.w	c
00003DCA =00003380                M c	=	c+$80
00003DCA 3380                     M 	dc.w	c
00003DCC =00003400                M c	=	c+$80
00003DCC 3400                     M 	dc.w	c
00003DCE =00003480                M c	=	c+$80
00003DCE 3480                     M 	dc.w	c
00003DD0 =00003500                M c	=	c+$80
00003DD0 3500                     M 	dc.w	c
00003DD2 =00003580                M c	=	c+$80
00003DD2 3580                     M 	dc.w	c
00003DD4 =00003600                M c	=	c+$80
00003DD4 3600                     M 	dc.w	c
00003DD6 =00003680                M c	=	c+$80
00003DD6 3680                     M 	dc.w	c
00003DD8 =00003700                M c	=	c+$80
00003DD8 3700                     M 	dc.w	c
00003DDA =00003780                M c	=	c+$80
00003DDA 3780                     M 	dc.w	c
00003DDC =00003800                M c	=	c+$80
00003DDC 3800                     M 	dc.w	c
00003DDE =00003880                M c	=	c+$80
00003DDE 3880                     M 	dc.w	c
00003DE0 =00003900                M c	=	c+$80
00003DE0 3900                     M 	dc.w	c
00003DE2 =00003980                M c	=	c+$80
00003DE2 3980                     M 	dc.w	c
00003DE4 =00003A00                M c	=	c+$80
00003DE4 3A00                     M 	dc.w	c
00003DE6 =00003A80                M c	=	c+$80
00003DE6 3A80                     M 	dc.w	c
00003DE8 =00003B00                M c	=	c+$80
00003DE8 3B00                     M 	dc.w	c
00003DEA =00003B80                M c	=	c+$80
00003DEA 3B80                     M 	dc.w	c
00003DEC =00003C00                M c	=	c+$80
00003DEC 3C00                     M 	dc.w	c
00003DEE =00003C80                M c	=	c+$80
00003DEE 3C80                     M 	dc.w	c
00003DF0 =00003D00                M c	=	c+$80
00003DF0 3D00                     M 	dc.w	c
00003DF2 =00003D80                M c	=	c+$80
00003DF2 3D80                     M 	dc.w	c
00003DF4 =00003E00                M c	=	c+$80
00003DF4 3E00                     M 	dc.w	c
00003DF6 =00003E80                M c	=	c+$80
00003DF6 3E80                     M 	dc.w	c
00003DF8 =00003F00                M c	=	c+$80
00003DF8 3F00                     M 	dc.w	c
00003DFA =00003F80                M c	=	c+$80
00003DFA 3F80                     M 	dc.w	c
00003DFC =00004000                M c	=	c+$80
00003DFC 4000                     M 	dc.w	c
00003DFE =00004080                M c	=	c+$80
00003DFE 4080                     M 	dc.w	c
00003E00 =00004100                M c	=	c+$80
00003E00 4100                     M 	dc.w	c
00003E02 =00004180                M c	=	c+$80
00003E02 4180                     M 	dc.w	c
00003E04 =00004200                M c	=	c+$80
00003E04 4200                     M 	dc.w	c
00003E06 =00004280                M c	=	c+$80
00003E06 4280                     M 	dc.w	c
00003E08 =00004300                M c	=	c+$80
00003E08 4300                     M 	dc.w	c
00003E0A =00004380                M c	=	c+$80
00003E0A 4380                     M 	dc.w	c
00003E0C =00004400                M c	=	c+$80
00003E0C 4400                     M 	dc.w	c
00003E0E =00004480                M c	=	c+$80
00003E0E 4480                     M 	dc.w	c
00003E10 =00004500                M c	=	c+$80
00003E10 4500                     M 	dc.w	c
00003E12 =00004580                M c	=	c+$80
00003E12 4580                     M 	dc.w	c
00003E14 =00004600                M c	=	c+$80
00003E14 4600                     M 	dc.w	c
00003E16 =00004680                M c	=	c+$80
00003E16 4680                     M 	dc.w	c
00003E18 =00004700                M c	=	c+$80
00003E18 4700                     M 	dc.w	c
00003E1A =00004780                M c	=	c+$80
00003E1A 4780                     M 	dc.w	c
00003E1C =00004800                M c	=	c+$80
00003E1C 4800                     M 	dc.w	c
00003E1E =00004880                M c	=	c+$80
00003E1E 4880                     M 	dc.w	c
00003E20 =00004900                M c	=	c+$80
00003E20 4900                     M 	dc.w	c
00003E22 =00004980                M c	=	c+$80
00003E22 4980                     M 	dc.w	c
00003E24 =00004A00                M c	=	c+$80
00003E24 4A00                     M 	dc.w	c
00003E26 =00004A80                M c	=	c+$80
00003E26 4A80                     M 	dc.w	c
00003E28 =00004B00                M c	=	c+$80
00003E28 4B00                     M 	dc.w	c
00003E2A =00004B80                M c	=	c+$80
00003E2A 4B80                     M 	dc.w	c
00003E2C =00004C00                M c	=	c+$80
00003E2C 4C00                     M 	dc.w	c
00003E2E =00004C80                M c	=	c+$80
00003E2E 4C80                     M 	dc.w	c
00003E30 =00004D00                M c	=	c+$80
00003E30 4D00                     M 	dc.w	c
00003E32 =00004D80                M c	=	c+$80
00003E32 4D80                     M 	dc.w	c
00003E34 =00004E00                M c	=	c+$80
00003E34 4E00                     M 	dc.w	c
00003E36 =00004E80                M c	=	c+$80
00003E36 4E80                     M 	dc.w	c
00003E38 =00004F00                M c	=	c+$80
00003E38 4F00                     M 	dc.w	c
00003E3A =00004F80                M c	=	c+$80
00003E3A 4F80                     M 	dc.w	c
00003E3C =00005000                M c	=	c+$80
00003E3C 5000                     M 	dc.w	c
00003E3E =00005080                M c	=	c+$80
00003E3E 5080                     M 	dc.w	c
00003E40 =00005100                M c	=	c+$80
00003E40 5100                     M 	dc.w	c
00003E42 =00005180                M c	=	c+$80
00003E42 5180                     M 	dc.w	c
00003E44 =00005200                M c	=	c+$80
00003E44 5200                     M 	dc.w	c
00003E46 =00005280                M c	=	c+$80
00003E46 5280                     M 	dc.w	c
00003E48 =00005300                M c	=	c+$80
00003E48 5300                     M 	dc.w	c
00003E4A =00005380                M c	=	c+$80
00003E4A 5380                     M 	dc.w	c
00003E4C =00005400                M c	=	c+$80
00003E4C 5400                     M 	dc.w	c
00003E4E =00005480                M c	=	c+$80
00003E4E 5480                     M 	dc.w	c
00003E50 =00005500                M c	=	c+$80
00003E50 5500                     M 	dc.w	c
00003E52 =00005580                M c	=	c+$80
00003E52 5580                     M 	dc.w	c
00003E54 =00005600                M c	=	c+$80
00003E54 5600                     M 	dc.w	c
00003E56 =00005680                M c	=	c+$80
00003E56 5680                     M 	dc.w	c
00003E58 =00005700                M c	=	c+$80
00003E58 5700                     M 	dc.w	c
00003E5A =00005780                M c	=	c+$80
00003E5A 5780                     M 	dc.w	c
00003E5C =00005800                M c	=	c+$80
00003E5C 5800                     M 	dc.w	c
00003E5E =00005880                M c	=	c+$80
00003E5E 5880                     M 	dc.w	c
00003E60 =00005900                M c	=	c+$80
00003E60 5900                     M 	dc.w	c
00003E62 =00005980                M c	=	c+$80
00003E62 5980                     M 	dc.w	c
00003E64 =00005A00                M c	=	c+$80
00003E64 5A00                     M 	dc.w	c
00003E66 =00005A80                M c	=	c+$80
00003E66 5A80                     M 	dc.w	c
00003E68 =00005B00                M c	=	c+$80
00003E68 5B00                     M 	dc.w	c
00003E6A =00005B80                M c	=	c+$80
00003E6A 5B80                     M 	dc.w	c
00003E6C =00005C00                M c	=	c+$80
00003E6C 5C00                     M 	dc.w	c
00003E6E =00005C80                M c	=	c+$80
00003E6E 5C80                     M 	dc.w	c
00003E70 =00005D00                M c	=	c+$80
00003E70 5D00                     M 	dc.w	c
00003E72 =00005D80                M c	=	c+$80
00003E72 5D80                     M 	dc.w	c
00003E74 =00005E00                M c	=	c+$80
00003E74 5E00                     M 	dc.w	c
00003E76 =00005E80                M c	=	c+$80
00003E76 5E80                     M 	dc.w	c
00003E78 =00005F00                M c	=	c+$80
00003E78 5F00                     M 	dc.w	c
00003E7A =00005F80                M c	=	c+$80
00003E7A 5F80                     M 	dc.w	c
00003E7C =00006000                M c	=	c+$80
00003E7C 6000                     M 	dc.w	c
00003E7E =00006080                M c	=	c+$80
00003E7E 6080                     M 	dc.w	c
00003E80 =00006100                M c	=	c+$80
00003E80 6100                     M 	dc.w	c
00003E82 =00006180                M c	=	c+$80
00003E82 6180                     M 	dc.w	c
00003E84 =00006200                M c	=	c+$80
00003E84 6200                     M 	dc.w	c
00003E86 =00006280                M c	=	c+$80
00003E86 6280                     M 	dc.w	c
00003E88 =00006300                M c	=	c+$80
00003E88 6300                     M 	dc.w	c
00003E8A =00006380                M c	=	c+$80
00003E8A 6380                     M 	dc.w	c
00003E8C =00006400                M c	=	c+$80
00003E8C 6400                     M 	dc.w	c
00003E8E =00006480                M c	=	c+$80
00003E8E 6480                     M 	dc.w	c
00003E90 =00006500                M c	=	c+$80
00003E90 6500                     M 	dc.w	c
00003E92 =00006580                M c	=	c+$80
00003E92 6580                     M 	dc.w	c
00003E94 =00006600                M c	=	c+$80
00003E94 6600                     M 	dc.w	c
00003E96 =00006680                M c	=	c+$80
00003E96 6680                     M 	dc.w	c
00003E98 =00006700                M c	=	c+$80
00003E98 6700                     M 	dc.w	c
00003E9A =00006780                M c	=	c+$80
00003E9A 6780                     M 	dc.w	c
00003E9C =00006800                M c	=	c+$80
00003E9C 6800                     M 	dc.w	c
00003E9E =00006880                M c	=	c+$80
00003E9E 6880                     M 	dc.w	c
00003EA0 =00006900                M c	=	c+$80
00003EA0 6900                     M 	dc.w	c
00003EA2 =00006980                M c	=	c+$80
00003EA2 6980                     M 	dc.w	c
00003EA4 =00006A00                M c	=	c+$80
00003EA4 6A00                     M 	dc.w	c
00003EA6 =00006A80                M c	=	c+$80
00003EA6 6A80                     M 	dc.w	c
00003EA8 =00006B00                M c	=	c+$80
00003EA8 6B00                     M 	dc.w	c
00003EAA =00006B80                M c	=	c+$80
00003EAA 6B80                     M 	dc.w	c
00003EAC =00006C00                M c	=	c+$80
00003EAC 6C00                     M 	dc.w	c
00003EAE =00006C80                M c	=	c+$80
00003EAE 6C80                     M 	dc.w	c
00003EB0 =00006D00                M c	=	c+$80
00003EB0 6D00                     M 	dc.w	c
00003EB2 =00006D80                M c	=	c+$80
00003EB2 6D80                     M 	dc.w	c
00003EB4 =00006E00                M c	=	c+$80
00003EB4 6E00                     M 	dc.w	c
00003EB6 =00006E80                M c	=	c+$80
00003EB6 6E80                     M 	dc.w	c
00003EB8 =00006F00                M c	=	c+$80
00003EB8 6F00                     M 	dc.w	c
00003EBA =00006F80                M c	=	c+$80
00003EBA 6F80                     M 	dc.w	c
00003EBC =00007000                M c	=	c+$80
00003EBC 7000                     M 	dc.w	c
00003EBE =00007080                M c	=	c+$80
00003EBE 7080                     M 	dc.w	c
00003EC0 =00007100                M c	=	c+$80
00003EC0 7100                     M 	dc.w	c
00003EC2 =00007180                M c	=	c+$80
00003EC2 7180                     M 	dc.w	c
00003EC4 =00007200                M c	=	c+$80
00003EC4 7200                     M 	dc.w	c
00003EC6 =00007280                M c	=	c+$80
00003EC6 7280                     M 	dc.w	c
00003EC8 =00007300                M c	=	c+$80
00003EC8 7300                     M 	dc.w	c
00003ECA =00007380                M c	=	c+$80
00003ECA 7380                     M 	dc.w	c
00003ECC =00007400                M c	=	c+$80
00003ECC 7400                     M 	dc.w	c
00003ECE =00007480                M c	=	c+$80
00003ECE 7480                     M 	dc.w	c
00003ED0 =00007500                M c	=	c+$80
00003ED0 7500                     M 	dc.w	c
00003ED2 =00007580                M c	=	c+$80
00003ED2 7580                     M 	dc.w	c
00003ED4 =00007600                M c	=	c+$80
00003ED4 7600                     M 	dc.w	c
00003ED6 =00007680                M c	=	c+$80
00003ED6 7680                     M 	dc.w	c
00003ED8 =00007700                M c	=	c+$80
00003ED8 7700                     M 	dc.w	c
00003EDA =00007780                M c	=	c+$80
00003EDA 7780                     M 	dc.w	c
00003EDC =00007800                M c	=	c+$80
00003EDC 7800                     M 	dc.w	c
00003EDE =00007880                M c	=	c+$80
00003EDE 7880                     M 	dc.w	c
00003EE0 =00007900                M c	=	c+$80
00003EE0 7900                     M 	dc.w	c
00003EE2 =00007980                M c	=	c+$80
00003EE2 7980                     M 	dc.w	c
00003EE4 =00007A00                M c	=	c+$80
00003EE4 7A00                     M 	dc.w	c
00003EE6 =00007A80                M c	=	c+$80
00003EE6 7A80                     M 	dc.w	c
00003EE8 =00007B00                M c	=	c+$80
00003EE8 7B00                     M 	dc.w	c
00003EEA =00007B80                M c	=	c+$80
00003EEA 7B80                     M 	dc.w	c
00003EEC =00007C00                M c	=	c+$80
00003EEC 7C00                     M 	dc.w	c
00003EEE =00007C80                M c	=	c+$80
00003EEE 7C80                     M 	dc.w	c
00003EF0 =00007D00                M c	=	c+$80
00003EF0 7D00                     M 	dc.w	c
00003EF2 =00007D80                M c	=	c+$80
00003EF2 7D80                     M 	dc.w	c
00003EF4 =00007E00                M c	=	c+$80
00003EF4 7E00                     M 	dc.w	c
00003EF6 =00007E80                M c	=	c+$80
00003EF6 7E80                     M 	dc.w	c
00003EF8 =00007F00                M c	=	c+$80
00003EF8 7F00                     M 	dc.w	c
00003EFA =00007F80                M c	=	c+$80
00003EFA 7F80                     M 	dc.w	c
00003EFC =00008000                M c	=	c+$80
00003EFC                            ; =========================================================================================================================================================
00003EFC                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003EFC                            ; =========================================================================================================================================================
00003EFC                            ; General level functions
00003EFC                            ; =========================================================================================================================================================
00003EFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EFC                            ; Load level data
00003EFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EFC                            Level_LoadData:
00003EFC                            		; --- Initialize the start position and camera ---
00003EFC                            
00003EFC 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003F02 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003F06 E218                       		ror.b	#1,d0				; Turn into offset
00003F08 E848                       		lsr.w	#4,d0				; ''
00003F0A 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003F0E                            
00003F0E 42B8 E8CE                  		clr.l	targetMinCamPos.w		; Set target minimum camera values
00003F12 42B8 E8D2                  		clr.l	minCamPos.w			; Set minimum camera values
00003F16 21D3 E8C6                  		move.l	(a3),targetMaxCamPos.w		; Set target maximum camera values
00003F1A 21DB E8CA                  		move.l	(a3)+,maxCamPos.w		; Set maximum camera values
00003F1E                            
00003F1E 31FC 0060 E8D8             		move.w	#(224/2)-16,panCamYPos.w	; Set camera Y distance
00003F24                            
00003F24 3078 E876                  		movea.w	playerPtrP1.w,a0		; Player object
00003F28 321B                       		move.w	(a3)+,d1			; Get starting X position
00003F2A 3141 0014                  		move.w	d1,_objXPos(a0)			; Set the player's X position
00003F2E 3013                       		move.w	(a3),d0				; Get starting Y position
00003F30 3140 0018                  		move.w	d0,_objYPos(a0)			; Set the player's Y position
00003F34                            
00003F34 4A38 C7B7                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003F38 6700                       		beq.s	.InitCam			; If not, branch
00003F3A 08E8 0002 000C             		bset	#2,_objFlags(a0)
00003F40 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003F42 3141 0014                  		move.w	d1,_objXPos(a0)			; ''
00003F46 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003F48 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00003F4C                            
00003F4C                            .InitCam:
00003F4C 4A38 C7B0                  		tst.b	chkIDLast.w		; Has a checkpoint been hit?
00003F50 6700                       		beq.s	.SetCam				; If not, branch
00003F52 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003F56 3228 0014                  		move.w	_objXPos(a0),d1			; Get X position
00003F5A 3028 0018                  		move.w	_objYPos(a0),d0			; Get Y position
00003F5E                            
00003F5E                            .SetCam:
00003F5E 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003F62 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003F64 7200                       		moveq	#0,d1				; Cap it
00003F66                            
00003F66                            .ChkMaxX:
00003F66 3438 E8CA                  		move.w	maxCamXPos.w,d2		; Get max camera X position
00003F6A B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003F6C 6500                       		bcs.s	.SetCamX			; If not, branch
00003F6E 3202                       		move.w	d2,d1				; Cap it
00003F70                            
00003F70                            .SetCamX:	
00003F70 31C1 E88A                  		move.w	d1,fgCamXPos.w			; Set the camera's X position
00003F74                            
00003F74 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003F78 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003F7A 7000                       		moveq	#0,d0				; Cap it
00003F7C                            
00003F7C                            .ChkMaxY:
00003F7C 3438 E8CC                  		move.w	maxCamYPos.w,d2		; Get max camera Y position
00003F80 B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003F82 6D00                       		blt.s	.SetCamY			; If not, branch
00003F84 3002                       		move.w	d2,d0				; Cap it
00003F86                            
00003F86                            .SetCamY:	
00003F86 31C0 E892                  		move.w	d0,fgCamYPos.w			; Set the camera's Y position
00003F8A                            
00003F8A                            		; --- Load level data ---
00003F8A                            
00003F8A 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003F90 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003F94 E218                       		ror.b	#1,d0				; Turn into offset
00003F96 E448                       		lsr.w	#2,d0				; ''
00003F98 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003F9C                            
00003F9C 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003F9E 43F9 00FF 0000             		lea	chunkData,a1			; Decompress into chunk table
00003FA4 4EB8 0B06                  		jsr	KosDec.w			; ''
00003FA8                            
00003FA8 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003FAA 43F8 C7D2                  		lea	blockData.w,a1			; Decompress into block table
00003FAE 4EB8 0B06                  		jsr	KosDec.w			; ''
00003FB2                            
00003FB2 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003FB4 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003FB6 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003FBA                            
00003FBA 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003FBC 3018                       		move.w	(a0)+,d0			; Size of palette data
00003FBE 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003FC2                            
00003FC2 21DB E856                  		move.l	(a3)+,lvlLayoutFG.w		; Move layout addresses to variables
00003FC6 21DB E85A                  		move.l	(a3)+,lvlLayoutBG.w
00003FCA                            
00003FCA 21DB C7B8                  		move.l	(a3)+,objMgrLayout.w		; Set object position data pointer
00003FCE 21DB E868                  		move.l	(a3)+,ringMgrLayout.w		; Set ring position data pointer
00003FD2 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003FD4 201B                       		move.l	(a3)+,d0			; Get collision data address
00003FD6 21C0 E8EA                  		move.l	d0,currentColAddr.w			; Set collision address to primary
00003FDA 21C0 E8E2                  		move.l	d0,primaryColPtr.w			; Set primary collision data pointer
00003FDE 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003FE0 21C0 E8E6                  		move.l	d0,secondaryColPtr.w			; Set secondary collision data pointer
00003FE4 43F8 E8F0                  		lea	angleValPtr.w,a1		; Collision pointers
00003FE8 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003FEA 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003FEC 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003FEE                            
00003FEE 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003FF4 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003FF8 E218                       		ror.b	#1,d0				; Turn into offset
00003FFA EA48                       		lsr.w	#5,d0				; ''
00003FFC 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00004000 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00004004                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004004                            ; Update the water surface
00004004                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004004                            Level_UpdateWaterSurface:
00004004 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00004008 6700                       		beq.s	.End				; If not, branch
0000400A 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera X position
0000400E 0838 0000 E905             		btst	#0,(lvlFrameCnt+1).w		; Are we on an odd frame?
00004014 6700                       		beq.s	.SetXPos			; If not, branch
00004016 0641 0020                  		addi.w	#$20,d1				; Shift X position
0000401A                            
0000401A                            .SetXPos:
0000401A 3001                       		move.w	d1,d0				; Copy X postion
0000401C 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00004020 3078 E886                  		movea.w	waterObjPtr1.w,a0
00004024 3140 0014                  		move.w	d0,_objXPos(a0)			; Set it
00004028 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
0000402C 3078 E888                  		movea.w	waterObjPtr2.w,a0
00004030 3141 0014                  		move.w	d1,_objXPos(a0)			; Set it
00004034                            
00004034                            .End:
00004034 4E75                       		rts
00004036                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004036                            ; Handle water height
00004036                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004036                            Level_WaterHeight:
00004036 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
0000403A 6700                       		beq.s	.End				; If not, branch
0000403C 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00004040 4238 E8FF                  		clr.b	waterFullscr.w		; Clear water fullscreen flag
00004044                            
00004044 7201                       		moveq	#1,d1				; Water movement speed
00004046 3038 E902                  		move.w	destWaterYPos.w,d0		; Get destination water level
0000404A 9078 E900                  		sub.w	waterYPos.w,d0		; Is the current water level at that destination?
0000404E 6700                       		beq.s	.ChkOnScr			; If so, branch
00004050 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00004052 4441                       		neg.w	d1				; Go up
00004054                            
00004054                            .MoveDown:
00004054 D378 E900                  		add.w	d1,waterYPos.w		; Move water
00004058                            
00004058                            .ChkOnScr:
00004058 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
0000405C 9078 E892                  		sub.w	fgCamYPos.w,d0			; Get camera's Y position
00004060 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00004062 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00004064                            		
00004064                            .Fullscreen:
00004064 50F8 E8FF                  		st	waterFullscr.w		; Set water fullscreen flag
00004068 50F8 C761                  		st	hIntCntValue.w			; Set H-INT counter to be offscreen
0000406C 4E75                       		rts
0000406E                            
0000406E                            .ChkBottom:
0000406E 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00004072 6500                       		blo.s	.SetCounter			; If not, branch
00004074 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00004076                            
00004076                            .SetCounter:
00004076 11C0 C761                  		move.b	d0,hIntCntValue.w			; Set H-INT counter
0000407A                            
0000407A                            .End:
0000407A 4E75                       		rts
0000407C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407C                            Level_MoveWater:
0000407C 4E75                       		rts
0000407E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407E                            ; Do level palette cycling
0000407E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407E                            Level_PalCycle:
0000407E 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00004084 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00004088 E218                       		ror.b	#1,d0				; Turn into offset
0000408A EA48                       		lsr.w	#5,d0				; ''
0000408C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00004090 4ED0                       		jmp	(a0)				; Jump to it
00004092                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004092                            ; Do level art animation
00004092                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004092                            Level_AnimateArt:
00004092 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00004098 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
0000409C E218                       		ror.b	#1,d0				; Turn into offset
0000409E EA48                       		lsr.w	#5,d0				; ''
000040A0 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
000040A4 4ED0                       		jmp	(a0)				; Jump to it
000040A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040A6                            ; Do dynamic events
000040A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040A6                            Level_DynEvents:
000040A6 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
000040AC 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
000040B0 E218                       		ror.b	#1,d0				; Turn into offset
000040B2 EA48                       		lsr.w	#5,d0				; ''
000040B4 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
000040B8 4ED0                       		jmp	(a0)				; Jump to it
000040BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040BA                            ; Handle the camera
000040BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040BA                            Level_HandleCamera:
000040BA 3078 E876                  		movea.w	playerPtrP1.w,a0		; Get player object
000040BE                            		
000040BE 4A38 E8DA                  		tst.b	camLockX.w			; Is the camera locked horizontally?
000040C2 6600                       		bne.s	.ChkY				; If so, branch
000040C4 43F8 E88A                  		lea	fgCamXPos.w,a1			; Get foreground level variables
000040C8 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
000040CA                            		
000040CA                            .ChkY:
000040CA 4A38 E8DB                  		tst.b	camLockY.w			; Is the camera locked vertically?
000040CE 6600                       		bne.s	.ChkMaxY			; If not, branch
000040D0 43F8 E892                  		lea	fgCamYPos.w,a1			; Get foreground level variables
000040D4 3638 E8D8                  		move.w	panCamYPos.w,d3		; Get camera Y distance
000040D8 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
000040DC                            
000040DC                            .ChkMaxY:
000040DC 7202                       		moveq	#2,d1				; Target camera scroll speed
000040DE 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get distance between target and actual target max camera Y position
000040E2 9078 E8CC                  		sub.w	maxCamYPos.w,d0		; ''
000040E6 6700                       		beq.s	.End				; If it's 0, branch
000040E8 6400                       		bcc.s	.MoveDown			; If it's positive, branch
000040EA 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
000040EE B078 E8C8                  		cmp.w	targetMaxCamY.w,d0		; Is it past the boundary?
000040F2 6300                       		bls.s	.ScrollUp			; If not, branch
000040F4 31C0 E8CC                  		move.w	d0,maxCamYPos.w		; Set max camera Y position
000040F8 0278 FFFE E8CC             		andi.w	#$FFFE,maxCamYPos.w		; Keep it a multiple of 2
000040FE                            
000040FE                            .ScrollUp:
000040FE 9378 E8CC                  		sub.w	d1,maxCamYPos.w		; Scroll up
00004102 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004106                            
00004106                            
00004106                            .End:
00004106 4E75                       		rts
00004108                            
00004108                            .MoveDown:
00004108 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
0000410C 5040                       		addq.w	#8,d0				; ''
0000410E B078 E8CC                  		cmp.w	maxCamYPos.w,d0		; Is it past the boundary?
00004112 6500                       		bcs.s	.ScrollDown			; If not, branch
00004114 0828 0001 0028             		btst	#1,_objStatus(a0)		; Is the player in the air?
0000411A 6700                       		beq.s	.ScrollDown			; If not, branch
0000411C D241                       		add.w	d1,d1				; Scroll down faster
0000411E D241                       		add.w	d1,d1				; ''
00004120                            
00004120                            .ScrollDown:
00004120 D378 E8CC                  		add.w	d1,maxCamYPos.w		; Scroll down
00004124 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004128 4E75                       		rts
0000412A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000412A                            Level_MoveCameraX:
0000412A 3028 0014                  		move.w	_objXPos(a0),d0			; Get the player's X position
0000412E 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00004130 9078 E8D6                  		sub.w	panCamXPos.w,d0		; Subtract center
00004134 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00004136 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00004138 4E75                       		rts
0000413A                            
0000413A                            .MoveLeft:
0000413A 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
0000413E 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00004140 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00004144                            
00004144                            .ChkLeftBound:
00004144 D051                       		add.w	(a1),d0				; Add back the camera's X position
00004146 B078 E8D2                  		cmp.w	minCamXPos.w,d0		; Have we gone past the left boundary?
0000414A 6E00                       		bgt.s	.SetCamX			; If not, branch
0000414C 3038 E8D2                  		move.w	minCamXPos.w,d0		; Cap at the left boundary
00004150 6000                       		bra.s	.SetCamX			; Continue
00004152                            
00004152                            .MoveRight:
00004152 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00004156 6500                       		blo.s	.ChkRightBound			; If not, branch
00004158 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
0000415C                            
0000415C                            .ChkRightBound:
0000415C D051                       		add.w	(a1),d0				; Add back the camera's X position
0000415E B078 E8CA                  		cmp.w	maxCamXPos.w,d0		; Has the camera gone beyond the right boundary?
00004162 6D00                       		blt.s	.SetCamX			; If not, branch
00004164 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Cap at the right boundary
00004168                            
00004168                            .SetCamX:
00004168 3280                       		move.w	d0,(a1)				; Set the new camera X position
0000416A 4E75                       		rts
0000416C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000416C                            Level_MoveCameraY:
0000416C 7200                       		moveq	#0,d1
0000416E 3028 0018                  		move.w	_objYPos(a0),d0			; Get the player's Y position
00004172 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00004174                            
00004174 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is the player rolling?
0000417A 6700                       		beq.s	.NoRoll				; If not, branch
0000417C 5B40                       		subq.w	#5,d0				; Move up some
0000417E                            
0000417E                            .NoRoll:
0000417E 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is the player in the air?
00004184 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00004186                            
00004186                            .ChkBoundCross_Air:
00004186 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
0000418A 9043                       		sub.w	d3,d0				; Subtract camera Y distance
0000418C 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
0000418E 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00004192 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00004194                            
00004194 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
00004198 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
0000419A 6000                       		bra.s	.NoScroll			; Continue
0000419C                            
0000419C                            .ChkBoundCross_Ground:
0000419C 9043                       		sub.w	d3,d0				; Subtract camera Y distance
0000419E 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
000041A0 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
000041A4 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
000041A6                            
000041A6                            .NoScroll:
000041A6 4E75                       		rts		
000041A8                            
000041A8                            .DecideScrollType:
000041A8 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
000041AC 6600                       		bne.s	.ScrollSlow			; If not, branch
000041AE                            
000041AE 3228 0000                  		move.w	_objGVel(a0),d1			; Get the players' ground velocity
000041B2 6A00                       		bpl.s	.Positive			; If it's positive, branch
000041B4 4441                       		neg.w	d1				; Force it to be positive
000041B6                            
000041B6                            .Positive:
000041B6 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
000041BA 6400                       		bhs.s	.ScrollFast			; If so, branch
000041BC                            
000041BC                            .ScrollMedium:
000041BC 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
000041C0 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
000041C4 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
000041C6 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
000041CA 6D00                       		blt.s	.ScrollUpMax			; If so, branch
000041CC 6000                       		bra.s	.ScrollUpOrDown			; Continue
000041CE                            
000041CE                            .ScrollSlow:
000041CE 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
000041D2 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
000041D6 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
000041D8 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
000041DC 6D00                       		blt.s	.ScrollUpMax			; If so, branch
000041DE 6000                       		bra.s	.ScrollUpOrDown			; Continue
000041E0                            
000041E0                            .ScrollFast:
000041E0 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
000041E4 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
000041E8 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
000041EA 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
000041EE 6D00                       		blt.s	.ScrollUpMax			; If so, branch
000041F0 6000                       		bra.s	.ScrollUpOrDown			; Continue
000041F2                            
000041F2                            .ScrollMaxYChange:
000041F2 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
000041F4 11C0 E8DC                  		move.b	d0,chgCamMaxY.w		; Clear the max Y boundary changing flag
000041F8                            		
000041F8                            .ScrollUpOrDown:
000041F8 7200                       		moveq	#0,d1
000041FA 3200                       		move.w	d0,d1				; Get position difference
000041FC D251                       		add.w	(a1),d1				; Add old camera Y position
000041FE 4A40                       		tst.w	d0				; Is the camera to scroll down?
00004200 6A00                       		bpl.s	.ScrollDown			; If so, branch
00004202 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00004206                            
00004206                            .ScrollUpMax:
00004206 4441                       		neg.w	d1				; Make the value negative, since we are going up
00004208 48C1                       		ext.l	d1
0000420A E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
0000420C D291                       		add.l	(a1),d1				; Add the camera's Y position
0000420E 4841                       		swap	d1				; Get the actual Y position
00004210                            
00004210                            .ScrollUp:
00004210 B278 E8D4                  		cmp.w	minCamYPos.w,d1		; Has the camera gone beyond the upper boundary?
00004214 6E00                       		bgt.s	.DoScroll			; If not, branch
00004216 3238 E8D4                  		move.w	minCamYPos.w,d1		; Cap at upper boundary
0000421A 6000                       		bra.s	.DoScroll			; Continue
0000421C                            
0000421C                            .ScrollDownMax:
0000421C 48C1                       		ext.l	d1
0000421E E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00004220 D291                       		add.l	(a1),d1				; Add the camera's Y position
00004222 4841                       		swap	d1				; Get the actual Y position
00004224                            
00004224                            .ScrollDown:
00004224 B278 E8CC                  		cmp.w	maxCamYPos.w,d1		; Has the camera gone beyond the lower boundary?
00004228 6D00                       		blt.s	.DoScroll			; If not, branch
0000422A 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Cap at lower boundary
0000422E                            
0000422E                            .DoScroll:
0000422E 4841                       		swap	d1				; Put Y coordinate in the higher word
00004230 2281                       		move.l	d1,(a1)				; Set Y position
00004232 4E75                       		rts
00004234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004234                            ; Level ring manager
00004234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004234                            Level_RingsManager:
00004234 7000                       		moveq	#0,d0
00004236 1038 E866                  		move.b	ringMgrRoutine.w,d0		; Get routine
0000423A 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
0000423E 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00004242                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004242                            .Routines:
00004242 0000                       		dc.w	Level_RingsManagerInit-.Routines
00004244 0000                       		dc.w	Level_RingsManagerMain-.Routines
00004246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004246                            ; Ring manager initialization
00004246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004246                            Level_RingsManagerInit:
00004246 5438 E866                  		addq.b	#2,ringMgrRoutine.w		; The next time the manager is run, only go to the main routine
0000424A                            		
0000424A 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
0000424E                            
0000424E                            		; Set up the addresses to use in the current location of the level
0000424E                            
0000424E                            		; Start at the left side of the screen
0000424E                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
0000424E                            
0000424E 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get current ring data address for the left side of the screen
00004252 45F8 DFD2                  		lea	ringStatus.w,a2		; Ring status table
00004256 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
0000425A 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
0000425C 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
0000425E 7801                       		moveq	#1,d4				; Cap left side to 1
00004260 6000                       		bra.s	.CheckLeftSide			; Start checking
00004262                            
00004262                            .NextLeftRing:
00004262 5849                       		addq.w	#4,a1				; Next ring in ring data
00004264 544A                       		addq.w	#2,a2				; Next ring in status table
00004266                            
00004266                            .CheckLeftSide:
00004266 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00004268 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
0000426A 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
0000426E 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
00004272                            
00004272                            		; Now the right side of the screen
00004272                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00004272                            
00004272 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00004276 6000                       		bra.s	.CheckRightSide			; Start checking
00004278                            
00004278                            .NextRightRing:
00004278 5849                       		addq.w	#4,a1				; Next ring in ring data
0000427A                            
0000427A                            .CheckRightSide:
0000427A B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
0000427C 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
0000427E 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
00004282 4E75                       		rts
00004284                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004284                            ; Ring manager main routine
00004284                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004284                            Level_RingsManagerMain:
00004284 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00004288                            
00004288 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get the current starting address for the ring data
0000428C 3478 E874                  		movea.w	ringMgrStatPtr.w,a2		; Get the current starting address for the status table
00004290                            		
00004290                            		; Get the new starting addresses for ring data
00004290                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00004290                            		; and then going back to get the very first ring that's on screen
00004290                            
00004290 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
00004294 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00004296 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00004298 7801                       		moveq	#1,d4				; Cap left side to 1
0000429A 6000                       		bra.s	.CheckNewLeftSide		; Start checking
0000429C                            
0000429C                            .NextNewLeftRing:
0000429C 5849                       		addq.w	#4,a1				; Next ring in ring data
0000429E 544A                       		addq.w	#2,a2				; Next ring in status table
000042A0                            
000042A0                            .CheckNewLeftSide:
000042A0 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
000042A2 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
000042A4 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
000042A6                            
000042A6                            .NextNewLeftRing2:
000042A6 5949                       		subq.w	#4,a1				; Previous ring in ring data
000042A8 554A                       		subq.w	#2,a2				; Previous ring in status table
000042AA                            
000042AA                            .CheckNewLeftSide2:
000042AA B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
000042AE 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
000042B0 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
000042B4 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
000042B8                            
000042B8                            		; Now get the new ending addresses for ring data
000042B8                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
000042B8                            		; and then going back to get the very first ring that's on screen on the left side
000042B8                            
000042B8 2278 E870                  		movea.l	ringMgrLoadR.w,a1		; Get the current ending address for the ring data
000042BC                            
000042BC 0644 0150                  		addi.w	#320+16,d4			; Right boundary
000042C0 6000                       		bra.s	.CheckNewRightSide		; Start checking
000042C2                            
000042C2                            .NextNewRightRing:
000042C2 5849                       		addq.w	#4,a1				; Next ring in ring data
000042C4                            
000042C4                            .CheckNewRightSide:
000042C4 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
000042C6 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
000042C8 6000                       		bra.s	.CheckNewRightSide2		; Start checking
000042CA                            
000042CA                            .NextNewRightRing2:
000042CA 5949                       		subq.w	#4,a1				; Previous ring in ring data
000042CC                            
000042CC                            .CheckNewRightSide2:
000042CC B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
000042D0 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
000042D2 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
000042D6 4E75                       		rts
000042D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042D8                            ; Handle ring collection
000042D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042D8                            Level_RingsManagerDoCollect:
000042D8 45F8 E3D2                  		lea	ringCollect.w,a2			; Ring collection table
000042DC 321A                       		move.w	(a2)+,d1			; Get consumed ring count
000042DE 5341                       		subq.w	#1,d1				; SutbactID 1
000042E0 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
000042E2                            
000042E2                            .Loop:
000042E2 301A                       		move.w	(a2)+,d0			; Get ring status address
000042E4 67FC                       		beq.s	.Loop				; If 0, get the next ring
000042E6 3240                       		movea.w	d0,a1				; Save in a1
000042E8 5311                       		subq.b	#1,(a1)				; Decrement timer
000042EA 6600                       		bne.s	.Next				; If nonzero, branch
000042EC 12BC 0006                  		move.b	#6,(a1)				; Reset timer
000042F0 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
000042F4                            							; Is it the last frame?
000042F4 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
000042FA 6600                       		bne.s	.Next				; If not, branch
000042FC 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00004300 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00004304 5378 E3D2                  		subq.w	#1,ringColCount.w		; Decrement collection table count
00004308                            
00004308                            .Next:
00004308 51C9 FFD8                  		dbf	d1,.Loop			; Loop
0000430C                            
0000430C                            .End:
0000430C 4E75                       		rts
0000430E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000430E                            ; Set up the tables and load ring data
0000430E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000430E                            Level_RingsManagerSetup:
0000430E                            		; Clear tables
0000430E                            		clrRAM	ringStatus
0000430E                          M 	local	endaddr
0000430E                          M endaddr	equs	"ringstatus_End"
0000430E 7000                     M 	moveq	#0,d0
00004310 43F8 DFD2                M 	lea	(ringstatus).w,a1
00004314 323C 00FF                M 	move.w	#(((ringstatus_end)-(ringstatus))-((ringstatus)&1))>>2-1,d1
00004318 22C0                     M .clear_187:	move.l	d0,(a1)+
0000431A 51C9 FFFC                M 	dbf	d1,.clear_187
0000431E                            		clrRAM	ringCollect
0000431E                          M 	local	endaddr
0000431E                          M endaddr	equs	"ringcollect_End"
0000431E 7000                     M 	moveq	#0,d0
00004320 43F8 E3D2                M 	lea	(ringcollect).w,a1
00004324 323C 001F                M 	move.w	#(((ringcollect_end)-(ringcollect))-((ringcollect)&1))>>2-1,d1
00004328 22C0                     M .clear_188:	move.l	d0,(a1)+
0000432A 51C9 FFFC                M 	dbf	d1,.clear_188
0000432E                            
0000432E 2278 E868                  		movea.l	ringMgrLayout.w,a1		; Get ring data pointer
00004332 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store address
00004336 5849                       		addq.w	#4,a1				; Increment address by 4
00004338 7A00                       		moveq	#0,d5				; Initialize the ring counter
0000433A 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
0000433E                            
0000433E                            .GetRingCount:
0000433E 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00004340 6B00                       		bmi.s	.Exit				; If so, branch
00004342 5245                       		addq.w	#1,d5				; Increment ring counter
00004344 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00004348                            
00004348                            .Exit:
00004348 4E75                       		rts
0000434A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000434A                            ; Do ring collision for the player
0000434A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000434A                            PlayeringCollectlision:
0000434A 0C28 0069 0000             		cmpi.b	#105,_objInvulTime(a0)		; Is the player able to collect rings while hurt?
00004350 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00004354 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get starting address of ring data
00004358 2478 E870                  		movea.l	ringMgrLoadR.w,a2		; Get starting address of status table
0000435C B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
0000435E 6700 0000                  		beq.w	.End				; If not, branch
00004362 3878 E874                  		movea.w	ringMgrStatPtr.w,a4
00004366 3428 0014                  		move.w	_objXPos(a0),d2			; Player's X position
0000436A 3628 0018                  		move.w	_objYPos(a0),d3			; Player's Y position
0000436E 5142                       		subq.w	#8,d2				; Subtract 8 from X
00004370 7A00                       		moveq	#0,d5
00004372 1A28 002D                  		move.b	_objColH(a0),d5			; Player's collision height
00004376 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00004378 9645                       		sub.w	d5,d3				; Subtract from Y
0000437A 323C 0006                  		move.w	#6,d1
0000437E 3C3C 000C                  		move.w	#$C,d6
00004382 383C 0010                  		move.w	#$10,d4				; Width
00004386 DA45                       		add.w	d5,d5				; Double the height
00004388                            
00004388                            .NextRing:
00004388 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
0000438A 6600                       		bne.s	.GetNext			; If so, get the next ring
0000438C 3011                       		move.w	(a1),d0				; Get ring's X position
0000438E 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00004390 9042                       		sub.w	d2,d0				; Check collision
00004392 6400                       		bcc.s	.ChkCol
00004394 D046                       		add.w	d6,d0
00004396 6500                       		bcs.s	.ChkCol2
00004398 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
0000439C                            
0000439C                            .ChkCol:
0000439C B044                       		cmp.w	d4,d0				; Check collision
0000439E 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
000043A2                            
000043A2                            .ChkCol2:
000043A2 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
000043A6 9041                       		sub.w	d1,d0
000043A8 9043                       		sub.w	d3,d0
000043AA 6400                       		bcc.s	.ChkCol3
000043AC D046                       		add.w	d6,d0
000043AE 6500                       		bcs.s	.Collect
000043B0 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
000043B4                            
000043B4                            .ChkCol3:
000043B4 B045                       		cmp.w	d5,d0
000043B6 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
000043BA                            
000043BA                            .Collect:
000043BA                            							; Consume the ring
000043BA 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
000043BE 6100                       		bsr.s	CollectRing			; Collect it
000043C0 47F8 E3D4                  		lea	ringColList.w,a3		; Get collection list
000043C4                            
000043C4                            .Consume:
000043C4 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
000043C6 66FC                       		bne.s	.Consume			; If not, get the next one
000043C8 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
000043CA 5278 E3D2                  		addq.w	#1,ringColCount.w		; Add to the number of rings consumed
000043CE                            
000043CE                            .GetNext:
000043CE 5849                       		addq.w	#4,a1				; Next ring in ring data
000043D0 544C                       		addq.w	#2,a4				; Next ring in status table
000043D2 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
000043D4 6600 FFB2                  		bne.w	.NextRing			; If not, loop
000043D8                            
000043D8                            .End:
000043D8 4E75                       		rts
000043DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043DA                            ; Collect a ring
000043DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043DA                            CollectRing:
000043DA 5278 E85E                  		addq.w	#1,ringCount.w			; Incremment ring count
000043DE 50F8 E867                  		st	hudUpdateRings.w			; Update ring counter in HUD
000043E2                            		playSnd	#sRing, 2			; Play ring sound
000043E2 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
000043E8 4E75                       		rts
000043EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EA                            ; Render the HUD
000043EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043EA                            Level_RenderHUDAndRings:
000043EA 7C00                       		moveq	#0,d6				; Clear render flags
000043EC 7802                       		moveq	#1*2,d4				; Standard frame
000043EE 4A78 E85E                  		tst.w	ringCount.w			; Do we have 0 rings?
000043F2 6600                       		bne.s	.Not0Rings			; If not, branch
000043F4 0838 0003 E905             		btst	#3,(lvlFrameCnt+1).w		; Can the timer blink?
000043FA 6600                       		bne.s	.Not0Rings			; If not, branch
000043FC 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
000043FE                            
000043FE                            .Not0Rings:
000043FE 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00004402                            		
00004402 303C 0090                  		move.w	#16+128,d0			; X position
00004406 323C 0088                  		move.w	#8+128,d1			; Y position
0000440A 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
0000440E D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00004412 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00004414 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00004416 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
0000441A                            
0000441A                            .RenderingCount:
0000441A 2078 E86C                  		movea.l	ringMgrLoadL.w,a0			; Get starting address of ring data
0000441E 2438 E870                  		move.l	ringMgrLoadR.w,d2			; Get ending address of ring data
00004422 9488                       		sub.l	a0,d2				; Get length of the data to read
00004424 6700                       		beq.s	.End				; If zero length, branch
00004426 3878 E874                  		movea.w	ringMgrStatPtr.w,a4		; Get starting address of status table
0000442A 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
0000442E 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00004432                            		
00004432                            .Loop:
00004432 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00004434 6B00                       		bmi.s	.Next				; If so, branch
00004436 3228 0002                  		move.w	2(a0),d1			; Get Y position
0000443A 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
0000443E 5041                       		addq.w	#8,d1				; Add 8
00004440 B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00004442 6400                       		bhs.s	.Next				; If so, branch
00004444 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00004448 3010                       		move.w	(a0),d0				; Get X position
0000444A 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
0000444C 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00004450 7C00                       		moveq	#0,d6
00004452 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00004456                            
00004456                            .Draw:
00004456 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00004458 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
0000445C D25A                       		add.w	(a2)+,d1			; Add Y offset
0000445E 3CC1                       		move.w	d1,(a6)+			; Save Y position
00004460 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00004462 1C86                       		move.b	d6,(a6)				; Save it
00004464 544E                       		addq.w	#2,a6				; Skip link value
00004466 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00004468 D05A                       		add.w	(a2)+,d0			; Add X offset
0000446A 3CC0                       		move.w	d0,(a6)+			; Save X position
0000446C 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
0000446E                            
0000446E                            .Next:
0000446E 5848                       		addq.w	#4,a0				; Next ring in ring data
00004470 5942                       		subq.w	#4,d2				; Decrement the ring count
00004472 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00004474                            
00004474                            .End:
00004474 4E75                       		rts
00004476                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004476                            ; Custom mappings format.
00004476                            ; Differences include...
00004476                            ;	No offset table (each sprite assumed to be 8 bytes)
00004476                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00004476                            ;	Sign-extended Y-pos value
00004476                            ;	Sign-extended sprite size value
00004476                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004476                            CMap_Ring:
00004476                            		; Main ring frame
00004476 FFF8                       		dc.w	$FFF8
00004478 0005                       		dc.w	$0005
0000447A 26BC                       		dc.w	$0000+$26BC
0000447C FFF8                       		dc.w	$FFF8
0000447E                            
0000447E                            CMap_Ring_Sparkle:
0000447E                            		; Ring sparkle frame 1
0000447E FFF8                       		dc.w	$FFF8
00004480 0005                       		dc.w	$0005
00004482 26B8                       		dc.w	$0000+$26B8
00004484 FFF8                       		dc.w	$FFF8
00004486                            		; Ring sparkle frame 2
00004486 FFF8                       		dc.w	$FFF8
00004488 0005                       		dc.w	$0005
0000448A 3EB8                       		dc.w	($0000+$26B8)|$1800
0000448C FFF8                       		dc.w	$FFF8
0000448E                            		; Ring sparkle frame 3
0000448E FFF8                       		dc.w	$FFF8
00004490 0005                       		dc.w	$0005
00004492 2EB8                       		dc.w	($0000+$26B8)|$800
00004494 FFF8                       		dc.w	$FFF8
00004496                            		; Ring sparkle frame 4
00004496 FFF8                       		dc.w	$FFF8
00004498 0005                       		dc.w	$0005
0000449A 36B8                       		dc.w	($0000+$26B8)|$1000
0000449C FFF8                       		dc.w	$FFF8
0000449E                            CMap_Ring_Sparkle_Last:
0000449E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000449E                            ; HUD mappings
0000449E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000449E                            Map_HUD:	
0000449E 0000 0000                  		dc.w Map_HUD_4-Map_HUD, Map_HUD_18-Map_HUD	
000044A2                            
000044A2 0003                       Map_HUD_4:	dc.b 0, 3	
000044A4 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
000044AA 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
000044B0 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30
000044B6                            
000044B6 0003                       Map_HUD_18:	dc.b 0, 3	
000044B8 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
000044BE 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
000044C4 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
000044CA                            		even
000044CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CA                            ; Update the HUD
000044CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CA                            ; PARAMETERS:
000044CA                            ;	a5.l	- VDP data port
000044CA                            ;	a6.l	- VDP control port
000044CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CA                            ; RETURNS:
000044CA                            ;	Nothing
000044CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CA                            Level_UpdateHUD:
000044CA 4A38 E867                  		tst.b	hudUpdateRings.w		; Does the ring counter need to be updated?
000044CE 6700                       		beq.s	.End				; If not, branch
000044D0 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
000044D2 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
000044D6                            
000044D6                            .DontZero:
000044D6 4238 E867                  		clr.b	hudUpdateRings.w		; Clear update value
000044DA                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
000044DA 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
000044E0 7200                       		moveq	#0,d1
000044E2 3238 E85E                  		move.w	ringCount.w,d1			; Ring count
000044E6 6000                       		bra.s	.UpdateRings			; Update the rings counter
000044E8                            
000044E8                            .End
000044E8 4E75                       		rts
000044EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044EA                            .UpdateRings:
000044EA 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
000044EC 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
000044F2 7C02                       		moveq	#3-1,d6				; Number of digits to draw
000044F4 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers
000044FA                            		
000044FA                            .LoadDigit_Loop:
000044FA 7400                       		moveq	#0,d2				; Reset the digit
000044FC 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
000044FE                            		
000044FE                            .GetDigit:
000044FE 9283                       		sub.l	d3,d1				; Subtract
00004500 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
00004502 5242                       		addq.w	#1,d2				; Increment digit
00004504 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004506                            
00004506                            .InitDrawDigit:
00004506 D283                       		add.l	d3,d1				; Add back
00004508 4A42                       		tst.w	d2				; Is the digit 0?
0000450A 6700                       		beq.s	.DrawDigit			; If so, branch
0000450C 50C4                       		st	d4				; Set the "draw digit" flag
0000450E                            
0000450E                            .DrawDigit:
0000450E 4A04                       		tst.b	d4				; Should we draw the digit?
00004510 6700                       		beq.s	.NextDigit			; If not, branch
00004512 ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00004514 2C80                       		move.l	d0,(a6)				; Set the VDP command
00004516 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
0000451A                            		rept	16
0000451A                            			move.l	(a3)+,(a5)		; Load the digit art
0000451A                            		endr
0000451A 2A9B                     M 	move.l	(a3)+,(a5)
0000451C 2A9B                     M 	move.l	(a3)+,(a5)
0000451E 2A9B                     M 	move.l	(a3)+,(a5)
00004520 2A9B                     M 	move.l	(a3)+,(a5)
00004522 2A9B                     M 	move.l	(a3)+,(a5)
00004524 2A9B                     M 	move.l	(a3)+,(a5)
00004526 2A9B                     M 	move.l	(a3)+,(a5)
00004528 2A9B                     M 	move.l	(a3)+,(a5)
0000452A 2A9B                     M 	move.l	(a3)+,(a5)
0000452C 2A9B                     M 	move.l	(a3)+,(a5)
0000452E 2A9B                     M 	move.l	(a3)+,(a5)
00004530 2A9B                     M 	move.l	(a3)+,(a5)
00004532 2A9B                     M 	move.l	(a3)+,(a5)
00004534 2A9B                     M 	move.l	(a3)+,(a5)
00004536 2A9B                     M 	move.l	(a3)+,(a5)
00004538 2A9B                     M 	move.l	(a3)+,(a5)
0000453A                            		
0000453A                            .NextDigit:
0000453A 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
00004540 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
00004544 4E75                       		rts
00004546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004546 0000 0064                  HUDMod_100:	dc.l	100
0000454A 0000 000A                  HUDMod_10:	dc.l	10
0000454E 0000 0001                  HUDMod_1:	dc.l	1
00004552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004552                            ; Initialize the HUD
00004552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004552                            Level_InitHUD:
00004552 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
00004558 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
0000455C                            		
0000455C                            Level_HUDResetRings:
0000455C                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
0000455C 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
00004562 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
00004566 343C 0002                  		move.w	#3-1,d2				; Length
0000456A                            
0000456A 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers art
00004570                            
00004570                            .LoadTiles:
00004570 101A                       		move.b	(a2)+,d0			; Get digit
00004572 4880                       		ext.w	d0
00004574 ED48                       		lsl.w	#6,d0				; Turn into offset
00004576 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
0000457A                            
0000457A                            		rept	8*2
0000457A                            			move.l	(a3)+,(a5)		; Load art
0000457A                            		endr
0000457A 2A9B                     M 	move.l	(a3)+,(a5)
0000457C 2A9B                     M 	move.l	(a3)+,(a5)
0000457E 2A9B                     M 	move.l	(a3)+,(a5)
00004580 2A9B                     M 	move.l	(a3)+,(a5)
00004582 2A9B                     M 	move.l	(a3)+,(a5)
00004584 2A9B                     M 	move.l	(a3)+,(a5)
00004586 2A9B                     M 	move.l	(a3)+,(a5)
00004588 2A9B                     M 	move.l	(a3)+,(a5)
0000458A 2A9B                     M 	move.l	(a3)+,(a5)
0000458C 2A9B                     M 	move.l	(a3)+,(a5)
0000458E 2A9B                     M 	move.l	(a3)+,(a5)
00004590 2A9B                     M 	move.l	(a3)+,(a5)
00004592 2A9B                     M 	move.l	(a3)+,(a5)
00004594 2A9B                     M 	move.l	(a3)+,(a5)
00004596 2A9B                     M 	move.l	(a3)+,(a5)
00004598 2A9B                     M 	move.l	(a3)+,(a5)
0000459A                            
0000459A 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
0000459E                            
0000459E 4E75                       		rts
000045A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A0                            HUD_RingsBase:
000045A0 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
000045A4 00                         		even
000045A4                            
000045A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A4                            ; Animate the level art
000045A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A4                            ; LEVEL ANIMATION SCRIPTS
000045A4                            ;
000045A4                            ; The AniArt_D_objAnimmate subroutine uses these scripts to reload certain tiles,
000045A4                            ; thus animating them. All the relevant art must be uncompressed, because
000045A4                            ; otherwise the subroutine would spend so much time waiting for the art to be
000045A4                            ; decompressed that the VBLANK window would close before all the animating was done.
000045A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A4                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
000045A4                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
000045A4                            ;		ArtUnc_Flowers1		Source address
000045A4                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
000045A4                            ;		6			Number of frames
000045A4                            ;		2			Number of tiles to load into VRAM for each frame
000045A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A4                            ;	dc.b   0,$7F			Start of the script proper
000045A4                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
000045A4                            ;		$7F			Frame duration. Only here if global duration is -1
000045A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045A4                            AniArt_D_objAnimmate:
000045A4 47F8 E90C                  		lea	lvlAnimCntrs.w,a3		; Level art animation counters
000045A8 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
000045AA 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
000045AC 4E75                       		rts
000045AE                            
000045AE                            .ListNotEmpty:
000045AE                            .Loop:
000045AE 5313                       		subq.b	#1,(a3)				; Tick down frame duration
000045B0 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
000045B2                            
000045B2                            .NextFrame:
000045B2 7000                       		moveq	#0,d0
000045B4 102B 0001                  		move.b	1(a3),d0			; Get current frame
000045B8 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
000045BC 6500                       		blo.s	.NotLastFrame			; If not, branch
000045BE 7000                       		moveq	#0,d0				; If so, reset to first frame
000045C0 1740 0001                  		move.b	d0,1(a3)			; ''
000045C4                            
000045C4                            .NotLastFrame:
000045C4 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
000045C8 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
000045CA 6A00                       		bpl.s	.GlobalDuration
000045CC D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
000045CE 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
000045D2                            
000045D2                            .GlobalDuration:
000045D2 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
000045D6 EB48                       		lsl.w	#5,d0				; Turn it into an offset
000045D8 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
000045DC 2212                       		move.l	(a2),d1				; Get ROM source address
000045DE 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
000045E4 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
000045E6 7600                       		moveq	#0,d3
000045E8 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
000045EC E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
000045EE 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
000045F2                            
000045F2                            .NextScript:
000045F2 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
000045F6 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
000045F8 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
000045FA D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
000045FC                            
000045FC                            .GlobalDuration2:
000045FC 5200                       		addq.b	#1,d0
000045FE 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
00004602 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
00004606 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
00004608 51CE FFA4                  		dbf	d6,.Loop			; Loop
0000460C 4E75                       		rts
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            ; Set an object as solid and check for collision
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For _objStatus):
0000460E                            ;	XXPXSXAX
0000460E                            ;	X	- Unused
0000460E                            ;	P	- Pushing flag
0000460E                            ;	S	- Standing on flag
0000460E                            ;	A	- In air flag (for the player)
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
0000460E                            ;	XXXTXBXS
0000460E                            ;	X	- Unused
0000460E                            ;	T	- Touch top flag
0000460E                            ;	B	- Touch bottom flag
0000460E                            ;	S	- Touch side flag
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            ; PARAMETERS:
0000460E                            ;	d1.w	- Object width
0000460E                            ;	d2.w	- Object height / 2 (when jumping)
0000460E                            ;	d3.w	- Object height / 2 (when walking)
0000460E                            ;	d4.w	- Object x-axis position
0000460E                            ;	a0.l	- Object space pointer
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            ; RETURNS:
0000460E                            ;	See object collision return values above
0000460E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460E                            SolidObject:
0000460E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004610 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004614 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
0000461A 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
0000461E 3401                       		move.w	d1,d2				; Copy object width
00004620 D442                       		add.w	d2,d2				; Double it
00004622 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004628 6600                       		bne.s	.NotOnTop			; If so, branch
0000462A 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000462E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004632 D041                       		add.w	d1,d0				; Add width
00004634 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004636 B042                       		cmp.w	d2,d0				; Compare with the width
00004638 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
0000463A                            
0000463A                            .NotOnTop:
0000463A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004640 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004646 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000464C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004650 7800                       		moveq	#0,d4				; Set collision status to 0
00004652 4E75                       		rts
00004654                            
00004654                            .IsOnTop:
00004654 3404                       		move.w	d4,d2				; Copy X position to d2
00004656 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
0000465A 7800                       		moveq	#0,d4				; Set collision status to 0
0000465C 4E75                       		rts
0000465E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000465E                            ; Set an object as solid and check for collision (even if off screen)
0000465E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000465E                            ; PARAMETERS:
0000465E                            ;	d1.w	- Object width
0000465E                            ;	d2.w	- Object height / 2 (when jumping)
0000465E                            ;	d3.w	- Object height / 2 (when walking)
0000465E                            ;	d4.w	- Object x-axis position
0000465E                            ;	a0.l	- Object space pointer
0000465E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000465E                            ; RETURNS:
0000465E                            ;	See object collision return values above
0000465E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000465E                            SolidObject_Always:
0000465E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004660 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004664 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
0000466A 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
0000466E 3401                       		move.w	d1,d2				; Copy object width
00004670 D442                       		add.w	d2,d2				; Double it
00004672 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004678 6600                       		bne.s	.NotOnTop			; If so, branch
0000467A 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000467E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004682 D041                       		add.w	d1,d0				; Add width
00004684 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004686 B042                       		cmp.w	d2,d0				; Compare with the width
00004688 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
0000468A                            
0000468A                            .NotOnTop:
0000468A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004690 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004696 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000469C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000046A0 7800                       		moveq	#0,d4				; Set collision status to 0
000046A2 4E75                       		rts
000046A4                            
000046A4                            .IsOnTop:
000046A4 3404                       		move.w	d4,d2				; Copy X position to d2
000046A6 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000046AA 7800                       		moveq	#0,d4				; Set collision status to 0
000046AC 4E75                       		rts
000046AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046AE                            ; Set an object as a solid slope and check for collision
000046AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046AE                            ; PARAMETERS:
000046AE                            ;	d1.w	- Object width
000046AE                            ;	d2.w	- Object height / 2 (when jumping)
000046AE                            ;	d3.w	- Object height / 2 (when walking)
000046AE                            ;	d4.w	- Object x-axis position
000046AE                            ;	a0.l	- Object space pointer
000046AE                            ;	a2.l	- Slope height data pointer
000046AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046AE                            ; RETURNS:
000046AE                            ;	See object collision return values above
000046AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046AE                            SlopedSolid:
000046AE 7C00                       		moveq	#0,d6				; Clear collision flag register
000046B0 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
000046B4 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
000046BA 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
000046BE 3401                       		move.w	d1,d2				; Copy object width
000046C0 D442                       		add.w	d2,d2				; Double it
000046C2 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000046C8 6600                       		bne.s	.NotOnTop			; If so, branch
000046CA 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000046CE 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000046D2 D041                       		add.w	d1,d0				; Add width
000046D4 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000046D6 B042                       		cmp.w	d2,d0				; Compare with the width
000046D8 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000046DA                            
000046DA                            .NotOnTop:
000046DA 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
000046E0 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
000046E6 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
000046EC 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000046F0 7800                       		moveq	#0,d4				; Set collision status to 0
000046F2 4E75                       		rts
000046F4                            
000046F4                            .IsOnTop:
000046F4 3404                       		move.w	d4,d2				; Copy X position to d2
000046F6 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
000046FA 7800                       		moveq	#0,d4				; Set collision status to 0
000046FC 4E75                       		rts
000046FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046FE                            SlopedSolid_ChkCollision:
000046FE 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004702 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract current object's X position
00004706 D041                       		add.w	d1,d0				; Add width to it
00004708 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
0000470C 3601                       		move.w	d1,d3				; Copy width to d3
0000470E D643                       		add.w	d3,d3				; Double it
00004710 B043                       		cmp.w	d3,d0				; Compare to the X position
00004712 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004716 3A00                       		move.w	d0,d5				; Copy the X position to d5
00004718 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X-flipped?
0000471E 6700                       		beq.s	.NoFlip				; If not, branch
00004720 4645                       		not.w	d5				; Logical notation on d5
00004722 DA43                       		add.w	d3,d5				; Add width
00004724                            
00004724                            .NoFlip:
00004724 E24D                       		lsr.w	#1,d5				; Divide by 2
00004726 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
0000472A 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
0000472C 4883                       		ext.w	d3				; Sign extend to word
0000472E 3A28 0018                  		move.w	_objYPos(a0),d5			; Get the current object's Y position
00004732 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
00004734 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
00004738 4883                       		ext.w	d3				; Sign extend to word
0000473A D443                       		add.w	d3,d2				; Add collision height to the object height
0000473C 3629 0018                  		move.w	_objYPos(a1),d3			; Get the player's Y position
00004740 9645                       		sub.w	d5,d3				; Subtract d5
00004742 5843                       		addq.w	#4,d3				; Add 4
00004744 D642                       		add.w	d2,d3				; Add height and collision height
00004746 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
0000474A 3802                       		move.w	d2,d4				; Copy height and collision height
0000474C D844                       		add.w	d4,d4				; Double it
0000474E B644                       		cmp.w	d4,d3				; Compare to Y position
00004750 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004754 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
00004758                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004758                            SolidObject_ChkColOnScr:
00004758 4A28 000D                  		tst.b	_objRender(a0)			; Is the object on screen?
0000475C 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
00004760                            
00004760                            SolidObject_ChkCollision:
00004760 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004764 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004768 D041                       		add.w	d1,d0				; Add width
0000476A 3601                       		move.w	d1,d3				; Copy width
0000476C D643                       		add.w	d3,d3				; Double it
0000476E B043                       		cmp.w	d3,d0				; Compare with the X position
00004770 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004774                            		
00004774 1829 0000                  		move.b	_objInitColH(a1),d4		; Get the player's default collision height
00004778 4884                       		ext.w	d4				; Sign extend to word
0000477A D842                       		add.w	d2,d4				; Add height
0000477C 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
00004780 4883                       		ext.w	d3				; Sign extend to word
00004782 D443                       		add.w	d3,d2				; Add to height
00004784 3629 0018                  		move.w	_objYPos(a1),d3			; Get player's Y position
00004788 9668 0018                  		sub.w	_objYPos(a0),d3			; Subtract the current object's Y position
0000478C 5843                       		addq.w	#4,d3				; Add 4
0000478E D642                       		add.w	d2,d3				; Add height
00004790 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
00004794 D842                       		add.w	d2,d4				; Add height
00004796 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004798 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
0000479C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000479C                            SolidObject_ChkBounds:
0000479C 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
000047A0 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
000047A4 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
000047AA 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
000047AE 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
000047B2 6600 0000                  		bne.w	SolidObject_End			; If so, branch
000047B6                            
000047B6 3A00                       		move.w	d0,d5				; Copy X offset
000047B8 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
000047BA 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
000047BC D241                       		add.w	d1,d1				; Double collision width
000047BE 9041                       		sub.w	d1,d0				; Subtract from X offset
000047C0 3A00                       		move.w	d0,d5				; Copy X offset
000047C2 4445                       		neg.w	d5				; Negate offset
000047C4                            
000047C4                            .IsLeft:
000047C4 3203                       		move.w	d3,d1				; Copy Y offset
000047C6 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
000047C8 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
000047CA 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
000047CC 9644                       		sub.w	d4,d3				; Subtract height from the collision height
000047CE 3203                       		move.w	d3,d1				; Copy Y offset
000047D0 4441                       		neg.w	d1				; Negate offset
000047D2                            
000047D2                            .IsAbove:
000047D2 BA41                       		cmp.w	d1,d5
000047D4 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
000047D8 0C41 0004                  		cmpi.w	#4,d1
000047DC 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
000047E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E0                            SolidObject_Sides:
000047E0 4A40                       		tst.w	d0
000047E2 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
000047E4 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
000047E6 4A69 001C                  		tst.w	_objXVel(a1)			; Is the player moving left?
000047EA 6B00                       		bmi.s	.AlignPlayer			; If so, branch
000047EC 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
000047EE                            
000047EE                            .ChkRight:
000047EE 4A69 001C                  		tst.w	_objXVel(a1)
000047F2 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
000047F4                            
000047F4                            .ClearGroundVel:
000047F4 4269 0000                  		clr.w	_objGVel(a1)			; Stop the player from moving
000047F8 4269 001C                  		clr.w	_objXVel(a1)			; Clear the player's X velocity
000047FC                            
000047FC                            .AlignPlayer:
000047FC 9169 0014                  		sub.w	d0,_objXPos(a1)			; Align player to the side of the object
00004800 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004806 6600                       		bne.s	.InAir				; If so, branch
00004808 08E8 0005 0028             		bset	#cPushBit,_objStatus(a0)		; Set the pushing bit
0000480E 08E9 0005 0028             		bset	#cPushBit,_objStatus(a1)		; Set the player's pushing bit
00004814 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004818 7801                       		moveq	#1,d4				; Set collision status to 1
0000481A 4E75                       		rts
0000481C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000481C                            .InAir:
0000481C 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
0000481E 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004822 7801                       		moveq	#1,d4				; Set collision status to 1
00004824 4E75                       		rts
00004826                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004826                            SolidObject_TestClearPush:
00004826 0828 0005 0028             		btst	#cPushBit,_objStatus(a0)		; Is the player pushing this object?
0000482C 6700                       		beq.s	SolidObject_End			; If not, branch
0000482E 0C29 0002 0020             		cmpi.b	#2,_objAnim(a1)			; Is the player jumping/rolling?
00004834 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004836 0C29 0017 0020             		cmpi.b	#$17,_objAnim(a1)			; Is the player in using the drowning animation
0000483C 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000483E 0C29 001A 0020             		cmpi.b	#$1A,_objAnim(a1)			; Is the player in using the hurt animation
00004844 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004846 337C 0001 0020             		move.w	#1,_objAnim(a1)			; Make the player use the walking animation
0000484C                            
0000484C                            SolidObject_ClearPush:
0000484C 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear the pushing bit
00004852 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; Clear the player's pushing bit
00004858                            
00004858                            SolidObject_End:
00004858 7800                       		moveq	#0,d4				; Set collision status to 0
0000485A 4E75                       		rts
0000485C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000485C                            SolidObject_UpDown:
0000485C 4A43                       		tst.w	d3				; Is the player below the middle of the object?
0000485E 6B00                       		bmi.s	SolidObject_Below		; If so, branch
00004860 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
00004864 6500                       		bcs.s	SolidObject_Above		; If so, branch
00004866 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
00004868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004868                            SolidObject_Below:
00004868 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving vertically?
0000486C 6700                       		beq.s	.CheckCrush			; If so, branch
0000486E 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
00004870 4A43                       		tst.w	d3				; Is the player above the middle of the object?
00004872 6A00                       		bpl.s	.SetY				; If so, branch
00004874 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
00004878                            
00004878                            .SetY:
00004878 9769 0018                  		sub.w	d3,_objYPos(a1)			; Push the player below the object
0000487C 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004880 78FE                       		moveq	#-2,d4				; Set the collision status to -2
00004882 4E75                       		rts
00004884                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004884                            .CheckCrush:
00004884 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
0000488A 66EC                       		bne.s	.SetY				; If so, branch
0000488C 3800                       		move.w	d0,d4				; Get x offset
0000488E 6A00                       		bpl.s	.NoNeg				; If it's positive branch
00004890 4444                       		neg.w	d4				; Negate it (absolute value)
00004892                            
00004892                            .NoNeg:
00004892 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004896 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
0000489A                            		
0000489A                            		push.l	a0				; Store the current object's address
0000489A 2F08                     M 	move.l	a0,-(sp)
0000489C 2049                       		movea.l	a1,a0				; Replace with the player's address
0000489E 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
000048A4                            		pop.l	a0				; Restore the current object's address
000048A4 205F                     M 	move.l	(sp)+,a0
000048A6 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000048AA 78FE                       		moveq	#-2,d4				; Set collision status to -2
000048AC 4E75                       		rts
000048AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048AE                            SolidObject_Above:
000048AE 5943                       		subq.w	#4,d3				; Get the sub Y offset
000048B0                            		
000048B0                            		; This next bit ensures the player does not collide with the top when next to the walls
000048B0                            		; recalculates object width.
000048B0                            
000048B0 7200                       		moveq	#0,d1
000048B2 1228 002C                  		move.b	_objColW(a0),d1			; Get the current object's width
000048B6 3401                       		move.w	d1,d2				; Copy it
000048B8 D442                       		add.w	d2,d2				; Double it
000048BA                            		
000048BA D269 0014                  		add.w	_objXPos(a1),d1			; Add the player's X position
000048BE 9268 0014                  		sub.w	_objXPos(a0),d1			; Subtract the current object's X position
000048C2 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
000048C4                            		
000048C4 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
000048C6 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
000048C8                            		
000048C8 5369 0018                  		subq.w	#1,_objYPos(a1)			; Subtract 1 from the player's Y position
000048CC 9769 0018                  		sub.w	d3,_objYPos(a1)			; Move the player above the object
000048D0 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
000048D4 6B00                       		bmi.s	.NoCollision			; If so, branch
000048D6 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
000048DA 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
000048DE 78FF                       		moveq	#-1,d4				; Set collision status to -1
000048E0 4E75                       		rts
000048E2                            
000048E2                            .NoCollision:
000048E2 7800                       		moveq	#0,d4				; Set collision status to 0
000048E4 4E75                       		rts
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; Set an object as a platform and check for collision
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; PARAMETERS:
000048E6                            ;	d1.w	- Object's width
000048E6                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
000048E6                            ;	d3.w	- Object's height
000048E6                            ;	d4.w	- Object x-axis position
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; RETURNS:
000048E6                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            PlatformObject:
000048E6 7C00                       		moveq	#0,d6				; Clear collision flag register
000048E8 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
000048EC 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
000048F2 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
000048F6 3401                       		move.w	d1,d2				; Copy the object's width
000048F8 D442                       		add.w	d2,d2				; Double it
000048FA 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004900 6600                       		bne.s	.NotOnTop			; If so, branch
00004902 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004906 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000490A D041                       		add.w	d1,d0				; Add width
0000490C 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000490E B042                       		cmp.w	d2,d0				; Compare with the width
00004910 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004912                            
00004912                            .NotOnTop:
00004912 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004918 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000491E 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004924 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004928 7800                       		moveq	#0,d4				; Set the collision status to 0
0000492A 4E75                       		rts
0000492C                            
0000492C                            .OnTop:
0000492C 3404                       		move.w	d4,d2				; Copy X position
0000492E 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
00004932 7800                       		moveq	#0,d4				; Set the collision status to 0
00004934 4E75                       		rts
00004936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004936                            Platform_ChkBridgeCol:
00004936 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
0000493A 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000493E 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004942 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004946 D041                       		add.w	d1,d0				; Add width
00004948 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000494C B042                       		cmp.w	d2,d0				; Compare with width
0000494E 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004952 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
00004954                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004954                            Platform_ChkCollision:
00004954 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004958 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000495C 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004960 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004964 D041                       		add.w	d1,d0				; Add width
00004966 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000496A D241                       		add.w	d1,d1				; Double width
0000496C B041                       		cmp.w	d1,d0				; Compare with width
0000496E 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004972                            
00004972                            Platform_ChkCol_Cont:
00004972 3028 0018                  		move.w	_objYPos(a0),d0			; Get the object's Y position
00004976 9043                       		sub.w	d3,d0				; Subtract the height from it
00004978                            
00004978                            PlatformObject_ChkYRange:
00004978 3429 0018                  		move.w	_objYPos(a1),d2			; Get the player's Y position
0000497C 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004980 4881                       		ext.w	d1				; Sign extend it
00004982 D242                       		add.w	d2,d1				; Add the Y position to the collision height
00004984 5841                       		addq.w	#4,d1				; Add 4
00004986 9041                       		sub.w	d1,d0				; SubactID the result from the Y position
00004988 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
0000498C 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
00004990 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
00004994 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004998 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
0000499C 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
000049A0 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000049A4 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)		; Is the player dead?
000049AA 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
000049AE D440                       		add.w	d0,d2				; Add the previous result to the Y position
000049B0 5642                       		addq.w	#3,d2				; Add 3
000049B2 3342 0018                  		move.w	d2,_objYPos(a1)			; Add to the player's Y position
000049B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049B6                            ; Set the player on top of the object
000049B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049B6                            ; PARAMETERS:
000049B6                            ;	a0.l	- Object space pointer
000049B6                            ;	a1.l	- Player object space pointer
000049B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049B6                            ; RETURNS:
000049B6                            ;	Nothing
000049B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049B6                            RideObject_SetRide:
000049B6 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
000049BC 6700                       		beq.s	.IsStanding			; If not, branch
000049BE 3669 0000                  		movea.w	_objInteract(a1),a3		; Get the object the player is standing on
000049C2 08AB 0003 0028             		bclr	#cStandBit,_objStatus(a3)		; Clear its standing on object bit
000049C8 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000049CC                            
000049CC                            .IsStanding:
000049CC 3348 0000                  		move.w	a0,_objInteract(a1)		; Set it as the object the player is standing on
000049D0 4229 0000                  		clr.b	_objAngle(a1)			; Clear the player's angle
000049D4 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
000049D8 3369 001C 0000             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's X velocity as its ground velocity
000049DE 08E9 0003 0028             		bset	#cStandBit,_objStatus(a1)		; Set the player's standing on object bit
000049E4 08E8 0003 0028             		bset	#cStandBit,_objStatus(a0)		; Set the player standing on this object bir
000049EA 08A9 0001 0028             		bclr	#1,_objStatus(a1)			; Clear the player's in midair bit
000049F0 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
000049F2 2F08                       		move.l	a0,-(sp)			; Store the current object's address
000049F4 2049                       		movea.l	a1,a0				; Replace it with the player's address
000049F6 6100 E8A6                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
000049FA 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
000049FC                            
000049FC                            PlatformObject_End:
000049FC 4E75                       		rts
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; Set an object as a solid slope and check for collision
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; PARAMETERS:
000049FE                            ;	d1.w	- Object width
000049FE                            ;	d3.w	- Object height
000049FE                            ;	d4.w	- Object x-axis position
000049FE                            ;	a0.l	- Object space pointer
000049FE                            ;	a2.l	- Slope height data pointer
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; RETURNS:
000049FE                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            SlopedPlatform:
000049FE 7C00                       		moveq	#0,d6				; Clear collision flag register
00004A00 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
00004A04 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
00004A0A 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
00004A0E 3401                       		move.w	d1,d2				; Copy the object's width
00004A10 D442                       		add.w	d2,d2				; Double it
00004A12 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004A18 6600                       		bne.s	.NotOnTop			; If so, branch
00004A1A 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004A1E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004A22 D041                       		add.w	d1,d0				; Add width
00004A24 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
00004A26 B042                       		cmp.w	d2,d0				; Compare with the width
00004A28 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004A2A                            
00004A2A                            .NotOnTop:
00004A2A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004A30 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004A36 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004A3C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004A40 7800                       		moveq	#0,d4				; Set the collision status to 0
00004A42 4E75                       		rts
00004A44                            
00004A44                            .OnTop:
00004A44 3404                       		move.w	d4,d2				; Copy X position
00004A46 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
00004A4A 7800                       		moveq	#0,d4				; Set the collision status to 0
00004A4C 4E75                       		rts
00004A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A4E                            SlopedPlarform_ChkCol:
00004A4E 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004A52 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
00004A56 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004A5A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004A5E D041                       		add.w	d1,d0				; Add width
00004A60 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004A64 D241                       		add.w	d1,d1				; Double width
00004A66 B041                       		cmp.w	d1,d0				; Compare with width
00004A68 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004A6C 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
00004A72 6700                       		beq.s	.NoXFlip			; If not, skip
00004A74 4640                       		not.w	d0				; Logical notation
00004A76 D041                       		add.w	d1,d0				; Add width
00004A78                            
00004A78                            .NoXFlip:
00004A78 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004A7A 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
00004A7E 4883                       		ext.w	d3				; Sign extend to word
00004A80 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
00004A84 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
00004A86 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; Move the player along a platform/solid object
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; PARAMETERS:
00004A8A                            ;	d2.w	- X position of the platform
00004A8A                            ;	d3.w	- Height of the platform
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; RETURNS:
00004A8A                            ;	Nothing
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            PlayerMoveOnPtfm:
00004A8A 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
00004A8E 9043                       		sub.w	d3,d0				; Subtract height
00004A90 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
00004A94 6B00                       		bmi.s	.End				; If so, branch
00004A96 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
00004A9C 6400                       		bcc.s	.End				; If so, branch
00004A9E 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004AA2 6600                       		bne.s	.End				; If so, branch
00004AA4 7200                       		moveq	#0,d1
00004AA6 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004AAA 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004AAC 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004AB0 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004AB4 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
00004AB8                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004AB8                            		;beq.s	.End				; If not branch
00004AB8                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004AB8                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004AB8                            
00004AB8                            .End:
00004AB8 4E75                       		rts
00004ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ABA                            ; Move the player along a sloped platform/solid object
00004ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ABA                            ; PARAMETERS:
00004ABA                            ;	d3.w	- Height of the platform
00004ABA                            ;	d4.w	- X position of the platform
00004ABA                            ;	a2.l	- Slope height data pointer
00004ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ABA                            ; RETURNS:
00004ABA                            ;	Nothing
00004ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ABA                            PlayerMoveOnSlope:
00004ABA 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
00004AC0 6700                       		beq.s	.End				; If not, branch
00004AC2 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004AC6 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004ACA D041                       		add.w	d1,d0				; Add width
00004ACC E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004ACE 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
00004AD4 6700                       		beq.s	.NoXFlip			; If not, branch
00004AD6 4640                       		not.w	d0				; Logical notation on d0
00004AD8 D041                       		add.w	d1,d0				; Add width
00004ADA                            
00004ADA                            .NoXFlip:
00004ADA 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
00004ADE 4881                       		ext.w	d1				; Sign extend to word
00004AE0 3028 0018                  		move.w	_objYPos(a0),d0			; Get current object's Y position
00004AE4 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004AE6 7200                       		moveq	#0,d1
00004AE8 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004AEC 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004AEE 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004AF2 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004AF6 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
00004AFA                            
00004AFA                            .End:
00004AFA 4E75                       		rts
00004AFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AFC                            ; Do object collision for the player object
00004AFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AFC                            PlayerDoObjCollision:
00004AFC 4EB8 434A                  		jsr	PlayeringCollectlision		; Do ring collision
00004B00                            		
00004B00 3428 0014                  		move.w	_objXPos(a0),d2			; Get X position
00004B04 3628 0018                  		move.w	_objYPos(a0),d3			; Get Y position
00004B08 5142                       		subq.w	#8,d2				; Get left sensor X
00004B0A 7A00                       		moveq	#0,d5
00004B0C 1A28 002D                  		move.b	_objColH(a0),d5			; Get collision height
00004B10 5705                       		subq.b	#3,d5				; Subtract 3
00004B12 9645                       		sub.w	d5,d3				; Get left sensor Y
00004B14 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
00004B18 DA45                       		add.w	d5,d5				; Get right sensor delta Y
00004B1A                            
00004B1A 49F8 E7D6                  		lea	collideList.w,a4			; Get collision response list
00004B1E 3C1C                       		move.w	(a4)+,d6			; Get count
00004B20 6700                       		beq.s	.End				; If there are no objects to test, branch
00004B22                            
00004B22                            .ObjLoop:
00004B22 325C                       		movea.w	(a4)+,a1			; Get object
00004B24 1029 002A                  		move.b	_objColType(a1),d0			; Does touching it do anything?
00004B28 6600                       		bne.s	.ChkPosition			; If so, branch
00004B2A                            
00004B2A                            .NextObj:
00004B2A 5546                       		subq.w	#2,d6				; Decrement count
00004B2C 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
00004B2E 7000                       		moveq	#0,d0				; Reset d0
00004B30                            
00004B30                            .End:
00004B30 4278 E7D6                  		clr.w	collideList.w			; Clear the collision response list count
00004B34 4E75                       		rts
00004B36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B36                            .ChkPosition:
00004B36 7200                       		moveq	#0,d1
00004B38 1229 002C                  		move.b	_objColW(a1),d1			; Get object width
00004B3C 3029 0014                  		move.w	_objXPos(a1),d0			; Get object X position
00004B40 9041                       		sub.w	d1,d0				; Get left side of object
00004B42 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
00004B44 6400                       		bcc.s	.ChkRightSide			; If so, branch
00004B46 D241                       		add.w	d1,d1				; Get right side delta X
00004B48 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004B4A 6500                       		bcs.s	.ChkHeight			; If not, branch
00004B4C 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
00004B4E                            
00004B4E                            .ChkRightSide:
00004B4E B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
00004B50 62D8                       		bhi.s	.NextObj			; If not, branch
00004B52                            
00004B52                            .ChkHeight:
00004B52 7200                       		moveq	#0,d1
00004B54 1229 002D                  		move.b	_objColH(a1),d1			; Get object height
00004B58 3029 0018                  		move.w	_objYPos(a1),d0			; Get object Y position
00004B5C 9041                       		sub.w	d1,d0				; Get top of object
00004B5E 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
00004B60 6400                       		bcc.s	.ChkBottom			; If so, branch
00004B62 D241                       		add.w	d1,d1				; Get bottom delta Y
00004B64 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004B66 6500                       		bcs.s	.ChkType			; If not, branch
00004B68 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004B6A                            
00004B6A                            .ChkBottom:
00004B6A B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
00004B6C 62BC                       		bhi.s	.NextObj			; If not, branch
00004B6E                            
00004B6E                            .ChkType:
00004B6E 7000                       		moveq	#0,d0
00004B70 1029 002A                  		move.b	_objColType(a1),d0			; Get collision type
00004B74 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004B78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B78                            .CollisionTypes:
00004B78 6000                       		bra.s	.Enemy				; Enemy
00004B7A 6000                       		bra.s	.Indestructable			; Indestructable
00004B7C                            
00004B7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7C                            .Enemy:
00004B7C 0C28 0002 0020             		cmpi.b	#2,_objAnim(a0)			; Are we rolling?
00004B82 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004B86                            
00004B86                            .ChkBoss:
00004B86 4A29 002B                  		tst.b	_objHitCnt(a1)			; Do we have a hit count?
00004B8A 6700                       		beq.s	.Kill				; If not, branch
00004B8C 4468 001C                  		neg.w	_objXVel(a0)			; Bounce backwards
00004B90 4468 001E                  		neg.w	_objYVel(a0)			; ''
00004B94 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004B98 5329 002B                  		subq.b	#1,_objHitCnt(a1)			; Decrement hit count
00004B9C 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
00004B9E 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004BA4                            
00004BA4                            .BossEnd:
00004BA4 4E75                       		rts
00004BA6                            
00004BA6                            .Kill:
00004BA6 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004BAC 22BC 0000 0000             		move.l	#ObjExplosion,_objAddress(a1)		; Change into an explosion
00004BB2 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004BB6 4229 0025                  		clr.b	_objRoutine(a1)			; Reset the routine ID
00004BBA 4A68 001E                  		tst.w	_objYVel(a0)			; Are we going up?
00004BBE 6B00                       		bmi.s	.MoveDown			; If so, branch
00004BC0 3028 0018                  		move.w	_objYPos(a0),d0			; Are we below the object?
00004BC4 B069 0018                  		cmp.w	_objYPos(a1),d0			; ''
00004BC8 6400                       		bhs.s	.MoveUp				; If so, branch
00004BCA 4468 001E                  		neg.w	_objYVel(a0)			; Bounce up
00004BCE 4E75                       		rts
00004BD0                            
00004BD0                            .MoveDown:
00004BD0 0668 0100 001E             		addi.w	#$100,_objYVel(a0)			; Move down
00004BD6 4E75                       		rts
00004BD8                            
00004BD8                            .MoveUp:
00004BD8 0468 0100 001E             		subi.w	#$100,_objYVel(a0)			; Move up
00004BDE 4E75                       		rts
00004BE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE0                            .Indestructable: 
00004BE0                            ;---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE0                            .ChkHurt:
00004BE0 4A68 0000                  		tst.w	_objInvulTime(a0)			; Are we invulnerable?
00004BE4 6600                       		bne.s	.NoHurt				; If so, branch
00004BE6 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
00004BE8 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
00004BEE                            
00004BEE                            .NoHurt:
00004BEE 4E75                       		rts
00004BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BF0                            ; Add a new entry to the collision response list
00004BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BF0                            AddToColResponse:
00004BF0 43F8 E7D6                  		lea	collideList.w,a1			; Get collision response list
00004BF4 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
00004BF8 6400                       		bhs.s	.End				; If so, branch
00004BFA 5451                       		addq.w	#2,(a1)				; Add a new entry
00004BFC D2D1                       		adda.w	(a1),a1				; Get entry pointer
00004BFE 3288                       		move.w	a0,(a1)				; Store entry
00004C00                            
00004C00                            .End:
00004C00 4E75                       		rts
00004C02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C02                            ; Save some info in a level (mainly for checkpoints)
00004C02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C02                            ; PARAMETERS:
00004C02                            ;	a0.l	- Object space pointer
00004C02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C02                            ; RETURNS:
00004C02                            ;	Nothing
00004C02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C02                            Level_SaveInfo:
00004C02 31E8 0014 C7B2             		move.w	_objXPos(a0),chkSavedXPos.w		; Save X position
00004C08 31E8 0018 C7B4             		move.w	_objYPos(a0),chkSavedYPos.w		; Save Y position
00004C0E 4E75                       		rts
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            ; Load some info in a level (mainly for checkpoints)
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            ; PARAMETERS:
00004C10                            ;	a0.l	- Object space pointer
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            ; RETURNS:
00004C10                            ;	Nothing
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            Level_LoadSavedInfo:
00004C10 3178 C7B2 0014             		move.w	chkSavedXPos.w,_objXPos(a0)		; Load X position
00004C16 3178 C7B4 0018             		move.w	chkSavedYPos.w,_objYPos(a0)		; Load Y position
00004C1C 4E75                       		rts
00004C1E                            ; =========================================================================================================================================================
00004C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C1E                            ; Music IDs
00004C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C1E                            Level_MusicIDs:
00004C1E 0B0B                       		dc.b	mWWZ, mWWZ
00004C20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C20                            ; Level water heights (-1 for no water)
00004C20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C20                            Level_WatelevelIDs:
00004C20                            		;dc.w	$490, -1			; Wacky Workbench
00004C20 FFFF FFFF                  		dc.w	-1, -1
00004C24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C24                            ; Level data pointers
00004C24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C24                            ; FORMAT:
00004C24                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004C24                            ;	dc.l	FG LAYOUT, BG LAYOUT 
00004C24                            ;	dc.l	OBJECTS, RINGS, COLLISION
00004C24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C24                            Level_DataPointers:
00004C24 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004C34 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004C3C 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004C48                            
00004C48 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004C58 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004C60 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6C                            ; Size and start position data
00004C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6C                            Level_SizeStartPos:
00004C6C 3000 0580                  		dc.w	$3000, $580
00004C70                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004C74 3000 0580                  		dc.w	$3000, $580
00004C78                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004C7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C7C                            ; Dynamic events routines
00004C7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C7C                            Level_DynEvenRouts:
00004C7C 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004C80 0000 0000                  		dc.l	DynEv_WWZ
00004C84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C84                            ; Wacky Workbench dynamic events routine
00004C84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C84                            DynEv_WWZ:
00004C84 31FC 0000 E8CA             		move.w	#0,	maxCamXPos
00004C8A 31FC 0000 E8CC             		move.w	#0,	maxCamYPos
00004C90 7000                       		moveq	#0,d0
00004C92 1038 E908                  		move.b	dynEventRout.w,d0
00004C96 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004C9A 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            .Index:
00004C9E 0000                       		dc.w	.WaitBoss-.Index
00004CA0 0000                       		dc.w	.Done-.Index
00004CA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA2                            .WaitBoss:
00004CA2                            
00004CA2                            
00004CA2                            .Done:
00004CA2 4E75                       		rts
00004CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA4                            ; Palette cycle routines
00004CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA4                            Level_PalCycRouts:
00004CA4 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004CA8 0000 0000                  		dc.l	PalCycle_WWZ
00004CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CAC                            ; Wacky Workbench palette cycle routine
00004CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CAC                            PalCycle_WWZ:
00004CAC 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00004CB0 6600                       		bne.s	.Flash				; If so, branch
00004CB2                            
00004CB2 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004CB6 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004CB8 50F8 E909                  		st	rFlooactIDive.w		; Set the floor active flag
00004CBC 31FC 00B4 E90A             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004CC2                            
00004CC2                            .ResetPal:
00004CC2 4278 C7D0                  		clr.w	palCycTimer.w		; Reset the palette cycle
00004CC6 31FC 0C28 9930             		move.w	#$C28,(paletteBuff+$62).w		; Set the floor color to be deactivated
00004CCC 31FC 0E48 98B0             		move.w	#$E48,(paletteBuffAlt+$62).w	; ''
00004CD2 4E75                       		rts
00004CD4                            
00004CD4                            .Flash:
00004CD4 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004CD8 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004CDA 4238 E909                  		clr.b	rFlooactIDive.w		; Clear the floor active flag
00004CDE 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004CE4                            
00004CE4                            .UpdatePal:
00004CE4 5338 C7D0                  		subq.b	#1,palCycTimer.w		; Decrement the palette cycle timer
00004CE8 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004CEA 11FC 0001 C7D0             		move.b	#1,palCycTimer.w		; Reset the palette cycle timer
00004CF0                            
00004CF0 7000                       		moveq	#0,d0
00004CF2 1038 C7D1                  		move.b	palCycIndex.w,d0		; Get the palette cycle index
00004CF6 D040                       		add.w	d0,d0				; Turn into offset
00004CF8                            							; Set the floor color
00004CF8 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(paletteBuff+$62).w
00004CFE 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(paletteBuffAlt+$62).w
00004D04                            
00004D04 5238 C7D1                  		addq.b	#1,palCycIndex.w		; Increment the palette cycle index
00004D08 0C38 0005 C7D1             		cmpi.b	#5,palCycIndex.w		; Has it reached the end of the cycle?
00004D0E 6500                       		bcs.s	.End				; If not, branch
00004D10 4238 C7D1                  		clr.b	palCycIndex.w		; Reset the palette cycle index
00004D14                            
00004D14                            .End:
00004D14 4E75                       		rts
00004D16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D16                            PalCyc_WWZFloor:
00004D16 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004D20                            PalCyc_WWZFloorUW:
00004D20 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D2A                            ; Animated art routines
00004D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D2A                            Level_AniArtRouts:
00004D2A 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004D2E 0000 0000                  		dc.l	AniArt_WWZ
00004D32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D32                            ; Wacky Workbench animated art routine
00004D32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D32                            AniArt_WWZ:
00004D32 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004D36 6000 F86C                  		bra.w	AniArt_D_objAnimmate		; Handle animations
00004D3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D3A                            .AniData:
00004D3A 0002                       		dc.w	2
00004D3C                            
00004D3C                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004D3C 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004D40 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004D42 0408                     M 	dc.b	4,8
00004D44 0008 1018                  		dc.b	0, 8, $10, $18
00004D48                            
00004D48                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004D48 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004D4C 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004D4E 0E04                     M 	dc.b	$e,4
00004D50 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004D5E                            
00004D5E                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004D5E 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004D62 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004D64 0804                     M 	dc.b	8,4
00004D66 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004D6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D6E                            ; Level drawing initialization and update routines
00004D6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D6E                            ; PARAMETERS:
00004D6E                            ;	a1.l	- Camera RAM
00004D6E                            ;	a3.l	- Row plane buffer
00004D6E                            ;	a4.l	- Column plane buffer
00004D6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D6E                            ; RETURNS:
00004D6E                            ;	Nothing
00004D6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D6E                            Level_RenderRouts:
00004D6E 0000 2C1E                  		dc.l	General_InitFG			; Wacky Workbench
00004D72 0000 0000                  		dc.l	WWZ_InitBG
00004D76 0000 2C3E                  		dc.l	General_UpdateFG
00004D7A 0000 0000                  		dc.l	WWZ_UpdateBG
00004D7E 0000 2C1E                  		dc.l	General_InitFG
00004D82 0000 0000                  		dc.l	WWZ_InitBG
00004D86 0000 2C3E                  		dc.l	General_UpdateFG
00004D8A 0000 0000                  		dc.l	WWZ_UpdateBG
00004D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D8E                            ; Wacky Workbench background initialization
00004D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D8E                            WWZ_InitBG:
00004D8E 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004D92 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004D96 E440                       		asr.w	#2,d0				; Divide by $20
00004D98 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004D9C                            
00004D9C 6100 E1D8                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004DA0                            
00004DA0 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004DA4 6000 E230                  		bra.w	ScrollSections			; Scroll the planes
00004DA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DA8                            ; Wacky Workbench background update
00004DA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DA8                            WWZ_UpdateBG:
00004DA8 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004DAC 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004DB0 E440                       		asr.w	#2,d0				; Divide by $20
00004DB2 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004DB6                            
00004DB6 6100 E210                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004DBA 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004DBC 6100 DF92                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004DC0                            
00004DC0 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004DC4 6000 E210                  		bra.w	ScrollSections			; Scroll the planes
00004DC8                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004DC8                            		scrollInit WWZ_Scroll
00004DC8                          M scroll_label	equs	"wwz_scroll"
00004DC8 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004DCA                            
00004DCA                            		; CEILING LIGHTS
00004DCA                            		scrollSection	 48, $80
00004DCA 0080 0000 0030           M 	dc.w	$80,0,48
00004DD0                            		scrollSection	 32, $60
00004DD0 0060 0000 0020           M 	dc.w	$60,0,32
00004DD6                            		scrollSection	 32, $50
00004DD6 0050 0000 0020           M 	dc.w	$50,0,32
00004DDC                            		scrollSection	 24, $40
00004DDC 0040 0000 0018           M 	dc.w	$40,0,24
00004DE2                            		scrollSection	 24, $38
00004DE2 0038 0000 0018           M 	dc.w	$38,0,24
00004DE8                            		scrollSection	 16, $30
00004DE8 0030 0000 0010           M 	dc.w	$30,0,16
00004DEE                            		scrollSection	 16, $2C
00004DEE 002C 0000 0010           M 	dc.w	$2c,0,16
00004DF4                            		scrollSection	 16, $28
00004DF4 0028 0000 0010           M 	dc.w	$28,0,16
00004DFA                            		scrollSection	 16, $24
00004DFA 0024 0000 0010           M 	dc.w	$24,0,16
00004E00                            		scrollSection	 16, $20
00004E00 0020 0000 0010           M 	dc.w	$20,0,16
00004E06                            
00004E06                            		; BACK WALL
00004E06                            		scrollSection	160, $40
00004E06 0040 0000 00A0           M 	dc.w	$40,0,160
00004E0C                            
00004E0C                            		; FRONT WALL
00004E0C                            		scrollSection	368, $80
00004E0C 0080 0000 0170           M 	dc.w	$80,0,368
00004E12                            
00004E12                            		scrollEnd
00004E12                          M wwz_scroll_end:
00004E12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E12                            ; Main level PLCs
00004E12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E12                            PLC_LevelMain:
00004E12 000A                       		dc.w	$A
00004E14 0000 0000                  		dc.l	ArtKosM_Chkpoint
00004E18 AFC0                       		dc.w	$AFC0
00004E1A 0000 0000                  		dc.l	ArtKosM_Monitor
00004E1E B100                       		dc.w	$B100
00004E20 0000 0000                  		dc.l	ArtKosM_SpringH
00004E24 B740                       		dc.w	$B740
00004E26 0000 0000                  		dc.l	ArtKosM_SpringV
00004E2A B940                       		dc.w	$B940
00004E2C 0000 0000                  		dc.l	ArtKosM_SpringD
00004E30 BB20                       		dc.w	$BB20
00004E32 0000 0000                  		dc.l	ArtKosM_HUD
00004E36 D000                       		dc.w	$D000
00004E38 0000 0000                  		dc.l	ArtKosM_WaterSurface
00004E3C D200                       		dc.w	$D200
00004E3E 0000 0000                  		dc.l	ArtKosM_SpikesN
00004E42 D500                       		dc.w	$D500
00004E44 0000 0000                  		dc.l	ArtKosM_SpikesS
00004E48 D580                       		dc.w	$D580
00004E4A 0000 0000                  		dc.l	ArtKosM_RingSparkle
00004E4E D700                       		dc.w	$D700
00004E50 0000 0000                  		dc.l	ArtKosM_Explosion
00004E54 D800                       		dc.w	$D800
00004E56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E56                            ; Level PLCs
00004E56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E56                            Level_PLCs:
00004E56 0000 0000                  		dc.l	PLC_WWZ
00004E5A 0000 0000                  		dc.l	PLC_WWZ
00004E5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E5E                            ; Wacky Workbench PLCs
00004E5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E5E                            PLC_WWZ:
00004E5E 0000                       		dc.w	0
00004E60 0000 0000                  		dc.l	ArtKosM_Bumper
00004E64 6B60                       		dc.w	$6B60
00004E66                            	;	dc.l	ArtKosM_Orbinaut
00004E66                            	;	dc.w	$71A0
00004E66                            	;	dc.l	ArtKosM_Diamond
00004E66                            	;	dc.w	$7580
00004E66                            	;	dc.l	ArtKosM_CNZBarrel
00004E66                            	;	dc.w	$7A00
00004E66                            	;	dc.l	ArtKosM_Slicer
00004E66                            	;	dc.w	$8000
00004E66                            	;	dc.l	ArtKosM_ShlCrker
00004E66                            	;	dc.w	$8400
00004E66                            	;	dc.l	ArtKosM_Asteron
00004E66                            	;	dc.w	$8880
00004E66                            	;	dc.l	ArtKosM_Harpoon
00004E66                            	;	dc.w	$8A60
00004E66                            	;	dc.l	ArtKosM_WFZBoss
00004E66                            	;	dc.w	$9000
00004E66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E66                            ; Object index
00004E66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E66                            Level_ObjIndex:
00004E66 0000 0000                  		dc.l	ObjEnemy
00004E6A 0000 0000                  		dc.l	ObjSpike
00004E6E 0000 0000                  		dc.l	ObjSpring
00004E72 0000 0000                  		dc.l	ObjCheckpoint
00004E76 0000 0000                  		dc.l	ObjNull			;ObjSlicer
00004E7A 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
00004E7E 0000 0000                  		dc.l	ObjNull			;ObjAsteron
00004E82 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
00004E86 0000 0000                  		dc.l	ObjWallSpring
00004E8A 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
00004E8E 0000 0000                  		dc.l	ObjBallMode
00004E92 0000 0000                  		dc.l	ObjAttack
00004E96 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
00004E9A 0000 0000                  		dc.l	ObjNull			;ObjDiamond
00004E9E 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
00004EA2                            
00004EA2                            ; =========================================================================================================================================================
00004EA2                            		include	"Opmodes/Ending/Main.asm"
00004EA2                            ; =========================================================================================================================================================
00004EA2                            ; End splash screen
00004EA2                            ; =========================================================================================================================================================
00004EA2                            
00004EA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA2                            Ending:
00004EA2 60FE                       		bra.s	Ending
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00004EA4                            ;
00004EA4                            ;		intsOff					; Disable interrupts
00004EA4                            ;
00004EA4                            ;		lea	VDP_CTRL,a5
00004EA4                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00004EA4                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
00004EA4                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00004EA4                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00004EA4                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
00004EA4                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00004EA4                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00004EA4                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00004EA4                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00004EA4                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00004EA4                            ;
00004EA4                            ;		jsr	ClearScreen.w			; Clear screen
00004EA4                            ;
00004EA4                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
00004EA4                            ;		lea	miscBuff,a1			; Decompress into RAM
00004EA4                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00004EA4                            ;		jsr	EniDec.w			; Decompress!
00004EA4                            ;
00004EA4                            ;		lea	miscBuff,a1			; Load mappings
00004EA4                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00004EA4                            ;		moveq	#$27,d1				; $28x$1C tiles
00004EA4                            ;		moveq	#$1B,d2				; ''
00004EA4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00004EA4                            ;		jsr	LoadPlaneMap.w			; Load the map
00004EA4                            ;
00004EA4                            ;		lea	ArtKosM_End,a1			; Load background art
00004EA4                            ;		move.w	#$20,d2				; ''
00004EA4                            ;		jsr	QueueKosMData.w			; ''
00004EA4                            ;
00004EA4                            ;.WaitPLCs:
00004EA4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004EA4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00004EA4                            ;		jsr	VSync_Routine.w			; V-SYNC
00004EA4                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00004EA4                            ;		tst.b	kosMModules.w			; Are there still modules left?
00004EA4                            ;		bne.s	.WaitPLCs			; If so, branch
00004EA4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004EA4                            ;		jsr	VSync_Routine.w			; V-SYNC
00004EA4                            ;
00004EA4                            ;		lea	SampleList+$F0,a3
00004EA4                            ;		jsr	PlayDAC1
00004EA4                            ;
00004EA4                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
00004EA4                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
00004EA4                            ;		jsr	LoadPalette.w			; ''
00004EA4                            ;
00004EA4                            ;		displayOn
00004EA4                            ;
00004EA4                            ;.Loop:
00004EA4                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00004EA4                            ;		jsr	VSync_Routine.w			; ''
00004EA4                            ;		bra.s	.Loop
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ; Art
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ;ArtKosM_End:
00004EA4                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
00004EA4                            ;		even
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ; Plane mappings
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ;MapEni_End:
00004EA4                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
00004EA4                            ;		even
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ; Palette
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ;Pal_End:
00004EA4                            ;		incbin	"Ending/Data/Palette.pal.bin"
00004EA4                            ;Pal_End_End:
00004EA4                            ;		even
00004EA4                            ; =========================================================================================================================================================
00004EA4                            
00004EA4                            ; =========================================================================================================================================================
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ; Object Code
00004EA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA4                            ObjNull:
00004EA4 4EF8 1A4C                  		jmp	DeleteObject
00004EA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA8                            		include	"Objects/Player/Code.asm"		; Player object
00004EA8                            ; =========================================================================================================================================================
00004EA8                            ; Sonic object
00004EA8                            ; =========================================================================================================================================================
00004EA8 =00000300                  TOP_SPD		EQU	$300				; Top speed
00004EA8 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
00004EA8 =00000080                  DEC_SPD		EQU	$80				; Deceleration
00004EA8 =00000180                  JUMP_HEIGHT	EQU	$180				; Jump height
00004EA8 =00000180                  MIN_JMP_HEIGHT	EQU	$180				; Minimum jump height
00004EA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA8                            		rsset	_objLvlSSTs
00004EA8 =00000030                  _objInitColH	rs.b	1				; Initial collision height
00004EA8 =00000031                  _objInitColW	rs.b	1				; Initial collision width
00004EA8 =00000032                  _objTopSolid	rs.b	1				; Top solid bit
00004EA8 =00000033                  _objLRBSolid	rs.b	1				; LRB solid bit
00004EA8 =00000034                  _objTopSpd	rs.w	1				; Top speed
00004EA8 =00000036                  _objAccel	rs.w	1				; Acceleration
00004EA8 =00000038                  _objDecel	rs.w	1				; Deceleration
00004EA8 =0000003A                  _objFlipDir	rs.w	0				; Flip direction
00004EA8 =0000003A                  _objGVel	rs.w	1				; Ground velocity
00004EA8 =0000003C                  _objInteract	rs.w	1				; Interacted object space pointer
00004EA8 =0000003E                  _objAirTimer	rs.b	1				; Air timer
00004EA8 =0000003F                  _objMoveLock	rs.b	1				; Move lock timer
00004EA8 =00000040                  _objJumping	rs.b	1				; Jumping flag
00004EA8 =00000041                  _objAngle	rs.b	1				; Angle
00004EA8 =00000042                  _objInvulTime	rs.b	1				; Invulnerability timer
00004EA8 =00000043                  _objDeathTimer	rs.b	1				; Death timer
00004EA8 =00000044                  _objScrlDelay	rs.b	1				; Look up and down scroll delay counter
00004EA8 =00000045                  _objDashFlag	rs.b	1				; Dash flags
00004EA8 =00000046                  _objDashTimer	rs.b	1				; Dash timer
00004EA8 =00000047                  _objFlipAngle	rs.b	1				; Flip angle about the X axis
00004EA8 =00000048                  _objFlipTurned	rs.b	1				; Inverted flip flag
00004EA8 =00000049                  _objFlipRemain	rs.b	1				; Remaining flips to do
00004EA8 =0000004A                  _objFlipSpeed	rs.b	1				; Flip speed
00004EA8 =0000004B                  _objBallMode	rs.b	1				; Ball mode flag
00004EA8 =0000004C                  _objHangAniTime	rs.b	1				; Hang animation timer
00004EA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EA8                            ObjPlayer:
00004EA8 7000                       		moveq	#0,d0
00004EAA 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00004EAE 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00004EB2                            	nextObject
00004EB2 3068 0004                M 	movea.w	_objnext(a0),a0
00004EB6 2250                     M 	move.l	_objaddress(a0),a1
00004EB8 4ED1                     M 	jmp	(a1)
00004EBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EBA                            .Index:
00004EBA 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
00004EBE 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
00004EC2 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
00004EC6 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
00004ECA 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
00004ECE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ECE                            ; Initialization routine
00004ECE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004ECE                            ObjPlayer_Init:
00004ECE 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00004ED2                            
00004ED2 117C 0007 002C             		move.b	#7,_objColW(a0)			; Collision width
00004ED8 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Collision height
00004EDE 1168 002C 0031             		move.b	_objColW(a0),_objInitColW(a0)		; Set initial collision width
00004EE4 1168 002D 0030             		move.b	_objColH(a0),_objInitColH(a0)		; Set initial collision height
00004EEA 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,_objMapping(a0)		; Mappings
00004EF2 317C 0780 000E             		move.w	#$780,_objVRAM(a0)			; Sprite tile properties
00004EF8                            	displaySprite	2,a0,a1,0			; Priority
00004EF8 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00004EFE 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00004F02 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00004F06 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00004F0A 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00004F0E                          M .no_212
00004F0E 117C 0018 0017             		move.b	#$18,_objDrawW(a0)			; Sprite width
00004F14 117C 0018 001B             		move.b	#$18,_objDrawH(a0)			; Sprite height
00004F1A 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00004F20                            
00004F20 117C 000C 0032             		move.b	#$C,_objTopSolid(a0)		; Top solid bit
00004F26 117C 000D 0033             		move.b	#$D,_objLRBSolid(a0)		; LRB solid bit
00004F2C 117C 001E 003E             		move.b	#$1E,_objAirTimer(a0)		; Set air timer
00004F32 50D0                       		st	_objPrevDPLC(a0)			; Reset saved DPLC frame
00004F34 4228 0049                  		clr.b	_objFlipRemain(a0)			; No flips remaining
00004F38 117C 0004 004A             		move.b	#4,_objFlipSpeed(a0)		; Flip speed
00004F3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F3E                            ; Main routine
00004F3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F3E                            ObjPlayer_Main:
00004F3E 4A38 C76A                  		tst.b	moveCheat.w
00004F42 6700                       		beq.s	.NoPlacementEnter
00004F44 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00004F4A 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00004F4C 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00004F52 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00004F58 4E75                       		rts
00004F5A                            
00004F5A                            .NoPlacementEnter:
00004F5A 0828 0002 000C             		btst	#2,_objFlags(a0)			; Are the controls locked?
00004F60 6600                       		bne.s	.Update				; If so, branch
00004F62 31F8 C742 E8DE             		move.w	ctrlDataP1.w,plrCtrlData.w		; Set the player's control data
00004F68                            
00004F68                            .Update:
00004F68                            	;	btst	#1,_objStatus(a0)
00004F68                            	;	bne.s	.NotOnGround
00004F68                            
00004F68                            ;.NotOnGround:
00004F68 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
00004F6C 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
00004F70 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
00004F74 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00004F78 4EB8 4AFC                  		jsr	PlayerDoObjCollision		; Do object collision
00004F7C                            
00004F7C 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00004F80 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
00004F84 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00004F88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F88                            ; Handle the extended camera
00004F88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F88                            ObjPlayer_ExtendedCam:
00004F88 3238 E8D6                  		move.w	panCamXPos.w,d1		; Get camera X center
00004F8C 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00004F90 6A00                       		bpl.s	.PosGVel			; Get absolute value
00004F92 4440                       		neg.w	d0				; ''
00004F94                            
00004F94                            .PosGVel:
00004F94 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
00004F98 6500                       		bcs.s	.ResetXShift			; If not, branch
00004F9A 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00004F9E 6A00                       		bpl.s	.MoveRight			; If so, branch
00004FA0 5441                       		addq.w	#2,d1				; Move right
00004FA2 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
00004FA6 6500                       		bcs.s	.SetShift			; ''
00004FA8 323C 00E0                  		move.w	#$E0,d1				; ''
00004FAC 6000                       		bra.s	.SetShift			; Continue
00004FAE                            
00004FAE                            .MoveRight:
00004FAE 5541                       		subq.w	#2,d1				; Move left
00004FB0 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
00004FB4 6400                       		bcc.s	.SetShift			; ''
00004FB6 323C 0060                  		move.w	#$60,d1				; ''
00004FBA 6000                       		bra.s	.SetShift			; Continue
00004FBC                            
00004FBC                            .ResetXShift:
00004FBC 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
00004FC0 6700                       		beq.s	.SetShift			; If so, branch
00004FC2 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
00004FC4 5441                       		addq.w	#2,d1				; Move back right
00004FC6 6000                       		bra.s	.SetShift			; Continue
00004FC8                            
00004FC8                            .ReduceShift:
00004FC8 5541                       		subq.w	#2,d1				; Move back left
00004FCA                            
00004FCA                            .SetShift:
00004FCA 31C1 E8D6                  		move.w	d1,panCamXPos.w		; Set camera X center
00004FCE 4E75                       		rts
00004FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FD0                            ; Update Sonic's physics
00004FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FD0                            ObjPlayer_GetPhysics:
00004FD0 7000                       		moveq	#0,d0
00004FD2 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00004FD8 6700                       		beq.s	.GetOffset			; If not, branch
00004FDA 7008                       		moveq	#8,d0				; Set the underwater bit
00004FDC                            
00004FDC                            .GetOffset:
00004FDC 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
00004FE0 2159 0034                  		move.l	(a1)+,_objTopSpd(a0)		; Set top speed and acceleration
00004FE4 3151 0038                  		move.w	(a1),_objDecel(a0)			; Set deceleration
00004FE8 4E75                       		rts
00004FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FEA                            ; Physics values
00004FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FEA                            ; FORMAT:
00004FEA                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
00004FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FEA                            ObjPlayer_Physics:
00004FEA 0300 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
00004FF2 0180 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
00004FFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FFA                            ; Handle Sonic in the water
00004FFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FFA                            ObjPlayer_Water:
00004FFA 4A38 E8FE                  	tst.b	lvlHasWater.w			; Is there water in the level?
00004FFE 6600                       	bne.s	.HandleWater			; If so, branch
00005000                            
00005000                            .End:
00005000 4E75                       	rts
00005002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005002                            .HandleWater:
00005002 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00005006 B068 0018                  		cmp.w	_objYPos(a0),d0			; Is Lover in the water?
0000500A 6C00                       		bge.s	.NotInWater			; If not, branch
0000500C                            
0000500C 08E8 0006 0028             		bset	#6,_objStatus(a0)			; Set the "in water" flag
00005012 66EC                       		bne.s	.End				; If Lover is already in the water, branch
00005014                            
00005014 E0E8 001C                  		asr.w	_objXVel(a0)			; Make Lover move slower
00005018 E0E8 001E                  		asr.w	_objYVel(a0)
0000501C E0E8 001E                  		asr.w	_objYVel(a0)
00005020 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
00005022                            
00005022                            		playSnd	#sSplash, 2			; Play splash sound
00005022 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00005028 4E75                       		rts
0000502A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000502A                            .NotInWater:
0000502A 08A8 0006 0028             		bclr	#6,_objStatus(a0)			; Clear "in water" flag
00005030 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
00005032                            
00005032 0C28 0010 0025             		cmpi.b	#$10,_objRoutine(a0)			; Is Lover falling back from getting hurt?
00005038 6700                       		beq.s	.ChkSplash			; If so, branch
0000503A E1E8 001E                  		asl	_objYVel(a0)			; Make Lover move faster vertically
0000503E                            
0000503E                            .ChkSplash:
0000503E 4A68 001E                  		tst.w	_objYVel(a0)			; Does a splash need to be created?
00005042 67BC                       		beq.s	.End				; If not, branch
00005044                            
00005044 0C68 F000 001E             		cmpi.w	#-$1000,_objYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
0000504A 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
0000504C 317C F000 001E             		move.w	#-$1000,_objYVel(a0)		; Cap the speed
00005052                            
00005052                            .PlaySplashSnd:
00005052                            		playSnd	#sSplash, 2			; Play splash sound
00005052 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00005058 4E75                       		rts
0000505A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000505A                            ; Do Sonic's modes
0000505A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000505A                            ObjPlayer_DoModes:
0000505A 0828 0000 000C             		btst	#0,_objFlags(a0)			; Is running Sonic's mode disabled?
00005060 6600                       		bne.s	.NoMode				; If so, branch
00005062                            
00005062 7000                       		moveq	#0,d0
00005064 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00005068 0240 0006                  		andi.w	#6,d0				; Only get mode bits
0000506C D040                       		add.w	d0,d0
0000506E 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
00005072                            
00005072 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00005076 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
0000507A 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
0000507E 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
00005082                            
00005082                            .NoMode:
00005082 4E75                       		rts
00005084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005084                            ; Sonic's modes
00005084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005084                            ObjPlayer_Modes:
00005084 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
00005088 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
0000508C 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
00005090 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
00005094                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005094                            ; Ground mode
00005094                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005094                            ObjPlayer_MdGround:
00005094                            ;		bsr.w	ObjPlayer_Peelout		; Handle the peelout
00005094                            ;		bsr.w	ObjPlayer_Spindash		; Handle the spindash
00005094 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00005098 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
0000509C                            ;		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
0000509C 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
000050A0 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
000050A4 4EB8 372E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
000050A8                            
000050A8 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
000050AC 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ; Misc. updates
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ObjPlayer_MiscUpdates:
000050B0 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer finished?
000050B4 6700                       		beq.s	.NoMoveLock			; If so, branch
000050B6 5328 003F                  		subq.b	#1,_objMoveLock(a0)		; Decrement the timer
000050BA                            
000050BA                            .NoMoveLock:
000050BA 4EB8 3446                  		jsr	sub_F846
000050BE 4A41                       		tst.w	d1
000050C0 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
000050C4 4EB8 36D6                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
000050C8 4A41                       		tst.w	d1				; Has Sonic entered the wall?
000050CA 6A00                       		bpl.s	.ChkRight			; If not, branch
000050CC 9368 0014                  		sub.w	d1,_objXPos(a0)			; Fix Sonic's X position
000050D0                            
000050D0                            .ChkRight:
000050D0 4EB8 355A                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
000050D4 4A41                       		tst.w	d1				; Has Sonic entered the wall?
000050D6 6A00                       		bpl.s	.End				; If not, branch
000050D8 D368 0014                  		add.w	d1,_objXPos(a0)			; Fix Sonic's X position
000050DC                            
000050DC                            .End:
000050DC 4E75                       		rts
000050DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050DE                            ; Air and jump modes
000050DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050DE                            ObjPlayer_MdJump:
000050DE                            ObjPlayer_MdAir:
000050DE 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
000050E2 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
000050E6                            
000050E6 4268 003C                  		clr.w	_objInteract(a0)			; Sonic cannot be interacting with objects while in midair
000050EA 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; ''
000050F0                            
000050F0 0828 0003 000C             		btst	#3,_objFlags(a0)			; Is Sonic hanging?
000050F6 6700                       		beq.s	.DoModes			; If not, branch
000050F8 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
000050FC 6000                       		bra.s	.DoCol				; Continue
000050FE                            
000050FE                            .DoModes:
000050FE 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
00005102 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
00005106 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000510A 0C68 1000 001E             		cmpi.w	#$1000,_objYVel(a0)		; Is Sonic moving down too fasr?
00005110 6F00                       		ble.s	.NoCap				; If not, branch
00005112 317C 1000 001E             		move.w	#$1000,_objYVel(a0)		; Cap the downward speed
00005118                            
00005118                            .NoCap:
00005118 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
0000511C                            
0000511C                            .DoCol:
0000511C 0828 0006 0028             		btst	#6,_objStatus(a0)
00005122 6700                       		beq.s	.NoWater
00005124 0468 0028 001E             		subi.w	#$28,_objYVel(a0)
0000512A                            
0000512A                            .NoWater:
0000512A 4EB8 30B2                  		jsr	PlayerChkCollision		; Check for level collision
0000512E 6080                       		bra.s	ObjPlayer_MiscUpdates
00005130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005130                            ; Roll mode
00005130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005130                            ObjPlayer_MdRoll:
00005130 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00005134 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00005138                            
00005138                            .NoJump:
00005138 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
0000513C 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
00005140 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005144 4EB8 372E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00005148                            
00005148 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
0000514C 6000 FF62                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
00005150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005150                            ; Do movement on the ground
00005150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005150                            ObjPlayer_MoveGround:
00005150 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005154 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00005158 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
0000515C                            
0000515C 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00005160 6600 0000                  		bne.w	.ResetScr			; If so, branch
00005164                            
00005164 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left held?
0000516A 6700                       		beq.s	.NotLeft			; If so, branch
0000516C 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
00005170                            
00005170                            .NotLeft:
00005170 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right held?
00005176 6700                       		beq.s	.NotRight			; If so, branch
00005178 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
0000517C                            
0000517C                            .NotRight:
0000517C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005180 0600 0020                  		addi.b	#$20,d0				; Shift it
00005184 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00005188 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
0000518C 4A68 003A                  		tst.w	_objGVel(a0)			; Has Sonic already been halted?
00005190 6600 0000                  		bne.w	.ResetScr			; If not, branch
00005194                            
00005194 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
0000519A 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Set to ducking animation
000051A0                            
000051A0 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is Sonic standing on an object?
000051A6 6700 0000                  		beq.w	.ChkBalance			; If not, branch
000051AA 3268 003C                  		movea.w	_objInteract(a0),a1		; Get interacted object
000051AE 4A29 0028                  		tst.b	_objStatus(a1)			; Is Sonic standing on it?
000051B2 6B00                       		bmi.s	.ChkLookUp			; If not, branch
000051B4 7200                       		moveq	#0,d1
000051B6 1229 002C                  		move.b	_objColW(a1),d1			; Get width of object
000051BA 3401                       		move.w	d1,d2				; Copy it
000051BC D442                       		add.w	d2,d2				; Double the copy
000051BE 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
000051C0 D268 0014                  		add.w	_objXPos(a0),d1			; Add Sonic's X position
000051C4 9269 0014                  		sub.w	_objXPos(a1),d1			; Subtract the object's X position
000051C8 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
000051CC 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
000051CE B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
000051D0 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
000051D2 6000                       		bra.s	.ChkLookUp			; Continue
000051D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051D4                            .ChkBalance:
000051D4 4EB8 341C                  		jsr	PlayerChkFloorDist		; Get floor distance
000051D8 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
000051DC 6D00                       		blt.s	.ChkLookUp			; If not, branch
000051DE 0C28 0003 002E             		cmpi.b	#3,_objNextTilt(a0)		; Is Sonic balancing on the right side?
000051E4 6600                       		bne.s	.ChkLeftBalance			; If not, branch
000051E6                            
000051E6                            .BalanceOnObjRight:
000051E6 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
000051EC 6000                       		bra.s	.SetBalanceAnim			; Set the animation
000051EE                            
000051EE                            .ChkLeftBalance:
000051EE 0C28 0003 002F             		cmpi.b	#3,_objTilt(a0)			; Is Sonic balancing on the left side?
000051F4 6600                       		bne.s	.ChkLookUp			; If not, branch
000051F6                            
000051F6                            .BalanceOnObjLeft:
000051F6 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
000051FC                            
000051FC                            .SetBalanceAnim:
000051FC 117C 0006 0020             		move.b	#6,_objAnim(a0)			; Set balancing animation
00005202 6000                       		bra.s	.ResetScr			; Continue
00005204                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005204                            .ChkLookUp:
00005204 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is the up button being held?
0000520A 6700                       		beq.s	.ChkDown			; If not, branch
0000520C 117C 0007 0020             		move.b	#7,_objAnim(a0)			; Set to looking up animation
00005212                            
00005212 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00005216 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
0000521C 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000521E 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00005224 0C78 00C8 E8D8             		cmpi.w	#200,panCamYPos.w		; Has the camera finished scrolling?
0000522A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000522C 5478 E8D8                  		addq.w	#2,panCamYPos.w		; Scroll the camera
00005230 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00005232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005232                            .ChkDown:
00005232 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is the down button being held?
00005238 6700                       		beq.s	.ResetScr			; If not, branch
0000523A 117C 0008 0020             		move.b	#8,_objAnim(a0)			; Set to ducking animation
00005240                            
00005240 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00005244 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
0000524A 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000524C 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00005252 0C78 0008 E8D8             		cmpi.w	#8,panCamYPos.w		; Has the camera finished scrolling?
00005258 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000525A 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera
0000525E 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00005260                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005260                            .ResetScr:
00005260 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005264                            
00005264                            .ResetScrPart2:
00005264 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
0000526A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000526C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000526E 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005272                            
00005272                            .ScrollUp:
00005272 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005276                            .UpdateSpdOnGround:
00005276 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
0000527A 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000527E 6600                       		bne.s	.ApplySpeed			; If so, branch
00005280                            
00005280 3028 003A                  		move.w	_objGVel(a0),d0			; Get current ground velocity
00005284 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
00005286 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
00005288                            
00005288                            .SettleRight:
00005288 9045                       		sub.w	d5,d0				; Slow down
0000528A 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
0000528C 7000                       		moveq	#0,d0				; Stop the movement
0000528E 6000                       		bra.s	.SetSpeed			; Continue
00005290                            
00005290                            .SettleLeft:
00005290 D045                       		add.w	d5,d0				; Slow down
00005292 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
00005294 7000                       		moveq	#0,d0				; Stop the movement
00005296                            
00005296                            .SetSpeed:
00005296 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000529A                            
0000529A                            .ApplySpeed:
0000529A 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000529E 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
000052A2 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
000052A6 C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
000052AA E081                       		asr.l	#8,d1				; Shift the values over
000052AC E080                       		asr.l	#8,d0				; ''
000052AE 3141 001C                  		move.w	d1,_objXVel(a0)			; Set the X velocity
000052B2 3140 001E                  		move.w	d0,_objYVel(a0)			; Set the Y velocity
000052B6                            
000052B6                            ObjPlayer_CheckWalls:
000052B6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000052BA 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
000052BE 6700                       		beq.s	.Skip				; If not, branch
000052C0 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000052C4 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
000052C8 6B00                       		bmi.s	.End				; If so, branch
000052CA                            
000052CA                            .Skip:
000052CA 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
000052CC 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
000052D0 6700                       		beq.s	.End				; Branch if not moving
000052D2 6B00                       		bmi.s	.CheckPush			; Branch if going left
000052D4 4441                       		neg.w	d1				; Negate the modifier
000052D6                            
000052D6                            .CheckPush:
000052D6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000052DA D001                       		add.b	d1,d0				; Add modifier
000052DC                            		push.w	d0				; Save it
000052DC 3F00                     M 	move.w	d0,-(sp)
000052DE 4EB8 32E4                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
000052E2                            		pop.w	d0				; Restore angle
000052E2 301F                     M 	move.w	(sp)+,d0
000052E4 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
000052E6 6A00                       		bpl.s	.End				; If not, branch
000052E8 E141                       		asl.w	#8,d1				; Shift distance inside the collision
000052EA 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
000052EE 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
000052F2 6700                       		beq.s	.PushCeiling			; If so, branch
000052F4 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
000052F8 6700                       		beq.s	.PushRightWall			; If so, branch
000052FA 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
000052FE 6700                       		beq.s	.PushFloor			; If so, branch
00005300 D368 001C                  		add.w	d1,_objXVel(a0)			; Push out to the right
00005304 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005308 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing right?
0000530E 6600                       		bne.s	.End				; If not, branch
00005310 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00005316 4E75                       		rts
00005318                            
00005318                            .PushFloor:
00005318 9368 001E                  		sub.w	d1,_objYVel(a0)			; Push out upwards
0000531C 4E75                       		rts
0000531E                            
0000531E                            .PushRightWall:
0000531E 9368 001C                  		sub.w	d1,_objXVel(a0)			; Push out to the left
00005322 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005326 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000532C 6700                       		beq.s	.End				; If not, branch
0000532E 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00005334 4E75                       		rts
00005336                            
00005336                            .PushCeiling:
00005336 D368 001E                  		add.w	d1,_objYVel(a0)			; Push out downwards
0000533A                            
0000533A                            .End:
0000533A 4E75                       		rts
0000533C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000533C                            ; Move left on the ground
0000533C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000533C                            ObjPlayer_MoveLeft:
0000533C 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
00005340 6700                       		beq.s	.SetFlip			; If not moving yet, branch
00005342 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
00005344                            
00005344                            .SetFlip:
00005344 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
0000534A 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000534C 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00005352 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00005358                            
00005358                            .MoveLeft:
00005358 9045                       		sub.w	d5,d0				; Subtract acceleration
0000535A 3206                       		move.w	d6,d1				; Get top speed
0000535C 4441                       		neg.w	d1				; Negate it
0000535E B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
00005360 6E00                       		bgt.s	.SetSpeed			; If not, branch
00005362 D045                       		add.w	d5,d0				; Add acceleration back
00005364 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
00005366 6F00                       		ble.s	.SetSpeed			; If not, branch
00005368 3001                       		move.w	d1,d0				; Cap at the top speed
0000536A                            
0000536A                            .SetSpeed:
0000536A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
0000536E 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
00005372                            
00005372                            .End:
00005372 4E75                       		rts
00005374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005374                            .Skid:
00005374 9044                       		sub.w	d4,d0				; Subtract deceleration
00005376 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00005378                            
00005378                            .Compare:
00005378 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000537A 6C00                       		bge.s	.SetSkidSpeed			; If not branch
0000537C 7080                       		moveq	#-$80,d0			; Set speed to -$80
0000537E                            
0000537E                            .SetSkidSpeed:
0000537E 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00005382 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005386 0600 0020                  		addi.b	#$20,d0				; Shift it
0000538A 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000538E 66E2                       		bne.s	.End				; If so, branch
00005390 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
00005394 6DDC                       		blt.s	.End				; If not, branch
00005396 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
0000539C 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
000053A2                            		playSnd	#sSkid, 2			; Play skid sound
000053A2 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
000053A8 4E75                       		rts
000053AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053AA                            ; Move right on the ground
000053AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053AA                            ObjPlayer_MoveRight:
000053AA 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
000053AE 6B00                       		bmi.s	.Skid				; If it's negative, skid
000053B0 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
000053B6 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
000053B8 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
000053BE 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000053C4                            
000053C4                            .MoveRight:
000053C4 D045                       		add.w	d5,d0				; Add acceleration
000053C6 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
000053C8 6D00                       		blt.s	.SetSpeed			; If not, branch
000053CA 9045                       		sub.w	d5,d0				; Subtract acceleration back
000053CC B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
000053CE 6C00                       		bge.s	.SetSpeed			; If not, branch
000053D0 3006                       		move.w	d6,d0				; Cap at top speed
000053D2                            
000053D2                            .SetSpeed:
000053D2 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
000053D6 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
000053DA                            
000053DA                            .End:
000053DA 4E75                       		rts
000053DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053DC                            .Skid:
000053DC D044                       		add.w	d4,d0				; Add deceleration
000053DE 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
000053E0                            
000053E0                            .Compare:
000053E0 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
000053E2 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
000053E4 303C 0080                  		move.w	#$80,d0				; Set speed to $80
000053E8                            
000053E8                            .SetSkidSpeed:
000053E8 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
000053EC 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000053F0 0600 0020                  		addi.b	#$20,d0				; Shift it
000053F4 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
000053F8 66E0                       		bne.s	.End				; If so, branch
000053FA 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
000053FE 6EDA                       		bgt.s	.End				; If not, branch
00005400 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00005406 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
0000540C                            
0000540C 4E75                       		rts
0000540E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000540E                            ; Do movement while rolling
0000540E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000540E                            ObjPlayer_MoveRoll:
0000540E 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005412 E346                       		asl.w	#1,d6				; ''
00005414 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00005418 E245                       		asr.w	#1,d5				; ''
0000541A 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
0000541E E444                       		asr.w	#2,d4				; ''
00005420                            
00005420 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00005424 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
00005428                            
00005428 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
0000542E 6700                       		beq.s	.ChkRight			; If not, branch
00005430 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
00005434                            
00005434                            .ChkRight:
00005434 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
0000543A 6700                       		beq.s	.Decelerate			; If not, branch
0000543C 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
00005440                            
00005440                            .Decelerate:
00005440 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00005444 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
00005446 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
00005448                            
00005448 9045                       		sub.w	d5,d0				; Decelerate
0000544A 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000544C 7000                       		moveq	#0,d0				; Cap at 0
0000544E                            
0000544E                            .SetGVel:
0000544E 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005452 6000                       		bra.s	.ChkStop			; Continue
00005454                            
00005454                            .DecLeft:
00005454 D045                       		add.w	d5,d0				; Decelerate
00005456 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
00005458 7000                       		moveq	#0,d0				; Cap at 0
0000545A                            
0000545A                            .SetGVel2:
0000545A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000545E                            
0000545E                            .ChkStop:
0000545E 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic still moving?
00005462 6600                       		bne.s	.UpdateSpd			; If so, branch
00005464                            
00005464 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
00005468 6600                       		bne.s	.KeepRoll			; If so, branch
0000546A 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Stop rolling
00005470 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005476 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
0000547C 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Use standing animation
00005482                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
00005482 6000                       		bra.s	.UpdateSpd			; Continue
00005484                            
00005484                            .KeepRoll:
00005484 317C 0400 003A             		move.w	#$400,_objGVel(a0)			; Speed up again
0000548A 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing right?
00005490 6700                       		beq.s	.UpdateSpd			; If so, branch
00005492 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005496                            
00005496                            .UpdateSpd:
00005496 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000549A 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
0000549E C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
000054A2 E080                       		asr.l	#8,d0				; Shift over
000054A4 3140 001E                  		move.w	d0,_objYVel(a0)			; Set Y velocity
000054A8 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
000054AC E081                       		asr.l	#8,d1				; Shift over
000054AE                            
000054AE 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
000054B2 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
000054B4 323C 1000                  		move.w	#$1000,d1			; Cap the speed
000054B8                            
000054B8                            .ChkLeftSpd:
000054B8 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
000054BC 6C00                       		bge.s	.SetXVel			; If not, branch
000054BE 323C F000                  		move.w	#-$1000,d1			; Cap the speed
000054C2                            
000054C2                            .SetXVel:
000054C2 3141 001C                  		move.w	d1,_objXVel(a0)			; Set X velocity
000054C6 6000 FDEE                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
000054CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054CA                            ; Handle left movement for rolling
000054CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054CA                            ObjPlayer_RollLeft:
000054CA 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000054CE 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
000054D0 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
000054D2                            
000054D2                            .SetLeft:
000054D2 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
000054D8 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
000054DE 4E75                       		rts
000054E0                            
000054E0                            .Dec:
000054E0 9044                       		sub.w	d4,d0				; Decelerate
000054E2 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000054E4 303C FF80                  		move.w	#-$80,d0			; Set new speed
000054E8                            
000054E8                            .SetGVel:
000054E8 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000054EC 4E75                       		rts
000054EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054EE                            ; Handle left movement for rolling
000054EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054EE                            ObjPlayer_RollRight:
000054EE 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000054F2 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
000054F4 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
000054FA 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
00005500 4E75                       		rts
00005502                            
00005502                            .Dec:
00005502 D044                       		add.w	d4,d0				; Decelerate
00005504 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005506 303C 0080                  		move.w	#$80,d0				; Set new speed
0000550A                            
0000550A                            .SetGVel:
0000550A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000550E 4E75                       		rts
00005510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005510                            ; Do movement in the air
00005510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005510                            ObjPlayer_MoveAir:
00005510 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005514 3A28 0036                  		move.w	_objAccel(a0),d5			; Get accleration
00005518 DA45                       		add.w	d5,d5				; Double it
0000551A 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
0000551E                            
0000551E 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
00005524 6700                       		beq.s	.NotLeft			; If not, branch
00005526 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
0000552C 9045                       		sub.w	d5,d0				; Subtract acceleration
0000552E 3206                       		move.w	d6,d1				; Get top speed
00005530 4441                       		neg.w	d1				; Negate it
00005532 B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
00005534 6E00                       		bgt.s	.NotLeft			; If not, branch
00005536 D045                       		add.w	d5,d0				; Add acceleration back
00005538 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000553A 6F00                       		ble.s	.NotLeft			; If not, branch
0000553C 3001                       		move.w	d1,d0				; Cap at top speed
0000553E                            
0000553E                            .NotLeft:
0000553E 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
00005544 6700                       		beq.s	.NotRight			; If not, branch
00005546 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
0000554C D045                       		add.w	d5,d0				; Add acceleration
0000554E B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00005550 6D00                       		blt.s	.NotRight			; If not, branch
00005552 9045                       		sub.w	d5,d0				; Subtract acceleration back
00005554 B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
00005556 6C00                       		bge.s	.NotRight			; If not, branch
00005558 3006                       		move.w	d6,d0				; Cap at top speed
0000555A                            
0000555A                            .NotRight:
0000555A 3140 001C                  		move.w	d0,_objXVel(a0)			; Set X velocity
0000555E                            
0000555E                            .ResetScr
0000555E 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005564 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
00005566 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005568 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
0000556C                            
0000556C                            .ScrollUp:
0000556C 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005570                            
00005570                            .DecelerateAtPeak:
00005570 0C68 FC00 001E             		cmpi.w	#-$400,_objYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
00005576 6500                       		bcs.s	.End				; If not, branch
00005578 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
0000557C 3200                       		move.w	d0,d1				; Save it
0000557E EA41                       		asr.w	#5,d1				; Turn it into the acceleration
00005580 6700                       		beq.s	.End				; If it's 0, branch
00005582 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
00005584                            
00005584                            .DecRight:
00005584 9041                       		sub.w	d1,d0				; Subtract accleration
00005586 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
00005588 7000                       		moveq	#0,d0				; Cap at 0
0000558A 6000                       		bra.s	.DecSetSpeed			; Continue
0000558C                            
0000558C                            .DecLeft:
0000558C 9041                       		sub.w	d1,d0				; Subtract acceleration
0000558E 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
00005590 7000                       		moveq	#0,d0				; Cap at 0
00005592                            
00005592                            .DecSetSpeed:
00005592 3140 001C                  		move.w	d0,_objXVel(a0)			; Set thhe X velocity
00005596                            
00005596                            .End:
00005596 4E75                       		rts
00005598                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005598                            ; Handle level boundaries
00005598                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005598                            ObjPlayer_LvlBound:
00005598 4A68 001E                  		tst.w	_objYVel(a0)
0000559C 6A00                       		bpl.s	.XBound
0000559E 3228 0018                  		move.w	_objYPos(a0),d1
000055A2 0641 0010                  		addi.w	#$10,d1
000055A6 3038 E8D4                  		move.w	minCamYPos.w,d0		; Get upper boundary position
000055AA B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
000055AC 6F00                       		ble.s	.XBound				; If so, branch
000055AE 3140 0018                  		move.w	d0,_objYPos(a0)
000055B2 4268 001E                  		clr.w	_objYVel(a0)
000055B6 4268 003A                  		clr.w	_objGVel(a0)
000055BA                            
000055BA                            .XBound:
000055BA 2228 0014                  		move.l	_objXPos(a0),d1			; Get X position
000055BE 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
000055C2 48C0                       		ext.l	d0
000055C4 E180                       		asl.l	#8,d0				; Shift it
000055C6 D280                       		add.l	d0,d1				; Add to X position
000055C8 4841                       		swap	d1				; Get actual X position
000055CA 3038 E8D2                  		move.w	minCamXPos.w,d0		; Get left boundary position
000055CE 0640 0010                  		addi.w	#$10,d0				; ''
000055D2 B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
000055D4 6E00                       		bgt.s	.TouchedSide			; If so, branch
000055D6 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Get max camera X position
000055DA 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
000055DE B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
000055E0 6F00                       		ble.s	.TouchedSide			; If so, branch
000055E2                            
000055E2                            .ChkBottom:
000055E2 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
000055E6 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
000055EA B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic touched the bottom boundary?
000055EE 6D00                       		blt.s	.TouchedBottom			; If so, branch
000055F0 4E75                       		rts
000055F2                            
000055F2                            .TouchedBottom:
000055F2 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get target max camera Y position
000055F6 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Get current max camera Y position
000055FA B240                       		cmp.w	d0,d1				; Are they the same?
000055FC 6D00                       		blt.s	.NoKill				; If not, branch
000055FE 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
00005602                            
00005602                            .NoKill:
00005602 4E75                       		rts
00005604                            
00005604                            .TouchedSide:
00005604 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00005608 3140 0014                  		move.w	d0,_objXPos(a0)			; Move Sonic out of the boundary
0000560C 4228 0016                  		clr.b	_objXPos+2(a0)			; Clear the subpixel of the X position
00005610 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
00005614 60CC                       		bra.s	.ChkBottom			; Continue
00005616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005616                            ; Handle peelout
00005616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005616                            ObjPlayer_Peelout:
00005616 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the peelout?
0000561A 6700                       		beq.s	.ChkUp				; If not, branch
0000561C 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000561E 4E75                       		rts
00005620                            
00005620                            .ChkUp:
00005620 0C28 0007 0020             		cmpi.b	#7,_objAnim(a0)			; Is Sonic looking up?
00005626 6600 0000                  		bne.w	.End				; If not, branch
0000562A 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
0000562E 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005632 6700 0000                  		beq.w	.End				; If not, branch
00005636                            
00005636 4228 0020                  		clr.b	_objAnim(a0)			; Set to peelout charge animation
0000563A 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
0000563E 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
00005644 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000564A 6700                       		beq.s	.SetAni				; If so, branch
0000564C 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005650                            
00005650                            .SetAni:
00005650                            		playSnd	#sCharge, 2			; Play charge sound
00005650 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
00005656                            
00005656 588F                       		addq.l	#4,sp				; Don't return to caller
00005658 50E8 0045                  		st	_objDashFlag(a0)			; Set the peelout flag
0000565C 4EF8 372E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005660                            .ChkLaunch:
00005660 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is up being held?
00005666 6600 0000                  		bne.w	.Charge				; If so, branch
0000566A 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
0000566E                            
0000566E 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged up enough?
00005674 6600                       		bne.s	.StopSound			; If not, branch
00005676                            
00005676 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
0000567A 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
00005680 0828 0006 0028             		btst	#6,_objStatus(a0)
00005686 6700                       		beq.s	.NoWater
00005688 E2E8 003A                  		lsr.w	_objGVel(a0)
0000568C                            
0000568C                            .NoWater:
0000568C 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005692 6700                       		beq.s	.FinishDash			; If not, branch
00005694 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005698                            
00005698                            .FinishDash:
00005698                            		playSnd	#sChargeRelease, 2		; Play charge release sound
00005698 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000569E                            
0000569E 6000                       		bra.s	.DoUpdates			; Continue
000056A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056A0                            .Charge:
000056A0 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged enough?
000056A6 6700                       		beq.s	.DoUpdates			; If so, branch
000056A8 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
000056AC 0668 0066 003A             		addi.w	#$66,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
000056B2 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000056B8 6700                       		beq.s	.DoUpdates			; If so, branch
000056BA 0468 00CC 003A             		subi.w	#$66*2,_objGVel(a0)		; Go the other way
000056C0 6000                       		bra.s	.DoUpdates			; Continue
000056C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056C2                            .StopSound:
000056C2 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000056C6                            
000056C6                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000056C6 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000056CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056CC                            .DoUpdates:
000056CC 588F                       		addq.l	#4,sp				; Don't return to caller
000056CE 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000056D4 6700                       		beq.s	.FinishUpdates			; If so, branch
000056D6 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000056D8 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000056DC                            
000056DC                            .ScrollUp:
000056DC 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000056E0                            
000056E0                            .FinishUpdates:
000056E0 4EF8 372E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000056E4                            
000056E4                            .End:
000056E4 4E75                       		rts
000056E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056E6                            ; Handle spindash
000056E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056E6                            ObjPlayer_Spindash:
000056E6 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the spindash?
000056EA 6700                       		beq.s	.ChkDown			; If not, branch
000056EC 6A00                       		bpl.s	.ChkLaunch			; If so, branch
000056EE 4E75                       		rts
000056F0                            
000056F0                            .ChkDown:
000056F0 0C28 0008 0020             		cmpi.b	#8,_objAnim(a0)			; Is Sonic ducking?
000056F6 6600 0000                  		bne.w	.End				; If not, branch
000056FA 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
000056FE 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005702 6700 0000                  		beq.w	.End				; If not, branch
00005706                            
00005706 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
0000570A 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
00005710 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005716 6700                       		beq.s	.SetAni				; If so, branch
00005718 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
0000571C                            
0000571C                            .SetAni:
0000571C 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005722 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005728                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005728 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set to spin animation
0000572E                            
0000572E                            		playSnd	#sCharge, 2			; Play charge sound
0000572E 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
00005734                            
00005734 588F                       		addq.l	#4,sp				; Don't return to caller
00005736 117C 0001 0045             		move.b	#1,_objDashFlag(a0)		; Set the spindash flag
0000573C 4EF8 372E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005740                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005740                            .ChkLaunch:
00005740 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
00005746 6600 0000                  		bne.w	.Charge				; If so, branch
0000574A 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
0000574E                            
0000574E 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged up enough?
00005754 6600                       		bne.s	.StopSound			; If not, branch
00005756                            
00005756 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set the roll flag
0000575C 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
00005762 0828 0006 0028             		btst	#6,_objStatus(a0)
00005768 6700                       		beq.s	.NoWater
0000576A E2E8 003A                  		lsr.w	_objGVel(a0)
0000576E                            
0000576E                            .NoWater:
0000576E 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005774 6700                       		beq.s	.FinishDash			; If not, branch
00005776 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
0000577A                            
0000577A                            .FinishDash:
0000577A                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000577A 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
00005780                            
00005780 6000                       		bra.s	.DoUpdates			; Continue
00005782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005782                            .Charge:
00005782 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged enough?
00005788 6700                       		beq.s	.DoUpdates			; If so, branch
0000578A 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
0000578E 0668 0046 003A             		addi.w	#$46,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
00005794 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000579A 6700                       		beq.s	.DoUpdates			; If so, branch
0000579C 0468 008C 003A             		subi.w	#$46*2,_objGVel(a0)		; Go the other way
000057A2 6000                       		bra.s	.DoUpdates			; Continue
000057A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057A4                            .StopSound:
000057A4 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000057A8 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000057AE 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000057B4                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
000057B4                            
000057B4                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000057B4 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000057BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057BA                            .DoUpdates:
000057BA 588F                       		addq.l	#4,sp				; Don't return to caller
000057BC 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000057C2 6700                       		beq.s	.FinishUpdates			; If so, branch
000057C4 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000057C6 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000057CA                            
000057CA                            .ScrollUp:
000057CA 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000057CE                            
000057CE                            .FinishUpdates:
000057CE 4EF8 372E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000057D2                            
000057D2                            .End:
000057D2 4E75                       		rts
000057D4                            		
000057D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057D4                            ; Check for fire attack
000057D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057D4                            ObjPlayer_ChkAttack:
000057D4 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
000057D8 0200 0010                  		andi.b	#$10,d0				; Are B pressed?
000057DC 4A00                       		tst.b	d0
000057DE 6700 0000                  		beq.w	.End				; If not, branch
000057E2                            		
000057E2 4EB8 1A1C                  		jsr	FindFreeObj.w
000057E6 6700                       		beq.s	.End
000057E8 22BC 0000 0000             		move.l	#ObjAttack,_objAddress(a1)
000057EE 137C 001E 0017             		move.b	#30,_objDrawW(a1)
000057F4 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000057FA 6700                       		beq.s	.cont			; If so, branch
000057FC 337C 0001 0024             		move.w	#1,	_objSubtype(a1)
00005802                            	.cont:
00005802 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005808 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
0000580E                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0000580E 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00005814                            		
00005814                            .End:
00005814 4E75                       		rts
00005816                            		
00005816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005816                            ; Check for jumping
00005816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005816                            ObjPlayer_ChkJump:
00005816 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
0000581A 0200 0020                  		andi.b	#$20,d0				; Are C pressed?
0000581E 4A38 C76A                  		tst.b	moveCheat.w
00005822 6700                       		beq.s	.NoDebug
00005824 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
00005828                            
00005828                            .NoDebug:
00005828 4A00                       		tst.b	d0
0000582A 6700 0000                  		beq.w	.End				; If not, branch
0000582E                            
0000582E 7000                       		moveq	#0,d0
00005830 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005834 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
00005838 4EB8 3356                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000583C 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
00005840 6D00 0000                  		blt.w	.End				; If not, branch
00005844                            
00005844 343C 0180                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
00005848 0828 0006 0028             		btst	#6,_objStatus(a0)
0000584E 6700                       		beq.s	.NoWater
00005850 0442 0300                  		subi.w	#$300,d2
00005854                            
00005854                            .NoWater:
00005854 7000                       		moveq	#0,d0
00005856 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000585A 0400 0040                  		subi.b	#$40,d0				; Shift it
0000585E 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
00005862 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
00005864 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
00005866 E081                       		asr.l	#8,d1				; Shift the values over
00005868 E080                       		asr.l	#8,d0				; ''
0000586A D368 001C                  		add.w	d1,_objXVel(a0)			; Add to X velocity
0000586E D168 001E                  		add.w	d0,_objYVel(a0)			; Add to Y velocity
00005872 0028 0006 0028             		ori.b	#6,_objStatus(a0)			; Set "in air" and roll flags
00005878 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
0000587E 584F                       		addq.w	#4,sp				; Do not return to collaer
00005880 50E8 0040                  		st	_objJumping(a0)			; Set the jumping flag
00005884                            		playSnd	#sLeap, 2			; Play jump sound
00005884 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
0000588A 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005890 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005896                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005896 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set jumping animation
0000589C                            
0000589C                            .End:
0000589C 4E75                       		rts
0000589E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000589E                            ; Handle variable jumping
0000589E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000589E                            ObjPlayer_JumpHeight:
0000589E                            	;	tst.b	_objJumping(a0)			; Is Sonic jumping?
0000589E                            	;	beq.s	.UpVelCap			; If not, branch
0000589E                            
0000589E 323C FE80                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
000058A2 B268 001E                  		cmp.w	_objYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
000058A6 6F00                       		ble.s	.End				; If not, branch
000058A8 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
000058AC 0200 0020                  		andi.b	#$20,d0				; Are A, B, or C pressed?
000058B0 4A38 C76A                  		tst.b	moveCheat.w
000058B4 6700                       		beq.s	.NoDebug
000058B6 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
000058BA                            
000058BA                            .NoDebug:
000058BA 4A00                       		tst.b	d0
000058BC 6600                       		bne.s	.End				; If not, branch
000058BE 3141 001E                  		move.w	d1,_objYVel(a0)			; Set to minimum height
000058C2                            
000058C2                            .End:
000058C2 4E75                       		rts
000058C4                            
000058C4                            .UpVelCap:
000058C4 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000058C8 66F8                       		bne.s	.End				; If so, branch
000058CA 0C68 F040 001E             		cmpi.w	#-$FC0,_objYVel(a0)		; Cap Y velocity at -$FC0 when going up
000058D0 6CF0                       		bge.s	.End				; ''
000058D2 317C F040 001E             		move.w	#-$FC0,_objYVel(a0)		; ''
000058D8 4E75                       		rts
000058DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058DA                            ; Gradually reset Sonic's angle in mid air
000058DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058DA                            ObjPlayer_JumpAngle:
000058DA 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000058DE 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
000058E0 6A00                       		bpl.s	.Decrease			; If it's positive, branch
000058E2                            
000058E2                            .Increase:
000058E2 5400                       		addq.b	#2,d0				; Increase angle
000058E4 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
000058E6 7000                       		moveq	#0,d0				; Reset the angle
000058E8 6000                       		bra.s	.SetAngle
000058EA                            
000058EA                            .Decrease:
000058EA 5500                       		subq.b	#2,d0				; Decrease angle
000058EC 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
000058EE 7000                       		moveq	#0,d0				; Reset the angle
000058F0                            
000058F0                            .SetAngle:
000058F0 1140 0041                  		move.b	d0,_objAngle(a0)			; Set the new angle
000058F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058F4                            ; Update Sonic's angle while he's tumbling in the air
000058F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058F4                            ObjPlayer_JumpFlip:
000058F4 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
000058F8 6700                       		beq.s	.End				; If it's 0, branch
000058FA 4A68 003A                  		tst.w	_objFlipDir(a0)			; Is Sonic flipping left?
000058FE 6B00                       		bmi.s	.FlipLeft			; IF so, branch
00005900                            
00005900                            .FlipRight:
00005900 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005904 D001                       		add.b	d1,d0				; Add to angle
00005906 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005908 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
0000590C 6400                       		bcc.s	.FlipSet			; If there are still some left
0000590E 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
00005912 7000                       		moveq	#0,d0				; Reset angle
00005914 6000                       		bra.s	.FlipSet			; Continue
00005916                            
00005916                            .FlipLeft:
00005916 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is the flipping inverted?
0000591A 66E4                       		bne.s	.FlipRight			; If so, branch
0000591C 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005920 9001                       		sub.b	d1,d0				; Subtract from angle
00005922 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005924 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
00005928 6400                       		bcc.s	.FlipSet			; If there are still some left
0000592A 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
0000592E 7000                       		moveq	#0,d0				; Reset angle
00005930                            
00005930                            .FlipSet:
00005930 1140 0047                  		move.b	d0,_objFlipAngle(a0)		; Update the angle
00005934                            
00005934                            .End:
00005934 4E75                       		rts
00005936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005936                            ; Check for rolling
00005936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005936                            ObjPlayer_ChkRoll:
00005936 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
0000593A 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000593C 4440                       		neg.w	d0				; ''
0000593E                            
0000593E                            .ChkSpd:
0000593E 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
00005942 6500                       		bcs.s	.NoRoll				; If not, branch
00005944 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
00005948 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000594C 6600                       		bne.s	.NoRoll				; If not, branch
0000594E 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
00005954 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
00005956                            
00005956                            .NoRoll:
00005956 4E75                       		rts
00005958                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005958                            ; Make Sonic roll
00005958                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005958                            ObjPlayer_DoRoll:
00005958 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
0000595E 6600                       		bne.s	.End				; If so, branch
00005960 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005966                            
00005966 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
0000596C 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005972                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005972 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005978                            
00005978 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving already?
0000597C 6600                       		bne.s	.End				; IF not, branch
0000597E 317C 0200 003A             		move.w	#$200,_objGVel(a0)			; Set speed
00005984                            
00005984                            .End:
00005984 4E75                       		rts
00005986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005986                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
00005986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005986                            ObjPlayer_SlopePush:
00005986 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000598A 0600 0060                  		addi.b	#$60,d0				; Shift it
0000598E 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
00005992 6400                       		bcc.s	.End				; If not, branch
00005994 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005998 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
0000599C C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
000059A0 E080                       		asr.l	#8,d0				; Shift it
000059A2 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
000059A6 6700                       		beq.s	.End				; If Sonic is not moving, branch
000059A8 D168 003A                  		add.w	d0,_objGVel(a0)			; Add to ground velocity
000059AC                            
000059AC                            .End:
000059AC 4E75                       		rts
000059AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059AE                            ; Check if Sonic is to fall off a slope
000059AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059AE                            ObjPlayer_FallOffSlope:
000059AE 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer, active?
000059B2 6600                       		bne.s	.End				; If so, branch
000059B4 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000059B8 0600 0020                  		addi.b	#$20,d0				; Shift it
000059BC 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000059C0 6700                       		beq.s	.End				; If Sonic is on the floor, branch
000059C2 3028 003A                  		move.w	_objGVel(a0),d0			; Get speed
000059C6 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
000059C8 4440                       		neg.w	d0				; Force it to be positive
000059CA                            
000059CA                            .ChkSpeed:
000059CA 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
000059CE 6400                       		bcc.s	.End				; If so, branch
000059D0 4268 003A                  		clr.w	_objGVel(a0)			; Stop movement
000059D4 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000059DA 117C 001E 003F             		move.b	#$1E,_objMoveLock(a0)		; Set move lock timer
000059E0                            
000059E0                            .End:
000059E0 4E75                       		rts
000059E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059E2                            ; Affect Sonic's speed on slopes while rolling
000059E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059E2                            ObjPlayer_RollSlopePush:
000059E2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000059E6 0600 0060                  		addi.b	#$60,d0				; ''
000059EA 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
000059EE 6400                       		bcc.s	.End				; If not, branch
000059F0                            
000059F0 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000059F4 4EB8 1374                  		jsr	CalcSine.w			; Get sine
000059F8 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
000059FC E080                       		asr.l	#8,d0				; Shift over
000059FE                            
000059FE 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00005A02 6B00                       		bmi.s	.PushLeft			; If not, branch
00005A04 4A40                       		tst.w	d0				; Is the push speed positive?
00005A06 6A00                       		bpl.s	.Push				; If so, branch
00005A08 E480                       		asr.l	#2,d0				; Shift over more
00005A0A                            
00005A0A                            .Push:
00005A0A D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
00005A0E 4E75                       		rts
00005A10                            
00005A10                            .PushLeft:
00005A10 4A40                       		tst.w	d0				; Is the push speed negative?
00005A12 6B00                       		bmi.s	.Push2				; If so, branch
00005A14 E480                       		asr.l	#2,d0				; Shift over more
00005A16                            
00005A16                            .Push2:
00005A16 D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
00005A1A                            
00005A1A                            .End:
00005A1A 4E75                       		rts
00005A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A1C                            ; Check for bouncy floor collision
00005A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A1C                            ObjPlayer_ChkBounce:
00005A1C 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00005A20 6700 0000                  		beq.w	.End				; If so, branch
00005A24                            
00005A24 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic in the air?
00005A2A 6700                       		beq.s	.ChkDown			; If not, branch
00005A2C                            
00005A2C 4A68 001E                  		tst.w	_objYVel(a0)			; Is Sonic falling?
00005A30 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
00005A34 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
00005A38                            
00005A38                            .ChkDown:
00005A38 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
00005A3C 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A40 4880                       		ext.w	d0				; ''
00005A42 D440                       		add.w	d0,d2				; ''
00005A44 5442                       		addq.w	#2,d2				; ''
00005A46 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
00005A4A 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A4E 4880                       		ext.w	d0				; ''
00005A50 9640                       		sub.w	d0,d3				; ''
00005A52 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005A56 3011                       		move.w	(a1),d0				; ''
00005A58 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A5C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A60 6700                       		beq.s	.Bounce				; If so, branch
00005A62                            
00005A62 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
00005A66 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A6A 4880                       		ext.w	d0				; ''
00005A6C D440                       		add.w	d0,d2				; ''
00005A6E 5442                       		addq.w	#2,d2				; ''
00005A70 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
00005A74 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A78 4880                       		ext.w	d0				; ''
00005A7A D640                       		add.w	d0,d3				; ''
00005A7C 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005A80 3011                       		move.w	(a1),d0				; ''
00005A82 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A86 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A8A 6600                       		bne.s	.End				; If not, branch
00005A8C                            
00005A8C                            .Bounce:
00005A8C 317C EA00 001E             		move.w	#-$1600,_objYVel(a0)		; Bounce Sonic up
00005A92 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005A98 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005A9C 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005AA0 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005AA4                            
00005AA4                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005AA4 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005AAA                            
00005AAA 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005AB0 6600                       		bne.s	.End				; If so, branch
00005AB2 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005AB8 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005ABE 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005AC4                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005AC4 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005ACA                            
00005ACA                            .End:
00005ACA 4E75                       		rts
00005ACC                            
00005ACC                            .ChkBounceUp:
00005ACC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
00005AD0 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005AD4 4880                       		ext.w	d0				; ''
00005AD6 9440                       		sub.w	d0,d2				; ''
00005AD8 5542                       		subq.w	#2,d2				; ''
00005ADA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
00005ADE 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005AE2 4880                       		ext.w	d0				; ''
00005AE4 9640                       		sub.w	d0,d3				; ''
00005AE6 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005AEA 3011                       		move.w	(a1),d0				; ''
00005AEC 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005AF0 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005AF4 6700                       		beq.s	.BounceUp			; If so, branch
00005AF6                            
00005AF6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
00005AFA 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005AFE 4880                       		ext.w	d0				; ''
00005B00 9440                       		sub.w	d0,d2				; ''
00005B02 5542                       		subq.w	#2,d2				; ''
00005B04 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
00005B08 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005B0C 4880                       		ext.w	d0				; ''
00005B0E D640                       		add.w	d0,d3				; ''
00005B10 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005B14 3011                       		move.w	(a1),d0				; ''
00005B16 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005B1A 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005B1E 66AA                       		bne.s	.End				; If not, branch
00005B20                            
00005B20                            .BounceUp:
00005B20 588F                       		addq.l	#4,sp				; Don't return to caller
00005B22                            
00005B22 317C 1600 001E             		move.w	#$1600,_objYVel(a0)		; Bounce Sonic up
00005B28 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005B2E 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005B32 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005B36 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005B3A                            
00005B3A                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005B3A 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005B40                            
00005B40 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005B46 6600                       		bne.s	.End2				; If so, branch
00005B48 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005B4E 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005B54 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005B5A                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005B5A 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005B60                            
00005B60                            .End2:
00005B60 4E75                       		rts
00005B62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B62                            ; Check for bars to hang on to
00005B62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B62                            ObjPlayer_ChkHang:
00005B62 0828 0003 000C             		btst	#3,_objFlags(a0)			; Are we already hanging?
00005B68 6600                       		bne.s	.End				; If so, branch
00005B6A                            
00005B6A 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005B6E 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005B72 0442 0018                  		subi.w	#$18,d2				; ''
00005B76 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005B7A 3011                       		move.w	(a1),d0				; ''
00005B7C 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005B80 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005B84 6600                       		bne.s	.End				; If not, branch
00005B86                            
00005B86 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00005B8C 42A8 001C                  		clr.l	_objXVel(a0)			; Stop movement
00005B90 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005B94 08E8 0003 000C             		bset	#3,_objFlags(a0)			; Set hanging flag
00005B9A 117C 000A 0020             		move.b	#$A,_objAnim(a0)			; Set hanging animation
00005BA0 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Animation timer
00005BA6                            	;	move.w	_objYPos(a0),d0			; Align with bar
00005BA6 0440 0018                  		subi.w	#$18,d0				; ''
00005BAA 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
00005BAE 0640 0018                  		addi.w	#$18,d0				; ''
00005BB2 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00005BB6 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00005BBA 08A8 0001 000D             		bclr	#1,_objRender(a0)			; ''
00005BC0                            
00005BC0                            .End:
00005BC0 4E75                       		rts
00005BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BC2                            ; Hang onto the bars
00005BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BC2                            ObjPlayer_Hang:
00005BC2 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005BC6 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005BCA 0442 0018                  		subi.w	#$18,d2				; ''
00005BCE 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005BD2 3011                       		move.w	(a1),d0				; ''
00005BD4 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005BD8 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005BDC 6600                       		bne.s	.FallOff			; If not, branch
00005BDE 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get control press bits
00005BE2 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
00005BE6 6700                       		beq.s	.MoveX				; If not, branch
00005BE8                            
00005BE8                            .FallOff:
00005BE8 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005BEE 0668 0010 0018             		addi.w	#$10,_objYPos(a0)			; Fall off
00005BF4 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005BFA 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005C00 4E75                       		rts
00005C02                            
00005C02                            .MoveX:
00005C02 7002                       		moveq	#2,d0				; X speed
00005C04 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Are we going left?
00005C0A 6700                       		beq.s	.ChkRight			; If not, branch
00005C0C 4440                       		neg.w	d0				; Go the other way
00005C0E 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face to the left
00005C14 08E8 0000 000D             		bset	#0,_objRender(a0)			; ''
00005C1A 6000                       		bra.s	.DoMove				; Continue
00005C1C                            
00005C1C                            .ChkRight:
00005C1C 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Are we going left?
00005C22 6700                       		beq.s	.ResetScr			; If not, branch
00005C24 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face to the right
00005C2A 08A8 0000 000D             		bclr	#0,_objRender(a0)			; ''
00005C30                            
00005C30                            .DoMove:
00005C30 D168 0014                  		add.w	d0,_objXPos(a0)			; Move
00005C34 5328 004C                  		subq.b	#1,_objHangAniTime(a0)		; Decrement animation timer
00005C38 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
00005C3A 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Reset timer
00005C40 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Increment animation frame
00005C44 0C28 0004 0022             		cmpi.b	#4,_objAnimFrame(a0)		; Have we reached the last one?
00005C4A 6500                       		bcs.s	.ResetScr			; If not, branch
00005C4C 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation frame
00005C50                            
00005C50                            .ResetScr:
00005C50 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005C54 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005C5A 6700                       		beq.s	.End				; If so, branch
00005C5C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005C5E 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005C62                            
00005C62                            .ScrollUp:
00005C62 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005C66                            
00005C66                            .End:
00005C66 4E75                       		rts
00005C68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C68                            ; Check for electricity
00005C68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C68                            ObjPlayer_ChkElectric:
00005C68 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005C6C 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005C70 4EB8 3CBE                  		jsr	Level_FindBlock			; Get the block located there
00005C74 3011                       		move.w	(a1),d0				; ''
00005C76 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005C7A                            
00005C7A 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
00005C7E 7C02                       		moveq	#2,d6				; ''
00005C80                            
00005C80                            .ChkBlocks:
00005C80 B059                       		cmp.w	(a1)+,d0			; have we touched this block?
00005C82 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
00005C84 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
00005C88 4E75                       		rts
00005C8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C8A 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
00005C90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C90                            ; Get Sonic hurt
00005C90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C90                            ObjPlayer_GetHurt:
00005C90                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005C90 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005C94 6600                     M 	bne.s	.no_228
00005C96 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005C9C 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005CA0 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005CA4 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005CA8 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005CAC                          M .no_228
00005CAC 4A28 0042                  		tst.b	_objInvulTime(a0)			; Are we invulnerable?
00005CB0 6600 0000                  		bne.w	.End				; If so, branch
00005CB4 4A78 E85E                  		tst.w	ringCount.w			; Does Sonic have any rings?
00005CB8 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
00005CBC 4EB8 1A1C                  		jsr	FindFreeObj.w
00005CC0 6700                       		beq.s	.Hurt
00005CC2 22BC 0000 0000             		move.l	#ObjRingLoss,_objAddress(a1)
00005CC8 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005CCE 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
00005CD4                            
00005CD4                            .Hurt:
00005CD4 117C 0008 0025             		move.b	#8,_objRoutine(a0)			; Set to hurt routine
00005CDA 4EB8 32AE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005CDE 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005CE2 08A8 0000 000C             		bclr	#0,_objFlags(a0)			; Allow modes
00005CE8 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005CEE 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005CF4 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Set to hurt animation
00005CFA 117C 0078 0042             		move.b	#$78,_objInvulTime(a0)		; Set invulnerable timer
00005D00                            
00005D00 317C FC00 001E             		move.w	#-$400,_objYVel(a0)		; Make Sonic bounce away
00005D06 317C FE00 001C             		move.w	#-$200,_objXVel(a0)		; ''
00005D0C 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005D12 6700                       		beq.s	.ChkReverse			; If not, branch
00005D14 317C FE00 001E             		move.w	#-$200,_objYVel(a0)		; Make Sonic bounce away slower
00005D1A 317C FF00 001C             		move.w	#-$100,_objXVel(a0)
00005D20                            
00005D20                            .ChkReverse:
00005D20 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00005D24 B06A 0014                  		cmp.w	_objXPos(a2),d0			; Is Sonic left of the object that hurt him?
00005D28 6500                       		bcs.s	.ChkSnd				; If so, branch
00005D2A 4468 001C                  		neg.w	_objXVel(a0)			; Make Sonic bounce the other way if on the right side
00005D2E                            
00005D2E                            .ChkSnd:
00005D2E 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00005D32                            
00005D32                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005D32                            	;	beq.s	.End				; If not, branch
00005D32                            		playSnd	#sHurt, 2			; Play hurt sound
00005D32 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
00005D38                            
00005D38                            .End:
00005D38 70FF                       		moveq	#-1,d0				; Set return status
00005D3A 4E75                       		rts
00005D3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D3C                            ; Hurt routine
00005D3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D3C                            ObjPlayer_Hurt:
00005D3C 4A38 C76A                  		tst.b	moveCheat.w
00005D40 6700                       		beq.s	.NoPlacementEnter
00005D42 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005D48 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005D4A 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005D50 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005D56 4E75                       		rts
00005D58                            
00005D58                            .NoPlacementEnter:
00005D58 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005D5C 0668 0030 001E             		addi.w	#$30,_objYVel(a0)			; Apply gravity
00005D62 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005D68 6700                       		beq.s	.NotWater			; If not, branch
00005D6A 0468 0020 001E             		subi.w	#$20,_objYVel(a0)			; Reduce gravity underwater
00005D70                            
00005D70                            .NotWater:
00005D70 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Force the hurt animation
00005D76 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
00005D78                            
00005D78 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005D7E 6700                       		beq.s	.Cont				; If so, branch
00005D80 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005D82 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005D86                            
00005D86                            .ScrollUp:
00005D86 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005D8A                            
00005D8A                            .Cont:
00005D8A 6100 F80C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00005D8E 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005D92 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005D96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D96                            .ChkStop:
00005D96 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005D9A 0640 00E0                  		addi.w	#224,d0				; ''
00005D9E B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005DA2 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
00005DA4                            
00005DA4 4EB8 30B2                  		jsr	PlayerChkCollision		; Check for level collision
00005DA8 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic still in midair?
00005DAE 6600                       		bne.s	.End				; If so, branch
00005DB0                            
00005DB0 7000                       		moveq	#0,d0
00005DB2 3140 001E                  		move.w	d0,_objYVel(a0)			; Stop Sonic's movement
00005DB6 3140 001C                  		move.w	d0,_objXVel(a0)			; ''
00005DBA 3140 003A                  		move.w	d0,_objGVel(a0)			; ''
00005DBE 1140 000C                  		move.b	d0,_objFlags(a0)			; Allow Sonic to move
00005DC2 1140 0020                  		move.b	d0,_objAnim(a0)			; Reset animation
00005DC6 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set back to main routine
00005DCC                            
00005DCC                            .End:
00005DCC 4E75                       		rts
00005DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DCE                            ; Get Sonic killed
00005DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DCE                            ObjPlayer_GetKilled:
00005DCE                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005DCE 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005DD2 6600                     M 	bne.s	.no_230
00005DD4 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005DDA 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005DDE 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005DE2 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005DE6 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005DEA                          M .no_230
00005DEA 117C 000C 0025             		move.b	#$C,_objRoutine(a0)			; Set to the death routine
00005DF0 4EB8 32AE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005DF4 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005DF8 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005DFE 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Set to death animation
00005E04                            
00005E04 317C F900 001E             		move.w	#-$700,_objYVel(a0)		; Make Sonic bounce up
00005E0A 4268 001C                  		clr.w	_objXVel(a0)			; Lock Sonic horizontally
00005E0E 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005E12 31FC FFFF E8DA             		move.w	#$FFFF,camLocked.w		; Lock the camera
00005E18                            
00005E18                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005E18                            	;	beq.s	.End				; If not, branch
00005E18                            		playSnd	#sDeath,2			; Play death sound
00005E18 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
00005E1E                            
00005E1E                            .End:
00005E1E 70FF                       		moveq	#-1,d0				; Set return status
00005E20 4E75                       		rts
00005E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E22                            ; Death routine
00005E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E22                            ObjPlayer_Dead:
00005E22 4A38 C76A                  		tst.b	moveCheat.w
00005E26 6700                       		beq.s	.NoPlacementEnter
00005E28 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005E2E 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005E30 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005E36 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005E3C 4E75                       		rts
00005E3E                            
00005E3E                            .NoPlacementEnter:
00005E3E 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Force the death animation
00005E44 0068 8000 000E             		ori.w	#$8000,_objVRAM(a0)		; Force high priority
00005E4A 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
00005E4C 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005E50 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005E54 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005E58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E58                            ObjPlayer_ChkBound:
00005E58 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005E5C 0640 0100                  		addi.w	#$100,d0			; ''
00005E60 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005E64 6C00                       		bge.s	.End				; If not, branch
00005E66                            
00005E66 117C 0010 0025             		move.b	#$10,_objRoutine(a0)			; Go to gone routine
00005E6C 117C 003C 0043             		move.b	#60,_objDeathTimer(a0)		; Set death timer to 1 second
00005E72                            
00005E72                            .End:
00005E72 4E75                       		rts
00005E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E74                            ; Wait for level reload or game/time over
00005E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E74                            ObjPlayer_Gone:
00005E74 4A28 0043                  		tst.b	_objDeathTimer(a0)
00005E78 6700                       		beq.s	.End
00005E7A 5328 0043                  		subq.b	#1,_objDeathTimer(a0)		; Decrement the death counter
00005E7E 6600                       		bne.s	.End				; If it hasn't run out, branch
00005E80 50F8 E906                  		st	lvlReload.w			; Reload the level
00005E84                            
00005E84                            .End:
00005E84 4E75                       		rts
00005E86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E86                            ; Display Sonic's sprite
00005E86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E86                            ObjPlayer_Display:
00005E86 1028 0042                  		move.b	_objInvulTime(a0),d0		; Get invulnerability timer
00005E8A 6700                       		beq.s	.Display			; If it's 0, branch
00005E8C 5328 0042                  		subq.b	#1,_objInvulTime(a0)		; Decrement invulnerability timer
00005E90 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
00005E92 6500                       		bcs.s	.Display			; If so, branch
00005E94                            	removeSprite	a0,a1,1				; Remove sprite if displayed
00005E94 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005E98 6700                     M 	beq.s	.yes_232
00005E9A 3268 000A                M 	move.w	_objdrawprev(a0),a1
00005E9E 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00005EA4 3268 0008                M 	move.w	_objdrawnext(a0),a1
00005EA8 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00005EAE                          M .no_232
00005EAE 42A8 0008                M 	clr.l	_objdrawnext(a0)
00005EB2                          M .yes_232
00005EB2 4E75                       		rts
00005EB4                            
00005EB4                            .Display:
00005EB4                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
00005EB4 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005EB8 6600                     M 	bne.s	.no_233
00005EBA 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005EC0 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005EC4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005EC8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005ECC 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005ED0                          M .no_233
00005ED0 4E75                       		rts
00005ED2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ED2                            ; Load Sonic's DPLCs
00005ED2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ED2                            ObjPlayer_LoadDPLCs:
00005ED2 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
00005ED8 383C F000                  		move.w	#$F000,d4			; VRAM location
00005EDC 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
00005EE2 4EF8 1CE8                  		jmp	LoadObjDPLCs.w			; Load DPLCs
00005EE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EE6                            ; Animate Sonic's sprite
00005EE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EE6                            ObjPlayer_Animate:
00005EE6 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
00005EEC 7000                       		moveq	#0,d0
00005EEE 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00005EF2 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00005EF6 6700                       		beq.s	.Run				; If not, branch
00005EF8 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00005EFC 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005F00 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005F04 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00005F0A                            
00005F0A                            .Run:
00005F0A D040                       		add.w	d0,d0				; Turn ID into offset
00005F0C D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00005F10 1011                       		move.b	(a1),d0				; Get first byte
00005F12 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
00005F14 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005F18 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
00005F1C 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00005F22 8328 000D                  		or.b	d1,_objRender(a0)			; Set flip bits
00005F26 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005F2A 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00005F2C 1140 0023                  		move.b	d0,_objAnimTimer(a0)		; Set new animation timer
00005F30                            
00005F30                            .GetFrame:
00005F30 7200                       		moveq	#0,d1
00005F32 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00005F36 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00005F3A 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
00005F3E 6400                       		bhs.s	.CmdReset			; If so, branch
00005F40                            
00005F40                            .Next:
00005F40 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00005F44 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00005F48                            
00005F48                            .Wait:
00005F48 4E75                       		rts
00005F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F4A                            .CmdReset:
00005F4A 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00005F4C 6600                       		bne.s	.CmdJump			; If not, branch
00005F4E 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005F52 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00005F56 60E8                       		bra.s	.Next				; Continue
00005F58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F58                            .CmdJump:
00005F58 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00005F5A 6600                       		bne.s	.CmdSetAnim			; If not, branch
00005F5C 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00005F60 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00005F64 9200                       		sub.b	d0,d1				; ''
00005F66 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00005F6A 60D4                       		bra.s	.Next				; Continue
00005F6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F6C                            .CmdSetAnim:
00005F6C 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00005F6E 6600                       		bne.s	.CmdEnd				; If not, branch
00005F70 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00005F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F76                            .CmdEnd:
00005F76 4E75                       		rts
00005F78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F78                            .WalkRunAnim:
00005F78 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005F7C 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
00005F7E 5200                       		addq.b	#1,d0				; Is the animation walking/running?
00005F80 6600 0000                  		bne.w	.RollAnim			; If not, branch
00005F84                            
00005F84 7000                       		moveq	#0,d0
00005F86 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Is Sonic tumbling in the air?
00005F8A 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
00005F8E                            
00005F8E 7200                       		moveq	#0,d1				; Intial flip bits
00005F90 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005F94 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
00005F96 6700                       		beq.s	.ChkStatus			; If it's zero, branch
00005F98 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
00005F9A                            
00005F9A                            .ChkStatus:
00005F9A 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005F9E 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
00005FA2 6600                       		bne.s	.ChkFlip			; If so, branch
00005FA4 4600                       		not.b	d0				; Reverse angle
00005FA6                            
00005FA6                            .ChkFlip:
00005FA6 0600 0010                  		addi.b	#$10,d0				; Shift angle
00005FAA 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
00005FAC 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
00005FAE                            
00005FAE                            .SetFlags:
00005FAE 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits
00005FB4 B302                       		eor.b	d1,d2				; Flip
00005FB6 8528 000D                  		or.b	d2,_objRender(a0)			; Set in render flags
00005FBA                            
00005FBA 0828 0005 0028             		btst	#5,_objStatus(a0)			; Is Sonic pushing?
00005FC0 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
00005FC4                            
00005FC4 E808                       		lsr.b	#4,d0				; Divide angle by $10
00005FC6 0200 0006                  		andi.b	#6,d0				; Get angle section
00005FCA                            
00005FCA 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005FCE 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
00005FD0 4442                       		neg.w	d2				; Force it to be positive
00005FD2                            
00005FD2                            .GetAnim:
00005FD2 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
00005FD8 4A00                       		tst.b	d0
00005FDA 6600                       		bne.s	.ChkRun
00005FDC 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
00005FE0 6400                       		bcc.s	.SkipWalk			; If so, branch
00005FE2                            
00005FE2                            .ChkRun:
00005FE2 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
00005FE8 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
00005FEC 6400                       		bcc.s	.SkipWalk			; If so, branch
00005FEE 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
00005FF4 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
00005FF6 E209                       		lsr.b	#1,d1				; ''
00005FF8 D001                       		add.b	d1,d0				; ''
00005FFA                            
00005FFA                            .SkipWalk:
00005FFA D000                       		add.b	d0,d0				; Double the offset
00005FFC 1600                       		move.b	d0,d3				; Copy the oofset
00005FFE 4442                       		neg.w	d2				; Get animation speed
00006000 0642 0800                  		addi.w	#$800,d2			; ''
00006004 6A00                       		bpl.s	.SetTimer			; ''
00006006 7400                       		moveq	#0,d2				; ''
00006008                            
00006008                            .SetTimer:
00006008 E04A                       		lsr.w	#8,d2				; ''
0000600A 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
0000600E 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
00006012 D728 0010                  		add.b	d3,_objFrame(a0)			; Add angle offset
00006016 4E75                       		rts
00006018                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006018                            .TumbleAnim:
00006018 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
0000601C 7200                       		moveq	#0,d1
0000601E 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00006022 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
00006026 6600                       		bne.s	.TumbleLeft			; If so, branch
00006028                            
00006028 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
0000602E 0600 000B                  		addi.b	#$B,d0				; Get map frame
00006032 80FC 0016                  		divu.w	#$16,d0				; ''
00006036 0600 0068                  		addi.b	#$68,d0				; ''
0000603A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
0000603E 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00006042 4E75                       		rts
00006044                            
00006044                            .TumbleLeft:
00006044 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
0000604A 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is flipping inverted?
0000604E 6700                       		beq.s	.NotInverted			; If not, branch
00006050 0028 0001 000D             		ori.b	#1,_objRender(a0)			; Face left
00006056 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000605A 6000                       		bra.s	.SetLeftFrame			; Continue
0000605C                            
0000605C                            .NotInverted:
0000605C 0028 0003 000D             		ori.b	#3,_objRender(a0)			; Face left and be upside down
00006062 4400                       		neg.b	d0				; Get map frame
00006064 0600 008F                  		addi.b	#$8F,d0				; ''
00006068                            
00006068                            .SetLeftFrame:
00006068 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
0000606C 0600 0068                  		addi.b	#$68,d0				; ''
00006070 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00006074 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00006078 4E75                       		rts
0000607A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000607A                            .RollAnim:
0000607A 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000607C 6600                       		bne.s	.PushAnim			; If not, branch
0000607E                            
0000607E 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00006082 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
00006084 4442                       		neg.w	d2				; Force it to be negative
00006086                            
00006086                            .GetAnim2:
00006086 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
0000608C 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
00006090 6400                       		bcc.s	.PrepareTimer			; If so, branch
00006092 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
00006098                            
00006098                            .PrepareTimer:
00006098 4442                       		neg.w	d2				; Get animation speed
0000609A 0642 0400                  		addi.w	#$400,d2			; ''
0000609E 6A00                       		bpl.s	.SetTimer2			; ''
000060A0 7400                       		moveq	#0,d2				; ''
000060A2                            
000060A2                            .SetTimer2:
000060A2 E04A                       		lsr.w	#8,d2				; ''
000060A4 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
000060A8                            
000060A8 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
000060AC 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
000060B0 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits in render flags
000060B6 8328 000D                  		or.b	d1,_objRender(a0)			; Set new flip bits
000060BA                            
000060BA 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
000060BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060BE                            .PushAnim:
000060BE 5200                       		addq.b	#1,d0				; Is the animation rolling?
000060C0 6600                       		bne.s	.HangAnim			; If not, branch
000060C2                            
000060C2                            .DoPushAnim:
000060C2 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
000060C6 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
000060C8 4442                       		neg.w	d2				; Force it to be negative
000060CA                            
000060CA                            .GetAnim3:
000060CA 0642 0800                  		addi.w	#$800,d2			; Get animation speed
000060CE 6A00                       		bpl.s	.SetTimer3			; ''
000060D0 7400                       		moveq	#0,d2				; ''
000060D2                            
000060D2                            .SetTimer3:
000060D2 EC4A                       		lsr.w	#6,d2				; ''
000060D4 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
000060D8 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
000060DE 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
000060E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060E2                            .HangAnim:
000060E2 7200                       		moveq	#0,d1
000060E4 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation frame
000060E8 1171 1001 0010             		move.b	1(a1,d1.w),_objFrame(a0)		; Set map frame
000060EE 4228 0023                  		clr.b	_objAnimTimer(a0)			; Clear animation timer
000060F2 4E75                       		rts
000060F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060F4                            ; Handle debug placement mode
000060F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060F4                            DebugPlacement:
000060F4 7000                       		moveq	#0,d0
000060F6 1038 E8DD                  		move.b	debugMode.w,d0		; Get debug placement mode routine
000060FA 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
000060FE D040                       		add.w	d0,d0				; Double it
00006100 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
00006104                            	nextObject
00006104 3068 0004                M 	movea.w	_objnext(a0),a0
00006108 2250                     M 	move.l	_objaddress(a0),a1
0000610A 4ED1                     M 	jmp	(a1)
0000610C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000610C                            .Routines:
0000610C 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
00006110 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
00006114                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006114                            Debug_Init:
00006114 5438 E8DD                  		addq.b	#2,debugMode.w		; Next routine
00006118 4228 0010                  		clr.b	_objFrame(a0)			; Reset mapping frame
0000611C 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
00006120 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00006124 4278 E8DA                  		clr.w	camLocked.w			; Unlock the camera
00006128 4228 004B                  		clr.b	_objBallMode(a0)			; Reset ball mode
0000612C 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00006130 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set routine to main
00006136                            
00006136 3028 003C                  		move.w	_objInteract(a0),d0		; Get object interacted with last
0000613A 6700                       		beq.s	.NoInteract			; If there is none, branch
0000613C 3240                       		movea.w	d0,a1
0000613E 08A9 0003 0028             		bclr	#3,_objStatus(a1)			; Clear flags
00006144 08A9 0005 0028             		bclr	#5,_objStatus(a1)			; ''
0000614A 4268 003C                  		clr.w	_objInteract(a0)			; No more interaction
0000614E                            
0000614E                            .NoInteract:
0000614E 4228 000C                  		clr.b	_objFlags(a0)			; Reset flags
00006152 4228 0028                  		clr.b	_objStatus(a0)			; Reset status
00006156 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
0000615C 117C 0001 0010             		move.b	#1,_objFrame(a0)			; Display the standing frame
00006162 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00006166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006166                            Debug_Main:
00006166 6100 EE20                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
0000616A 6100                       		bsr.s	Debug_Control			; Control
0000616C                            	displaySprite	2,a0,a2,1
0000616C 4A68 0008                M 	tst.w	_objdrawnext(a0)
00006170 6600                     M 	bne.s	.no_235
00006172 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00006178 3478 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a2
0000617C 314A 000A                M 	move.w	a2,_objdrawprev(a0)
00006180 3548 0008                M 	move.w	a0,_objdrawnext(a2)
00006184 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00006188                          M .no_235
00006188 4E75                       		rts
0000618A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000618A                            Debug_Control:
0000618A 7006                       		moveq	#6,d0				; Speed
0000618C 0838 0000 C742             		btst	#0,ctrlHoldP1.w			; Is up being held?
00006192 6700                       		beq.s	.NoUp				; If not, branch
00006194 9168 0018                  		sub.w	d0,_objYPos(a0)			; Move up
00006198                            
00006198                            .NoUp:
00006198 0838 0001 C742             		btst	#1,ctrlHoldP1.w			; Is down being held?
0000619E 6700                       		beq.s	.NoDown				; If not, branch
000061A0 D168 0018                  		add.w	d0,_objYPos(a0)			; Move down
000061A4                            
000061A4                            .NoDown:
000061A4 0838 0002 C742             		btst	#2,ctrlHoldP1.w			; Is left being held?
000061AA 6700                       		beq.s	.NoLeft				; If not, branch
000061AC 9168 0014                  		sub.w	d0,_objXPos(a0)			; Move left
000061B0                            
000061B0                            .NoLeft:
000061B0 0838 0003 C742             		btst	#3,ctrlHoldP1.w			; Is right being held?
000061B6 6700                       		beq.s	.NoRight			; If not, branch
000061B8 D168 0014                  		add.w	d0,_objXPos(a0)			; Move right
000061BC                            
000061BC                            .NoRight:
000061BC 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
000061C2 6700                       		beq.s	.ChkWrap			; If not, branch
000061C4 7000                       		moveq	#0,d0
000061C6 11C0 E8DD                  		move.b	d0,debugMode.w		; Disable debug placement mode
000061CA 1140 0016                  		move.b	d0,_objXPos+2(a0)			; Reset X subpixel
000061CE 1140 001A                  		move.b	d0,_objYPos+2(a0)			; Reset Y subpixel
000061D2 3140 001C                  		move.w	d0,_objXVel(a0)			; Reset X velocity
000061D6 3140 001E                  		move.w	d0,_objYVel(a0)			; Reset Y velocity
000061DA 3140 003A                  		move.w	d0,_objGVel(a0)			; Reset ground velocity
000061DE 0228 0001 0028             		andi.b	#1,_objStatus(a0)			; Reset status
000061E4 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000061EA 20BC 0000 4EA8             		move.l	#ObjPlayer,_objAddress(a0)		; Use normal Sonic object
000061F0 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000061F6 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000061FC                            
000061FC                            .ChkWrap:
000061FC 4E75                       		rts
000061FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061FE                            ; Data
000061FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061FE                            Map_ObjPlayer:
000061FE                            		include	"Objects/Player/Mappings.asm"
000061FE                            Map_79b3:
000061FE 0000                       Map_79b3_0: 	dc.w Map_79b3_8-Map_79b3
00006200 0000                       Map_79b3_2: 	dc.w Map_79b3_A-Map_79b3
00006202 0000                       Map_79b3_4: 	dc.w Map_79b3_12-Map_79b3
00006204 0000                       Map_79b3_6: 	dc.w Map_79b3_1A-Map_79b3
00006206 0000                       Map_79b3_8: 	dc.b $0, $0
00006208 0001                       Map_79b3_A: 	dc.b $0, $1
0000620A FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006210 0001                       Map_79b3_12: 	dc.b $0, $1
00006212 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006218 0001                       Map_79b3_1A: 	dc.b $0, $1
0000621A FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006220                            	even
00006220                            		even
00006220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006220                            DPLC_ObjPlayer:
00006220                            		include	"Objects/Player/DPLCs.asm"
00006220                            DPLC_bf0f:
00006220 0000                       DPLC_bf0f_0: 	dc.w DPLC_bf0f_8-DPLC_bf0f
00006222 0000                       DPLC_bf0f_2: 	dc.w DPLC_bf0f_A-DPLC_bf0f
00006224 0000                       DPLC_bf0f_4: 	dc.w DPLC_bf0f_E-DPLC_bf0f
00006226 0000                       DPLC_bf0f_6: 	dc.w DPLC_bf0f_12-DPLC_bf0f
00006228 0000                       DPLC_bf0f_8: 	dc.b $0, $0
0000622A 0001                       DPLC_bf0f_A: 	dc.b $0, $1
0000622C 3000                       	dc.b $30, $0
0000622E 0001                       DPLC_bf0f_E: 	dc.b $0, $1
00006230 3008                       	dc.b $30, $8
00006232 0001                       DPLC_bf0f_12: 	dc.b $0, $1
00006234 3004                       	dc.b $30, $4
00006236                            	even
00006236                            		even
00006236                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006236                            Ani_ObjPlayer:
00006236                            		include	"Objects/Player/Animations.asm"
00006236                            ; ---------------------------------------------------------------------------
00006236                            ; Animation script - Sonic
00006236                            ; ---------------------------------------------------------------------------
00006236                            SonicAniData:
00006236 0000                       		dc.w SonicAni_Blank-SonicAniData
00006238 0000                       		dc.w SonicANi_Blank-SonicAniData
0000623A 0000                       		dc.w SonicANi_Flap-SonicAniData
0000623C 0000                       		dc.w SonicANi_Flap-SonicAniData
0000623E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006240 0000                       		dc.w SonicANi_Blank-SonicAniData
00006242 0000                       		dc.w SonicANi_Blank-SonicAniData
00006244 0000                       		dc.w SonicANi_Blank-SonicAniData
00006246 0000                       		dc.w SonicANi_Blank-SonicAniData
00006248 0000                       		dc.w SonicANi_Blank-SonicAniData
0000624A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000624C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000624E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006250 0000                       		dc.w SonicANi_Blank-SonicAniData
00006252 0000                       		dc.w SonicANi_Blank-SonicAniData
00006254 0000                       		dc.w SonicANi_Blank-SonicAniData
00006256 0000                       		dc.w SonicANi_Blank-SonicAniData
00006258 0000                       		dc.w SonicANi_Blank-SonicAniData
0000625A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000625C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000625E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006260 0000                       		dc.w SonicANi_Blank-SonicAniData
00006262 0000                       		dc.w SonicANi_Blank-SonicAniData
00006264 0000                       		dc.w SonicANi_Blank-SonicAniData
00006266 0000                       		dc.w SonicANi_Blank-SonicAniData
00006268 0000                       		dc.w SonicANi_Blank-SonicAniData
0000626A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000626C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000626E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006270 0000                       		dc.w SonicANi_Blank-SonicAniData
00006272 0000                       		dc.w SonicANi_FlapB-SonicAniData
00006274 0101 FD00                  SonicAni_Blank:		dc.b 1, 1, $FD, 0
00006278                            		even
00006278 03FD 1E                    SonicANi_Flap:		dc.b	3,	$FD,	$1E
0000627B 0301 0203 0201 FD00        SonicANi_FlapB:		dc.b	3,	1,	2,	3,	2,	1, $FD,	0
00006283                            sonicani_sprint:
00006283                            sonicani_run:
00006283                            sonicani_walk:
00006283                            sonicani_roll2:
00006283                            sonicani_roll:
00006283                            sonicani_push:
00006284 00                         		even
00006284                            ; =========================================================================================================================================================
00006284                            		include	"Objects/Ring/Code.asm"		; Ring loss object
00006284                            ; =========================================================================================================================================================
00006284                            ; Water surface object
00006284                            ; =========================================================================================================================================================
00006284                            		rsset	_objLvlSSTs
00006284                            
00006284                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006284                            ObjRingLoss:
00006284 2248                       		movea.l	a0,a1
00006286 7A00                       		moveq	#0,d5
00006288 3A3C 0001                  		move.w	#1,d5
0000628C 7020                       		moveq	#32,d0
0000628E BA40                       		cmp.w	d0,d5
00006290 6500                       		bcs.s	.BelowMax
00006292 3A00                       		move.w	d0,d5
00006294                            
00006294                            .BelowMax:
00006294 5345                       		subq.w	#1,d5
00006296 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
0000629C 6000                       		bra.s	.MakeRings
0000629E                            
0000629E                            .Loop:
0000629E 4EB8 1A1C                  		jsr	FindFreeObj.w
000062A2 6700                       		beq.s	.ResetCounter
000062A4                            
000062A4                            .MakeRings:
000062A4 22BC 0000 0000             		move.l	#ObjLostRing,_objAddress(a1)
000062AA 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
000062B0 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
000062B6 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,_objMapping(a1)	; Mappings
000062BE 337C 26B4 000E             		move.w	#$26B4,_objVRAM(a1)		; Tile properties
000062C4 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
000062CA                            	displaySprite	3,a1,a2,0			; Priority
000062CA 337C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a1)
000062D0 3478 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a2
000062D4 334A 000A                M 	move.w	a2,_objdrawprev(a1)
000062D8 3549 0008                M 	move.w	a1,_objdrawnext(a2)
000062DC 31C9 C17C                M 	move.w	a1,objdisplay+dprev+(3*dsize).w
000062E0                          M .no_236
000062E0 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
000062E6 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
000062EC 137C 0008 002C             		move.b	#8,_objColW(a1)			; Collision width
000062F2 137C 0008 002D             		move.b	#8,_objColH(a1)			; Collision height
000062F8 335B 001C                  		move.w	(a3)+,_objXVel(a1)
000062FC 335B 001E                  		move.w	(a3)+,_objYVel(a1)
00006300 51CD FF9C                  		dbf	d5,.Loop
00006304 11FC 00FF E864             		move.b	#-1,ringLossAnimT.w
0000630A                            
0000630A                            .ResetCounter:
0000630A 4278 E85E                  		clr.w	ringCount.w
0000630E 11FC 0001 E867             		move.b	#1,hudUpdateRings.w
00006314                            		playSnd	#sRingLoss, 2
00006314 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
0000631A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000631A                            ObjLostRing:
0000631A 4EB8 1D28                  		jsr	ObjectMove.w
0000631E 0668 0018 001E             		addi.w	#$18,_objYVel(a0)
00006324 6B00                       		bmi.s	.ChkCol
00006326 1038 C75B                  		move.b	(frameCounter+3).w,d0
0000632A D048                       		add.w	a0,d0
0000632C 0200 0006                  		andi.b	#6,d0
00006330 6600                       		bne.s	.ChkCol
00006332 4EB8 34CE                  		jsr	ObjCheckFloorDist
00006336 4A41                       		tst.w	d1
00006338 6A00                       		bpl.s	.ChkCol
0000633A D368 0018                  		add.w	d1,_objYPos(a0)
0000633E 3028 001E                  		move.w	_objYVel(a0),d0
00006342 E440                       		asr.w	#2,d0
00006344 9168 001E                  		sub.w	d0,_objYVel(a0)
00006348 4468 001E                  		neg.w	_objYVel(a0)
0000634C                            
0000634C                            .ChkCol:
0000634C 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00006350 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
00006354 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
00006358 4A40                       		tst.w	d0				; ''
0000635A 6700                       		beq.s	.ChkDel				; If not, branch
0000635C 0C2A 0069 0042             		cmpi.b	#105,_objInvulTime(a2)
00006362 6400                       		bhs.s	.ChkDel
00006364 6000                       		bra.s	ObjLostRing_Collect
00006366                            
00006366                            .ChkDel:
00006366 4A38 E864                  		tst.b	ringLossAnimT.w
0000636A 6700 0000                  		beq.w	ObjLostRing_Delete
0000636E 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
00006372 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00006376 B068 0018                  		cmp.w	_objYPos(a0),d0			; Have we touched the bottom boundary?
0000637A 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
0000637C                            	nextObject
0000637C 3068 0004                M 	movea.w	_objnext(a0),a0
00006380 2250                     M 	move.l	_objaddress(a0),a1
00006382 4ED1                     M 	jmp	(a1)
00006384                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006384                            .RangeData:
00006384 FFF0 0020                  		dc.w	-$10, $20
00006388 FFF0 0020                  		dc.w	-$10, $20
0000638C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000638C                            ObjLostRing_Collect:
0000638C                            	removeSprite	a0,a1,0
0000638C 3268 000A                M 	move.w	_objdrawprev(a0),a1
00006390 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00006396 3268 0008                M 	move.w	_objdrawnext(a0),a1
0000639A 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
000063A0                          M .no_239
000063A0 42A8 0008                M 	clr.l	_objdrawnext(a0)
000063A4                          M .yes_239
000063A4                            	displaySprite	1,a0,a1,0
000063A4 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
000063AA 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
000063AE 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000063B2 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000063B6 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
000063BA                          M .no_240
000063BA 4EB8 43DA                  		jsr	CollectRing
000063BE 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
000063C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063C4                            ObjLostRing_Sparkle:
000063C4 43F9 0000 0000             		lea	Ani_ObjRing,a1
000063CA 4EB8 1C42                  		jsr	AnimateObject.w
000063CE 4A28 0025                  		tst.b	_objRoutine(a0)
000063D2 6600                       		bne.s	ObjLostRing_Delete
000063D4                            	nextObject
000063D4 3068 0004                M 	movea.w	_objnext(a0),a0
000063D8 2250                     M 	move.l	_objaddress(a0),a1
000063DA 4ED1                     M 	jmp	(a1)
000063DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063DC                            ObjLostRing_Delete:
000063DC 4EB8 1A4C                  		jsr	DeleteObject.w
000063E0                            	nextObject
000063E0 3068 0004                M 	movea.w	_objnext(a0),a0
000063E4 2250                     M 	move.l	_objaddress(a0),a1
000063E6 4ED1                     M 	jmp	(a1)
000063E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063E8                            ; Ring Spawn Array
000063E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063E8                            ObjLostRing_Speeds:
000063E8 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
000063F8 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00006408 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00006418 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00006428 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00006438 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00006448 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00006458 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00006468                            		even
00006468                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006468                            ; Data
00006468                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006468                            Map_ObjLostRing:
00006468                            		include	"Objects/Ring/Mappings.asm"
00006468                            ; --------------------------------------------------------------------------------
00006468                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006468                            ; --------------------------------------------------------------------------------
00006468                            
00006468                            SME_k4ulR:	
00006468 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
0000646C 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00006470 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00006472 0001                       SME_k4ulrA:	dc.b 0, 1	
00006474 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
0000647A 0001                       SME_k4ulrC:	dc.b 0, 1	
0000647C F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00006482 0001                       SME_k4ulr14:	dc.b 0, 1	
00006484 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
0000648A 0001                       SME_k4ulr1C:	dc.b 0, 1	
0000648C F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00006492 0001                       SME_k4ulr24:	dc.b 0, 1	
00006494 F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
0000649A                            		even
0000649A                            		even
0000649A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000649A                            Ani_ObjRing:
0000649A 0000                       		dc.w	.Ani0-Ani_ObjRing
0000649C 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
000064A2                            		even
000064A2                            ; =========================================================================================================================================================
000064A2                            		include	"Objects/Explosion/Code.asm"	; Explosion object
000064A2                            ; =========================================================================================================================================================
000064A2                            ; Explosion object
000064A2                            ; =========================================================================================================================================================
000064A2 =00000003                  EXPLODE_ANI	EQU	3
000064A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000064A2                            ObjBossExplode:
000064A2                            		playSnd	#sBomb, 2			; Play explosion sound
000064A2 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
000064A8 6000                       		bra.s	ObjExplosion_Init		; Continue
000064AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000064AA                            ObjExplosion:
000064AA                            		playSnd	#sBreakItem, 2			; Play explosion sound
000064AA 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
000064B0                            
000064B0                            ObjExplosion_Init:
000064B0 20BC 0000 0000             		move.l	#ObjExplosion_Main,_objAddress(a0)	; Next routine
000064B6 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000064BC 317C 86C0 000E             		move.w	#$86C0,_objVRAM(a0)		; Tile properties
000064C2 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,_objMapping(a0)	; Mappings
000064CA                            	displaySprite	1,a0,a1,0			; Priority
000064CA 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
000064D0 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
000064D4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000064D8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000064DC 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
000064E0                          M .no_245
000064E0 117C 000C 0017             		move.b	#$C,_objDrawW(a0)			; Sprite width
000064E6 117C 000C 001B             		move.b	#$C,_objDrawH(a0)			; Sprite height
000064EC 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Animation timer
000064F2 4228 0010                  		clr.b	_objFrame(a0)			; Mapping frame
000064F6                            		
000064F6                            ObjExplosion_Main:
000064F6 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
000064FA 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
000064FC 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Reset animation timer
00006502 5228 0010                  		addq.b	#1,_objFrame(a0)			; Next frame
00006506 0C28 0005 0010             		cmpi.b	#5,_objFrame(a0)			; Has it reached the last frame?
0000650C 6600                       		bne.s	.Display			; If not, branch
0000650E 4EB8 1A4C                  		jsr	DeleteObject.w
00006512                            		
00006512                            .Display:
00006512                            	nextObject
00006512 3068 0004                M 	movea.w	_objnext(a0),a0
00006516 2250                     M 	move.l	_objaddress(a0),a1
00006518 4ED1                     M 	jmp	(a1)
0000651A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000651A                            ; Data
0000651A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000651A                            Map_ObjExplosion:
0000651A                            		include	"Objects/Explosion/Mappings.asm"
0000651A                            ; --------------------------------------------------------------------------------
0000651A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000651A                            ; --------------------------------------------------------------------------------
0000651A                            
0000651A                            SME_PS_OI:	
0000651A 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
0000651E 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
00006522 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
00006524 0001                       SME_PS_OI_A:	dc.b 0, 1	
00006526 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
0000652C 0001                       SME_PS_OI_12:	dc.b 0, 1	
0000652E F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
00006534 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00006536 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
0000653C 0004                       SME_PS_OI_22:	dc.b 0, 4	
0000653E EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
00006544 EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
0000654A 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00006550 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00006556 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00006558 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
0000655E EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
00006564 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
0000656A FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
00006570                            		even
00006570                            		even
00006570                            ; =========================================================================================================================================================
00006570                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
00006570                            ; =========================================================================================================================================================
00006570                            ; Water surface object
00006570                            ; =========================================================================================================================================================
00006570                            		rsset	_objLvlSSTs
00006570 =00000030                  _objSurfPause	rs.b	1			; Animation stop flag
00006570                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006570                            ObjWaterSurface:
00006570 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,_objAddress(a0)	; Next routine
00006576 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,_objMapping(a0)	; Mappings
0000657E 317C 8690 000E             		move.w	#$8690,_objVRAM(a0)		; Tile properties
00006584 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
0000658A                            	displaySprite	0,a0,a1,0			; Priority
0000658A 317C C15A 0008           M 	move.w	#objdisplay+(0*dsize),_objdrawnext(a0)
00006590 3278 C164                M 	move.w	objdisplay+dprev+(0*dsize).w,a1
00006594 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006598 3348 0008                M 	move.w	a0,_objdrawnext(a1)
0000659C 31C8 C164                M 	move.w	a0,objdisplay+dprev+(0*dsize).w
000065A0                          M .no_247
000065A0 117C 0080 0017             		move.b	#$80,_objDrawW(a0)			; Sprite width
000065A6 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
000065AC                            
000065AC                            ObjWaterSurface_Main:
000065AC 3238 E900                  		move.w	waterYPos.w,d1		; Get water height
000065B0 5D41                       		subq.w	#6,d1				; Shift it
000065B2 3141 0018                  		move.w	d1,_objYPos(a0)			; Set Y position
000065B6                            
000065B6 4A28 0030                  		tst.b	_objSurfPause(a0)			; Is the animation paused?
000065BA 6600                       		bne.s	.ChkUnpause			; If so, branch
000065BC 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
000065C2 6700                       		beq.s	.Animate			; If not, branch
000065C4 5628 0010                  		addq.b	#3,_objFrame(a0)			; Use different frames
000065C8 50E8 0030                  		st	_objSurfPause(a0)			; Pause the animation
000065CC 6000                       		bra.s	.Animate			; Continue
000065CE                            
000065CE                            .ChkUnpause:
000065CE 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game paused?
000065D2 6600                       		bne.s	.Animate			; If so, branch
000065D4 4228 0030                  		clr.b	_objSurfPause(a0)			; Resume animation
000065D8 5728 0010                  		subq.b	#3,_objFrame(a0)			; Use normal frames
000065DC                            
000065DC                            .Animate:
000065DC 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
000065E0 7200                       		moveq	#0,d1
000065E2 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation script frame
000065E6 1171 1000 0010             		move.b	(a1,d1.w),_objFrame(a0)		; Set mapping frame
000065EC 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next frame in animation script
000065F0 0228 003F 0022             		andi.b	#$3F,_objAnimFrame(a0)		; Loop in necessary
000065F6                            	nextObject
000065F6 3068 0004                M 	movea.w	_objnext(a0),a0
000065FA 2250                     M 	move.l	_objaddress(a0),a1
000065FC 4ED1                     M 	jmp	(a1)
000065FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000065FE                            .AniScript:
000065FE 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0000660E 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
0000661E 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
0000662E 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0000663E 00                         		even
0000663E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000663E                            ; Data
0000663E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000663E                            Map_ObjWaterSurface:
0000663E                            		include	"Objects/Water Surface/Mappings.asm"
0000663E                            MapConv_obj1B:
0000663E 0000                       	dc.w	byte_11178-MapConv_obj1B
00006640 0000                       	dc.w	byte_11188-MapConv_obj1B
00006642 0000                       	dc.w	byte_11198-MapConv_obj1B
00006644 0000                       	dc.w	byte_111A8-MapConv_obj1B
00006646 0000                       	dc.w	byte_111C7-MapConv_obj1B
00006648 0000                       	dc.w	byte_111E6-MapConv_obj1B
0000664A                            
0000664A 0003                       byte_11178:	dc.w 3
0000664C FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006652 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006658 FD0D 0000 0020             	dc.w $FD0D, 0, $20
0000665E                            
0000665E 0003                       byte_11188:	dc.w 3
00006660 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00006666 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
0000666C FD0D 0008 0020             	dc.w $FD0D, 8, $20
00006672                            
00006672 0003                       byte_11198:	dc.w 3
00006674 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
0000667A FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00006680 FD0D 0800 0020             	dc.w $FD0D, $800, $20
00006686                            
00006686 0006                       byte_111A8:	dc.w 6
00006688 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
0000668E FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
00006694 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
0000669A FD0D 0000 0000             	dc.w $FD0D, 0, 0
000066A0 FD0D 0000 0020             	dc.w $FD0D, 0, $20
000066A6 FD0D 0000 0040             	dc.w $FD0D, 0, $40
000066AC                            
000066AC 0006                       byte_111C7:	dc.w 6
000066AE FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000066B4 FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
000066BA FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000066C0 FD0D 0008 0000             	dc.w $FD0D, 8, 0
000066C6 FD0D 0008 0020             	dc.w $FD0D, 8, $20
000066CC FD0D 0008 0040             	dc.w $FD0D, 8, $40
000066D2                            
000066D2 0006                       byte_111E6:	dc.w 6
000066D4 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000066DA FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
000066E0 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000066E6 FD0D 0800 0000             	dc.w $FD0D, $800, 0
000066EC FD0D 0800 0020             	dc.w $FD0D, $800, $20
000066F2 FD0D 0800 0040             	dc.w $FD0D, $800, $40
000066F8                            
000066F8                            	even
000066F8                            		even
000066F8                            ; =========================================================================================================================================================
000066F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066F8                            		include	"Objects/Monitor/Code.asm"	; Monitor object
000066F8                            ; =========================================================================================================================================================
000066F8                            ; Monitor object
000066F8                            ; =========================================================================================================================================================
000066F8                            		rsset	_objLvlSSTs
000066F8 =00000030                  _objMonFall	rs.b	1				; Fall flag
000066F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066F8                            ObjEnemy:
000066F8 7000                               moveq   #0, d0
000066FA 1028 0025                          move.b  _objRoutine(a0),d0
000066FE 303B 0000                          move.w  .Index(pc,d0.w),d0
00006702 4EFB 0000                          jmp     .Index(pc,d0.w)
00006706                            
00006706                            .Index:
00006706 0000                               dc.w    ObjEnemy_Init-.Index
00006708 0000                               dc.w    ObjEnemy_Down-.Index
0000670A 0000                               dc.w    ObjEnemy_Up-.Index
0000670C                            
0000670C                            ObjEnemy_Init:
0000670C 5428 0025                          addq.b  #2, _objRoutine(a0)
00006710 217C 0000 0000 0010                move.l  #Map_ObjMonitor,_objMapping(a0)
00006718 317C 0588 000E                     move.w	#$588,_objVRAM(a0)
0000671E 117C 0004 000D             		move.b	#4,_objRender(a0)
00006724                                    displaySprite	3,a0,a1,0			; Priority
00006724 317C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a0)
0000672A 3278 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a1
0000672E 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006732 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006736 31C8 C17C                M 	move.w	a0,objdisplay+dprev+(3*dsize).w
0000673A                          M .no_249
0000673A                            
0000673A                            ObjEnemy_Down:
0000673A 0C68 00C8 0018                     cmpi.w  #200,   _objYPos(a0)
00006740 6500                               blo.s   .cont
00006742 5428 0025                          addq.b  #2, _ObjRoutine(a0)
00006746                                .cont:
00006746 5268 0018                          add.w   #1, _objYPos(a0)
0000674A                                    nextObject
0000674A 3068 0004                M 	movea.w	_objnext(a0),a0
0000674E 2250                     M 	move.l	_objaddress(a0),a1
00006750 4ED1                     M 	jmp	(a1)
00006752                            
00006752                            ObjEnemy_Up:
00006752 0C68 0018 0018                     cmpi.w  #24,   _objYPos(a0)
00006758 6200                               bhi.s   .cont
0000675A 5528 0025                          subq.b  #2, _ObjRoutine(a0)
0000675E                                .cont:
0000675E 5368 0018                          sub.w   #1, _objYPos(a0)
00006762                                    nextObject
00006762 3068 0004                M 	movea.w	_objnext(a0),a0
00006766 2250                     M 	move.l	_objaddress(a0),a1
00006768 4ED1                     M 	jmp	(a1)
0000676A                            
0000676A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000676A                            ; Data
0000676A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000676A                            Map_ObjMonitor:
0000676A                            		include	"Objects/Monitor/Mappings.asm"
0000676A                            ; --------------------------------------------------------------------------------
0000676A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000676A                            ; --------------------------------------------------------------------------------
0000676A                            
0000676A                            SME_7TKK1:	
0000676A 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
0000676E 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00006772 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
00006776 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
0000677A 0001                       SME_7TKK1_10:	dc.b 0, 1	
0000677C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006782 0002                       SME_7TKK1_18:	dc.b 0, 2	
00006784 F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
0000678A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006790 0002                       SME_7TKK1_26:	dc.b 0, 2	
00006792 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00006798 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
0000679E 0002                       SME_7TKK1_34:	dc.b 0, 2	
000067A0 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
000067A6 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000067AC 0002                       SME_7TKK1_42:	dc.b 0, 2	
000067AE F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
000067B4 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000067BA 0002                       SME_7TKK1_50:	dc.b 0, 2	
000067BC F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
000067C2 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000067C8 0002                       SME_7TKK1_5E:	dc.b 0, 2	
000067CA F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
000067D0 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000067D6 0001                       SME_7TKK1_6C:	dc.b 0, 1	
000067D8 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
000067DE                            		even
000067DE                            Ani_ObjMonitor:
000067DE                            		include	"Objects/Monitor/Animations.asm"
000067DE                            ; ---------------------------------------------------------------------------
000067DE                            ; Animation script - monitors
000067DE                            ; ---------------------------------------------------------------------------
000067DE 0000                       		dc.w .Static-Ani_ObjMonitor
000067E0 0000                       		dc.w .Eggman-Ani_ObjMonitor
000067E2 0000                       		dc.w .Rings-Ani_ObjMonitor
000067E4 0000                       		dc.w .Shoes-Ani_ObjMonitor
000067E6 0000                       		dc.w .Shield-Ani_ObjMonitor
000067E8 0000                       		dc.w .Stars-Ani_ObjMonitor
000067EA 0000                       		dc.w .Destroyed-Ani_ObjMonitor
000067EC 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
000067F1 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
000067FA 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00006803 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
0000680C 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00006815 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
0000681E 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00006826 00                         		even
00006826                            ; =========================================================================================================================================================
00006826                            		include	"Objects/Spikes/Code.asm"		; Spike object
00006826                            ; ===========================================================================
00006826                            ; Spike object
00006826                            ; ===========================================================================
00006826                            		rsset	_objLvlSSTs
00006826 =00000030                  _objSpikeX	rs.w	1
00006826 =00000032                  _objSpikeY	rs.w	1
00006826 =00000034                  _objSpkMvOff	rs.w	1
00006826 =00000036                  _objSpkMvState	rs.w	1
00006826 =00000038                  _objSpkMvTime	rs.w	1
00006826                            ; ===========================================================================
00006826                            ObjSpike:
00006826 7000                       		moveq	#0,d0
00006828 1028 0025                  		move.b	_objRoutine(a0),d0
0000682C 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00006830                            	nextObject
00006830 3068 0004                M 	movea.w	_objnext(a0),a0
00006834 2250                     M 	move.l	_objaddress(a0),a1
00006836 4ED1                     M 	jmp	(a1)
00006838                            ; ===========================================================================
00006838                            ObjSpike_Index:
00006838 6000 0000                  		bra.w ObjSpike_Init
0000683C 6000 0000                  		bra.w ObjSpike_Upright
00006840 6000 0000                  		bra.w ObjSpike_Sideways
00006844 6000 0000                  		bra.w ObjSpike_UpsideDown
00006848                            ; ===========================================================================
00006848                            ;ObjSpike_InitData:
00006848                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00006848                            ;		dc.b $10,$10	; 2	- Sideways spikes
00006848                            ; ===========================================================================
00006848                            ObjSpike_Init:
00006848 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000684C 217C 0000 0000 0010        		move.l	#Map_ObjSpike,_objMapping(a0)
00006854 317C 06A8 000E             		move.w	#$6A8,_objVRAM(a0)
0000685A 0028 0004 000D             		ori.b	#4,_objRender(a0)
00006860                            	displaySprite	4,a0,a1,0			; Priority
00006860 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
00006866 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
0000686A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000686E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006872 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
00006876                          M .no_253
00006876 1028 0024                  		move.b	_objSubtype(a0),d0
0000687A 0228 000F 0024             		andi.b	#$F,_objSubtype(a0)
00006880 0240 00F0                  		andi.w	#$F0,d0
00006884 7210                       		moveq	#$10,d1
00006886 1141 0017                  		move.b	d1,_objDrawW(a0)
0000688A 1141 002C                  		move.b	d1,_objColW(a0)
0000688E 1141 001B                  		move.b	d1,_objDrawH(a0)
00006892 1141 002D                  		move.b	d1,_objColH(a0)
00006896 E848                       		lsr.w	#4,d0
00006898 1140 0010                  		move.b	d0,_objFrame(a0)
0000689C 0C00 0001                  		cmpi.b	#1,d0
000068A0 6600                       		bne.s	.ChkUpsideDown
000068A2 5828 0025                  		addq.b	#4,_objRoutine(a0)
000068A6 317C 06AC 000E             		move.w	#$6AC,_objVRAM(a0)
000068AC                            
000068AC                            .ChkUpsideDown:
000068AC 0828 0001 0028             		btst	#1,_objStatus(a0)
000068B2 6700                       		beq.s	.SavePos
000068B4 117C 000C 0025             		move.b	#$C,_objRoutine(a0)
000068BA                            
000068BA                            .SavePos:
000068BA 3168 0014 0030             		move.w	_objXPos(a0),_objSpikeX(a0)
000068C0 3168 0018 0032             		move.w	_objYPos(a0),_objSpikeY(a0)
000068C6                            
000068C6 6100 0000                  		bsr.w	MoveSpikes		; make the object move
000068CA 0C28 0001 0010             		cmpi.b	#1,_objFrame(a0)		; is object type $1x ?
000068D0 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
000068D2                            ; ===========================================================================
000068D2                            ; Upright spikes
000068D2                            ; ===========================================================================
000068D2                            ObjSpike_Upright:
000068D2 6100 0000                  		bsr.w	MoveSpikes
000068D6 7200                       		moveq	#0,d1
000068D8 1228 0017                  		move.b	_objDrawW(a0),d1
000068DC 0641 000B                  		addi.w	#$B,d1
000068E0 7400                       		moveq	#0,d2
000068E2 1428 001B                  		move.b	_objDrawH(a0),d2
000068E6 3602                       		move.w	d2,d3
000068E8 5243                       		addq.w	#1,d3
000068EA 3828 0014                  		move.w	_objXPos(a0),d4
000068EE 4EB8 460E                  		jsr	SolidObject
000068F2 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)
000068F8 6700                       		beq.s	ObjSpike_UprightEnd
000068FA 3278 E876                  		movea.w	playerPtrP1.w,a1
000068FE 6100 0000                  		bsr.w	Touch_ChkHurt2
00006902                            
00006902                            ObjSpike_UprightEnd:
00006902 3028 0030                  		move.w	_objSpikeX(a0),d0
00006906 4EF8 2000                  		jmp	CheckObjActive.w
0000690A                            ; ===========================================================================
0000690A                            ; Sideways spikes
0000690A                            ; ===========================================================================
0000690A                            ObjSpike_Sideways:
0000690A 3F28 0014                  		move.w	_objXPos(a0),-(sp)	
0000690E 6100 0000                  		bsr.w	MoveSpikes
00006912 7200                       		moveq	#0,d1
00006914 1228 0017                  		move.b	_objDrawW(a0),d1
00006918 0641 000B                  		addi.w	#$B,d1
0000691C 7400                       		moveq	#0,d2
0000691E 1428 001B                  		move.b	_objDrawH(a0),d2
00006922 3602                       		move.w	d2,d3
00006924 5243                       		addq.w	#1,d3
00006926 381F                       		move.w	(sp)+,d4
00006928 4EB8 460E                  		jsr	SolidObject
0000692C 0806 0000                  		btst	#cTouchSideBit,d6
00006930 6700                       		beq.s	ObjSpike_SidewaysEnd
00006932 3278 E876                  		movea.w	playerPtrP1.w,a1
00006936 6100 0000                  		bsr.w	Touch_ChkHurt2
0000693A                            
0000693A                            ObjSpike_SidewaysEnd:
0000693A 3028 0030                  		move.w	_objSpikeX(a0),d0
0000693E 4EF8 2000                  		jmp	CheckObjActive.w
00006942                            ; ===========================================================================
00006942                            ; Upside down spikes
00006942                            ; ===========================================================================
00006942                            ObjSpike_UpsideDown:
00006942 6100 0000                  		bsr.w	MoveSpikes
00006946 7200                       		moveq	#0,d1
00006948 1228 0017                  		move.b	_objDrawW(a0),d1
0000694C 0641 000B                  		addi.w	#$B,d1
00006950 7400                       		moveq	#0,d2
00006952 1428 001B                  		move.b	_objDrawH(a0),d2
00006956 3602                       		move.w	d2,d3
00006958 5243                       		addq.w	#1,d3
0000695A 3828 0014                  		move.w	_objXPos(a0),d4
0000695E 4EB8 460E                  		jsr	SolidObject
00006962 0806 0002                  		btst	#cTouchBtmBit,d6
00006966 6700                       		beq.s	ObjSpike_UpsideDownEnd
00006968 3278 E876                  		movea.w	playerPtrP1.w,a1
0000696C 6100 0000                  		bsr.w	Touch_ChkHurt2
00006970                            
00006970                            ObjSpike_UpsideDownEnd:
00006970 3028 0030                  		move.w	_objSpikeX(a0),d0
00006974 4EF8 2000                  		jmp	CheckObjActive.w
00006978                            ; ===========================================================================
00006978                            Touch_ChkHurt2:
00006978 4A29 0042                  		tst.b	_objInvulTime(a1)			; is Sonic invincible?
0000697C 6600                       		bne.s	.End				; if yes, branch
0000697E 0C29 0008 0025             		cmpi.b	#8,_objRoutine(a1)
00006984 6700                       		beq.s	.End
00006986 2629 0018                  		move.l	_objYPos(a1),d3
0000698A 3029 001E                  		move.w	_objYVel(a1),d0
0000698E 48C0                       		ext.l	d0
00006990 E180                       		asl.l	#8,d0
00006992 9680                       		sub.l	d0,d3
00006994 2343 0018                  		move.l	d3,_objYPos(a1)
00006998 2448                       		movea.l	a0,a2
0000699A 2049                       		movea.l	a1,a0
0000699C 4EB8 5C90                  		jsr	ObjPlayer_GetHurt
000069A0 204A                       		movea.l	a2,a0
000069A2                            
000069A2                            .End:
000069A2 4E75                       		rts
000069A4                            ; ===========================================================================
000069A4                            MoveSpikes:	
000069A4 7000                       		moveq	#0,d0
000069A6 1028 0024                  		move.b	_objSubtype(a0),d0
000069AA D040                       		add.w	d0,d0
000069AC 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
000069B0                            ; ===========================================================================
000069B0                            MoveSpikes_Behaviors:
000069B0 6000                       		bra.s MoveSpikes_Still
000069B2 6000                       		bra.s MoveSpikes_Vertical
000069B4 6000                       		bra.s MoveSpikes_Horizontal
000069B6                            ; ===========================================================================
000069B6                            MoveSpikes_Still:
000069B6 4E75                       		rts			; don't move the object
000069B8                            ; ===========================================================================
000069B8                            MoveSpikes_Vertical:
000069B8 6100 0000                  		bsr.w	MoveSpikes_Delay
000069BC 7000                       		moveq	#0,d0
000069BE 1028 0034                  		move.b	_objSpkMvOff(a0),d0
000069C2 D068 0032                  		add.w	_objSpikeY(a0),d0
000069C6 3140 0018                  		move.w	d0,_objYPos(a0)	; move the object vertically
000069CA 4E75                       		rts
000069CC                            ; ===========================================================================
000069CC                            MoveSpikes_Horizontal:
000069CC 6100 0000                  		bsr.w	MoveSpikes_Delay
000069D0 7000                       		moveq	#0,d0
000069D2 1028 0034                  		move.b	_objSpkMvOff(a0),d0
000069D6 D068 0030                  		add.w	_objSpikeX(a0),d0
000069DA 3140 0014                  		move.w	d0,_objXPos(a0)	; move the object horizontally
000069DE 4E75                       		rts
000069E0                            ; ===========================================================================
000069E0                            MoveSpikes_Delay:
000069E0 4A68 0038                  		tst.w	_objSpkMvTime(a0)		; is time delay	= zero?
000069E4 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
000069E6 5368 0038                  		subq.w	#1,_objSpkMvTime(a0)	; subtract 1 from time delay
000069EA 6600                       		bne.s	locret_CFE6
000069EC 4A28 000D                  		tst.b	_objRender(a0)
000069F0 6A00                       		bpl.s	locret_CFE6
000069F2                            		playSnd	#sSpikeMove, 2		; Play spike move sound
000069F2 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
000069F8 6000                       		bra.s	locret_CFE6
000069FA                            ; ===========================================================================
000069FA                            MoveSpikes_ChkDir:
000069FA 4A68 0036                  		tst.w	_objSpkMvState(a0)
000069FE 6700                       		beq.s	MoveSpikes_Retract
00006A00 0468 0800 0034             		subi.w	#$800,_objSpkMvOff(a0)
00006A06 6400                       		bcc.s	locret_CFE6
00006A08 317C 0000 0034             		move.w	#0,_objSpkMvOff(a0)
00006A0E 317C 0000 0036             		move.w	#0,_objSpkMvState(a0)
00006A14 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
00006A1A 6000                       		bra.s	locret_CFE6
00006A1C                            ; ===========================================================================
00006A1C                            MoveSpikes_Retract:
00006A1C 0668 0800 0034             		addi.w	#$800,_objSpkMvOff(a0)
00006A22 0C68 2000 0034             		cmpi.w	#$2000,_objSpkMvOff(a0)
00006A28 6500                       		bcs.s	locret_CFE6
00006A2A 317C 2000 0034             		move.w	#$2000,_objSpkMvOff(a0)
00006A30 317C 0001 0036             		move.w	#1,_objSpkMvState(a0)
00006A36 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
00006A3C                            
00006A3C                            locret_CFE6:
00006A3C 4E75                       		rts
00006A3E                            ; ===========================================================================
00006A3E                            ; Spike object mappings
00006A3E                            ; ===========================================================================
00006A3E                            Map_ObjSpike:
00006A3E                            	include "Objects/Spikes/Mappings.asm"
00006A3E                            ; --------------------------------------------------------------------------------
00006A3E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006A3E                            ; --------------------------------------------------------------------------------
00006A3E                            
00006A3E                            SME_5AG23:	
00006A3E 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00006A42 0004                       SME_5AG23_4:	dc.b 0, 4	
00006A44 F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
00006A4A F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00006A50 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
00006A56 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
00006A5C 0004                       SME_5AG23_1E:	dc.b 0, 4	
00006A5E F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
00006A64 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006A6A 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
00006A70 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
00006A76                            		even
00006A76                            ; ===========================================================================
00006A76                            		include	"Objects/Spring/Code.asm"		; Spring object
00006A76                            ; =========================================================================================================================================================
00006A76                            ; Spring object
00006A76                            ; =========================================================================================================================================================
00006A76                            		rsset	_objLvlSSTs
00006A76 =00000030                  _objSprSpd		rs.w	1				; Spring strength
00006A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A76                            ObjSpring:
00006A76 217C 0000 0000 0010        		move.l	#Map_ObjSpring,_objMapping(a0)		; Mappings
00006A7E 317C 05BA 000E             		move.w	#$5BA,_objVRAM(a0)			; Tile properties
00006A84 0028 0004 000D             		ori.b	#4,_objRender(a0)			; Render flags
00006A8A 117C 0010 0017             		move.b	#$10,_objDrawW(a0)			; Sprite width
00006A90 117C 0008 001B             		move.b	#8,_objDrawH(a0)			; Sprite height
00006A96 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006A9C                            	displaySprite	4,a0,a1,0			; Priority
00006A9C 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
00006AA2 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
00006AA6 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006AAA 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006AAE 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
00006AB2                          M .no_255
00006AB2                            		
00006AB2 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006AB6 E648                       		lsr.w	#3,d0				; Turn into offset
00006AB8 0240 000E                  		andi.w	#$E,d0				; ''
00006ABC 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
00006AC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AC0                            .Subtypes:
00006AC0 6000                       		bra.s .Init_Up				; Up
00006AC2 6000                       		bra.s .Init_Horizontal			; Horizontal
00006AC4 6000                       		bra.s .Init_Down			; Down
00006AC6 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
00006AC8 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
00006ACA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006ACA                            .Init_Horizontal:
00006ACA 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Animation
00006AD0 117C 0002 0010             		move.b	#2,_objFrame(a0)			; Mapping frame
00006AD6 317C 05CA 000E             		move.w	#$5CA,_objVRAM(a0)			; Tile properties
00006ADC 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006AE2 117C 0010 001B             		move.b	#$10,_objDrawH(a0)			; Sprite height
00006AE8 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006AEE 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,_objAddress(a0)	; Next routine
00006AF4 6000                       		bra.s	.Init_Common			; Continue
00006AF6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AF6                            .Init_Down:
00006AF6 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006AFC 20BC 0000 0000             		move.l	#ObjSpring_Down,_objAddress(a0)	; Next routine
00006B02 6000                       		bra.s	.Init_Common			; Continue
00006B04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B04                            .Init_DiagonallyUp:
00006B04 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006B0A 117C 0004 0010             		move.b	#4,_objFrame(a0)			; Map frame
00006B10 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006B16 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,_objAddress(a0); Next routine
00006B1C 6000                       		bra.s	.Init_Common			; Continue
00006B1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B1E                            .Init_DiagonallyDown:
00006B1E 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006B24 117C 0006 0010             		move.b	#6,_objFrame(a0)			; Map frame
00006B2A 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006B30 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006B36 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,_objAddress(a0); Next routine
00006B3C 6000                       		bra.s	.Init_Common			; Continue
00006B3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B3E                            .Init_Up:
00006B3E 20BC 0000 0000             		move.l	#ObjSpring_Up,_objAddress(a0)		; Next routine
00006B44                            
00006B44                            .Init_Common:
00006B44 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006B48 0240 0002                  		andi.w	#2,d0				; Turn into offset
00006B4C 317B 0000 0030             		move.w	.Strengths(pc,d0.w),_objSprSpd(a0)	; Get spring strength
00006B52 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
00006B56 6700                       		beq.s	.NotYellow			; If not, branch
00006B58 08E8 0005 000E             		bset	#5,_objVRAM(a0)			; Make the spring yellow
00006B5E                            
00006B5E                            .NotYellow:
00006B5E                            	nextObject
00006B5E 3068 0004                M 	movea.w	_objnext(a0),a0
00006B62 2250                     M 	move.l	_objaddress(a0),a1
00006B64 4ED1                     M 	jmp	(a1)
00006B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B66                            .Strengths:
00006B66 F000                       		dc.w	-$1000				; Strength of red spring
00006B68 F600                       		dc.w	-$A00				; Strength of yellow spring
00006B6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B6A                            ObjSpring_Up:
00006B6A 323C 001A                  		move.w	#27-1,d1			; Width
00006B6E 343C 0008                  		move.w	#16/2,d2			; Height
00006B72 3602                       		move.w	d2,d3				; ''
00006B74 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006B78 4EB8 465E                  		jsr	SolidObject_Always		; Set object as solid
00006B7C 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the top of the of spring?
00006B82 6700                       		beq.s	.Display			; If not, branch
00006B84 6100                       		bsr.s	.Bounce				; Bounce the player up
00006B86                            
00006B86                            .Display:
00006B86 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006B8A 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006B8E 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006B92                            	nextObject
00006B92 3068 0004                M 	movea.w	_objnext(a0),a0
00006B96 2250                     M 	move.l	_objaddress(a0),a1
00006B98 4ED1                     M 	jmp	(a1)
00006B9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B9A                            .Bounce:
00006B9A 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006BA0 5069 0018                  		addq.w	#8,_objYPos(a1)			; Align player to spring
00006BA4 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006BAA 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006BB0 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006BB6 4229 0040                  		clr.b	_objJumping(a1)			; Clear the player's jump flag
00006BBA 137C 0010 0020             		move.b	#$10,_objAnim(a1)			; Set the player's animation to the spring animation
00006BC0 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006BC6                            		
00006BC6 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006BCA 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006BCC 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006BD0                            
00006BD0                            .ChkPath1:
00006BD0 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006BD4 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006BD8 6600                       		bne.s	.ChkPath2			; If not, branch
00006BDA 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006BE0 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006BE6                            
00006BE6                            .ChkPath2:
00006BE6 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006BEA 6600                       		bne.s	.PlaySound			; If not, branch
00006BEC 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006BF2 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006BF8                            
00006BF8                            .PlaySound:
00006BF8                            		playSnd	#sSpring, 2			; Play spring sound
00006BF8 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006BFE 4E75                       		rts
00006C00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C00                            ObjSpring_Horizontal:
00006C00 323C 0013                  		move.w	#20-1,d1			; Width
00006C04 343C 000E                  		move.w	#28/2,d2			; Height
00006C08 3602                       		move.w	d2,d3				; ''
00006C0A 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006C0E 4EB8 465E                  		jsr	SolidObject_Always		; Set object as solid
00006C12 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
00006C16 6700                       		beq.s	.Display			; If not, branch
00006C18 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006C1C 3028 0014                  		move.w	_objXPos(a0),d0			; Get which side of the spring the player is facing
00006C20 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
00006C24 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
00006C26 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
00006C2A                            
00006C2A                            .NoFlip:
00006C2A 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
00006C2E 6600                       		bne.s	.Display			; If not, branch
00006C30 6100                       		bsr.s	.Bounce				; Bounce the player
00006C32                            
00006C32                            .Display:
00006C32 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006C36 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006C3A 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006C3E                            	nextObject
00006C3E 3068 0004                M 	movea.w	_objnext(a0),a0
00006C42 2250                     M 	move.l	_objaddress(a0),a1
00006C44 4ED1                     M 	jmp	(a1)
00006C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C46                            .Bounce:	
00006C46 317C 0300 0020             		move.w	#$300,_objAnim(a0)			; Reset animation
00006C4C 5069 0014                  		addq.w	#8,_objXPos(a1)			; Align player to spring
00006C50 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)		; Set the player's X velocity
00006C56 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Make the player face the left
00006C5C 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is this spring facing the left?
00006C62 6600                       		bne.s	.SetMoveLock			; If so, branch
00006C64 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Make the player face the right
00006C6A 0469 0010 0014             		subi.w	#$10,_objXPos(a1)			; Align player to spring
00006C70 4469 001C                  		neg.w	_objXVel(a1)			; Move the player to the right
00006C74                            
00006C74                            .SetMoveLock:
00006C74 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Lock the player's movement for a bit
00006C7A 3369 001C 003A             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's ground velocity
00006C80                            		
00006C80 0829 0002 0028             		btst	#2,_objStatus(a1)			; Is the player jumping?
00006C86 6600                       		bne.s	.ChkYStop			; If so, branch
00006C88 4229 0020                  		clr.b	_objAnim(a1)			; Set the animation to the walking animation
00006C8C                            		
00006C8C                            .ChkYStop:
00006C8C 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006C90 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
00006C92 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's Y movement
00006C96                            
00006C96                            .ChkPath1:
00006C96 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006C9A 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006C9E 6600                       		bne.s	.ChkPath2			; If not, branch
00006CA0 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006CA6 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006CAC                            
00006CAC                            .ChkPath2:
00006CAC 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006CB0 6600                       		bne.s	.PlaySound			; If not, branch
00006CB2 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006CB8 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006CBE                            
00006CBE                            .PlaySound:
00006CBE 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear "push" flags
00006CC4 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
00006CCA                            		playSnd	#sSpring, 2			; Play spring sound
00006CCA 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006CD0 4E75                       		rts
00006CD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CD2                            ObjSpring_Down:
00006CD2 323C 0012                  		move.w	#19-1,d1			; Width
00006CD6 343C 0008                  		move.w	#16/2,d2			; Height
00006CDA 3602                       		move.w	d2,d3				; ''
00006CDC 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006CE0 4EB8 465E                  		jsr	SolidObject_Always		; Set object as solid
00006CE4 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
00006CE8 6600                       		bne.s	.Display			; If not, branch
00006CEA 6100                       		bsr.s	.Bounce				; Bounce the player
00006CEC                            
00006CEC                            .Display:
00006CEC 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006CF0 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006CF4 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006CF8                            	nextObject
00006CF8 3068 0004                M 	movea.w	_objnext(a0),a0
00006CFC 2250                     M 	move.l	_objaddress(a0),a1
00006CFE 4ED1                     M 	jmp	(a1)
00006D00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D00                            .Bounce:
00006D00 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006D06 5169 0018                  		subq.w	#8,_objYPos(a1)			; Align player with the spring
00006D0A 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006D10 4469 001E                  		neg.w	_objYVel(a1)			; Move the player down
00006D14                            		
00006D14 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006D18 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006D1A 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006D1E                            
00006D1E                            .ChkPath1:
00006D1E 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006D22 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006D26 6600                       		bne.s	.ChkPath2			; If not, branch
00006D28 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006D2E 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006D34                            
00006D34                            .ChkPath2:
00006D34 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006D38 6600                       		bne.s	.PlaySound			; If not, branch
00006D3A 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006D40 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006D46                            
00006D46                            .PlaySound:
00006D46 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006D4C 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006D52 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006D58                            		playSnd	#sSpring, 2			; Play spring sound
00006D58 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006D5E 4E75                       		rts
00006D60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D60                            ObjSpring_DiagonallyUp:
00006D60 323C 0019                  		move.w	#26-1,d1			; Width
00006D64 343C 0010                  		move.w	#32/2,d2			; Height
00006D68 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006D6C 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
00006D70 4EB8 46AE                  		jsr	SlopedSolid			; Set object as a solid slope
00006D74                            		
00006D74 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the spring?
00006D7A 6700                       		beq.s	.End				; If not, branch
00006D7C 6100                       		bsr.s	.Bounce				; Bounce the player
00006D7E                            
00006D7E                            .End:
00006D7E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006D82 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006D86 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006D8A                            	nextObject
00006D8A 3068 0004                M 	movea.w	_objnext(a0),a0
00006D8E 2250                     M 	move.l	_objaddress(a0),a1
00006D90 4ED1                     M 	jmp	(a1)
00006D92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D92                            .Bounce:
00006D92 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is the spring facing left?
00006D98 6600                       		bne.s	.FaceLeft			; If so, branch
00006D9A 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00006D9E 5940                       		subq.w	#4,d0				; Subtract 4
00006DA0 B069 0014                  		cmp.w	_objXPos(a1),d0			; Is the player
00006DA4 6500                       		blo.s	.DoBounce
00006DA6 4E75                       		rts
00006DA8                            
00006DA8                            .FaceLeft:
00006DA8 3028 0014                  		move.w	_objXPos(a0),d0
00006DAC 5840                       		addq.w	#4,d0
00006DAE B069 0014                  		cmp.w	_objXPos(a1),d0
00006DB2 6400                       		bhs.s	.DoBounce
00006DB4 4E75                       		rts
00006DB6                            
00006DB6                            .DoBounce:
00006DB6 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006DBC 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006DC2 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006DC8 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006DCC 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006DD0 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006DD6 0828 0000 0028             		btst	#0,_objStatus(a0)
00006DDC 6600                       		bne.s	.SetAni
00006DDE 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006DE4 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006DEA 4469 001C                  		neg.w	_objXVel(a1)
00006DEE                            
00006DEE                            .SetAni:
00006DEE 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006DF4 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006DFA 137C 0010 0020             		move.b	#$10,_objAnim(a1)
00006E00 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006E06                            
00006E06 1028 0024                  		move.b	_objSubtype(a0),d0
00006E0A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006E0E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006E12 6600                       		bne.s	.ChkPath2			; If not, branch
00006E14 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006E1A 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006E20                            
00006E20                            .ChkPath2:
00006E20 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006E24 6600                       		bne.s	.PlaySound			; If not, branch
00006E26 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006E2C 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006E32                            
00006E32                            .PlaySound:
00006E32                            		playSnd	#sSpring, 2			; Play spring sound
00006E32 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006E38 4E75                       		rts
00006E3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E3A                            .SlopeData:
00006E3A 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
00006E41 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
00006E48 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
00006E4F FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
00006E56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E56                            ObjSpring_DiagonallyDown:
00006E56 323C 0019                  		move.w	#26-1,d1			; Width
00006E5A 343C 0010                  		move.w	#32/2,d2
00006E5E 3828 0014                  		move.w	_objXPos(a0),d4
00006E62 45FA 0000                  		lea	.SlopeData(pc),a2
00006E66 4EB8 46AE                  		jsr	SlopedSolid			; Set object as a solid slope
00006E6A 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
00006E6E 6600                       		bne.s	.End				; If not, branch
00006E70 6100                       		bsr.s	.Bounce				; Bounce the player
00006E72                            
00006E72                            .End:
00006E72 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006E76 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006E7A 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006E7E                            	nextObject
00006E7E 3068 0004                M 	movea.w	_objnext(a0),a0
00006E82 2250                     M 	move.l	_objaddress(a0),a1
00006E84 4ED1                     M 	jmp	(a1)
00006E86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E86                            .Bounce:
00006E86 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006E8C 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006E92 4469 001E                  		neg.w	_objYVel(a1)
00006E96 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006E9C 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006EA0 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006EA4 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006EAA 0828 0000 0028             		btst	#0,_objStatus(a0)
00006EB0 6600                       		bne.s	.SetAni
00006EB2 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006EB8 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006EBE 4469 001C                  		neg.w	_objXVel(a1)
00006EC2                            
00006EC2                            .SetAni:
00006EC2 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006EC8 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006ECE 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006ED4                            
00006ED4 1028 0024                  		move.b	_objSubtype(a0),d0
00006ED8 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006EDC 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006EE0 6600                       		bne.s	.ChkPath2			; If not, branch
00006EE2 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006EE8 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006EEE                            
00006EEE                            .ChkPath2:
00006EEE 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006EF2 6600                       		bne.s	.PlaySound			; If not, branch
00006EF4 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006EFA 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006F00                            
00006F00                            .PlaySound:
00006F00                            		playSnd	#sSpring, 2			; Play spring sound
00006F00 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006F06 4E75                       		rts
00006F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F08                            .SlopeData:
00006F08 F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
00006F0F F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
00006F16 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
00006F1D 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
00006F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F24                            ; Data
00006F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F24                            Ani_ObjSpring:
00006F24                            		include	"Objects/Spring/Animations.asm"
00006F24                            ; ---------------------------------------------------------------------------
00006F24                            ; Animation script - springs
00006F24                            ; ---------------------------------------------------------------------------
00006F24 0000                       		dc.w byte_18FEE-Ani_ObjSpring
00006F26 0000                       		dc.w byte_18FF1-Ani_ObjSpring
00006F28 0000                       		dc.w byte_18FFD-Ani_ObjSpring
00006F2A 0000                       		dc.w byte_19000-Ani_ObjSpring
00006F2C 0000                       		dc.w byte_1900C-Ani_ObjSpring
00006F2E 0000                       		dc.w byte_1900F-Ani_ObjSpring
00006F30                            byte_18FEE:
00006F30 0F00 FF                    		dc.b  $F, 0, $FF
00006F34 00                         		even
00006F34                            byte_18FF1:
00006F34 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
00006F3E 00                         		even
00006F3E                            byte_18FFD:
00006F3E 0F02 FF                    		dc.b $F, 2, $FF
00006F42 00                         		even
00006F42                            byte_19000:
00006F42 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
00006F4C 00                         		even
00006F4C                            byte_1900C:
00006F4C 0F04 FF                    		dc.b $F, 4, $FF
00006F50 00                         		even
00006F50                            byte_1900F:
00006F50 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
00006F5A 00                         		even
00006F5A                            Map_ObjSpring:
00006F5A                            		include	"Objects/Spring/Mappings.asm"
00006F5A                            ; --------------------------------------------------------------------------------
00006F5A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006F5A                            ; --------------------------------------------------------------------------------
00006F5A                            
00006F5A                            SME_q_6K9:	
00006F5A 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
00006F5E 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
00006F62 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
00006F66 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
00006F68 0002                       SME_q_6K9_E:	dc.b 0, 2	
00006F6A F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006F70 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
00006F76 0005                       SME_q_6K9_1C:	dc.b 0, 5	
00006F78 E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
00006F7E E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
00006F84 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
00006F8A F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
00006F90 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
00006F96 0001                       SME_q_6K9_3C:	dc.b 0, 1	
00006F98 E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
00006F9E 0007                       SME_q_6K9_44:	dc.b 0, 7	
00006FA0 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
00006FA6 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
00006FAC F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
00006FB2 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
00006FB8 F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
00006FBE E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
00006FC4 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
00006FCA 0002                       SME_q_6K9_70:	dc.b 0, 2	
00006FCC F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00006FD2 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
00006FD8 0005                       SME_q_6K9_7E:	dc.b 0, 5	
00006FDA E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
00006FE0 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
00006FE6 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
00006FEC FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
00006FF2 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
00006FF8 0002                       SME_q_6K9_9E:	dc.b 0, 2	
00006FFA 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
00007000 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
00007006                            		even
00007006                            ; =========================================================================================================================================================
00007006                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
00007006                            ; =========================================================================================================================================================
00007006                            ; Checkpoint object
00007006                            ; =========================================================================================================================================================
00007006                            		rsset	_objLvlSSTs
00007006 =00000030                  _objDongleX	rs.w	1				; Ball dongle X
00007006 =00000032                  _objDongleY	rs.w	1				; Ball dongle Y
00007006 =00000034                  _objDongleTime	rs.w	1				; Ball dongle timer
00007006 =00000036                  _objDonglePar	rs.w	1				; Ball dongle parent
00007006                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007006                            ObjCheckpoint:
00007006 7000                       		moveq	#0,d0
00007008 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
0000700C 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00007010                            	nextObject
00007010 3068 0004                M 	movea.w	_objnext(a0),a0
00007014 2250                     M 	move.l	_objaddress(a0),a1
00007016 4ED1                     M 	jmp	(a1)
00007018                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007018                            .Index:
00007018 6000 0000                  		bra.w	ObjChkpoint_Init
0000701C 6000 0000                  		bra.w	ObjChkpoint_Main
00007020 6000 0000                  		bra.w	ObjChkpoint_Animate
00007024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007024                            ObjChkpoint_Init:
00007024 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00007028                            		
00007028 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,_objMapping(a0)	; Mappings
00007030 317C 057E 000E             		move.w	#$57E,_objVRAM(a0)			; Tile properties
00007036 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
0000703C 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00007042 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00007048                            	displaySprite	5,a0,a1,0			; Priority
00007048 317C C182 0008           M 	move.w	#objdisplay+(5*dsize),_objdrawnext(a0)
0000704E 3278 C18C                M 	move.w	objdisplay+dprev+(5*dsize).w,a1
00007052 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00007056 3348 0008                M 	move.w	a0,_objdrawnext(a1)
0000705A 31C8 C18C                M 	move.w	a0,objdisplay+dprev+(5*dsize).w
0000705E                          M .no_268
0000705E                            		
0000705E 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00007062 3440                       		movea.w	d0,a2				; ''
00007064 0812 0000                  		btst	#0,(a2)				; Is it already set?
00007068 6600                       		bne.s	.AlreadySet			; If so, branch
0000706A                            
0000706A 1228 0024                  		move.b	_objSubtype(a0),d1			; Get checkpoint ID
0000706E B238 C7B0                  		cmp.b	chkIDLast.w,d1		; Has a later checkpoint already been hit?
00007072 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
00007074                            
00007074                            .AlreadySet:
00007074 08D2 0000                  		bset	#0,(a2)				; Mark as set
00007078 117C 0002 0020             		move.b	#2,_objAnim(a0)			; ''
0000707E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000707E                            ObjChkpoint_Main:
0000707E 4A38 E8DD                  		tst.b	debugMode.w			; Are we in debug placement mode?
00007082 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
00007086                            		
00007086 3278 E876                  		movea.w	playerPtrP1.w,a1		; Player object
0000708A 1238 C7B0                  		move.b	chkIDLast.w,d1		; Get last checkpoint hit
0000708E B228 0024                  		cmp.b	_objSubtype(a0),d1			; Has a later checkpoint already been hit?
00007092 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
00007096                            
00007096 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000709A 9068 0014                  		sub.w	_objXPos(a0),d0			; Get delta X from current position
0000709E 5040                       		addq.w	#8,d0				; Add 8
000070A0 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
000070A4 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
000070A8 3029 0018                  		move.w	_objYPos(a1),d0			; Get player's Y position
000070AC 9068 0018                  		sub.w	_objYPos(a0),d0			; Get delta Y from current position
000070B0 0640 0040                  		addi.w	#$40,d0				; Add $40
000070B4 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
000070B8 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
000070BC                            		
000070BC                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
000070BC 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
000070C2                            
000070C2 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
000070C6 6700                       		beq.s	.SetPoint			; If there is none, branch
000070C8 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,_objAddress(a1)	; Load the checkpoint ball dongle object
000070CE 3368 0014 0030             		move.w	_objXPos(a0),_objDongleX(a1)		; Dongle X
000070D4 3368 0018 0032             		move.w	_objYPos(a0),_objDongleY(a1)		; Dongle Y
000070DA 0469 0014 0032             		subi.w	#$14,_objDongleY(a1)		; ''
000070E0 2368 0010 0010             		move.l	_objMapping(a0),_objMapping(a1)		; Mappings
000070E6 3368 000E 000E             		move.w	_objVRAM(a0),_objVRAM(a1)		; Tile properties
000070EC 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
000070F2 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
000070F8 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
000070FE                            	displaySprite	4,a1,a2,0			; Priority
000070FE 337C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a1)
00007104 3478 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a2
00007108 334A 000A                M 	move.w	a2,_objdrawprev(a1)
0000710C 3549 0008                M 	move.w	a1,_objdrawnext(a2)
00007110 31C9 C184                M 	move.w	a1,objdisplay+dprev+(4*dsize).w
00007114                          M .no_270
00007114 137C 0002 0010             		move.b	#2,_objFrame(a1)			; Map frame
0000711A 337C 0020 0034             		move.w	#$20,_objDongleTime(a1)		; Dongle timer
00007120 3348 0036                  		move.w	a0,_objDonglePar(a1)		; Dongle parent
00007124                            
00007124                            .SetPoint:
00007124 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00007128 3440                       		movea.w	d0,a2				; ''
0000712A 08D2 0000                  		bset	#0,(a2)				; Mark as set
0000712E                            		
0000712E 117C 0001 0020             		move.b	#1,_objAnim(a0)			; Use dongling animation
00007134 11E8 0024 C7B0             		move.b	_objSubtype(a0),chkIDLast.w	; Set checkpoint ID
0000713A                            
0000713A 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000713E 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
00007144 4EF8 4C02                  		jmp	Level_SaveInfo			; Save data
00007148                            		
00007148                            .ChkSetAnim:
00007148 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000714C 4A28 0020                  		tst.b	_objAnim(a0)			; Are we still unset?
00007150 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
00007152 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use the set animation
00007158                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007158                            ObjChkpoint_Animate:
00007158 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0000715E 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00007162 4EF8 2000                  		jmp	CheckObjActive.w		; Display
00007166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007166                            ; Ball dongle object
00007166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007166                            ObjChkPoint_Dongle:
00007166 5368 0034                  		subq.w	#1,_objDongleTime(a0)		; Decrement timer
0000716A 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0000716C 3268 0036                  		movea.w	_objDonglePar(a0),a1		; Get parent
00007170 137C 0002 0020             		move.b	#2,_objAnim(a1)			; Set set animation for parent
00007176 4229 0010                  		clr.b	_objFrame(a1)			; Reset map frame for parent
0000717A 4EB8 1A4C                  		jsr	DeleteObject.w			; Delete ourselves
0000717E                            	nextObject
0000717E 3068 0004                M 	movea.w	_objnext(a0),a0
00007182 2250                     M 	move.l	_objaddress(a0),a1
00007184 4ED1                     M 	jmp	(a1)
00007186                            
00007186                            .MoveDongle:
00007186 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000718A 0428 0010 0041             		subi.b	#$10,_objAngle(a0)			; Decrement angle
00007190 0400 0040                  		subi.b	#$40,d0				; Subtract $40
00007194 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00007198 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
0000719C 4841                       		swap	d1				; Get high word
0000719E D268 0030                  		add.w	_objDongleX(a0),d1			; Add dongle X
000071A2 3141 0014                  		move.w	d1,_objXPos(a0)			; Set actual X
000071A6 C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
000071AA 4840                       		swap	d0				; Get high word
000071AC D068 0032                  		add.w	_objDongleY(a0),d0			; Add dongle X
000071B0 3140 0018                  		move.w	d0,_objYPos(a0)			; Set actual X
000071B4 4EB8 2000                  		jsr	CheckObjActive.w		; Display
000071B8                            	nextObject
000071B8 3068 0004                M 	movea.w	_objnext(a0),a0
000071BC 2250                     M 	move.l	_objaddress(a0),a1
000071BE 4ED1                     M 	jmp	(a1)
000071C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071C0                            ; Data
000071C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071C0                            Ani_ObjChkpoint:
000071C0 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
000071C2 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
000071C4 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
000071C6 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
000071CA 00                         		even
000071CA 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
000071CE 00                         		even
000071CE 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
000071D2                            		even
000071D2                            Map_ObjChkpoint:
000071D2                            		include	"Objects/Checkpoint/Mappings.asm"
000071D2                            ; --------------------------------------------------------------------------------
000071D2                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000071D2                            ; --------------------------------------------------------------------------------
000071D2                            
000071D2                            SME_JjCUP:	
000071D2 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
000071D6 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
000071DA 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
000071DC 0004                       SME_JjCUP_A:	dc.b 0, 4	
000071DE E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
000071E4 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
000071EA F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
000071F0 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
000071F6 0003                       SME_JjCUP_24:	dc.b 0, 3	
000071F8 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
000071FE F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007204 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000720A 0001                       SME_JjCUP_38:	dc.b 0, 1	
0000720C F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
00007212 0001                       SME_JjCUP_40:	dc.b 0, 1	
00007214 F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0000721A 0004                       SME_JjCUP_48:	dc.b 0, 4	
0000721C E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007222 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007228 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000722E D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
00007234                            		even
00007234                            ; =========================================================================================================================================================
00007234                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
00007234                            ; =========================================================================================================================================================
00007234                            ; Wall spring object
00007234                            ; =========================================================================================================================================================
00007234                            ObjWallSpring:
00007234 20BC 0000 0000             		move.l	#ObjWallSpring_Main,_objAddress(a0)	; Next routine
0000723A                            	;	move.l	#Map_ObjWallSpring,_objMapping(a0)	; Mappings
0000723A                            	;	clr.w	_objVRAM(a0)			; Tile properties
0000723A                            	;	ori.b	#4,_objRender(a0)			; Render flags
0000723A                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0000723A                            	;	move.b	#8,_objDrawW(a0)			; Sprite width
0000723A                            	;	move.b	#$40,_objDrawH(a0)			; Sprite height
0000723A 117C 0008 002C             		move.b	#8,_objColW(a0)			; Collision width
00007240 117C 0040 002D             		move.b	#$40,_objColH(a0)			; Collision height
00007246                            
00007246 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
0000724A E808                       		lsr.b	#4,d0				; Get map frame
0000724C 0200 0007                  		andi.b	#7,d0				; ''
00007250 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00007254 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
00007256                            	;	move.b	#$80,_objDrawH(a0)			; Larger sprite height
00007256 117C 0080 002D             		move.b	#$80,_objColH(a0)			; Larger collision height
0000725C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000725C                            ObjWallSpring_Main:
0000725C 7208                       		moveq	#8,d1				; Width
0000725E 7400                       		moveq	#0,d2
00007260 1428 002D                  		move.b	_objColH(a0),d2			; Height
00007264 3602                       		move.w	d2,d3				; ''
00007266 5243                       		addq.w	#1,d3				; ''
00007268 3828 0014                  		move.w	_objXPos(a0),d4			; X position
0000726C 4EB8 465E                  		jsr	SolidObject_Always		; Make us solid
00007270                            
00007270 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
00007274 6700                       		beq.s	.Display			; If not, branch
00007276 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set in air
0000727C 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00007280 3028 0014                  		move.w	_objXPos(a0),d0			; Get distance between us and Sonic
00007284 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
00007288 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
0000728A 0A01 0001                  		eori.b	#1,d1				; Go the other way
0000728E                            
0000728E                            .ChkXStat:
0000728E 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
00007292 6600                       		bne.s	.Display			; If not, branch
00007294 6100                       		bsr.s	.Bounce
00007296                            
00007296                            .Display:
00007296 4EB8 2000                  		jsr	CheckObjActive.w		; Delete if inactive
0000729A                            	nextObject
0000729A 3068 0004                M 	movea.w	_objnext(a0),a0
0000729E 2250                     M 	move.l	_objaddress(a0),a1
000072A0 4ED1                     M 	jmp	(a1)
000072A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072A2                            .Bounce:
000072A2 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is Sonic dead?
000072A8 6500                       		blo.s	.DoBounce			; If not, branch
000072AA 4E75                       		rts
000072AC                            
000072AC                            .DoBounce:
000072AC 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Make Sonic not hurt if he is
000072B2 337C F800 001C             		move.w	#-$800,_objXVel(a1)		; Bounce left
000072B8 337C F800 001E             		move.w	#-$800,_objYVel(a1)		; Bounce up
000072BE 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Face left
000072C4 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing left?
000072CA 6600                       		bne.s	.MoveLock			; If so, branch
000072CC 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Face right
000072D2 4469 001C                  		neg.w	_objXVel(a1)			; Go right
000072D6                            
000072D6                            .MoveLock:
000072D6 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Set move lock timer
000072DC 0829 0002 0028             		btst	#2,_objStatus(a1)			; Was Sonic jumping?
000072E2 6600                       		bne.s	.ChkN_objYVel			; If so, branch
000072E4 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
000072E8                            
000072E8                            .ChkN_objYVel:
000072E8 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
000072EC 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
000072EE 4229 001E                  		clr.b	_objYVel(a1)			; Stop Y velocity
000072F2                            
000072F2                            .ChkFlip:
000072F2 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
000072F6 6700                       		beq.s	.PlaySnd			; If not, branch
000072F8 337C 0001 003A             		move.w	#1,_objFlipDir(a1)			; Set flip direction
000072FE 137C 0001 0047             		move.b	#1,_objFlipAngle(a1)		; Set flip angle
00007304 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00007308 137C 0001 0049             		move.b	#1,_objFlipRemain(a1)		; Set flips remaining
0000730E 137C 0008 004A             		move.b	#8,_objFlipSpeed(a1)		; Set flip speed
00007314 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
00007318 6600                       		bne.s	.ChkDir				; If not, branch
0000731A 137C 0003 0049             		move.b	#3,_objFlipRemain(a1)		; Do 3 flips isntead
00007320                            
00007320                            .ChkDir:
00007320 0829 0000 0028             		btst	#0,_objStatus(a1)			; Was Sonic facing left?
00007326 6700                       		beq.s	.PlaySnd			; If not, branch
00007328 4429 0047                  		neg.b	_objFlipAngle(a1)			; Flip the other way
0000732C 4469 003A                  		neg.w	_objFlipDir(a1)			; ''
00007330                            
00007330                            .PlaySnd:
00007330 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Stop pushing
00007336 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
0000733C                            		playSnd	#sSpring, 2			; Play spring sound
0000733C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007342 4E75                       		rts
00007344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007344                            ; Data
00007344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007344                            Map_ObjWallSpring:
00007344                            		include	"Objects/Wall Spring/Mappings.asm"
00007344                            ; --------------------------------------------------------------------------------
00007344                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007344                            ; --------------------------------------------------------------------------------
00007344                            
00007344                            SME_ReVf5:	
00007344 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
00007348 0002                       SME_ReVf5_4:	dc.b 0, 2	
0000734A C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
00007350 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
00007356 0002                       SME_ReVf5_12:	dc.b 0, 2	
00007358 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0000735E 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
00007364                            		even
00007364                            		even
00007364                            ; =========================================================================================================================================================
00007364                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
00007364                            ; =========================================================================================================================================================
00007364                            ; Ball mode enable/disable object
00007364                            ; =========================================================================================================================================================
00007364                            		rsset	_objLvlSSTs
00007364 =00000030                  _objBModeTouch	rs.b	1				; Touched flag
00007364                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007364                            ObjBallMode:
00007364                            	;	move.l	#ObjBallMode_Main,_objAddress(a0)	; Next routine
00007364                            	;	move.l	#Map_ObjMonitor,_objMapping(a0)	; Mappings
00007364                            	;	clr.w	_objVRAM(a0)			; Tile properties
00007364                            	;	ori.b	#4,_objRender(a0)			; Render flags
00007364                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
00007364                            	;	move.b	#$10,_objDrawW(a0)			; Sprite width
00007364                            	;	move.b	#$10,_objDrawH(a0)			; Sprite height
00007364                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007364                            ObjBallMode_Main:
00007364 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00007368 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
0000736C 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
00007370 4A40                       		tst.w	d0				; ''
00007372 6700                       		beq.s	.NotTouched			; If not, branch
00007374                            
00007374 08AA 0002 000C             		bclr	#2,_objFlags(a2)
0000737A                            		
0000737A 4A28 0024                  		tst.b	_objSubtype(a0)			; Should we force Sonic out of ball mode?
0000737E 6B00                       		bmi.s	.NoBallMode			; If so, branch
00007380 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
00007382                            
00007382 4A28 0030                  		tst.b	_objBModeTouch(a0)		; Have we already been touched?
00007386 6600                       		bne.s	.End				; If so, branch
00007388 50E8 0030                  		st	_objBModeTouch(a0)		; Touched
0000738C                            
0000738C 462A 004B                  		not.b	_objBallMode(a2)		; Switch ball mode for Sonic
00007390 6700                       		beq.s	.End				; If it's not set, branch
00007392                            
00007392                            .MakeSonicRoll:
00007392 2248                       		movea.l	a0,a1				; Save a0
00007394 204A                       		movea.l	a2,a0				; Make Sonic roll
00007396 4EB8 5958                  		jsr	ObjPlayer_DoRoll		; ''
0000739A 2049                       		movea.l	a1,a0				; Restore a0
0000739C                            	nextObject
0000739C 3068 0004                M 	movea.w	_objnext(a0),a0
000073A0 2250                     M 	move.l	_objaddress(a0),a1
000073A2 4ED1                     M 	jmp	(a1)
000073A4                            
000073A4                            .NotTouched:
000073A4 4228 0030                  		clr.b	_objBModeTouch(a0)		; Not touched
000073A8                            	nextObject
000073A8 3068 0004                M 	movea.w	_objnext(a0),a0
000073AC 2250                     M 	move.l	_objaddress(a0),a1
000073AE 4ED1                     M 	jmp	(a1)
000073B0                            
000073B0                            .BallMode:
000073B0 50EA 004B                  		st	_objBallMode(a2)		; Get in to ball mode
000073B4 60DC                       		bra.s	.MakeSonicRoll			; ''
000073B6                            
000073B6                            .NoBallMode:
000073B6 422A 004B                  		clr.b	_objBallMode(a2)		; Get out of ball mode
000073BA                            
000073BA                            .End:
000073BA                            	nextObject
000073BA 3068 0004                M 	movea.w	_objnext(a0),a0
000073BE 2250                     M 	move.l	_objaddress(a0),a1
000073C0 4ED1                     M 	jmp	(a1)
000073C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073C2                            .RangeData:
000073C2 FFF0 0020                  		dc.w	-$10, $20
000073C6 FFF0 0020                  		dc.w	-$10, $20
000073CA                            ; =========================================================================================================================================================
000073CA                            		include	"Objects/Bumper/Code.asm"		; Bumper object
000073CA                            ; =========================================================================================================================================================
000073CA                            ; Water surface object
000073CA                            ; =========================================================================================================================================================
000073CA                            		rsset	_objLvlSSTs
000073CA                            
000073CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073CA                            ObjAttack:
000073CA 20BC 0000 0000             		move.l	#ObjBumperMain,_objAddress(a0)	; Next routine
000073D0 217C 0000 0000 0010        		move.l	#Map_ObjBumper,_objMapping(a0)		; Mappings
000073D8 317C 035B 000E             		move.w	#$35B,_objVRAM(a0)			; Tile properties
000073DE 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000073E4                            		displaySprite	1,a0,a1,0			; Priority
000073E4 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
000073EA 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
000073EE 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000073F2 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000073F6 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
000073FA                          M .no_278
000073FA 7210                       		moveq	#$10,d1
000073FC                            	;	move.b	d1,_objDrawW(a0)
000073FC                            	;	move.b	d1,_objColW(a0)
000073FC                            	;	move.b	d1,_objDrawH(a0)
000073FC                            	;	move.b	d1,_objColH(a0)
000073FC                            		
000073FC                            
000073FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073FC                            ObjBumperMain:
000073FC 0C68 0000 0024             		cmpi.w	#0,	_objSubtype(a0)
00007402 6700                       		beq.s	.AttackX
00007404                            		
00007404 0668 FFF6 0014             		add.w	#-10,_objXPos(a0)
0000740A 6000                       		bra.s	.cont
0000740C                            		
0000740C                            	.AttackX:
0000740C 0668 000A 0014             		add.w	#10,_objXPos(a0)
00007412                            	.cont:
00007412 5328 0017                  		subq.b	#1,	_objDrawW(a0)
00007416 4A28 0017                  		tst.b	_objDrawW(a0)
0000741A 6700 0000                  		beq.w	ObjAttack_Delete
0000741E                            		
0000741E                            	nextObject
0000741E 3068 0004                M 	movea.w	_objnext(a0),a0
00007422 2250                     M 	move.l	_objaddress(a0),a1
00007424 4ED1                     M 	jmp	(a1)
00007426                            
00007426                            ObjAttack_Delete:
00007426                            	;	playSnd	#sCheckpoint, 2			; Play checkpoint sound
00007426 4EB8 1A4C                  		jsr	DeleteObject.w
0000742A                            	nextObject
0000742A 3068 0004                M 	movea.w	_objnext(a0),a0
0000742E 2250                     M 	move.l	_objaddress(a0),a1
00007430 4ED1                     M 	jmp	(a1)
00007432                            
00007432                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007432                            ; Data
00007432                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007432                            Map_ObjBumper:
00007432                            		include	"Objects/Bumper/Mappings.asm"
00007432                            Map_eb08:
00007432 0000                       Map_eb08_0: 	dc.w Map_eb08_2-Map_eb08
00007434 0001                       Map_eb08_2: 	dc.b $0, $1
00007436 FC04 0000 FFF8             	dc.b $FC, $4, $0, $0, $FF, $F8
0000743C                            	even
0000743C                            		even
0000743C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000743C                            Ani_ObjBumper:
0000743C 0000                       		dc.w	.Ani0-Ani_ObjBumper
0000743E 0000                       		dc.w	.Ani1-Ani_ObjBumper
00007440 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
00007444 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0000744C 00                         		even
0000744C                            ; =========================================================================================================================================================
0000744C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000744C                            ; Unused/Temporary
0000744C                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
0000744C                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
0000744C                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
0000744C                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0000744C                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
0000744C                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0000744C                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
0000744C                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
0000744C                            
0000744C                            ; =========================================================================================================================================================
0000744C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000744C                            ; Object Art
0000744C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000744C                            ArtUnc_Sonic:
0000744C                            		incbin	"Graphics/Sprites/Sonic/Art.unc"
000075CC                            		even
000075CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000075CC                            ArtKosM_Bumper:
000075CC                            		incbin	"Graphics/Sprites/Bumper/Art.kosm"
000075EA                            		even
000075EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000075EA                            ArtKosM_Chkpoint:
000075EA                            		incbin	"Graphics/Sprites/Checkpoint/Art.kosm"
000076EA 00                         		even
000076EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000076EA                            ArtKosM_DrownCnt:
000076EA                            		incbin	"Graphics/Sprites/Drown Countdown/Art.kosm"
00007CBC 00                         		even
00007CBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007CBC                            ArtKosM_Explosion:
00007CBC                            		incbin	"Graphics/Sprites/Explosion/Art.kosm"
0000814E                            		even
0000814E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000814E                            ArtKosM_Monitor:
0000814E                            		incbin	"Graphics/Sprites/Monitor/Art.kosm"
00008470 00                         		even
00008470                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008470                            ArtUnc_Ring:
00008470                            		incbin	"Graphics/Sprites/Ring/Art - Ring.unc"
00008870                            		even
00008870                            
00008870                            ArtKosM_RingSparkle:
00008870                            		incbin	"Graphics/Sprites/Ring/Art - Sparkle.kosm"
000088BC 00                         		even
000088BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000088BC                            ArtKosM_SpikesN:
000088BC                            		incbin	"Graphics/Sprites/Spikes/Art - Normal.kosm"
000088FC                            		even
000088FC                            
000088FC                            ArtKosM_SpikesS:
000088FC                            		incbin	"Graphics/Sprites/Spikes/Art - Sideways.kosm"
0000893E 00                         		even
0000893E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000893E                            ArtKosM_SpringH:
0000893E                            		incbin	"Graphics/Sprites/Spring/Art - Horizontal.kosm"
00008A1A 00                         		even
00008A1A                            
00008A1A                            ArtKosM_SpringV:
00008A1A                            		incbin	"Graphics/Sprites/Spring/Art - Vertical.kosm"
00008B00 00                         		even
00008B00                            
00008B00                            ArtKosM_SpringD:
00008B00                            		incbin	"Graphics/Sprites/Spring/Art - Diagonal.kosm"
00008D1A 00                         		even
00008D1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008D1A                            ArtKosM_WaterSplash:
00008D1A                            		incbin	"Graphics/Sprites/Water Splash/Art.kosm"
0000952E                            		even
0000952E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000952E                            ArtKosM_WaterSurface:
0000952E                            		incbin	"Graphics/Sprites/Water Surface/Art.kosm"
00009688                            		even
00009688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00009688                            ArtKosM_HUD:
00009688                            		incbin	"Graphics/Sprites/HUD/Art - HUD Base.kosm"
000096FE                            		even
000096FE                            
000096FE                            ArtUnc_HUDNumbers:
000096FE                            		incbin	"Graphics/Sprites/HUD/Art - HUD Numbers.unc"
0000997E 0000 0000 0000 0000 0000+  		dcb.l	16, 0
000099BE                            		even
000099BE                            
000099BE                            ; =========================================================================================================================================================
000099BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000099BE                            ; Level data
000099BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000099BE                            ; Wacky Workbench Zone
000099BE                            
000099BE                            WWZ_FGLayout:
000099BE                            		incbin	"Zones/Wacky Workbench/Foreground.lvl"
0000A1E0                            		even
0000A1E0                            WWZ_BGLayout:
0000A1E0                            		incbin	"Zones/Wacky Workbench/Background.lvl"
0000A206                            		even
0000A206                            
0000A206 FFFF 0000 0000             		dc.w	$FFFF, 0, 0				; Null object list entry
0000A20C                            WWZ_Objects:
0000A20C                            		incbin	"Zones/Wacky Workbench/Objects.bin"
0000A218                            		even
0000A218                            WWZ_Rings:
0000A218                            		incbin	"Zones/Wacky Workbench/Rings.bin"
0000A21C                            		even
0000A21C                            WWZ_Collision:
0000A21C 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
0000A22C                            .ColData:
0000A22C                            		incbin	"Zones/Wacky Workbench/Collision.bin"
0000A82C                            		even
0000A82C                            .Angles:
0000A82C                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
0000A92C                            		even
0000A92C                            .Heights:
0000A92C                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
0000B92C                            		even
0000B92C                            .HeightsR:
0000B92C                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
0000C92C                            		even
0000C92C                            WWZ_Chunks:
0000C92C                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
0000C996                            		even
0000C996                            WWZ_Blocks:
0000C996                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
0000C9C0                            		even
0000C9C0                            WWZ_Pal:
0000C9C0 007F                       		dc.w	$100>>1-1
0000C9C2                            		incbin	"Graphics/Palettes/Wacky Workbench/Normal.pal"
0000CA42                                    WWZ_Pal_End:
0000CA42                            		incbin	"Graphics/Palettes/Wacky Workbench/Water.pal"
0000CAC2                            		even
0000CAC2                            WWZ_Tiles:
0000CAC2                            		incbin	"Graphics/Tilesets/Wacky Workbench/Tiles.kosm"
0000CB4C                            		even
0000CB4C                            ArtUnc_Electricity:
0000CB4C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electricity.unc"
0000CF4C                            		even
0000CF4C                            ArtUnc_ElectricOrbs:
0000CF4C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electric Orbs.unc"
0000D14C                            		even
0000D14C                            ArtUnc_Sirens:
0000D14C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Sirens.unc"
0000D34C                            		even
0000D34C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D34C                            
0000D34C                            ; =========================================================================================================================================================
0000D34C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D34C                            ; Sound driver
0000D34C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D34C                            		include	"Sound/amps/code/68k.asm"
0000D34C                            	opt oz+					; enable zero-offset optimization
0000D34C                            	opt l.					; local lables are dots
0000D34C                            	opt ae+					; enable automatic even's
0000D34C                            
0000D34C                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Note timout handler macro
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dNoteToutHandler	macro
0000D34C                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0000D34C                            		beq.s	.endt			; if is, do not timeout
0000D34C                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0000D34C                            		bne.s	.endt			; if still not 0, branch
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Note timout handler macro for DAC
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dNoteToutDAC	macro
0000D34C                            	dNoteToutHandler			; include timeout handler
0000D34C                            		moveq	#0,d0			; play stop sample
0000D34C                            		bra.w	dNoteOnDAC2		; ''
0000D34C                            .endt
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Note timout handler macro for FM
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dNoteToutFM	macro
0000D34C                            	dNoteToutHandler			; include timeout handler
0000D34C                            		bset	#cfbRest,(a5)		; set track to resting
0000D34C                            		bsr.w	dKeyOffFM		; key off FM
0000D34C                            		bra.\0	.next			; jump to next track
0000D34C                            .endt
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Note timout handler macro for PSG
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dNoteToutPSG	macro
0000D34C                            	dNoteToutHandler			; include timeout handler
0000D34C                            		bset	#cfbRest,(a5)		; set track to resting
0000D34C                            		bsr.w	dMutePSGmus		; mute PSG channel
0000D34C                            		bra.s	.next			; jump to next track
0000D34C                            .endt
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for calculating the current frequency (without modulation) into d6.
0000D34C                            ; Used if user wants to add extra pitch effects such as pitch slides.
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dCalcFreq	macro
0000D34C                            		move.b	cDetune(a5),d6		; get detune value to d6
0000D34C                            		ext.w	d6			; extend to word
0000D34C                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for generating frequency modulation code
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dModulate	macro jump,loop,type
0000D34C                            		btst	#cfbMod,(a5)		; check if modulation is active
0000D34C                            		beq.s	.noret			; if not, update volume and return
0000D34C                            		tst.b	cModDelay(a5)		; check if there is delay left
0000D34C                            		beq.s	.started		; if not, modulate!
0000D34C                            		subq.b	#1,cModDelay(a5)	; decrease delay
0000D34C                            .noret
0000D34C                            	if narg>0
0000D34C                            		if narg=3
0000D34C                            			if type<2
0000D34C                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D34C                            				beq.s	.noupdatevol		; if not, skip
0000D34C                            				jsr	dUpdateVolFM(pc)	; update FM volume
0000D34C                            			.noupdatevol:
0000D34C                            			endif
0000D34C                            			if type>=4
0000D34C                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D34C                            				beq.s	.noupdatevol		; if not, skip
0000D34C                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0000D34C                            			.noupdatevol:
0000D34C                            			endif
0000D34C                            			if \type<>5
0000D34C                            				dbf	d7,\loop		; loop for all channels
0000D34C                            			endif
0000D34C                            		endif
0000D34C                            		bra.w	\jump			; jump to next routine
0000D34C                            	else
0000D34C                            		bra.s	.endm			; jump to the next .endm routine
0000D34C                            	endif
0000D34C                            .started
0000D34C                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0000D34C                            		bne.s	.noret			; if there's still delay left, update vol and return
0000D34C                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0000D34C                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0000D34C                            		tst.b	cModCount(a5)		; check if this was the last step
0000D34C                            		bne.s	.norev			; if was not, do not reverse
0000D34C                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0000D34C                            		neg.b	cModStep(a5)		; negate step amount
0000D34C                            .norev
0000D34C                            		subq.b	#1,cModCount(a5)	; decrease step counter
0000D34C                            		move.b	cModStep(a5),d5		; get step offset into d5
0000D34C                            		ext.w	d5			; extend to word
0000D34C                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0000D34C                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0000D34C                            		add.w	d5,d6			; add to channel base frequency
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for processing the tracker
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dDoTracker	macro
0000D34C                            		movea.l	cData(a5),a4		; grab tracker address
0000D34C                            	if safe=1
0000D34C                            		AMPS_Debug_TrackUpd		; check if this address is valid
0000D34C                            	endif
0000D34C                            .data
0000D34C                            		moveq	#0,d5
0000D34C                            		move.b	(a4)+,d5		; get a byte from tracker
0000D34C                            		cmpi.b	#$E0,d5			; is this a command?
0000D34C                            		blo.s	.notcomm		; if not, continue
0000D34C                            		jsr	dCommands(pc)		; run the condition flag
0000D34C                            		bra.s	.data			; for most commands, use this branch to loop
0000D34C                            		bra.s	.next			; however, for example sStop will make us return here.
0000D34C                            .notcomm
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for playing a note, and setting up for it (software updates only)
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dProcNote	macro sfx, psg
0000D34C                            		move.l	a4,cData(a5)		; save tracker address
0000D34C                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0000D34C                            		btst	#cfbHold,(a5)		; check if we are holding
0000D34C                            		bne.s	.endpn			; if we are, branch
0000D34C                            	if sfx=0
0000D34C                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0000D34C                            	endif
0000D34C                            	if psg<>0
0000D34C                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0000D34C                            	endif
0000D34C                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0000D34C                            		beq.s	.endpn			; if not, branch
0000D34C                            		movea.l	cMod(a5),a1		; get modulation data address
0000D34C                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0000D34C                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0000D34C                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0000D34C                            		move.b	(a1),d0			; get number of steps
0000D34C                            		lsr.b	#1,d0			; halve it
0000D34C                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0000D34C                            		clr.w	cModFreq(a5)		; clear frequency offset
0000D34C                            .endpn
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for processing a note in DAC channel
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dTrackNoteDAC	macro
0000D34C                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0000D34C                            		bne.s	.pitch			; if so, load pitch
0000D34C                            		move.b	d5,cSample(a5)		; else, save as a sample
0000D34C                            		bra.s	.cont
0000D34C                            .pitch
0000D34C                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000D34C                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0000D34C                            		moveq	#0,d0			; play stop sample
0000D34C                            		bsr.w	dNoteOnDAC2		; ''
0000D34C                            		moveq	#-$80,d6		; tell the code we are resting
0000D34C                            		bra.s	.cont
0000D34C                            .noprest
0000D34C                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D34C                            		add.w	d5,d5			; double offset (each entry is a word)
0000D34C                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0000D34C                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000D34C                            .cont
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for doing keying-on FM channel
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dKeyOnFM	macro
0000D34C                            		btst	#cfbHold,(a5)		; check if note is held
0000D34C                            		bne.s	.k			; if so, do not note on
0000D34C                            		btst	#cfbRest,(a5)		; check if channel is resting
0000D34C                            		bne.s	.k			; if so, do not note on
0000D34C                            	if narg=0
0000D34C                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0000D34C                            		bne.s	.k			; if so, do not note on
0000D34C                            	endif
0000D34C                            		moveq	#$28,d0			; YM command: Key on
0000D34C                            		move.b	cType(a5),d1		; get channel type bits
0000D34C                            		ori.b	#$F0,d1			; turn all FM operators on
0000D34C                            		bsr.w	WriteYM_Pt1		; send note-on event
0000D34C                            .k
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Macro for processing a note in PSG channel
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            dGetFreqPSG	macro
0000D34C                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0000D34C                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0000D34C                            		bset	#cfbRest,(a5)		; set channel to resting
0000D34C                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0000D34C                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0000D34C                            		bra.s	.freqgot
0000D34C                            .norest
0000D34C                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D34C                            		andi.w	#$7F,d5			; keep within $80 notes
0000D34C                            		add.w	d5,d5			; double offset (each entry is a word)
0000D34C                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0000D34C                            	if safe=1
0000D34C                            		AMPS_Debug_NotePSG		; check if the note was valid
0000D34C                            	endif
0000D34C                            .freqgot
0000D34C                                endm
0000D34C                            ; ===========================================================================
0000D34C                            	include "Sound/amps/code/debug.asm"	; debug data blob
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; write channel string to console
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            AMPS_Debug_GetChannel	macro
0000D34C                            	cmp.w	#mPSG1,a5
0000D34C                            	bne.s	AMPS_Debug_Writepsg2
0000D34C                            	Console.Write "PSG1"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writepsg2
0000D34C                            	cmp.w	#mPSG2,a5
0000D34C                            	bne.s	AMPS_Debug_Writepsg3
0000D34C                            	Console.Write "PSG2"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writepsg3
0000D34C                            	cmp.w	#mPSG3,a5
0000D34C                            	bne.s	AMPS_Debug_Writepsgs1
0000D34C                            	Console.Write "PSG3"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writepsgs1
0000D34C                            	cmp.w	#mSFXPSG1,a5
0000D34C                            	bne.s	AMPS_Debug_Writepsgs2
0000D34C                            	Console.Write "SFX PSG1"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writepsgs2
0000D34C                            	cmp.w	#mSFXPSG2,a5
0000D34C                            	bne.s	AMPS_Debug_Writepsgs3
0000D34C                            	Console.Write "SFX PSG2"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writepsgs3
0000D34C                            	cmp.w	#mSFXPSG3,a5
0000D34C                            	bne.s	AMPS_Debug_Writedacs1
0000D34C                            	Console.Write "SFX PSG3"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writedacs1
0000D34C                            	cmp.w	#mSFXDAC1,a5
0000D34C                            	bne.s	AMPS_Debug_Writedac1
0000D34C                            	Console.Write "SFX DAC1"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writedac1
0000D34C                            	cmp.w	#mDAC1,a5
0000D34C                            	bne.s	AMPS_Debug_Writedac2
0000D34C                            	Console.Write "DAC1"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writedac2
0000D34C                            	cmp.w	#mDAC2,a5
0000D34C                            	bne.s	AMPS_Debug_Writefm1
0000D34C                            	Console.Write "DAC2"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefm1
0000D34C                            	cmp.w	#mFM1,a5
0000D34C                            	bne.s	AMPS_Debug_Writefm2
0000D34C                            	Console.Write "FM1"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefm2
0000D34C                            	cmp.w	#mFM2,a5
0000D34C                            	bne.s	AMPS_Debug_Writefm3
0000D34C                            	Console.Write "FM2"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefm3
0000D34C                            	cmp.w	#mFM3,a5
0000D34C                            	bne.s	AMPS_Debug_Writefm4
0000D34C                            	Console.Write "FM3"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefm4
0000D34C                            	cmp.w	#mFM4,a5
0000D34C                            	bne.s	AMPS_Debug_Writefm5
0000D34C                            	Console.Write "FM4"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefm5
0000D34C                            	cmp.w	#mFM5,a5
0000D34C                            	bne.s	AMPS_Debug_Writefms3
0000D34C                            	Console.Write "FM5"
0000D34C                            	bra.w	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefms3
0000D34C                            	cmp.w	#mSFXFM3,a5
0000D34C                            	bne.s	AMPS_Debug_Writefms4
0000D34C                            	Console.Write "SFX FM3"
0000D34C                            	rts
0000D34C                            AMPS_Debug_Writefms4
0000D34C                            	cmp.w	#mSFXFM4,a5
0000D34C                            	bne.s	AMPS_Debug_Writefms5
0000D34C                            	Console.Write "SFX FM4"
0000D34C                            	bra.s	AMPS_Debug_Writeend
0000D34C                            AMPS_Debug_Writefms5
0000D34C                            	cmp.w	#mSFXFM5,a5
0000D34C                            	beq.s	AMPS_Debug_Writefms5_
0000D34C                            AMPS_Debug_Writeaddr
0000D34C                            	Console.Write "%<fpal2>%<.l a5>"
0000D34C                            	rts
0000D34C                            AMPS_Debug_Writefms5_
0000D34C                            	Console.Write "SFX FM5"
0000D34C                            AMPS_Debug_Writeend
0000D34C                            	endm
0000D34C                            ; ===========================================================================
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            ; Channel console code
0000D34C                            ; ---------------------------------------------------------------------------
0000D34C                            
0000D34C                            AMPS_Debug_Console_Channel:
0000D34C                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34C 40E7                     M 	move.w	sr,-(sp)
0000D34E                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =00000000                M 	__stack:set	0
0000D34E =00000000                M 	__sp:	set 0
0000D34E                          M 	while	(__pos)
0000D34E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =0000000A                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =00000016                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =0000001E                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	pushp	"move.l d0,-(sp)"
0000D34E =00000001                M 	__stack:	= __stack+1
0000D34E =00000004                M 	__sp:	= __sp+4
0000D34E =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =00000028                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =00000034                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D34E =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D34E =0000003C                M 	__midpos:	= __endpos
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D34E                          M 	pushp	"move.l a0,-(sp)"
0000D34E =00000002                M 	__stack:	= __stack+1
0000D34E =00000008                M 	__sp:	= __sp+4
0000D34E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D34E                          M 	rept	__stack
0000D34E                          M 	popp	__command
0000D34E 2F08                     M 	move.l	a0,-(sp)
0000D350                          M 	popp	__command
0000D350 2F00                     M 	move.l	d0,-(sp)
0000D352 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D356 45EF 0010                M 	lea	4*4(sp),a2
0000D35A 43FA 0000                M 	lea	.str_281(pc),a1
0000D35E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D364 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D368 504F                     M 	addq.w	#__sp,sp
0000D36A 46DF                     M 	move.w	(sp)+,sr
0000D36C 6000 0000                M 	bra.w	.instr_end_281
0000D370                          M 	.str_281:
0000D370                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D370 =00000001                M 	__lpos:	set 1
0000D370 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D370                          M 	while	(__pos)
0000D370                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D370 2020                     M 	dc.b	"  "
0000D372 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D372 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D372 =0000000A                M 	__midpos:	= __endpos
0000D372                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D372                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D372 E8                       M 	dc.b	fpal0
0000D373 =0000000B                M 	__lpos:	set __endpos+1
0000D373 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D373                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D373 6430 3A20                M 	dc.b	"d0: "
0000D377 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D377 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D377 =00000016                M 	__midpos:	= __endpos
0000D377                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D377                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D377 EC                       M 	dc.b	fpal2
0000D378 =00000017                M 	__lpos:	set __endpos+1
0000D378 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D378                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D378                          M 	dc.b	""
0000D378 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D378 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D378 =0000001E                M 	__midpos:	= __endpos
0000D378                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D378                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D378                          M 	__param:	substr ,,"hex"
0000D378 83                       M 	dc.b	hex|3
0000D379 =0000001F                M 	__lpos:	set __endpos+1
0000D379 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D379                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D379 2020                     M 	dc.b	"  "
0000D37B =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D37B =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D37B =00000028                M 	__midpos:	= __endpos
0000D37B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D37B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D37B E8                       M 	dc.b	fpal0
0000D37C =00000029                M 	__lpos:	set __endpos+1
0000D37C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D37C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D37C 6130 3A20                M 	dc.b	"a0: "
0000D380 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D380 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D380 =00000034                M 	__midpos:	= __endpos
0000D380                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D380                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D380 EC                       M 	dc.b	fpal2
0000D381 =00000035                M 	__lpos:	set __endpos+1
0000D381 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D381                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D381                          M 	dc.b	""
0000D381 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D381 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D381 =0000003C                M 	__midpos:	= __endpos
0000D381                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D381                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D381                          M 	__param:	substr ,,"hex"
0000D381 83                       M 	dc.b	hex|3
0000D382 =0000003D                M 	__lpos:	set __endpos+1
0000D382 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D382                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D382                          M 	dc.b	""
0000D382 00                       M 	dc.b	0
0000D384 00                       M 	even
0000D384                          M 	.instr_end_281:
0000D384                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D384 40E7                     M 	move.w	sr,-(sp)
0000D386                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =00000000                M 	__stack:set	0
0000D386 =00000000                M 	__sp:	set 0
0000D386                          M 	while	(__pos)
0000D386 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =0000000A                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =00000016                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =0000001E                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	pushp	"move.l d1,-(sp)"
0000D386 =00000001                M 	__stack:	= __stack+1
0000D386 =00000004                M 	__sp:	= __sp+4
0000D386 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =00000028                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =00000034                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D386 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D386 =0000003C                M 	__midpos:	= __endpos
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D386                          M 	pushp	"move.l a1,-(sp)"
0000D386 =00000002                M 	__stack:	= __stack+1
0000D386 =00000008                M 	__sp:	= __sp+4
0000D386 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D386                          M 	rept	__stack
0000D386                          M 	popp	__command
0000D386 2F09                     M 	move.l	a1,-(sp)
0000D388                          M 	popp	__command
0000D388 2F01                     M 	move.l	d1,-(sp)
0000D38A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D38E 45EF 0010                M 	lea	4*4(sp),a2
0000D392 43FA 0000                M 	lea	.str_284(pc),a1
0000D396 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D39C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3A0 504F                     M 	addq.w	#__sp,sp
0000D3A2 46DF                     M 	move.w	(sp)+,sr
0000D3A4 6000 0000                M 	bra.w	.instr_end_284
0000D3A8                          M 	.str_284:
0000D3A8                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3A8 =00000001                M 	__lpos:	set 1
0000D3A8 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3A8                          M 	while	(__pos)
0000D3A8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3A8 2020                     M 	dc.b	"  "
0000D3AA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3AA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3AA =0000000A                M 	__midpos:	= __endpos
0000D3AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3AA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3AA E8                       M 	dc.b	fpal0
0000D3AB =0000000B                M 	__lpos:	set __endpos+1
0000D3AB =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3AB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3AB 6431 3A20                M 	dc.b	"d1: "
0000D3AF =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3AF =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3AF =00000016                M 	__midpos:	= __endpos
0000D3AF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3AF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3AF EC                       M 	dc.b	fpal2
0000D3B0 =00000017                M 	__lpos:	set __endpos+1
0000D3B0 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3B0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B0                          M 	dc.b	""
0000D3B0 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3B0 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3B0 =0000001E                M 	__midpos:	= __endpos
0000D3B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B0                          M 	__param:	substr ,,"hex"
0000D3B0 83                       M 	dc.b	hex|3
0000D3B1 =0000001F                M 	__lpos:	set __endpos+1
0000D3B1 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3B1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B1 2020                     M 	dc.b	"  "
0000D3B3 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3B3 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3B3 =00000028                M 	__midpos:	= __endpos
0000D3B3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B3 E8                       M 	dc.b	fpal0
0000D3B4 =00000029                M 	__lpos:	set __endpos+1
0000D3B4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3B4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B4 6131 3A20                M 	dc.b	"a1: "
0000D3B8 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3B8 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3B8 =00000034                M 	__midpos:	= __endpos
0000D3B8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B8 EC                       M 	dc.b	fpal2
0000D3B9 =00000035                M 	__lpos:	set __endpos+1
0000D3B9 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3B9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B9                          M 	dc.b	""
0000D3B9 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D3B9 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D3B9 =0000003C                M 	__midpos:	= __endpos
0000D3B9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B9                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3B9                          M 	__param:	substr ,,"hex"
0000D3B9 83                       M 	dc.b	hex|3
0000D3BA =0000003D                M 	__lpos:	set __endpos+1
0000D3BA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D3BA                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D3BA                          M 	dc.b	""
0000D3BA 00                       M 	dc.b	0
0000D3BC 00                       M 	even
0000D3BC                          M 	.instr_end_284:
0000D3BC                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BC 40E7                     M 	move.w	sr,-(sp)
0000D3BE                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =00000000                M 	__stack:set	0
0000D3BE =00000000                M 	__sp:	set 0
0000D3BE                          M 	while	(__pos)
0000D3BE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =0000000A                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =00000016                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =0000001E                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	pushp	"move.l d2,-(sp)"
0000D3BE =00000001                M 	__stack:	= __stack+1
0000D3BE =00000004                M 	__sp:	= __sp+4
0000D3BE =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =00000028                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =00000034                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3BE =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3BE =0000003C                M 	__midpos:	= __endpos
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3BE                          M 	pushp	"move.l a2,-(sp)"
0000D3BE =00000002                M 	__stack:	= __stack+1
0000D3BE =00000008                M 	__sp:	= __sp+4
0000D3BE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3BE                          M 	rept	__stack
0000D3BE                          M 	popp	__command
0000D3BE 2F0A                     M 	move.l	a2,-(sp)
0000D3C0                          M 	popp	__command
0000D3C0 2F02                     M 	move.l	d2,-(sp)
0000D3C2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3C6 45EF 0010                M 	lea	4*4(sp),a2
0000D3CA 43FA 0000                M 	lea	.str_287(pc),a1
0000D3CE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D3D4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3D8 504F                     M 	addq.w	#__sp,sp
0000D3DA 46DF                     M 	move.w	(sp)+,sr
0000D3DC 6000 0000                M 	bra.w	.instr_end_287
0000D3E0                          M 	.str_287:
0000D3E0                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E0 =00000001                M 	__lpos:	set 1
0000D3E0 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3E0                          M 	while	(__pos)
0000D3E0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E0 2020                     M 	dc.b	"  "
0000D3E2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3E2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3E2 =0000000A                M 	__midpos:	= __endpos
0000D3E2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E2 E8                       M 	dc.b	fpal0
0000D3E3 =0000000B                M 	__lpos:	set __endpos+1
0000D3E3 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3E3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E3 6432 3A20                M 	dc.b	"d2: "
0000D3E7 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3E7 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3E7 =00000016                M 	__midpos:	= __endpos
0000D3E7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E7 EC                       M 	dc.b	fpal2
0000D3E8 =00000017                M 	__lpos:	set __endpos+1
0000D3E8 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3E8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E8                          M 	dc.b	""
0000D3E8 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3E8 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3E8 =0000001E                M 	__midpos:	= __endpos
0000D3E8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E8                          M 	__param:	substr ,,"hex"
0000D3E8 83                       M 	dc.b	hex|3
0000D3E9 =0000001F                M 	__lpos:	set __endpos+1
0000D3E9 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3E9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3E9 2020                     M 	dc.b	"  "
0000D3EB =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3EB =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3EB =00000028                M 	__midpos:	= __endpos
0000D3EB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3EB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3EB E8                       M 	dc.b	fpal0
0000D3EC =00000029                M 	__lpos:	set __endpos+1
0000D3EC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3EC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3EC 6132 3A20                M 	dc.b	"a2: "
0000D3F0 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3F0 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3F0 =00000034                M 	__midpos:	= __endpos
0000D3F0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F0 EC                       M 	dc.b	fpal2
0000D3F1 =00000035                M 	__lpos:	set __endpos+1
0000D3F1 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3F1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F1                          M 	dc.b	""
0000D3F1 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D3F1 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D3F1 =0000003C                M 	__midpos:	= __endpos
0000D3F1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F1                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F1                          M 	__param:	substr ,,"hex"
0000D3F1 83                       M 	dc.b	hex|3
0000D3F2 =0000003D                M 	__lpos:	set __endpos+1
0000D3F2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D3F2                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D3F2                          M 	dc.b	""
0000D3F2 00                       M 	dc.b	0
0000D3F4 00                       M 	even
0000D3F4                          M 	.instr_end_287:
0000D3F4                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F4 40E7                     M 	move.w	sr,-(sp)
0000D3F6                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =00000000                M 	__stack:set	0
0000D3F6 =00000000                M 	__sp:	set 0
0000D3F6                          M 	while	(__pos)
0000D3F6 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =0000000A                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =00000016                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =0000001E                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	pushp	"move.l d3,-(sp)"
0000D3F6 =00000001                M 	__stack:	= __stack+1
0000D3F6 =00000004                M 	__sp:	= __sp+4
0000D3F6 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =00000028                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =00000034                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D3F6 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D3F6 =0000003C                M 	__midpos:	= __endpos
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D3F6                          M 	pushp	"move.l a3,-(sp)"
0000D3F6 =00000002                M 	__stack:	= __stack+1
0000D3F6 =00000008                M 	__sp:	= __sp+4
0000D3F6 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D3F6                          M 	rept	__stack
0000D3F6                          M 	popp	__command
0000D3F6 2F0B                     M 	move.l	a3,-(sp)
0000D3F8                          M 	popp	__command
0000D3F8 2F03                     M 	move.l	d3,-(sp)
0000D3FA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3FE 45EF 0010                M 	lea	4*4(sp),a2
0000D402 43FA 0000                M 	lea	.str_290(pc),a1
0000D406 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D40C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D410 504F                     M 	addq.w	#__sp,sp
0000D412 46DF                     M 	move.w	(sp)+,sr
0000D414 6000 0000                M 	bra.w	.instr_end_290
0000D418                          M 	.str_290:
0000D418                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D418 =00000001                M 	__lpos:	set 1
0000D418 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D418                          M 	while	(__pos)
0000D418                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D418 2020                     M 	dc.b	"  "
0000D41A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D41A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D41A =0000000A                M 	__midpos:	= __endpos
0000D41A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D41A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D41A E8                       M 	dc.b	fpal0
0000D41B =0000000B                M 	__lpos:	set __endpos+1
0000D41B =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D41B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D41B 6433 3A20                M 	dc.b	"d3: "
0000D41F =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D41F =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D41F =00000016                M 	__midpos:	= __endpos
0000D41F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D41F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D41F EC                       M 	dc.b	fpal2
0000D420 =00000017                M 	__lpos:	set __endpos+1
0000D420 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D420                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D420                          M 	dc.b	""
0000D420 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D420 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D420 =0000001E                M 	__midpos:	= __endpos
0000D420                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D420                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D420                          M 	__param:	substr ,,"hex"
0000D420 83                       M 	dc.b	hex|3
0000D421 =0000001F                M 	__lpos:	set __endpos+1
0000D421 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D421                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D421 2020                     M 	dc.b	"  "
0000D423 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D423 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D423 =00000028                M 	__midpos:	= __endpos
0000D423                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D423                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D423 E8                       M 	dc.b	fpal0
0000D424 =00000029                M 	__lpos:	set __endpos+1
0000D424 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D424                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D424 6133 3A20                M 	dc.b	"a3: "
0000D428 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D428 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D428 =00000034                M 	__midpos:	= __endpos
0000D428                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D428                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D428 EC                       M 	dc.b	fpal2
0000D429 =00000035                M 	__lpos:	set __endpos+1
0000D429 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D429                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D429                          M 	dc.b	""
0000D429 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D429 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D429 =0000003C                M 	__midpos:	= __endpos
0000D429                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D429                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D429                          M 	__param:	substr ,,"hex"
0000D429 83                       M 	dc.b	hex|3
0000D42A =0000003D                M 	__lpos:	set __endpos+1
0000D42A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D42A                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D42A                          M 	dc.b	""
0000D42A 00                       M 	dc.b	0
0000D42C 00                       M 	even
0000D42C                          M 	.instr_end_290:
0000D42C                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42C 40E7                     M 	move.w	sr,-(sp)
0000D42E                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =00000000                M 	__stack:set	0
0000D42E =00000000                M 	__sp:	set 0
0000D42E                          M 	while	(__pos)
0000D42E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =0000000A                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =00000016                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =0000001E                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	pushp	"move.l d4,-(sp)"
0000D42E =00000001                M 	__stack:	= __stack+1
0000D42E =00000004                M 	__sp:	= __sp+4
0000D42E =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =00000028                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =00000034                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D42E =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D42E =0000003C                M 	__midpos:	= __endpos
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D42E                          M 	pushp	"move.l a4,-(sp)"
0000D42E =00000002                M 	__stack:	= __stack+1
0000D42E =00000008                M 	__sp:	= __sp+4
0000D42E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D42E                          M 	rept	__stack
0000D42E                          M 	popp	__command
0000D42E 2F0C                     M 	move.l	a4,-(sp)
0000D430                          M 	popp	__command
0000D430 2F04                     M 	move.l	d4,-(sp)
0000D432 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D436 45EF 0010                M 	lea	4*4(sp),a2
0000D43A 43FA 0000                M 	lea	.str_293(pc),a1
0000D43E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D444 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D448 504F                     M 	addq.w	#__sp,sp
0000D44A 46DF                     M 	move.w	(sp)+,sr
0000D44C 6000 0000                M 	bra.w	.instr_end_293
0000D450                          M 	.str_293:
0000D450                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D450 =00000001                M 	__lpos:	set 1
0000D450 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D450                          M 	while	(__pos)
0000D450                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D450 2020                     M 	dc.b	"  "
0000D452 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D452 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D452 =0000000A                M 	__midpos:	= __endpos
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D452 E8                       M 	dc.b	fpal0
0000D453 =0000000B                M 	__lpos:	set __endpos+1
0000D453 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D453                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D453 6434 3A20                M 	dc.b	"d4: "
0000D457 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D457 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D457 =00000016                M 	__midpos:	= __endpos
0000D457                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D457                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D457 EC                       M 	dc.b	fpal2
0000D458 =00000017                M 	__lpos:	set __endpos+1
0000D458 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D458                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D458                          M 	dc.b	""
0000D458 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D458 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D458 =0000001E                M 	__midpos:	= __endpos
0000D458                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D458                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D458                          M 	__param:	substr ,,"hex"
0000D458 83                       M 	dc.b	hex|3
0000D459 =0000001F                M 	__lpos:	set __endpos+1
0000D459 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D459                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D459 2020                     M 	dc.b	"  "
0000D45B =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D45B =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D45B =00000028                M 	__midpos:	= __endpos
0000D45B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D45B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D45B E8                       M 	dc.b	fpal0
0000D45C =00000029                M 	__lpos:	set __endpos+1
0000D45C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D45C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D45C 6134 3A20                M 	dc.b	"a4: "
0000D460 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D460 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D460 =00000034                M 	__midpos:	= __endpos
0000D460                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D460                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D460 EC                       M 	dc.b	fpal2
0000D461 =00000035                M 	__lpos:	set __endpos+1
0000D461 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D461                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D461                          M 	dc.b	""
0000D461 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D461 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D461 =0000003C                M 	__midpos:	= __endpos
0000D461                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D461                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D461                          M 	__param:	substr ,,"hex"
0000D461 83                       M 	dc.b	hex|3
0000D462 =0000003D                M 	__lpos:	set __endpos+1
0000D462 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D462                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D462                          M 	dc.b	""
0000D462 00                       M 	dc.b	0
0000D464 00                       M 	even
0000D464                          M 	.instr_end_293:
0000D464                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D464 40E7                     M 	move.w	sr,-(sp)
0000D466                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =00000000                M 	__stack:set	0
0000D466 =00000000                M 	__sp:	set 0
0000D466                          M 	while	(__pos)
0000D466 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =0000000A                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =00000016                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =0000001E                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	pushp	"move.l d5,-(sp)"
0000D466 =00000001                M 	__stack:	= __stack+1
0000D466 =00000004                M 	__sp:	= __sp+4
0000D466 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =00000028                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =00000034                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D466 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D466 =0000003C                M 	__midpos:	= __endpos
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D466                          M 	pushp	"move.l a5,-(sp)"
0000D466 =00000002                M 	__stack:	= __stack+1
0000D466 =00000008                M 	__sp:	= __sp+4
0000D466 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D466                          M 	rept	__stack
0000D466                          M 	popp	__command
0000D466 2F0D                     M 	move.l	a5,-(sp)
0000D468                          M 	popp	__command
0000D468 2F05                     M 	move.l	d5,-(sp)
0000D46A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D46E 45EF 0010                M 	lea	4*4(sp),a2
0000D472 43FA 0000                M 	lea	.str_296(pc),a1
0000D476 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D47C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D480 504F                     M 	addq.w	#__sp,sp
0000D482 46DF                     M 	move.w	(sp)+,sr
0000D484 6000 0000                M 	bra.w	.instr_end_296
0000D488                          M 	.str_296:
0000D488                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D488 =00000001                M 	__lpos:	set 1
0000D488 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D488                          M 	while	(__pos)
0000D488                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D488 2020                     M 	dc.b	"  "
0000D48A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D48A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D48A =0000000A                M 	__midpos:	= __endpos
0000D48A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D48A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D48A E8                       M 	dc.b	fpal0
0000D48B =0000000B                M 	__lpos:	set __endpos+1
0000D48B =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D48B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D48B 6435 3A20                M 	dc.b	"d5: "
0000D48F =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D48F =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D48F =00000016                M 	__midpos:	= __endpos
0000D48F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D48F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D48F EC                       M 	dc.b	fpal2
0000D490 =00000017                M 	__lpos:	set __endpos+1
0000D490 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D490                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D490                          M 	dc.b	""
0000D490 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D490 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D490 =0000001E                M 	__midpos:	= __endpos
0000D490                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D490                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D490                          M 	__param:	substr ,,"hex"
0000D490 83                       M 	dc.b	hex|3
0000D491 =0000001F                M 	__lpos:	set __endpos+1
0000D491 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D491                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D491 2020                     M 	dc.b	"  "
0000D493 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D493 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D493 =00000028                M 	__midpos:	= __endpos
0000D493                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D493                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D493 E8                       M 	dc.b	fpal0
0000D494 =00000029                M 	__lpos:	set __endpos+1
0000D494 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D494                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D494 6135 3A20                M 	dc.b	"a5: "
0000D498 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D498 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D498 =00000034                M 	__midpos:	= __endpos
0000D498                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D498                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D498 EC                       M 	dc.b	fpal2
0000D499 =00000035                M 	__lpos:	set __endpos+1
0000D499 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D499                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D499                          M 	dc.b	""
0000D499 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D499 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D499 =0000003C                M 	__midpos:	= __endpos
0000D499                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D499                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D499                          M 	__param:	substr ,,"hex"
0000D499 83                       M 	dc.b	hex|3
0000D49A =0000003D                M 	__lpos:	set __endpos+1
0000D49A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D49A                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D49A                          M 	dc.b	""
0000D49A 00                       M 	dc.b	0
0000D49C 00                       M 	even
0000D49C                          M 	.instr_end_296:
0000D49C                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49C 40E7                     M 	move.w	sr,-(sp)
0000D49E                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =00000000                M 	__stack:set	0
0000D49E =00000000                M 	__sp:	set 0
0000D49E                          M 	while	(__pos)
0000D49E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =0000000A                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =00000016                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =0000001E                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	pushp	"move.l d6,-(sp)"
0000D49E =00000001                M 	__stack:	= __stack+1
0000D49E =00000004                M 	__sp:	= __sp+4
0000D49E =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =00000028                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =00000034                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D49E =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D49E =0000003C                M 	__midpos:	= __endpos
0000D49E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D49E                          M 	pushp	"move.l a6,-(sp)"
0000D49E =00000002                M 	__stack:	= __stack+1
0000D49E =00000008                M 	__sp:	= __sp+4
0000D49E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D49E                          M 	rept	__stack
0000D49E                          M 	popp	__command
0000D49E 2F0E                     M 	move.l	a6,-(sp)
0000D4A0                          M 	popp	__command
0000D4A0 2F06                     M 	move.l	d6,-(sp)
0000D4A2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4A6 45EF 0010                M 	lea	4*4(sp),a2
0000D4AA 43FA 0000                M 	lea	.str_299(pc),a1
0000D4AE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D4B4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4B8 504F                     M 	addq.w	#__sp,sp
0000D4BA 46DF                     M 	move.w	(sp)+,sr
0000D4BC 6000 0000                M 	bra.w	.instr_end_299
0000D4C0                          M 	.str_299:
0000D4C0                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C0 =00000001                M 	__lpos:	set 1
0000D4C0 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4C0                          M 	while	(__pos)
0000D4C0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C0 2020                     M 	dc.b	"  "
0000D4C2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4C2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4C2 =0000000A                M 	__midpos:	= __endpos
0000D4C2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C2 E8                       M 	dc.b	fpal0
0000D4C3 =0000000B                M 	__lpos:	set __endpos+1
0000D4C3 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4C3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C3 6436 3A20                M 	dc.b	"d6: "
0000D4C7 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4C7 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4C7 =00000016                M 	__midpos:	= __endpos
0000D4C7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C7 EC                       M 	dc.b	fpal2
0000D4C8 =00000017                M 	__lpos:	set __endpos+1
0000D4C8 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4C8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C8                          M 	dc.b	""
0000D4C8 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4C8 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4C8 =0000001E                M 	__midpos:	= __endpos
0000D4C8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C8                          M 	__param:	substr ,,"hex"
0000D4C8 83                       M 	dc.b	hex|3
0000D4C9 =0000001F                M 	__lpos:	set __endpos+1
0000D4C9 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4C9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4C9 2020                     M 	dc.b	"  "
0000D4CB =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4CB =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4CB =00000028                M 	__midpos:	= __endpos
0000D4CB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4CB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4CB E8                       M 	dc.b	fpal0
0000D4CC =00000029                M 	__lpos:	set __endpos+1
0000D4CC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4CC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4CC 6136 3A20                M 	dc.b	"a6: "
0000D4D0 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4D0 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4D0 =00000034                M 	__midpos:	= __endpos
0000D4D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D0 EC                       M 	dc.b	fpal2
0000D4D1 =00000035                M 	__lpos:	set __endpos+1
0000D4D1 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4D1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D1                          M 	dc.b	""
0000D4D1 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D4D1 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D4D1 =0000003C                M 	__midpos:	= __endpos
0000D4D1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D1                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D1                          M 	__param:	substr ,,"hex"
0000D4D1 83                       M 	dc.b	hex|3
0000D4D2 =0000003D                M 	__lpos:	set __endpos+1
0000D4D2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D4D2                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D4D2                          M 	dc.b	""
0000D4D2 00                       M 	dc.b	0
0000D4D4 00                       M 	even
0000D4D4                          M 	.instr_end_299:
0000D4D4                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D4 40E7                     M 	move.w	sr,-(sp)
0000D4D6                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =00000000                M 	__stack:set	0
0000D4D6 =00000000                M 	__sp:	set 0
0000D4D6                          M 	while	(__pos)
0000D4D6 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =0000000A                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =00000016                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =0000001E                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	pushp	"move.l d7,-(sp)"
0000D4D6 =00000001                M 	__stack:	= __stack+1
0000D4D6 =00000004                M 	__sp:	= __sp+4
0000D4D6 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =00000028                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =00000034                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4D6 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4D6 =0000003C                M 	__midpos:	= __endpos
0000D4D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4D6                          M 	pushp	"move.l a7,-(sp)"
0000D4D6 =00000002                M 	__stack:	= __stack+1
0000D4D6 =00000008                M 	__sp:	= __sp+4
0000D4D6 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4D6                          M 	rept	__stack
0000D4D6                          M 	popp	__command
0000D4D6 2F0F                     M 	move.l	a7,-(sp)
0000D4D8                          M 	popp	__command
0000D4D8 2F07                     M 	move.l	d7,-(sp)
0000D4DA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4DE 45EF 0010                M 	lea	4*4(sp),a2
0000D4E2 43FA 0000                M 	lea	.str_302(pc),a1
0000D4E6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D4EC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4F0 504F                     M 	addq.w	#__sp,sp
0000D4F2 46DF                     M 	move.w	(sp)+,sr
0000D4F4 6000 0000                M 	bra.w	.instr_end_302
0000D4F8                          M 	.str_302:
0000D4F8                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4F8 =00000001                M 	__lpos:	set 1
0000D4F8 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4F8                          M 	while	(__pos)
0000D4F8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4F8 2020                     M 	dc.b	"  "
0000D4FA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4FA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4FA =0000000A                M 	__midpos:	= __endpos
0000D4FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4FA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4FA E8                       M 	dc.b	fpal0
0000D4FB =0000000B                M 	__lpos:	set __endpos+1
0000D4FB =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D4FB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4FB 6437 3A20                M 	dc.b	"d7: "
0000D4FF =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D4FF =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D4FF =00000016                M 	__midpos:	= __endpos
0000D4FF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4FF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D4FF EC                       M 	dc.b	fpal2
0000D500 =00000017                M 	__lpos:	set __endpos+1
0000D500 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D500                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D500                          M 	dc.b	""
0000D500 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D500 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D500 =0000001E                M 	__midpos:	= __endpos
0000D500                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D500                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D500                          M 	__param:	substr ,,"hex"
0000D500 83                       M 	dc.b	hex|3
0000D501 =0000001F                M 	__lpos:	set __endpos+1
0000D501 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D501                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D501 2020                     M 	dc.b	"  "
0000D503 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D503 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D503 =00000028                M 	__midpos:	= __endpos
0000D503                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D503                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D503 E8                       M 	dc.b	fpal0
0000D504 =00000029                M 	__lpos:	set __endpos+1
0000D504 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D504                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D504 7370 3A20                M 	dc.b	"sp: "
0000D508 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D508 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D508 =00000034                M 	__midpos:	= __endpos
0000D508                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D508                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D508 EC                       M 	dc.b	fpal2
0000D509 =00000035                M 	__lpos:	set __endpos+1
0000D509 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D509                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D509                          M 	dc.b	""
0000D509 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D509 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D509 =0000003C                M 	__midpos:	= __endpos
0000D509                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D509                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D509                          M 	__param:	substr ,,"hex"
0000D509 83                       M 	dc.b	hex|3
0000D50A =0000003D                M 	__lpos:	set __endpos+1
0000D50A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D50A                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D50A                          M 	dc.b	""
0000D50A 00                       M 	dc.b	0
0000D50C 00                       M 	even
0000D50C                          M 	.instr_end_302:
0000D50C                            	Console.BreakLine
0000D50C 40E7                     M 	move.w	sr,-(sp)
0000D50E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D514 46DF                     M 	move.w	(sp)+,sr
0000D516                            
0000D516                            	Console.Write "%<fpal1>Channel: %<fpal0>"
0000D516 40E7                     M 	move.w	sr,-(sp)
0000D518                          M 	__fstring_generateargumentscode	"%<fpal1>Channel: %<fpal0>"
0000D518 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D518 =00000000                M 	__stack:set	0
0000D518 =00000000                M 	__sp:	set 0
0000D518                          M 	while	(__pos)
0000D518 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D518 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D518 =00000008                M 	__midpos:	= __endpos
0000D518                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D518                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D518 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D518 =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D518 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D518 =00000019                M 	__midpos:	= __endpos
0000D518                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D518                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D518 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D518                          M 	rept	__stack
0000D518 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D51C 43FA 0000                M 	lea	.str_306(pc),a1
0000D520 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D526 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D52A 46DF                     M 	move.w	(sp)+,sr
0000D52C 6000 0000                M 	bra.w	.instr_end_306
0000D530                          M 	.str_306:
0000D530                          M 	__fstring_generatedecodedstring	"%<fpal1>Channel: %<fpal0>"
0000D530 =00000001                M 	__lpos:	set 1
0000D530 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D530                          M 	while	(__pos)
0000D530                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D530                          M 	dc.b	""
0000D530 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D530 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D530 =00000008                M 	__midpos:	= __endpos
0000D530                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D530                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D530 EA                       M 	dc.b	fpal1
0000D531 =00000009                M 	__lpos:	set __endpos+1
0000D531 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D531                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D531 4368 616E 6E65 6C3A 20   M 	dc.b	"Channel: "
0000D53A =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D53A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D53A =00000019                M 	__midpos:	= __endpos
0000D53A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D53A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D53A E8                       M 	dc.b	fpal0
0000D53B =0000001A                M 	__lpos:	set __endpos+1
0000D53B =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D53B                          M 	__substr:	substr __lpos,,"%<fpal1>Channel: %<fpal0>"
0000D53B                          M 	dc.b	""
0000D53B 00                       M 	dc.b	0
0000D53C                          M 	even
0000D53C                          M 	.instr_end_306:
0000D53C                            	AMPS_Debug_GetChannel
0000D53C BAFC C5F8                M 	cmp.w	#mpsg1,a5
0000D540 6600                     M 	bne.s	amps_debug_writepsg2
0000D542                          M 	console.write	"PSG1"
0000D542 40E7                     M 	move.w	sr,-(sp)
0000D544                          M 	__fstring_generateargumentscode	"PSG1"
0000D544 =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D544 =00000000                M 	__stack:set	0
0000D544 =00000000                M 	__sp:	set 0
0000D544                          M 	while	(__pos)
0000D544                          M 	rept	__stack
0000D544 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D548 43FA 0000                M 	lea	.str_310(pc),a1
0000D54C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D552 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D556 46DF                     M 	move.w	(sp)+,sr
0000D558 6000 0000                M 	bra.w	.instr_end_310
0000D55C                          M 	.str_310:
0000D55C                          M 	__fstring_generatedecodedstring	"PSG1"
0000D55C =00000001                M 	__lpos:	set 1
0000D55C =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D55C                          M 	while	(__pos)
0000D55C                          M 	__substr:	substr __lpos,,"PSG1"
0000D55C 5053 4731                M 	dc.b	"PSG1"
0000D560 00                       M 	dc.b	0
0000D562 00                       M 	even
0000D562                          M 	.instr_end_310:
0000D562 6000 0000                M 	bra.w	amps_debug_writeend
0000D566                          M amps_debug_writepsg2
0000D566 BAFC C624                M 	cmp.w	#mpsg2,a5
0000D56A 6600                     M 	bne.s	amps_debug_writepsg3
0000D56C                          M 	console.write	"PSG2"
0000D56C 40E7                     M 	move.w	sr,-(sp)
0000D56E                          M 	__fstring_generateargumentscode	"PSG2"
0000D56E =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D56E =00000000                M 	__stack:set	0
0000D56E =00000000                M 	__sp:	set 0
0000D56E                          M 	while	(__pos)
0000D56E                          M 	rept	__stack
0000D56E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D572 43FA 0000                M 	lea	.str_313(pc),a1
0000D576 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D57C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D580 46DF                     M 	move.w	(sp)+,sr
0000D582 6000 0000                M 	bra.w	.instr_end_313
0000D586                          M 	.str_313:
0000D586                          M 	__fstring_generatedecodedstring	"PSG2"
0000D586 =00000001                M 	__lpos:	set 1
0000D586 =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D586                          M 	while	(__pos)
0000D586                          M 	__substr:	substr __lpos,,"PSG2"
0000D586 5053 4732                M 	dc.b	"PSG2"
0000D58A 00                       M 	dc.b	0
0000D58C 00                       M 	even
0000D58C                          M 	.instr_end_313:
0000D58C 6000 0000                M 	bra.w	amps_debug_writeend
0000D590                          M amps_debug_writepsg3
0000D590 BAFC C650                M 	cmp.w	#mpsg3,a5
0000D594 6600                     M 	bne.s	amps_debug_writepsgs1
0000D596                          M 	console.write	"PSG3"
0000D596 40E7                     M 	move.w	sr,-(sp)
0000D598                          M 	__fstring_generateargumentscode	"PSG3"
0000D598 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D598 =00000000                M 	__stack:set	0
0000D598 =00000000                M 	__sp:	set 0
0000D598                          M 	while	(__pos)
0000D598                          M 	rept	__stack
0000D598 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D59C 43FA 0000                M 	lea	.str_316(pc),a1
0000D5A0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5A6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5AA 46DF                     M 	move.w	(sp)+,sr
0000D5AC 6000 0000                M 	bra.w	.instr_end_316
0000D5B0                          M 	.str_316:
0000D5B0                          M 	__fstring_generatedecodedstring	"PSG3"
0000D5B0 =00000001                M 	__lpos:	set 1
0000D5B0 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D5B0                          M 	while	(__pos)
0000D5B0                          M 	__substr:	substr __lpos,,"PSG3"
0000D5B0 5053 4733                M 	dc.b	"PSG3"
0000D5B4 00                       M 	dc.b	0
0000D5B6 00                       M 	even
0000D5B6                          M 	.instr_end_316:
0000D5B6 6000 0000                M 	bra.w	amps_debug_writeend
0000D5BA                          M amps_debug_writepsgs1
0000D5BA BAFC C6EC                M 	cmp.w	#msfxpsg1,a5
0000D5BE 6600                     M 	bne.s	amps_debug_writepsgs2
0000D5C0                          M 	console.write	"SFX PSG1"
0000D5C0 40E7                     M 	move.w	sr,-(sp)
0000D5C2                          M 	__fstring_generateargumentscode	"SFX PSG1"
0000D5C2 =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D5C2 =00000000                M 	__stack:set	0
0000D5C2 =00000000                M 	__sp:	set 0
0000D5C2                          M 	while	(__pos)
0000D5C2                          M 	rept	__stack
0000D5C2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5C6 43FA 0000                M 	lea	.str_319(pc),a1
0000D5CA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5D0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5D4 46DF                     M 	move.w	(sp)+,sr
0000D5D6 6000 0000                M 	bra.w	.instr_end_319
0000D5DA                          M 	.str_319:
0000D5DA                          M 	__fstring_generatedecodedstring	"SFX PSG1"
0000D5DA =00000001                M 	__lpos:	set 1
0000D5DA =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D5DA                          M 	while	(__pos)
0000D5DA                          M 	__substr:	substr __lpos,,"SFX PSG1"
0000D5DA 5346 5820 5053 4731      M 	dc.b	"SFX PSG1"
0000D5E2 00                       M 	dc.b	0
0000D5E4 00                       M 	even
0000D5E4                          M 	.instr_end_319:
0000D5E4 6000 0000                M 	bra.w	amps_debug_writeend
0000D5E8                          M amps_debug_writepsgs2
0000D5E8 BAFC C708                M 	cmp.w	#msfxpsg2,a5
0000D5EC 6600                     M 	bne.s	amps_debug_writepsgs3
0000D5EE                          M 	console.write	"SFX PSG2"
0000D5EE 40E7                     M 	move.w	sr,-(sp)
0000D5F0                          M 	__fstring_generateargumentscode	"SFX PSG2"
0000D5F0 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D5F0 =00000000                M 	__stack:set	0
0000D5F0 =00000000                M 	__sp:	set 0
0000D5F0                          M 	while	(__pos)
0000D5F0                          M 	rept	__stack
0000D5F0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5F4 43FA 0000                M 	lea	.str_322(pc),a1
0000D5F8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5FE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D602 46DF                     M 	move.w	(sp)+,sr
0000D604 6000 0000                M 	bra.w	.instr_end_322
0000D608                          M 	.str_322:
0000D608                          M 	__fstring_generatedecodedstring	"SFX PSG2"
0000D608 =00000001                M 	__lpos:	set 1
0000D608 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D608                          M 	while	(__pos)
0000D608                          M 	__substr:	substr __lpos,,"SFX PSG2"
0000D608 5346 5820 5053 4732      M 	dc.b	"SFX PSG2"
0000D610 00                       M 	dc.b	0
0000D612 00                       M 	even
0000D612                          M 	.instr_end_322:
0000D612 6000 0000                M 	bra.w	amps_debug_writeend
0000D616                          M amps_debug_writepsgs3
0000D616 BAFC C724                M 	cmp.w	#msfxpsg3,a5
0000D61A 6600                     M 	bne.s	amps_debug_writedacs1
0000D61C                          M 	console.write	"SFX PSG3"
0000D61C 40E7                     M 	move.w	sr,-(sp)
0000D61E                          M 	__fstring_generateargumentscode	"SFX PSG3"
0000D61E =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D61E =00000000                M 	__stack:set	0
0000D61E =00000000                M 	__sp:	set 0
0000D61E                          M 	while	(__pos)
0000D61E                          M 	rept	__stack
0000D61E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D622 43FA 0000                M 	lea	.str_325(pc),a1
0000D626 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D62C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D630 46DF                     M 	move.w	(sp)+,sr
0000D632 6000 0000                M 	bra.w	.instr_end_325
0000D636                          M 	.str_325:
0000D636                          M 	__fstring_generatedecodedstring	"SFX PSG3"
0000D636 =00000001                M 	__lpos:	set 1
0000D636 =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D636                          M 	while	(__pos)
0000D636                          M 	__substr:	substr __lpos,,"SFX PSG3"
0000D636 5346 5820 5053 4733      M 	dc.b	"SFX PSG3"
0000D63E 00                       M 	dc.b	0
0000D640 00                       M 	even
0000D640                          M 	.instr_end_325:
0000D640 6000 0000                M 	bra.w	amps_debug_writeend
0000D644                          M amps_debug_writedacs1
0000D644 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0000D648 6600                     M 	bne.s	amps_debug_writedac1
0000D64A                          M 	console.write	"SFX DAC1"
0000D64A 40E7                     M 	move.w	sr,-(sp)
0000D64C                          M 	__fstring_generateargumentscode	"SFX DAC1"
0000D64C =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D64C =00000000                M 	__stack:set	0
0000D64C =00000000                M 	__sp:	set 0
0000D64C                          M 	while	(__pos)
0000D64C                          M 	rept	__stack
0000D64C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D650 43FA 0000                M 	lea	.str_328(pc),a1
0000D654 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D65A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D65E 46DF                     M 	move.w	(sp)+,sr
0000D660 6000 0000                M 	bra.w	.instr_end_328
0000D664                          M 	.str_328:
0000D664                          M 	__fstring_generatedecodedstring	"SFX DAC1"
0000D664 =00000001                M 	__lpos:	set 1
0000D664 =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D664                          M 	while	(__pos)
0000D664                          M 	__substr:	substr __lpos,,"SFX DAC1"
0000D664 5346 5820 4441 4331      M 	dc.b	"SFX DAC1"
0000D66C 00                       M 	dc.b	0
0000D66E 00                       M 	even
0000D66E                          M 	.instr_end_328:
0000D66E 6000 0000                M 	bra.w	amps_debug_writeend
0000D672                          M amps_debug_writedac1
0000D672 BAFC C4C4                M 	cmp.w	#mdac1,a5
0000D676 6600                     M 	bne.s	amps_debug_writedac2
0000D678                          M 	console.write	"DAC1"
0000D678 40E7                     M 	move.w	sr,-(sp)
0000D67A                          M 	__fstring_generateargumentscode	"DAC1"
0000D67A =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D67A =00000000                M 	__stack:set	0
0000D67A =00000000                M 	__sp:	set 0
0000D67A                          M 	while	(__pos)
0000D67A                          M 	rept	__stack
0000D67A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D67E 43FA 0000                M 	lea	.str_331(pc),a1
0000D682 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D688 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D68C 46DF                     M 	move.w	(sp)+,sr
0000D68E 6000 0000                M 	bra.w	.instr_end_331
0000D692                          M 	.str_331:
0000D692                          M 	__fstring_generatedecodedstring	"DAC1"
0000D692 =00000001                M 	__lpos:	set 1
0000D692 =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D692                          M 	while	(__pos)
0000D692                          M 	__substr:	substr __lpos,,"DAC1"
0000D692 4441 4331                M 	dc.b	"DAC1"
0000D696 00                       M 	dc.b	0
0000D698 00                       M 	even
0000D698                          M 	.instr_end_331:
0000D698 6000 0000                M 	bra.w	amps_debug_writeend
0000D69C                          M amps_debug_writedac2
0000D69C BAFC C4F0                M 	cmp.w	#mdac2,a5
0000D6A0 6600                     M 	bne.s	amps_debug_writefm1
0000D6A2                          M 	console.write	"DAC2"
0000D6A2 40E7                     M 	move.w	sr,-(sp)
0000D6A4                          M 	__fstring_generateargumentscode	"DAC2"
0000D6A4 =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D6A4 =00000000                M 	__stack:set	0
0000D6A4 =00000000                M 	__sp:	set 0
0000D6A4                          M 	while	(__pos)
0000D6A4                          M 	rept	__stack
0000D6A4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6A8 43FA 0000                M 	lea	.str_334(pc),a1
0000D6AC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6B2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6B6 46DF                     M 	move.w	(sp)+,sr
0000D6B8 6000 0000                M 	bra.w	.instr_end_334
0000D6BC                          M 	.str_334:
0000D6BC                          M 	__fstring_generatedecodedstring	"DAC2"
0000D6BC =00000001                M 	__lpos:	set 1
0000D6BC =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D6BC                          M 	while	(__pos)
0000D6BC                          M 	__substr:	substr __lpos,,"DAC2"
0000D6BC 4441 4332                M 	dc.b	"DAC2"
0000D6C0 00                       M 	dc.b	0
0000D6C2 00                       M 	even
0000D6C2                          M 	.instr_end_334:
0000D6C2 6000 0000                M 	bra.w	amps_debug_writeend
0000D6C6                          M amps_debug_writefm1
0000D6C6 BAFC C51C                M 	cmp.w	#mfm1,a5
0000D6CA 6600                     M 	bne.s	amps_debug_writefm2
0000D6CC                          M 	console.write	"FM1"
0000D6CC 40E7                     M 	move.w	sr,-(sp)
0000D6CE                          M 	__fstring_generateargumentscode	"FM1"
0000D6CE =00000000                M 	__pos:	set instr("FM1",'%<')
0000D6CE =00000000                M 	__stack:set	0
0000D6CE =00000000                M 	__sp:	set 0
0000D6CE                          M 	while	(__pos)
0000D6CE                          M 	rept	__stack
0000D6CE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6D2 43FA 0000                M 	lea	.str_337(pc),a1
0000D6D6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6DC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6E0 46DF                     M 	move.w	(sp)+,sr
0000D6E2 6000 0000                M 	bra.w	.instr_end_337
0000D6E6                          M 	.str_337:
0000D6E6                          M 	__fstring_generatedecodedstring	"FM1"
0000D6E6 =00000001                M 	__lpos:	set 1
0000D6E6 =00000000                M 	__pos:	set instr("FM1",'%<')
0000D6E6                          M 	while	(__pos)
0000D6E6                          M 	__substr:	substr __lpos,,"FM1"
0000D6E6 464D 31                  M 	dc.b	"FM1"
0000D6E9 00                       M 	dc.b	0
0000D6EA                          M 	even
0000D6EA                          M 	.instr_end_337:
0000D6EA 6000 0000                M 	bra.w	amps_debug_writeend
0000D6EE                          M amps_debug_writefm2
0000D6EE BAFC C548                M 	cmp.w	#mfm2,a5
0000D6F2 6600                     M 	bne.s	amps_debug_writefm3
0000D6F4                          M 	console.write	"FM2"
0000D6F4 40E7                     M 	move.w	sr,-(sp)
0000D6F6                          M 	__fstring_generateargumentscode	"FM2"
0000D6F6 =00000000                M 	__pos:	set instr("FM2",'%<')
0000D6F6 =00000000                M 	__stack:set	0
0000D6F6 =00000000                M 	__sp:	set 0
0000D6F6                          M 	while	(__pos)
0000D6F6                          M 	rept	__stack
0000D6F6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6FA 43FA 0000                M 	lea	.str_340(pc),a1
0000D6FE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D704 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D708 46DF                     M 	move.w	(sp)+,sr
0000D70A 6000 0000                M 	bra.w	.instr_end_340
0000D70E                          M 	.str_340:
0000D70E                          M 	__fstring_generatedecodedstring	"FM2"
0000D70E =00000001                M 	__lpos:	set 1
0000D70E =00000000                M 	__pos:	set instr("FM2",'%<')
0000D70E                          M 	while	(__pos)
0000D70E                          M 	__substr:	substr __lpos,,"FM2"
0000D70E 464D 32                  M 	dc.b	"FM2"
0000D711 00                       M 	dc.b	0
0000D712                          M 	even
0000D712                          M 	.instr_end_340:
0000D712 6000 0000                M 	bra.w	amps_debug_writeend
0000D716                          M amps_debug_writefm3
0000D716 BAFC C574                M 	cmp.w	#mfm3,a5
0000D71A 6600                     M 	bne.s	amps_debug_writefm4
0000D71C                          M 	console.write	"FM3"
0000D71C 40E7                     M 	move.w	sr,-(sp)
0000D71E                          M 	__fstring_generateargumentscode	"FM3"
0000D71E =00000000                M 	__pos:	set instr("FM3",'%<')
0000D71E =00000000                M 	__stack:set	0
0000D71E =00000000                M 	__sp:	set 0
0000D71E                          M 	while	(__pos)
0000D71E                          M 	rept	__stack
0000D71E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D722 43FA 0000                M 	lea	.str_343(pc),a1
0000D726 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D72C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D730 46DF                     M 	move.w	(sp)+,sr
0000D732 6000 0000                M 	bra.w	.instr_end_343
0000D736                          M 	.str_343:
0000D736                          M 	__fstring_generatedecodedstring	"FM3"
0000D736 =00000001                M 	__lpos:	set 1
0000D736 =00000000                M 	__pos:	set instr("FM3",'%<')
0000D736                          M 	while	(__pos)
0000D736                          M 	__substr:	substr __lpos,,"FM3"
0000D736 464D 33                  M 	dc.b	"FM3"
0000D739 00                       M 	dc.b	0
0000D73A                          M 	even
0000D73A                          M 	.instr_end_343:
0000D73A 6000 0000                M 	bra.w	amps_debug_writeend
0000D73E                          M amps_debug_writefm4
0000D73E BAFC C5A0                M 	cmp.w	#mfm4,a5
0000D742 6600                     M 	bne.s	amps_debug_writefm5
0000D744                          M 	console.write	"FM4"
0000D744 40E7                     M 	move.w	sr,-(sp)
0000D746                          M 	__fstring_generateargumentscode	"FM4"
0000D746 =00000000                M 	__pos:	set instr("FM4",'%<')
0000D746 =00000000                M 	__stack:set	0
0000D746 =00000000                M 	__sp:	set 0
0000D746                          M 	while	(__pos)
0000D746                          M 	rept	__stack
0000D746 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D74A 43FA 0000                M 	lea	.str_346(pc),a1
0000D74E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D754 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D758 46DF                     M 	move.w	(sp)+,sr
0000D75A 6000 0000                M 	bra.w	.instr_end_346
0000D75E                          M 	.str_346:
0000D75E                          M 	__fstring_generatedecodedstring	"FM4"
0000D75E =00000001                M 	__lpos:	set 1
0000D75E =00000000                M 	__pos:	set instr("FM4",'%<')
0000D75E                          M 	while	(__pos)
0000D75E                          M 	__substr:	substr __lpos,,"FM4"
0000D75E 464D 34                  M 	dc.b	"FM4"
0000D761 00                       M 	dc.b	0
0000D762                          M 	even
0000D762                          M 	.instr_end_346:
0000D762 6000 0000                M 	bra.w	amps_debug_writeend
0000D766                          M amps_debug_writefm5
0000D766 BAFC C5CC                M 	cmp.w	#mfm5,a5
0000D76A 6600                     M 	bne.s	amps_debug_writefms3
0000D76C                          M 	console.write	"FM5"
0000D76C 40E7                     M 	move.w	sr,-(sp)
0000D76E                          M 	__fstring_generateargumentscode	"FM5"
0000D76E =00000000                M 	__pos:	set instr("FM5",'%<')
0000D76E =00000000                M 	__stack:set	0
0000D76E =00000000                M 	__sp:	set 0
0000D76E                          M 	while	(__pos)
0000D76E                          M 	rept	__stack
0000D76E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D772 43FA 0000                M 	lea	.str_349(pc),a1
0000D776 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D77C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D780 46DF                     M 	move.w	(sp)+,sr
0000D782 6000 0000                M 	bra.w	.instr_end_349
0000D786                          M 	.str_349:
0000D786                          M 	__fstring_generatedecodedstring	"FM5"
0000D786 =00000001                M 	__lpos:	set 1
0000D786 =00000000                M 	__pos:	set instr("FM5",'%<')
0000D786                          M 	while	(__pos)
0000D786                          M 	__substr:	substr __lpos,,"FM5"
0000D786 464D 35                  M 	dc.b	"FM5"
0000D789 00                       M 	dc.b	0
0000D78A                          M 	even
0000D78A                          M 	.instr_end_349:
0000D78A 6000 0000                M 	bra.w	amps_debug_writeend
0000D78E                          M amps_debug_writefms3
0000D78E BAFC C698                M 	cmp.w	#msfxfm3,a5
0000D792 6600                     M 	bne.s	amps_debug_writefms4
0000D794                          M 	console.write	"SFX FM3"
0000D794 40E7                     M 	move.w	sr,-(sp)
0000D796                          M 	__fstring_generateargumentscode	"SFX FM3"
0000D796 =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D796 =00000000                M 	__stack:set	0
0000D796 =00000000                M 	__sp:	set 0
0000D796                          M 	while	(__pos)
0000D796                          M 	rept	__stack
0000D796 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D79A 43FA 0000                M 	lea	.str_352(pc),a1
0000D79E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D7A4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D7A8 46DF                     M 	move.w	(sp)+,sr
0000D7AA 6000 0000                M 	bra.w	.instr_end_352
0000D7AE                          M 	.str_352:
0000D7AE                          M 	__fstring_generatedecodedstring	"SFX FM3"
0000D7AE =00000001                M 	__lpos:	set 1
0000D7AE =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D7AE                          M 	while	(__pos)
0000D7AE                          M 	__substr:	substr __lpos,,"SFX FM3"
0000D7AE 5346 5820 464D 33        M 	dc.b	"SFX FM3"
0000D7B5 00                       M 	dc.b	0
0000D7B6                          M 	even
0000D7B6                          M 	.instr_end_352:
0000D7B6 4E75                     M 	rts
0000D7B8                          M amps_debug_writefms4
0000D7B8 BAFC C6B4                M 	cmp.w	#msfxfm4,a5
0000D7BC 6600                     M 	bne.s	amps_debug_writefms5
0000D7BE                          M 	console.write	"SFX FM4"
0000D7BE 40E7                     M 	move.w	sr,-(sp)
0000D7C0                          M 	__fstring_generateargumentscode	"SFX FM4"
0000D7C0 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D7C0 =00000000                M 	__stack:set	0
0000D7C0 =00000000                M 	__sp:	set 0
0000D7C0                          M 	while	(__pos)
0000D7C0                          M 	rept	__stack
0000D7C0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7C4 43FA 0000                M 	lea	.str_355(pc),a1
0000D7C8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D7CE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D7D2 46DF                     M 	move.w	(sp)+,sr
0000D7D4 6000 0000                M 	bra.w	.instr_end_355
0000D7D8                          M 	.str_355:
0000D7D8                          M 	__fstring_generatedecodedstring	"SFX FM4"
0000D7D8 =00000001                M 	__lpos:	set 1
0000D7D8 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D7D8                          M 	while	(__pos)
0000D7D8                          M 	__substr:	substr __lpos,,"SFX FM4"
0000D7D8 5346 5820 464D 34        M 	dc.b	"SFX FM4"
0000D7DF 00                       M 	dc.b	0
0000D7E0                          M 	even
0000D7E0                          M 	.instr_end_355:
0000D7E0 6000                     M 	bra.s	amps_debug_writeend
0000D7E2                          M amps_debug_writefms5
0000D7E2 BAFC C6D0                M 	cmp.w	#msfxfm5,a5
0000D7E6 6700                     M 	beq.s	amps_debug_writefms5_
0000D7E8                          M amps_debug_writeaddr
0000D7E8                          M 	console.write	"%<fpal2>%<.l a5>"
0000D7E8 40E7                     M 	move.w	sr,-(sp)
0000D7EA                          M 	__fstring_generateargumentscode	"%<fpal2>%<.l a5>"
0000D7EA =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D7EA =00000000                M 	__stack:set	0
0000D7EA =00000000                M 	__sp:	set 0
0000D7EA                          M 	while	(__pos)
0000D7EA =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D7EA =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D7EA =00000008                M 	__midpos:	= __endpos
0000D7EA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D7EA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D7EA =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D7EA =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D7EA =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D7EA =00000010                M 	__midpos:	= __endpos
0000D7EA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D7EA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D7EA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal2>%<.l a5>"
0000D7EA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D7EA                          M 	pushp	"move.l a5,-(sp)"
0000D7EA =00000001                M 	__stack:	= __stack+1
0000D7EA =00000004                M 	__sp:	= __sp+4
0000D7EA =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D7EA                          M 	rept	__stack
0000D7EA                          M 	popp	__command
0000D7EA 2F0D                     M 	move.l	a5,-(sp)
0000D7EC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7F0 45EF 0010                M 	lea	4*4(sp),a2
0000D7F4 43FA 0000                M 	lea	.str_358(pc),a1
0000D7F8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D7FE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D802 584F                     M 	addq.w	#__sp,sp
0000D804 46DF                     M 	move.w	(sp)+,sr
0000D806 6000 0000                M 	bra.w	.instr_end_358
0000D80A                          M 	.str_358:
0000D80A                          M 	__fstring_generatedecodedstring	"%<fpal2>%<.l a5>"
0000D80A =00000001                M 	__lpos:	set 1
0000D80A =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D80A                          M 	while	(__pos)
0000D80A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D80A                          M 	dc.b	""
0000D80A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D80A =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D80A =00000008                M 	__midpos:	= __endpos
0000D80A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D80A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D80A EC                       M 	dc.b	fpal2
0000D80B =00000009                M 	__lpos:	set __endpos+1
0000D80B =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D80B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D80B                          M 	dc.b	""
0000D80B =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D80B =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D80B =00000010                M 	__midpos:	= __endpos
0000D80B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D80B                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D80B                          M 	__param:	substr ,,"hex"
0000D80B 83                       M 	dc.b	hex|3
0000D80C =00000011                M 	__lpos:	set __endpos+1
0000D80C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D80C                          M 	__substr:	substr __lpos,,"%<fpal2>%<.l a5>"
0000D80C                          M 	dc.b	""
0000D80C 00                       M 	dc.b	0
0000D80E 00                       M 	even
0000D80E                          M 	.instr_end_358:
0000D80E 4E75                     M 	rts
0000D810                          M amps_debug_writefms5_
0000D810                          M 	console.write	"SFX FM5"
0000D810 40E7                     M 	move.w	sr,-(sp)
0000D812                          M 	__fstring_generateargumentscode	"SFX FM5"
0000D812 =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D812 =00000000                M 	__stack:set	0
0000D812 =00000000                M 	__sp:	set 0
0000D812                          M 	while	(__pos)
0000D812                          M 	rept	__stack
0000D812 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D816 43FA 0000                M 	lea	.str_361(pc),a1
0000D81A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D820 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D824 46DF                     M 	move.w	(sp)+,sr
0000D826 6000 0000                M 	bra.w	.instr_end_361
0000D82A                          M 	.str_361:
0000D82A                          M 	__fstring_generatedecodedstring	"SFX FM5"
0000D82A =00000001                M 	__lpos:	set 1
0000D82A =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D82A                          M 	while	(__pos)
0000D82A                          M 	__substr:	substr __lpos,,"SFX FM5"
0000D82A 5346 5820 464D 35        M 	dc.b	"SFX FM5"
0000D831 00                       M 	dc.b	0
0000D832                          M 	even
0000D832                          M 	.instr_end_361:
0000D832                          M amps_debug_writeend
0000D832                            	Console.BreakLine
0000D832 40E7                     M 	move.w	sr,-(sp)
0000D834 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D83A 46DF                     M 	move.w	(sp)+,sr
0000D83C                            
0000D83C                            	Console.WriteLine "%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83C 40E7                     M 	move.w	sr,-(sp)
0000D83E                          M 	__fstring_generateargumentscode	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D83E =00000000                M 	__stack:set	0
0000D83E =00000000                M 	__sp:	set 0
0000D83E                          M 	while	(__pos)
0000D83E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D83E =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D83E =00000008                M 	__midpos:	= __endpos
0000D83E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D83E =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D83E =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D83E =00000016                M 	__midpos:	= __endpos
0000D83E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D83E =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D83E =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D83E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	pushp	"move.l a4,-(sp)"
0000D83E =00000001                M 	__stack:	= __stack+1
0000D83E =00000004                M 	__sp:	= __sp+4
0000D83E =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D83E =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D83E =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D83E =0000003A                M 	__midpos:	= __endpos
0000D83E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D83E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D83E                          M 	rept	__stack
0000D83E                          M 	popp	__command
0000D83E 2F0C                     M 	move.l	a4,-(sp)
0000D840 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D844 45EF 0010                M 	lea	4*4(sp),a2
0000D848 43FA 0000                M 	lea	.str_365(pc),a1
0000D84C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D852 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D856 584F                     M 	addq.w	#__sp,sp
0000D858 46DF                     M 	move.w	(sp)+,sr
0000D85A 6000 0000                M 	bra.w	.instr_end_365
0000D85E                          M 	.str_365:
0000D85E                          M 	__fstring_generatedecodedstring	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D85E =00000001                M 	__lpos:	set 1
0000D85E =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D85E                          M 	while	(__pos)
0000D85E                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D85E                          M 	dc.b	""
0000D85E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D85E =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D85E =00000008                M 	__midpos:	= __endpos
0000D85E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D85E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D85E EA                       M 	dc.b	fpal1
0000D85F =00000009                M 	__lpos:	set __endpos+1
0000D85F =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D85F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D85F 4164 6472 3A20           M 	dc.b	"Addr: "
0000D865 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D865 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D865 =00000016                M 	__midpos:	= __endpos
0000D865                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D865                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D865 E8                       M 	dc.b	fpal0
0000D866 =00000017                M 	__lpos:	set __endpos+1
0000D866 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D866                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D866                          M 	dc.b	""
0000D866 =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D866 =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D866 BB                       M 	dc.b	sym|fsplit|3
0000D867 =0000002A                M 	__lpos:	set __endpos+1
0000D867 =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D867                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D867                          M 	dc.b	""
0000D867 =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D867 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D867 =0000003A                M 	__midpos:	= __endpos
0000D867                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D867                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D867 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D869 =0000003B                M 	__lpos:	set __endpos+1
0000D869 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D869                          M 	__substr:	substr __lpos,,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D869                          M 	dc.b	""
0000D869 00                       M 	dc.b	0
0000D86A                          M 	even
0000D86A                          M 	.instr_end_365:
0000D86A                            ; fmt: flag, type, pan, det, pitch, vol, tick, sample/voice, dur, lastdur, freq
0000D86A                            	Console.Write	  "%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86A 40E7                     M 	move.w	sr,-(sp)
0000D86C                          M 	__fstring_generateargumentscode	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C =00000000                M 	__stack:set	0
0000D86C =00000000                M 	__sp:	set 0
0000D86C                          M 	while	(__pos)
0000D86C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D86C =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D86C =00000008                M 	__midpos:	= __endpos
0000D86C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D86C =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D86C =00000014                M 	__midpos:	= __endpos
0000D86C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D86C =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D86C =0000001E                M 	__midpos:	= __endpos
0000D86C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	pushp	"move.b (a5),1(sp)"
0000D86C                          M 	pushp	"subq.w	#2, sp"
0000D86C =00000002                M 	__stack:	= __stack+2
0000D86C =00000002                M 	__sp:	= __sp+2
0000D86C =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D86C =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D86C =0000002E                M 	__midpos:	= __endpos
0000D86C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	pushp	"move.b cType(a5),1(sp)"
0000D86C                          M 	pushp	"subq.w	#2, sp"
0000D86C =00000004                M 	__stack:	= __stack+2
0000D86C =00000004                M 	__sp:	= __sp+2
0000D86C =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D86C =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D86C =00000041                M 	__midpos:	= __endpos
0000D86C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D86C                          M 	pushp	"move.b cPanning(a5),1(sp)"
0000D86C                          M 	pushp	"subq.w	#2, sp"
0000D86C =00000006                M 	__stack:	= __stack+2
0000D86C =00000006                M 	__sp:	= __sp+2
0000D86C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D86C                          M 	rept	__stack
0000D86C                          M 	popp	__command
0000D86C 554F                     M 	subq.w	#2,sp
0000D86E                          M 	popp	__command
0000D86E 1F6D 0006 0001           M 	move.b	cpanning(a5),1(sp)
0000D874                          M 	popp	__command
0000D874 554F                     M 	subq.w	#2,sp
0000D876                          M 	popp	__command
0000D876 1F6D 0001 0001           M 	move.b	ctype(a5),1(sp)
0000D87C                          M 	popp	__command
0000D87C 554F                     M 	subq.w	#2,sp
0000D87E                          M 	popp	__command
0000D87E 1F55 0001                M 	move.b	(a5),1(sp)
0000D882 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D886 45EF 0010                M 	lea	4*4(sp),a2
0000D88A 43FA 0000                M 	lea	.str_368(pc),a1
0000D88E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D894 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D898 5C4F                     M 	addq.w	#__sp,sp
0000D89A 46DF                     M 	move.w	(sp)+,sr
0000D89C 6000 0000                M 	bra.w	.instr_end_368
0000D8A0                          M 	.str_368:
0000D8A0                          M 	__fstring_generatedecodedstring	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A0 =00000001                M 	__lpos:	set 1
0000D8A0 =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8A0                          M 	while	(__pos)
0000D8A0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A0                          M 	dc.b	""
0000D8A0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D8A0 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D8A0 =00000008                M 	__midpos:	= __endpos
0000D8A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A0 EA                       M 	dc.b	fpal1
0000D8A1 =00000009                M 	__lpos:	set __endpos+1
0000D8A1 =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8A1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A1 4348 3A20                M 	dc.b	"CH: "
0000D8A5 =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D8A5 =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D8A5 =00000014                M 	__midpos:	= __endpos
0000D8A5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A5                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A5 EC                       M 	dc.b	fpal2
0000D8A6 =00000015                M 	__lpos:	set __endpos+1
0000D8A6 =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8A6                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A6                          M 	dc.b	""
0000D8A6 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D8A6 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D8A6 =0000001E                M 	__midpos:	= __endpos
0000D8A6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A6                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A6                          M 	__param:	substr ,,"hex"
0000D8A6 80                       M 	dc.b	hex
0000D8A7 =0000001F                M 	__lpos:	set __endpos+1
0000D8A7 =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8A7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A7 20                       M 	dc.b	" "
0000D8A8 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D8A8 =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D8A8 =0000002E                M 	__midpos:	= __endpos
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A8                          M 	__param:	substr ,,"hex"
0000D8A8 80                       M 	dc.b	hex
0000D8A9 =0000002F                M 	__lpos:	set __endpos+1
0000D8A9 =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8A9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8A9 20                       M 	dc.b	" "
0000D8AA =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D8AA =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D8AA =00000041                M 	__midpos:	= __endpos
0000D8AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8AA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8AA                          M 	__param:	substr ,,"hex"
0000D8AA 80                       M 	dc.b	hex
0000D8AB =00000042                M 	__lpos:	set __endpos+1
0000D8AB =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D8AB                          M 	__substr:	substr __lpos,,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D8AB 20                       M 	dc.b	" "
0000D8AC 00                       M 	dc.b	0
0000D8AE 00                       M 	even
0000D8AE                          M 	.instr_end_368:
0000D8AE                            	Console.Write	  "%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8AE 40E7                     M 	move.w	sr,-(sp)
0000D8B0                          M 	__fstring_generateargumentscode	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0 =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8B0 =00000000                M 	__stack:set	0
0000D8B0 =00000000                M 	__sp:	set 0
0000D8B0                          M 	while	(__pos)
0000D8B0 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8B0 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8B0 =00000011                M 	__midpos:	= __endpos
0000D8B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	pushp	"move.b cDetune(a5),1(sp)"
0000D8B0                          M 	pushp	"subq.w	#2, sp"
0000D8B0 =00000002                M 	__stack:	= __stack+2
0000D8B0 =00000002                M 	__sp:	= __sp+2
0000D8B0 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8B0 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8B0 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8B0 =00000022                M 	__midpos:	= __endpos
0000D8B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	pushp	"move.b cPitch(a5),1(sp)"
0000D8B0                          M 	pushp	"subq.w	#2, sp"
0000D8B0 =00000004                M 	__stack:	= __stack+2
0000D8B0 =00000004                M 	__sp:	= __sp+2
0000D8B0 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8B0 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8B0 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8B0 =00000034                M 	__midpos:	= __endpos
0000D8B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	pushp	"move.b cVolume(a5),1(sp)"
0000D8B0                          M 	pushp	"subq.w	#2, sp"
0000D8B0 =00000006                M 	__stack:	= __stack+2
0000D8B0 =00000006                M 	__sp:	= __sp+2
0000D8B0 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8B0 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8B0 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8B0 =00000044                M 	__midpos:	= __endpos
0000D8B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8B0                          M 	pushp	"move.b cTick(a5),1(sp)"
0000D8B0                          M 	pushp	"subq.w	#2, sp"
0000D8B0 =00000008                M 	__stack:	= __stack+2
0000D8B0 =00000008                M 	__sp:	= __sp+2
0000D8B0 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8B0                          M 	rept	__stack
0000D8B0                          M 	popp	__command
0000D8B0 554F                     M 	subq.w	#2,sp
0000D8B2                          M 	popp	__command
0000D8B2 1F6D 000A 0001           M 	move.b	ctick(a5),1(sp)
0000D8B8                          M 	popp	__command
0000D8B8 554F                     M 	subq.w	#2,sp
0000D8BA                          M 	popp	__command
0000D8BA 1F6D 0009 0001           M 	move.b	cvolume(a5),1(sp)
0000D8C0                          M 	popp	__command
0000D8C0 554F                     M 	subq.w	#2,sp
0000D8C2                          M 	popp	__command
0000D8C2 1F6D 0008 0001           M 	move.b	cpitch(a5),1(sp)
0000D8C8                          M 	popp	__command
0000D8C8 554F                     M 	subq.w	#2,sp
0000D8CA                          M 	popp	__command
0000D8CA 1F6D 0007 0001           M 	move.b	cdetune(a5),1(sp)
0000D8D0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D8D4 45EF 0010                M 	lea	4*4(sp),a2
0000D8D8 43FA 0000                M 	lea	.str_371(pc),a1
0000D8DC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D8E2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D8E6 504F                     M 	addq.w	#__sp,sp
0000D8E8 46DF                     M 	move.w	(sp)+,sr
0000D8EA 6000 0000                M 	bra.w	.instr_end_371
0000D8EE                          M 	.str_371:
0000D8EE                          M 	__fstring_generatedecodedstring	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8EE =00000001                M 	__lpos:	set 1
0000D8EE =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8EE                          M 	while	(__pos)
0000D8EE                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8EE                          M 	dc.b	""
0000D8EE =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8EE =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8EE =00000011                M 	__midpos:	= __endpos
0000D8EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8EE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8EE                          M 	__param:	substr ,,"hex"
0000D8EE 80                       M 	dc.b	hex
0000D8EF =00000012                M 	__lpos:	set __endpos+1
0000D8EF =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8EF                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8EF 20                       M 	dc.b	" "
0000D8F0 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8F0 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8F0 =00000022                M 	__midpos:	= __endpos
0000D8F0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F0                          M 	__param:	substr ,,"hex"
0000D8F0 80                       M 	dc.b	hex
0000D8F1 =00000023                M 	__lpos:	set __endpos+1
0000D8F1 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8F1                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F1 20                       M 	dc.b	" "
0000D8F2 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8F2 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8F2 =00000034                M 	__midpos:	= __endpos
0000D8F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F2                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F2                          M 	__param:	substr ,,"hex"
0000D8F2 80                       M 	dc.b	hex
0000D8F3 =00000035                M 	__lpos:	set __endpos+1
0000D8F3 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8F3                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F3 20                       M 	dc.b	" "
0000D8F4 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D8F4 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D8F4 =00000044                M 	__midpos:	= __endpos
0000D8F4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F4                          M 	__param:	substr ,,"hex"
0000D8F4 80                       M 	dc.b	hex
0000D8F5 =00000045                M 	__lpos:	set __endpos+1
0000D8F5 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D8F5                          M 	__substr:	substr __lpos,,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D8F5 20                       M 	dc.b	" "
0000D8F6 00                       M 	dc.b	0
0000D8F8 00                       M 	even
0000D8F8                          M 	.instr_end_371:
0000D8F8                            	Console.WriteLine "%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8F8 40E7                     M 	move.w	sr,-(sp)
0000D8FA                          M 	__fstring_generateargumentscode	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8FA =00000000                M 	__stack:set	0
0000D8FA =00000000                M 	__sp:	set 0
0000D8FA                          M 	while	(__pos)
0000D8FA =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8FA =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8FA =00000011                M 	__midpos:	= __endpos
0000D8FA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	pushp	"move.b cSample(a5),1(sp)"
0000D8FA                          M 	pushp	"subq.w	#2, sp"
0000D8FA =00000002                M 	__stack:	= __stack+2
0000D8FA =00000002                M 	__sp:	= __sp+2
0000D8FA =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8FA =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8FA =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8FA =00000025                M 	__midpos:	= __endpos
0000D8FA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000D8FA                          M 	pushp	"subq.w	#2, sp"
0000D8FA =00000004                M 	__stack:	= __stack+2
0000D8FA =00000004                M 	__sp:	= __sp+2
0000D8FA =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8FA =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8FA =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8FA =00000038                M 	__midpos:	= __endpos
0000D8FA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000D8FA                          M 	pushp	"subq.w	#2, sp"
0000D8FA =00000006                M 	__stack:	= __stack+2
0000D8FA =00000006                M 	__sp:	= __sp+2
0000D8FA =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8FA =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8FA =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8FA =00000048                M 	__midpos:	= __endpos
0000D8FA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8FA                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000D8FA =00000007                M 	__stack:	= __stack+1
0000D8FA =00000008                M 	__sp:	= __sp+2
0000D8FA =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8FA                          M 	rept	__stack
0000D8FA                          M 	popp	__command
0000D8FA 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000D8FE                          M 	popp	__command
0000D8FE 554F                     M 	subq.w	#2,sp
0000D900                          M 	popp	__command
0000D900 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000D906                          M 	popp	__command
0000D906 554F                     M 	subq.w	#2,sp
0000D908                          M 	popp	__command
0000D908 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000D90E                          M 	popp	__command
0000D90E 554F                     M 	subq.w	#2,sp
0000D910                          M 	popp	__command
0000D910 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000D916 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D91A 45EF 0010                M 	lea	4*4(sp),a2
0000D91E 43FA 0000                M 	lea	.str_374(pc),a1
0000D922 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D928 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D92C 504F                     M 	addq.w	#__sp,sp
0000D92E 46DF                     M 	move.w	(sp)+,sr
0000D930 6000 0000                M 	bra.w	.instr_end_374
0000D934                          M 	.str_374:
0000D934                          M 	__fstring_generatedecodedstring	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D934 =00000001                M 	__lpos:	set 1
0000D934 =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D934                          M 	while	(__pos)
0000D934                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D934                          M 	dc.b	""
0000D934 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D934 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D934 =00000011                M 	__midpos:	= __endpos
0000D934                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D934                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D934                          M 	__param:	substr ,,"hex"
0000D934 80                       M 	dc.b	hex
0000D935 =00000012                M 	__lpos:	set __endpos+1
0000D935 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D935                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D935 20                       M 	dc.b	" "
0000D936 =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D936 =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D936 =00000025                M 	__midpos:	= __endpos
0000D936                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D936                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D936                          M 	__param:	substr ,,"hex"
0000D936 80                       M 	dc.b	hex
0000D937 =00000026                M 	__lpos:	set __endpos+1
0000D937 =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D937                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D937 20                       M 	dc.b	" "
0000D938 =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D938 =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D938 =00000038                M 	__midpos:	= __endpos
0000D938                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D938                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D938                          M 	__param:	substr ,,"hex"
0000D938 80                       M 	dc.b	hex
0000D939 =00000039                M 	__lpos:	set __endpos+1
0000D939 =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D939                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D939 20                       M 	dc.b	" "
0000D93A =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D93A =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D93A =00000048                M 	__midpos:	= __endpos
0000D93A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D93A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D93A                          M 	__param:	substr ,,"hex"
0000D93A 81                       M 	dc.b	hex|1
0000D93B =00000049                M 	__lpos:	set __endpos+1
0000D93B =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D93B                          M 	__substr:	substr __lpos,,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D93B                          M 	dc.b	""
0000D93B 00                       M 	dc.b	0
0000D93C                          M 	even
0000D93C                          M 	.instr_end_374:
0000D93C                            	Console.BreakLine
0000D93C 40E7                     M 	move.w	sr,-(sp)
0000D93E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D944 46DF                     M 	move.w	(sp)+,sr
0000D946                            
0000D946                            	Console.WriteLine "%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D946 40E7                     M 	move.w	sr,-(sp)
0000D948                          M 	__fstring_generateargumentscode	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948 =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D948 =00000000                M 	__stack:set	0
0000D948 =00000000                M 	__sp:	set 0
0000D948                          M 	while	(__pos)
0000D948 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D948 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D948 =00000008                M 	__midpos:	= __endpos
0000D948                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948 =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D948 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D948 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D948 =00000015                M 	__midpos:	= __endpos
0000D948                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D948 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D948 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D948                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	pushp	"move.l cMod(a5),-(sp)"
0000D948 =00000001                M 	__stack:	= __stack+1
0000D948 =00000004                M 	__sp:	= __sp+4
0000D948 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D948 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D948 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D948 =0000003F                M 	__midpos:	= __endpos
0000D948                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D948 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D948                          M 	rept	__stack
0000D948                          M 	popp	__command
0000D948 2F2D 0010                M 	move.l	cmod(a5),-(sp)
0000D94C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D950 45EF 0010                M 	lea	4*4(sp),a2
0000D954 43FA 0000                M 	lea	.str_378(pc),a1
0000D958 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D95E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D962 584F                     M 	addq.w	#__sp,sp
0000D964 46DF                     M 	move.w	(sp)+,sr
0000D966 6000 0000                M 	bra.w	.instr_end_378
0000D96A                          M 	.str_378:
0000D96A                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D96A =00000001                M 	__lpos:	set 1
0000D96A =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D96A                          M 	while	(__pos)
0000D96A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D96A                          M 	dc.b	""
0000D96A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D96A =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D96A =00000008                M 	__midpos:	= __endpos
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D96A EA                       M 	dc.b	fpal1
0000D96B =00000009                M 	__lpos:	set __endpos+1
0000D96B =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D96B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D96B 4D6F 643A 20             M 	dc.b	"Mod: "
0000D970 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D970 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D970 =00000015                M 	__midpos:	= __endpos
0000D970                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D970                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D970 E8                       M 	dc.b	fpal0
0000D971 =00000016                M 	__lpos:	set __endpos+1
0000D971 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D971                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D971                          M 	dc.b	""
0000D971 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D971 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D971                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D971                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D971 BB                       M 	dc.b	sym|fsplit|3
0000D972 =0000002F                M 	__lpos:	set __endpos+1
0000D972 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D972                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D972                          M 	dc.b	""
0000D972 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D972 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D972 =0000003F                M 	__midpos:	= __endpos
0000D972                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D972                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D972 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D974 =00000040                M 	__lpos:	set __endpos+1
0000D974 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D974                          M 	__substr:	substr __lpos,,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D974                          M 	dc.b	""
0000D974 00                       M 	dc.b	0
0000D976 00                       M 	even
0000D976                          M 	.instr_end_378:
0000D976                            	Console.Write	  "%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D976 40E7                     M 	move.w	sr,-(sp)
0000D978                          M 	__fstring_generateargumentscode	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978 =00000000                M 	__stack:set	0
0000D978 =00000000                M 	__sp:	set 0
0000D978                          M 	while	(__pos)
0000D978 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D978 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D978 =00000008                M 	__midpos:	= __endpos
0000D978                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978 =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D978 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D978 =0000001A                M 	__midpos:	= __endpos
0000D978                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978 =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978 =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D978 =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D978 =0000002D                M 	__midpos:	= __endpos
0000D978                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	pushp	"move.b cModDelay(a5),1(sp)"
0000D978                          M 	pushp	"subq.w	#2, sp"
0000D978 =00000002                M 	__stack:	= __stack+2
0000D978 =00000002                M 	__sp:	= __sp+2
0000D978 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D978 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D978 =00000036                M 	__midpos:	= __endpos
0000D978                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D978 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D978 =00000048                M 	__midpos:	= __endpos
0000D978                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D978                          M 	pushp	"move.w cModFreq(a5),-(sp)"
0000D978 =00000003                M 	__stack:	= __stack+1
0000D978 =00000004                M 	__sp:	= __sp+2
0000D978 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D978                          M 	rept	__stack
0000D978                          M 	popp	__command
0000D978 3F2D 0014                M 	move.w	cmodfreq(a5),-(sp)
0000D97C                          M 	popp	__command
0000D97C 554F                     M 	subq.w	#2,sp
0000D97E                          M 	popp	__command
0000D97E 1F6D 0010 0001           M 	move.b	cmoddelay(a5),1(sp)
0000D984 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D988 45EF 0010                M 	lea	4*4(sp),a2
0000D98C 43FA 0000                M 	lea	.str_381(pc),a1
0000D990 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D996 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D99A 584F                     M 	addq.w	#__sp,sp
0000D99C 46DF                     M 	move.w	(sp)+,sr
0000D99E 6000 0000                M 	bra.w	.instr_end_381
0000D9A2                          M 	.str_381:
0000D9A2                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9A2 =00000001                M 	__lpos:	set 1
0000D9A2 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9A2                          M 	while	(__pos)
0000D9A2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9A2                          M 	dc.b	""
0000D9A2 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D9A2 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D9A2 =00000008                M 	__midpos:	= __endpos
0000D9A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9A2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9A2 EA                       M 	dc.b	fpal1
0000D9A3 =00000009                M 	__lpos:	set __endpos+1
0000D9A3 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9A3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9A3 4D6F 6420 4461 7461 3A20 M 	dc.b	"Mod Data: "
0000D9AD =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D9AD =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D9AD =0000001A                M 	__midpos:	= __endpos
0000D9AD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AD                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AD EC                       M 	dc.b	fpal2
0000D9AE =0000001B                M 	__lpos:	set __endpos+1
0000D9AE =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9AE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AE                          M 	dc.b	""
0000D9AE =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D9AE =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D9AE =0000002D                M 	__midpos:	= __endpos
0000D9AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AE                          M 	__param:	substr ,,"hex"
0000D9AE 80                       M 	dc.b	hex
0000D9AF =0000002E                M 	__lpos:	set __endpos+1
0000D9AF =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9AF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9AF 20                       M 	dc.b	" "
0000D9B0 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D9B0 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D9B0 =00000036                M 	__midpos:	= __endpos
0000D9B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B0 EC                       M 	dc.b	fpal2
0000D9B1 =00000037                M 	__lpos:	set __endpos+1
0000D9B1 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9B1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B1                          M 	dc.b	""
0000D9B1 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D9B1 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D9B1 =00000048                M 	__midpos:	= __endpos
0000D9B1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B1                          M 	__param:	substr ,,"hex"
0000D9B1 81                       M 	dc.b	hex|1
0000D9B2 =00000049                M 	__lpos:	set __endpos+1
0000D9B2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D9B2                          M 	__substr:	substr __lpos,,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D9B2 20                       M 	dc.b	" "
0000D9B3 00                       M 	dc.b	0
0000D9B4                          M 	even
0000D9B4                          M 	.instr_end_381:
0000D9B4                            	Console.WriteLine "%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B4 40E7                     M 	move.w	sr,-(sp)
0000D9B6                          M 	__fstring_generateargumentscode	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6 =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9B6 =00000000                M 	__stack:set	0
0000D9B6 =00000000                M 	__sp:	set 0
0000D9B6                          M 	while	(__pos)
0000D9B6 =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9B6 =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9B6 =00000013                M 	__midpos:	= __endpos
0000D9B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	pushp	"move.b cModSpeed(a5),1(sp)"
0000D9B6                          M 	pushp	"subq.w	#2, sp"
0000D9B6 =00000002                M 	__stack:	= __stack+2
0000D9B6 =00000002                M 	__sp:	= __sp+2
0000D9B6 =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9B6 =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9B6 =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9B6 =00000026                M 	__midpos:	= __endpos
0000D9B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	pushp	"move.b cModStep(a5),1(sp)"
0000D9B6                          M 	pushp	"subq.w	#2, sp"
0000D9B6 =00000004                M 	__stack:	= __stack+2
0000D9B6 =00000004                M 	__sp:	= __sp+2
0000D9B6 =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9B6 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9B6 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9B6 =0000003A                M 	__midpos:	= __endpos
0000D9B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9B6                          M 	pushp	"move.b cModCount(a5),1(sp)"
0000D9B6                          M 	pushp	"subq.w	#2, sp"
0000D9B6 =00000006                M 	__stack:	= __stack+2
0000D9B6 =00000006                M 	__sp:	= __sp+2
0000D9B6 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9B6                          M 	rept	__stack
0000D9B6                          M 	popp	__command
0000D9B6 554F                     M 	subq.w	#2,sp
0000D9B8                          M 	popp	__command
0000D9B8 1F6D 0018 0001           M 	move.b	cmodcount(a5),1(sp)
0000D9BE                          M 	popp	__command
0000D9BE 554F                     M 	subq.w	#2,sp
0000D9C0                          M 	popp	__command
0000D9C0 1F6D 0017 0001           M 	move.b	cmodstep(a5),1(sp)
0000D9C6                          M 	popp	__command
0000D9C6 554F                     M 	subq.w	#2,sp
0000D9C8                          M 	popp	__command
0000D9C8 1F6D 0016 0001           M 	move.b	cmodspeed(a5),1(sp)
0000D9CE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9D2 45EF 0010                M 	lea	4*4(sp),a2
0000D9D6 43FA 0000                M 	lea	.str_384(pc),a1
0000D9DA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D9E0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9E4 5C4F                     M 	addq.w	#__sp,sp
0000D9E6 46DF                     M 	move.w	(sp)+,sr
0000D9E8 6000 0000                M 	bra.w	.instr_end_384
0000D9EC                          M 	.str_384:
0000D9EC                          M 	__fstring_generatedecodedstring	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EC =00000001                M 	__lpos:	set 1
0000D9EC =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9EC                          M 	while	(__pos)
0000D9EC                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EC                          M 	dc.b	""
0000D9EC =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9EC =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9EC =00000013                M 	__midpos:	= __endpos
0000D9EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EC                          M 	__param:	substr ,,"hex"
0000D9EC 80                       M 	dc.b	hex
0000D9ED =00000014                M 	__lpos:	set __endpos+1
0000D9ED =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9ED                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9ED 20                       M 	dc.b	" "
0000D9EE =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9EE =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9EE =00000026                M 	__midpos:	= __endpos
0000D9EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EE                          M 	__param:	substr ,,"hex"
0000D9EE 80                       M 	dc.b	hex
0000D9EF =00000027                M 	__lpos:	set __endpos+1
0000D9EF =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9EF                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9EF 20                       M 	dc.b	" "
0000D9F0 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D9F0 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D9F0 =0000003A                M 	__midpos:	= __endpos
0000D9F0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9F0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9F0                          M 	__param:	substr ,,"hex"
0000D9F0 80                       M 	dc.b	hex
0000D9F1 =0000003B                M 	__lpos:	set __endpos+1
0000D9F1 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D9F1                          M 	__substr:	substr __lpos,,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D9F1                          M 	dc.b	""
0000D9F1 00                       M 	dc.b	0
0000D9F2                          M 	even
0000D9F2                          M 	.instr_end_384:
0000D9F2                            	Console.BreakLine
0000D9F2 40E7                     M 	move.w	sr,-(sp)
0000D9F4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D9FA 46DF                     M 	move.w	(sp)+,sr
0000D9FC                            
0000D9FC                            	Console.Write "%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FC 40E7                     M 	move.w	sr,-(sp)
0000D9FE                          M 	__fstring_generateargumentscode	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE =00000000                M 	__stack:set	0
0000D9FE =00000000                M 	__sp:	set 0
0000D9FE                          M 	while	(__pos)
0000D9FE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9FE =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9FE =00000008                M 	__midpos:	= __endpos
0000D9FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9FE =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9FE =00000016                M 	__midpos:	= __endpos
0000D9FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9FE =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9FE =00000025                M 	__midpos:	= __endpos
0000D9FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000D9FE                          M 	pushp	"subq.w	#2, sp"
0000D9FE =00000002                M 	__stack:	= __stack+2
0000D9FE =00000002                M 	__sp:	= __sp+2
0000D9FE =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9FE =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9FE =00000037                M 	__midpos:	= __endpos
0000D9FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000D9FE                          M 	pushp	"subq.w	#2, sp"
0000D9FE =00000004                M 	__stack:	= __stack+2
0000D9FE =00000004                M 	__sp:	= __sp+2
0000D9FE =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9FE =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9FE =00000049                M 	__midpos:	= __endpos
0000D9FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9FE                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000D9FE                          M 	pushp	"subq.w	#2, sp"
0000D9FE =00000006                M 	__stack:	= __stack+2
0000D9FE =00000006                M 	__sp:	= __sp+2
0000D9FE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9FE                          M 	rept	__stack
0000D9FE                          M 	popp	__command
0000D9FE 554F                     M 	subq.w	#2,sp
0000DA00                          M 	popp	__command
0000DA00 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000DA06                          M 	popp	__command
0000DA06 554F                     M 	subq.w	#2,sp
0000DA08                          M 	popp	__command
0000DA08 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000DA0E                          M 	popp	__command
0000DA0E 554F                     M 	subq.w	#2,sp
0000DA10                          M 	popp	__command
0000DA10 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000DA16 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA1A 45EF 0010                M 	lea	4*4(sp),a2
0000DA1E 43FA 0000                M 	lea	.str_388(pc),a1
0000DA22 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DA28 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA2C 5C4F                     M 	addq.w	#__sp,sp
0000DA2E 46DF                     M 	move.w	(sp)+,sr
0000DA30 6000 0000                M 	bra.w	.instr_end_388
0000DA34                          M 	.str_388:
0000DA34                          M 	__fstring_generatedecodedstring	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA34 =00000001                M 	__lpos:	set 1
0000DA34 =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA34                          M 	while	(__pos)
0000DA34                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA34                          M 	dc.b	""
0000DA34 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000DA34 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000DA34 =00000008                M 	__midpos:	= __endpos
0000DA34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA34                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA34 EA                       M 	dc.b	fpal1
0000DA35 =00000009                M 	__lpos:	set __endpos+1
0000DA35 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA35                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA35 4C6F 6F70 3A20           M 	dc.b	"Loop: "
0000DA3B =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000DA3B =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000DA3B =00000016                M 	__midpos:	= __endpos
0000DA3B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3B EC                       M 	dc.b	fpal2
0000DA3C =00000017                M 	__lpos:	set __endpos+1
0000DA3C =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA3C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3C                          M 	dc.b	""
0000DA3C =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000DA3C =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000DA3C =00000025                M 	__midpos:	= __endpos
0000DA3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3C                          M 	__param:	substr ,,"hex"
0000DA3C 80                       M 	dc.b	hex
0000DA3D =00000026                M 	__lpos:	set __endpos+1
0000DA3D =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA3D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3D 20                       M 	dc.b	" "
0000DA3E =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000DA3E =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000DA3E =00000037                M 	__midpos:	= __endpos
0000DA3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3E                          M 	__param:	substr ,,"hex"
0000DA3E 80                       M 	dc.b	hex
0000DA3F =00000038                M 	__lpos:	set __endpos+1
0000DA3F =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA3F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA3F 20                       M 	dc.b	" "
0000DA40 =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000DA40 =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000DA40 =00000049                M 	__midpos:	= __endpos
0000DA40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA40                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA40                          M 	__param:	substr ,,"hex"
0000DA40 80                       M 	dc.b	hex
0000DA41 =0000004A                M 	__lpos:	set __endpos+1
0000DA41 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000DA41                          M 	__substr:	substr __lpos,,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000DA41 20                       M 	dc.b	" "
0000DA42 00                       M 	dc.b	0
0000DA44 00                       M 	even
0000DA44                          M 	.instr_end_388:
0000DA44 BAFC C67C                  	cmp.w	#mSFXDAC1,a5
0000DA48 6400 0000                  	bhs.w	AMPS_Debug_Console_Channel_Writerts
0000DA4C                            	Console.WriteLine "%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4C 40E7                     M 	move.w	sr,-(sp)
0000DA4E                          M 	__fstring_generateargumentscode	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA4E =00000000                M 	__stack:set	0
0000DA4E =00000000                M 	__sp:	set 0
0000DA4E                          M 	while	(__pos)
0000DA4E =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000DA4E =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000DA4E =00000016                M 	__midpos:	= __endpos
0000DA4E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	pushp	"move.b cNoteTimeCur(a5),1(sp)"
0000DA4E                          M 	pushp	"subq.w	#2, sp"
0000DA4E =00000002                M 	__stack:	= __stack+2
0000DA4E =00000002                M 	__sp:	= __sp+2
0000DA4E =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA4E =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000DA4E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000DA4E =0000002E                M 	__midpos:	= __endpos
0000DA4E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA4E                          M 	pushp	"move.b cNoteTimeMain(a5),1(sp)"
0000DA4E                          M 	pushp	"subq.w	#2, sp"
0000DA4E =00000004                M 	__stack:	= __stack+2
0000DA4E =00000004                M 	__sp:	= __sp+2
0000DA4E =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA4E                          M 	rept	__stack
0000DA4E                          M 	popp	__command
0000DA4E 554F                     M 	subq.w	#2,sp
0000DA50                          M 	popp	__command
0000DA50 1F6D 001D 0001           M 	move.b	cnotetimemain(a5),1(sp)
0000DA56                          M 	popp	__command
0000DA56 554F                     M 	subq.w	#2,sp
0000DA58                          M 	popp	__command
0000DA58 1F6D 001C 0001           M 	move.b	cnotetimecur(a5),1(sp)
0000DA5E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA62 45EF 0010                M 	lea	4*4(sp),a2
0000DA66 43FA 0000                M 	lea	.str_391(pc),a1
0000DA6A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA70 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA74 584F                     M 	addq.w	#__sp,sp
0000DA76 46DF                     M 	move.w	(sp)+,sr
0000DA78 6000 0000                M 	bra.w	.instr_end_391
0000DA7C                          M 	.str_391:
0000DA7C                          M 	__fstring_generatedecodedstring	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7C =00000001                M 	__lpos:	set 1
0000DA7C =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA7C                          M 	while	(__pos)
0000DA7C                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7C                          M 	dc.b	""
0000DA7C =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000DA7C =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000DA7C =00000016                M 	__midpos:	= __endpos
0000DA7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7C                          M 	__param:	substr ,,"hex"
0000DA7C 80                       M 	dc.b	hex
0000DA7D =00000017                M 	__lpos:	set __endpos+1
0000DA7D =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA7D                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7D 20                       M 	dc.b	" "
0000DA7E =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000DA7E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000DA7E =0000002E                M 	__midpos:	= __endpos
0000DA7E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7E                          M 	__param:	substr ,,"hex"
0000DA7E 80                       M 	dc.b	hex
0000DA7F =0000002F                M 	__lpos:	set __endpos+1
0000DA7F =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000DA7F                          M 	__substr:	substr __lpos,,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000DA7F                          M 	dc.b	""
0000DA7F 00                       M 	dc.b	0
0000DA80                          M 	even
0000DA80                          M 	.instr_end_391:
0000DA80                            	Console.WriteLine "%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA80 40E7                     M 	move.w	sr,-(sp)
0000DA82                          M 	__fstring_generateargumentscode	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA82 =00000000                M 	__stack:set	0
0000DA82 =00000000                M 	__sp:	set 0
0000DA82                          M 	while	(__pos)
0000DA82 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA82 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA82 =00000008                M 	__midpos:	= __endpos
0000DA82                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA82 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA82 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA82 =00000017                M 	__midpos:	= __endpos
0000DA82                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA82 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA82 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA82 =00000027                M 	__midpos:	= __endpos
0000DA82                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA82                          M 	pushp	"move.b cStack(a5),1(sp)"
0000DA82                          M 	pushp	"subq.w	#2, sp"
0000DA82 =00000002                M 	__stack:	= __stack+2
0000DA82 =00000002                M 	__sp:	= __sp+2
0000DA82 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA82                          M 	rept	__stack
0000DA82                          M 	popp	__command
0000DA82 554F                     M 	subq.w	#2,sp
0000DA84                          M 	popp	__command
0000DA84 1F6D 001E 0001           M 	move.b	cstack(a5),1(sp)
0000DA8A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA8E 45EF 0010                M 	lea	4*4(sp),a2
0000DA92 43FA 0000                M 	lea	.str_394(pc),a1
0000DA96 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA9C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAA0 544F                     M 	addq.w	#__sp,sp
0000DAA2 46DF                     M 	move.w	(sp)+,sr
0000DAA4 6000 0000                M 	bra.w	.instr_end_394
0000DAA8                          M 	.str_394:
0000DAA8                          M 	__fstring_generatedecodedstring	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAA8 =00000001                M 	__lpos:	set 1
0000DAA8 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DAA8                          M 	while	(__pos)
0000DAA8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAA8                          M 	dc.b	""
0000DAA8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DAA8 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DAA8 =00000008                M 	__midpos:	= __endpos
0000DAA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAA8 EA                       M 	dc.b	fpal1
0000DAA9 =00000009                M 	__lpos:	set __endpos+1
0000DAA9 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DAA9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAA9 5374 6163 6B3A 20        M 	dc.b	"Stack: "
0000DAB0 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DAB0 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DAB0 =00000017                M 	__midpos:	= __endpos
0000DAB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB0 EC                       M 	dc.b	fpal2
0000DAB1 =00000018                M 	__lpos:	set __endpos+1
0000DAB1 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DAB1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB1                          M 	dc.b	""
0000DAB1 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DAB1 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DAB1 =00000027                M 	__midpos:	= __endpos
0000DAB1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB1                          M 	__param:	substr ,,"hex"
0000DAB1 80                       M 	dc.b	hex
0000DAB2 =00000028                M 	__lpos:	set __endpos+1
0000DAB2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DAB2                          M 	__substr:	substr __lpos,,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DAB2                          M 	dc.b	""
0000DAB2 00                       M 	dc.b	0
0000DAB4 00                       M 	even
0000DAB4                          M 	.instr_end_394:
0000DAB4                            
0000DAB4 320D                       	move.w	a5,d1
0000DAB6 0641 002C                  	add.w	#cSize,d1
0000DABA                            
0000DABA 7000                       	moveq	#0,d0
0000DABC 102D 001E                  	move.b	cStack(a5),d0
0000DAC0 DAC0                       	add.w	d0,a5
0000DAC2                            
0000DAC2                            AMPS_Debug_Console_Channel_Writeloop
0000DAC2 B24D                       	cmp.w	a5,d1
0000DAC4 6300                       	bls.s	AMPS_Debug_Console_Channel_Writerts
0000DAC6                            	Console.WriteLine "%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC6 40E7                     M 	move.w	sr,-(sp)
0000DAC8                          M 	__fstring_generateargumentscode	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAC8 =00000000                M 	__stack:set	0
0000DAC8 =00000000                M 	__sp:	set 0
0000DAC8                          M 	while	(__pos)
0000DAC8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAC8 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAC8 =00000008                M 	__midpos:	= __endpos
0000DAC8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAC8 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAC8 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAC8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	pushp	"move.l (a5)+,-(sp)"
0000DAC8 =00000001                M 	__stack:	= __stack+1
0000DAC8 =00000004                M 	__sp:	= __sp+4
0000DAC8 =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAC8 =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAC8 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAC8 =0000002F                M 	__midpos:	= __endpos
0000DAC8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAC8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAC8                          M 	rept	__stack
0000DAC8                          M 	popp	__command
0000DAC8 2F1D                     M 	move.l	(a5)+,-(sp)
0000DACA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DACE 45EF 0010                M 	lea	4*4(sp),a2
0000DAD2 43FA 0000                M 	lea	.str_397(pc),a1
0000DAD6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DADC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAE0 584F                     M 	addq.w	#__sp,sp
0000DAE2 46DF                     M 	move.w	(sp)+,sr
0000DAE4 6000 0000                M 	bra.w	.instr_end_397
0000DAE8                          M 	.str_397:
0000DAE8                          M 	__fstring_generatedecodedstring	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE8 =00000001                M 	__lpos:	set 1
0000DAE8 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAE8                          M 	while	(__pos)
0000DAE8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE8                          M 	dc.b	""
0000DAE8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAE8 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAE8 =00000008                M 	__midpos:	= __endpos
0000DAE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE8 E8                       M 	dc.b	fpal0
0000DAE9 =00000009                M 	__lpos:	set __endpos+1
0000DAE9 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAE9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE9                          M 	dc.b	""
0000DAE9 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAE9 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAE9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE9                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAE9 BB                       M 	dc.b	sym|fsplit|3
0000DAEA =0000001F                M 	__lpos:	set __endpos+1
0000DAEA =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAEA                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAEA                          M 	dc.b	""
0000DAEA =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DAEA =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DAEA =0000002F                M 	__midpos:	= __endpos
0000DAEA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAEA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAEA ECC0                     M 	dc.b	fpal2,fsymdisp
0000DAEC =00000030                M 	__lpos:	set __endpos+1
0000DAEC =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DAEC                          M 	__substr:	substr __lpos,,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DAEC                          M 	dc.b	""
0000DAEC 00                       M 	dc.b	0
0000DAEE 00                       M 	even
0000DAEE                          M 	.instr_end_397:
0000DAEE 60D2                       	bra.s	AMPS_Debug_Console_Channel_Writeloop
0000DAF0                            
0000DAF0                            AMPS_Debug_Console_Channel_Writerts
0000DAF0 4E75                       	rts
0000DAF2                            ; ===========================================================================
0000DAF2                            ; ---------------------------------------------------------------------------
0000DAF2                            ; Generic console code
0000DAF2                            ; ---------------------------------------------------------------------------
0000DAF2                            
0000DAF2                            AMPS_Debug_Console_Main:
0000DAF2                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF2 40E7                     M 	move.w	sr,-(sp)
0000DAF4                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =00000000                M 	__stack:set	0
0000DAF4 =00000000                M 	__sp:	set 0
0000DAF4                          M 	while	(__pos)
0000DAF4 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =0000000A                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =00000016                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =0000001E                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	pushp	"move.l d0,-(sp)"
0000DAF4 =00000001                M 	__stack:	= __stack+1
0000DAF4 =00000004                M 	__sp:	= __sp+4
0000DAF4 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =00000028                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =00000034                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DAF4 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DAF4 =0000003C                M 	__midpos:	= __endpos
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DAF4                          M 	pushp	"move.l a0,-(sp)"
0000DAF4 =00000002                M 	__stack:	= __stack+1
0000DAF4 =00000008                M 	__sp:	= __sp+4
0000DAF4 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DAF4                          M 	rept	__stack
0000DAF4                          M 	popp	__command
0000DAF4 2F08                     M 	move.l	a0,-(sp)
0000DAF6                          M 	popp	__command
0000DAF6 2F00                     M 	move.l	d0,-(sp)
0000DAF8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DAFC 45EF 0010                M 	lea	4*4(sp),a2
0000DB00 43FA 0000                M 	lea	.str_400(pc),a1
0000DB04 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB0A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB0E 504F                     M 	addq.w	#__sp,sp
0000DB10 46DF                     M 	move.w	(sp)+,sr
0000DB12 6000 0000                M 	bra.w	.instr_end_400
0000DB16                          M 	.str_400:
0000DB16                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB16 =00000001                M 	__lpos:	set 1
0000DB16 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB16                          M 	while	(__pos)
0000DB16                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB16 2020                     M 	dc.b	"  "
0000DB18 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB18 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB18 =0000000A                M 	__midpos:	= __endpos
0000DB18                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB18                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB18 E8                       M 	dc.b	fpal0
0000DB19 =0000000B                M 	__lpos:	set __endpos+1
0000DB19 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB19                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB19 6430 3A20                M 	dc.b	"d0: "
0000DB1D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB1D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB1D =00000016                M 	__midpos:	= __endpos
0000DB1D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1D EC                       M 	dc.b	fpal2
0000DB1E =00000017                M 	__lpos:	set __endpos+1
0000DB1E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB1E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1E                          M 	dc.b	""
0000DB1E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB1E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB1E =0000001E                M 	__midpos:	= __endpos
0000DB1E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1E                          M 	__param:	substr ,,"hex"
0000DB1E 83                       M 	dc.b	hex|3
0000DB1F =0000001F                M 	__lpos:	set __endpos+1
0000DB1F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB1F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB1F 2020                     M 	dc.b	"  "
0000DB21 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB21 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB21 =00000028                M 	__midpos:	= __endpos
0000DB21                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB21                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB21 E8                       M 	dc.b	fpal0
0000DB22 =00000029                M 	__lpos:	set __endpos+1
0000DB22 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB22                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB22 6130 3A20                M 	dc.b	"a0: "
0000DB26 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB26 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB26 =00000034                M 	__midpos:	= __endpos
0000DB26                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB26                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB26 EC                       M 	dc.b	fpal2
0000DB27 =00000035                M 	__lpos:	set __endpos+1
0000DB27 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB27                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB27                          M 	dc.b	""
0000DB27 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DB27 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DB27 =0000003C                M 	__midpos:	= __endpos
0000DB27                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB27                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB27                          M 	__param:	substr ,,"hex"
0000DB27 83                       M 	dc.b	hex|3
0000DB28 =0000003D                M 	__lpos:	set __endpos+1
0000DB28 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DB28                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DB28                          M 	dc.b	""
0000DB28 00                       M 	dc.b	0
0000DB2A 00                       M 	even
0000DB2A                          M 	.instr_end_400:
0000DB2A                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2A 40E7                     M 	move.w	sr,-(sp)
0000DB2C                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =00000000                M 	__stack:set	0
0000DB2C =00000000                M 	__sp:	set 0
0000DB2C                          M 	while	(__pos)
0000DB2C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =0000000A                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =00000016                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =0000001E                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	pushp	"move.l d1,-(sp)"
0000DB2C =00000001                M 	__stack:	= __stack+1
0000DB2C =00000004                M 	__sp:	= __sp+4
0000DB2C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =00000028                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =00000034                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB2C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB2C =0000003C                M 	__midpos:	= __endpos
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB2C                          M 	pushp	"move.l a1,-(sp)"
0000DB2C =00000002                M 	__stack:	= __stack+1
0000DB2C =00000008                M 	__sp:	= __sp+4
0000DB2C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB2C                          M 	rept	__stack
0000DB2C                          M 	popp	__command
0000DB2C 2F09                     M 	move.l	a1,-(sp)
0000DB2E                          M 	popp	__command
0000DB2E 2F01                     M 	move.l	d1,-(sp)
0000DB30 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB34 45EF 0010                M 	lea	4*4(sp),a2
0000DB38 43FA 0000                M 	lea	.str_403(pc),a1
0000DB3C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB42 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB46 504F                     M 	addq.w	#__sp,sp
0000DB48 46DF                     M 	move.w	(sp)+,sr
0000DB4A 6000 0000                M 	bra.w	.instr_end_403
0000DB4E                          M 	.str_403:
0000DB4E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB4E =00000001                M 	__lpos:	set 1
0000DB4E =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB4E                          M 	while	(__pos)
0000DB4E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB4E 2020                     M 	dc.b	"  "
0000DB50 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB50 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB50 =0000000A                M 	__midpos:	= __endpos
0000DB50                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB50                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB50 E8                       M 	dc.b	fpal0
0000DB51 =0000000B                M 	__lpos:	set __endpos+1
0000DB51 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB51                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB51 6431 3A20                M 	dc.b	"d1: "
0000DB55 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB55 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB55 =00000016                M 	__midpos:	= __endpos
0000DB55                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB55                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB55 EC                       M 	dc.b	fpal2
0000DB56 =00000017                M 	__lpos:	set __endpos+1
0000DB56 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB56                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB56                          M 	dc.b	""
0000DB56 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB56 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB56 =0000001E                M 	__midpos:	= __endpos
0000DB56                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB56                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB56                          M 	__param:	substr ,,"hex"
0000DB56 83                       M 	dc.b	hex|3
0000DB57 =0000001F                M 	__lpos:	set __endpos+1
0000DB57 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB57                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB57 2020                     M 	dc.b	"  "
0000DB59 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB59 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB59 =00000028                M 	__midpos:	= __endpos
0000DB59                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB59                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB59 E8                       M 	dc.b	fpal0
0000DB5A =00000029                M 	__lpos:	set __endpos+1
0000DB5A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB5A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5A 6131 3A20                M 	dc.b	"a1: "
0000DB5E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB5E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB5E =00000034                M 	__midpos:	= __endpos
0000DB5E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5E EC                       M 	dc.b	fpal2
0000DB5F =00000035                M 	__lpos:	set __endpos+1
0000DB5F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB5F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5F                          M 	dc.b	""
0000DB5F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DB5F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DB5F =0000003C                M 	__midpos:	= __endpos
0000DB5F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB5F                          M 	__param:	substr ,,"hex"
0000DB5F 83                       M 	dc.b	hex|3
0000DB60 =0000003D                M 	__lpos:	set __endpos+1
0000DB60 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DB60                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DB60                          M 	dc.b	""
0000DB60 00                       M 	dc.b	0
0000DB62 00                       M 	even
0000DB62                          M 	.instr_end_403:
0000DB62                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB62 40E7                     M 	move.w	sr,-(sp)
0000DB64                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =00000000                M 	__stack:set	0
0000DB64 =00000000                M 	__sp:	set 0
0000DB64                          M 	while	(__pos)
0000DB64 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =0000000A                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =00000016                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =0000001E                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	pushp	"move.l d2,-(sp)"
0000DB64 =00000001                M 	__stack:	= __stack+1
0000DB64 =00000004                M 	__sp:	= __sp+4
0000DB64 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =00000028                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =00000034                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB64 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB64 =0000003C                M 	__midpos:	= __endpos
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB64                          M 	pushp	"move.l a2,-(sp)"
0000DB64 =00000002                M 	__stack:	= __stack+1
0000DB64 =00000008                M 	__sp:	= __sp+4
0000DB64 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB64                          M 	rept	__stack
0000DB64                          M 	popp	__command
0000DB64 2F0A                     M 	move.l	a2,-(sp)
0000DB66                          M 	popp	__command
0000DB66 2F02                     M 	move.l	d2,-(sp)
0000DB68 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB6C 45EF 0010                M 	lea	4*4(sp),a2
0000DB70 43FA 0000                M 	lea	.str_406(pc),a1
0000DB74 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB7A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB7E 504F                     M 	addq.w	#__sp,sp
0000DB80 46DF                     M 	move.w	(sp)+,sr
0000DB82 6000 0000                M 	bra.w	.instr_end_406
0000DB86                          M 	.str_406:
0000DB86                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB86 =00000001                M 	__lpos:	set 1
0000DB86 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB86                          M 	while	(__pos)
0000DB86                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB86 2020                     M 	dc.b	"  "
0000DB88 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB88 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB88 =0000000A                M 	__midpos:	= __endpos
0000DB88                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB88                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB88 E8                       M 	dc.b	fpal0
0000DB89 =0000000B                M 	__lpos:	set __endpos+1
0000DB89 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB89                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB89 6432 3A20                M 	dc.b	"d2: "
0000DB8D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB8D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB8D =00000016                M 	__midpos:	= __endpos
0000DB8D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8D EC                       M 	dc.b	fpal2
0000DB8E =00000017                M 	__lpos:	set __endpos+1
0000DB8E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB8E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8E                          M 	dc.b	""
0000DB8E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB8E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB8E =0000001E                M 	__midpos:	= __endpos
0000DB8E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8E                          M 	__param:	substr ,,"hex"
0000DB8E 83                       M 	dc.b	hex|3
0000DB8F =0000001F                M 	__lpos:	set __endpos+1
0000DB8F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB8F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB8F 2020                     M 	dc.b	"  "
0000DB91 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB91 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB91 =00000028                M 	__midpos:	= __endpos
0000DB91                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB91                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB91 E8                       M 	dc.b	fpal0
0000DB92 =00000029                M 	__lpos:	set __endpos+1
0000DB92 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB92                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB92 6132 3A20                M 	dc.b	"a2: "
0000DB96 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB96 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB96 =00000034                M 	__midpos:	= __endpos
0000DB96                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB96                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB96 EC                       M 	dc.b	fpal2
0000DB97 =00000035                M 	__lpos:	set __endpos+1
0000DB97 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB97                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB97                          M 	dc.b	""
0000DB97 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB97 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB97 =0000003C                M 	__midpos:	= __endpos
0000DB97                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB97                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB97                          M 	__param:	substr ,,"hex"
0000DB97 83                       M 	dc.b	hex|3
0000DB98 =0000003D                M 	__lpos:	set __endpos+1
0000DB98 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB98                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB98                          M 	dc.b	""
0000DB98 00                       M 	dc.b	0
0000DB9A 00                       M 	even
0000DB9A                          M 	.instr_end_406:
0000DB9A                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9A 40E7                     M 	move.w	sr,-(sp)
0000DB9C                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =00000000                M 	__stack:set	0
0000DB9C =00000000                M 	__sp:	set 0
0000DB9C                          M 	while	(__pos)
0000DB9C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =0000000A                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =00000016                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =0000001E                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	pushp	"move.l d3,-(sp)"
0000DB9C =00000001                M 	__stack:	= __stack+1
0000DB9C =00000004                M 	__sp:	= __sp+4
0000DB9C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =00000028                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =00000034                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB9C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB9C =0000003C                M 	__midpos:	= __endpos
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB9C                          M 	pushp	"move.l a3,-(sp)"
0000DB9C =00000002                M 	__stack:	= __stack+1
0000DB9C =00000008                M 	__sp:	= __sp+4
0000DB9C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB9C                          M 	rept	__stack
0000DB9C                          M 	popp	__command
0000DB9C 2F0B                     M 	move.l	a3,-(sp)
0000DB9E                          M 	popp	__command
0000DB9E 2F03                     M 	move.l	d3,-(sp)
0000DBA0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DBA4 45EF 0010                M 	lea	4*4(sp),a2
0000DBA8 43FA 0000                M 	lea	.str_409(pc),a1
0000DBAC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DBB2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DBB6 504F                     M 	addq.w	#__sp,sp
0000DBB8 46DF                     M 	move.w	(sp)+,sr
0000DBBA 6000 0000                M 	bra.w	.instr_end_409
0000DBBE                          M 	.str_409:
0000DBBE                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBBE =00000001                M 	__lpos:	set 1
0000DBBE =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBBE                          M 	while	(__pos)
0000DBBE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBBE 2020                     M 	dc.b	"  "
0000DBC0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBC0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBC0 =0000000A                M 	__midpos:	= __endpos
0000DBC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC0 E8                       M 	dc.b	fpal0
0000DBC1 =0000000B                M 	__lpos:	set __endpos+1
0000DBC1 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBC1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC1 6433 3A20                M 	dc.b	"d3: "
0000DBC5 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBC5 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBC5 =00000016                M 	__midpos:	= __endpos
0000DBC5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC5 EC                       M 	dc.b	fpal2
0000DBC6 =00000017                M 	__lpos:	set __endpos+1
0000DBC6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBC6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC6                          M 	dc.b	""
0000DBC6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBC6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBC6 =0000001E                M 	__midpos:	= __endpos
0000DBC6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC6                          M 	__param:	substr ,,"hex"
0000DBC6 83                       M 	dc.b	hex|3
0000DBC7 =0000001F                M 	__lpos:	set __endpos+1
0000DBC7 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBC7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC7 2020                     M 	dc.b	"  "
0000DBC9 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBC9 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBC9 =00000028                M 	__midpos:	= __endpos
0000DBC9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBC9 E8                       M 	dc.b	fpal0
0000DBCA =00000029                M 	__lpos:	set __endpos+1
0000DBCA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBCA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCA 6133 3A20                M 	dc.b	"a3: "
0000DBCE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBCE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBCE =00000034                M 	__midpos:	= __endpos
0000DBCE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCE EC                       M 	dc.b	fpal2
0000DBCF =00000035                M 	__lpos:	set __endpos+1
0000DBCF =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBCF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCF                          M 	dc.b	""
0000DBCF =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DBCF =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DBCF =0000003C                M 	__midpos:	= __endpos
0000DBCF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCF                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBCF                          M 	__param:	substr ,,"hex"
0000DBCF 83                       M 	dc.b	hex|3
0000DBD0 =0000003D                M 	__lpos:	set __endpos+1
0000DBD0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DBD0                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DBD0                          M 	dc.b	""
0000DBD0 00                       M 	dc.b	0
0000DBD2 00                       M 	even
0000DBD2                          M 	.instr_end_409:
0000DBD2                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD2 40E7                     M 	move.w	sr,-(sp)
0000DBD4                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =00000000                M 	__stack:set	0
0000DBD4 =00000000                M 	__sp:	set 0
0000DBD4                          M 	while	(__pos)
0000DBD4 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =0000000A                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =00000016                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =0000001E                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	pushp	"move.l d4,-(sp)"
0000DBD4 =00000001                M 	__stack:	= __stack+1
0000DBD4 =00000004                M 	__sp:	= __sp+4
0000DBD4 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =00000028                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =00000034                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBD4 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBD4 =0000003C                M 	__midpos:	= __endpos
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBD4                          M 	pushp	"move.l a4,-(sp)"
0000DBD4 =00000002                M 	__stack:	= __stack+1
0000DBD4 =00000008                M 	__sp:	= __sp+4
0000DBD4 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBD4                          M 	rept	__stack
0000DBD4                          M 	popp	__command
0000DBD4 2F0C                     M 	move.l	a4,-(sp)
0000DBD6                          M 	popp	__command
0000DBD6 2F04                     M 	move.l	d4,-(sp)
0000DBD8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DBDC 45EF 0010                M 	lea	4*4(sp),a2
0000DBE0 43FA 0000                M 	lea	.str_412(pc),a1
0000DBE4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DBEA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DBEE 504F                     M 	addq.w	#__sp,sp
0000DBF0 46DF                     M 	move.w	(sp)+,sr
0000DBF2 6000 0000                M 	bra.w	.instr_end_412
0000DBF6                          M 	.str_412:
0000DBF6                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBF6 =00000001                M 	__lpos:	set 1
0000DBF6 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBF6                          M 	while	(__pos)
0000DBF6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBF6 2020                     M 	dc.b	"  "
0000DBF8 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBF8 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBF8 =0000000A                M 	__midpos:	= __endpos
0000DBF8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBF8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBF8 E8                       M 	dc.b	fpal0
0000DBF9 =0000000B                M 	__lpos:	set __endpos+1
0000DBF9 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBF9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBF9 6434 3A20                M 	dc.b	"d4: "
0000DBFD =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBFD =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBFD =00000016                M 	__midpos:	= __endpos
0000DBFD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFD EC                       M 	dc.b	fpal2
0000DBFE =00000017                M 	__lpos:	set __endpos+1
0000DBFE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBFE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFE                          M 	dc.b	""
0000DBFE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DBFE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DBFE =0000001E                M 	__midpos:	= __endpos
0000DBFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFE                          M 	__param:	substr ,,"hex"
0000DBFE 83                       M 	dc.b	hex|3
0000DBFF =0000001F                M 	__lpos:	set __endpos+1
0000DBFF =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DBFF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DBFF 2020                     M 	dc.b	"  "
0000DC01 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DC01 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DC01 =00000028                M 	__midpos:	= __endpos
0000DC01                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC01                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC01 E8                       M 	dc.b	fpal0
0000DC02 =00000029                M 	__lpos:	set __endpos+1
0000DC02 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DC02                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC02 6134 3A20                M 	dc.b	"a4: "
0000DC06 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DC06 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DC06 =00000034                M 	__midpos:	= __endpos
0000DC06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC06                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC06 EC                       M 	dc.b	fpal2
0000DC07 =00000035                M 	__lpos:	set __endpos+1
0000DC07 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DC07                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC07                          M 	dc.b	""
0000DC07 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DC07 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DC07 =0000003C                M 	__midpos:	= __endpos
0000DC07                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC07                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC07                          M 	__param:	substr ,,"hex"
0000DC07 83                       M 	dc.b	hex|3
0000DC08 =0000003D                M 	__lpos:	set __endpos+1
0000DC08 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DC08                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DC08                          M 	dc.b	""
0000DC08 00                       M 	dc.b	0
0000DC0A 00                       M 	even
0000DC0A                          M 	.instr_end_412:
0000DC0A                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0A 40E7                     M 	move.w	sr,-(sp)
0000DC0C                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =00000000                M 	__stack:set	0
0000DC0C =00000000                M 	__sp:	set 0
0000DC0C                          M 	while	(__pos)
0000DC0C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =0000000A                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =00000016                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =0000001E                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	pushp	"move.l d5,-(sp)"
0000DC0C =00000001                M 	__stack:	= __stack+1
0000DC0C =00000004                M 	__sp:	= __sp+4
0000DC0C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =00000028                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =00000034                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC0C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC0C =0000003C                M 	__midpos:	= __endpos
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC0C                          M 	pushp	"move.l a5,-(sp)"
0000DC0C =00000002                M 	__stack:	= __stack+1
0000DC0C =00000008                M 	__sp:	= __sp+4
0000DC0C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC0C                          M 	rept	__stack
0000DC0C                          M 	popp	__command
0000DC0C 2F0D                     M 	move.l	a5,-(sp)
0000DC0E                          M 	popp	__command
0000DC0E 2F05                     M 	move.l	d5,-(sp)
0000DC10 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC14 45EF 0010                M 	lea	4*4(sp),a2
0000DC18 43FA 0000                M 	lea	.str_415(pc),a1
0000DC1C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DC22 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC26 504F                     M 	addq.w	#__sp,sp
0000DC28 46DF                     M 	move.w	(sp)+,sr
0000DC2A 6000 0000                M 	bra.w	.instr_end_415
0000DC2E                          M 	.str_415:
0000DC2E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC2E =00000001                M 	__lpos:	set 1
0000DC2E =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC2E                          M 	while	(__pos)
0000DC2E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC2E 2020                     M 	dc.b	"  "
0000DC30 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC30 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC30 =0000000A                M 	__midpos:	= __endpos
0000DC30                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC30                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC30 E8                       M 	dc.b	fpal0
0000DC31 =0000000B                M 	__lpos:	set __endpos+1
0000DC31 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC31                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC31 6435 3A20                M 	dc.b	"d5: "
0000DC35 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC35 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC35 =00000016                M 	__midpos:	= __endpos
0000DC35                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC35                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC35 EC                       M 	dc.b	fpal2
0000DC36 =00000017                M 	__lpos:	set __endpos+1
0000DC36 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC36                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC36                          M 	dc.b	""
0000DC36 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC36 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC36 =0000001E                M 	__midpos:	= __endpos
0000DC36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC36                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC36                          M 	__param:	substr ,,"hex"
0000DC36 83                       M 	dc.b	hex|3
0000DC37 =0000001F                M 	__lpos:	set __endpos+1
0000DC37 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC37                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC37 2020                     M 	dc.b	"  "
0000DC39 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC39 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC39 =00000028                M 	__midpos:	= __endpos
0000DC39                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC39                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC39 E8                       M 	dc.b	fpal0
0000DC3A =00000029                M 	__lpos:	set __endpos+1
0000DC3A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC3A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3A 6135 3A20                M 	dc.b	"a5: "
0000DC3E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC3E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC3E =00000034                M 	__midpos:	= __endpos
0000DC3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3E EC                       M 	dc.b	fpal2
0000DC3F =00000035                M 	__lpos:	set __endpos+1
0000DC3F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC3F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3F                          M 	dc.b	""
0000DC3F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DC3F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DC3F =0000003C                M 	__midpos:	= __endpos
0000DC3F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC3F                          M 	__param:	substr ,,"hex"
0000DC3F 83                       M 	dc.b	hex|3
0000DC40 =0000003D                M 	__lpos:	set __endpos+1
0000DC40 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DC40                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DC40                          M 	dc.b	""
0000DC40 00                       M 	dc.b	0
0000DC42 00                       M 	even
0000DC42                          M 	.instr_end_415:
0000DC42                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC42 40E7                     M 	move.w	sr,-(sp)
0000DC44                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =00000000                M 	__stack:set	0
0000DC44 =00000000                M 	__sp:	set 0
0000DC44                          M 	while	(__pos)
0000DC44 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =0000000A                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =00000016                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =0000001E                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	pushp	"move.l d6,-(sp)"
0000DC44 =00000001                M 	__stack:	= __stack+1
0000DC44 =00000004                M 	__sp:	= __sp+4
0000DC44 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =00000028                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =00000034                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC44 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC44 =0000003C                M 	__midpos:	= __endpos
0000DC44                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC44                          M 	pushp	"move.l a6,-(sp)"
0000DC44 =00000002                M 	__stack:	= __stack+1
0000DC44 =00000008                M 	__sp:	= __sp+4
0000DC44 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC44                          M 	rept	__stack
0000DC44                          M 	popp	__command
0000DC44 2F0E                     M 	move.l	a6,-(sp)
0000DC46                          M 	popp	__command
0000DC46 2F06                     M 	move.l	d6,-(sp)
0000DC48 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC4C 45EF 0010                M 	lea	4*4(sp),a2
0000DC50 43FA 0000                M 	lea	.str_418(pc),a1
0000DC54 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DC5A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC5E 504F                     M 	addq.w	#__sp,sp
0000DC60 46DF                     M 	move.w	(sp)+,sr
0000DC62 6000 0000                M 	bra.w	.instr_end_418
0000DC66                          M 	.str_418:
0000DC66                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC66 =00000001                M 	__lpos:	set 1
0000DC66 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC66                          M 	while	(__pos)
0000DC66                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC66 2020                     M 	dc.b	"  "
0000DC68 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC68 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC68 =0000000A                M 	__midpos:	= __endpos
0000DC68                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC68                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC68 E8                       M 	dc.b	fpal0
0000DC69 =0000000B                M 	__lpos:	set __endpos+1
0000DC69 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC69                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC69 6436 3A20                M 	dc.b	"d6: "
0000DC6D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC6D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC6D =00000016                M 	__midpos:	= __endpos
0000DC6D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6D EC                       M 	dc.b	fpal2
0000DC6E =00000017                M 	__lpos:	set __endpos+1
0000DC6E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC6E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6E                          M 	dc.b	""
0000DC6E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC6E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC6E =0000001E                M 	__midpos:	= __endpos
0000DC6E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6E                          M 	__param:	substr ,,"hex"
0000DC6E 83                       M 	dc.b	hex|3
0000DC6F =0000001F                M 	__lpos:	set __endpos+1
0000DC6F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC6F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC6F 2020                     M 	dc.b	"  "
0000DC71 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC71 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC71 =00000028                M 	__midpos:	= __endpos
0000DC71                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC71                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC71 E8                       M 	dc.b	fpal0
0000DC72 =00000029                M 	__lpos:	set __endpos+1
0000DC72 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC72                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC72 6136 3A20                M 	dc.b	"a6: "
0000DC76 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC76 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC76 =00000034                M 	__midpos:	= __endpos
0000DC76                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC76                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC76 EC                       M 	dc.b	fpal2
0000DC77 =00000035                M 	__lpos:	set __endpos+1
0000DC77 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC77                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC77                          M 	dc.b	""
0000DC77 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DC77 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DC77 =0000003C                M 	__midpos:	= __endpos
0000DC77                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC77                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC77                          M 	__param:	substr ,,"hex"
0000DC77 83                       M 	dc.b	hex|3
0000DC78 =0000003D                M 	__lpos:	set __endpos+1
0000DC78 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DC78                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DC78                          M 	dc.b	""
0000DC78 00                       M 	dc.b	0
0000DC7A 00                       M 	even
0000DC7A                          M 	.instr_end_418:
0000DC7A                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7A 40E7                     M 	move.w	sr,-(sp)
0000DC7C                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =00000000                M 	__stack:set	0
0000DC7C =00000000                M 	__sp:	set 0
0000DC7C                          M 	while	(__pos)
0000DC7C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =0000000A                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =00000016                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =0000001E                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	pushp	"move.l d7,-(sp)"
0000DC7C =00000001                M 	__stack:	= __stack+1
0000DC7C =00000004                M 	__sp:	= __sp+4
0000DC7C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =00000028                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =00000034                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC7C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC7C =0000003C                M 	__midpos:	= __endpos
0000DC7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC7C                          M 	pushp	"move.l a7,-(sp)"
0000DC7C =00000002                M 	__stack:	= __stack+1
0000DC7C =00000008                M 	__sp:	= __sp+4
0000DC7C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC7C                          M 	rept	__stack
0000DC7C                          M 	popp	__command
0000DC7C 2F0F                     M 	move.l	a7,-(sp)
0000DC7E                          M 	popp	__command
0000DC7E 2F07                     M 	move.l	d7,-(sp)
0000DC80 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC84 45EF 0010                M 	lea	4*4(sp),a2
0000DC88 43FA 0000                M 	lea	.str_421(pc),a1
0000DC8C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DC92 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC96 504F                     M 	addq.w	#__sp,sp
0000DC98 46DF                     M 	move.w	(sp)+,sr
0000DC9A 6000 0000                M 	bra.w	.instr_end_421
0000DC9E                          M 	.str_421:
0000DC9E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC9E =00000001                M 	__lpos:	set 1
0000DC9E =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC9E                          M 	while	(__pos)
0000DC9E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC9E 2020                     M 	dc.b	"  "
0000DCA0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCA0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCA0 =0000000A                M 	__midpos:	= __endpos
0000DCA0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA0 E8                       M 	dc.b	fpal0
0000DCA1 =0000000B                M 	__lpos:	set __endpos+1
0000DCA1 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCA1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA1 6437 3A20                M 	dc.b	"d7: "
0000DCA5 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCA5 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCA5 =00000016                M 	__midpos:	= __endpos
0000DCA5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA5 EC                       M 	dc.b	fpal2
0000DCA6 =00000017                M 	__lpos:	set __endpos+1
0000DCA6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCA6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA6                          M 	dc.b	""
0000DCA6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCA6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCA6 =0000001E                M 	__midpos:	= __endpos
0000DCA6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA6                          M 	__param:	substr ,,"hex"
0000DCA6 83                       M 	dc.b	hex|3
0000DCA7 =0000001F                M 	__lpos:	set __endpos+1
0000DCA7 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCA7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA7 2020                     M 	dc.b	"  "
0000DCA9 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCA9 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCA9 =00000028                M 	__midpos:	= __endpos
0000DCA9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCA9 E8                       M 	dc.b	fpal0
0000DCAA =00000029                M 	__lpos:	set __endpos+1
0000DCAA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCAA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAA 7370 3A20                M 	dc.b	"sp: "
0000DCAE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCAE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCAE =00000034                M 	__midpos:	= __endpos
0000DCAE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAE EC                       M 	dc.b	fpal2
0000DCAF =00000035                M 	__lpos:	set __endpos+1
0000DCAF =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCAF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAF                          M 	dc.b	""
0000DCAF =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DCAF =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DCAF =0000003C                M 	__midpos:	= __endpos
0000DCAF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAF                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCAF                          M 	__param:	substr ,,"hex"
0000DCAF 83                       M 	dc.b	hex|3
0000DCB0 =0000003D                M 	__lpos:	set __endpos+1
0000DCB0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DCB0                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DCB0                          M 	dc.b	""
0000DCB0 00                       M 	dc.b	0
0000DCB2 00                       M 	even
0000DCB2                          M 	.instr_end_421:
0000DCB2                            	Console.BreakLine
0000DCB2 40E7                     M 	move.w	sr,-(sp)
0000DCB4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000DCBA 46DF                     M 	move.w	(sp)+,sr
0000DCBC                            
0000DCBC                            	Console.Write	  "%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBC 40E7                     M 	move.w	sr,-(sp)
0000DCBE                          M 	__fstring_generateargumentscode	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCBE =00000000                M 	__stack:set	0
0000DCBE =00000000                M 	__sp:	set 0
0000DCBE                          M 	while	(__pos)
0000DCBE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCBE =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCBE =00000008                M 	__midpos:	= __endpos
0000DCBE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCBE =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCBE =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCBE =00000018                M 	__midpos:	= __endpos
0000DCBE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCBE =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCBE =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCBE =00000026                M 	__midpos:	= __endpos
0000DCBE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	pushp	"move.b mFlags.w,1(sp)"
0000DCBE                          M 	pushp	"subq.w	#2, sp"
0000DCBE =00000002                M 	__stack:	= __stack+2
0000DCBE =00000002                M 	__sp:	= __sp+2
0000DCBE =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCBE =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCBE =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCBE =00000036                M 	__midpos:	= __endpos
0000DCBE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCBE                          M 	pushp	"move.b mCtrPal.w,1(sp)"
0000DCBE                          M 	pushp	"subq.w	#2, sp"
0000DCBE =00000004                M 	__stack:	= __stack+2
0000DCBE =00000004                M 	__sp:	= __sp+2
0000DCBE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCBE                          M 	rept	__stack
0000DCBE                          M 	popp	__command
0000DCBE 554F                     M 	subq.w	#2,sp
0000DCC0                          M 	popp	__command
0000DCC0 1F78 C4A7 0001           M 	move.b	mctrpal.w,1(sp)
0000DCC6                          M 	popp	__command
0000DCC6 554F                     M 	subq.w	#2,sp
0000DCC8                          M 	popp	__command
0000DCC8 1F78 C4A6 0001           M 	move.b	mflags.w,1(sp)
0000DCCE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DCD2 45EF 0010                M 	lea	4*4(sp),a2
0000DCD6 43FA 0000                M 	lea	.str_425(pc),a1
0000DCDA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DCE0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DCE4 584F                     M 	addq.w	#__sp,sp
0000DCE6 46DF                     M 	move.w	(sp)+,sr
0000DCE8 6000 0000                M 	bra.w	.instr_end_425
0000DCEC                          M 	.str_425:
0000DCEC                          M 	__fstring_generatedecodedstring	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCEC =00000001                M 	__lpos:	set 1
0000DCEC =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCEC                          M 	while	(__pos)
0000DCEC                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCEC                          M 	dc.b	""
0000DCEC =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCEC =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCEC =00000008                M 	__midpos:	= __endpos
0000DCEC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCEC                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCEC EA                       M 	dc.b	fpal1
0000DCED =00000009                M 	__lpos:	set __endpos+1
0000DCED =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCED                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCED 4D69 7363 3A20 2020      M 	dc.b	"Misc:   "
0000DCF5 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCF5 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCF5 =00000018                M 	__midpos:	= __endpos
0000DCF5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF5                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF5 EC                       M 	dc.b	fpal2
0000DCF6 =00000019                M 	__lpos:	set __endpos+1
0000DCF6 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCF6                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF6                          M 	dc.b	""
0000DCF6 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCF6 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCF6 =00000026                M 	__midpos:	= __endpos
0000DCF6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF6                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF6                          M 	__param:	substr ,,"hex"
0000DCF6 80                       M 	dc.b	hex
0000DCF7 =00000027                M 	__lpos:	set __endpos+1
0000DCF7 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCF7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF7 20                       M 	dc.b	" "
0000DCF8 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DCF8 =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DCF8 =00000036                M 	__midpos:	= __endpos
0000DCF8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF8                          M 	__param:	substr ,,"hex"
0000DCF8 80                       M 	dc.b	hex
0000DCF9 =00000037                M 	__lpos:	set __endpos+1
0000DCF9 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DCF9                          M 	__substr:	substr __lpos,,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DCF9 20                       M 	dc.b	" "
0000DCFA 00                       M 	dc.b	0
0000DCFC 00                       M 	even
0000DCFC                          M 	.instr_end_425:
0000DCFC                            	Console.WriteLine "%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFC 40E7                     M 	move.w	sr,-(sp)
0000DCFE                          M 	__fstring_generateargumentscode	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCFE =00000000                M 	__stack:set	0
0000DCFE =00000000                M 	__sp:	set 0
0000DCFE                          M 	while	(__pos)
0000DCFE =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCFE =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCFE =00000011                M 	__midpos:	= __endpos
0000DCFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	pushp	"move.b mSpindash.w,1(sp)"
0000DCFE                          M 	pushp	"subq.w	#2, sp"
0000DCFE =00000002                M 	__stack:	= __stack+2
0000DCFE =00000002                M 	__sp:	= __sp+2
0000DCFE =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCFE =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCFE =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCFE =00000022                M 	__midpos:	= __endpos
0000DCFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	pushp	"move.b mContCtr.w,1(sp)"
0000DCFE                          M 	pushp	"subq.w	#2, sp"
0000DCFE =00000004                M 	__stack:	= __stack+2
0000DCFE =00000004                M 	__sp:	= __sp+2
0000DCFE =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCFE =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCFE =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCFE =00000034                M 	__midpos:	= __endpos
0000DCFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCFE                          M 	pushp	"move.b mContLast.w,1(sp)"
0000DCFE                          M 	pushp	"subq.w	#2, sp"
0000DCFE =00000006                M 	__stack:	= __stack+2
0000DCFE =00000006                M 	__sp:	= __sp+2
0000DCFE =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCFE                          M 	rept	__stack
0000DCFE                          M 	popp	__command
0000DCFE 554F                     M 	subq.w	#2,sp
0000DD00                          M 	popp	__command
0000DD00 1F78 C4C3 0001           M 	move.b	mcontlast.w,1(sp)
0000DD06                          M 	popp	__command
0000DD06 554F                     M 	subq.w	#2,sp
0000DD08                          M 	popp	__command
0000DD08 1F78 C4C2 0001           M 	move.b	mcontctr.w,1(sp)
0000DD0E                          M 	popp	__command
0000DD0E 554F                     M 	subq.w	#2,sp
0000DD10                          M 	popp	__command
0000DD10 1F78 C4C1 0001           M 	move.b	mspindash.w,1(sp)
0000DD16 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD1A 45EF 0010                M 	lea	4*4(sp),a2
0000DD1E 43FA 0000                M 	lea	.str_428(pc),a1
0000DD22 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD28 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD2C 5C4F                     M 	addq.w	#__sp,sp
0000DD2E 46DF                     M 	move.w	(sp)+,sr
0000DD30 6000 0000                M 	bra.w	.instr_end_428
0000DD34                          M 	.str_428:
0000DD34                          M 	__fstring_generatedecodedstring	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD34 =00000001                M 	__lpos:	set 1
0000DD34 =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DD34                          M 	while	(__pos)
0000DD34                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD34                          M 	dc.b	""
0000DD34 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DD34 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DD34 =00000011                M 	__midpos:	= __endpos
0000DD34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD34                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD34                          M 	__param:	substr ,,"hex"
0000DD34 80                       M 	dc.b	hex
0000DD35 =00000012                M 	__lpos:	set __endpos+1
0000DD35 =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DD35                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD35 20                       M 	dc.b	" "
0000DD36 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DD36 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DD36 =00000022                M 	__midpos:	= __endpos
0000DD36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD36                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD36                          M 	__param:	substr ,,"hex"
0000DD36 80                       M 	dc.b	hex
0000DD37 =00000023                M 	__lpos:	set __endpos+1
0000DD37 =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DD37                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD37 20                       M 	dc.b	" "
0000DD38 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DD38 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DD38 =00000034                M 	__midpos:	= __endpos
0000DD38                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD38                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD38                          M 	__param:	substr ,,"hex"
0000DD38 80                       M 	dc.b	hex
0000DD39 =00000035                M 	__lpos:	set __endpos+1
0000DD39 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DD39                          M 	__substr:	substr __lpos,,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DD39                          M 	dc.b	""
0000DD39 00                       M 	dc.b	0
0000DD3A                          M 	even
0000DD3A                          M 	.instr_end_428:
0000DD3A                            	Console.Write	  "%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3A 40E7                     M 	move.w	sr,-(sp)
0000DD3C                          M 	__fstring_generateargumentscode	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD3C =00000000                M 	__stack:set	0
0000DD3C =00000000                M 	__sp:	set 0
0000DD3C                          M 	while	(__pos)
0000DD3C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD3C =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD3C =00000008                M 	__midpos:	= __endpos
0000DD3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD3C =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD3C =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD3C =00000018                M 	__midpos:	= __endpos
0000DD3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD3C =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD3C =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD3C =0000002A                M 	__midpos:	= __endpos
0000DD3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	pushp	"move.b mTempoMain.w,1(sp)"
0000DD3C                          M 	pushp	"subq.w	#2, sp"
0000DD3C =00000002                M 	__stack:	= __stack+2
0000DD3C =00000002                M 	__sp:	= __sp+2
0000DD3C =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD3C =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD3C =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD3C =0000003E                M 	__midpos:	= __endpos
0000DD3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD3C                          M 	pushp	"move.b mTempoSpeed.w,1(sp)"
0000DD3C                          M 	pushp	"subq.w	#2, sp"
0000DD3C =00000004                M 	__stack:	= __stack+2
0000DD3C =00000004                M 	__sp:	= __sp+2
0000DD3C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD3C                          M 	rept	__stack
0000DD3C                          M 	popp	__command
0000DD3C 554F                     M 	subq.w	#2,sp
0000DD3E                          M 	popp	__command
0000DD3E 1F78 C4B9 0001           M 	move.b	mtempospeed.w,1(sp)
0000DD44                          M 	popp	__command
0000DD44 554F                     M 	subq.w	#2,sp
0000DD46                          M 	popp	__command
0000DD46 1F78 C4B8 0001           M 	move.b	mtempomain.w,1(sp)
0000DD4C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD50 45EF 0010                M 	lea	4*4(sp),a2
0000DD54 43FA 0000                M 	lea	.str_431(pc),a1
0000DD58 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DD5E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD62 584F                     M 	addq.w	#__sp,sp
0000DD64 46DF                     M 	move.w	(sp)+,sr
0000DD66 6000 0000                M 	bra.w	.instr_end_431
0000DD6A                          M 	.str_431:
0000DD6A                          M 	__fstring_generatedecodedstring	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD6A =00000001                M 	__lpos:	set 1
0000DD6A =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD6A                          M 	while	(__pos)
0000DD6A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD6A                          M 	dc.b	""
0000DD6A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD6A =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD6A =00000008                M 	__midpos:	= __endpos
0000DD6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD6A EA                       M 	dc.b	fpal1
0000DD6B =00000009                M 	__lpos:	set __endpos+1
0000DD6B =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD6B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD6B 5465 6D70 6F3A 2020      M 	dc.b	"Tempo:  "
0000DD73 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD73 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD73 =00000018                M 	__midpos:	= __endpos
0000DD73                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD73                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD73 EC                       M 	dc.b	fpal2
0000DD74 =00000019                M 	__lpos:	set __endpos+1
0000DD74 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD74                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD74                          M 	dc.b	""
0000DD74 =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD74 =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD74 =0000002A                M 	__midpos:	= __endpos
0000DD74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD74                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD74                          M 	__param:	substr ,,"hex"
0000DD74 80                       M 	dc.b	hex
0000DD75 =0000002B                M 	__lpos:	set __endpos+1
0000DD75 =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD75                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD75 20                       M 	dc.b	" "
0000DD76 =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DD76 =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DD76 =0000003E                M 	__midpos:	= __endpos
0000DD76                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD76                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD76                          M 	__param:	substr ,,"hex"
0000DD76 80                       M 	dc.b	hex
0000DD77 =0000003F                M 	__lpos:	set __endpos+1
0000DD77 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DD77                          M 	__substr:	substr __lpos,,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DD77 20                       M 	dc.b	" "
0000DD78 00                       M 	dc.b	0
0000DD7A 00                       M 	even
0000DD7A                          M 	.instr_end_431:
0000DD7A                            	Console.WriteLine "%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7A 40E7                     M 	move.w	sr,-(sp)
0000DD7C                          M 	__fstring_generateargumentscode	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD7C =00000000                M 	__stack:set	0
0000DD7C =00000000                M 	__sp:	set 0
0000DD7C                          M 	while	(__pos)
0000DD7C =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DD7C =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DD7C =0000000E                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	pushp	"move.b mTempo.w,1(sp)"
0000DD7C                          M 	pushp	"subq.w	#2, sp"
0000DD7C =00000002                M 	__stack:	= __stack+2
0000DD7C =00000002                M 	__sp:	= __sp+2
0000DD7C =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD7C =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DD7C =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DD7C =00000020                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD7C                          M 	pushp	"move.b mTempoCur.w,1(sp)"
0000DD7C                          M 	pushp	"subq.w	#2, sp"
0000DD7C =00000004                M 	__stack:	= __stack+2
0000DD7C =00000004                M 	__sp:	= __sp+2
0000DD7C =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD7C                          M 	rept	__stack
0000DD7C                          M 	popp	__command
0000DD7C 554F                     M 	subq.w	#2,sp
0000DD7E                          M 	popp	__command
0000DD7E 1F78 C4BB 0001           M 	move.b	mtempocur.w,1(sp)
0000DD84                          M 	popp	__command
0000DD84 554F                     M 	subq.w	#2,sp
0000DD86                          M 	popp	__command
0000DD86 1F78 C4BA 0001           M 	move.b	mtempo.w,1(sp)
0000DD8C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD90 45EF 0010                M 	lea	4*4(sp),a2
0000DD94 43FA 0000                M 	lea	.str_434(pc),a1
0000DD98 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD9E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDA2 584F                     M 	addq.w	#__sp,sp
0000DDA4 46DF                     M 	move.w	(sp)+,sr
0000DDA6 6000 0000                M 	bra.w	.instr_end_434
0000DDAA                          M 	.str_434:
0000DDAA                          M 	__fstring_generatedecodedstring	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAA =00000001                M 	__lpos:	set 1
0000DDAA =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DDAA                          M 	while	(__pos)
0000DDAA                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAA                          M 	dc.b	""
0000DDAA =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DDAA =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DDAA =0000000E                M 	__midpos:	= __endpos
0000DDAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAA                          M 	__param:	substr ,,"hex"
0000DDAA 80                       M 	dc.b	hex
0000DDAB =0000000F                M 	__lpos:	set __endpos+1
0000DDAB =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DDAB                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAB 20                       M 	dc.b	" "
0000DDAC =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DDAC =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DDAC =00000020                M 	__midpos:	= __endpos
0000DDAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAC                          M 	__param:	substr ,,"hex"
0000DDAC 80                       M 	dc.b	hex
0000DDAD =00000021                M 	__lpos:	set __endpos+1
0000DDAD =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DDAD                          M 	__substr:	substr __lpos,,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DDAD                          M 	dc.b	""
0000DDAD 00                       M 	dc.b	0
0000DDAE                          M 	even
0000DDAE                          M 	.instr_end_434:
0000DDAE                            	Console.Write	  "%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDAE 40E7                     M 	move.w	sr,-(sp)
0000DDB0                          M 	__fstring_generateargumentscode	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0 =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDB0 =00000000                M 	__stack:set	0
0000DDB0 =00000000                M 	__sp:	set 0
0000DDB0                          M 	while	(__pos)
0000DDB0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDB0 =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDB0 =00000008                M 	__midpos:	= __endpos
0000DDB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDB0 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDB0 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDB0 =00000018                M 	__midpos:	= __endpos
0000DDB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDB0 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDB0 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDB0 =0000002C                M 	__midpos:	= __endpos
0000DDB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	pushp	"move.b mMasterVolFM.w,1(sp)"
0000DDB0                          M 	pushp	"subq.w	#2, sp"
0000DDB0 =00000002                M 	__stack:	= __stack+2
0000DDB0 =00000002                M 	__sp:	= __sp+2
0000DDB0 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDB0 =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDB0 =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDB0 =00000042                M 	__midpos:	= __endpos
0000DDB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDB0                          M 	pushp	"move.b mMasterVolDAC.w,1(sp)"
0000DDB0                          M 	pushp	"subq.w	#2, sp"
0000DDB0 =00000004                M 	__stack:	= __stack+2
0000DDB0 =00000004                M 	__sp:	= __sp+2
0000DDB0 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDB0                          M 	rept	__stack
0000DDB0                          M 	popp	__command
0000DDB0 554F                     M 	subq.w	#2,sp
0000DDB2                          M 	popp	__command
0000DDB2 1F78 C4C0 0001           M 	move.b	mmastervoldac.w,1(sp)
0000DDB8                          M 	popp	__command
0000DDB8 554F                     M 	subq.w	#2,sp
0000DDBA                          M 	popp	__command
0000DDBA 1F78 C4B4 0001           M 	move.b	mmastervolfm.w,1(sp)
0000DDC0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DDC4 45EF 0010                M 	lea	4*4(sp),a2
0000DDC8 43FA 0000                M 	lea	.str_437(pc),a1
0000DDCC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DDD2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDD6 584F                     M 	addq.w	#__sp,sp
0000DDD8 46DF                     M 	move.w	(sp)+,sr
0000DDDA 6000 0000                M 	bra.w	.instr_end_437
0000DDDE                          M 	.str_437:
0000DDDE                          M 	__fstring_generatedecodedstring	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDDE =00000001                M 	__lpos:	set 1
0000DDDE =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDDE                          M 	while	(__pos)
0000DDDE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDDE                          M 	dc.b	""
0000DDDE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDDE =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDDE =00000008                M 	__midpos:	= __endpos
0000DDDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDDE EA                       M 	dc.b	fpal1
0000DDDF =00000009                M 	__lpos:	set __endpos+1
0000DDDF =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDDF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDDF 566F 6C75 6D65 3A20      M 	dc.b	"Volume: "
0000DDE7 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDE7 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDE7 =00000018                M 	__midpos:	= __endpos
0000DDE7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE7                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE7 EC                       M 	dc.b	fpal2
0000DDE8 =00000019                M 	__lpos:	set __endpos+1
0000DDE8 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDE8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE8                          M 	dc.b	""
0000DDE8 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDE8 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDE8 =0000002C                M 	__midpos:	= __endpos
0000DDE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE8                          M 	__param:	substr ,,"hex"
0000DDE8 80                       M 	dc.b	hex
0000DDE9 =0000002D                M 	__lpos:	set __endpos+1
0000DDE9 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDE9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDE9 20                       M 	dc.b	" "
0000DDEA =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DDEA =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DDEA =00000042                M 	__midpos:	= __endpos
0000DDEA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDEA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDEA                          M 	__param:	substr ,,"hex"
0000DDEA 80                       M 	dc.b	hex
0000DDEB =00000043                M 	__lpos:	set __endpos+1
0000DDEB =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DDEB                          M 	__substr:	substr __lpos,,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DDEB 20                       M 	dc.b	" "
0000DDEC 00                       M 	dc.b	0
0000DDEE 00                       M 	even
0000DDEE                          M 	.instr_end_437:
0000DDEE                            	Console.WriteLine "%<.b mMasterVolPSG.w>"
0000DDEE 40E7                     M 	move.w	sr,-(sp)
0000DDF0                          M 	__fstring_generateargumentscode	"%<.b mMasterVolPSG.w>"
0000DDF0 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DDF0 =00000000                M 	__stack:set	0
0000DDF0 =00000000                M 	__sp:	set 0
0000DDF0                          M 	while	(__pos)
0000DDF0 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DDF0 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DDF0 =00000015                M 	__midpos:	= __endpos
0000DDF0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DDF0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DDF0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mMasterVolPSG.w>"
0000DDF0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DDF0                          M 	pushp	"move.b mMasterVolPSG.w,1(sp)"
0000DDF0                          M 	pushp	"subq.w	#2, sp"
0000DDF0 =00000002                M 	__stack:	= __stack+2
0000DDF0 =00000002                M 	__sp:	= __sp+2
0000DDF0 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DDF0                          M 	rept	__stack
0000DDF0                          M 	popp	__command
0000DDF0 554F                     M 	subq.w	#2,sp
0000DDF2                          M 	popp	__command
0000DDF2 1F78 C4BF 0001           M 	move.b	mmastervolpsg.w,1(sp)
0000DDF8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DDFC 45EF 0010                M 	lea	4*4(sp),a2
0000DE00 43FA 0000                M 	lea	.str_440(pc),a1
0000DE04 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE0A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE0E 544F                     M 	addq.w	#__sp,sp
0000DE10 46DF                     M 	move.w	(sp)+,sr
0000DE12 6000 0000                M 	bra.w	.instr_end_440
0000DE16                          M 	.str_440:
0000DE16                          M 	__fstring_generatedecodedstring	"%<.b mMasterVolPSG.w>"
0000DE16 =00000001                M 	__lpos:	set 1
0000DE16 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DE16                          M 	while	(__pos)
0000DE16                          M 	__substr:	substr __lpos,__pos-1,"%<.b mMasterVolPSG.w>"
0000DE16                          M 	dc.b	""
0000DE16 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DE16 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DE16 =00000015                M 	__midpos:	= __endpos
0000DE16                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DE16                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DE16                          M 	__param:	substr ,,"hex"
0000DE16 80                       M 	dc.b	hex
0000DE17 =00000016                M 	__lpos:	set __endpos+1
0000DE17 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DE17                          M 	__substr:	substr __lpos,,"%<.b mMasterVolPSG.w>"
0000DE17                          M 	dc.b	""
0000DE17 00                       M 	dc.b	0
0000DE18                          M 	even
0000DE18                          M 	.instr_end_440:
0000DE18                            	Console.WriteLine "%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE18 40E7                     M 	move.w	sr,-(sp)
0000DE1A                          M 	__fstring_generateargumentscode	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE1A =00000000                M 	__stack:set	0
0000DE1A =00000000                M 	__sp:	set 0
0000DE1A                          M 	while	(__pos)
0000DE1A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE1A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE1A =00000008                M 	__midpos:	= __endpos
0000DE1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE1A =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE1A =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE1A =00000018                M 	__midpos:	= __endpos
0000DE1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE1A =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE1A =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	pushp	"move.l mFadeAddr.w,-(sp)"
0000DE1A =00000001                M 	__stack:	= __stack+1
0000DE1A =00000004                M 	__sp:	= __sp+4
0000DE1A =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE1A =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE1A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE1A =00000045                M 	__midpos:	= __endpos
0000DE1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE1A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE1A                          M 	rept	__stack
0000DE1A                          M 	popp	__command
0000DE1A 2F38 C4B4                M 	move.l	mfadeaddr.w,-(sp)
0000DE1E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE22 45EF 0010                M 	lea	4*4(sp),a2
0000DE26 43FA 0000                M 	lea	.str_443(pc),a1
0000DE2A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE30 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE34 584F                     M 	addq.w	#__sp,sp
0000DE36 46DF                     M 	move.w	(sp)+,sr
0000DE38 6000 0000                M 	bra.w	.instr_end_443
0000DE3C                          M 	.str_443:
0000DE3C                          M 	__fstring_generatedecodedstring	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE3C =00000001                M 	__lpos:	set 1
0000DE3C =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3C                          M 	while	(__pos)
0000DE3C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE3C                          M 	dc.b	""
0000DE3C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE3C =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE3C =00000008                M 	__midpos:	= __endpos
0000DE3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE3C EA                       M 	dc.b	fpal1
0000DE3D =00000009                M 	__lpos:	set __endpos+1
0000DE3D =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE3D 4661 6465 3A20 2020      M 	dc.b	"Fade:   "
0000DE45 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE45 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE45 =00000018                M 	__midpos:	= __endpos
0000DE45                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE45                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE45 E8                       M 	dc.b	fpal0
0000DE46 =00000019                M 	__lpos:	set __endpos+1
0000DE46 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE46                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE46                          M 	dc.b	""
0000DE46 =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE46 =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE46                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE46                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE46 BB                       M 	dc.b	sym|fsplit|3
0000DE47 =00000035                M 	__lpos:	set __endpos+1
0000DE47 =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE47                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE47                          M 	dc.b	""
0000DE47 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE47 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE47 =00000045                M 	__midpos:	= __endpos
0000DE47                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE47                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE47 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DE49 =00000046                M 	__lpos:	set __endpos+1
0000DE49 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE49                          M 	__substr:	substr __lpos,,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DE49                          M 	dc.b	""
0000DE49 00                       M 	dc.b	0
0000DE4A                          M 	even
0000DE4A                          M 	.instr_end_443:
0000DE4A                            	Console.WriteLine "%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4A 40E7                     M 	move.w	sr,-(sp)
0000DE4C                          M 	__fstring_generateargumentscode	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C =00000000                M 	__stack:set	0
0000DE4C =00000000                M 	__sp:	set 0
0000DE4C                          M 	while	(__pos)
0000DE4C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE4C =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE4C =00000008                M 	__midpos:	= __endpos
0000DE4C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE4C =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE4C =00000018                M 	__midpos:	= __endpos
0000DE4C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE4C =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE4C =00000026                M 	__midpos:	= __endpos
0000DE4C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	pushp	"move.b mQueue.w,1(sp)"
0000DE4C                          M 	pushp	"subq.w	#2, sp"
0000DE4C =00000002                M 	__stack:	= __stack+2
0000DE4C =00000002                M 	__sp:	= __sp+2
0000DE4C =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE4C =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE4C =00000037                M 	__midpos:	= __endpos
0000DE4C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	pushp	"move.b mQueue+1.w,1(sp)"
0000DE4C                          M 	pushp	"subq.w	#2, sp"
0000DE4C =00000004                M 	__stack:	= __stack+2
0000DE4C =00000004                M 	__sp:	= __sp+2
0000DE4C =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE4C =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE4C =00000048                M 	__midpos:	= __endpos
0000DE4C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE4C                          M 	pushp	"move.b mQueue+2.w,1(sp)"
0000DE4C                          M 	pushp	"subq.w	#2, sp"
0000DE4C =00000006                M 	__stack:	= __stack+2
0000DE4C =00000006                M 	__sp:	= __sp+2
0000DE4C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE4C                          M 	rept	__stack
0000DE4C                          M 	popp	__command
0000DE4C 554F                     M 	subq.w	#2,sp
0000DE4E                          M 	popp	__command
0000DE4E 1F78 C4BE 0001           M 	move.b	mqueue+2.w,1(sp)
0000DE54                          M 	popp	__command
0000DE54 554F                     M 	subq.w	#2,sp
0000DE56                          M 	popp	__command
0000DE56 1F78 C4BD 0001           M 	move.b	mqueue+1.w,1(sp)
0000DE5C                          M 	popp	__command
0000DE5C 554F                     M 	subq.w	#2,sp
0000DE5E                          M 	popp	__command
0000DE5E 1F78 C4BC 0001           M 	move.b	mqueue.w,1(sp)
0000DE64 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE68 45EF 0010                M 	lea	4*4(sp),a2
0000DE6C 43FA 0000                M 	lea	.str_446(pc),a1
0000DE70 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE76 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE7A 5C4F                     M 	addq.w	#__sp,sp
0000DE7C 46DF                     M 	move.w	(sp)+,sr
0000DE7E 6000 0000                M 	bra.w	.instr_end_446
0000DE82                          M 	.str_446:
0000DE82                          M 	__fstring_generatedecodedstring	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE82 =00000001                M 	__lpos:	set 1
0000DE82 =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE82                          M 	while	(__pos)
0000DE82                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE82                          M 	dc.b	""
0000DE82 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE82 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE82 =00000008                M 	__midpos:	= __endpos
0000DE82                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE82                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE82 EA                       M 	dc.b	fpal1
0000DE83 =00000009                M 	__lpos:	set __endpos+1
0000DE83 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE83                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE83 5175 6575 653A 2020      M 	dc.b	"Queue:  "
0000DE8B =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE8B =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE8B =00000018                M 	__midpos:	= __endpos
0000DE8B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8B EC                       M 	dc.b	fpal2
0000DE8C =00000019                M 	__lpos:	set __endpos+1
0000DE8C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE8C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8C                          M 	dc.b	""
0000DE8C =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE8C =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE8C =00000026                M 	__midpos:	= __endpos
0000DE8C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8C                          M 	__param:	substr ,,"hex"
0000DE8C 80                       M 	dc.b	hex
0000DE8D =00000027                M 	__lpos:	set __endpos+1
0000DE8D =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE8D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8D 20                       M 	dc.b	" "
0000DE8E =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE8E =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE8E =00000037                M 	__midpos:	= __endpos
0000DE8E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8E                          M 	__param:	substr ,,"hex"
0000DE8E 80                       M 	dc.b	hex
0000DE8F =00000038                M 	__lpos:	set __endpos+1
0000DE8F =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE8F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE8F 20                       M 	dc.b	" "
0000DE90 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DE90 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DE90 =00000048                M 	__midpos:	= __endpos
0000DE90                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE90                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE90                          M 	__param:	substr ,,"hex"
0000DE90 80                       M 	dc.b	hex
0000DE91 =00000049                M 	__lpos:	set __endpos+1
0000DE91 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DE91                          M 	__substr:	substr __lpos,,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DE91                          M 	dc.b	""
0000DE91 00                       M 	dc.b	0
0000DE92                          M 	even
0000DE92                          M 	.instr_end_446:
0000DE92                            	Console.Write	  "%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE92 40E7                     M 	move.w	sr,-(sp)
0000DE94                          M 	__fstring_generateargumentscode	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94 =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94 =00000000                M 	__stack:set	0
0000DE94 =00000000                M 	__sp:	set 0
0000DE94                          M 	while	(__pos)
0000DE94 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE94 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE94 =00000008                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE94 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE94 =00000018                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE94 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE94 =00000025                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	pushp	"move.b mComm.w,1(sp)"
0000DE94                          M 	pushp	"subq.w	#2, sp"
0000DE94 =00000002                M 	__stack:	= __stack+2
0000DE94 =00000002                M 	__sp:	= __sp+2
0000DE94 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE94 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE94 =00000035                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	pushp	"move.b mComm+1.w,1(sp)"
0000DE94                          M 	pushp	"subq.w	#2, sp"
0000DE94 =00000004                M 	__stack:	= __stack+2
0000DE94 =00000004                M 	__sp:	= __sp+2
0000DE94 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE94 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE94 =00000045                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE94                          M 	pushp	"move.b mComm+2.w,1(sp)"
0000DE94                          M 	pushp	"subq.w	#2, sp"
0000DE94 =00000006                M 	__stack:	= __stack+2
0000DE94 =00000006                M 	__sp:	= __sp+2
0000DE94 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE94                          M 	rept	__stack
0000DE94                          M 	popp	__command
0000DE94 554F                     M 	subq.w	#2,sp
0000DE96                          M 	popp	__command
0000DE96 1F78 C4AE 0001           M 	move.b	mcomm+2.w,1(sp)
0000DE9C                          M 	popp	__command
0000DE9C 554F                     M 	subq.w	#2,sp
0000DE9E                          M 	popp	__command
0000DE9E 1F78 C4AD 0001           M 	move.b	mcomm+1.w,1(sp)
0000DEA4                          M 	popp	__command
0000DEA4 554F                     M 	subq.w	#2,sp
0000DEA6                          M 	popp	__command
0000DEA6 1F78 C4AC 0001           M 	move.b	mcomm.w,1(sp)
0000DEAC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DEB0 45EF 0010                M 	lea	4*4(sp),a2
0000DEB4 43FA 0000                M 	lea	.str_449(pc),a1
0000DEB8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DEBE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DEC2 5C4F                     M 	addq.w	#__sp,sp
0000DEC4 46DF                     M 	move.w	(sp)+,sr
0000DEC6 6000 0000                M 	bra.w	.instr_end_449
0000DECA                          M 	.str_449:
0000DECA                          M 	__fstring_generatedecodedstring	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DECA =00000001                M 	__lpos:	set 1
0000DECA =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DECA                          M 	while	(__pos)
0000DECA                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DECA                          M 	dc.b	""
0000DECA =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DECA =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DECA =00000008                M 	__midpos:	= __endpos
0000DECA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DECA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DECA EA                       M 	dc.b	fpal1
0000DECB =00000009                M 	__lpos:	set __endpos+1
0000DECB =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DECB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DECB 436F 6D6D 3A20 2020      M 	dc.b	"Comm:   "
0000DED3 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DED3 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DED3 =00000018                M 	__midpos:	= __endpos
0000DED3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED3                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED3 EC                       M 	dc.b	fpal2
0000DED4 =00000019                M 	__lpos:	set __endpos+1
0000DED4 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DED4                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED4                          M 	dc.b	""
0000DED4 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DED4 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DED4 =00000025                M 	__midpos:	= __endpos
0000DED4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED4                          M 	__param:	substr ,,"hex"
0000DED4 80                       M 	dc.b	hex
0000DED5 =00000026                M 	__lpos:	set __endpos+1
0000DED5 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DED5                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED5 20                       M 	dc.b	" "
0000DED6 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DED6 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DED6 =00000035                M 	__midpos:	= __endpos
0000DED6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED6                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED6                          M 	__param:	substr ,,"hex"
0000DED6 80                       M 	dc.b	hex
0000DED7 =00000036                M 	__lpos:	set __endpos+1
0000DED7 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DED7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED7 20                       M 	dc.b	" "
0000DED8 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DED8 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DED8 =00000045                M 	__midpos:	= __endpos
0000DED8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED8                          M 	__param:	substr ,,"hex"
0000DED8 80                       M 	dc.b	hex
0000DED9 =00000046                M 	__lpos:	set __endpos+1
0000DED9 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DED9                          M 	__substr:	substr __lpos,,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DED9 20                       M 	dc.b	" "
0000DEDA 00                       M 	dc.b	0
0000DEDC 00                       M 	even
0000DEDC                          M 	.instr_end_449:
0000DEDC                            	Console.Write	  "%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDC 40E7                     M 	move.w	sr,-(sp)
0000DEDE                          M 	__fstring_generateargumentscode	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DEDE =00000000                M 	__stack:set	0
0000DEDE =00000000                M 	__sp:	set 0
0000DEDE                          M 	while	(__pos)
0000DEDE =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DEDE =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DEDE =0000000F                M 	__midpos:	= __endpos
0000DEDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	pushp	"move.b mComm+3.w,1(sp)"
0000DEDE                          M 	pushp	"subq.w	#2, sp"
0000DEDE =00000002                M 	__stack:	= __stack+2
0000DEDE =00000002                M 	__sp:	= __sp+2
0000DEDE =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DEDE =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DEDE =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DEDE =0000001F                M 	__midpos:	= __endpos
0000DEDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	pushp	"move.b mComm+4.w,1(sp)"
0000DEDE                          M 	pushp	"subq.w	#2, sp"
0000DEDE =00000004                M 	__stack:	= __stack+2
0000DEDE =00000004                M 	__sp:	= __sp+2
0000DEDE =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DEDE =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DEDE =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DEDE =0000002F                M 	__midpos:	= __endpos
0000DEDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	pushp	"move.b mComm+5.w,1(sp)"
0000DEDE                          M 	pushp	"subq.w	#2, sp"
0000DEDE =00000006                M 	__stack:	= __stack+2
0000DEDE =00000006                M 	__sp:	= __sp+2
0000DEDE =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DEDE =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DEDE =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DEDE =0000003F                M 	__midpos:	= __endpos
0000DEDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DEDE                          M 	pushp	"move.b mComm+6.w,1(sp)"
0000DEDE                          M 	pushp	"subq.w	#2, sp"
0000DEDE =00000008                M 	__stack:	= __stack+2
0000DEDE =00000008                M 	__sp:	= __sp+2
0000DEDE =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DEDE                          M 	rept	__stack
0000DEDE                          M 	popp	__command
0000DEDE 554F                     M 	subq.w	#2,sp
0000DEE0                          M 	popp	__command
0000DEE0 1F78 C4B2 0001           M 	move.b	mcomm+6.w,1(sp)
0000DEE6                          M 	popp	__command
0000DEE6 554F                     M 	subq.w	#2,sp
0000DEE8                          M 	popp	__command
0000DEE8 1F78 C4B1 0001           M 	move.b	mcomm+5.w,1(sp)
0000DEEE                          M 	popp	__command
0000DEEE 554F                     M 	subq.w	#2,sp
0000DEF0                          M 	popp	__command
0000DEF0 1F78 C4B0 0001           M 	move.b	mcomm+4.w,1(sp)
0000DEF6                          M 	popp	__command
0000DEF6 554F                     M 	subq.w	#2,sp
0000DEF8                          M 	popp	__command
0000DEF8 1F78 C4AF 0001           M 	move.b	mcomm+3.w,1(sp)
0000DEFE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DF02 45EF 0010                M 	lea	4*4(sp),a2
0000DF06 43FA 0000                M 	lea	.str_452(pc),a1
0000DF0A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DF10 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DF14 504F                     M 	addq.w	#__sp,sp
0000DF16 46DF                     M 	move.w	(sp)+,sr
0000DF18 6000 0000                M 	bra.w	.instr_end_452
0000DF1C                          M 	.str_452:
0000DF1C                          M 	__fstring_generatedecodedstring	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1C =00000001                M 	__lpos:	set 1
0000DF1C =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DF1C                          M 	while	(__pos)
0000DF1C                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1C                          M 	dc.b	""
0000DF1C =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DF1C =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DF1C =0000000F                M 	__midpos:	= __endpos
0000DF1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1C                          M 	__param:	substr ,,"hex"
0000DF1C 80                       M 	dc.b	hex
0000DF1D =00000010                M 	__lpos:	set __endpos+1
0000DF1D =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DF1D                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1D 20                       M 	dc.b	" "
0000DF1E =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DF1E =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DF1E =0000001F                M 	__midpos:	= __endpos
0000DF1E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1E                          M 	__param:	substr ,,"hex"
0000DF1E 80                       M 	dc.b	hex
0000DF1F =00000020                M 	__lpos:	set __endpos+1
0000DF1F =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DF1F                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF1F 20                       M 	dc.b	" "
0000DF20 =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DF20 =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DF20 =0000002F                M 	__midpos:	= __endpos
0000DF20                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF20                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF20                          M 	__param:	substr ,,"hex"
0000DF20 80                       M 	dc.b	hex
0000DF21 =00000030                M 	__lpos:	set __endpos+1
0000DF21 =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DF21                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF21 20                       M 	dc.b	" "
0000DF22 =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DF22 =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DF22 =0000003F                M 	__midpos:	= __endpos
0000DF22                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF22                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF22                          M 	__param:	substr ,,"hex"
0000DF22 80                       M 	dc.b	hex
0000DF23 =00000040                M 	__lpos:	set __endpos+1
0000DF23 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DF23                          M 	__substr:	substr __lpos,,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DF23 20                       M 	dc.b	" "
0000DF24 00                       M 	dc.b	0
0000DF26 00                       M 	even
0000DF26                          M 	.instr_end_452:
0000DF26                            	Console.WriteLine "%<.b mComm+7.w>"
0000DF26 40E7                     M 	move.w	sr,-(sp)
0000DF28                          M 	__fstring_generateargumentscode	"%<.b mComm+7.w>"
0000DF28 =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DF28 =00000000                M 	__stack:set	0
0000DF28 =00000000                M 	__sp:	set 0
0000DF28                          M 	while	(__pos)
0000DF28 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DF28 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DF28 =0000000F                M 	__midpos:	= __endpos
0000DF28                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+7.w>"
0000DF28                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DF28                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+7.w>"
0000DF28                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DF28                          M 	pushp	"move.b mComm+7.w,1(sp)"
0000DF28                          M 	pushp	"subq.w	#2, sp"
0000DF28 =00000002                M 	__stack:	= __stack+2
0000DF28 =00000002                M 	__sp:	= __sp+2
0000DF28 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DF28                          M 	rept	__stack
0000DF28                          M 	popp	__command
0000DF28 554F                     M 	subq.w	#2,sp
0000DF2A                          M 	popp	__command
0000DF2A 1F78 C4B3 0001           M 	move.b	mcomm+7.w,1(sp)
0000DF30 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DF34 45EF 0010                M 	lea	4*4(sp),a2
0000DF38 43FA 0000                M 	lea	.str_455(pc),a1
0000DF3C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DF42 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DF46 544F                     M 	addq.w	#__sp,sp
0000DF48 46DF                     M 	move.w	(sp)+,sr
0000DF4A 6000 0000                M 	bra.w	.instr_end_455
0000DF4E                          M 	.str_455:
0000DF4E                          M 	__fstring_generatedecodedstring	"%<.b mComm+7.w>"
0000DF4E =00000001                M 	__lpos:	set 1
0000DF4E =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DF4E                          M 	while	(__pos)
0000DF4E                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+7.w>"
0000DF4E                          M 	dc.b	""
0000DF4E =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DF4E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DF4E =0000000F                M 	__midpos:	= __endpos
0000DF4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DF4E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DF4E                          M 	__param:	substr ,,"hex"
0000DF4E 80                       M 	dc.b	hex
0000DF4F =00000010                M 	__lpos:	set __endpos+1
0000DF4F =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DF4F                          M 	__substr:	substr __lpos,,"%<.b mComm+7.w>"
0000DF4F                          M 	dc.b	""
0000DF4F 00                       M 	dc.b	0
0000DF50                          M 	even
0000DF50                          M 	.instr_end_455:
0000DF50                            
0000DF50                            .rts
0000DF50 4E75                       	rts
0000DF52                            ; ===========================================================================
0000DF52                            ; ---------------------------------------------------------------------------
0000DF52                            ; Invalid fade command handler
0000DF52                            ; ---------------------------------------------------------------------------
0000DF52                            
0000DF52                            AMPS_Debug_FadeCmd	macro
0000DF52                            	cmp.b	#fLast,d0	; check against max
0000DF52                            	bhs.s	.fail		; if in range, branch
0000DF52                            	cmp.b	#$80,d0		; check against min
0000DF52                            	blo.s	.fail		; if too little, bra
0000DF52                            	btst	#1,d0		; check if bit1 set
0000DF52                            	bne.s	.fail		; if is, branch
0000DF52                            	btst	#0,d0		; check if even
0000DF52                            	beq.s	.ok		; if is, branch
0000DF52                            .fail
0000DF52                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF52                            		jsr	AMPS_DebugR_FadeCmd
0000DF52                            	else
0000DF52                            		bra.w	*
0000DF52                            	endif
0000DF52                            .ok
0000DF52                                endm
0000DF52                            
0000DF52                            AMPS_DebugR_FadeCmd:
0000DF52                            		RaiseError2 "Invalid Fade command: %<.b d0>", AMPS_Debug_Console_Main
0000DF52 40E7                     M 	move.w	sr,-(sp)
0000DF54                          M 	__fstring_generateargumentscode	"Invalid Fade command: %<.b d0>"
0000DF54 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DF54 =00000000                M 	__stack:set	0
0000DF54 =00000000                M 	__sp:	set 0
0000DF54                          M 	while	(__pos)
0000DF54 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DF54 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DF54 =0000001E                M 	__midpos:	= __endpos
0000DF54                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DF54                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DF54                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid Fade command: %<.b d0>"
0000DF54                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DF54                          M 	pushp	"move.b d0,1(sp)"
0000DF54                          M 	pushp	"subq.w	#2, sp"
0000DF54 =00000002                M 	__stack:	= __stack+2
0000DF54 =00000002                M 	__sp:	= __sp+2
0000DF54 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DF54                          M 	rept	__stack
0000DF54                          M 	popp	__command
0000DF54 554F                     M 	subq.w	#2,sp
0000DF56                          M 	popp	__command
0000DF56 1F40 0001                M 	move.b	d0,1(sp)
0000DF5A 4EB9 0000 0000           M 	jsr	errorhandler
0000DF60                          M 	__fstring_generatedecodedstring	"Invalid Fade command: %<.b d0>"
0000DF60 =00000001                M 	__lpos:	set 1
0000DF60 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DF60                          M 	while	(__pos)
0000DF60                          M 	__substr:	substr __lpos,__pos-1,"Invalid Fade command: %<.b d0>"
0000DF60 496E 7661 6C69 6420 4661+M 	dc.b	"Invalid Fade command: "
0000DF76 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DF76 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DF76 =0000001E                M 	__midpos:	= __endpos
0000DF76                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DF76                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DF76                          M 	__param:	substr ,,"hex"
0000DF76 80                       M 	dc.b	hex
0000DF77 =0000001F                M 	__lpos:	set __endpos+1
0000DF77 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DF77                          M 	__substr:	substr __lpos,,"Invalid Fade command: %<.b d0>"
0000DF77                          M 	dc.b	""
0000DF77 00                       M 	dc.b	0
0000DF78 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF7A 00                       M 	even
0000DF7A 4EFA FB76                M 	jmp	amps_debug_console_main
0000DF7E                          M 	even
0000DF7E                            ; ===========================================================================
0000DF7E                            ; ---------------------------------------------------------------------------
0000DF7E                            ; Invalid volume envelope handler
0000DF7E                            ; ---------------------------------------------------------------------------
0000DF7E                            
0000DF7E                            AMPS_Debug_VolEnvID	macro
0000DF7E                            	cmp.b	#(VolEnvs_End-VolEnvs)/4,d4	; check against max
0000DF7E                            	bls.s	.ok			; if in range, branch
0000DF7E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF7E                            		jsr	AMPS_DebugR_VolEnvID
0000DF7E                            	else
0000DF7E                            		bra.w	*
0000DF7E                            	endif
0000DF7E                            .ok
0000DF7E                                endm
0000DF7E                            
0000DF7E                            AMPS_DebugR_VolEnvID:
0000DF7E                            		RaiseError2 "Volume envelope ID out of range: %<.b d4>", AMPS_Debug_Console_Channel
0000DF7E 40E7                     M 	move.w	sr,-(sp)
0000DF80                          M 	__fstring_generateargumentscode	"Volume envelope ID out of range: %<.b d4>"
0000DF80 =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DF80 =00000000                M 	__stack:set	0
0000DF80 =00000000                M 	__sp:	set 0
0000DF80                          M 	while	(__pos)
0000DF80 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DF80 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DF80 =00000029                M 	__midpos:	= __endpos
0000DF80                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DF80                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DF80                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DF80                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DF80                          M 	pushp	"move.b d4,1(sp)"
0000DF80                          M 	pushp	"subq.w	#2, sp"
0000DF80 =00000002                M 	__stack:	= __stack+2
0000DF80 =00000002                M 	__sp:	= __sp+2
0000DF80 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DF80                          M 	rept	__stack
0000DF80                          M 	popp	__command
0000DF80 554F                     M 	subq.w	#2,sp
0000DF82                          M 	popp	__command
0000DF82 1F44 0001                M 	move.b	d4,1(sp)
0000DF86 4EB9 0000 0000           M 	jsr	errorhandler
0000DF8C                          M 	__fstring_generatedecodedstring	"Volume envelope ID out of range: %<.b d4>"
0000DF8C =00000001                M 	__lpos:	set 1
0000DF8C =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DF8C                          M 	while	(__pos)
0000DF8C                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope ID out of range: %<.b d4>"
0000DF8C 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope ID out of range: "
0000DFAD =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DFAD =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DFAD =00000029                M 	__midpos:	= __endpos
0000DFAD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DFAD                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DFAD                          M 	__param:	substr ,,"hex"
0000DFAD 80                       M 	dc.b	hex
0000DFAE =0000002A                M 	__lpos:	set __endpos+1
0000DFAE =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DFAE                          M 	__substr:	substr __lpos,,"Volume envelope ID out of range: %<.b d4>"
0000DFAE                          M 	dc.b	""
0000DFAE 00                       M 	dc.b	0
0000DFAF 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFB0                          M 	even
0000DFB0 4EFA F39A                M 	jmp	amps_debug_console_channel
0000DFB4                          M 	even
0000DFB4                            ; ===========================================================================
0000DFB4                            ; ---------------------------------------------------------------------------
0000DFB4                            ; Invalid volume envelope command handler
0000DFB4                            ; ---------------------------------------------------------------------------
0000DFB4                            
0000DFB4                            AMPS_Debug_VolEnvCmd	macro
0000DFB4                            	cmp.b	#eLast,d0	; check against max
0000DFB4                            	bhs.s	.fail		; if too much, bra
0000DFB4                            	cmp.b	#$80,d0		; check against min
0000DFB4                            	blo.s	.fail		; if too little, bra
0000DFB4                            	btst	#0,d0		; check if even
0000DFB4                            	beq.s	.ok		; if is, branch
0000DFB4                            .fail
0000DFB4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFB4                            		RaiseError2 "Volume envelope command invalid: %<.b d0>", AMPS_Debug_Console_Channel
0000DFB4                            	else
0000DFB4                            		bra.w	*
0000DFB4                            	endif
0000DFB4                            .ok
0000DFB4                                endm
0000DFB4                            ; ===========================================================================
0000DFB4                            ; ---------------------------------------------------------------------------
0000DFB4                            ; PSG note check
0000DFB4                            ; ---------------------------------------------------------------------------
0000DFB4                            
0000DFB4                            AMPS_Debug_NotePSG	macro
0000DFB4                            	cmp.b	#dFreqPSG_-dFreqPSG,d5; check against max
0000DFB4                            	blo.s	.ok		; if too little, bra
0000DFB4                            .fail
0000DFB4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFB4                            		jsr	AMPS_DebugR_NotePSG
0000DFB4                            	else
0000DFB4                            		bra.w	*
0000DFB4                            	endif
0000DFB4                            .ok
0000DFB4                                endm
0000DFB4                            
0000DFB4                            AMPS_DebugR_NotePSG:
0000DFB4 E24D                       		lsr.w	#1,d5	; get real note
0000DFB6                            		RaiseError2 "Invalid PSG note: %<.b d5>", AMPS_Debug_Console_Channel
0000DFB6 40E7                     M 	move.w	sr,-(sp)
0000DFB8                          M 	__fstring_generateargumentscode	"Invalid PSG note: %<.b d5>"
0000DFB8 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DFB8 =00000000                M 	__stack:set	0
0000DFB8 =00000000                M 	__sp:	set 0
0000DFB8                          M 	while	(__pos)
0000DFB8 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DFB8 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DFB8 =0000001A                M 	__midpos:	= __endpos
0000DFB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DFB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DFB8                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid PSG note: %<.b d5>"
0000DFB8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DFB8                          M 	pushp	"move.b d5,1(sp)"
0000DFB8                          M 	pushp	"subq.w	#2, sp"
0000DFB8 =00000002                M 	__stack:	= __stack+2
0000DFB8 =00000002                M 	__sp:	= __sp+2
0000DFB8 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DFB8                          M 	rept	__stack
0000DFB8                          M 	popp	__command
0000DFB8 554F                     M 	subq.w	#2,sp
0000DFBA                          M 	popp	__command
0000DFBA 1F45 0001                M 	move.b	d5,1(sp)
0000DFBE 4EB9 0000 0000           M 	jsr	errorhandler
0000DFC4                          M 	__fstring_generatedecodedstring	"Invalid PSG note: %<.b d5>"
0000DFC4 =00000001                M 	__lpos:	set 1
0000DFC4 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DFC4                          M 	while	(__pos)
0000DFC4                          M 	__substr:	substr __lpos,__pos-1,"Invalid PSG note: %<.b d5>"
0000DFC4 496E 7661 6C69 6420 5053+M 	dc.b	"Invalid PSG note: "
0000DFD6 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DFD6 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DFD6 =0000001A                M 	__midpos:	= __endpos
0000DFD6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DFD6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DFD6                          M 	__param:	substr ,,"hex"
0000DFD6 80                       M 	dc.b	hex
0000DFD7 =0000001B                M 	__lpos:	set __endpos+1
0000DFD7 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DFD7                          M 	__substr:	substr __lpos,,"Invalid PSG note: %<.b d5>"
0000DFD7                          M 	dc.b	""
0000DFD7 00                       M 	dc.b	0
0000DFD8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFDA 00                       M 	even
0000DFDA 4EFA F370                M 	jmp	amps_debug_console_channel
0000DFDE                          M 	even
0000DFDE                            ; ===========================================================================
0000DFDE                            ; ---------------------------------------------------------------------------
0000DFDE                            ; FM note check
0000DFDE                            ; ---------------------------------------------------------------------------
0000DFDE                            
0000DFDE                            AMPS_Debug_NoteFM	macro
0000DFDE                            	cmp.b	#dFreqFM_-dFreqFM,d5; check against max
0000DFDE                            	blo.s	.ok		; if too little, bra
0000DFDE                            .fail
0000DFDE                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFDE                            		jsr	AMPS_DebugR_NoteFM
0000DFDE                            	else
0000DFDE                            		bra.w	*
0000DFDE                            	endif
0000DFDE                            .ok
0000DFDE                                endm
0000DFDE                            
0000DFDE                            AMPS_DebugR_NoteFM:
0000DFDE E24D                       		lsr.w	#1,d5	; get real note
0000DFE0                            		RaiseError2 "Invalid FM note: %<.b d5>", AMPS_Debug_Console_Channel
0000DFE0 40E7                     M 	move.w	sr,-(sp)
0000DFE2                          M 	__fstring_generateargumentscode	"Invalid FM note: %<.b d5>"
0000DFE2 =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DFE2 =00000000                M 	__stack:set	0
0000DFE2 =00000000                M 	__sp:	set 0
0000DFE2                          M 	while	(__pos)
0000DFE2 =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DFE2 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DFE2 =00000019                M 	__midpos:	= __endpos
0000DFE2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DFE2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DFE2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid FM note: %<.b d5>"
0000DFE2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DFE2                          M 	pushp	"move.b d5,1(sp)"
0000DFE2                          M 	pushp	"subq.w	#2, sp"
0000DFE2 =00000002                M 	__stack:	= __stack+2
0000DFE2 =00000002                M 	__sp:	= __sp+2
0000DFE2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DFE2                          M 	rept	__stack
0000DFE2                          M 	popp	__command
0000DFE2 554F                     M 	subq.w	#2,sp
0000DFE4                          M 	popp	__command
0000DFE4 1F45 0001                M 	move.b	d5,1(sp)
0000DFE8 4EB9 0000 0000           M 	jsr	errorhandler
0000DFEE                          M 	__fstring_generatedecodedstring	"Invalid FM note: %<.b d5>"
0000DFEE =00000001                M 	__lpos:	set 1
0000DFEE =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DFEE                          M 	while	(__pos)
0000DFEE                          M 	__substr:	substr __lpos,__pos-1,"Invalid FM note: %<.b d5>"
0000DFEE 496E 7661 6C69 6420 464D+M 	dc.b	"Invalid FM note: "
0000DFFF =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DFFF =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DFFF =00000019                M 	__midpos:	= __endpos
0000DFFF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DFFF                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DFFF                          M 	__param:	substr ,,"hex"
0000DFFF 80                       M 	dc.b	hex
0000E000 =0000001A                M 	__lpos:	set __endpos+1
0000E000 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000E000                          M 	__substr:	substr __lpos,,"Invalid FM note: %<.b d5>"
0000E000                          M 	dc.b	""
0000E000 00                       M 	dc.b	0
0000E001 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E002                          M 	even
0000E002 4EFA F348                M 	jmp	amps_debug_console_channel
0000E006                          M 	even
0000E006                            ; ===========================================================================
0000E006                            ; ---------------------------------------------------------------------------
0000E006                            ; DAC frequency check
0000E006                            ; ---------------------------------------------------------------------------
0000E006                            
0000E006                            AMPS_Debug_FreqDAC	macro
0000E006                            	cmp.w	#MaxPitch,d6	; check if frequency is too large
0000E006                            	bgt.s	.fail		; if so, branch
0000E006                            	cmp.w	#-MaxPitch,d6	; check if frequency is too small
0000E006                            	bge.s	.ok		; if not, branch
0000E006                            .fail
0000E006                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E006                            		jsr	AMPS_DebugR_FreqDAC
0000E006                            	else
0000E006                            		bra.w	*
0000E006                            	endif
0000E006                            .ok
0000E006                                endm
0000E006                            
0000E006                            AMPS_DebugR_FreqDAC:
0000E006                            		RaiseError "Out of range DAC frequency: %<.w d6>", AMPS_Debug_Console_Channel
0000E006 487A FFFE                M 	pea	*(pc)
0000E00A                          M 	raiseerror2	"Out of range DAC frequency: %<.w d6>",amps_debug_console_channel
0000E00A 40E7                     M 	move.w	sr,-(sp)
0000E00C                          M 	__fstring_generateargumentscode	"Out of range DAC frequency: %<.w d6>"
0000E00C =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000E00C =00000000                M 	__stack:set	0
0000E00C =00000000                M 	__sp:	set 0
0000E00C                          M 	while	(__pos)
0000E00C =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000E00C =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000E00C =00000024                M 	__midpos:	= __endpos
0000E00C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000E00C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000E00C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Out of range DAC frequency: %<.w d6>"
0000E00C                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000E00C                          M 	pushp	"move.w d6,-(sp)"
0000E00C =00000001                M 	__stack:	= __stack+1
0000E00C =00000002                M 	__sp:	= __sp+2
0000E00C =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000E00C                          M 	rept	__stack
0000E00C                          M 	popp	__command
0000E00C 3F06                     M 	move.w	d6,-(sp)
0000E00E 4EB9 0000 0000           M 	jsr	errorhandler
0000E014                          M 	__fstring_generatedecodedstring	"Out of range DAC frequency: %<.w d6>"
0000E014 =00000001                M 	__lpos:	set 1
0000E014 =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000E014                          M 	while	(__pos)
0000E014                          M 	__substr:	substr __lpos,__pos-1,"Out of range DAC frequency: %<.w d6>"
0000E014 4F75 7420 6F66 2072 616E+M 	dc.b	"Out of range DAC frequency: "
0000E030 =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000E030 =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000E030 =00000024                M 	__midpos:	= __endpos
0000E030                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000E030                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000E030                          M 	__param:	substr ,,"hex"
0000E030 81                       M 	dc.b	hex|1
0000E031 =00000025                M 	__lpos:	set __endpos+1
0000E031 =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000E031                          M 	__substr:	substr __lpos,,"Out of range DAC frequency: %<.w d6>"
0000E031                          M 	dc.b	""
0000E031 00                       M 	dc.b	0
0000E032 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E034 00                       M 	even
0000E034 4EFA F316                M 	jmp	amps_debug_console_channel
0000E038                          M 	even
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Invalid tracker command handlers
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcInvalid	macro
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "Invalid command detected!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; PSG on sPan handler
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcPan	macro
0000E038                            	tst.b	cType(a5)	; check for PSG channel
0000E038                            	bpl.s	.ok		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sPan on a PSG channel!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Timeout command on SFX channel handler
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcTimeout	macro
0000E038                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000E038                            	blo.s	.ok		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sNoteTimeOut on a SFX channel!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Call command handlers
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcCall1	macro
0000E038                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000E038                            	blo.s	.ok1		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sCall on a SFX channel!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok1
0000E038                                endm
0000E038                            
0000E038                            AMPS_Debug_dcCall2	macro
0000E038                            	cmp.b	#cNoteTimeCur,d0; check for invalid stack address
0000E038                            	bhi.s	.ok2		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sCall stack too deep!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok2
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Loop command handler
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcLoop	macro
0000E038                            	cmp.b	#3,d0		; check for invalid call number
0000E038                            	bhi.s	.fail		; if is, branch
0000E038                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000E038                            	blo.s	.nosfx		; if no, branch
0000E038                            	cmp.b	#1,d0		; check if cPrio
0000E038                            	beq.s	.fail		; if so, branch
0000E038                            .nosfx
0000E038                            	cmp.b	#$C0,cType(a5)	; check if PSG3 or PSG4
0000E038                            	blo.s	AMPS_Debug_dcLoop_ok; if no, branch
0000E038                            	cmp.b	#2,d0		; check if cStatPSG4
0000E038                            	bne.s	AMPS_Debug_dcLoop_ok; if no, branch
0000E038                            .fail
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sLoop ID is invalid!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            AMPS_Debug_dcLoop_ok
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Return command handlers
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_dcReturn1	macro
0000E038                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000E038                            	blo.s	.ok1		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sRet on a SFX channel!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok1
0000E038                                endm
0000E038                            
0000E038                            AMPS_Debug_dcReturn2	macro
0000E038                            	cmp.b	#cSize,d0	; check for invalid stack address
0000E038                            	bls.s	.ok2		; if no, branch
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "sRet stack too shallow!", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok2
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Update FM voice handler
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_UpdVoiceFM	macro
0000E038                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000E038                            	bne.s	.fail		; if not, branch
0000E038                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000E038                            	beq.s	.ok		; if is, branch
0000E038                            .fail
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		RaiseError "FM voice Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok
0000E038                                endm
0000E038                            ; ===========================================================================
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            ; Update FM Volume handler
0000E038                            ; ---------------------------------------------------------------------------
0000E038                            
0000E038                            AMPS_Debug_UpdVolFM	macro
0000E038                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000E038                            	bne.s	.fail		; if not, branch
0000E038                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000E038                            	beq.s	.ok		; if is, branch
0000E038                            .fail
0000E038                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E038                            		jsr	AMPS_DebugR_UpdVolFM
0000E038                            	else
0000E038                            		bra.w	*
0000E038                            	endif
0000E038                            .ok
0000E038                                endm
0000E038                            
0000E038                            AMPS_DebugR_UpdVolFM:
0000E038                            	RaiseError2 "FM Volume Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000E038 40E7                     M 	move.w	sr,-(sp)
0000E03A                          M 	__fstring_generateargumentscode	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E03A =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000E03A =00000000                M 	__stack:set	0
0000E03A =00000000                M 	__sp:	set 0
0000E03A                          M 	while	(__pos)
0000E03A =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000E03A =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000E03A =00000030                M 	__midpos:	= __endpos
0000E03A                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E03A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E03A                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E03A                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E03A                          M 	pushp	"move.b cVoice(a5),1(sp)"
0000E03A                          M 	pushp	"subq.w	#2, sp"
0000E03A =00000002                M 	__stack:	= __stack+2
0000E03A =00000002                M 	__sp:	= __sp+2
0000E03A =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000E03A                          M 	rept	__stack
0000E03A                          M 	popp	__command
0000E03A 554F                     M 	subq.w	#2,sp
0000E03C                          M 	popp	__command
0000E03C 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
0000E042 4EB9 0000 0000           M 	jsr	errorhandler
0000E048                          M 	__fstring_generatedecodedstring	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E048 =00000001                M 	__lpos:	set 1
0000E048 =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000E048                          M 	while	(__pos)
0000E048                          M 	__substr:	substr __lpos,__pos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E048 464D 2056 6F6C 756D 6520+M 	dc.b	"FM Volume Update invalid voice: "
0000E068 =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000E068 =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000E068 =00000030                M 	__midpos:	= __endpos
0000E068                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E068                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E068                          M 	__param:	substr ,,"hex"
0000E068 80                       M 	dc.b	hex
0000E069 =00000031                M 	__lpos:	set __endpos+1
0000E069 =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000E069                          M 	__substr:	substr __lpos,,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000E069                          M 	dc.b	""
0000E069 00                       M 	dc.b	0
0000E06A 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E06C 00                       M 	even
0000E06C 4EFA F2DE                M 	jmp	amps_debug_console_channel
0000E070                          M 	even
0000E070                            ; ===========================================================================
0000E070                            ; ---------------------------------------------------------------------------
0000E070                            ; Invalid cue handler
0000E070                            ; ---------------------------------------------------------------------------
0000E070                            
0000E070                            AMPS_Debug_CuePtr	macro id
0000E070                            	cmp.l	#$A00000+YM_Buffer1,a0	; check against min
0000E070                            	blo.s	.fail\@			; if not in range, branch
0000E070                            	cmp.l	#$A00000+YM_Buffer2+$400,a0; check against max
0000E070                            	blo.s	.ok\@			; if in range, branch
0000E070                            .fail\@
0000E070                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E070                            		jsr	AMPS_Debug_CuePtr\id
0000E070                            	else
0000E070                            		bra.w	*
0000E070                            	endif
0000E070                            .ok\@
0000E070                                endm
0000E070                            
0000E070                            AMPS_Debug_CuePtr1:
0000E070                            		RaiseError2 "CUE invalid at WriteYM_Pt1: %<.l a0>", AMPS_Debug_Console_Channel
0000E070 40E7                     M 	move.w	sr,-(sp)
0000E072                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E072 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000E072 =00000000                M 	__stack:set	0
0000E072 =00000000                M 	__sp:	set 0
0000E072                          M 	while	(__pos)
0000E072 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000E072 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000E072 =00000024                M 	__midpos:	= __endpos
0000E072                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E072                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E072                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E072                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E072                          M 	pushp	"move.l a0,-(sp)"
0000E072 =00000001                M 	__stack:	= __stack+1
0000E072 =00000004                M 	__sp:	= __sp+4
0000E072 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000E072                          M 	rept	__stack
0000E072                          M 	popp	__command
0000E072 2F08                     M 	move.l	a0,-(sp)
0000E074 4EB9 0000 0000           M 	jsr	errorhandler
0000E07A                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E07A =00000001                M 	__lpos:	set 1
0000E07A =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000E07A                          M 	while	(__pos)
0000E07A                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E07A 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt1: "
0000E096 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000E096 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000E096 =00000024                M 	__midpos:	= __endpos
0000E096                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E096                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E096                          M 	__param:	substr ,,"hex"
0000E096 83                       M 	dc.b	hex|3
0000E097 =00000025                M 	__lpos:	set __endpos+1
0000E097 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000E097                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E097                          M 	dc.b	""
0000E097 00                       M 	dc.b	0
0000E098 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E09A 00                       M 	even
0000E09A 4EFA F2B0                M 	jmp	amps_debug_console_channel
0000E09E                          M 	even
0000E09E                            AMPS_Debug_CuePtr2:
0000E09E                            		RaiseError2 "CUE invalid at WriteYM_Pt2: %<.l a0>", AMPS_Debug_Console_Channel
0000E09E 40E7                     M 	move.w	sr,-(sp)
0000E0A0                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A0 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E0A0 =00000000                M 	__stack:set	0
0000E0A0 =00000000                M 	__sp:	set 0
0000E0A0                          M 	while	(__pos)
0000E0A0 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000E0A0 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000E0A0 =00000024                M 	__midpos:	= __endpos
0000E0A0                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A0                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A0                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A0                          M 	pushp	"move.l a0,-(sp)"
0000E0A0 =00000001                M 	__stack:	= __stack+1
0000E0A0 =00000004                M 	__sp:	= __sp+4
0000E0A0 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E0A0                          M 	rept	__stack
0000E0A0                          M 	popp	__command
0000E0A0 2F08                     M 	move.l	a0,-(sp)
0000E0A2 4EB9 0000 0000           M 	jsr	errorhandler
0000E0A8                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A8 =00000001                M 	__lpos:	set 1
0000E0A8 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E0A8                          M 	while	(__pos)
0000E0A8                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0A8 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt2: "
0000E0C4 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000E0C4 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000E0C4 =00000024                M 	__midpos:	= __endpos
0000E0C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0C4                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0C4                          M 	__param:	substr ,,"hex"
0000E0C4 83                       M 	dc.b	hex|3
0000E0C5 =00000025                M 	__lpos:	set __endpos+1
0000E0C5 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E0C5                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E0C5                          M 	dc.b	""
0000E0C5 00                       M 	dc.b	0
0000E0C6 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E0C8 00                       M 	even
0000E0C8 4EFA F282                M 	jmp	amps_debug_console_channel
0000E0CC                          M 	even
0000E0CC                            AMPS_Debug_CuePtr0:
0000E0CC                            		RaiseError2 "CUE invalid at dUpdateVoiceFM: %<.l a0>", AMPS_Debug_Console_Channel
0000E0CC 40E7                     M 	move.w	sr,-(sp)
0000E0CE                          M 	__fstring_generateargumentscode	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0CE =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E0CE =00000000                M 	__stack:set	0
0000E0CE =00000000                M 	__sp:	set 0
0000E0CE                          M 	while	(__pos)
0000E0CE =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000E0CE =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000E0CE =00000027                M 	__midpos:	= __endpos
0000E0CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0CE                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0CE                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0CE                          M 	pushp	"move.l a0,-(sp)"
0000E0CE =00000001                M 	__stack:	= __stack+1
0000E0CE =00000004                M 	__sp:	= __sp+4
0000E0CE =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E0CE                          M 	rept	__stack
0000E0CE                          M 	popp	__command
0000E0CE 2F08                     M 	move.l	a0,-(sp)
0000E0D0 4EB9 0000 0000           M 	jsr	errorhandler
0000E0D6                          M 	__fstring_generatedecodedstring	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0D6 =00000001                M 	__lpos:	set 1
0000E0D6 =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E0D6                          M 	while	(__pos)
0000E0D6                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0D6 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dUpdateVoiceFM: "
0000E0F5 =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000E0F5 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000E0F5 =00000027                M 	__midpos:	= __endpos
0000E0F5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0F5                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0F5                          M 	__param:	substr ,,"hex"
0000E0F5 83                       M 	dc.b	hex|3
0000E0F6 =00000028                M 	__lpos:	set __endpos+1
0000E0F6 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E0F6                          M 	__substr:	substr __lpos,,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E0F6                          M 	dc.b	""
0000E0F6 00                       M 	dc.b	0
0000E0F7 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E0F8                          M 	even
0000E0F8 4EFA F252                M 	jmp	amps_debug_console_channel
0000E0FC                          M 	even
0000E0FC                            AMPS_Debug_CuePtr3:
0000E0FC                            		RaiseError2 "CUE invalid at dAMPSend: %<.l a0>", AMPS_Debug_Console_Channel
0000E0FC 40E7                     M 	move.w	sr,-(sp)
0000E0FE                          M 	__fstring_generateargumentscode	"CUE invalid at dAMPSend: %<.l a0>"
0000E0FE =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E0FE =00000000                M 	__stack:set	0
0000E0FE =00000000                M 	__sp:	set 0
0000E0FE                          M 	while	(__pos)
0000E0FE =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E0FE =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E0FE =00000021                M 	__midpos:	= __endpos
0000E0FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E0FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E0FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E0FE                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E0FE                          M 	pushp	"move.l a0,-(sp)"
0000E0FE =00000001                M 	__stack:	= __stack+1
0000E0FE =00000004                M 	__sp:	= __sp+4
0000E0FE =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E0FE                          M 	rept	__stack
0000E0FE                          M 	popp	__command
0000E0FE 2F08                     M 	move.l	a0,-(sp)
0000E100 4EB9 0000 0000           M 	jsr	errorhandler
0000E106                          M 	__fstring_generatedecodedstring	"CUE invalid at dAMPSend: %<.l a0>"
0000E106 =00000001                M 	__lpos:	set 1
0000E106 =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E106                          M 	while	(__pos)
0000E106                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E106 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dAMPSend: "
0000E11F =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E11F =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E11F =00000021                M 	__midpos:	= __endpos
0000E11F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E11F                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E11F                          M 	__param:	substr ,,"hex"
0000E11F 83                       M 	dc.b	hex|3
0000E120 =00000022                M 	__lpos:	set __endpos+1
0000E120 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E120                          M 	__substr:	substr __lpos,,"CUE invalid at dAMPSend: %<.l a0>"
0000E120                          M 	dc.b	""
0000E120 00                       M 	dc.b	0
0000E121 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E122                          M 	even
0000E122 4EFA F228                M 	jmp	amps_debug_console_channel
0000E126                          M 	even
0000E126                            ; ===========================================================================
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            ; Play Command handler
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            
0000E126                            AMPS_Debug_PlayCmd	macro
0000E126                            	cmp.b	#(dSoundCommands_End-dSoundCommands)/4,d7; check if this is valid command
0000E126                            	bls.s	.ok		; if is, branch
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		RaiseError "Invalid command in queue: %<.b d7>", AMPS_Debug_Console_Channel
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                            .ok
0000E126                                endm
0000E126                            ; ===========================================================================
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            ; Tracker address handlers
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            
0000E126                            AMPS_Debug_PlayTrackMus	macro
0000E126                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.fail\@		; if no, branch
0000E126                            	cmp.l	#musend,d0	; check if this is valid tracker
0000E126                            	blo.s	.ok\@		; if is, branch
0000E126                            .fail\@
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		lsr.w	#2,d7	; get actual ID
0000E126                            		RaiseError "Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                            .ok\@
0000E126                                endm
0000E126                            
0000E126                            AMPS_Debug_PlayTrackMus2	macro ch
0000E126                            	and.l	#$FFFFFF,d0	; remove high byte
0000E126                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.fail\@		; if no, branch
0000E126                            	cmp.l	#dacaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.ok\@		; if is, branch
0000E126                            .fail\@
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		RaiseError "Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                            .ok\@
0000E126                                endm
0000E126                            
0000E126                            AMPS_Debug_PlayTrackSFX	macro
0000E126                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.fail\@		; if no, branch
0000E126                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.ok\@		; if is, branch
0000E126                            .fail\@
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		RaiseError "Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                            .ok\@
0000E126                                endm
0000E126                            
0000E126                            AMPS_Debug_PlayTrackSFX2	macro
0000E126                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.fail\@		; if no, branch
0000E126                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E126                            	blo.s	.ok\@		; if is, branch
0000E126                            .fail\@
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		RaiseError "Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                            .ok\@
0000E126                                endm
0000E126                            
0000E126                            AMPS_Debug_TrackUpd	macro
0000E126                            	move.l	a4,d1		; copy to d1
0000E126                            	and.l	#$FFFFFF,d1	; remove high byte
0000E126                            	cmp.l	#sfxaddr,d1	; check if this is valid tracker
0000E126                            	blo.s	.fail2		; if no, branch
0000E126                            	cmp.l	#dacaddr,d1	; check if this is valid tracker
0000E126                            	blo.s	.data		; if is, branch
0000E126                            .fail2
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		RaiseError "Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Channel
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                                endm
0000E126                            ; ===========================================================================
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            ; Tracker debugger handler and console code
0000E126                            ; ---------------------------------------------------------------------------
0000E126                            
0000E126                            AMPS_Debug_ChkTracker	macro
0000E126                            .fail
0000E126                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E126                            		jsr	AMPS_DebugR_ChkTracker
0000E126                            	else
0000E126                            		bra.w	*
0000E126                            	endif
0000E126                                endm
0000E126                            
0000E126                            AMPS_DebugR_ChkTracker:
0000E126 4EBA 0000                  		jsr	AMPS_Debug_CalcMax(pc)
0000E12A 4847                       		swap	d7			; swap d7 words
0000E12C                            
0000E12C                            AMPS_DebugR_ChkTracker_loop
0000E12C 23C7 00FF 0000             		move.l	d7,$FF0000		; save stuff in RAM
0000E132                            		Console.Run AMPS_DebugR_ChkTracker2, "NAT"
0000E132 4EB9 0000 0000           M 	jsr	errorhandler.__extern__console_only
0000E138 4EB9 0000 0000           M 	jsr	amps_debugr_chktracker2
0000E13E 2E39 00FF 0000             		move.l	$FF0000,d7		; get stuff back
0000E144                            
0000E144                            AMPS_DebugR_ChkTracker_nodraw
0000E144 7CFF                       		moveq	#-1,d6
0000E146 51CE FFFE                  		dbf	d6,*			; delay a lot
0000E14A                            
0000E14A                            	; implement reading control data
0000E14A 43F9 00A1 0003             		lea	$A10003,a1
0000E150 12BC 0000                  		move.b	#0,(a1)			; set TH low
0000E154 8080                       		or.l	d0,d0			; delay
0000E156 12BC 0040                  		move.b	#$40,(a1)		; set TH high
0000E15A 8080                       		or.l	d0,d0			; delay
0000E15C 1011                       		move.b	(a1),d0			; get dpad stat
0000E15E                            
0000E15E 3A07                       		move.w	d7,d5			; copy to d5
0000E160 0800 0000                  		btst	#0,d0			; check if up held
0000E164 6600                       		bne.s	AMPS_Debug_Writekd			; if not ,branch
0000E166                            
0000E166 5347                       		subq.w	#1,d7			; move up
0000E168 6A00                       		bpl.s	AMPS_Debug_Writekd			; if positive, branch
0000E16A 4247                       		clr.w	d7			; else force to 0
0000E16C                            
0000E16C                            AMPS_Debug_Writekd
0000E16C 0800 0001                  		btst	#1,d0			; check if down held
0000E170 6600                       		bne.s	AMPS_Debug_Writekdraw			; if not ,branch
0000E172                            
0000E172 4847                       		swap	d7
0000E174 3C07                       		move.w	d7,d6			; copy high word to d6
0000E176 4847                       		swap	d7
0000E178                            
0000E178 BE46                       		cmp.w	d6,d7			; check if we can move up
0000E17A 6C00                       		bge.s	AMPS_Debug_Writekdraw			; if not, branch
0000E17C 5247                       		addq.w	#1,d7			; move down
0000E17E                            
0000E17E                            AMPS_Debug_Writekdraw
0000E17E BA47                       		cmp.w	d7,d5			; check if we need to redraw
0000E180 67C2                       		beq.s	AMPS_DebugR_ChkTracker_nodraw; if not, branch
0000E182 6000 FFA8                  		bra.w	AMPS_DebugR_ChkTracker_loop
0000E186                            
0000E186                            AMPS_Debug_CalcMax:
0000E186 7C1C                       		moveq	#28,d6	; max lines count
0000E188 7E09                       		moveq	#10-1,d7	; run for 10 chs
0000E18A 7A2C                       		moveq	#cSize,d5	; prepare size
0000E18C 4BF8 C650                  		lea	mPSG3.w,a5	; start at PSG3
0000E190                            
0000E190                            AMPS_Debug_Writehkloop
0000E190 4A46                       		tst.w	d6		; check if we have no lines left
0000E192                            	;	ble.s	.rts		; if so, we found it
0000E192 5746                       		subq.w	#3,d6		; we need at least 3 lines
0000E194 6B00                       		bmi.s	.add		; if not enough lines, branch
0000E196                            
0000E196 320D                       		move.w	a5,d1		; copy ch to d1
0000E198 0641 002C                  		add.w	#cSize,d1	; go to end of it
0000E19C                            
0000E19C 7000                       		moveq	#0,d0
0000E19E 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E1A2 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E1A6                            
0000E1A6                            .stack
0000E1A6 B24E                       		cmp.w	a6,d1		; check if stack is dry now
0000E1A8 6200                       		bhi.s	.inc		; if not, branch
0000E1AA                            
0000E1AA 9AC5                       		sub.w	d5,a5		; sub ch size
0000E1AC 51CF FFE2                  		dbf	d7,AMPS_Debug_Writehkloop	; loop for all chans
0000E1B0 6000                       		bra.s	.add
0000E1B2                            
0000E1B2                            .inc
0000E1B2 584E                       		addq.w	#4,a6		; go to next long
0000E1B4 5346                       		subq.w	#1,d6		; sub 1 line
0000E1B6 6AEE                       		bpl.s	.stack		; if lines left, branch
0000E1B8                            
0000E1B8                            .add
0000E1B8 5247                       		addq.w	#1,d7		; increase ch by 1
0000E1BA                            .rts
0000E1BA 4E75                       		rts
0000E1BC                            
0000E1BC                            AMPS_DebugR_ChkTracker_Ch:
0000E1BC 5347                       		subq.w	#1,d7		; sub 1 from offset
0000E1BE 6A00 0000                  		bpl.w	AMPS_Debug_Write_n; branch if positive
0000E1C2 4A46                       		tst.w	d6		; check if we need to render anymore
0000E1C4 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if not, branch
0000E1C8                            
0000E1C8                            ; fmt: <addr> lstdur, dur, freq, sample, loop0, loop1, loop2
0000E1C8 4E90                       		jsr	(a0)
0000E1CA                            	Console.Write	  ": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CA 40E7                     M 	move.w	sr,-(sp)
0000E1CC                          M 	__fstring_generateargumentscode	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC =00000000                M 	__stack:set	0
0000E1CC =00000000                M 	__sp:	set 0
0000E1CC                          M 	while	(__pos)
0000E1CC =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E1CC =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E1CC =0000000A                M 	__midpos:	= __endpos
0000E1CC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E1CC =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E1CC =00000012                M 	__midpos:	= __endpos
0000E1CC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	pushp	"move.w a5,-(sp)"
0000E1CC =00000001                M 	__stack:	= __stack+1
0000E1CC =00000002                M 	__sp:	= __sp+2
0000E1CC =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E1CC =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E1CC =00000025                M 	__midpos:	= __endpos
0000E1CC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000E1CC                          M 	pushp	"subq.w	#2, sp"
0000E1CC =00000003                M 	__stack:	= __stack+2
0000E1CC =00000004                M 	__sp:	= __sp+2
0000E1CC =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E1CC =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E1CC =00000039                M 	__midpos:	= __endpos
0000E1CC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000E1CC                          M 	pushp	"subq.w	#2, sp"
0000E1CC =00000005                M 	__stack:	= __stack+2
0000E1CC =00000006                M 	__sp:	= __sp+2
0000E1CC =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E1CC =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E1CC =00000049                M 	__midpos:	= __endpos
0000E1CC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E1CC                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000E1CC =00000006                M 	__stack:	= __stack+1
0000E1CC =00000008                M 	__sp:	= __sp+2
0000E1CC =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E1CC                          M 	rept	__stack
0000E1CC                          M 	popp	__command
0000E1CC 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000E1D0                          M 	popp	__command
0000E1D0 554F                     M 	subq.w	#2,sp
0000E1D2                          M 	popp	__command
0000E1D2 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000E1D8                          M 	popp	__command
0000E1D8 554F                     M 	subq.w	#2,sp
0000E1DA                          M 	popp	__command
0000E1DA 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000E1E0                          M 	popp	__command
0000E1E0 3F0D                     M 	move.w	a5,-(sp)
0000E1E2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E1E6 45EF 0010                M 	lea	4*4(sp),a2
0000E1EA 43FA 0000                M 	lea	.str_490(pc),a1
0000E1EE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E1F4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E1F8 504F                     M 	addq.w	#__sp,sp
0000E1FA 46DF                     M 	move.w	(sp)+,sr
0000E1FC 6000 0000                M 	bra.w	.instr_end_490
0000E200                          M 	.str_490:
0000E200                          M 	__fstring_generatedecodedstring	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E200 =00000001                M 	__lpos:	set 1
0000E200 =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E200                          M 	while	(__pos)
0000E200                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E200 3A20                     M 	dc.b	": "
0000E202 =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E202 =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E202 =0000000A                M 	__midpos:	= __endpos
0000E202                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E202                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E202 EC                       M 	dc.b	fpal2
0000E203 =0000000B                M 	__lpos:	set __endpos+1
0000E203 =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E203                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E203                          M 	dc.b	""
0000E203 =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E203 =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E203 =00000012                M 	__midpos:	= __endpos
0000E203                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E203                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E203                          M 	__param:	substr ,,"hex"
0000E203 81                       M 	dc.b	hex|1
0000E204 =00000013                M 	__lpos:	set __endpos+1
0000E204 =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E204                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E204 20                       M 	dc.b	" "
0000E205 =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E205 =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E205 =00000025                M 	__midpos:	= __endpos
0000E205                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E205                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E205                          M 	__param:	substr ,,"hex"
0000E205 80                       M 	dc.b	hex
0000E206 =00000026                M 	__lpos:	set __endpos+1
0000E206 =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E206                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E206 20                       M 	dc.b	" "
0000E207 =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E207 =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E207 =00000039                M 	__midpos:	= __endpos
0000E207                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E207                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E207                          M 	__param:	substr ,,"hex"
0000E207 80                       M 	dc.b	hex
0000E208 =0000003A                M 	__lpos:	set __endpos+1
0000E208 =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E208                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E208 20                       M 	dc.b	" "
0000E209 =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E209 =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E209 =00000049                M 	__midpos:	= __endpos
0000E209                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E209                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E209                          M 	__param:	substr ,,"hex"
0000E209 81                       M 	dc.b	hex|1
0000E20A =0000004A                M 	__lpos:	set __endpos+1
0000E20A =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E20A                          M 	__substr:	substr __lpos,,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E20A                          M 	dc.b	""
0000E20A 00                       M 	dc.b	0
0000E20C 00                       M 	even
0000E20C                          M 	.instr_end_490:
0000E20C                            	Console.WriteLine " %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20C 40E7                     M 	move.w	sr,-(sp)
0000E20E                          M 	__fstring_generateargumentscode	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E20E =00000000                M 	__stack:set	0
0000E20E =00000000                M 	__sp:	set 0
0000E20E                          M 	while	(__pos)
0000E20E =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E20E =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E20E =00000012                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	pushp	"move.b cSample(a5),1(sp)"
0000E20E                          M 	pushp	"subq.w	#2, sp"
0000E20E =00000002                M 	__stack:	= __stack+2
0000E20E =00000002                M 	__sp:	= __sp+2
0000E20E =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E20E =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E20E =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E20E =00000022                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000E20E                          M 	pushp	"subq.w	#2, sp"
0000E20E =00000004                M 	__stack:	= __stack+2
0000E20E =00000004                M 	__sp:	= __sp+2
0000E20E =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E20E =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E20E =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E20E =00000034                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000E20E                          M 	pushp	"subq.w	#2, sp"
0000E20E =00000006                M 	__stack:	= __stack+2
0000E20E =00000006                M 	__sp:	= __sp+2
0000E20E =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E20E =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E20E =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E20E =00000046                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E20E                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000E20E                          M 	pushp	"subq.w	#2, sp"
0000E20E =00000008                M 	__stack:	= __stack+2
0000E20E =00000008                M 	__sp:	= __sp+2
0000E20E =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E20E                          M 	rept	__stack
0000E20E                          M 	popp	__command
0000E20E 554F                     M 	subq.w	#2,sp
0000E210                          M 	popp	__command
0000E210 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000E216                          M 	popp	__command
0000E216 554F                     M 	subq.w	#2,sp
0000E218                          M 	popp	__command
0000E218 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000E21E                          M 	popp	__command
0000E21E 554F                     M 	subq.w	#2,sp
0000E220                          M 	popp	__command
0000E220 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000E226                          M 	popp	__command
0000E226 554F                     M 	subq.w	#2,sp
0000E228                          M 	popp	__command
0000E228 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000E22E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E232 45EF 0010                M 	lea	4*4(sp),a2
0000E236 43FA 0000                M 	lea	.str_493(pc),a1
0000E23A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E240 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E244 504F                     M 	addq.w	#__sp,sp
0000E246 46DF                     M 	move.w	(sp)+,sr
0000E248 6000 0000                M 	bra.w	.instr_end_493
0000E24C                          M 	.str_493:
0000E24C                          M 	__fstring_generatedecodedstring	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24C =00000001                M 	__lpos:	set 1
0000E24C =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E24C                          M 	while	(__pos)
0000E24C                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24C 20                       M 	dc.b	" "
0000E24D =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E24D =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E24D =00000012                M 	__midpos:	= __endpos
0000E24D                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24D                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24D                          M 	__param:	substr ,,"hex"
0000E24D 80                       M 	dc.b	hex
0000E24E =00000013                M 	__lpos:	set __endpos+1
0000E24E =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E24E                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24E 20                       M 	dc.b	" "
0000E24F =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E24F =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E24F =00000022                M 	__midpos:	= __endpos
0000E24F                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24F                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E24F                          M 	__param:	substr ,,"hex"
0000E24F 80                       M 	dc.b	hex
0000E250 =00000023                M 	__lpos:	set __endpos+1
0000E250 =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E250                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E250 20                       M 	dc.b	" "
0000E251 =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E251 =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E251 =00000034                M 	__midpos:	= __endpos
0000E251                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E251                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E251                          M 	__param:	substr ,,"hex"
0000E251 80                       M 	dc.b	hex
0000E252 =00000035                M 	__lpos:	set __endpos+1
0000E252 =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E252                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E252 20                       M 	dc.b	" "
0000E253 =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E253 =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E253 =00000046                M 	__midpos:	= __endpos
0000E253                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E253                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E253                          M 	__param:	substr ,,"hex"
0000E253 80                       M 	dc.b	hex
0000E254 =00000047                M 	__lpos:	set __endpos+1
0000E254 =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E254                          M 	__substr:	substr __lpos,," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E254                          M 	dc.b	""
0000E254 00                       M 	dc.b	0
0000E256 00                       M 	even
0000E256                          M 	.instr_end_493:
0000E256                            	Console.WriteLine " %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E256 40E7                     M 	move.w	sr,-(sp)
0000E258                          M 	__fstring_generateargumentscode	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258 =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E258 =00000000                M 	__stack:set	0
0000E258 =00000000                M 	__sp:	set 0
0000E258                          M 	while	(__pos)
0000E258 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E258 =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E258 =00000009                M 	__midpos:	= __endpos
0000E258                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E258 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E258 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E258 =00000017                M 	__midpos:	= __endpos
0000E258                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E258 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E258 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E258                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	pushp	"move.l cData(a5),-(sp)"
0000E258 =00000001                M 	__stack:	= __stack+1
0000E258 =00000004                M 	__sp:	= __sp+4
0000E258 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E258 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E258 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E258 =00000042                M 	__midpos:	= __endpos
0000E258                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E258 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E258                          M 	rept	__stack
0000E258                          M 	popp	__command
0000E258 2F2D 0002                M 	move.l	cdata(a5),-(sp)
0000E25C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E260 45EF 0010                M 	lea	4*4(sp),a2
0000E264 43FA 0000                M 	lea	.str_496(pc),a1
0000E268 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E26E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E272 584F                     M 	addq.w	#__sp,sp
0000E274 46DF                     M 	move.w	(sp)+,sr
0000E276 6000 0000                M 	bra.w	.instr_end_496
0000E27A                          M 	.str_496:
0000E27A                          M 	__fstring_generatedecodedstring	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E27A =00000001                M 	__lpos:	set 1
0000E27A =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E27A                          M 	while	(__pos)
0000E27A                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E27A 20                       M 	dc.b	" "
0000E27B =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E27B =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E27B =00000009                M 	__midpos:	= __endpos
0000E27B                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E27B                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E27B EA                       M 	dc.b	fpal1
0000E27C =0000000A                M 	__lpos:	set __endpos+1
0000E27C =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E27C                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E27C 4164 6472 3A20           M 	dc.b	"Addr: "
0000E282 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E282 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E282 =00000017                M 	__midpos:	= __endpos
0000E282                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E282                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E282 E8                       M 	dc.b	fpal0
0000E283 =00000018                M 	__lpos:	set __endpos+1
0000E283 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E283                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E283                          M 	dc.b	""
0000E283 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E283 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E283                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E283                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E283 BB                       M 	dc.b	sym|fsplit|3
0000E284 =00000032                M 	__lpos:	set __endpos+1
0000E284 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E284                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E284                          M 	dc.b	""
0000E284 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E284 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E284 =00000042                M 	__midpos:	= __endpos
0000E284                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E284                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E284 ECC0                     M 	dc.b	fpal2,fsymdisp
0000E286 =00000043                M 	__lpos:	set __endpos+1
0000E286 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E286                          M 	__substr:	substr __lpos,," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E286                          M 	dc.b	""
0000E286 00                       M 	dc.b	0
0000E288 00                       M 	even
0000E288                          M 	.instr_end_496:
0000E288                            
0000E288 5546                       		subq.w	#2,d6		; sub those 2 lines from stuff
0000E28A 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if drawn all, branch
0000E28E 320D                       		move.w	a5,d1		; copy ch to d1
0000E290 D245                       		add.w	d5,d1		; go to end of it
0000E292                            
0000E292 7000                       		moveq	#0,d0
0000E294 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E298 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E29C                            
0000E29C B24E                       		cmp.w	a6,d1		; check if stack is dry
0000E29E 6300                       		bls.s	AMPS_Debug_Write		; if is, branch
0000E2A0                            	Console.WriteLine " %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A0 40E7                     M 	move.w	sr,-(sp)
0000E2A2                          M 	__fstring_generateargumentscode	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2A2 =00000000                M 	__stack:set	0
0000E2A2 =00000000                M 	__sp:	set 0
0000E2A2                          M 	while	(__pos)
0000E2A2 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2A2 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2A2 =00000009                M 	__midpos:	= __endpos
0000E2A2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2A2 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2A2 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2A2 =00000017                M 	__midpos:	= __endpos
0000E2A2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2A2 =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2A2 =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2A2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	pushp	"move.l (a6)+,-(sp)"
0000E2A2 =00000001                M 	__stack:	= __stack+1
0000E2A2 =00000004                M 	__sp:	= __sp+4
0000E2A2 =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2A2 =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2A2 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2A2 =0000003E                M 	__midpos:	= __endpos
0000E2A2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2A2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2A2                          M 	rept	__stack
0000E2A2                          M 	popp	__command
0000E2A2 2F1E                     M 	move.l	(a6)+,-(sp)
0000E2A4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2A8 45EF 0010                M 	lea	4*4(sp),a2
0000E2AC 43FA 0000                M 	lea	.str_499(pc),a1
0000E2B0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E2B6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2BA 584F                     M 	addq.w	#__sp,sp
0000E2BC 46DF                     M 	move.w	(sp)+,sr
0000E2BE 6000 0000                M 	bra.w	.instr_end_499
0000E2C2                          M 	.str_499:
0000E2C2                          M 	__fstring_generatedecodedstring	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2C2 =00000001                M 	__lpos:	set 1
0000E2C2 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2C2                          M 	while	(__pos)
0000E2C2                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2C2 20                       M 	dc.b	" "
0000E2C3 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2C3 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2C3 =00000009                M 	__midpos:	= __endpos
0000E2C3                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2C3                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2C3 EA                       M 	dc.b	fpal1
0000E2C4 =0000000A                M 	__lpos:	set __endpos+1
0000E2C4 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2C4                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2C4 5374 6163 6B3A           M 	dc.b	"Stack:"
0000E2CA =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2CA =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2CA =00000017                M 	__midpos:	= __endpos
0000E2CA                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CA                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CA E8                       M 	dc.b	fpal0
0000E2CB =00000018                M 	__lpos:	set __endpos+1
0000E2CB =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2CB                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CB                          M 	dc.b	""
0000E2CB =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2CB =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2CB                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CB                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CB BB                       M 	dc.b	sym|fsplit|3
0000E2CC =0000002E                M 	__lpos:	set __endpos+1
0000E2CC =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2CC                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CC                          M 	dc.b	""
0000E2CC =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2CC =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2CC =0000003E                M 	__midpos:	= __endpos
0000E2CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CC                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CC ECC0                     M 	dc.b	fpal2,fsymdisp
0000E2CE =0000003F                M 	__lpos:	set __endpos+1
0000E2CE =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2CE                          M 	__substr:	substr __lpos,," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2CE                          M 	dc.b	""
0000E2CE 00                       M 	dc.b	0
0000E2D0 00                       M 	even
0000E2D0                          M 	.instr_end_499:
0000E2D0 5346                       		subq.w	#1,d6		; sub a line
0000E2D2 6B00                       		bmi.s	AMPS_Debug_Write_n; if drawn all, branch
0000E2D4                            
0000E2D4                            AMPS_DebugR_ChkTracker_Ch_loop
0000E2D4 B24E                       		cmp.w	a6,d1		; check if we printed full stack
0000E2D6 6300                       		bls.s	AMPS_Debug_Write		; if not though, branch
0000E2D8                            	Console.WriteLine "   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2D8 40E7                     M 	move.w	sr,-(sp)
0000E2DA                          M 	__fstring_generateargumentscode	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2DA =00000000                M 	__stack:set	0
0000E2DA =00000000                M 	__sp:	set 0
0000E2DA                          M 	while	(__pos)
0000E2DA =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2DA =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2DA =0000000B                M 	__midpos:	= __endpos
0000E2DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2DA =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2DA =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	__operand:	substr __pos+1+1,__midpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	pushp	"move.l (a6)+,-(sp)"
0000E2DA =00000001                M 	__stack:	= __stack+1
0000E2DA =00000004                M 	__sp:	= __sp+4
0000E2DA =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2DA =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2DA =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2DA =00000032                M 	__midpos:	= __endpos
0000E2DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2DA =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2DA                          M 	rept	__stack
0000E2DA                          M 	popp	__command
0000E2DA 2F1E                     M 	move.l	(a6)+,-(sp)
0000E2DC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2E0 45EF 0010                M 	lea	4*4(sp),a2
0000E2E4 43FA 0000                M 	lea	.str_502(pc),a1
0000E2E8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E2EE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2F2 584F                     M 	addq.w	#__sp,sp
0000E2F4 46DF                     M 	move.w	(sp)+,sr
0000E2F6 6000 0000                M 	bra.w	.instr_end_502
0000E2FA                          M 	.str_502:
0000E2FA                          M 	__fstring_generatedecodedstring	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FA =00000001                M 	__lpos:	set 1
0000E2FA =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2FA                          M 	while	(__pos)
0000E2FA                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FA 2020 20                  M 	dc.b	"   "
0000E2FD =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2FD =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2FD =0000000B                M 	__midpos:	= __endpos
0000E2FD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FD                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FD E8                       M 	dc.b	fpal0
0000E2FE =0000000C                M 	__lpos:	set __endpos+1
0000E2FE =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2FE                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FE                          M 	dc.b	""
0000E2FE =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2FE =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FE                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FE BB                       M 	dc.b	sym|fsplit|3
0000E2FF =00000022                M 	__lpos:	set __endpos+1
0000E2FF =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E2FF                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FF                          M 	dc.b	""
0000E2FF =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E2FF =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E2FF =00000032                M 	__midpos:	= __endpos
0000E2FF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FF                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E2FF ECC0                     M 	dc.b	fpal2,fsymdisp
0000E301 =00000033                M 	__lpos:	set __endpos+1
0000E301 =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E301                          M 	__substr:	substr __lpos,,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E301                          M 	dc.b	""
0000E301 00                       M 	dc.b	0
0000E302                          M 	even
0000E302                          M 	.instr_end_502:
0000E302 5346                       		subq.w	#1,d6		; sub a line
0000E304 6ACE                       		bpl.s	AMPS_DebugR_ChkTracker_Ch_loop; if we havent drawn all, branch
0000E306                            
0000E306                            AMPS_Debug_Write
0000E306                            	Console.BreakLine
0000E306 40E7                     M 	move.w	sr,-(sp)
0000E308 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000E30E 46DF                     M 	move.w	(sp)+,sr
0000E310 5346                       		subq.w	#1,d6		; sub a line
0000E312                            AMPS_Debug_Write_n
0000E312 DAC5                       		add.w	d5,a5		; go to next ch
0000E314 4E75                       		rts
0000E316                            
0000E316                            AMPS_DebugR_ChkTracker2:
0000E316 7C27                       		moveq	#40-1,d6
0000E318 7A2C                       		moveq	#cSize,d5
0000E31A 4BF8 C4C4                  		lea	mDAC1.w,a5
0000E31E                            
0000E31E                            
0000E31E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac1(pc),a0
0000E322 4EBA FE98                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E326 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac2(pc),a0
0000E32A 4EBA FE90                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E32E                            
0000E32E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm1(pc),a0
0000E332 4EBA FE88                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E336 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm2(pc),a0
0000E33A 4EBA FE80                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E33E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm3(pc),a0
0000E342 4EBA FE78                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E346 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm4(pc),a0
0000E34A 4EBA FE70                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E34E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm5(pc),a0
0000E352 4EBA FE68                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E356                            
0000E356 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg1(pc),a0
0000E35A 4EBA FE60                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E35E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg2(pc),a0
0000E362 4EBA FE58                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E366 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg3(pc),a0
0000E36A 4EFA FE50                  		jmp	AMPS_DebugR_ChkTracker_Ch(pc)
0000E36E                            
0000E36E                            AMPS_DebugR_ChkTracker2_dac1
0000E36E                            	Console.Write " %<fpal0>DAC1"
0000E36E 40E7                     M 	move.w	sr,-(sp)
0000E370                          M 	__fstring_generateargumentscode	" %<fpal0>DAC1"
0000E370 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E370 =00000000                M 	__stack:set	0
0000E370 =00000000                M 	__sp:	set 0
0000E370                          M 	while	(__pos)
0000E370 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E370 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E370 =00000009                M 	__midpos:	= __endpos
0000E370                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E370                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E370 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E370                          M 	rept	__stack
0000E370 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E374 43FA 0000                M 	lea	.str_506(pc),a1
0000E378 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E37E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E382 46DF                     M 	move.w	(sp)+,sr
0000E384 6000 0000                M 	bra.w	.instr_end_506
0000E388                          M 	.str_506:
0000E388                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC1"
0000E388 =00000001                M 	__lpos:	set 1
0000E388 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E388                          M 	while	(__pos)
0000E388                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC1"
0000E388 20                       M 	dc.b	" "
0000E389 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E389 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E389 =00000009                M 	__midpos:	= __endpos
0000E389                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E389                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E389 E8                       M 	dc.b	fpal0
0000E38A =0000000A                M 	__lpos:	set __endpos+1
0000E38A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E38A                          M 	__substr:	substr __lpos,," %<fpal0>DAC1"
0000E38A 4441 4331                M 	dc.b	"DAC1"
0000E38E 00                       M 	dc.b	0
0000E390 00                       M 	even
0000E390                          M 	.instr_end_506:
0000E390 4E75                       		rts
0000E392                            
0000E392                            AMPS_DebugR_ChkTracker2_dac2
0000E392                            	Console.Write " %<fpal0>DAC2"
0000E392 40E7                     M 	move.w	sr,-(sp)
0000E394                          M 	__fstring_generateargumentscode	" %<fpal0>DAC2"
0000E394 =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E394 =00000000                M 	__stack:set	0
0000E394 =00000000                M 	__sp:	set 0
0000E394                          M 	while	(__pos)
0000E394 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E394 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E394 =00000009                M 	__midpos:	= __endpos
0000E394                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E394                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E394 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E394                          M 	rept	__stack
0000E394 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E398 43FA 0000                M 	lea	.str_509(pc),a1
0000E39C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3A2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3A6 46DF                     M 	move.w	(sp)+,sr
0000E3A8 6000 0000                M 	bra.w	.instr_end_509
0000E3AC                          M 	.str_509:
0000E3AC                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC2"
0000E3AC =00000001                M 	__lpos:	set 1
0000E3AC =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E3AC                          M 	while	(__pos)
0000E3AC                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC2"
0000E3AC 20                       M 	dc.b	" "
0000E3AD =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E3AD =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E3AD =00000009                M 	__midpos:	= __endpos
0000E3AD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E3AD                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E3AD E8                       M 	dc.b	fpal0
0000E3AE =0000000A                M 	__lpos:	set __endpos+1
0000E3AE =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E3AE                          M 	__substr:	substr __lpos,," %<fpal0>DAC2"
0000E3AE 4441 4332                M 	dc.b	"DAC2"
0000E3B2 00                       M 	dc.b	0
0000E3B4 00                       M 	even
0000E3B4                          M 	.instr_end_509:
0000E3B4 4E75                       		rts
0000E3B6                            
0000E3B6                            AMPS_DebugR_ChkTracker2_fm1
0000E3B6                            	Console.Write " %<fpal0> FM1"
0000E3B6 40E7                     M 	move.w	sr,-(sp)
0000E3B8                          M 	__fstring_generateargumentscode	" %<fpal0> FM1"
0000E3B8 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E3B8 =00000000                M 	__stack:set	0
0000E3B8 =00000000                M 	__sp:	set 0
0000E3B8                          M 	while	(__pos)
0000E3B8 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E3B8 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E3B8 =00000009                M 	__midpos:	= __endpos
0000E3B8                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E3B8                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E3B8 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E3B8                          M 	rept	__stack
0000E3B8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3BC 43FA 0000                M 	lea	.str_512(pc),a1
0000E3C0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3C6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3CA 46DF                     M 	move.w	(sp)+,sr
0000E3CC 6000 0000                M 	bra.w	.instr_end_512
0000E3D0                          M 	.str_512:
0000E3D0                          M 	__fstring_generatedecodedstring	" %<fpal0> FM1"
0000E3D0 =00000001                M 	__lpos:	set 1
0000E3D0 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E3D0                          M 	while	(__pos)
0000E3D0                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM1"
0000E3D0 20                       M 	dc.b	" "
0000E3D1 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E3D1 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E3D1 =00000009                M 	__midpos:	= __endpos
0000E3D1                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E3D1                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E3D1 E8                       M 	dc.b	fpal0
0000E3D2 =0000000A                M 	__lpos:	set __endpos+1
0000E3D2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E3D2                          M 	__substr:	substr __lpos,," %<fpal0> FM1"
0000E3D2 2046 4D31                M 	dc.b	" FM1"
0000E3D6 00                       M 	dc.b	0
0000E3D8 00                       M 	even
0000E3D8                          M 	.instr_end_512:
0000E3D8 4E75                       		rts
0000E3DA                            
0000E3DA                            AMPS_DebugR_ChkTracker2_fm2
0000E3DA                            	Console.Write " %<fpal0> FM2"
0000E3DA 40E7                     M 	move.w	sr,-(sp)
0000E3DC                          M 	__fstring_generateargumentscode	" %<fpal0> FM2"
0000E3DC =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E3DC =00000000                M 	__stack:set	0
0000E3DC =00000000                M 	__sp:	set 0
0000E3DC                          M 	while	(__pos)
0000E3DC =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E3DC =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E3DC =00000009                M 	__midpos:	= __endpos
0000E3DC                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E3DC                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E3DC =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E3DC                          M 	rept	__stack
0000E3DC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3E0 43FA 0000                M 	lea	.str_515(pc),a1
0000E3E4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3EA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3EE 46DF                     M 	move.w	(sp)+,sr
0000E3F0 6000 0000                M 	bra.w	.instr_end_515
0000E3F4                          M 	.str_515:
0000E3F4                          M 	__fstring_generatedecodedstring	" %<fpal0> FM2"
0000E3F4 =00000001                M 	__lpos:	set 1
0000E3F4 =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E3F4                          M 	while	(__pos)
0000E3F4                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM2"
0000E3F4 20                       M 	dc.b	" "
0000E3F5 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E3F5 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E3F5 =00000009                M 	__midpos:	= __endpos
0000E3F5                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E3F5                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E3F5 E8                       M 	dc.b	fpal0
0000E3F6 =0000000A                M 	__lpos:	set __endpos+1
0000E3F6 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E3F6                          M 	__substr:	substr __lpos,," %<fpal0> FM2"
0000E3F6 2046 4D32                M 	dc.b	" FM2"
0000E3FA 00                       M 	dc.b	0
0000E3FC 00                       M 	even
0000E3FC                          M 	.instr_end_515:
0000E3FC 4E75                       		rts
0000E3FE                            
0000E3FE                            AMPS_DebugR_ChkTracker2_fm3
0000E3FE                            	Console.Write " %<fpal0> FM3"
0000E3FE 40E7                     M 	move.w	sr,-(sp)
0000E400                          M 	__fstring_generateargumentscode	" %<fpal0> FM3"
0000E400 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E400 =00000000                M 	__stack:set	0
0000E400 =00000000                M 	__sp:	set 0
0000E400                          M 	while	(__pos)
0000E400 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E400 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E400 =00000009                M 	__midpos:	= __endpos
0000E400                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E400                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E400 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E400                          M 	rept	__stack
0000E400 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E404 43FA 0000                M 	lea	.str_518(pc),a1
0000E408 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E40E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E412 46DF                     M 	move.w	(sp)+,sr
0000E414 6000 0000                M 	bra.w	.instr_end_518
0000E418                          M 	.str_518:
0000E418                          M 	__fstring_generatedecodedstring	" %<fpal0> FM3"
0000E418 =00000001                M 	__lpos:	set 1
0000E418 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E418                          M 	while	(__pos)
0000E418                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM3"
0000E418 20                       M 	dc.b	" "
0000E419 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E419 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E419 =00000009                M 	__midpos:	= __endpos
0000E419                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E419                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E419 E8                       M 	dc.b	fpal0
0000E41A =0000000A                M 	__lpos:	set __endpos+1
0000E41A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E41A                          M 	__substr:	substr __lpos,," %<fpal0> FM3"
0000E41A 2046 4D33                M 	dc.b	" FM3"
0000E41E 00                       M 	dc.b	0
0000E420 00                       M 	even
0000E420                          M 	.instr_end_518:
0000E420 4E75                       		rts
0000E422                            
0000E422                            AMPS_DebugR_ChkTracker2_fm4
0000E422                            	Console.Write " %<fpal0> FM4"
0000E422 40E7                     M 	move.w	sr,-(sp)
0000E424                          M 	__fstring_generateargumentscode	" %<fpal0> FM4"
0000E424 =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E424 =00000000                M 	__stack:set	0
0000E424 =00000000                M 	__sp:	set 0
0000E424                          M 	while	(__pos)
0000E424 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E424 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E424 =00000009                M 	__midpos:	= __endpos
0000E424                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E424                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E424 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E424                          M 	rept	__stack
0000E424 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E428 43FA 0000                M 	lea	.str_521(pc),a1
0000E42C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E432 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E436 46DF                     M 	move.w	(sp)+,sr
0000E438 6000 0000                M 	bra.w	.instr_end_521
0000E43C                          M 	.str_521:
0000E43C                          M 	__fstring_generatedecodedstring	" %<fpal0> FM4"
0000E43C =00000001                M 	__lpos:	set 1
0000E43C =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E43C                          M 	while	(__pos)
0000E43C                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM4"
0000E43C 20                       M 	dc.b	" "
0000E43D =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E43D =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E43D =00000009                M 	__midpos:	= __endpos
0000E43D                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E43D                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E43D E8                       M 	dc.b	fpal0
0000E43E =0000000A                M 	__lpos:	set __endpos+1
0000E43E =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E43E                          M 	__substr:	substr __lpos,," %<fpal0> FM4"
0000E43E 2046 4D34                M 	dc.b	" FM4"
0000E442 00                       M 	dc.b	0
0000E444 00                       M 	even
0000E444                          M 	.instr_end_521:
0000E444 4E75                       		rts
0000E446                            
0000E446                            AMPS_DebugR_ChkTracker2_fm5
0000E446                            	Console.Write " %<fpal0> FM5"
0000E446 40E7                     M 	move.w	sr,-(sp)
0000E448                          M 	__fstring_generateargumentscode	" %<fpal0> FM5"
0000E448 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E448 =00000000                M 	__stack:set	0
0000E448 =00000000                M 	__sp:	set 0
0000E448                          M 	while	(__pos)
0000E448 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E448 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E448 =00000009                M 	__midpos:	= __endpos
0000E448                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E448                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E448 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E448                          M 	rept	__stack
0000E448 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E44C 43FA 0000                M 	lea	.str_524(pc),a1
0000E450 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E456 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E45A 46DF                     M 	move.w	(sp)+,sr
0000E45C 6000 0000                M 	bra.w	.instr_end_524
0000E460                          M 	.str_524:
0000E460                          M 	__fstring_generatedecodedstring	" %<fpal0> FM5"
0000E460 =00000001                M 	__lpos:	set 1
0000E460 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E460                          M 	while	(__pos)
0000E460                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM5"
0000E460 20                       M 	dc.b	" "
0000E461 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E461 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E461 =00000009                M 	__midpos:	= __endpos
0000E461                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E461                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E461 E8                       M 	dc.b	fpal0
0000E462 =0000000A                M 	__lpos:	set __endpos+1
0000E462 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E462                          M 	__substr:	substr __lpos,," %<fpal0> FM5"
0000E462 2046 4D35                M 	dc.b	" FM5"
0000E466 00                       M 	dc.b	0
0000E468 00                       M 	even
0000E468                          M 	.instr_end_524:
0000E468 4E75                       		rts
0000E46A                            
0000E46A                            AMPS_DebugR_ChkTracker2_psg1
0000E46A                            	Console.Write " %<fpal0>PSG1"
0000E46A 40E7                     M 	move.w	sr,-(sp)
0000E46C                          M 	__fstring_generateargumentscode	" %<fpal0>PSG1"
0000E46C =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E46C =00000000                M 	__stack:set	0
0000E46C =00000000                M 	__sp:	set 0
0000E46C                          M 	while	(__pos)
0000E46C =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E46C =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E46C =00000009                M 	__midpos:	= __endpos
0000E46C                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E46C                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E46C =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E46C                          M 	rept	__stack
0000E46C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E470 43FA 0000                M 	lea	.str_527(pc),a1
0000E474 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E47A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E47E 46DF                     M 	move.w	(sp)+,sr
0000E480 6000 0000                M 	bra.w	.instr_end_527
0000E484                          M 	.str_527:
0000E484                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG1"
0000E484 =00000001                M 	__lpos:	set 1
0000E484 =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E484                          M 	while	(__pos)
0000E484                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG1"
0000E484 20                       M 	dc.b	" "
0000E485 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E485 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E485 =00000009                M 	__midpos:	= __endpos
0000E485                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E485                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E485 E8                       M 	dc.b	fpal0
0000E486 =0000000A                M 	__lpos:	set __endpos+1
0000E486 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E486                          M 	__substr:	substr __lpos,," %<fpal0>PSG1"
0000E486 5053 4731                M 	dc.b	"PSG1"
0000E48A 00                       M 	dc.b	0
0000E48C 00                       M 	even
0000E48C                          M 	.instr_end_527:
0000E48C 4E75                       		rts
0000E48E                            
0000E48E                            AMPS_DebugR_ChkTracker2_psg2
0000E48E                            	Console.Write " %<fpal0>PSG2"
0000E48E 40E7                     M 	move.w	sr,-(sp)
0000E490                          M 	__fstring_generateargumentscode	" %<fpal0>PSG2"
0000E490 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E490 =00000000                M 	__stack:set	0
0000E490 =00000000                M 	__sp:	set 0
0000E490                          M 	while	(__pos)
0000E490 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E490 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E490 =00000009                M 	__midpos:	= __endpos
0000E490                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E490                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E490 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E490                          M 	rept	__stack
0000E490 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E494 43FA 0000                M 	lea	.str_530(pc),a1
0000E498 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E49E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E4A2 46DF                     M 	move.w	(sp)+,sr
0000E4A4 6000 0000                M 	bra.w	.instr_end_530
0000E4A8                          M 	.str_530:
0000E4A8                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG2"
0000E4A8 =00000001                M 	__lpos:	set 1
0000E4A8 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E4A8                          M 	while	(__pos)
0000E4A8                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG2"
0000E4A8 20                       M 	dc.b	" "
0000E4A9 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E4A9 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E4A9 =00000009                M 	__midpos:	= __endpos
0000E4A9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E4A9                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E4A9 E8                       M 	dc.b	fpal0
0000E4AA =0000000A                M 	__lpos:	set __endpos+1
0000E4AA =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E4AA                          M 	__substr:	substr __lpos,," %<fpal0>PSG2"
0000E4AA 5053 4732                M 	dc.b	"PSG2"
0000E4AE 00                       M 	dc.b	0
0000E4B0 00                       M 	even
0000E4B0                          M 	.instr_end_530:
0000E4B0 4E75                       		rts
0000E4B2                            
0000E4B2                            AMPS_DebugR_ChkTracker2_psg3
0000E4B2                            	Console.Write " %<fpal0>PSG3"
0000E4B2 40E7                     M 	move.w	sr,-(sp)
0000E4B4                          M 	__fstring_generateargumentscode	" %<fpal0>PSG3"
0000E4B4 =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E4B4 =00000000                M 	__stack:set	0
0000E4B4 =00000000                M 	__sp:	set 0
0000E4B4                          M 	while	(__pos)
0000E4B4 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E4B4 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E4B4 =00000009                M 	__midpos:	= __endpos
0000E4B4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E4B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E4B4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E4B4                          M 	rept	__stack
0000E4B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E4B8 43FA 0000                M 	lea	.str_533(pc),a1
0000E4BC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E4C2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E4C6 46DF                     M 	move.w	(sp)+,sr
0000E4C8 6000 0000                M 	bra.w	.instr_end_533
0000E4CC                          M 	.str_533:
0000E4CC                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG3"
0000E4CC =00000001                M 	__lpos:	set 1
0000E4CC =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E4CC                          M 	while	(__pos)
0000E4CC                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG3"
0000E4CC 20                       M 	dc.b	" "
0000E4CD =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E4CD =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E4CD =00000009                M 	__midpos:	= __endpos
0000E4CD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E4CD                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E4CD E8                       M 	dc.b	fpal0
0000E4CE =0000000A                M 	__lpos:	set __endpos+1
0000E4CE =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E4CE                          M 	__substr:	substr __lpos,," %<fpal0>PSG3"
0000E4CE 5053 4733                M 	dc.b	"PSG3"
0000E4D2 00                       M 	dc.b	0
0000E4D4 00                       M 	even
0000E4D4                          M 	.instr_end_533:
0000E4D4 4E75                       		rts
0000E4D6                            ; ===========================================================================
0000E4D6                            ; ---------------------------------------------------------------------------
0000E4D6                            ; Routine for loading the Dual PCM driver into Z80 RAM
0000E4D6                            ; ---------------------------------------------------------------------------
0000E4D6                            
0000E4D6                            LoadDualPCM:
0000E4D6 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0000E4DE 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E4E6                            
0000E4E6 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0000E4EC 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0000E4F2 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0000E4F6                            
0000E4F6                            .z80
0000E4F6 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0000E4FE 66F6                       		bne.s	.z80			; if not, wait more
0000E500                            
0000E500                            .load
0000E500 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0000E502 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0000E506                            
0000E506 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0000E50A 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0000E510                            
0000E510                            	rept 6
0000E510                            		move.b	(a0)+,(a1)+		; copy all required data
0000E510                            	endr
0000E510 12D8                     M 	move.b	(a0)+,(a1)+
0000E512 12D8                     M 	move.b	(a0)+,(a1)+
0000E514 12D8                     M 	move.b	(a0)+,(a1)+
0000E516 12D8                     M 	move.b	(a0)+,(a1)+
0000E518 12D8                     M 	move.b	(a0)+,(a1)+
0000E51A 12D8                     M 	move.b	(a0)+,(a1)+
0000E51C                            
0000E51C 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0000E51E 0838 0006 C746             		btst	#6,hwVersion.w	; is this a PAL Mega Drive?
0000E524 6700                       		beq.s	.ntsc			; if not, branch
0000E526 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0000E528                            .ntsc
0000E528 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0000E52E                            
0000E52E 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0000E536 727F                       		moveq	#$7F,d1			; wait for a little bit
0000E538 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0000E53C                            
0000E53C 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0000E544 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E54C 4E75                       		rts
0000E54E                            ; ---------------------------------------------------------------------------
0000E54E                            ; Play DAC
0000E54E                            ; ---------------------------------------------------------------------------
0000E54E                            
0000E54E                            PlayDAC2:
0000E54E 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E554                            	StopZ80					; wait for Z80 to stop
0000E554 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E55C                          M 	waitz80stop
0000E55C 0839 0000 00A1 1100      M .wait_537:	btst	#0,z80_bus_req
0000E564 66F6                     M 	bne.s	.wait_537
0000E566                            	rept 12
0000E566                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E566                            	endr
0000E566 12DB                     M 	move.b	(a3)+,(a1)+
0000E568 12DB                     M 	move.b	(a3)+,(a1)+
0000E56A 12DB                     M 	move.b	(a3)+,(a1)+
0000E56C 12DB                     M 	move.b	(a3)+,(a1)+
0000E56E 12DB                     M 	move.b	(a3)+,(a1)+
0000E570 12DB                     M 	move.b	(a3)+,(a1)+
0000E572 12DB                     M 	move.b	(a3)+,(a1)+
0000E574 12DB                     M 	move.b	(a3)+,(a1)+
0000E576 12DB                     M 	move.b	(a3)+,(a1)+
0000E578 12DB                     M 	move.b	(a3)+,(a1)+
0000E57A 12DB                     M 	move.b	(a3)+,(a1)+
0000E57C 12DB                     M 	move.b	(a3)+,(a1)+
0000E57E 101B                       		move.b	(a3)+,d0
0000E580 5200                       		addq.b	#1,d0
0000E582 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0000E588 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0000E58E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E596                            
0000E596 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000E59E                            	StartZ80				; enable Z80 execution
0000E59E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E5A6 4E75                       		rts
0000E5A8                            
0000E5A8                            ; ---------------------------------------------------------------------------
0000E5A8                            
0000E5A8                            PlayDAC1:
0000E5A8 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0000E5AE                            	StopZ80					; wait for Z80 to stop
0000E5AE 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E5B6                          M 	waitz80stop
0000E5B6 0839 0000 00A1 1100      M .wait_540:	btst	#0,z80_bus_req
0000E5BE 66F6                     M 	bne.s	.wait_540
0000E5C0                            	rept 12
0000E5C0                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E5C0                            	endr
0000E5C0 12DB                     M 	move.b	(a3)+,(a1)+
0000E5C2 12DB                     M 	move.b	(a3)+,(a1)+
0000E5C4 12DB                     M 	move.b	(a3)+,(a1)+
0000E5C6 12DB                     M 	move.b	(a3)+,(a1)+
0000E5C8 12DB                     M 	move.b	(a3)+,(a1)+
0000E5CA 12DB                     M 	move.b	(a3)+,(a1)+
0000E5CC 12DB                     M 	move.b	(a3)+,(a1)+
0000E5CE 12DB                     M 	move.b	(a3)+,(a1)+
0000E5D0 12DB                     M 	move.b	(a3)+,(a1)+
0000E5D2 12DB                     M 	move.b	(a3)+,(a1)+
0000E5D4 12DB                     M 	move.b	(a3)+,(a1)+
0000E5D6 12DB                     M 	move.b	(a3)+,(a1)+
0000E5D8 101B                       		move.b	(a3)+,d0
0000E5DA 5200                       		addq.b	#1,d0
0000E5DC 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0000E5E2 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0000E5E8 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E5F0                            
0000E5F0 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000E5F8                            	StartZ80				; enable Z80 execution
0000E5F8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E600 4E75                       		rts
0000E602                            ; ===========================================================================
0000E602                            ; ---------------------------------------------------------------------------
0000E602                            ; Handle Dual PCM YM Cue correctly
0000E602                            ; ---------------------------------------------------------------------------
0000E602                            
0000E602                            UpdateAMPS:
0000E602                            	StopZ80					; wait for Z80 to stop
0000E602 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E60A                          M 	waitz80stop
0000E60A 0839 0000 00A1 1100      M .wait_543:	btst	#0,z80_bus_req
0000E612 66F6                     M 	bne.s	.wait_543
0000E614 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0000E61A                            	StartZ80				; enable Z80 execution
0000E61A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E622                            
0000E622 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0000E628 4A00                       		tst.b	d0			; check buffer to use
0000E62A 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0000E62C D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0000E630                            
0000E630                            .gotbuffer
0000E630 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0000E632                            		AMPS_Debug_CuePtr 3		; check if the cue is still valid
0000E632 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000E638 6500                     M 	blo.s	.fail_545
0000E63A B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000E640 6500                     M 	blo.s	.ok_545
0000E642                          M .fail_545
0000E642 4EBA FAB8                M 	jsr	amps_debug_cueptr3
0000E646                          M .ok_545
0000E646                            
0000E646                            	StopZ80					; wait for Z80 to stop
0000E646 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E64E                          M 	waitz80stop
0000E64E 0839 0000 00A1 1100      M .wait_547:	btst	#0,z80_bus_req
0000E656 66F6                     M 	bne.s	.wait_547
0000E658 50D0                       		st	(a0)			; make sure cue is marked as completed
0000E65A                            	StartZ80				; enable Z80 execution
0000E65A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E662                            
0000E662                            dPaused:
0000E662 4E75                       		rts
0000E664                            ; ===========================================================================
0000E664                            ; ---------------------------------------------------------------------------
0000E664                            ; Main routine for updating the AMPS driver
0000E664                            ; ---------------------------------------------------------------------------
0000E664                            
0000E664                            dUpdateAllAMPS:
0000E664 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0000E668 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0000E66C 6BF4                       		bmi.s	dPaused			; if yes, branch
0000E66E                            ; ---------------------------------------------------------------------------
0000E66E                            ; This is the new fading feature I created, to make custom fading
0000E66E                            ; types easier to program. You can define series of 3 bytes, each
0000E66E                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0000E66E                            ; once per frame. If the first value in a frame is a command flag,
0000E66E                            ; instead its code is executed. Additionally, no fade program may
0000E66E                            ; appear before ROM offset $10000, or else it will never be executed.
0000E66E                            ; ---------------------------------------------------------------------------
0000E66E                            
0000E66E 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000E672 6700 0000                  		beq.w	.chkregion		; branch if not
0000E676                            
0000E676 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0000E67A 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0000E67E                            
0000E67E 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0000E680 7000                       		moveq	#0,d0
0000E682 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0000E684 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0000E686                            
0000E686                            		AMPS_Debug_FadeCmd		; check if this command is valid
0000E686 0C00 0090                M 	cmp.b	#flast,d0
0000E68A 6400                     M 	bhs.s	.fail
0000E68C 0C00 0080                M 	cmp.b	#$80,d0
0000E690 6500                     M 	blo.s	.fail
0000E692 0800 0001                M 	btst	#1,d0
0000E696 6600                     M 	bne.s	.fail
0000E698 0800 0000                M 	btst	#0,d0
0000E69C 6700                     M 	beq.s	.ok
0000E69E                          M .fail
0000E69E 4EBA F8B2                M 	jsr	amps_debugr_fadecmd
0000E6A2                          M .ok
0000E6A2 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0000E6A6 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0000E6AA 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0000E6AE 6000                       		bra.s	.chkregion		; go check the region
0000E6B0                            
0000E6B0                            .nofadeend
0000E6B0 B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0000E6B4 6700                       		beq.s	.fadedac		; if did not, branch
0000E6B6 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0000E6BA 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0000E6BE                            
0000E6BE                            .fadedac
0000E6BE 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0000E6C0 B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0000E6C4 6700                       		beq.s	.fadepsg		; if did not, branch
0000E6C6 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0000E6CA                            
0000E6CA =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000E6CA                            	rept Mus_DAC				; do for all music DAC channels
0000E6CA                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E6CA                            .ch =		.ch+cSize			; go to next channel
0000E6CA                            	endr
0000E6CA 8338 C4C4                M 	or.b	d1,.ch.w
0000E6CE =FFFFC4F0                M .ch	=	.ch+csize
0000E6CE 8338 C4F0                M 	or.b	d1,.ch.w
0000E6D2 =FFFFC51C                M .ch	=	.ch+csize
0000E6D2 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0000E6D6                            
0000E6D6                            .fadepsg
0000E6D6 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0000E6D8 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0000E6DC 6700                       		beq.s	.chkregion		; if did not, branch
0000E6DE 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0000E6E2                            
0000E6E2 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000E6E2                            	rept Mus_PSG				; do for all music PSG channels
0000E6E2                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E6E2                            .ch =		.ch+cSize			; go to next channel
0000E6E2                            	endr
0000E6E2 8338 C5F8                M 	or.b	d1,.ch.w
0000E6E6 =FFFFC624                M .ch	=	.ch+csize
0000E6E6 8338 C624                M 	or.b	d1,.ch.w
0000E6EA =FFFFC650                M .ch	=	.ch+csize
0000E6EA 8338 C650                M 	or.b	d1,.ch.w
0000E6EE =FFFFC67C                M .ch	=	.ch+csize
0000E6EE                            
0000E6EE =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000E6EE                            	rept SFX_PSG				; do for all SFX PSG channels
0000E6EE                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E6EE                            .ch =		.ch+cSizeSFX			; go to next channel
0000E6EE                            	endr
0000E6EE 8338 C6EC                M 	or.b	d1,.ch.w
0000E6F2 =FFFFC708                M .ch	=	.ch+csizesfx
0000E6F2 8338 C708                M 	or.b	d1,.ch.w
0000E6F6 =FFFFC724                M .ch	=	.ch+csizesfx
0000E6F6 8338 C724                M 	or.b	d1,.ch.w
0000E6FA =FFFFC740                M .ch	=	.ch+csizesfx
0000E6FA                            ; ---------------------------------------------------------------------------
0000E6FA                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0000E6FA                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0000E6FA                            ; on PAL systems. This will cause issues with some songs that rely on
0000E6FA                            ; game engine to seem "in sync". Because of that, I added a flag to
0000E6FA                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0000E6FA                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0000E6FA                            ; play at the exact right speed, instead of slightly too slow.
0000E6FA                            ; ---------------------------------------------------------------------------
0000E6FA                            
0000E6FA 0838 0006 C746             .chkregion	btst	#6,hwVersion.w	; is this PAL system?
0000E700 6700                       		beq.s	.driver			; if not, branch
0000E702 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0000E706 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0000E708                            
0000E708 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0000E70E 6600                       		bne.s	.nofix			; if yes, run music and SFX
0000E710 6100                       		bsr.s	.nosfx			; run the sound driver
0000E712                            
0000E712                            .nofix
0000E712 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0000E718                            .driver
0000E718 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0000E71C                            
0000E71C                            .nosfx		; continue to run sound driver again
0000E71C                            ; ---------------------------------------------------------------------------
0000E71C                            ; There are 2 methods of handling tempo adjustments in SMPS,
0000E71C                            ; overflow (where a value is added to the accumulator, and when it
0000E71C                            ; range overflows, tick of delay is added), and counter (where a
0000E71C                            ; counter is copied to the tempo, which is then decreased each frame,
0000E71C                            ; until it becomes 0, after which a tick of delay is added). AMPS
0000E71C                            ; supports these both too, because there is no single right answer,
0000E71C                            ; and users may prefer one over the other. The overflow method is
0000E71C                            ; really good for low values, as it provides very fine control over
0000E71C                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0000E71C                            ; method isn't as good for small values, but for large value it works
0000E71C                            ; better. You may choose this setting in the macro.asm file,
0000E71C                            ; ---------------------------------------------------------------------------
0000E71C                            
0000E71C 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0000E720 D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0000E724 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0000E726                            
0000E726                            
0000E726 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0000E726                            	rept Mus_Ch				; loop through all music channels
0000E726                            		addq.b	#1,.ch.w		; add 1 to duration
0000E726                            .ch =		.ch+cSize			; go to next channel
0000E726                            	endr
0000E726 5238 C4D0                M 	addq.b	#1,.ch.w
0000E72A =FFFFC4FC                M .ch	=	.ch+csize
0000E72A 5238 C4FC                M 	addq.b	#1,.ch.w
0000E72E =FFFFC528                M .ch	=	.ch+csize
0000E72E 5238 C528                M 	addq.b	#1,.ch.w
0000E732 =FFFFC554                M .ch	=	.ch+csize
0000E732 5238 C554                M 	addq.b	#1,.ch.w
0000E736 =FFFFC580                M .ch	=	.ch+csize
0000E736 5238 C580                M 	addq.b	#1,.ch.w
0000E73A =FFFFC5AC                M .ch	=	.ch+csize
0000E73A 5238 C5AC                M 	addq.b	#1,.ch.w
0000E73E =FFFFC5D8                M .ch	=	.ch+csize
0000E73E 5238 C5D8                M 	addq.b	#1,.ch.w
0000E742 =FFFFC604                M .ch	=	.ch+csize
0000E742 5238 C604                M 	addq.b	#1,.ch.w
0000E746 =FFFFC630                M .ch	=	.ch+csize
0000E746 5238 C630                M 	addq.b	#1,.ch.w
0000E74A =FFFFC65C                M .ch	=	.ch+csize
0000E74A 5238 C65C                M 	addq.b	#1,.ch.w
0000E74E =FFFFC688                M .ch	=	.ch+csize
0000E74E                            ; ===========================================================================
0000E74E                            ; ---------------------------------------------------------------------------
0000E74E                            ; Process music DAC channels
0000E74E                            ; ---------------------------------------------------------------------------
0000E74E                            
0000E74E                            dAMPSdoAll:
0000E74E 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E752 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0000E756 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0000E758                            
0000E758                            dAMPSdoDAC:
0000E758 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0000E75C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E75E 6A00 0000                  		bpl.w	.next			; if not, branch
0000E762 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E766 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E76A                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0000E76A                          M 	dnotetouthandler
0000E76A 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000E76E 6700                     M 	beq.s	.endt
0000E770 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000E774 6600                     M 	bne.s	.endt
0000E776 7000                     M 	moveq	#0,d0
0000E778 6000 0000                M 	bra.w	dnoteondac2
0000E77C                          M .endt
0000E77C                            
0000E77C                            	dCalcFreq				; calculate channel base frequency
0000E77C 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E780 4886                     M 	ext.w	d6
0000E782 DC6D 000E                M 	add.w	cfreq(a5),d6
0000E786                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0000E786 0815 0003                M 	btst	#cfbmod,(a5)
0000E78A 6700                     M 	beq.s	.noret
0000E78C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E790 6700                     M 	beq.s	.started
0000E792 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E796                          M .noret
0000E796 0895 0005                M 	bclr	#cfbvol,(a5)
0000E79A 6700                     M 	beq.s	.noupdatevol
0000E79C 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E7A0                          M 	.noupdatevol:
0000E7A0 51CF FFB6                M 	dbf	d7,dampsdodac
0000E7A4 6000 0000                M 	bra.w	dampsdofm
0000E7A8                          M .started
0000E7A8 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E7AC 66E8                     M 	bne.s	.noret
0000E7AE 226D 0010                M 	movea.l	cmod(a5),a1
0000E7B2 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E7B8 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E7BC 6600                     M 	bne.s	.norev
0000E7BE 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E7C4 442D 0017                M 	neg.b	cmodstep(a5)
0000E7C8                          M .norev
0000E7C8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E7CC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E7D0 4885                     M 	ext.w	d5
0000E7D2 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E7D6 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E7DA DC45                     M 	add.w	d5,d6
0000E7DC 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0000E7E0                            
0000E7E0 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E7E4 6700                       		beq.s	.next			; if not, skip
0000E7E6 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0000E7EA                            
0000E7EA                            .next
0000E7EA 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E7EE 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0000E7F2                            
0000E7F2                            .update
0000E7F2 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E7F6                            	dDoTracker				; process tracker
0000E7F6 286D 0002                M 	movea.l	cdata(a5),a4
0000E7FA                          M 	amps_debug_trackupd
0000E7FA 220C                     M 	move.l	a4,d1
0000E7FC 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E802 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E808 6500                     M 	blo.s	.fail2
0000E80A 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E810 6500                     M 	blo.s	.data
0000E812                          M .fail2
0000E812                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E812 487A FFFE                M 	pea	*(pc)
0000E816                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E816 40E7                     M 	move.w	sr,-(sp)
0000E818                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E818 =00000000                M 	__stack:set	0
0000E818 =00000000                M 	__sp:	set 0
0000E818                          M 	while	(__pos)
0000E818 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E818 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E818 =00000021                M 	__midpos:	= __endpos
0000E818                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	pushp	"move.l a4,-(sp)"
0000E818 =00000001                M 	__stack:	= __stack+1
0000E818 =00000004                M 	__sp:	= __sp+4
0000E818 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E818 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E818 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E818 =00000029                M 	__midpos:	= __endpos
0000E818                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E818 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E818 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E818                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E818                          M 	pushp	"move.l a4,-(sp)"
0000E818 =00000002                M 	__stack:	= __stack+1
0000E818 =00000008                M 	__sp:	= __sp+4
0000E818 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E818                          M 	rept	__stack
0000E818                          M 	popp	__command
0000E818 2F0C                     M 	move.l	a4,-(sp)
0000E81A                          M 	popp	__command
0000E81A 2F0C                     M 	move.l	a4,-(sp)
0000E81C 4EB9 0000 0000           M 	jsr	errorhandler
0000E822                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E822 =00000001                M 	__lpos:	set 1
0000E822 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E822                          M 	while	(__pos)
0000E822                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E822 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000E83B =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E83B =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E83B =00000021                M 	__midpos:	= __endpos
0000E83B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83B                          M 	__param:	substr ,,"hex"
0000E83B 83                       M 	dc.b	hex|3
0000E83C =00000022                M 	__lpos:	set __endpos+1
0000E83C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E83C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83C                          M 	dc.b	""
0000E83C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E83C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E83C =00000029                M 	__midpos:	= __endpos
0000E83C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83C E0                       M 	dc.b	fendl
0000E83D =0000002A                M 	__lpos:	set __endpos+1
0000E83D =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E83D                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83D                          M 	dc.b	""
0000E83D =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E83D =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E83D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83D B3                       M 	dc.b	sym|3
0000E83E =00000036                M 	__lpos:	set __endpos+1
0000E83E =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E83E                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E83E                          M 	dc.b	""
0000E83E 00                       M 	dc.b	0
0000E83F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E840                          M 	even
0000E840 4EFA EB0A                M 	jmp	amps_debug_console_channel
0000E844                          M 	even
0000E844                          M .data
0000E844 7A00                     M 	moveq	#0,d5
0000E846 1A1C                     M 	move.b	(a4)+,d5
0000E848 0C05 00E0                M 	cmpi.b	#$e0,d5
0000E84C 6500                     M 	blo.s	.notcomm
0000E84E 4EBA 0000                M 	jsr	dcommands(pc)
0000E852 60F0                     M 	bra.s	.data
0000E854 6094                     M 	bra.s	.next
0000E856                          M .notcomm
0000E856 7C00                       		moveq	#0,d6			; clear rest flag
0000E858 4A05                       		tst.b	d5			; check if note is being played
0000E85A 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000E85C                            
0000E85C                            	dTrackNoteDAC				; calculate frequency or update sample
0000E85C 0815 0000                M 	btst	#cfbmode,(a5)
0000E860 6600                     M 	bne.s	.pitch
0000E862 1B45 000B                M 	move.b	d5,csample(a5)
0000E866 6000                     M 	bra.s	.cont
0000E868                          M .pitch
0000E868 0405 0080                M 	subi.b	#$80,d5
0000E86C 6600                     M 	bne.s	.noprest
0000E86E 7000                     M 	moveq	#0,d0
0000E870 6100 0000                M 	bsr.w	dnoteondac2
0000E874 7C80                     M 	moveq	#-$80,d6
0000E876 6000                     M 	bra.s	.cont
0000E878                          M .noprest
0000E878 DA2D 0008                M 	add.b	cpitch(a5),d5
0000E87C DA45                     M 	add.w	d5,d5
0000E87E 43FA 0000                M 	lea	dfreqdac(pc),a1
0000E882 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000E888                          M .cont
0000E888 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000E88A 6A00                       		bpl.s	.timer			; if yes, handle timer
0000E88C 534C                       		subq.w	#1,a4			; else, undo the increment
0000E88E 6000                       		bra.s	.pcnote			; do not calculate duration
0000E890                            
0000E890                            .timer
0000E890 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0000E894                            .pcnote
0000E894                            	dProcNote 0, 0				; reset necessary channel memory
0000E894 2B4C 0002                M 	move.l	a4,cdata(a5)
0000E898 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000E89E 0815 0002                M 	btst	#cfbhold,(a5)
0000E8A2 6600                     M 	bne.s	.endpn
0000E8A4 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000E8AA 0815 0003                M 	btst	#cfbmod,(a5)
0000E8AE 6700                     M 	beq.s	.endpn
0000E8B0 226D 0010                M 	movea.l	cmod(a5),a1
0000E8B4 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000E8B8 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000E8BC 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000E8C0 1011                     M 	move.b	(a1),d0
0000E8C2 E208                     M 	lsr.b	#1,d0
0000E8C4 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000E8C8 426D 0014                M 	clr.w	cmodfreq(a5)
0000E8CC                          M .endpn
0000E8CC                            
0000E8CC 4A06                       		tst.b	d6			; check if channel was resting
0000E8CE 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000E8D0 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0000E8D2                            
0000E8D2 51CF FE84                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E8D6 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0000E8DA                            ; ===========================================================================
0000E8DA                            ; ---------------------------------------------------------------------------
0000E8DA                            ; Write DAC sample information to Dual PCM
0000E8DA                            ; ---------------------------------------------------------------------------
0000E8DA                            
0000E8DA                            dNoteOnDAC2:
0000E8DA 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E8DE 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0000E8E0 4E75                       		rts
0000E8E2                            
0000E8E2                            dNoteOnDAC:
0000E8E2 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E8E6 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0000E8E8                            
0000E8E8 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E8EA 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E8EE 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E8F2 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000E8F6 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0000E8FA                            
0000E8FA                            dNoteOnDAC3:
0000E8FA E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E8FC 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0000E900                            
0000E900 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0000E904 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000E90A 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0000E90C                            ; ---------------------------------------------------------------------------
0000E90C                            ; This code is for updating the note to Dual PCM. We have tracker commands
0000E90C                            ; for also playing notes on DAC channels, which is why the code seems a
0000E90C                            ; little weird.
0000E90C                            ; ---------------------------------------------------------------------------
0000E90C                            
0000E90C                            dNoteWriteDAC2:
0000E90C 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E912 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0000E918 6000                       		bra.s	dNoteOnDAC4
0000E91A                            
0000E91A                            dNoteWriteDAC1:
0000E91A                            
0000E91A 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0000E920 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0000E926                            
0000E926                            dNoteOnDAC4:
0000E926                            	StopZ80					; wait for Z80 to stop
0000E926 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E92E                          M 	waitz80stop
0000E92E 0839 0000 00A1 1100      M .wait_563:	btst	#0,z80_bus_req
0000E936 66F6                     M 	bne.s	.wait_563
0000E938                            	rept 12
0000E938                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E938                            	endr
0000E938 12DB                     M 	move.b	(a3)+,(a1)+
0000E93A 12DB                     M 	move.b	(a3)+,(a1)+
0000E93C 12DB                     M 	move.b	(a3)+,(a1)+
0000E93E 12DB                     M 	move.b	(a3)+,(a1)+
0000E940 12DB                     M 	move.b	(a3)+,(a1)+
0000E942 12DB                     M 	move.b	(a3)+,(a1)+
0000E944 12DB                     M 	move.b	(a3)+,(a1)+
0000E946 12DB                     M 	move.b	(a3)+,(a1)+
0000E948 12DB                     M 	move.b	(a3)+,(a1)+
0000E94A 12DB                     M 	move.b	(a3)+,(a1)+
0000E94C 12DB                     M 	move.b	(a3)+,(a1)+
0000E94E 12DB                     M 	move.b	(a3)+,(a1)+
0000E950                            
0000E950 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0000E954                            	StartZ80				; enable Z80 execution
0000E954 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E95C                            
0000E95C                            locret_dNoteOnDAC4:
0000E95C 4E75                       		rts
0000E95E                            ; ===========================================================================
0000E95E                            ; ---------------------------------------------------------------------------
0000E95E                            ; Write DAC frequency to Dual PCM
0000E95E                            ; ---------------------------------------------------------------------------
0000E95E                            
0000E95E                            dUpdateFreqOffDAC2:
0000E95E E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E960 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0000E964                            
0000E964                            dUpdateFreqOffDAC:
0000E964 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000E968 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0000E96A                            
0000E96A 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0000E96E 4880                       		ext.w	d0			; extend to word
0000E970 DC40                       		add.w	d0,d6			; add it to d6
0000E972                            
0000E972 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000E976 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0000E978 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0000E97C 6000                       		bra.s	dUpdateFreqDAC3
0000E97E                            
0000E97E                            dUpdateFreqDAC:
0000E97E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E982 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0000E984                            
0000E984                            dUpdateFreqDAC2:
0000E984 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E986 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E98A 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E98E E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0000E990 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0000E994                            
0000E994                            dUpdateFreqDAC3:
0000E994                            		AMPS_Debug_FreqDAC		; check if DAC frequency is in bounds
0000E994 0C46 1000                M 	cmp.w	#maxpitch,d6
0000E998 6E00                     M 	bgt.s	.fail
0000E99A 0C46 F000                M 	cmp.w	#-maxpitch,d6
0000E99E 6C00                     M 	bge.s	.ok
0000E9A0                          M .fail
0000E9A0 4EBA F664                M 	jsr	amps_debugr_freqdac
0000E9A4                          M .ok
0000E9A4                            
0000E9A4 1006                       		move.b	d6,d0			; copy the frequency to d0
0000E9A6 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0000E9A8 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0000E9AE 6700                       		beq.s	dFreqDAC1		; if is, branch
0000E9B0                            
0000E9B0                            	StopZ80					; wait for Z80 to stop
0000E9B0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E9B8                          M 	waitz80stop
0000E9B8 0839 0000 00A1 1100      M .wait_567:	btst	#0,z80_bus_req
0000E9C0 66F6                     M 	bne.s	.wait_567
0000E9C2 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0000E9C8 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0000E9CE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E9D6                            	StartZ80				; enable Z80 execution
0000E9D6 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E9DE                            
0000E9DE                            locret_UpdFreqDAC;
0000E9DE 4E75                       		rts
0000E9E0                            
0000E9E0                            dFreqDAC1:
0000E9E0                            	StopZ80					; wait for Z80 to stop
0000E9E0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E9E8                          M 	waitz80stop
0000E9E8 0839 0000 00A1 1100      M .wait_570:	btst	#0,z80_bus_req
0000E9F0 66F6                     M 	bne.s	.wait_570
0000E9F2 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0000E9F8 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0000E9FE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000EA06                            	StartZ80				; enable Z80 execution
0000EA06 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EA0E 4E75                       		rts
0000EA10                            ; ===========================================================================
0000EA10                            ; ---------------------------------------------------------------------------
0000EA10                            ; Routine to multiply duration by tick rate
0000EA10                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0000EA10                            ; around the loop will be faster than a single mulu instruction
0000EA10                            ; ---------------------------------------------------------------------------
0000EA10                            
0000EA10                            dCalcDuration:
0000EA10 7000                       		moveq	#0,d0			; clear duration
0000EA12 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0000EA14 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0000EA18                            
0000EA18 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0000EA1A 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0000EA1E                            
0000EA1E 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0000EA22 4E75                       		rts				; get copied to duration by later code
0000EA24                            ; ===========================================================================
0000EA24                            ; ---------------------------------------------------------------------------
0000EA24                            ; Process SFX DAC channels
0000EA24                            ; ---------------------------------------------------------------------------
0000EA24                            
0000EA24                            dAMPSdoSFX:
0000EA24 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0000EA28                            
0000EA28                            dAMPSdoDACSFX:
0000EA28 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000EA2C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000EA2E 6A00                       		bpl.s	.next			; if not, branch
0000EA30                            
0000EA30 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000EA34 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000EA38 6700 0000                  		beq.w	.update			; if timed out, update channel
0000EA3C                            
0000EA3C                            	dCalcFreq				; calculate channel base frequency
0000EA3C 1C2D 0007                M 	move.b	cdetune(a5),d6
0000EA40 4886                     M 	ext.w	d6
0000EA42 DC6D 000E                M 	add.w	cfreq(a5),d6
0000EA46                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0000EA46 0815 0003                M 	btst	#cfbmod,(a5)
0000EA4A 6700                     M 	beq.s	.noret
0000EA4C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000EA50 6700                     M 	beq.s	.started
0000EA52 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000EA56                          M .noret
0000EA56 0895 0005                M 	bclr	#cfbvol,(a5)
0000EA5A 6700                     M 	beq.s	.noupdatevol
0000EA5C 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000EA60                          M 	.noupdatevol:
0000EA60 6000 0000                M 	bra.w	dampsdofmsfx
0000EA64                          M .started
0000EA64 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000EA68 66EC                     M 	bne.s	.noret
0000EA6A 226D 0010                M 	movea.l	cmod(a5),a1
0000EA6E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000EA74 4A2D 0018                M 	tst.b	cmodcount(a5)
0000EA78 6600                     M 	bne.s	.norev
0000EA7A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000EA80 442D 0017                M 	neg.b	cmodstep(a5)
0000EA84                          M .norev
0000EA84 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000EA88 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000EA8C 4885                     M 	ext.w	d5
0000EA8E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000EA92 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000EA96 DC45                     M 	add.w	d5,d6
0000EA98 6100 FEEA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0000EA9C                            
0000EA9C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000EAA0 6700                       		beq.s	.next			; if not, skip
0000EAA2 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0000EAA6                            
0000EAA6                            .next
0000EAA6 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000EAAA                            
0000EAAA                            .update
0000EAAA 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000EAAE                            	dDoTracker				; process tracker
0000EAAE 286D 0002                M 	movea.l	cdata(a5),a4
0000EAB2                          M 	amps_debug_trackupd
0000EAB2 220C                     M 	move.l	a4,d1
0000EAB4 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000EABA 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000EAC0 6500                     M 	blo.s	.fail2
0000EAC2 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000EAC8 6500                     M 	blo.s	.data
0000EACA                          M .fail2
0000EACA                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000EACA 487A FFFE                M 	pea	*(pc)
0000EACE                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000EACE 40E7                     M 	move.w	sr,-(sp)
0000EAD0                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAD0 =00000000                M 	__stack:set	0
0000EAD0 =00000000                M 	__sp:	set 0
0000EAD0                          M 	while	(__pos)
0000EAD0 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAD0 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAD0 =00000021                M 	__midpos:	= __endpos
0000EAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	pushp	"move.l a4,-(sp)"
0000EAD0 =00000001                M 	__stack:	= __stack+1
0000EAD0 =00000004                M 	__sp:	= __sp+4
0000EAD0 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAD0 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAD0 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAD0 =00000029                M 	__midpos:	= __endpos
0000EAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAD0 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAD0 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAD0                          M 	pushp	"move.l a4,-(sp)"
0000EAD0 =00000002                M 	__stack:	= __stack+1
0000EAD0 =00000008                M 	__sp:	= __sp+4
0000EAD0 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAD0                          M 	rept	__stack
0000EAD0                          M 	popp	__command
0000EAD0 2F0C                     M 	move.l	a4,-(sp)
0000EAD2                          M 	popp	__command
0000EAD2 2F0C                     M 	move.l	a4,-(sp)
0000EAD4 4EB9 0000 0000           M 	jsr	errorhandler
0000EADA                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EADA =00000001                M 	__lpos:	set 1
0000EADA =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EADA                          M 	while	(__pos)
0000EADA                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EADA 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000EAF3 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAF3 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAF3 =00000021                M 	__midpos:	= __endpos
0000EAF3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF3                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF3                          M 	__param:	substr ,,"hex"
0000EAF3 83                       M 	dc.b	hex|3
0000EAF4 =00000022                M 	__lpos:	set __endpos+1
0000EAF4 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAF4                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF4                          M 	dc.b	""
0000EAF4 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAF4 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAF4 =00000029                M 	__midpos:	= __endpos
0000EAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF4 E0                       M 	dc.b	fendl
0000EAF5 =0000002A                M 	__lpos:	set __endpos+1
0000EAF5 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAF5                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF5                          M 	dc.b	""
0000EAF5 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EAF5 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EAF5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF5                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF5 B3                       M 	dc.b	sym|3
0000EAF6 =00000036                M 	__lpos:	set __endpos+1
0000EAF6 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EAF6                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EAF6                          M 	dc.b	""
0000EAF6 00                       M 	dc.b	0
0000EAF7 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EAF8                          M 	even
0000EAF8 4EFA E852                M 	jmp	amps_debug_console_channel
0000EAFC                          M 	even
0000EAFC                          M .data
0000EAFC 7A00                     M 	moveq	#0,d5
0000EAFE 1A1C                     M 	move.b	(a4)+,d5
0000EB00 0C05 00E0                M 	cmpi.b	#$e0,d5
0000EB04 6500                     M 	blo.s	.notcomm
0000EB06 4EBA 0000                M 	jsr	dcommands(pc)
0000EB0A 60F0                     M 	bra.s	.data
0000EB0C 6098                     M 	bra.s	.next
0000EB0E                          M .notcomm
0000EB0E 7C00                       		moveq	#0,d6			; clear rest flag
0000EB10 4A05                       		tst.b	d5			; check if note is being played
0000EB12 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000EB14                            
0000EB14                            	dTrackNoteDAC				; calculate frequency or update sample
0000EB14 0815 0000                M 	btst	#cfbmode,(a5)
0000EB18 6600                     M 	bne.s	.pitch
0000EB1A 1B45 000B                M 	move.b	d5,csample(a5)
0000EB1E 6000                     M 	bra.s	.cont
0000EB20                          M .pitch
0000EB20 0405 0080                M 	subi.b	#$80,d5
0000EB24 6600                     M 	bne.s	.noprest
0000EB26 7000                     M 	moveq	#0,d0
0000EB28 6100 FDB0                M 	bsr.w	dnoteondac2
0000EB2C 7C80                     M 	moveq	#-$80,d6
0000EB2E 6000                     M 	bra.s	.cont
0000EB30                          M .noprest
0000EB30 DA2D 0008                M 	add.b	cpitch(a5),d5
0000EB34 DA45                     M 	add.w	d5,d5
0000EB36 43FA 0000                M 	lea	dfreqdac(pc),a1
0000EB3A 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000EB40                          M .cont
0000EB40 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000EB42 6A00                       		bpl.s	.timer			; if yes, handle timer
0000EB44 534C                       		subq.w	#1,a4			; else, undo the increment
0000EB46 6000                       		bra.s	.pcnote			; do not calculate duration
0000EB48                            
0000EB48                            .timer
0000EB48 4EBA FEC6                  		jsr	dCalcDuration(pc)	; calculate duration
0000EB4C                            .pcnote
0000EB4C                            	dProcNote 1, 0				; reset necessary channel memory
0000EB4C 2B4C 0002                M 	move.l	a4,cdata(a5)
0000EB50 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000EB56 0815 0002                M 	btst	#cfbhold,(a5)
0000EB5A 6600                     M 	bne.s	.endpn
0000EB5C 0815 0003                M 	btst	#cfbmod,(a5)
0000EB60 6700                     M 	beq.s	.endpn
0000EB62 226D 0010                M 	movea.l	cmod(a5),a1
0000EB66 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000EB6A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000EB6E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000EB72 1011                     M 	move.b	(a1),d0
0000EB74 E208                     M 	lsr.b	#1,d0
0000EB76 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000EB7A 426D 0014                M 	clr.w	cmodfreq(a5)
0000EB7E                          M .endpn
0000EB7E 4A06                       		tst.b	d6			; check if channel was resting
0000EB80 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000EB82 6100 FD5E                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0000EB86                            
0000EB86                            .noplay
0000EB86 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000EB8A                            ; ===========================================================================
0000EB8A                            ; ---------------------------------------------------------------------------
0000EB8A                            ; Write DAC volume to Dual PCM
0000EB8A                            ; ---------------------------------------------------------------------------
0000EB8A                            
0000EB8A                            dUpdateVolDAC:
0000EB8A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EB8E 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0000EB90                            
0000EB90                            dUpdateVolDAC2:
0000EB90 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0000EB94 D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0000EB98 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0000EB9A 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0000EB9C                            
0000EB9C                            .gotvol
0000EB9C                            	StopZ80					; wait for Z80 to stop
0000EB9C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EBA4                          M 	waitz80stop
0000EBA4 0839 0000 00A1 1100      M .wait_583:	btst	#0,z80_bus_req
0000EBAC 66F6                     M 	bne.s	.wait_583
0000EBAE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0000EBB6                            
0000EBB6 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000EBBC 6700                       		beq.s	.dac1			; if is, branch
0000EBBE 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0000EBC4                            	StartZ80				; enable Z80 execution
0000EBC4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EBCC 4E75                       		rts
0000EBCE                            
0000EBCE                            .dac1
0000EBCE 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0000EBD4                            	StartZ80				; enable Z80 execution
0000EBD4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EBDC                            
0000EBDC                            locret_VolDAC:
0000EBDC 4E75                       		rts
0000EBDE                            ; ===========================================================================
0000EBDE                            ; ---------------------------------------------------------------------------
0000EBDE                            ; Routine for unpausing the sound driver
0000EBDE                            ; ---------------------------------------------------------------------------
0000EBDE                            
0000EBDE                            dPlaySnd_Unpause:
0000EBDE 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0000EBE4 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0000EBE6                            ; ---------------------------------------------------------------------------
0000EBE6                            ; The following code will reset the panning values for each running
0000EBE6                            ; channel. It also makes sure that the channel is not interrupted
0000EBE6                            ; by sound effects, and that each running sound effect channel gets
0000EBE6                            ; updated. We do not handle key on's, since that could potentially
0000EBE6                            ; cause issues if notes are half-done. The next time tracker plays
0000EBE6                            ; notes, they start being audible again.
0000EBE6                            ; ---------------------------------------------------------------------------
0000EBE6                            
0000EBE6 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EBEA 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0000EBEC 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0000EBEE                            
0000EBEE                            .musloop
0000EBEE 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EBF0 6A00                       		bpl.s	.skipmus		; if not, do not update
0000EBF2 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EBF6 6600                       		bne.s	.skipmus		; if is, do not update
0000EBF8                            
0000EBF8 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EBFA 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EBFE 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EC02                            
0000EC02                            .skipmus
0000EC02 DAC3                       		adda.w	d3,a5			; go to next channel
0000EC04 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0000EC08                            
0000EC08 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0000EC0C 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0000EC0E 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0000EC10                            
0000EC10                            .sfxloop
0000EC10 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EC12 6A00                       		bpl.s	.skipsfx		; if not, do not update
0000EC14                            
0000EC14 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EC16 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EC1A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EC1E                            
0000EC1E                            .skipsfx
0000EC1E DAC3                       		adda.w  d3,a5			; go to next channel
0000EC20 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0000EC24                            ; ---------------------------------------------------------------------------
0000EC24                            ; Since the DAC channels have or based panning behavior, we need this
0000EC24                            ; piece of code to update its panning
0000EC24                            ; ---------------------------------------------------------------------------
0000EC24                            
0000EC24 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0000EC28 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0000EC2E 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0000EC30 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0000EC34                            
0000EC34                            .nodacsfx
0000EC34 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0000EC38 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EC3A 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0000EC3E                            ; ===========================================================================
0000EC3E                            ; ---------------------------------------------------------------------------
0000EC3E                            ; Routine for pausing the sound driver
0000EC3E                            ; ---------------------------------------------------------------------------
0000EC3E                            
0000EC3E                            dPlaySnd_Pause:
0000EC3E 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0000EC44 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0000EC46                            ; ---------------------------------------------------------------------------
0000EC46                            ; The following code will set channel panning to none for all FM channels.
0000EC46                            ; This will ensure they are muted while we are pausing.
0000EC46                            ; ---------------------------------------------------------------------------
0000EC46                            
0000EC46 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0000EC48 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EC4A 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0000EC4C                            
0000EC4C                            .muteFM
0000EC4C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EC50 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EC54 5200                       		addq.b	#1,d0			; go to next FM channel
0000EC56 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0000EC5A                            ; ---------------------------------------------------------------------------
0000EC5A                            ; The following code will key off all FM channels. There is a special
0000EC5A                            ; behavior in that, we must write all channels into part 1, and we
0000EC5A                            ; control the channel we are writing in the data portion.
0000EC5A                            ; 4 bits are reserved for which operators are active (in this case,
0000EC5A                            ; none), and 3 bits are reserved for the channel we want to affect.
0000EC5A                            ; ---------------------------------------------------------------------------
0000EC5A                            
0000EC5A 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EC5C 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000EC5E                            
0000EC5E                            .note
0000EC5E 1203                       		move.b	d3,d1			; copy value into d1
0000EC60 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EC64 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000EC66 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EC6A 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0000EC6E                            
0000EC6E 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0000EC72                            	; continue to mute all DAC channels
0000EC72                            ; ===========================================================================
0000EC72                            ; ---------------------------------------------------------------------------
0000EC72                            ; Routine for muting all DAC channels
0000EC72                            ; ---------------------------------------------------------------------------
0000EC72                            
0000EC72                            dMuteDAC:
0000EC72                            	StopZ80					; wait for Z80 to stop
0000EC72 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EC7A                          M 	waitz80stop
0000EC7A 0839 0000 00A1 1100      M .wait_587:	btst	#0,z80_bus_req
0000EC82 66F6                     M 	bne.s	.wait_587
0000EC84 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000EC88 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0000EC8E                            
0000EC8E                            	rept 12
0000EC8E                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000EC8E                            	endr
0000EC8E 12DA                     M 	move.b	(a2)+,(a1)+
0000EC90 12DA                     M 	move.b	(a2)+,(a1)+
0000EC92 12DA                     M 	move.b	(a2)+,(a1)+
0000EC94 12DA                     M 	move.b	(a2)+,(a1)+
0000EC96 12DA                     M 	move.b	(a2)+,(a1)+
0000EC98 12DA                     M 	move.b	(a2)+,(a1)+
0000EC9A 12DA                     M 	move.b	(a2)+,(a1)+
0000EC9C 12DA                     M 	move.b	(a2)+,(a1)+
0000EC9E 12DA                     M 	move.b	(a2)+,(a1)+
0000ECA0 12DA                     M 	move.b	(a2)+,(a1)+
0000ECA2 12DA                     M 	move.b	(a2)+,(a1)+
0000ECA4 12DA                     M 	move.b	(a2)+,(a1)+
0000ECA6                            
0000ECA6 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000ECAE                            
0000ECAE 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000ECB2 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0000ECB8                            
0000ECB8                            	rept 12
0000ECB8                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000ECB8                            	endr
0000ECB8 12DA                     M 	move.b	(a2)+,(a1)+
0000ECBA 12DA                     M 	move.b	(a2)+,(a1)+
0000ECBC 12DA                     M 	move.b	(a2)+,(a1)+
0000ECBE 12DA                     M 	move.b	(a2)+,(a1)+
0000ECC0 12DA                     M 	move.b	(a2)+,(a1)+
0000ECC2 12DA                     M 	move.b	(a2)+,(a1)+
0000ECC4 12DA                     M 	move.b	(a2)+,(a1)+
0000ECC6 12DA                     M 	move.b	(a2)+,(a1)+
0000ECC8 12DA                     M 	move.b	(a2)+,(a1)+
0000ECCA 12DA                     M 	move.b	(a2)+,(a1)+
0000ECCC 12DA                     M 	move.b	(a2)+,(a1)+
0000ECCE 12DA                     M 	move.b	(a2)+,(a1)+
0000ECD0                            
0000ECD0 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000ECD8                            	StartZ80				; enable Z80 execution
0000ECD8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000ECE0                            
0000ECE0                            locret_MuteDAC:
0000ECE0 4E75                       		rts
0000ECE2                            ; ===========================================================================
0000ECE2                            ; ---------------------------------------------------------------------------
0000ECE2                            ; Subroutine to play any queued music tracks, sound effects or commands
0000ECE2                            ; ---------------------------------------------------------------------------
0000ECE2                            
0000ECE2                            dPlaySnd:
0000ECE2 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0000ECE6 7E00                       		moveq	#0,d7
0000ECE8 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000ECEA 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000ECEC 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000ECEE 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000ECF0 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000ECF2 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0000ECF4                            
0000ECF4                            .found
0000ECF4 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0000ECF8 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0000ECFC 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0000ED00 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0000ED04 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0000ED08                            	; it was music, handle it below
0000ED08                            ; ===========================================================================
0000ED08                            ; ---------------------------------------------------------------------------
0000ED08                            ; Subroutine to play a queued music track
0000ED08                            ; ---------------------------------------------------------------------------
0000ED08                            
0000ED08                            dPlaySnd_Music:
0000ED08 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0000ED0C 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0000ED10                            ; ---------------------------------------------------------------------------
0000ED10                            ; To save few cycles, we don't directly substract the music offset from
0000ED10                            ; the ID, and instead offset the table position. In practice this will
0000ED10                            ; have the same effect, but saves us 8 cycles overall.
0000ED10                            ; ---------------------------------------------------------------------------
0000ED10                            
0000ED10 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0000ED14 DE47                       		add.w	d7,d7			; quadruple music ID
0000ED16 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000ED18 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0000ED1E 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0000ED22                            
0000ED22 200C                       		move.l	a4,d0			; copy pointer to d0
0000ED24 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000ED2A 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000ED2C                            		AMPS_Debug_PlayTrackMus		; check if this was valid music
0000ED2C 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000ED32 6500                     M 	blo.s	.fail_589
0000ED34 0C80 0000 0000           M 	cmp.l	#musend,d0
0000ED3A 6500                     M 	blo.s	.ok_589
0000ED3C                          M .fail_589
0000ED3C E44F                     M 	lsr.w	#2,d7
0000ED3E                          M 	raiseerror	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000ED3E 487A FFFE                M 	pea	*(pc)
0000ED42                          M 	raiseerror2	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000ED42 40E7                     M 	move.w	sr,-(sp)
0000ED44                          M 	__fstring_generateargumentscode	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED44 =00000000                M 	__stack:set	0
0000ED44 =00000000                M 	__sp:	set 0
0000ED44                          M 	while	(__pos)
0000ED44 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED44 =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED44 =00000021                M 	__midpos:	= __endpos
0000ED44                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	pushp	"move.b d7,1(sp)"
0000ED44                          M 	pushp	"subq.w	#2, sp"
0000ED44 =00000002                M 	__stack:	= __stack+2
0000ED44 =00000002                M 	__sp:	= __sp+2
0000ED44 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED44 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED44 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED44 =0000002B                M 	__midpos:	= __endpos
0000ED44                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	pushp	"move.l a4,-(sp)"
0000ED44 =00000003                M 	__stack:	= __stack+1
0000ED44 =00000006                M 	__sp:	= __sp+4
0000ED44 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED44 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED44 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED44 =00000033                M 	__midpos:	= __endpos
0000ED44                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED44 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED44 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED44                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED44                          M 	pushp	"move.l a4,-(sp)"
0000ED44 =00000004                M 	__stack:	= __stack+1
0000ED44 =0000000A                M 	__sp:	= __sp+4
0000ED44 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED44                          M 	rept	__stack
0000ED44                          M 	popp	__command
0000ED44 2F0C                     M 	move.l	a4,-(sp)
0000ED46                          M 	popp	__command
0000ED46 2F0C                     M 	move.l	a4,-(sp)
0000ED48                          M 	popp	__command
0000ED48 554F                     M 	subq.w	#2,sp
0000ED4A                          M 	popp	__command
0000ED4A 1F47 0001                M 	move.b	d7,1(sp)
0000ED4E 4EB9 0000 0000           M 	jsr	errorhandler
0000ED54                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED54 =00000001                M 	__lpos:	set 1
0000ED54 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED54                          M 	while	(__pos)
0000ED54                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED54 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music "
0000ED6D =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED6D =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED6D =00000021                M 	__midpos:	= __endpos
0000ED6D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED6D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED6D                          M 	__param:	substr ,,"hex"
0000ED6D 80                       M 	dc.b	hex
0000ED6E =00000022                M 	__lpos:	set __endpos+1
0000ED6E =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED6E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED6E 3A20                     M 	dc.b	": "
0000ED70 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED70 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED70 =0000002B                M 	__midpos:	= __endpos
0000ED70                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED70                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED70                          M 	__param:	substr ,,"hex"
0000ED70 83                       M 	dc.b	hex|3
0000ED71 =0000002C                M 	__lpos:	set __endpos+1
0000ED71 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED71                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED71                          M 	dc.b	""
0000ED71 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED71 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED71 =00000033                M 	__midpos:	= __endpos
0000ED71                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED71                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED71 E0                       M 	dc.b	fendl
0000ED72 =00000034                M 	__lpos:	set __endpos+1
0000ED72 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED72                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED72                          M 	dc.b	""
0000ED72 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ED72 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ED72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED72                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED72 B3                       M 	dc.b	sym|3
0000ED73 =00000040                M 	__lpos:	set __endpos+1
0000ED73 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ED73                          M 	__substr:	substr __lpos,,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ED73                          M 	dc.b	""
0000ED73 00                       M 	dc.b	0
0000ED74 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000ED76 00                       M 	even
0000ED76 4EFA ED7A                M 	jmp	amps_debug_console_main
0000ED7A                          M 	even
0000ED7A                          M .ok_589
0000ED7A                            
0000ED7A 264C                       		move.l	a4,a3			; copy pointer to a3
0000ED7C 584C                       		addq.w	#4,a4			; go to DAC1 data section
0000ED7E                            
0000ED7E 7000                       		moveq	#0,d0
0000ED80 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0000ED84 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0000ED88 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0000ED8E 6700                       		beq.s	.tempogot		; if not, use main tempo
0000ED90 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0000ED94                            
0000ED94                            .tempogot
0000ED94 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0000ED98 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0000ED9C 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0000EDA2                            ; ---------------------------------------------------------------------------
0000EDA2                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0000EDA2                            ; disabled. I know, very weird place to put it, but we dont have
0000EDA2                            ; much free room in the song header
0000EDA2                            ; ---------------------------------------------------------------------------
0000EDA2                            
0000EDA2 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0000EDA4 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0000EDA6 0244 007F                  		and.w	#$7F,d4			; keep value in range
0000EDAA 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0000EDB0                            
0000EDB0                            .noPAL
0000EDB0 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0000EDB2 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0000EDB4 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0000EDB6 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0000EDB8                            
0000EDB8 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0000EDBC 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0000EDC0 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0000EDC2 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0000EDC6                            
0000EDC6                            .loopDAC
0000EDC6 1282                       		move.b	d2,(a1)			; save channel flags
0000EDC8 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EDCC 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EDD0 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EDD4 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000EDD8 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EDDC 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0000EDE0                            
0000EDE0 7000                       		moveq	#0,d0
0000EDE2 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EDE4 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EDE6 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EDEA                            		AMPS_Debug_PlayTrackMus2 DAC	; make sure the tracker address is valid
0000EDEA 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EDF0 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EDF6 6500                     M 	blo.s	.fail_594
0000EDF8 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EDFE 6500                     M 	blo.s	.ok_594
0000EE00                          M .fail_594
0000EE00                          M 	raiseerror	"Invalid tracker at Music dac: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE00 487A FFFE                M 	pea	*(pc)
0000EE04                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE04 40E7                     M 	move.w	sr,-(sp)
0000EE06                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE06 =00000000                M 	__stack:set	0
0000EE06 =00000000                M 	__sp:	set 0
0000EE06                          M 	while	(__pos)
0000EE06 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE06 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE06 =00000027                M 	__midpos:	= __endpos
0000EE06                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	pushp	"move.l d0,-(sp)"
0000EE06 =00000001                M 	__stack:	= __stack+1
0000EE06 =00000004                M 	__sp:	= __sp+4
0000EE06 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE06 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE06 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE06 =0000002F                M 	__midpos:	= __endpos
0000EE06                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE06 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE06 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE06                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE06                          M 	pushp	"move.l d0,-(sp)"
0000EE06 =00000002                M 	__stack:	= __stack+1
0000EE06 =00000008                M 	__sp:	= __sp+4
0000EE06 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE06                          M 	rept	__stack
0000EE06                          M 	popp	__command
0000EE06 2F00                     M 	move.l	d0,-(sp)
0000EE08                          M 	popp	__command
0000EE08 2F00                     M 	move.l	d0,-(sp)
0000EE0A 4EB9 0000 0000           M 	jsr	errorhandler
0000EE10                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE10 =00000001                M 	__lpos:	set 1
0000EE10 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE10                          M 	while	(__pos)
0000EE10                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE10 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EE2F =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE2F =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE2F =00000027                M 	__midpos:	= __endpos
0000EE2F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE2F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE2F                          M 	__param:	substr ,,"hex"
0000EE2F 83                       M 	dc.b	hex|3
0000EE30 =00000028                M 	__lpos:	set __endpos+1
0000EE30 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE30                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE30                          M 	dc.b	""
0000EE30 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE30 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE30 =0000002F                M 	__midpos:	= __endpos
0000EE30                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE30                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE30 E0                       M 	dc.b	fendl
0000EE31 =00000030                M 	__lpos:	set __endpos+1
0000EE31 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE31                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE31                          M 	dc.b	""
0000EE31 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE31 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE31                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE31                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE31 B3                       M 	dc.b	sym|3
0000EE32 =0000003C                M 	__lpos:	set __endpos+1
0000EE32 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE32                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE32                          M 	dc.b	""
0000EE32 00                       M 	dc.b	0
0000EE33 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EE34                          M 	even
0000EE34 4EFA ECBC                M 	jmp	amps_debug_console_main
0000EE38                          M 	even
0000EE38                          M .ok_594
0000EE38                            
0000EE38 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0000EE3C 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0000EE40 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0000EE42 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0000EE46                            
0000EE46                            .sampmode
0000EE46 D2C6                       		add.w	d6,a1			; go to the next channel
0000EE48 51CF FF7C                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0000EE4C                            
0000EE4C 7E00                       		moveq	#0,d7
0000EE4E 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0000EE50 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0000EE54 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0000EE56                            
0000EE56                            .loopFM
0000EE56 1282                       		move.b	d2,(a1)			; save channel flags
0000EE58 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EE5C 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EE60 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EE64 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000EE68 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EE6C                            
0000EE6C 7000                       		moveq	#0,d0
0000EE6E 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EE70 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EE72 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EE76                            		AMPS_Debug_PlayTrackMus2 FM	; make sure the tracker address is valid
0000EE76 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EE7C 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EE82 6500                     M 	blo.s	.fail_599
0000EE84 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EE8A 6500                     M 	blo.s	.ok_599
0000EE8C                          M .fail_599
0000EE8C                          M 	raiseerror	"Invalid tracker at Music fm: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE8C 487A FFFE                M 	pea	*(pc)
0000EE90                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE90 40E7                     M 	move.w	sr,-(sp)
0000EE92                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE92 =00000000                M 	__stack:set	0
0000EE92 =00000000                M 	__sp:	set 0
0000EE92                          M 	while	(__pos)
0000EE92 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE92 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE92 =00000027                M 	__midpos:	= __endpos
0000EE92                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	pushp	"move.l d0,-(sp)"
0000EE92 =00000001                M 	__stack:	= __stack+1
0000EE92 =00000004                M 	__sp:	= __sp+4
0000EE92 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE92 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE92 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE92 =0000002F                M 	__midpos:	= __endpos
0000EE92                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE92 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE92 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE92                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE92                          M 	pushp	"move.l d0,-(sp)"
0000EE92 =00000002                M 	__stack:	= __stack+1
0000EE92 =00000008                M 	__sp:	= __sp+4
0000EE92 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE92                          M 	rept	__stack
0000EE92                          M 	popp	__command
0000EE92 2F00                     M 	move.l	d0,-(sp)
0000EE94                          M 	popp	__command
0000EE94 2F00                     M 	move.l	d0,-(sp)
0000EE96 4EB9 0000 0000           M 	jsr	errorhandler
0000EE9C                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE9C =00000001                M 	__lpos:	set 1
0000EE9C =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE9C                          M 	while	(__pos)
0000EE9C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE9C 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EEBB =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEBB =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEBB =00000027                M 	__midpos:	= __endpos
0000EEBB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBB                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBB                          M 	__param:	substr ,,"hex"
0000EEBB 83                       M 	dc.b	hex|3
0000EEBC =00000028                M 	__lpos:	set __endpos+1
0000EEBC =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEBC                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBC                          M 	dc.b	""
0000EEBC =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEBC =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEBC =0000002F                M 	__midpos:	= __endpos
0000EEBC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBC E0                       M 	dc.b	fendl
0000EEBD =00000030                M 	__lpos:	set __endpos+1
0000EEBD =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEBD                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBD                          M 	dc.b	""
0000EEBD =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEBD =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEBD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBD                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBD B3                       M 	dc.b	sym|3
0000EEBE =0000003C                M 	__lpos:	set __endpos+1
0000EEBE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEBE                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEBE                          M 	dc.b	""
0000EEBE 00                       M 	dc.b	0
0000EEBF 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EEC0                          M 	even
0000EEC0 4EFA EC30                M 	jmp	amps_debug_console_main
0000EEC4                          M 	even
0000EEC4                          M .ok_599
0000EEC4                            
0000EEC4 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EEC8 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EECA 51CF FF8A                  		dbf	d7,.loopFM		; repeat for all FM channels
0000EECE                            
0000EECE                            .doPSG
0000EECE 7E00                       		moveq	#0,d7
0000EED0 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0000EED4 6B00 0000                  		bmi.w	.intSFX			; if no PSG channels are loaded, branch
0000EED8                            ; ---------------------------------------------------------------------------
0000EED8                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EED8                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EED8                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EED8                            ; is controlled by the 68000, we would be off by a single frame without
0000EED8                            ; this fix.
0000EED8                            ; ---------------------------------------------------------------------------
0000EED8                            
0000EED8 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0000EEDA 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0000EEDE 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0000EEE2                            
0000EEE2                            .loopPSG
0000EEE2 1282                       		move.b	d2,(a1)			; save channel flags
0000EEE4 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EEE8 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EEEC 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EEF0 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EEF4                            
0000EEF4 7000                       		moveq	#0,d0
0000EEF6 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EEF8 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EEFA 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EEFE                            		AMPS_Debug_PlayTrackMus2 PSG	; make sure the tracker address is valid
0000EEFE 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EF04 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EF0A 6500                     M 	blo.s	.fail_604
0000EF0C 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EF12 6500                     M 	blo.s	.ok_604
0000EF14                          M .fail_604
0000EF14                          M 	raiseerror	"Invalid tracker at Music psg: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EF14 487A FFFE                M 	pea	*(pc)
0000EF18                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EF18 40E7                     M 	move.w	sr,-(sp)
0000EF1A                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF1A =00000000                M 	__stack:set	0
0000EF1A =00000000                M 	__sp:	set 0
0000EF1A                          M 	while	(__pos)
0000EF1A =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF1A =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF1A =00000027                M 	__midpos:	= __endpos
0000EF1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	pushp	"move.l d0,-(sp)"
0000EF1A =00000001                M 	__stack:	= __stack+1
0000EF1A =00000004                M 	__sp:	= __sp+4
0000EF1A =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF1A =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF1A =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF1A =0000002F                M 	__midpos:	= __endpos
0000EF1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF1A =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF1A =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF1A                          M 	pushp	"move.l d0,-(sp)"
0000EF1A =00000002                M 	__stack:	= __stack+1
0000EF1A =00000008                M 	__sp:	= __sp+4
0000EF1A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF1A                          M 	rept	__stack
0000EF1A                          M 	popp	__command
0000EF1A 2F00                     M 	move.l	d0,-(sp)
0000EF1C                          M 	popp	__command
0000EF1C 2F00                     M 	move.l	d0,-(sp)
0000EF1E 4EB9 0000 0000           M 	jsr	errorhandler
0000EF24                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF24 =00000001                M 	__lpos:	set 1
0000EF24 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF24                          M 	while	(__pos)
0000EF24                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF24 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EF43 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF43 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF43 =00000027                M 	__midpos:	= __endpos
0000EF43                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF43                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF43                          M 	__param:	substr ,,"hex"
0000EF43 83                       M 	dc.b	hex|3
0000EF44 =00000028                M 	__lpos:	set __endpos+1
0000EF44 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF44                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF44                          M 	dc.b	""
0000EF44 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF44 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF44 =0000002F                M 	__midpos:	= __endpos
0000EF44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF44                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF44 E0                       M 	dc.b	fendl
0000EF45 =00000030                M 	__lpos:	set __endpos+1
0000EF45 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF45                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF45                          M 	dc.b	""
0000EF45 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EF45 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EF45                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF45                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF45 B3                       M 	dc.b	sym|3
0000EF46 =0000003C                M 	__lpos:	set __endpos+1
0000EF46 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EF46                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EF46                          M 	dc.b	""
0000EF46 00                       M 	dc.b	0
0000EF47 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EF48                          M 	even
0000EF48 4EFA EBA8                M 	jmp	amps_debug_console_main
0000EF4C                          M 	even
0000EF4C                          M .ok_604
0000EF4C                            
0000EF4C 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EF50 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0000EF54 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0000EF58 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EF5A 51CF FF86                  		dbf	d7,.loopPSG		; repeat for all FM channels
0000EF5E                            
0000EF5E                            .intSFX
0000EF5E                            ; ---------------------------------------------------------------------------
0000EF5E                            ; Now follows initializing FM6 to be ready for PCM streaming,
0000EF5E                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0000EF5E                            ; clears some YM registers.
0000EF5E                            ; ---------------------------------------------------------------------------
0000EF5E                            
0000EF5E 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EF60 7206                       		moveq	#6,d1			; FM6, all operators off
0000EF62 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EF66                            
0000EF66 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000EF68 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0000EF6A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EF6E 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0000EF70 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EF74 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0000EF76 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EF7A 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0000EF7C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EF80                            
0000EF80 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000EF82 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EF84 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EF88                            
0000EF88 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0000EF8C 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0000EF90                            ; ---------------------------------------------------------------------------
0000EF90                            ; This piece of code here handles SFX overriding our newly loaded
0000EF90                            ; music channels. Since we did not do this at the initialization
0000EF90                            ; step, we will handle it here instead.
0000EF90                            ; ---------------------------------------------------------------------------
0000EF90                            
0000EF90 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0000EF94 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0000EF98 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0000EF9A 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EF9C                            
0000EF9C                            .loopSFX
0000EF9C 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0000EF9E 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0000EFA0                            
0000EFA0 7000                       		moveq	#0,d0
0000EFA2 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0000EFA6 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0000EFA8                            
0000EFA8 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0000EFAC 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0000EFAE D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0000EFB0 6000                       		bra.s	.override
0000EFB2                            ; ---------------------------------------------------------------------------
0000EFB2                            
0000EFB2                            .SFXPSG
0000EFB2 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0000EFB4                            .override
0000EFB4 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0000EFB8 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0000EFBC                            
0000EFBC                            .nextSFX
0000EFBC D2C6                       		adda.w	d6,a1			; go to the next channel
0000EFBE 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0000EFC2                            ; ---------------------------------------------------------------------------
0000EFC2                            ; Here we mute all non-interrupted FM and PSG channels
0000EFC2                            ; ---------------------------------------------------------------------------
0000EFC2                            
0000EFC2 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EFC6 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0000EFC8                            .stopFM
0000EFC8 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0000EFCC DAC6                       		adda.w	d6,a5			; go to the next channel
0000EFCE 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0000EFD2                            
0000EFD2 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0000EFD4                            .mutePSG
0000EFD4 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0000EFD8 DAC6                       		adda.w	d6,a5			; go to the next channel
0000EFDA 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0000EFDE 4E75                       		rts
0000EFE0                            
0000EFE0                            ; ===========================================================================
0000EFE0                            ; ---------------------------------------------------------------------------
0000EFE0                            ; Type values for different channels. Used for playing music
0000EFE0                            ; ---------------------------------------------------------------------------
0000EFE0 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0000EFE2 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0000EFE7 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0000EFEA                            		even
0000EFEA                            ; ===========================================================================
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            ; Subroutine to play a queued sound effect
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            
0000EFEA                            dPlaySnd_SFX:
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            ; This is a little special case with Sonic 1 - 3K, where the ring
0000EFEA                            ; sound effect would change panning each time it is played. AMPS
0000EFEA                            ; emulates this behavior like the original drivers did, by
0000EFEA                            ; playing a different sound effect ID.
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            
0000EFEA                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0000EFEA                            		;bne.s	.noring			; if not, skip
0000EFEA                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0000EFEA                            		;beq.s	.noring			; if was not, do not change sound effect
0000EFEA                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            ; To save few cycles, we don't directly substract the SFX offset from
0000EFEA                            ; the ID, and instead offset the table position. In practice this will
0000EFEA                            ; have the same effect, but saves us 8 cycles overall.
0000EFEA                            ; ---------------------------------------------------------------------------
0000EFEA                            
0000EFEA                            .noring
0000EFEA 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0000EFEE 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0000EFF0 DE47                       		add.w	d7,d7			; quadruple sfx ID
0000EFF2 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EFF4 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0000EFF8                            
0000EFF8 200C                       		move.l	a4,d0			; copy pointer to d0
0000EFFA 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000F000 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000F002                            		AMPS_Debug_PlayTrackSFX		; check if this was valid sound effect
0000F002 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000F008 6500                     M 	blo.s	.fail_609
0000F00A 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000F010 6500                     M 	blo.s	.ok_609
0000F012                          M .fail_609
0000F012                          M 	raiseerror	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000F012 487A FFFE                M 	pea	*(pc)
0000F016                          M 	raiseerror2	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000F016 40E7                     M 	move.w	sr,-(sp)
0000F018                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F018 =00000000                M 	__stack:set	0
0000F018 =00000000                M 	__sp:	set 0
0000F018                          M 	while	(__pos)
0000F018 =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F018 =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F018 =0000001F                M 	__midpos:	= __endpos
0000F018                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	pushp	"move.b d0,1(sp)"
0000F018                          M 	pushp	"subq.w	#2, sp"
0000F018 =00000002                M 	__stack:	= __stack+2
0000F018 =00000002                M 	__sp:	= __sp+2
0000F018 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F018 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F018 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F018 =00000029                M 	__midpos:	= __endpos
0000F018                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	pushp	"move.l a4,-(sp)"
0000F018 =00000003                M 	__stack:	= __stack+1
0000F018 =00000006                M 	__sp:	= __sp+4
0000F018 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F018 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F018 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F018 =00000031                M 	__midpos:	= __endpos
0000F018                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F018 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F018 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F018                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F018                          M 	pushp	"move.l a4,-(sp)"
0000F018 =00000004                M 	__stack:	= __stack+1
0000F018 =0000000A                M 	__sp:	= __sp+4
0000F018 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F018                          M 	rept	__stack
0000F018                          M 	popp	__command
0000F018 2F0C                     M 	move.l	a4,-(sp)
0000F01A                          M 	popp	__command
0000F01A 2F0C                     M 	move.l	a4,-(sp)
0000F01C                          M 	popp	__command
0000F01C 554F                     M 	subq.w	#2,sp
0000F01E                          M 	popp	__command
0000F01E 1F40 0001                M 	move.b	d0,1(sp)
0000F022 4EB9 0000 0000           M 	jsr	errorhandler
0000F028                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F028 =00000001                M 	__lpos:	set 1
0000F028 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F028                          M 	while	(__pos)
0000F028                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F028 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX "
0000F03F =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F03F =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F03F =0000001F                M 	__midpos:	= __endpos
0000F03F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F03F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F03F                          M 	__param:	substr ,,"hex"
0000F03F 80                       M 	dc.b	hex
0000F040 =00000020                M 	__lpos:	set __endpos+1
0000F040 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F040                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F040 3A20                     M 	dc.b	": "
0000F042 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F042 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F042 =00000029                M 	__midpos:	= __endpos
0000F042                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F042                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F042                          M 	__param:	substr ,,"hex"
0000F042 83                       M 	dc.b	hex|3
0000F043 =0000002A                M 	__lpos:	set __endpos+1
0000F043 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F043                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F043                          M 	dc.b	""
0000F043 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F043 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F043 =00000031                M 	__midpos:	= __endpos
0000F043                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F043                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F043 E0                       M 	dc.b	fendl
0000F044 =00000032                M 	__lpos:	set __endpos+1
0000F044 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F044                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F044                          M 	dc.b	""
0000F044 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F044 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F044                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F044                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F044 B3                       M 	dc.b	sym|3
0000F045 =0000003E                M 	__lpos:	set __endpos+1
0000F045 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F045                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000F045                          M 	dc.b	""
0000F045 00                       M 	dc.b	0
0000F046 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F048 00                       M 	even
0000F048 4EFA EAA8                M 	jmp	amps_debug_console_main
0000F04C                          M 	even
0000F04C                          M .ok_609
0000F04C                            ; ---------------------------------------------------------------------------
0000F04C                            ; Continous SFX is a very special type of sound effect. Unlike other
0000F04C                            ; sound effects, when a continous SFX is played, it will run a loop
0000F04C                            ; again, until it is no longer queued. This is very useful for sound
0000F04C                            ; effects that need to be queued very often, but that really do not
0000F04C                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0000F04C                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0000F04C                            ; but the code was not quite as matured as this here. Only one continous
0000F04C                            ; SFX may be running at once, when other type is loaded, the earlier one
0000F04C                            ; is stopped and replaced.
0000F04C                            ; ---------------------------------------------------------------------------
0000F04C                            
0000F04C 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0000F050 6A00                       		bpl.s	.nocont			; if not, skip
0000F052 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0000F058 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0000F05C 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0000F05E 4E75                       		rts
0000F060                            
0000F060                            .setcont
0000F060 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0000F064                            .nocont
0000F064 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0000F066                            
0000F066 7E00                       		moveq	#0,d7
0000F068 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0000F06C 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0000F070 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0000F072 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0000F074 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000F076                            ; ---------------------------------------------------------------------------
0000F076                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000F076                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000F076                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000F076                            ; is controlled by the 68000, we would be off by a single frame without
0000F076                            ; this fix.
0000F076                            ; ---------------------------------------------------------------------------
0000F076                            
0000F076                            .loopSFX
0000F076 7600                       		moveq	#0,d3
0000F078 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0000F07A 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0000F07E 1803                       		move.b	d3,d4			; copy type to d4
0000F080 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0000F082                            
0000F082 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0000F086 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0000F088 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0000F08A                            
0000F08A 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000F08E BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000F092 6500                       		blo.s	.skip			; if not, we can not override it
0000F094                            
0000F094 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000F098 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000F09C 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0000F09E 6000                       		bra.s	.clearCh
0000F0A0                            ; ---------------------------------------------------------------------------
0000F0A0                            
0000F0A0                            .skip
0000F0A0 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0000F0A2 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F0A6 4E75                       		rts
0000F0A8                            ; ---------------------------------------------------------------------------
0000F0A8                            
0000F0A8                            .chPSG
0000F0A8 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0000F0AA 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000F0AE BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000F0B2 65EC                       		blo.s	.skip			; if not, we can not override it
0000F0B4                            
0000F0B4 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000F0B8 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000F0BC 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0000F0C0 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0000F0C6                            
0000F0C6 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0000F0CA 6600                       		bne.s	.clearCh		; if not, skip
0000F0CC 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0000F0D4                            
0000F0D4                            .clearCh
0000F0D4 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0000F0D6 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0000F0D8                            .clear
0000F0D8 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0000F0DA 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0000F0DE                            
0000F0DE                            
0000F0DE 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0000F0E0 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0000F0E4 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0000F0E8                            
0000F0E8 7000                       		moveq	#0,d0
0000F0EA 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0000F0EC D08C                       		add.l	a4,d0			; add music header offset to d0
0000F0EE 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0000F0F2                            		AMPS_Debug_PlayTrackSFX2	; make sure the tracker address is valid
0000F0F2 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000F0F8 6500                     M 	blo.s	.fail_614
0000F0FA 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000F100 6500                     M 	blo.s	.ok_614
0000F102                          M .fail_614
0000F102                          M 	raiseerror	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F102 487A FFFE                M 	pea	*(pc)
0000F106                          M 	raiseerror2	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F106 40E7                     M 	move.w	sr,-(sp)
0000F108                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F108 =00000000                M 	__stack:set	0
0000F108 =00000000                M 	__sp:	set 0
0000F108                          M 	while	(__pos)
0000F108 =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F108 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F108 =00000023                M 	__midpos:	= __endpos
0000F108                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	pushp	"move.l d0,-(sp)"
0000F108 =00000001                M 	__stack:	= __stack+1
0000F108 =00000004                M 	__sp:	= __sp+4
0000F108 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F108 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F108 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F108 =0000002B                M 	__midpos:	= __endpos
0000F108                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F108 =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F108 =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F108                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F108                          M 	pushp	"move.l d0,-(sp)"
0000F108 =00000002                M 	__stack:	= __stack+1
0000F108 =00000008                M 	__sp:	= __sp+4
0000F108 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F108                          M 	rept	__stack
0000F108                          M 	popp	__command
0000F108 2F00                     M 	move.l	d0,-(sp)
0000F10A                          M 	popp	__command
0000F10A 2F00                     M 	move.l	d0,-(sp)
0000F10C 4EB9 0000 0000           M 	jsr	errorhandler
0000F112                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F112 =00000001                M 	__lpos:	set 1
0000F112 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F112                          M 	while	(__pos)
0000F112                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F112 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX ch: "
0000F12D =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F12D =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F12D =00000023                M 	__midpos:	= __endpos
0000F12D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12D                          M 	__param:	substr ,,"hex"
0000F12D 83                       M 	dc.b	hex|3
0000F12E =00000024                M 	__lpos:	set __endpos+1
0000F12E =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F12E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12E                          M 	dc.b	""
0000F12E =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F12E =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F12E =0000002B                M 	__midpos:	= __endpos
0000F12E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12E E0                       M 	dc.b	fendl
0000F12F =0000002C                M 	__lpos:	set __endpos+1
0000F12F =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F12F                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12F                          M 	dc.b	""
0000F12F =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F12F =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F12F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F12F B3                       M 	dc.b	sym|3
0000F130 =00000038                M 	__lpos:	set __endpos+1
0000F130 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F130                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F130                          M 	dc.b	""
0000F130 00                       M 	dc.b	0
0000F131 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F132                          M 	even
0000F132 4EFA E9BE                M 	jmp	amps_debug_console_main
0000F136                          M 	even
0000F136                          M .ok_614
0000F136                            
0000F136 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0000F13A 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0000F13C 6B00                       		bmi.s	.loop			; if is, skip over this
0000F13E                            
0000F13E 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000F140 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0000F144 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000F146 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0000F14A                            
0000F14A BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0000F14E 6600                       		bne.s	.fm			; if not, branch
0000F150 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0000F156                            
0000F156                            .loop
0000F156 51CF FF1E                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F15A 4E75                       		rts
0000F15C                            ; ---------------------------------------------------------------------------
0000F15C                            ; The instant release for FM channels behavior was not in the Sonic 1
0000F15C                            ; SMPS driver by default, but it has been added since it fixes an
0000F15C                            ; issue with YM2612, where sometimes subsequent sound effect activations
0000F15C                            ; would sound different over time. This fix will help to mitigate that.
0000F15C                            ; ---------------------------------------------------------------------------
0000F15C                            
0000F15C                            .fm
0000F15C 720F                       		moveq	#$F,d1			; set to release note instantly
0000F15E 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0000F160 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F164 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0000F166 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F16A 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0000F16C 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F170 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0000F172 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F176                            
0000F176 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F178 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0000F17C 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0000F180                            
0000F180 51CF FEF4                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F184 4E75                       		rts
0000F186                            ; ===========================================================================
0000F186                            ; ---------------------------------------------------------------------------
0000F186                            ; pointers for music channels SFX can override and addresses of SFX channels
0000F186                            ; ---------------------------------------------------------------------------
0000F186                            
0000F186 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0000F188 C67C                       		dc.w mSFXDAC1			; DAC1
0000F18A C6B4                       		dc.w mSFXFM4			; FM4
0000F18C C6D0                       		dc.w mSFXFM5			; FM5
0000F18E C6EC                       		dc.w mSFXPSG1			; PSG1
0000F190 C708                       		dc.w mSFXPSG2			; PSG2
0000F192 C724                       		dc.w mSFXPSG3			; PSG3
0000F194 C724                       		dc.w mSFXPSG3			; PSG4
0000F196                            
0000F196 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0000F198 C4C4                       		dc.w mDAC1			; SFX DAC1
0000F19A C5A0                       		dc.w mFM4			; SFX FM4
0000F19C C5CC                       		dc.w mFM5			; SFX FM5
0000F19E C5F8                       		dc.w mPSG1			; SFX PSG1
0000F1A0 C624                       		dc.w mPSG2			; SFX PSG2
0000F1A2 C650                       		dc.w mPSG3			; SFX PSG3
0000F1A4 C650                       		dc.w mPSG3			; SFX PSG4
0000F1A6                            ; ===========================================================================
0000F1A6                            ; ---------------------------------------------------------------------------
0000F1A6                            ; Play queued command
0000F1A6                            ; ---------------------------------------------------------------------------
0000F1A6                            
0000F1A6                            dPlaySnd_Comm:
0000F1A6                            		AMPS_Debug_PlayCmd		; check if the command is valid
0000F1A6 0C07 0000                M 	cmp.b	#(dsoundcommands_end-dsoundcommands)/4,d7
0000F1AA 6300                     M 	bls.s	.ok
0000F1AC                          M 	raiseerror	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F1AC 487A FFFE                M 	pea	*(pc)
0000F1B0                          M 	raiseerror2	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F1B0 40E7                     M 	move.w	sr,-(sp)
0000F1B2                          M 	__fstring_generateargumentscode	"Invalid command in queue: %<.b d7>"
0000F1B2 =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F1B2 =00000000                M 	__stack:set	0
0000F1B2 =00000000                M 	__sp:	set 0
0000F1B2                          M 	while	(__pos)
0000F1B2 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F1B2 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F1B2 =00000022                M 	__midpos:	= __endpos
0000F1B2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F1B2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F1B2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid command in queue: %<.b d7>"
0000F1B2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F1B2                          M 	pushp	"move.b d7,1(sp)"
0000F1B2                          M 	pushp	"subq.w	#2, sp"
0000F1B2 =00000002                M 	__stack:	= __stack+2
0000F1B2 =00000002                M 	__sp:	= __sp+2
0000F1B2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F1B2                          M 	rept	__stack
0000F1B2                          M 	popp	__command
0000F1B2 554F                     M 	subq.w	#2,sp
0000F1B4                          M 	popp	__command
0000F1B4 1F47 0001                M 	move.b	d7,1(sp)
0000F1B8 4EB9 0000 0000           M 	jsr	errorhandler
0000F1BE                          M 	__fstring_generatedecodedstring	"Invalid command in queue: %<.b d7>"
0000F1BE =00000001                M 	__lpos:	set 1
0000F1BE =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F1BE                          M 	while	(__pos)
0000F1BE                          M 	__substr:	substr __lpos,__pos-1,"Invalid command in queue: %<.b d7>"
0000F1BE 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command in queue: "
0000F1D8 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F1D8 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F1D8 =00000022                M 	__midpos:	= __endpos
0000F1D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F1D8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F1D8                          M 	__param:	substr ,,"hex"
0000F1D8 80                       M 	dc.b	hex
0000F1D9 =00000023                M 	__lpos:	set __endpos+1
0000F1D9 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F1D9                          M 	__substr:	substr __lpos,,"Invalid command in queue: %<.b d7>"
0000F1D9                          M 	dc.b	""
0000F1D9 00                       M 	dc.b	0
0000F1DA 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F1DC 00                       M 	even
0000F1DC 4EFA E16E                M 	jmp	amps_debug_console_channel
0000F1E0                          M 	even
0000F1E0                          M .ok
0000F1E0                            
0000F1E0 DE47                       		add.w	d7,d7			; quadruple ID
0000F1E2 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0000F1E4 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0000F1E8                            
0000F1E8                            ; ---------------------------------------------------------------------------
0000F1E8                            dSoundCommands:
0000F1E8 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0000F1EC 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0000F1F0 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0000F1F4 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0000F1F8 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0000F1FC 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0000F200 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0000F204 6000 FA38                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0000F208 6000 F9D4                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0000F20C                            dSoundCommands_End:
0000F20C                            ; ===========================================================================
0000F20C                            ; ---------------------------------------------------------------------------
0000F20C                            ; Commands for what to do after a volume fade
0000F20C                            ; ---------------------------------------------------------------------------
0000F20C                            
0000F20C                            dFadeCommands:
0000F20C 4E75                       		rts				; 80 - Do nothing
0000F20E 4E75                       		rts
0000F210 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0000F212 4E75                       		rts
0000F214 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0000F218 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0000F21A 60F4                       		bra.s	.stop
0000F21C                            ; ===========================================================================
0000F21C                            ; ---------------------------------------------------------------------------
0000F21C                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0000F21C                            ; ---------------------------------------------------------------------------
0000F21C                            
0000F21C                            dPlaySnd_Stop:
0000F21C                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0000F21C                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0000F21C                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F21C                            
0000F21C 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0000F21E 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0000F220 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F224                            
0000F224 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0000F228                            
0000F228                            	rept (mSize-mSFXDAC1)/4
0000F228                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0000F228                            	endr
0000F228 4299                     M 	clr.l	(a1)+
0000F22A 4299                     M 	clr.l	(a1)+
0000F22C 4299                     M 	clr.l	(a1)+
0000F22E 4299                     M 	clr.l	(a1)+
0000F230 4299                     M 	clr.l	(a1)+
0000F232 4299                     M 	clr.l	(a1)+
0000F234 4299                     M 	clr.l	(a1)+
0000F236 4299                     M 	clr.l	(a1)+
0000F238 4299                     M 	clr.l	(a1)+
0000F23A 4299                     M 	clr.l	(a1)+
0000F23C 4299                     M 	clr.l	(a1)+
0000F23E 4299                     M 	clr.l	(a1)+
0000F240 4299                     M 	clr.l	(a1)+
0000F242 4299                     M 	clr.l	(a1)+
0000F244 4299                     M 	clr.l	(a1)+
0000F246 4299                     M 	clr.l	(a1)+
0000F248 4299                     M 	clr.l	(a1)+
0000F24A 4299                     M 	clr.l	(a1)+
0000F24C 4299                     M 	clr.l	(a1)+
0000F24E 4299                     M 	clr.l	(a1)+
0000F250 4299                     M 	clr.l	(a1)+
0000F252 4299                     M 	clr.l	(a1)+
0000F254 4299                     M 	clr.l	(a1)+
0000F256 4299                     M 	clr.l	(a1)+
0000F258 4299                     M 	clr.l	(a1)+
0000F25A 4299                     M 	clr.l	(a1)+
0000F25C 4299                     M 	clr.l	(a1)+
0000F25E 4299                     M 	clr.l	(a1)+
0000F260 4299                     M 	clr.l	(a1)+
0000F262 4299                     M 	clr.l	(a1)+
0000F264 4299                     M 	clr.l	(a1)+
0000F266 4299                     M 	clr.l	(a1)+
0000F268 4299                     M 	clr.l	(a1)+
0000F26A 4299                     M 	clr.l	(a1)+
0000F26C 4299                     M 	clr.l	(a1)+
0000F26E 4299                     M 	clr.l	(a1)+
0000F270 4299                     M 	clr.l	(a1)+
0000F272 4299                     M 	clr.l	(a1)+
0000F274 4299                     M 	clr.l	(a1)+
0000F276 4299                     M 	clr.l	(a1)+
0000F278 4299                     M 	clr.l	(a1)+
0000F27A 4299                     M 	clr.l	(a1)+
0000F27C 4299                     M 	clr.l	(a1)+
0000F27E 4299                     M 	clr.l	(a1)+
0000F280 4299                     M 	clr.l	(a1)+
0000F282 4299                     M 	clr.l	(a1)+
0000F284 4299                     M 	clr.l	(a1)+
0000F286 4299                     M 	clr.l	(a1)+
0000F288 4299                     M 	clr.l	(a1)+
0000F28A                            
0000F28A 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F28C                            	; continue straight to stopping music
0000F28C                            ; ===========================================================================
0000F28C                            ; ---------------------------------------------------------------------------
0000F28C                            ; Stop music from playing, reset driver memory and mute hardware
0000F28C                            ; ---------------------------------------------------------------------------
0000F28C                            
0000F28C                            dStopMusic:
0000F28C 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0000F290 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0000F292 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0000F296 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0000F29A 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0000F2A0                            
0000F2A0                            	rept (mSFXDAC1-mFlags)/4
0000F2A0                            		clr.l	(a1)+			; clear driver and music channel memory
0000F2A0                            	endr
0000F2A0 4299                     M 	clr.l	(a1)+
0000F2A2 4299                     M 	clr.l	(a1)+
0000F2A4 4299                     M 	clr.l	(a1)+
0000F2A6 4299                     M 	clr.l	(a1)+
0000F2A8 4299                     M 	clr.l	(a1)+
0000F2AA 4299                     M 	clr.l	(a1)+
0000F2AC 4299                     M 	clr.l	(a1)+
0000F2AE 4299                     M 	clr.l	(a1)+
0000F2B0 4299                     M 	clr.l	(a1)+
0000F2B2 4299                     M 	clr.l	(a1)+
0000F2B4 4299                     M 	clr.l	(a1)+
0000F2B6 4299                     M 	clr.l	(a1)+
0000F2B8 4299                     M 	clr.l	(a1)+
0000F2BA 4299                     M 	clr.l	(a1)+
0000F2BC 4299                     M 	clr.l	(a1)+
0000F2BE 4299                     M 	clr.l	(a1)+
0000F2C0 4299                     M 	clr.l	(a1)+
0000F2C2 4299                     M 	clr.l	(a1)+
0000F2C4 4299                     M 	clr.l	(a1)+
0000F2C6 4299                     M 	clr.l	(a1)+
0000F2C8 4299                     M 	clr.l	(a1)+
0000F2CA 4299                     M 	clr.l	(a1)+
0000F2CC 4299                     M 	clr.l	(a1)+
0000F2CE 4299                     M 	clr.l	(a1)+
0000F2D0 4299                     M 	clr.l	(a1)+
0000F2D2 4299                     M 	clr.l	(a1)+
0000F2D4 4299                     M 	clr.l	(a1)+
0000F2D6 4299                     M 	clr.l	(a1)+
0000F2D8 4299                     M 	clr.l	(a1)+
0000F2DA 4299                     M 	clr.l	(a1)+
0000F2DC 4299                     M 	clr.l	(a1)+
0000F2DE 4299                     M 	clr.l	(a1)+
0000F2E0 4299                     M 	clr.l	(a1)+
0000F2E2 4299                     M 	clr.l	(a1)+
0000F2E4 4299                     M 	clr.l	(a1)+
0000F2E6 4299                     M 	clr.l	(a1)+
0000F2E8 4299                     M 	clr.l	(a1)+
0000F2EA 4299                     M 	clr.l	(a1)+
0000F2EC 4299                     M 	clr.l	(a1)+
0000F2EE 4299                     M 	clr.l	(a1)+
0000F2F0 4299                     M 	clr.l	(a1)+
0000F2F2 4299                     M 	clr.l	(a1)+
0000F2F4 4299                     M 	clr.l	(a1)+
0000F2F6 4299                     M 	clr.l	(a1)+
0000F2F8 4299                     M 	clr.l	(a1)+
0000F2FA 4299                     M 	clr.l	(a1)+
0000F2FC 4299                     M 	clr.l	(a1)+
0000F2FE 4299                     M 	clr.l	(a1)+
0000F300 4299                     M 	clr.l	(a1)+
0000F302 4299                     M 	clr.l	(a1)+
0000F304 4299                     M 	clr.l	(a1)+
0000F306 4299                     M 	clr.l	(a1)+
0000F308 4299                     M 	clr.l	(a1)+
0000F30A 4299                     M 	clr.l	(a1)+
0000F30C 4299                     M 	clr.l	(a1)+
0000F30E 4299                     M 	clr.l	(a1)+
0000F310 4299                     M 	clr.l	(a1)+
0000F312 4299                     M 	clr.l	(a1)+
0000F314 4299                     M 	clr.l	(a1)+
0000F316 4299                     M 	clr.l	(a1)+
0000F318 4299                     M 	clr.l	(a1)+
0000F31A 4299                     M 	clr.l	(a1)+
0000F31C 4299                     M 	clr.l	(a1)+
0000F31E 4299                     M 	clr.l	(a1)+
0000F320 4299                     M 	clr.l	(a1)+
0000F322 4299                     M 	clr.l	(a1)+
0000F324 4299                     M 	clr.l	(a1)+
0000F326 4299                     M 	clr.l	(a1)+
0000F328 4299                     M 	clr.l	(a1)+
0000F32A 4299                     M 	clr.l	(a1)+
0000F32C 4299                     M 	clr.l	(a1)+
0000F32E 4299                     M 	clr.l	(a1)+
0000F330 4299                     M 	clr.l	(a1)+
0000F332 4299                     M 	clr.l	(a1)+
0000F334 4299                     M 	clr.l	(a1)+
0000F336 4299                     M 	clr.l	(a1)+
0000F338 4299                     M 	clr.l	(a1)+
0000F33A 4299                     M 	clr.l	(a1)+
0000F33C 4299                     M 	clr.l	(a1)+
0000F33E 4299                     M 	clr.l	(a1)+
0000F340 4299                     M 	clr.l	(a1)+
0000F342 4299                     M 	clr.l	(a1)+
0000F344 4299                     M 	clr.l	(a1)+
0000F346 4299                     M 	clr.l	(a1)+
0000F348 4299                     M 	clr.l	(a1)+
0000F34A 4299                     M 	clr.l	(a1)+
0000F34C 4299                     M 	clr.l	(a1)+
0000F34E 4299                     M 	clr.l	(a1)+
0000F350 4299                     M 	clr.l	(a1)+
0000F352 4299                     M 	clr.l	(a1)+
0000F354 4299                     M 	clr.l	(a1)+
0000F356 4299                     M 	clr.l	(a1)+
0000F358 4299                     M 	clr.l	(a1)+
0000F35A 4299                     M 	clr.l	(a1)+
0000F35C 4299                     M 	clr.l	(a1)+
0000F35E 4299                     M 	clr.l	(a1)+
0000F360 4299                     M 	clr.l	(a1)+
0000F362 4299                     M 	clr.l	(a1)+
0000F364 4299                     M 	clr.l	(a1)+
0000F366 4299                     M 	clr.l	(a1)+
0000F368 4299                     M 	clr.l	(a1)+
0000F36A 4299                     M 	clr.l	(a1)+
0000F36C 4299                     M 	clr.l	(a1)+
0000F36E 4299                     M 	clr.l	(a1)+
0000F370 4299                     M 	clr.l	(a1)+
0000F372 4299                     M 	clr.l	(a1)+
0000F374 4299                     M 	clr.l	(a1)+
0000F376 4299                     M 	clr.l	(a1)+
0000F378 4299                     M 	clr.l	(a1)+
0000F37A 4299                     M 	clr.l	(a1)+
0000F37C 4299                     M 	clr.l	(a1)+
0000F37E 4299                     M 	clr.l	(a1)+
0000F380 4299                     M 	clr.l	(a1)+
0000F382 4299                     M 	clr.l	(a1)+
0000F384 4299                     M 	clr.l	(a1)+
0000F386 4299                     M 	clr.l	(a1)+
0000F388 4299                     M 	clr.l	(a1)+
0000F38A                            
0000F38A 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F38C                            
0000F38C 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0000F390 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0000F394 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0000F398 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0000F39E                            
0000F39E 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0000F3A0 4EBA F8D0                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0000F3A4                            	; continue straight to hardware muting FM
0000F3A4                            ; ===========================================================================
0000F3A4                            ; ---------------------------------------------------------------------------
0000F3A4                            ; Mute all FM channels
0000F3A4                            ; ---------------------------------------------------------------------------
0000F3A4                            
0000F3A4                            dMuteFM:
0000F3A4 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F3A6 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000F3A8                            
0000F3A8                            .noteoff
0000F3A8 1203                       		move.b	d3,d1			; copy value into d1
0000F3AA 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F3AE 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000F3B0 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000F3B4 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0000F3B8                            
0000F3B8 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0000F3BA 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000F3BC 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0000F3BE                            
0000F3BE                            .chloop
0000F3BE 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0000F3C0 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0000F3C2                            
0000F3C2                            .oploop
0000F3C2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F3C6 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000F3CA 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0000F3CC 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0000F3D0                            
0000F3D0 9005                       		sub.b	d5,d0			; go to next FM channel
0000F3D2 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0000F3D6 4E75                       		rts
0000F3D8                            ; ===========================================================================
0000F3D8                            ; ---------------------------------------------------------------------------
0000F3D8                            ; Routine for muting all PSG channels
0000F3D8                            ; ---------------------------------------------------------------------------
0000F3D8                            
0000F3D8                            dMutePSG:
0000F3D8 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0000F3DE 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0000F3E2 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0000F3E6 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0000F3EA 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0000F3EE 4E75                       		rts
0000F3F0                            ; ===========================================================================
0000F3F0                            ; ---------------------------------------------------------------------------
0000F3F0                            ; Normal fade out data
0000F3F0                            ; ---------------------------------------------------------------------------
0000F3F0                            
0000F3F0                            dFadeOutDataLog:
0000F3F0 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0000F3FC 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0000F408 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0000F414 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0000F420 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0000F42C 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0000F438 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0000F444 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0000F450 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0000F45A                            
0000F45A                            ;dFadeOutDataLinear:
0000F45A                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0000F45A                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0000F45A                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0000F45A                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0000F45A                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0000F45A                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0000F45A                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0000F45A                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0000F45A                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0000F45A                            	even
0000F45A                            ; ===========================================================================
0000F45A                            ; ---------------------------------------------------------------------------
0000F45A                            ; Subroutine for initializing a fade effect.
0000F45A                            ; Since the driver allows for such an extensive and customizable
0000F45A                            ; fading code, we may hit a snag if we use fades too fast. It is
0000F45A                            ; possible, for example, to fade out, then in the middle of that,
0000F45A                            ; start fading in. This would normally cause a quick jump in the
0000F45A                            ; volume level from maybe half to completely mute. This routine
0000F45A                            ; aims to combat this by actually searching for the closest FM
0000F45A                            ; volume level in the fade program, and to start the new fade from
0000F45A                            ; where that byte appears. This can alter how long a volume fade
0000F45A                            ; lasts however, and if PSG and DAC volume are not correct faded,
0000F45A                            ; it may still cause a jump in their volume (especially if only,
0000F45A                            ; say, DAC fades volume). In the future, there might be a fix for
0000F45A                            ; that.
0000F45A                            ; ---------------------------------------------------------------------------
0000F45A                            
0000F45A                            dPlaySnd_FadeOut:
0000F45A 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0000F45E                            
0000F45E                            dLoadFade:
0000F45E 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0000F462 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000F466 6700                       		beq.s	.nofade			; if not, load fade as is
0000F468                            
0000F468 2449                       		move.l	a1,a2			; copy fade program address to a2
0000F46A 74FF                       		moveq	#-1,d2			; prepare max byter difference
0000F46C                            
0000F46C                            .find
0000F46C 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0000F46E 6A00                       		bpl.s	.search			; branch if this is not a command
0000F470                            
0000F470                            .nofade
0000F470 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0000F474 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0000F478 4E75                       		rts
0000F47A                            
0000F47A                            .search
0000F47A 568A                       		addq.l	#3,a2			; skip over the current volume group
0000F47C 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0000F47E 6A00                       		bpl.s	.abs			; if positive, do not negate
0000F480 4401                       		neg.b	d1			; negative to positive
0000F482                            
0000F482                            .abs
0000F482 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0000F484 64E6                       		bhs.s	.find			; if not, read next group
0000F486                            
0000F486 1401                       		move.b	d1,d2			; else save the new difference
0000F488 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0000F48A 60E0                       		bra.s	.find			; loop through each group in the program
0000F48C                            ; ===========================================================================
0000F48C                            ; ---------------------------------------------------------------------------
0000F48C                            ; Routine for loading a volume filter into Dual PCM ROM.
0000F48C                            ; This routine will actually write the bank number the volume filter
0000F48C                            ; is in. This requires volume filters are aligned to Z80 banks, and
0000F48C                            ; just because we can, we write 9 bits (yeah its not necessary, but
0000F48C                            ; what the hell, you have to have fun sometimes!)
0000F48C                            ; ---------------------------------------------------------------------------
0000F48C                            
0000F48C                            dSetFilter:
0000F48C 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0000F492 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0000F494 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0000F496                            	StopZ80					; wait for Z80 to stop
0000F496 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F49E                          M 	waitz80stop
0000F49E 0839 0000 00A1 1100      M .wait_625:	btst	#0,z80_bus_req
0000F4A6 66F6                     M 	bne.s	.wait_625
0000F4A8                            ; ---------------------------------------------------------------------------
0000F4A8                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0000F4A8                            ; a register AND the carry to another register. What this means, is if
0000F4A8                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0000F4A8                            ; of $74 into the carry, making us able to switch between the Z80
0000F4A8                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0000F4A8                            ; Dual PCM to bank switch into the appropriate bank.
0000F4A8                            ; ---------------------------------------------------------------------------
0000F4A8                            
0000F4A8                            .loop
0000F4A8 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0000F4AA E248                       		lsr.w	#1,d0			; shift lsb into carry
0000F4AC D701                       		addx.b	d1,d3			; add instruction and carry into d3
0000F4AE                            
0000F4AE 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0000F4B0 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0000F4B4                            	StartZ80				; enable Z80 execution
0000F4B4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F4BC 4E75                       		rts
0000F4BE                            
0000F4BE                            ; ===========================================================================
0000F4BE                            ; ---------------------------------------------------------------------------
0000F4BE                            ; Routine for resetting master volumes, filters and disabling fading
0000F4BE                            ; ---------------------------------------------------------------------------
0000F4BE                            
0000F4BE                            dResetVolume:
0000F4BE 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0000F4C2 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0000F4C6 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0000F4CA 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0000F4CE 61BC                       		bsr.s	dSetFilter		; load filter instructions
0000F4D0                            
0000F4D0                            dUpdateVolumeAll:
0000F4D0 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0000F4D2 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0000F4D6                            
0000F4D6 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000F4D6                            	rept Mus_DAC				; loop through all music DAC channels
0000F4D6                            		or.b	d0,.ch.w		; request channel volume update
0000F4D6                            .ch =		.ch+cSize			; go to next channel
0000F4D6                            	endr
0000F4D6 8138 C4C4                M 	or.b	d0,.ch.w
0000F4DA =FFFFC4F0                M .ch	=	.ch+csize
0000F4DA 8138 C4F0                M 	or.b	d0,.ch.w
0000F4DE =FFFFC51C                M .ch	=	.ch+csize
0000F4DE                            
0000F4DE =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000F4DE                            	rept Mus_PSG				; loop through all music PSG channels
0000F4DE                            		or.b	d0,.ch.w		; request channel volume update
0000F4DE                            .ch =		.ch+cSize			; go to next channel
0000F4DE                            	endr
0000F4DE 8138 C5F8                M 	or.b	d0,.ch.w
0000F4E2 =FFFFC624                M .ch	=	.ch+csize
0000F4E2 8138 C624                M 	or.b	d0,.ch.w
0000F4E6 =FFFFC650                M .ch	=	.ch+csize
0000F4E6 8138 C650                M 	or.b	d0,.ch.w
0000F4EA =FFFFC67C                M .ch	=	.ch+csize
0000F4EA                            
0000F4EA =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000F4EA                            	rept SFX_PSG				; loop through all SFX PSG channels
0000F4EA                            		or.b	d0,.ch.w		; request channel volume update
0000F4EA                            .ch =		.ch+cSizeSFX			; go to next channel
0000F4EA                            	endr
0000F4EA 8138 C6EC                M 	or.b	d0,.ch.w
0000F4EE =FFFFC708                M .ch	=	.ch+csizesfx
0000F4EE 8138 C708                M 	or.b	d0,.ch.w
0000F4F2 =FFFFC724                M .ch	=	.ch+csizesfx
0000F4F2 8138 C724                M 	or.b	d0,.ch.w
0000F4F6 =FFFFC740                M .ch	=	.ch+csizesfx
0000F4F6 4E75                       		rts
0000F4F8                            ; ===========================================================================
0000F4F8                            ; ---------------------------------------------------------------------------
0000F4F8                            ; Enable speed shoes mode
0000F4F8                            ; ---------------------------------------------------------------------------
0000F4F8                            
0000F4F8                            dPlaySnd_ShoesOn:
0000F4F8 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0000F4FE 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0000F504 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0000F50A 4E75                       		rts
0000F50C                            ; ===========================================================================
0000F50C                            ; ---------------------------------------------------------------------------
0000F50C                            ; Reset music flags (underwater mode and tempo mode)
0000F50C                            ; ---------------------------------------------------------------------------
0000F50C                            
0000F50C                            dPlaySnd_Reset:
0000F50C 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0000F50E                            ; ===========================================================================
0000F50E                            ; ---------------------------------------------------------------------------
0000F50E                            ; Disable speed shoes mode
0000F50E                            ; ---------------------------------------------------------------------------
0000F50E                            
0000F50E                            dPlaySnd_ShoesOff:
0000F50E 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0000F514 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0000F51A 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0000F520 4E75                       		rts
0000F522                            ; ===========================================================================
0000F522                            ; ---------------------------------------------------------------------------
0000F522                            ; Enable Underwater mode
0000F522                            ; ---------------------------------------------------------------------------
0000F522                            
0000F522                            dPlaySnd_ToWater:
0000F522 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0000F528 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0000F52A                            ; ===========================================================================
0000F52A                            ; ---------------------------------------------------------------------------
0000F52A                            ; Disable Underwater mode
0000F52A                            ; ---------------------------------------------------------------------------
0000F52A                            
0000F52A                            dPlaySnd_OutWater:
0000F52A 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0000F530                            ; ===========================================================================
0000F530                            ; ---------------------------------------------------------------------------
0000F530                            ; force volume update on all FM channels
0000F530                            ; ---------------------------------------------------------------------------
0000F530                            
0000F530                            dReqVolUpFM;
0000F530 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0000F532 =FFFFC51C                  .ch =	mFM1					; start at FM1
0000F532                            	rept Mus_FM				; loop through all music FM channels
0000F532                            		or.b	d0,.ch.w		; request channel volume update
0000F532                            .ch =		.ch+cSize			; go to next channel
0000F532                            	endr
0000F532 8138 C51C                M 	or.b	d0,.ch.w
0000F536 =FFFFC548                M .ch	=	.ch+csize
0000F536 8138 C548                M 	or.b	d0,.ch.w
0000F53A =FFFFC574                M .ch	=	.ch+csize
0000F53A 8138 C574                M 	or.b	d0,.ch.w
0000F53E =FFFFC5A0                M .ch	=	.ch+csize
0000F53E 8138 C5A0                M 	or.b	d0,.ch.w
0000F542 =FFFFC5CC                M .ch	=	.ch+csize
0000F542 8138 C5CC                M 	or.b	d0,.ch.w
0000F546 =FFFFC5F8                M .ch	=	.ch+csize
0000F546                            
0000F546 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0000F546                            	rept SFX_FM				; loop through all SFX FM channels
0000F546                            		or.b	d0,.ch.w		; request channel volume update
0000F546                            .ch =		.ch+cSizeSFX			; go to next channel
0000F546                            	endr
0000F546 8138 C698                M 	or.b	d0,.ch.w
0000F54A =FFFFC6B4                M .ch	=	.ch+csizesfx
0000F54A 8138 C6B4                M 	or.b	d0,.ch.w
0000F54E =FFFFC6D0                M .ch	=	.ch+csizesfx
0000F54E 8138 C6D0                M 	or.b	d0,.ch.w
0000F552 =FFFFC6EC                M .ch	=	.ch+csizesfx
0000F552 4E75                       		rts
0000F554                            ; ===========================================================================
0000F554                            ; ---------------------------------------------------------------------------
0000F554                            ; Subroutine for updating Total Levels for FM channel
0000F554                            ; ---------------------------------------------------------------------------
0000F554                            
0000F554                            dUpdateVolFM:
0000F554 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F558 6600                       		bne.s	locret_VolFM		; if yes, do not update
0000F55A                            
0000F55A 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0000F55E D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0000F562 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0000F564 767F                       		moveq	#$7F,d3			; force FM volume to silence
0000F566                            
0000F566                            .noover
0000F566 7000                       		moveq	#0,d0
0000F568 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0000F56C 224E                       		move.l	a6,a1			; copy music voice table address to a1
0000F56E                            
0000F56E                            	dCALC_VOICE				; get address of the specific voice to a1
0000F56E EB48                     M 	lsl.w	#5,d0
0000F570 D2C0                     M 	add.w	d0,a1
0000F572 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0000F574 7C00                       		moveq	#0,d6			; reset the modulator offset
0000F576                            
0000F576 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0000F57C 6700                       		beq.s	.uwdone			; if not, skip
0000F57E 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0000F580 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0000F584 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0000F586 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0000F588                            
0000F588                            .uwdone
0000F588 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0000F58A D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0000F58E 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0000F592                            
0000F592                            .tlloop
0000F592 101A                       		move.b	(a2)+,d0		; load YM address to write to
0000F594 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0000F596 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0000F598                            
0000F598 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0000F59A 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0000F59C 727F                       		moveq	#$7F,d1			; cap to silent volume
0000F59E 6000                       		bra.s	.slot
0000F5A0                            
0000F5A0                            .noslot
0000F5A0 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0000F5A2                            .slot
0000F5A2 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0000F5A6                            .ignore
0000F5A6 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0000F5AA                            
0000F5AA                            		AMPS_Debug_UpdVolFM		; check if the voice was valid
0000F5AA 0C19 004E                M 	cmp.b	#'N',(a1)+
0000F5AE 6600                     M 	bne.s	.fail
0000F5B0 0C59 4154                M 	cmp.w	#'AT',(a1)+
0000F5B4 6700                     M 	beq.s	.ok
0000F5B6                          M .fail
0000F5B6 4EBA EA80                M 	jsr	amps_debugr_updvolfm
0000F5BA                          M .ok
0000F5BA                            
0000F5BA                            locret_VolFM:
0000F5BA 4E75                       		rts
0000F5BC                            ; ===========================================================================
0000F5BC                            ; ---------------------------------------------------------------------------
0000F5BC                            ; YM2612 register update list
0000F5BC                            ; ---------------------------------------------------------------------------
0000F5BC                            
0000F5BC 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0000F5C0 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0000F5C4 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0000F5C8 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0000F5CC 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0000F5D0 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0000F5D4 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0000F5D8                            ; ===========================================================================
0000F5D8                            ; ---------------------------------------------------------------------------
0000F5D8                            ; Process SFX FM channels
0000F5D8                            ; ---------------------------------------------------------------------------
0000F5D8                            
0000F5D8                            dAMPSdoFMSFX:
0000F5D8 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0000F5DC 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0000F5DE                            
0000F5DE                            dAMPSnextFMSFX:
0000F5DE DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000F5E2 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F5E4 6A00 0000                  		bpl.w	.next			; if not, branch
0000F5E8 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F5EC 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F5F0                            
0000F5F0                            	dCalcFreq				; calculate channel base frequency
0000F5F0 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F5F4 4886                     M 	ext.w	d6
0000F5F6 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F5FA                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0000F5FA 0815 0003                M 	btst	#cfbmod,(a5)
0000F5FE 6700                     M 	beq.s	.noret
0000F600 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F604 6700                     M 	beq.s	.started
0000F606 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F60A                          M .noret
0000F60A 0895 0005                M 	bclr	#cfbvol,(a5)
0000F60E 6700                     M 	beq.s	.noupdatevol
0000F610 4EBA FF42                M 	jsr	dupdatevolfm(pc)
0000F614                          M 	.noupdatevol:
0000F614 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0000F618 6000 0000                M 	bra.w	dampsdopsgsfx
0000F61C                          M .started
0000F61C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F620 66E8                     M 	bne.s	.noret
0000F622 226D 0010                M 	movea.l	cmod(a5),a1
0000F626 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F62C 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F630 6600                     M 	bne.s	.norev
0000F632 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F638 442D 0017                M 	neg.b	cmodstep(a5)
0000F63C                          M .norev
0000F63C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F640 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F644 4885                     M 	ext.w	d5
0000F646 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F64A 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F64E DC45                     M 	add.w	d5,d6
0000F650 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0000F654                            
0000F654 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F658 6700                       		beq.s	.next			; if not, skip
0000F65A 4EBA FEF8                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F65E                            
0000F65E                            .next
0000F65E 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F662 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F666                            
0000F666                            .update
0000F666 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F66A                            	dDoTracker				; process tracker
0000F66A 286D 0002                M 	movea.l	cdata(a5),a4
0000F66E                          M 	amps_debug_trackupd
0000F66E 220C                     M 	move.l	a4,d1
0000F670 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F676 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F67C 6500                     M 	blo.s	.fail2
0000F67E 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F684 6500                     M 	blo.s	.data
0000F686                          M .fail2
0000F686                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F686 487A FFFE                M 	pea	*(pc)
0000F68A                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F68A 40E7                     M 	move.w	sr,-(sp)
0000F68C                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F68C =00000000                M 	__stack:set	0
0000F68C =00000000                M 	__sp:	set 0
0000F68C                          M 	while	(__pos)
0000F68C =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F68C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F68C =00000021                M 	__midpos:	= __endpos
0000F68C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	pushp	"move.l a4,-(sp)"
0000F68C =00000001                M 	__stack:	= __stack+1
0000F68C =00000004                M 	__sp:	= __sp+4
0000F68C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F68C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F68C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F68C =00000029                M 	__midpos:	= __endpos
0000F68C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F68C =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F68C =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F68C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F68C                          M 	pushp	"move.l a4,-(sp)"
0000F68C =00000002                M 	__stack:	= __stack+1
0000F68C =00000008                M 	__sp:	= __sp+4
0000F68C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F68C                          M 	rept	__stack
0000F68C                          M 	popp	__command
0000F68C 2F0C                     M 	move.l	a4,-(sp)
0000F68E                          M 	popp	__command
0000F68E 2F0C                     M 	move.l	a4,-(sp)
0000F690 4EB9 0000 0000           M 	jsr	errorhandler
0000F696                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F696 =00000001                M 	__lpos:	set 1
0000F696 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F696                          M 	while	(__pos)
0000F696                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F696 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F6AF =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F6AF =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F6AF =00000021                M 	__midpos:	= __endpos
0000F6AF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6AF                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6AF                          M 	__param:	substr ,,"hex"
0000F6AF 83                       M 	dc.b	hex|3
0000F6B0 =00000022                M 	__lpos:	set __endpos+1
0000F6B0 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F6B0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B0                          M 	dc.b	""
0000F6B0 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F6B0 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F6B0 =00000029                M 	__midpos:	= __endpos
0000F6B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B0 E0                       M 	dc.b	fendl
0000F6B1 =0000002A                M 	__lpos:	set __endpos+1
0000F6B1 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F6B1                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B1                          M 	dc.b	""
0000F6B1 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F6B1 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F6B1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B1                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B1 B3                       M 	dc.b	sym|3
0000F6B2 =00000036                M 	__lpos:	set __endpos+1
0000F6B2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F6B2                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F6B2                          M 	dc.b	""
0000F6B2 00                       M 	dc.b	0
0000F6B3 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F6B4                          M 	even
0000F6B4 4EFA DC96                M 	jmp	amps_debug_console_channel
0000F6B8                          M 	even
0000F6B8                          M .data
0000F6B8 7A00                     M 	moveq	#0,d5
0000F6BA 1A1C                     M 	move.b	(a4)+,d5
0000F6BC 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F6C0 6500                     M 	blo.s	.notcomm
0000F6C2 4EBA 0000                M 	jsr	dcommands(pc)
0000F6C6 60F0                     M 	bra.s	.data
0000F6C8 6094                     M 	bra.s	.next
0000F6CA                          M .notcomm
0000F6CA 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0000F6CE 4A05                       		tst.b	d5			; check if note is being played
0000F6D0 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F6D2                            
0000F6D2 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F6D6 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F6D8 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F6DA 534C                       		subq.w	#1,a4			; if not, then return back
0000F6DC 6000                       		bra.s	.pcnote			; do some extra clearing
0000F6DE                            
0000F6DE                            .timer
0000F6DE 4EBA F330                  		jsr	dCalcDuration(pc)	; calculate duration
0000F6E2                            .pcnote
0000F6E2                            	dProcNote 1, 0				; reset necessary channel memory
0000F6E2 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F6E6 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F6EC 0815 0002                M 	btst	#cfbhold,(a5)
0000F6F0 6600                     M 	bne.s	.endpn
0000F6F2 0815 0003                M 	btst	#cfbmod,(a5)
0000F6F6 6700                     M 	beq.s	.endpn
0000F6F8 226D 0010                M 	movea.l	cmod(a5),a1
0000F6FC 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F700 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F704 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F708 1011                     M 	move.b	(a1),d0
0000F70A E208                     M 	lsr.b	#1,d0
0000F70C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F710 426D 0014                M 	clr.w	cmodfreq(a5)
0000F714                          M .endpn
0000F714 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0000F718                            	dKeyOnFM 1				; send key-on command to YM
0000F718 0815 0002                M 	btst	#cfbhold,(a5)
0000F71C 6600                     M 	bne.s	.k
0000F71E 0815 0000                M 	btst	#cfbrest,(a5)
0000F722 6600                     M 	bne.s	.k
0000F724 7028                     M 	moveq	#$28,d0
0000F726 122D 0001                M 	move.b	ctype(a5),d1
0000F72A 0001 00F0                M 	ori.b	#$f0,d1
0000F72E 6100 0000                M 	bsr.w	writeym_pt1
0000F732                          M .k
0000F732                            
0000F732 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F736 6700                       		beq.s	.noupdate		; if not, branch
0000F738 4EBA FE1A                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F73C                            
0000F73C 51CF FEA0                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F740 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F744                            ; ===========================================================================
0000F744                            ; ---------------------------------------------------------------------------
0000F744                            ; Process music FM channels
0000F744                            ; ---------------------------------------------------------------------------
0000F744                            
0000F744                            dAMPSdoFM:
0000F744 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0000F748 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0000F74A                            
0000F74A                            dAMPSnextFM:
0000F74A DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0000F74E 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F750 6A00 0000                  		bpl.w	.next			; if not, branch
0000F754 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F758 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F75C                            
0000F75C                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0000F75C                          M 	dnotetouthandler
0000F75C 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000F760 6700                     M 	beq.s	.endt
0000F762 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000F766 6600                     M 	bne.s	.endt
0000F768 08D5 0000                M 	bset	#cfbrest,(a5)
0000F76C 6100 0000                M 	bsr.w	dkeyofffm
0000F770 6000 0000                M 	bra.w	.next
0000F774                          M .endt
0000F774                            	dCalcFreq				; calculate channel base frequency
0000F774 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F778 4886                     M 	ext.w	d6
0000F77A DC6D 000E                M 	add.w	cfreq(a5),d6
0000F77E                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0000F77E 0815 0003                M 	btst	#cfbmod,(a5)
0000F782 6700                     M 	beq.s	.noret
0000F784 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F788 6700                     M 	beq.s	.started
0000F78A 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F78E                          M .noret
0000F78E 0895 0005                M 	bclr	#cfbvol,(a5)
0000F792 6700                     M 	beq.s	.noupdatevol
0000F794 4EBA FDBE                M 	jsr	dupdatevolfm(pc)
0000F798                          M 	.noupdatevol:
0000F798 51CF FFB0                M 	dbf	d7,dampsnextfm
0000F79C 6000 0000                M 	bra.w	dampsdopsg
0000F7A0                          M .started
0000F7A0 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F7A4 66E8                     M 	bne.s	.noret
0000F7A6 226D 0010                M 	movea.l	cmod(a5),a1
0000F7AA 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F7B0 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F7B4 6600                     M 	bne.s	.norev
0000F7B6 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F7BC 442D 0017                M 	neg.b	cmodstep(a5)
0000F7C0                          M .norev
0000F7C0 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F7C4 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F7C8 4885                     M 	ext.w	d5
0000F7CA DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F7CE 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F7D2 DC45                     M 	add.w	d5,d6
0000F7D4 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0000F7D8                            
0000F7D8 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F7DC 6700                       		beq.s	.next			; if not, skip
0000F7DE 4EBA FD74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F7E2                            
0000F7E2                            .next
0000F7E2 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F7E6 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F7EA                            
0000F7EA                            .update
0000F7EA 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F7EE                            	dDoTracker				; process tracker
0000F7EE 286D 0002                M 	movea.l	cdata(a5),a4
0000F7F2                          M 	amps_debug_trackupd
0000F7F2 220C                     M 	move.l	a4,d1
0000F7F4 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F7FA 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F800 6500                     M 	blo.s	.fail2
0000F802 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F808 6500                     M 	blo.s	.data
0000F80A                          M .fail2
0000F80A                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F80A 487A FFFE                M 	pea	*(pc)
0000F80E                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F80E 40E7                     M 	move.w	sr,-(sp)
0000F810                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F810 =00000000                M 	__stack:set	0
0000F810 =00000000                M 	__sp:	set 0
0000F810                          M 	while	(__pos)
0000F810 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F810 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F810 =00000021                M 	__midpos:	= __endpos
0000F810                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	pushp	"move.l a4,-(sp)"
0000F810 =00000001                M 	__stack:	= __stack+1
0000F810 =00000004                M 	__sp:	= __sp+4
0000F810 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F810 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F810 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F810 =00000029                M 	__midpos:	= __endpos
0000F810                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F810 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F810 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F810                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F810                          M 	pushp	"move.l a4,-(sp)"
0000F810 =00000002                M 	__stack:	= __stack+1
0000F810 =00000008                M 	__sp:	= __sp+4
0000F810 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F810                          M 	rept	__stack
0000F810                          M 	popp	__command
0000F810 2F0C                     M 	move.l	a4,-(sp)
0000F812                          M 	popp	__command
0000F812 2F0C                     M 	move.l	a4,-(sp)
0000F814 4EB9 0000 0000           M 	jsr	errorhandler
0000F81A                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F81A =00000001                M 	__lpos:	set 1
0000F81A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F81A                          M 	while	(__pos)
0000F81A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F81A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F833 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F833 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F833 =00000021                M 	__midpos:	= __endpos
0000F833                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F833                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F833                          M 	__param:	substr ,,"hex"
0000F833 83                       M 	dc.b	hex|3
0000F834 =00000022                M 	__lpos:	set __endpos+1
0000F834 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F834                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F834                          M 	dc.b	""
0000F834 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F834 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F834 =00000029                M 	__midpos:	= __endpos
0000F834                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F834                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F834 E0                       M 	dc.b	fendl
0000F835 =0000002A                M 	__lpos:	set __endpos+1
0000F835 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F835                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F835                          M 	dc.b	""
0000F835 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F835 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F835                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F835                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F835 B3                       M 	dc.b	sym|3
0000F836 =00000036                M 	__lpos:	set __endpos+1
0000F836 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F836                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F836                          M 	dc.b	""
0000F836 00                       M 	dc.b	0
0000F837 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F838                          M 	even
0000F838 4EFA DB12                M 	jmp	amps_debug_console_channel
0000F83C                          M 	even
0000F83C                          M .data
0000F83C 7A00                     M 	moveq	#0,d5
0000F83E 1A1C                     M 	move.b	(a4)+,d5
0000F840 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F844 6500                     M 	blo.s	.notcomm
0000F846 4EBA 0000                M 	jsr	dcommands(pc)
0000F84A 60F0                     M 	bra.s	.data
0000F84C 6094                     M 	bra.s	.next
0000F84E                          M .notcomm
0000F84E 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0000F852 4A05                       		tst.b	d5			; check if note is being played
0000F854 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F856                            
0000F856 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F85A 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F85C 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F85E 534C                       		subq.w	#1,a4			; if not, then return back
0000F860 6000                       		bra.s	.pcnote			; do some extra clearing
0000F862                            
0000F862                            .timer
0000F862 4EBA F1AC                  		jsr	dCalcDuration(pc)	; calculate duration
0000F866                            .pcnote
0000F866                            	dProcNote 0, 0				; reset necessary channel memory
0000F866 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F86A 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F870 0815 0002                M 	btst	#cfbhold,(a5)
0000F874 6600                     M 	bne.s	.endpn
0000F876 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000F87C 0815 0003                M 	btst	#cfbmod,(a5)
0000F880 6700                     M 	beq.s	.endpn
0000F882 226D 0010                M 	movea.l	cmod(a5),a1
0000F886 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F88A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F88E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F892 1011                     M 	move.b	(a1),d0
0000F894 E208                     M 	lsr.b	#1,d0
0000F896 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F89A 426D 0014                M 	clr.w	cmodfreq(a5)
0000F89E                          M .endpn
0000F89E 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0000F8A0                            	dKeyOnFM				; send key-on command to YM
0000F8A0 0815 0002                M 	btst	#cfbhold,(a5)
0000F8A4 6600                     M 	bne.s	.k
0000F8A6 0815 0000                M 	btst	#cfbrest,(a5)
0000F8AA 6600                     M 	bne.s	.k
0000F8AC 0815 0001                M 	btst	#cfbint,(a5)
0000F8B0 6600                     M 	bne.s	.k
0000F8B2 7028                     M 	moveq	#$28,d0
0000F8B4 122D 0001                M 	move.b	ctype(a5),d1
0000F8B8 0001 00F0                M 	ori.b	#$f0,d1
0000F8BC 6100 0000                M 	bsr.w	writeym_pt1
0000F8C0                          M .k
0000F8C0                            
0000F8C0 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F8C4 6700                       		beq.s	.noupdate		; if not, branch
0000F8C6 4EBA FC8C                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F8CA                            
0000F8CA                            .noupdate
0000F8CA 51CF FE7E                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F8CE 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F8D2                            ; ===========================================================================
0000F8D2                            ; ---------------------------------------------------------------------------
0000F8D2                            ; Write FM frequency to Dual PCM YMCue
0000F8D2                            ; ---------------------------------------------------------------------------
0000F8D2                            
0000F8D2                            dUpdateFreqFM:
0000F8D2 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000F8D6 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0000F8D8 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0000F8DC 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0000F8DE                            
0000F8DE 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0000F8E2 4880                       		ext.w	d0			; extend to word
0000F8E4 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0000F8E6                            
0000F8E6 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000F8EA 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0000F8EC DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0000F8F0                            
0000F8F0                            dUpdateFreqFM2:
0000F8F0 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F8F4 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0000F8F6                            
0000F8F6                            dUpdateFreqFM3:
0000F8F6 3206                       		move.w	d6,d1			; copy frequency to d1
0000F8F8 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0000F8FA 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0000F8FC 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F900                            
0000F900 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0000F902 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0000F906 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0000F90A                            
0000F90A                            dUpdFreqFMrest:
0000F90A 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F90E                            
0000F90E                            locret_UpdFreqFM:
0000F90E 4E75                       		rts
0000F910                            ; ===========================================================================
0000F910                            ; ---------------------------------------------------------------------------
0000F910                            ; Process a note in FM channel (enable resting or get frequency)
0000F910                            ; ---------------------------------------------------------------------------
0000F910                            
0000F910                            dGetFreqFM:
0000F910 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000F914 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0000F916 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F91A 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0000F91E 4E75                       		rts
0000F920                            
0000F920                            .norest
0000F920 DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0000F924 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0000F928 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0000F92A                            
0000F92A 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0000F92E 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000F934                            
0000F934                            		AMPS_Debug_NoteFM		; check if the note was valid
0000F934 0C05 0000                M 	cmp.b	#dfreqfm_-dfreqfm,d5
0000F938 6500                     M 	blo.s	.ok
0000F93A                          M .fail
0000F93A 4EBA E6A2                M 	jsr	amps_debugr_notefm
0000F93E                          M .ok
0000F93E 4E75                       		rts
0000F940                            ; ===========================================================================
0000F940                            ; ---------------------------------------------------------------------------
0000F940                            ; Subroutine for doing keying-off FM channel
0000F940                            ; ---------------------------------------------------------------------------
0000F940                            
0000F940                            dKeyOffFM:
0000F940 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0000F944 66C8                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F946                            
0000F946                            dKeyOffFM2:
0000F946 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000F94A 66C2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F94C                            
0000F94C 7028                       		moveq	#$28,d0			; YM command: Key on
0000F94E 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0000F952 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0000F954                            ; ===========================================================================
0000F954                            ; ---------------------------------------------------------------------------
0000F954                            ; Write to YMCue according to channel and check if interrupted by sfx
0000F954                            ; ---------------------------------------------------------------------------
0000F954                            
0000F954                            dWriteYMchnInt:
0000F954 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0000F958 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0000F95A                            ; ===========================================================================
0000F95A                            ; ---------------------------------------------------------------------------
0000F95A                            ; Write to YMCue according to channel
0000F95A                            ; ---------------------------------------------------------------------------
0000F95A                            
0000F95A                            WriteChYM:
0000F95A 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0000F960 6600                       		bne.s	WriteChYM2		; if part 2, branch
0000F962 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0000F966                            ; ===========================================================================
0000F966                            ; ---------------------------------------------------------------------------
0000F966                            ; Write to YMCue using part 1
0000F966                            ; ---------------------------------------------------------------------------
0000F966                            
0000F966                            WriteYM_Pt1:
0000F966                            		AMPS_Debug_CuePtr 1		; check if cue pointer is valid
0000F966 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F96C 6500                     M 	blo.s	.fail_652
0000F96E B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F974 6500                     M 	blo.s	.ok_652
0000F976                          M .fail_652
0000F976 4EBA E6F8                M 	jsr	amps_debug_cueptr1
0000F97A                          M .ok_652
0000F97A                            	StopZ80					; wait for Z80 to stop
0000F97A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F982                          M 	waitz80stop
0000F982 0839 0000 00A1 1100      M .wait_654:	btst	#0,z80_bus_req
0000F98A 66F6                     M 	bne.s	.wait_654
0000F98C 51D8                       		sf	(a0)+			; set YM port address as 0
0000F98E 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F990 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F992                            	;	st	(a0)			; mark as the end of the cue data
0000F992                            	StartZ80				; enable Z80 execution
0000F992 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F99A                            
0000F99A                            WriteYM_Pt1_rts:
0000F99A 4E75                       		rts
0000F99C                            ; ===========================================================================
0000F99C                            ; ---------------------------------------------------------------------------
0000F99C                            ; Write to YMCue according to channel in part 2
0000F99C                            ; ---------------------------------------------------------------------------
0000F99C                            
0000F99C                            WriteChYM2:
0000F99C 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0000F9A0 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0000F9A4 D002                       		add.b	d2,d0			; add to YM address
0000F9A6                            ; ===========================================================================
0000F9A6                            ; ---------------------------------------------------------------------------
0000F9A6                            ; Write to YMCue using part 2
0000F9A6                            ; ---------------------------------------------------------------------------
0000F9A6                            
0000F9A6                            WriteYM_Pt2:
0000F9A6                            		AMPS_Debug_CuePtr 2		; check if cue pointer is valid
0000F9A6 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F9AC 6500                     M 	blo.s	.fail_656
0000F9AE B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F9B4 6500                     M 	blo.s	.ok_656
0000F9B6                          M .fail_656
0000F9B6 4EBA E6E6                M 	jsr	amps_debug_cueptr2
0000F9BA                          M .ok_656
0000F9BA                            	StopZ80					; wait for Z80 to stop
0000F9BA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F9C2                          M 	waitz80stop
0000F9C2 0839 0000 00A1 1100      M .wait_658:	btst	#0,z80_bus_req
0000F9CA 66F6                     M 	bne.s	.wait_658
0000F9CC 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0000F9D0 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F9D2 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F9D4                            	;	st	(a0)			; mark as the end of the cue data
0000F9D4                            	StartZ80				; enable Z80 execution
0000F9D4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F9DC 4E75                       		rts
0000F9DE                            ; ===========================================================================
0000F9DE                            ; ---------------------------------------------------------------------------
0000F9DE                            ; Note to FM frequency conversion table
0000F9DE                            ; ---------------------------------------------------------------------------
0000F9DE                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F9DE 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0000F9E0 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0000F9F8 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0000FA10 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0000FA28 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0000FA40 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0000FA58 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0000FA70 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0000FA88 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0000FA9E                            dFreqFM_:
0000FA9E =00000160                  .x = $100|((dFreqFM_-dFreqFM)/2)		; to check if we played an invalid note
0000FA9E                            		rept $80-((dFreqFM_-dFreqFM)/2)	; and if so, tell us which note it was
0000FA9E                            			dc.w .x
0000FA9E                            .x =			.x+$101
0000FA9E                            		endr
0000FA9E 0160                     M 	dc.w	.x
0000FAA0 =00000261                M .x	=	.x+$101
0000FAA0 0261                     M 	dc.w	.x
0000FAA2 =00000362                M .x	=	.x+$101
0000FAA2 0362                     M 	dc.w	.x
0000FAA4 =00000463                M .x	=	.x+$101
0000FAA4 0463                     M 	dc.w	.x
0000FAA6 =00000564                M .x	=	.x+$101
0000FAA6 0564                     M 	dc.w	.x
0000FAA8 =00000665                M .x	=	.x+$101
0000FAA8 0665                     M 	dc.w	.x
0000FAAA =00000766                M .x	=	.x+$101
0000FAAA 0766                     M 	dc.w	.x
0000FAAC =00000867                M .x	=	.x+$101
0000FAAC 0867                     M 	dc.w	.x
0000FAAE =00000968                M .x	=	.x+$101
0000FAAE 0968                     M 	dc.w	.x
0000FAB0 =00000A69                M .x	=	.x+$101
0000FAB0 0A69                     M 	dc.w	.x
0000FAB2 =00000B6A                M .x	=	.x+$101
0000FAB2 0B6A                     M 	dc.w	.x
0000FAB4 =00000C6B                M .x	=	.x+$101
0000FAB4 0C6B                     M 	dc.w	.x
0000FAB6 =00000D6C                M .x	=	.x+$101
0000FAB6 0D6C                     M 	dc.w	.x
0000FAB8 =00000E6D                M .x	=	.x+$101
0000FAB8 0E6D                     M 	dc.w	.x
0000FABA =00000F6E                M .x	=	.x+$101
0000FABA 0F6E                     M 	dc.w	.x
0000FABC =0000106F                M .x	=	.x+$101
0000FABC 106F                     M 	dc.w	.x
0000FABE =00001170                M .x	=	.x+$101
0000FABE 1170                     M 	dc.w	.x
0000FAC0 =00001271                M .x	=	.x+$101
0000FAC0 1271                     M 	dc.w	.x
0000FAC2 =00001372                M .x	=	.x+$101
0000FAC2 1372                     M 	dc.w	.x
0000FAC4 =00001473                M .x	=	.x+$101
0000FAC4 1473                     M 	dc.w	.x
0000FAC6 =00001574                M .x	=	.x+$101
0000FAC6 1574                     M 	dc.w	.x
0000FAC8 =00001675                M .x	=	.x+$101
0000FAC8 1675                     M 	dc.w	.x
0000FACA =00001776                M .x	=	.x+$101
0000FACA 1776                     M 	dc.w	.x
0000FACC =00001877                M .x	=	.x+$101
0000FACC 1877                     M 	dc.w	.x
0000FACE =00001978                M .x	=	.x+$101
0000FACE 1978                     M 	dc.w	.x
0000FAD0 =00001A79                M .x	=	.x+$101
0000FAD0 1A79                     M 	dc.w	.x
0000FAD2 =00001B7A                M .x	=	.x+$101
0000FAD2 1B7A                     M 	dc.w	.x
0000FAD4 =00001C7B                M .x	=	.x+$101
0000FAD4 1C7B                     M 	dc.w	.x
0000FAD6 =00001D7C                M .x	=	.x+$101
0000FAD6 1D7C                     M 	dc.w	.x
0000FAD8 =00001E7D                M .x	=	.x+$101
0000FAD8 1E7D                     M 	dc.w	.x
0000FADA =00001F7E                M .x	=	.x+$101
0000FADA 1F7E                     M 	dc.w	.x
0000FADC =0000207F                M .x	=	.x+$101
0000FADC 207F                     M 	dc.w	.x
0000FADE =00002180                M .x	=	.x+$101
0000FADE                            ; ===========================================================================
0000FADE                            ; ---------------------------------------------------------------------------
0000FADE                            ; Note to Dual PCM frequency conversion table
0000FADE                            ; ---------------------------------------------------------------------------
0000FADE                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FADE 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0000FAE0 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0000FAF8 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0000FB10 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0000FB28 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0000FB40 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0000FB58 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0000FB70 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0000FB88 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0000FBA0 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0000FBB8 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0000FBD0 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0000FBDE                            
0000FBDE F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0000FBEE F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0000FC06 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0000FC1E F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0000FC36 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0000FC4E FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0000FC66 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0000FC7E FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0000FC96 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0000FCAE FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0000FCC6 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0000FCDE                            ; ===========================================================================
0000FCDE                            ; ---------------------------------------------------------------------------
0000FCDE                            ; Note to PSG frequency conversion table
0000FCDE                            ; ---------------------------------------------------------------------------
0000FCDE                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FCDE 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0000FCF6 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0000FD0E 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0000FD26 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0000FD3E 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0000FD56 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0000FD68 0000                       	dc.w  $0000								     ; Note (C6)
0000FD6A                            dFreqPSG_:
0000FD6A =00000146                  .x = $100|((dFreqPSG_-dFreqPSG)/2)		; to check if we played an invalid note
0000FD6A                            		rept $80-((dFreqPSG_-dFreqPSG)/2); and if so, tell us which note it was
0000FD6A                            			dc.w .x
0000FD6A                            .x =			.x+$101
0000FD6A                            		endr
0000FD6A 0146                     M 	dc.w	.x
0000FD6C =00000247                M .x	=	.x+$101
0000FD6C 0247                     M 	dc.w	.x
0000FD6E =00000348                M .x	=	.x+$101
0000FD6E 0348                     M 	dc.w	.x
0000FD70 =00000449                M .x	=	.x+$101
0000FD70 0449                     M 	dc.w	.x
0000FD72 =0000054A                M .x	=	.x+$101
0000FD72 054A                     M 	dc.w	.x
0000FD74 =0000064B                M .x	=	.x+$101
0000FD74 064B                     M 	dc.w	.x
0000FD76 =0000074C                M .x	=	.x+$101
0000FD76 074C                     M 	dc.w	.x
0000FD78 =0000084D                M .x	=	.x+$101
0000FD78 084D                     M 	dc.w	.x
0000FD7A =0000094E                M .x	=	.x+$101
0000FD7A 094E                     M 	dc.w	.x
0000FD7C =00000A4F                M .x	=	.x+$101
0000FD7C 0A4F                     M 	dc.w	.x
0000FD7E =00000B50                M .x	=	.x+$101
0000FD7E 0B50                     M 	dc.w	.x
0000FD80 =00000C51                M .x	=	.x+$101
0000FD80 0C51                     M 	dc.w	.x
0000FD82 =00000D52                M .x	=	.x+$101
0000FD82 0D52                     M 	dc.w	.x
0000FD84 =00000E53                M .x	=	.x+$101
0000FD84 0E53                     M 	dc.w	.x
0000FD86 =00000F54                M .x	=	.x+$101
0000FD86 0F54                     M 	dc.w	.x
0000FD88 =00001055                M .x	=	.x+$101
0000FD88 1055                     M 	dc.w	.x
0000FD8A =00001156                M .x	=	.x+$101
0000FD8A 1156                     M 	dc.w	.x
0000FD8C =00001257                M .x	=	.x+$101
0000FD8C 1257                     M 	dc.w	.x
0000FD8E =00001358                M .x	=	.x+$101
0000FD8E 1358                     M 	dc.w	.x
0000FD90 =00001459                M .x	=	.x+$101
0000FD90 1459                     M 	dc.w	.x
0000FD92 =0000155A                M .x	=	.x+$101
0000FD92 155A                     M 	dc.w	.x
0000FD94 =0000165B                M .x	=	.x+$101
0000FD94 165B                     M 	dc.w	.x
0000FD96 =0000175C                M .x	=	.x+$101
0000FD96 175C                     M 	dc.w	.x
0000FD98 =0000185D                M .x	=	.x+$101
0000FD98 185D                     M 	dc.w	.x
0000FD9A =0000195E                M .x	=	.x+$101
0000FD9A 195E                     M 	dc.w	.x
0000FD9C =00001A5F                M .x	=	.x+$101
0000FD9C 1A5F                     M 	dc.w	.x
0000FD9E =00001B60                M .x	=	.x+$101
0000FD9E 1B60                     M 	dc.w	.x
0000FDA0 =00001C61                M .x	=	.x+$101
0000FDA0 1C61                     M 	dc.w	.x
0000FDA2 =00001D62                M .x	=	.x+$101
0000FDA2 1D62                     M 	dc.w	.x
0000FDA4 =00001E63                M .x	=	.x+$101
0000FDA4 1E63                     M 	dc.w	.x
0000FDA6 =00001F64                M .x	=	.x+$101
0000FDA6 1F64                     M 	dc.w	.x
0000FDA8 =00002065                M .x	=	.x+$101
0000FDA8 2065                     M 	dc.w	.x
0000FDAA =00002166                M .x	=	.x+$101
0000FDAA 2166                     M 	dc.w	.x
0000FDAC =00002267                M .x	=	.x+$101
0000FDAC 2267                     M 	dc.w	.x
0000FDAE =00002368                M .x	=	.x+$101
0000FDAE 2368                     M 	dc.w	.x
0000FDB0 =00002469                M .x	=	.x+$101
0000FDB0 2469                     M 	dc.w	.x
0000FDB2 =0000256A                M .x	=	.x+$101
0000FDB2 256A                     M 	dc.w	.x
0000FDB4 =0000266B                M .x	=	.x+$101
0000FDB4 266B                     M 	dc.w	.x
0000FDB6 =0000276C                M .x	=	.x+$101
0000FDB6 276C                     M 	dc.w	.x
0000FDB8 =0000286D                M .x	=	.x+$101
0000FDB8 286D                     M 	dc.w	.x
0000FDBA =0000296E                M .x	=	.x+$101
0000FDBA 296E                     M 	dc.w	.x
0000FDBC =00002A6F                M .x	=	.x+$101
0000FDBC 2A6F                     M 	dc.w	.x
0000FDBE =00002B70                M .x	=	.x+$101
0000FDBE 2B70                     M 	dc.w	.x
0000FDC0 =00002C71                M .x	=	.x+$101
0000FDC0 2C71                     M 	dc.w	.x
0000FDC2 =00002D72                M .x	=	.x+$101
0000FDC2 2D72                     M 	dc.w	.x
0000FDC4 =00002E73                M .x	=	.x+$101
0000FDC4 2E73                     M 	dc.w	.x
0000FDC6 =00002F74                M .x	=	.x+$101
0000FDC6 2F74                     M 	dc.w	.x
0000FDC8 =00003075                M .x	=	.x+$101
0000FDC8 3075                     M 	dc.w	.x
0000FDCA =00003176                M .x	=	.x+$101
0000FDCA 3176                     M 	dc.w	.x
0000FDCC =00003277                M .x	=	.x+$101
0000FDCC 3277                     M 	dc.w	.x
0000FDCE =00003378                M .x	=	.x+$101
0000FDCE 3378                     M 	dc.w	.x
0000FDD0 =00003479                M .x	=	.x+$101
0000FDD0 3479                     M 	dc.w	.x
0000FDD2 =0000357A                M .x	=	.x+$101
0000FDD2 357A                     M 	dc.w	.x
0000FDD4 =0000367B                M .x	=	.x+$101
0000FDD4 367B                     M 	dc.w	.x
0000FDD6 =0000377C                M .x	=	.x+$101
0000FDD6 377C                     M 	dc.w	.x
0000FDD8 =0000387D                M .x	=	.x+$101
0000FDD8 387D                     M 	dc.w	.x
0000FDDA =0000397E                M .x	=	.x+$101
0000FDDA 397E                     M 	dc.w	.x
0000FDDC =00003A7F                M .x	=	.x+$101
0000FDDC 3A7F                     M 	dc.w	.x
0000FDDE =00003B80                M .x	=	.x+$101
0000FDDE                            ; ===========================================================================
0000FDDE                            ; ---------------------------------------------------------------------------
0000FDDE                            ; Process SFX PSG channels
0000FDDE                            ; ---------------------------------------------------------------------------
0000FDDE                            
0000FDDE                            dAMPSdoPSGSFX:
0000FDDE 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0000FDE0 4DFA FEFC                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FDE4                            
0000FDE4                            dAMPSnextPSGSFX:
0000FDE4 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000FDE8 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FDEA 6A00                       		bpl.s	.next			; if not, branch
0000FDEC 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FDF0 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FDF4                            
0000FDF4                            	dCalcFreq				; calculate channel base frequency
0000FDF4 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FDF8 4886                     M 	ext.w	d6
0000FDFA DC6D 000E                M 	add.w	cfreq(a5),d6
0000FDFE                            	dModulate				; run modulation code
0000FDFE 0815 0003                M 	btst	#cfbmod,(a5)
0000FE02 6700                     M 	beq.s	.noret
0000FE04 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FE08 6700                     M 	beq.s	.started
0000FE0A 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FE0E                          M .noret
0000FE0E 6000                     M 	bra.s	.endm
0000FE10                          M .started
0000FE10 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FE14 66F8                     M 	bne.s	.noret
0000FE16 226D 0010                M 	movea.l	cmod(a5),a1
0000FE1A 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FE20 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FE24 6600                     M 	bne.s	.norev
0000FE26 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FE2C 442D 0017                M 	neg.b	cmodstep(a5)
0000FE30                          M .norev
0000FE30 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FE34 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FE38 4885                     M 	ext.w	d5
0000FE3A DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FE3E 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FE42 DC45                     M 	add.w	d5,d6
0000FE44 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0000FE48                            
0000FE48                            .endm
0000FE48 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FE4C                            .next
0000FE4C 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FE50 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0000FE54                            
0000FE54                            .update
0000FE54 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FE58                            	dDoTracker				; process tracker
0000FE58 286D 0002                M 	movea.l	cdata(a5),a4
0000FE5C                          M 	amps_debug_trackupd
0000FE5C 220C                     M 	move.l	a4,d1
0000FE5E 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FE64 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FE6A 6500                     M 	blo.s	.fail2
0000FE6C 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FE72 6500                     M 	blo.s	.data
0000FE74                          M .fail2
0000FE74                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FE74 487A FFFE                M 	pea	*(pc)
0000FE78                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FE78 40E7                     M 	move.w	sr,-(sp)
0000FE7A                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE7A =00000000                M 	__stack:set	0
0000FE7A =00000000                M 	__sp:	set 0
0000FE7A                          M 	while	(__pos)
0000FE7A =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE7A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE7A =00000021                M 	__midpos:	= __endpos
0000FE7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	pushp	"move.l a4,-(sp)"
0000FE7A =00000001                M 	__stack:	= __stack+1
0000FE7A =00000004                M 	__sp:	= __sp+4
0000FE7A =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE7A =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE7A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE7A =00000029                M 	__midpos:	= __endpos
0000FE7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE7A =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE7A =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE7A                          M 	pushp	"move.l a4,-(sp)"
0000FE7A =00000002                M 	__stack:	= __stack+1
0000FE7A =00000008                M 	__sp:	= __sp+4
0000FE7A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE7A                          M 	rept	__stack
0000FE7A                          M 	popp	__command
0000FE7A 2F0C                     M 	move.l	a4,-(sp)
0000FE7C                          M 	popp	__command
0000FE7C 2F0C                     M 	move.l	a4,-(sp)
0000FE7E 4EB9 0000 0000           M 	jsr	errorhandler
0000FE84                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE84 =00000001                M 	__lpos:	set 1
0000FE84 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE84                          M 	while	(__pos)
0000FE84                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE84 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FE9D =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE9D =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE9D =00000021                M 	__midpos:	= __endpos
0000FE9D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9D                          M 	__param:	substr ,,"hex"
0000FE9D 83                       M 	dc.b	hex|3
0000FE9E =00000022                M 	__lpos:	set __endpos+1
0000FE9E =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE9E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9E                          M 	dc.b	""
0000FE9E =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE9E =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE9E =00000029                M 	__midpos:	= __endpos
0000FE9E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9E E0                       M 	dc.b	fendl
0000FE9F =0000002A                M 	__lpos:	set __endpos+1
0000FE9F =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE9F                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9F                          M 	dc.b	""
0000FE9F =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE9F =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE9F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE9F B3                       M 	dc.b	sym|3
0000FEA0 =00000036                M 	__lpos:	set __endpos+1
0000FEA0 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FEA0                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FEA0                          M 	dc.b	""
0000FEA0 00                       M 	dc.b	0
0000FEA1 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FEA2                          M 	even
0000FEA2 4EFA D4A8                M 	jmp	amps_debug_console_channel
0000FEA6                          M 	even
0000FEA6                          M .data
0000FEA6 7A00                     M 	moveq	#0,d5
0000FEA8 1A1C                     M 	move.b	(a4)+,d5
0000FEAA 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FEAE 6500                     M 	blo.s	.notcomm
0000FEB0 4EBA 0000                M 	jsr	dcommands(pc)
0000FEB4 60F0                     M 	bra.s	.data
0000FEB6 6094                     M 	bra.s	.next
0000FEB8                          M .notcomm
0000FEB8 4A05                       		tst.b	d5			; check if note is being played
0000FEBA 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000FEBC                            
0000FEBC                            	dGetFreqPSG				; get PSG frequency
0000FEBC 0405 0081                M 	subi.b	#$81,d5
0000FEC0 6400                     M 	bhs.s	.norest
0000FEC2 08D5 0000                M 	bset	#cfbrest,(a5)
0000FEC6 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FECC 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FED0 6000                     M 	bra.s	.freqgot
0000FED2                          M .norest
0000FED2 DA2D 0008                M 	add.b	cpitch(a5),d5
0000FED6 0245 007F                M 	andi.w	#$7f,d5
0000FEDA DA45                     M 	add.w	d5,d5
0000FEDC 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FEE2                          M 	amps_debug_notepsg
0000FEE2 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FEE6 6500                     M 	blo.s	.ok
0000FEE8                          M .fail
0000FEE8 4EBA E0CA                M 	jsr	amps_debugr_notepsg
0000FEEC                          M .ok
0000FEEC                          M .freqgot
0000FEEC 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FEEE 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FEF0 534C                       		subq.w	#1,a4			; else, undo the increment
0000FEF2 6000                       		bra.s	.pcnote			; do not calculate duration
0000FEF4                            
0000FEF4                            .timer
0000FEF4 4EBA EB1A                  		jsr	dCalcDuration(pc)	; calculate duration
0000FEF8                            .pcnote
0000FEF8                            	dProcNote 1, 1				; reset necessary channel memory
0000FEF8 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FEFC 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FF02 0815 0002                M 	btst	#cfbhold,(a5)
0000FF06 6600                     M 	bne.s	.endpn
0000FF08 422D 0006                M 	clr.b	cenvpos(a5)
0000FF0C 0815 0003                M 	btst	#cfbmod,(a5)
0000FF10 6700                     M 	beq.s	.endpn
0000FF12 226D 0010                M 	movea.l	cmod(a5),a1
0000FF16 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FF1A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FF1E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FF22 1011                     M 	move.b	(a1),d0
0000FF24 E208                     M 	lsr.b	#1,d0
0000FF26 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FF2A 426D 0014                M 	clr.w	cmodfreq(a5)
0000FF2E                          M .endpn
0000FF2E                            
0000FF2E 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0000FF32 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FF36 51CF FEAC                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FF3A                            	; continue to check tracker and end loop
0000FF3A                            ; ===========================================================================
0000FF3A                            ; ---------------------------------------------------------------------------
0000FF3A                            ; End channel loop and check if tracker debugger should be opened
0000FF3A                            ; ---------------------------------------------------------------------------
0000FF3A                            
0000FF3A                            dCheckTracker:
0000FF3A 4A38 C740                  		tst.b	msChktracker.w		; check if tracker debugger flag was set
0000FF3E 6700                       		beq.s	.rts			; if not, skip
0000FF40 4238 C740                  		clr.b	msChktracker.w		; clear that flag
0000FF44                            		AMPS_Debug_ChkTracker		; run debugger
0000FF44                          M .fail
0000FF44 4EBA E1E0                M 	jsr	amps_debugr_chktracker
0000FF48                            .rts
0000FF48 4E75                       		rts
0000FF4A                            ; ===========================================================================
0000FF4A                            ; ---------------------------------------------------------------------------
0000FF4A                            ; Music PSG channel loop
0000FF4A                            ; ---------------------------------------------------------------------------
0000FF4A                            
0000FF4A                            dAMPSdoPSG:
0000FF4A 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0000FF4C 4DFA FD90                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FF50                            
0000FF50                            dAMPSnextPSG:
0000FF50 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0000FF54 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FF56 6A00 0000                  		bpl.w	.next			; if not, branch
0000FF5A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FF5E 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FF62                            
0000FF62                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0000FF62                          M 	dnotetouthandler
0000FF62 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000FF66 6700                     M 	beq.s	.endt
0000FF68 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000FF6C 6600                     M 	bne.s	.endt
0000FF6E 08D5 0000                M 	bset	#cfbrest,(a5)
0000FF72 6100 0000                M 	bsr.w	dmutepsgmus
0000FF76 6000                     M 	bra.s	.next
0000FF78                          M .endt
0000FF78                            	dCalcFreq				; calculate channel base frequency
0000FF78 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FF7C 4886                     M 	ext.w	d6
0000FF7E DC6D 000E                M 	add.w	cfreq(a5),d6
0000FF82                            	dModulate				; run modulation code
0000FF82 0815 0003                M 	btst	#cfbmod,(a5)
0000FF86 6700                     M 	beq.s	.noret
0000FF88 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FF8C 6700                     M 	beq.s	.started
0000FF8E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FF92                          M .noret
0000FF92 6000                     M 	bra.s	.endm
0000FF94                          M .started
0000FF94 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FF98 66F8                     M 	bne.s	.noret
0000FF9A 226D 0010                M 	movea.l	cmod(a5),a1
0000FF9E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FFA4 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FFA8 6600                     M 	bne.s	.norev
0000FFAA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FFB0 442D 0017                M 	neg.b	cmodstep(a5)
0000FFB4                          M .norev
0000FFB4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FFB8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FFBC 4885                     M 	ext.w	d5
0000FFBE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FFC2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FFC6 DC45                     M 	add.w	d5,d6
0000FFC8 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0000FFCC                            
0000FFCC                            .endm
0000FFCC 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FFD0                            .next
0000FFD0 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FFD4 4EFA EA52                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FFD8                            
0000FFD8                            .update
0000FFD8 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FFDC                            	dDoTracker				; process tracker
0000FFDC 286D 0002                M 	movea.l	cdata(a5),a4
0000FFE0                          M 	amps_debug_trackupd
0000FFE0 220C                     M 	move.l	a4,d1
0000FFE2 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FFE8 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FFEE 6500                     M 	blo.s	.fail2
0000FFF0 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FFF6 6500                     M 	blo.s	.data
0000FFF8                          M .fail2
0000FFF8                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FFF8 487A FFFE                M 	pea	*(pc)
0000FFFC                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FFFC 40E7                     M 	move.w	sr,-(sp)
0000FFFE                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FFFE =00000000                M 	__stack:set	0
0000FFFE =00000000                M 	__sp:	set 0
0000FFFE                          M 	while	(__pos)
0000FFFE =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FFFE =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FFFE =00000021                M 	__midpos:	= __endpos
0000FFFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	pushp	"move.l a4,-(sp)"
0000FFFE =00000001                M 	__stack:	= __stack+1
0000FFFE =00000004                M 	__sp:	= __sp+4
0000FFFE =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FFFE =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FFFE =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FFFE =00000029                M 	__midpos:	= __endpos
0000FFFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FFFE =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FFFE =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FFFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FFFE                          M 	pushp	"move.l a4,-(sp)"
0000FFFE =00000002                M 	__stack:	= __stack+1
0000FFFE =00000008                M 	__sp:	= __sp+4
0000FFFE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FFFE                          M 	rept	__stack
0000FFFE                          M 	popp	__command
0000FFFE 2F0C                     M 	move.l	a4,-(sp)
00010000                          M 	popp	__command
00010000 2F0C                     M 	move.l	a4,-(sp)
00010002 4EB9 0000 0000           M 	jsr	errorhandler
00010008                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010008 =00000001                M 	__lpos:	set 1
00010008 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
00010008                          M 	while	(__pos)
00010008                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010008 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
00010021 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
00010021 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
00010021 =00000021                M 	__midpos:	= __endpos
00010021                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010021                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010021                          M 	__param:	substr ,,"hex"
00010021 83                       M 	dc.b	hex|3
00010022 =00000022                M 	__lpos:	set __endpos+1
00010022 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
00010022                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010022                          M 	dc.b	""
00010022 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
00010022 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
00010022 =00000029                M 	__midpos:	= __endpos
00010022                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010022                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010022 E0                       M 	dc.b	fendl
00010023 =0000002A                M 	__lpos:	set __endpos+1
00010023 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
00010023                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010023                          M 	dc.b	""
00010023 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
00010023 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
00010023                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010023                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010023 B3                       M 	dc.b	sym|3
00010024 =00000036                M 	__lpos:	set __endpos+1
00010024 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
00010024                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
00010024                          M 	dc.b	""
00010024 00                       M 	dc.b	0
00010025 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010026                          M 	even
00010026 4EFA D324                M 	jmp	amps_debug_console_channel
0001002A                          M 	even
0001002A                          M .data
0001002A 7A00                     M 	moveq	#0,d5
0001002C 1A1C                     M 	move.b	(a4)+,d5
0001002E 0C05 00E0                M 	cmpi.b	#$e0,d5
00010032 6500                     M 	blo.s	.notcomm
00010034 4EBA 0000                M 	jsr	dcommands(pc)
00010038 60F0                     M 	bra.s	.data
0001003A 6094                     M 	bra.s	.next
0001003C                          M .notcomm
0001003C 4A05                       		tst.b	d5			; check if note is being played
0001003E 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
00010040                            
00010040                            	dGetFreqPSG				; get PSG frequency
00010040 0405 0081                M 	subi.b	#$81,d5
00010044 6400                     M 	bhs.s	.norest
00010046 08D5 0000                M 	bset	#cfbrest,(a5)
0001004A 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
00010050 4EBA 0000                M 	jsr	dmutepsgmus(pc)
00010054 6000                     M 	bra.s	.freqgot
00010056                          M .norest
00010056 DA2D 0008                M 	add.b	cpitch(a5),d5
0001005A 0245 007F                M 	andi.w	#$7f,d5
0001005E DA45                     M 	add.w	d5,d5
00010060 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
00010066                          M 	amps_debug_notepsg
00010066 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0001006A 6500                     M 	blo.s	.ok
0001006C                          M .fail
0001006C 4EBA DF46                M 	jsr	amps_debugr_notepsg
00010070                          M .ok
00010070                          M .freqgot
00010070 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
00010072 6A00                       		bpl.s	.timer			; if yes, handle timer
00010074 534C                       		subq.w	#1,a4			; else, undo the increment
00010076 6000                       		bra.s	.pcnote			; do not calculate duration
00010078                            
00010078                            .timer
00010078 4EBA E996                  		jsr	dCalcDuration(pc)	; calculate duration
0001007C                            .pcnote
0001007C                            	dProcNote 0, 1				; reset necessary channel memory
0001007C 2B4C 0002                M 	move.l	a4,cdata(a5)
00010080 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
00010086 0815 0002                M 	btst	#cfbhold,(a5)
0001008A 6600                     M 	bne.s	.endpn
0001008C 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
00010092 422D 0006                M 	clr.b	cenvpos(a5)
00010096 0815 0003                M 	btst	#cfbmod,(a5)
0001009A 6700                     M 	beq.s	.endpn
0001009C 226D 0010                M 	movea.l	cmod(a5),a1
000100A0 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
000100A4 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
000100A8 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
000100AC 1011                     M 	move.b	(a1),d0
000100AE E208                     M 	lsr.b	#1,d0
000100B0 1B40 0018                M 	move.b	d0,cmodcount(a5)
000100B4 426D 0014                M 	clr.w	cmodfreq(a5)
000100B8                          M .endpn
000100B8                            
000100B8 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
000100BA 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
000100BE 51CF FE90                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
000100C2 4EFA E964                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
000100C6                            ; ===========================================================================
000100C6                            ; ---------------------------------------------------------------------------
000100C6                            ; Write PSG frequency to hardware
000100C6                            ; ---------------------------------------------------------------------------
000100C6                            
000100C6                            dUpdateFreqPSG:
000100C6 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
000100CA 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
000100CC 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
000100D0 4E75                       		rts
000100D2                            
000100D2                            .detune
000100D2 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
000100D6 4880                       		ext.w	d0			; extend to word
000100D8 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
000100DA                            
000100DA 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
000100DE 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
000100E0 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
000100E4                            
000100E4                            dUpdateFreqPSG2:
000100E4 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
000100E8 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
000100EA                            
000100EA                            dUpdateFreqPSG3:
000100EA 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
000100EE 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
000100F0                            
000100F0 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
000100F4 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
000100F8 6600                       		bne.s	.notPSG4		; if not, branch
000100FA 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
000100FC                            
000100FC                            .notPSG4
000100FC 3206                       		move.w	d6,d1			; copy frequency to d1
000100FE 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
00010102 8001                       		or.b	d1,d0			; combine with channel type
00010104                            ; ---------------------------------------------------------------------------
00010104                            ; Note about the and instruction below: If this instruction is
00010104                            ; not commented out, the instashield SFX will not sound correct.
00010104                            ; This instruction was removed in Sonic 3K because of this, but
00010104                            ; this can cause issues when values overflow the valid range of
00010104                            ; PSG frequency. This may cause erroneous behavior if not anded,
00010104                            ; but will also make the instashield SFX not sound correctly.
00010104                            ; Comment out the instruction with caution, if you are planning
00010104                            ; to port said sound effect to this driver. This has not caused
00010104                            ; any issues for me, and if you are careful you can avoid any
00010104                            ; such case, but beware of this issue!
00010104                            ; ---------------------------------------------------------------------------
00010104                            
00010104 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
00010106 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001010A 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
00010110 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
00010116                            
00010116                            locret_dUpdateFreqPSG:
00010116 4E75                       		rts
00010118                            ; ===========================================================================
00010118                            ; ---------------------------------------------------------------------------
00010118                            ; Routine for running envelope programs
00010118                            ; ---------------------------------------------------------------------------
00010118                            
00010118                            dEnvProgPSG:
00010118 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001011C DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
00010120                            
00010120 7800                       		moveq	#0,d4
00010122 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
00010126 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
00010128 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001012A                            
0001012A                            dEnvelopePSG:
0001012A 7800                       		moveq	#0,d4
0001012C 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
00010130 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
00010132                            
00010132 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
00010136 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001013A                            
0001013A                            dEnvProgPSG2:
0001013A                            		AMPS_Debug_VolEnvID		; check if volume envelope ID is valid
0001013A 0C04 0000                M 	cmp.b	#(volenvs_end-volenvs)/4,d4
0001013E 6300                     M 	bls.s	.ok
00010140 4EBA DE3C                M 	jsr	amps_debugr_volenvid
00010144                          M .ok
00010144                            
00010144 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
00010148 D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001014A D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001014C 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
00010150                            
00010150 7200                       		moveq	#0,d1
00010152 7000                       		moveq	#0,d0
00010154                            
00010154                            dEnvProgPSG3:
00010154 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
00010158 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001015C 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001015E                            
0001015E 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
00010162 DA00                       		add.b	d0,d5			; add envelope volume to d5
00010164                            	; continue to update PSG volume
00010164                            ; ===========================================================================
00010164                            ; ---------------------------------------------------------------------------
00010164                            ; Routine for updating PSG volume to hardware
00010164                            ; ---------------------------------------------------------------------------
00010164                            
00010164                            dUpdateVolPSG2:
00010164 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
00010168 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001016A 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001016C                            
0001016C                            dUpdateVolPSG:
0001016C 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
00010170 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
00010172 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
00010176 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
00010178                            
00010178 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001017C 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001017E BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
00010182 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
00010184                            
00010184 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
00010188 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001018A 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001018E 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
00010190                            
00010190                            dUpdVolPSGset:
00010190 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
00010194 0605 0010                  		addi.b	#$10,d5			; set volume update bit
00010198 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001019E                            
0001019E                            locret_UpdVolPSG:
0001019E 4E75                       		rts
000101A0                            ; ===========================================================================
000101A0                            ; ---------------------------------------------------------------------------
000101A0                            ; Subroutine for handling volume envelope commands
000101A0                            ; ---------------------------------------------------------------------------
000101A0                            
000101A0                            dEnvCommand:
000101A0                            		AMPS_Debug_VolEnvCmd		; check if command is valid
000101A0 0C00 0088                M 	cmp.b	#elast,d0
000101A4 6400                     M 	bhs.s	.fail
000101A6 0C00 0080                M 	cmp.b	#$80,d0
000101AA 6500                     M 	blo.s	.fail
000101AC 0800 0000                M 	btst	#0,d0
000101B0 6700                     M 	beq.s	.ok
000101B2                          M .fail
000101B2                          M 	raiseerror2	"Volume envelope command invalid: %<.b d0>",amps_debug_console_channel
000101B2 40E7                     M 	move.w	sr,-(sp)
000101B4                          M 	__fstring_generateargumentscode	"Volume envelope command invalid: %<.b d0>"
000101B4 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
000101B4 =00000000                M 	__stack:set	0
000101B4 =00000000                M 	__sp:	set 0
000101B4                          M 	while	(__pos)
000101B4 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
000101B4 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
000101B4 =00000029                M 	__midpos:	= __endpos
000101B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
000101B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
000101B4                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope command invalid: %<.b d0>"
000101B4                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
000101B4                          M 	pushp	"move.b d0,1(sp)"
000101B4                          M 	pushp	"subq.w	#2, sp"
000101B4 =00000002                M 	__stack:	= __stack+2
000101B4 =00000002                M 	__sp:	= __sp+2
000101B4 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
000101B4                          M 	rept	__stack
000101B4                          M 	popp	__command
000101B4 554F                     M 	subq.w	#2,sp
000101B6                          M 	popp	__command
000101B6 1F40 0001                M 	move.b	d0,1(sp)
000101BA 4EB9 0000 0000           M 	jsr	errorhandler
000101C0                          M 	__fstring_generatedecodedstring	"Volume envelope command invalid: %<.b d0>"
000101C0 =00000001                M 	__lpos:	set 1
000101C0 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
000101C0                          M 	while	(__pos)
000101C0                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope command invalid: %<.b d0>"
000101C0 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope command invalid: "
000101E1 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
000101E1 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
000101E1 =00000029                M 	__midpos:	= __endpos
000101E1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
000101E1                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
000101E1                          M 	__param:	substr ,,"hex"
000101E1 80                       M 	dc.b	hex
000101E2 =0000002A                M 	__lpos:	set __endpos+1
000101E2 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
000101E2                          M 	__substr:	substr __lpos,,"Volume envelope command invalid: %<.b d0>"
000101E2                          M 	dc.b	""
000101E2 00                       M 	dc.b	0
000101E3 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000101E4                          M 	even
000101E4 4EFA D166                M 	jmp	amps_debug_console_channel
000101E8                          M 	even
000101E8                          M .ok
000101E8                            
000101E8 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
000101EC                            
000101EC                            .comm
000101EC 6000                       		bra.s	.reset			; 80 - Loop back to beginning
000101EE 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
000101F0 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
000101F2                            	;	bra.s	.stop			; 86 - Stop current note and envelope
000101F2                            ; ---------------------------------------------------------------------------
000101F2                            
000101F2                            .stop
000101F2 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
000101F6 6000                       		bra.s	dMutePSGmus		; nute the channel
000101F8                            ; ---------------------------------------------------------------------------
000101F8                            
000101F8                            .hold
000101F8 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
000101FC 4EFA FF56                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
00010200                            ; ---------------------------------------------------------------------------
00010200                            
00010200                            .reset
00010200 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
00010204 4EFA FF4E                  		jmp	dEnvProgPSG3(pc)	; run the program again
00010208                            ; ---------------------------------------------------------------------------
00010208                            
00010208                            .loop
00010208 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001020E 4EFA FF44                  		jmp	dEnvProgPSG3(pc)	; run the program again
00010212                            ; ===========================================================================
00010212                            ; ---------------------------------------------------------------------------
00010212                            ; Routine for hardware muting a PSG channel
00010212                            ; ---------------------------------------------------------------------------
00010212                            
00010212                            dMutePSGmus:
00010212 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
00010216 6600                       		bne.s	locret_MutePSG		; if yes, do not update
00010218                            
00010218                            dMutePSGsfx:
00010218 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001021A 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001021E 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
00010224                            
00010224                            locret_MutePSG:
00010224 4E75                       		rts
00010226                            
00010226 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001022E                            ; ===========================================================================
0001022E                            ; ---------------------------------------------------------------------------
0001022E                            ; Routine to execute tracker commands
0001022E                            ;
0001022E                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001022E                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001022E                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001022E                            ; but it may be helpful with speed anyway.
0001022E                            ; ---------------------------------------------------------------------------
0001022E                            
0001022E                            dCommands:
0001022E DA05                       		add.b	d5,d5			; quadruple command ID
00010230 DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
00010232                            
00010232 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
00010236 6600 0000                  		bne.w	.falsecomm		; branch if false
0001023A 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001023E                            ; ===========================================================================
0001023E                            ; ---------------------------------------------------------------------------
0001023E                            ; Command handlers for normal execution
0001023E                            ; ---------------------------------------------------------------------------
0001023E                            
0001023E                            .comm
0001023E 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00010242 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
00010246 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001024A 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001024E 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00010252 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00010256 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001025A 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001025E 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00010262 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00010266 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001026A 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001026E 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00010272 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00010276 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001027A 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001027E 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
00010282 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00010286 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001028A 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001028E 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
00010292 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
00010296 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001029A 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001029E 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
000102A2 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
000102A6 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
000102AA 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
000102AE 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
000102B2 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
000102B6 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
000102BA                            				; FF - META
000102BA                            ; ===========================================================================
000102BA                            ; ---------------------------------------------------------------------------
000102BA                            ; Routine to execute tracker meta and false condition commands
000102BA                            ; ---------------------------------------------------------------------------
000102BA                            
000102BA                            .metacall
000102BA 1A1C                       		move.b	(a4)+,d5		; get next command byte
000102BC DA45                       		add.w	d5,d5			; quadruple ID
000102BE DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
000102C0 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
000102C4                            
000102C4                            .falsecomm
000102C4 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
000102C8                            ; ===========================================================================
000102C8                            ; ---------------------------------------------------------------------------
000102C8                            ; Command handlers for meta commands
000102C8                            ; ---------------------------------------------------------------------------
000102C8                            
000102C8                            .meta
000102C8 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
000102CC 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
000102D0 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
000102D4 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
000102D8 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
000102DC 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
000102E0 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
000102E4 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
000102E8 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
000102EC 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
000102F0 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
000102F4 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
000102F8 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
000102FC 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
00010300                            
00010300 6000 0000                  		bra.w	dcFreeze	; FF 0E - Freeze CPU. Debug flag (DEBUG_STOP_CPU)
00010304 6000 0000                  		bra.w	dcTracker	; FF 0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00010308                            ; ===========================================================================
00010308                            ; ---------------------------------------------------------------------------
00010308                            ; Command handlers for false condition execution
00010308                            ; ---------------------------------------------------------------------------
00010308                            
00010308                            .false
00010308 524C                       	addq.w	#1,a4
0001030A 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001030C 524C                       	addq.w	#1,a4
0001030E 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
00010310 524C                       	addq.w	#1,a4
00010312 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
00010314 524C                       	addq.w	#1,a4
00010316 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00010318 524C                       	addq.w	#1,a4
0001031A 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001031C 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00010320 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00010324 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
00010328 524C                       	addq.w	#1,a4
0001032A 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001032C 524C                       	addq.w	#1,a4
0001032E 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
00010330 524C                       	addq.w	#1,a4
00010332 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00010334 4E75                       	rts
00010336 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
00010338 4E75                       	rts
0001033A 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001033C 524C                       	addq.w	#1,a4
0001033E 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00010340 524C                       	addq.w	#1,a4
00010342 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00010344 524C                       	addq.w	#1,a4
00010346 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
00010348 584C                       	addq.w	#4,a4
0001034A 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001034C 4E75                       	rts
0001034E 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00010350 4E75                       	rts
00010352 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00010354 524C                       	addq.w	#1,a4
00010356 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
00010358 544C                       	addq.w	#2,a4
0001035A 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001035C 4E75                       	rts
0001035E 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
00010360 544C                       	addq.w	#2,a4
00010362 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
00010364 584C                       	addq.w	#4,a4
00010366 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
00010368 544C                       	addq.w	#2,a4
0001036A 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001036C 4E75                       	rts
0001036E 4E75                       	rts			; F9 - Return (RETURN)
00010370 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
00010374 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
00010378 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001037C 524C                       	addq.w	#1,a4
0001037E 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
00010380 524C                       	addq.w	#1,a4
00010382 4E75                       	rts			; FE - YM command (YMCMD)
00010384 6000 FF34                  	bra.w	.metacall	; FF - META
00010388                            ; ===========================================================================
00010388                            ; ---------------------------------------------------------------------------
00010388                            ; Tracker commands for writing direct DAC samples to Dual PCM.
00010388                            ; Note that this will override any DAC already being played,
00010388                            ; and in turn trackers may override these DAC samples at any
00010388                            ; time. Use with caution!
00010388                            ; ---------------------------------------------------------------------------
00010388                            
00010388                            dcWriteDAC1:
00010388 7000                       		moveq	#0,d0
0001038A 101C                       		move.b	(a4)+,d0		; get note to write
0001038C 4EFA E58C                  		jmp	dNoteWriteDAC1(pc)	; note-on
00010390                            
00010390                            dcWriteDAC2:
00010390 7000                       		moveq	#0,d0
00010392 101C                       		move.b	(a4)+,d0		; get note to write
00010394 4EFA E576                  		jmp	dNoteWriteDAC2(pc)	; note-on
00010398                            ; ===========================================================================
00010398                            ; ---------------------------------------------------------------------------
00010398                            ; Tracker commands for handling spindash revving.
00010398                            ; The way spindash revving works, is it actually just
00010398                            ; increments a counter each time, and this counter is
00010398                            ; added into the channel pitch offset.
00010398                            ; ---------------------------------------------------------------------------
00010398                            
00010398                            dcSpRev:
00010398 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001039C 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
000103A0 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
000103A4                            
000103A4 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
000103A8 6500                       		blo.s	.rts			; if not, skip
000103AA 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
000103AE                            
000103AE                            .rts
000103AE 4E75                       		rts
000103B0                            
000103B0                            dcSpReset:
000103B0 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
000103B4 4E75                       		rts
000103B6                            ; ===========================================================================
000103B6                            ; ---------------------------------------------------------------------------
000103B6                            ; Tracker command for changing channel panning
000103B6                            ; ---------------------------------------------------------------------------
000103B6                            
000103B6                            dcPan:
000103B6                            		AMPS_Debug_dcPan		; check if this channel can pan
000103B6 4A2D 0001                M 	tst.b	ctype(a5)
000103BA 6A00                     M 	bpl.s	.ok
000103BC                          M 	raiseerror	"sPan on a PSG channel!",amps_debug_console_channel
000103BC 487A FFFE                M 	pea	*(pc)
000103C0                          M 	raiseerror2	"sPan on a PSG channel!",amps_debug_console_channel
000103C0 40E7                     M 	move.w	sr,-(sp)
000103C2                          M 	__fstring_generateargumentscode	"sPan on a PSG channel!"
000103C2 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
000103C2 =00000000                M 	__stack:set	0
000103C2 =00000000                M 	__sp:	set 0
000103C2                          M 	while	(__pos)
000103C2                          M 	rept	__stack
000103C2 4EB9 0000 0000           M 	jsr	errorhandler
000103C8                          M 	__fstring_generatedecodedstring	"sPan on a PSG channel!"
000103C8 =00000001                M 	__lpos:	set 1
000103C8 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
000103C8                          M 	while	(__pos)
000103C8                          M 	__substr:	substr __lpos,,"sPan on a PSG channel!"
000103C8 7350 616E 206F 6E20 6120+M 	dc.b	"sPan on a PSG channel!"
000103DE 00                       M 	dc.b	0
000103DF 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000103E0                          M 	even
000103E0 4EFA CF6A                M 	jmp	amps_debug_console_channel
000103E4                          M 	even
000103E4                          M .ok
000103E4                            
000103E4 7237                       		moveq	#$37,d1			; prepare bits to keep
000103E6 C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
000103EA 821C                       		or.b	(a4)+,d1		; or panning value
000103EC 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
000103F0                            
000103F0 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
000103F2 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000103F8 6700 F55A                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
000103FC                            ; ---------------------------------------------------------------------------
000103FC                            ; Since the DAC channels have or based panning behavior, we need this
000103FC                            ; piece of code to update its panning
000103FC                            ; ---------------------------------------------------------------------------
000103FC                            
000103FC 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
00010400 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
00010406 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
00010408 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001040C                            
0001040C                            .nodacsfx
0001040C 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
00010410 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
00010412 4EFA F592                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
00010416                            ; ===========================================================================
00010416                            ; ---------------------------------------------------------------------------
00010416                            ; Tracker commands for changing detune offset
00010416                            ; ---------------------------------------------------------------------------
00010416                            
00010416                            dcaDetune:
00010416 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
00010418 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001041C 4E75                       		rts
0001041E                            
0001041E                            dcsDetune:
0001041E 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
00010422 4E75                       		rts
00010424                            ; ===========================================================================
00010424                            ; ---------------------------------------------------------------------------
00010424                            ; Tracker command for changing channel volume
00010424                            ; ---------------------------------------------------------------------------
00010424                            
00010424                            dcsVolume:
00010424 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
00010428 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001042C 4E75                       		rts
0001042E                            
0001042E                            dcaVolume:
0001042E 101C                       		move.b	(a4)+,d0		; load volume from tracker
00010430 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
00010434 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
00010438 4E75                       		rts
0001043A                            ; ===========================================================================
0001043A                            ; ---------------------------------------------------------------------------
0001043A                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001043A                            ; ---------------------------------------------------------------------------
0001043A                            
0001043A                            dcSampDAC:
0001043A 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
00010440 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
00010444 4E75                       		rts
00010446                            ; ===========================================================================
00010446                            ; ---------------------------------------------------------------------------
00010446                            ; Tracker command for setting DAC to pitch mode
00010446                            ; ---------------------------------------------------------------------------
00010446                            
00010446                            dcPitchDAC:
00010446 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001044A 4E75                       		rts
0001044C                            ; ===========================================================================
0001044C                            ; ---------------------------------------------------------------------------
0001044C                            ; Tracker commands for changing channel tick multiplier
0001044C                            ; ---------------------------------------------------------------------------
0001044C                            
0001044C                            dcsTmulCh:
0001044C 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
00010450 4E75                       		rts
00010452                            
00010452                            dcsTmul:
00010452 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
00010454 =FFFFC4C4                  .x =	mDAC1					; start at DAC1
00010454                            	rept Mus_Ch				; do for all music channels
00010454                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
00010454                            .x =		.x+cSize			; go to next channel
00010454                            	endr
00010454 11C0 C4CE                M 	move.b	d0,ctick+.x.w
00010458 =FFFFC4F0                M .x	=	.x+csize
00010458 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001045C =FFFFC51C                M .x	=	.x+csize
0001045C 11C0 C526                M 	move.b	d0,ctick+.x.w
00010460 =FFFFC548                M .x	=	.x+csize
00010460 11C0 C552                M 	move.b	d0,ctick+.x.w
00010464 =FFFFC574                M .x	=	.x+csize
00010464 11C0 C57E                M 	move.b	d0,ctick+.x.w
00010468 =FFFFC5A0                M .x	=	.x+csize
00010468 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001046C =FFFFC5CC                M .x	=	.x+csize
0001046C 11C0 C5D6                M 	move.b	d0,ctick+.x.w
00010470 =FFFFC5F8                M .x	=	.x+csize
00010470 11C0 C602                M 	move.b	d0,ctick+.x.w
00010474 =FFFFC624                M .x	=	.x+csize
00010474 11C0 C62E                M 	move.b	d0,ctick+.x.w
00010478 =FFFFC650                M .x	=	.x+csize
00010478 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001047C =FFFFC67C                M .x	=	.x+csize
0001047C 4E75                       		rts
0001047E                            ; ===========================================================================
0001047E                            ; ---------------------------------------------------------------------------
0001047E                            ; Tracker command for enabling or disabling the hold flag
0001047E                            ; ---------------------------------------------------------------------------
0001047E                            
0001047E                            dcHold:
0001047E 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
00010482 4E75                       		rts
00010484                            ; ===========================================================================
00010484                            ; ---------------------------------------------------------------------------
00010484                            ; Tracker command for enabling or disabling note timeout
00010484                            ; ---------------------------------------------------------------------------
00010484                            
00010484                            dcTimeout:
00010484                            		AMPS_Debug_dcTimeout		; check if this channel has timeout support
00010484 BAFC C67C                M 	cmp.w	#msfxdac1,a5
00010488 6500                     M 	blo.s	.ok
0001048A                          M 	raiseerror	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
0001048A 487A FFFE                M 	pea	*(pc)
0001048E                          M 	raiseerror2	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
0001048E 40E7                     M 	move.w	sr,-(sp)
00010490                          M 	__fstring_generateargumentscode	"sNoteTimeOut on a SFX channel!"
00010490 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
00010490 =00000000                M 	__stack:set	0
00010490 =00000000                M 	__sp:	set 0
00010490                          M 	while	(__pos)
00010490                          M 	rept	__stack
00010490 4EB9 0000 0000           M 	jsr	errorhandler
00010496                          M 	__fstring_generatedecodedstring	"sNoteTimeOut on a SFX channel!"
00010496 =00000001                M 	__lpos:	set 1
00010496 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
00010496                          M 	while	(__pos)
00010496                          M 	__substr:	substr __lpos,,"sNoteTimeOut on a SFX channel!"
00010496 734E 6F74 6554 696D 654F+M 	dc.b	"sNoteTimeOut on a SFX channel!"
000104B4 00                       M 	dc.b	0
000104B5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000104B6                          M 	even
000104B6 4EFA CE94                M 	jmp	amps_debug_console_channel
000104BA                          M 	even
000104BA                          M .ok
000104BA                            
000104BA 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
000104BE 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
000104C2 4E75                       		rts
000104C4                            ; ===========================================================================
000104C4                            ; ---------------------------------------------------------------------------
000104C4                            ; Tracker commands for changing channel pitch
000104C4                            ; ---------------------------------------------------------------------------
000104C4                            
000104C4                            dcaTransp:
000104C4 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
000104C6 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
000104CA 4E75                       		rts
000104CC                            
000104CC                            dcsTransp:
000104CC 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
000104D0 4E75                       		rts
000104D2                            ; ===========================================================================
000104D2                            ; ---------------------------------------------------------------------------
000104D2                            ; Tracker commands for tempo control
000104D2                            ; ---------------------------------------------------------------------------
000104D2                            
000104D2                            dcsTempoShoes:
000104D2 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000104D4 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
000104D8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000104DE 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
000104E0 4E75                       		rts
000104E2                            
000104E2                            dcsTempo:
000104E2 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000104E4 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
000104E8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000104EE 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
000104F0                            
000104F0                            dcsTempoCur:
000104F0 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
000104F4                            
000104F4                            locret_Tempo:
000104F4 4E75                       		rts
000104F6                            
000104F6                            dcaTempoShoes:
000104F6 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000104F8 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
000104FC 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
00010502 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
00010504 4E75                       		rts
00010506                            
00010506                            dcaTempo:
00010506 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010508 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001050C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
00010512 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
00010514                            
00010514                            dcaTempoCur:
00010514 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
00010518 4E75                       		rts
0001051A                            ; ===========================================================================
0001051A                            ; ---------------------------------------------------------------------------
0001051A                            ; Tracker command for enabling or disabling PSG4 noise mode
0001051A                            ; ---------------------------------------------------------------------------
0001051A                            
0001051A                            dcNoisePSG:
0001051A 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001051E 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
00010520 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
00010526 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001052C 4E75                       		rts
0001052E                            
0001052E                            .psg3
0001052E 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
00010534 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001053C 524C                       		addq.w	#1,a4			; skip param
0001053E 4E75                       		rts
00010540                            ; ===========================================================================
00010540                            ; ---------------------------------------------------------------------------
00010540                            ; Tracker command for playing another music or SFX
00010540                            ; ---------------------------------------------------------------------------
00010540                            
00010540                            dcSound:
00010540 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
00010544                            
00010544                            Return_dcSound:
00010544 4E75                       		rts
00010546                            ; ===========================================================================
00010546                            ; ---------------------------------------------------------------------------
00010546                            ; Tracker command for setting DAC filter bank
00010546                            ; ---------------------------------------------------------------------------
00010546                            
00010546                            dcFilter:
00010546 7000                       		moveq	#0,d0
00010548 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001054A 4EFA EF40                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001054E                            ; ===========================================================================
0001054E                            ; ---------------------------------------------------------------------------
0001054E                            ; Tracker command for writing a YM command to YMCue
0001054E                            ; ---------------------------------------------------------------------------
0001054E                            
0001054E                            dcYM:
0001054E 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
00010550 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
00010552 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
00010556 66EC                       		bne.s	Return_dcSound		; if so, skip
00010558                            
00010558 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001055C 6500 F408                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
00010560                            
00010560 1400                       		move.b	d0,d2			; copy address to d2
00010562 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
00010566 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001056A 6500 F3FA                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001056E 4EFA F3EA                  		jmp	WriteChYM(pc)		; write to YM according to channel
00010572                            ; ===========================================================================
00010572                            ; ---------------------------------------------------------------------------
00010572                            ; Tracker command for setting channel base frequency
00010572                            ; ---------------------------------------------------------------------------
00010572                            
00010572                            dcsFreq:
00010572 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
00010576 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001057A                            
0001057A 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010580 6600                       		bne.s	.rts			; if so, brÃ¡nch
00010582                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
00010582                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010582 487A FFFE                M 	pea	*(pc)
00010586                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010586 40E7                     M 	move.w	sr,-(sp)
00010588                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010588 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010588 =00000000                M 	__stack:set	0
00010588 =00000000                M 	__sp:	set 0
00010588                          M 	while	(__pos)
00010588                          M 	rept	__stack
00010588 4EB9 0000 0000           M 	jsr	errorhandler
0001058E                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
0001058E =00000001                M 	__lpos:	set 1
0001058E =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001058E                          M 	while	(__pos)
0001058E                          M 	__substr:	substr __lpos,,"Invalid command detected!"
0001058E 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000105A7 00                       M 	dc.b	0
000105A8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000105AA 00                       M 	even
000105AA 4EFA CDA0                M 	jmp	amps_debug_console_channel
000105AE                          M 	even
000105AE                            .rts
000105AE 4E75                       		rts
000105B0                            ; ===========================================================================
000105B0                            ; ---------------------------------------------------------------------------
000105B0                            ; Tracker command for setting channel base frequency from the note table
000105B0                            ; ---------------------------------------------------------------------------
000105B0                            
000105B0                            dcsFreqNote:
000105B0 7000                       		moveq	#0,d0
000105B2 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
000105B4 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
000105B8 D040                       		add.w	d0,d0			; double offset (each entry is a word)
000105BA                            
000105BA 43FA F522                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
000105BE 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
000105C4                            
000105C4 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000105CA 6600                       		bne.s	.rts			; if so, brÃ¡nch
000105CC                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
000105CC                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000105CC 487A FFFE                M 	pea	*(pc)
000105D0                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000105D0 40E7                     M 	move.w	sr,-(sp)
000105D2                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000105D2 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000105D2 =00000000                M 	__stack:set	0
000105D2 =00000000                M 	__sp:	set 0
000105D2                          M 	while	(__pos)
000105D2                          M 	rept	__stack
000105D2 4EB9 0000 0000           M 	jsr	errorhandler
000105D8                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000105D8 =00000001                M 	__lpos:	set 1
000105D8 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000105D8                          M 	while	(__pos)
000105D8                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000105D8 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000105F1 00                       M 	dc.b	0
000105F2 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000105F4 00                       M 	even
000105F4 4EFA CD56                M 	jmp	amps_debug_console_channel
000105F8                          M 	even
000105F8                            .rts
000105F8 4E75                       		rts
000105FA                            ; ===========================================================================
000105FA                            ; ---------------------------------------------------------------------------
000105FA                            ; Tracker command for doing a continous SFX loop
000105FA                            ; ---------------------------------------------------------------------------
000105FA                            
000105FA                            dcCont:
000105FA 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
000105FE 6A00                       		bpl.s	dcJump			; if positive, jump to routine
00010600 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
00010604 544C                       		addq.w	#2,a4			; skip over jump offset
00010606 4E75                       		rts
00010608                            ; ===========================================================================
00010608                            ; ---------------------------------------------------------------------------
00010608                            ; Tracker command for calling a tracker subroutine
00010608                            ; ---------------------------------------------------------------------------
00010608                            
00010608                            dcCall:
00010608                            		AMPS_Debug_dcCall1		; check if this channel supports the stack
00010608 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001060C 6500                     M 	blo.s	.ok1
0001060E                          M 	raiseerror	"sCall on a SFX channel!",amps_debug_console_channel
0001060E 487A FFFE                M 	pea	*(pc)
00010612                          M 	raiseerror2	"sCall on a SFX channel!",amps_debug_console_channel
00010612 40E7                     M 	move.w	sr,-(sp)
00010614                          M 	__fstring_generateargumentscode	"sCall on a SFX channel!"
00010614 =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
00010614 =00000000                M 	__stack:set	0
00010614 =00000000                M 	__sp:	set 0
00010614                          M 	while	(__pos)
00010614                          M 	rept	__stack
00010614 4EB9 0000 0000           M 	jsr	errorhandler
0001061A                          M 	__fstring_generatedecodedstring	"sCall on a SFX channel!"
0001061A =00000001                M 	__lpos:	set 1
0001061A =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
0001061A                          M 	while	(__pos)
0001061A                          M 	__substr:	substr __lpos,,"sCall on a SFX channel!"
0001061A 7343 616C 6C20 6F6E 2061+M 	dc.b	"sCall on a SFX channel!"
00010631 00                       M 	dc.b	0
00010632 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010634 00                       M 	even
00010634 4EFA CD16                M 	jmp	amps_debug_console_channel
00010638                          M 	even
00010638                          M .ok1
00010638                            
00010638 7000                       		moveq	#0,d0
0001063A 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001063E 5900                       		subq.b	#4,d0			; allocate space for another routine
00010640                            
00010640                            		AMPS_Debug_dcCall2		; check if we overflowed the space
00010640 0C00 001C                M 	cmp.b	#cnotetimecur,d0
00010644 6200                     M 	bhi.s	.ok2
00010646                          M 	raiseerror	"sCall stack too deep!",amps_debug_console_channel
00010646 487A FFFE                M 	pea	*(pc)
0001064A                          M 	raiseerror2	"sCall stack too deep!",amps_debug_console_channel
0001064A 40E7                     M 	move.w	sr,-(sp)
0001064C                          M 	__fstring_generateargumentscode	"sCall stack too deep!"
0001064C =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
0001064C =00000000                M 	__stack:set	0
0001064C =00000000                M 	__sp:	set 0
0001064C                          M 	while	(__pos)
0001064C                          M 	rept	__stack
0001064C 4EB9 0000 0000           M 	jsr	errorhandler
00010652                          M 	__fstring_generatedecodedstring	"sCall stack too deep!"
00010652 =00000001                M 	__lpos:	set 1
00010652 =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
00010652                          M 	while	(__pos)
00010652                          M 	__substr:	substr __lpos,,"sCall stack too deep!"
00010652 7343 616C 6C20 7374 6163+M 	dc.b	"sCall stack too deep!"
00010667 00                       M 	dc.b	0
00010668 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001066A 00                       M 	even
0001066A 4EFA CCE0                M 	jmp	amps_debug_console_channel
0001066E                          M 	even
0001066E                          M .ok2
0001066E 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
00010672 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
00010676                            ; ===========================================================================
00010676                            ; ---------------------------------------------------------------------------
00010676                            ; Tracker command for jumping to another tracker location
00010676                            ; ---------------------------------------------------------------------------
00010676                            
00010676                            dcJump:
00010676                            	dREAD_WORD a4, d0			; read a word from tracker to d0
00010676 1E9C                     M 	move.b	(a4)+,(sp)
00010678 3017                     M 	move.w	(sp),d0
0001067A 1014                     M 	move.b	(a4),d0
0001067C D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001067E 4E75                       		rts
00010680                            ; ===========================================================================
00010680                            ; ---------------------------------------------------------------------------
00010680                            ; Tracker command for handling loops
00010680                            ; ---------------------------------------------------------------------------
00010680                            
00010680                            dcLoop:
00010680 7000                       		moveq	#0,d0
00010682 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
00010684                            		AMPS_Debug_dcLoop		; check if loop index is valid
00010684 0C00 0003                M 	cmp.b	#3,d0
00010688 6200                     M 	bhi.s	.fail
0001068A BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001068E 6500                     M 	blo.s	.nosfx
00010690 0C00 0001                M 	cmp.b	#1,d0
00010694 6700                     M 	beq.s	.fail
00010696                          M .nosfx
00010696 0C2D 00C0 0001           M 	cmp.b	#$c0,ctype(a5)
0001069C 6500                     M 	blo.s	amps_debug_dcloop_ok
0001069E 0C00 0002                M 	cmp.b	#2,d0
000106A2 6600                     M 	bne.s	amps_debug_dcloop_ok
000106A4                          M .fail
000106A4                          M 	raiseerror	"sLoop ID is invalid!",amps_debug_console_channel
000106A4 487A FFFE                M 	pea	*(pc)
000106A8                          M 	raiseerror2	"sLoop ID is invalid!",amps_debug_console_channel
000106A8 40E7                     M 	move.w	sr,-(sp)
000106AA                          M 	__fstring_generateargumentscode	"sLoop ID is invalid!"
000106AA =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
000106AA =00000000                M 	__stack:set	0
000106AA =00000000                M 	__sp:	set 0
000106AA                          M 	while	(__pos)
000106AA                          M 	rept	__stack
000106AA 4EB9 0000 0000           M 	jsr	errorhandler
000106B0                          M 	__fstring_generatedecodedstring	"sLoop ID is invalid!"
000106B0 =00000001                M 	__lpos:	set 1
000106B0 =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
000106B0                          M 	while	(__pos)
000106B0                          M 	__substr:	substr __lpos,,"sLoop ID is invalid!"
000106B0 734C 6F6F 7020 4944 2069+M 	dc.b	"sLoop ID is invalid!"
000106C4 00                       M 	dc.b	0
000106C5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000106C6                          M 	even
000106C6 4EFA CC84                M 	jmp	amps_debug_console_channel
000106CA                          M 	even
000106CA                          M amps_debug_dcloop_ok
000106CA                            
000106CA 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
000106CE 6600                       		bne.s	.loopok			; if nonzero, branch
000106D0 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
000106D6                            
000106D6                            .loopok
000106D6 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
000106DA 669A                       		bne.s	dcJump			; if not 0, jump to routine
000106DC 564C                       		addq.w	#3,a4			; skip over jump offset
000106DE 4E75                       		rts
000106E0                            ; ===========================================================================
000106E0                            ; ---------------------------------------------------------------------------
000106E0                            ; Tracker command for initializing modulation
000106E0                            ; ---------------------------------------------------------------------------
000106E0                            
000106E0                            dcMod68K:
000106E0 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
000106E4 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
000106E8 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
000106EC 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
000106F0                            
000106F0 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
000106F2 E208                       		lsr.b	#1,d0			; halve it
000106F4 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
000106F8 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
000106FC                            	; continue to enabling modulation
000106FC                            ; ===========================================================================
000106FC                            ; ---------------------------------------------------------------------------
000106FC                            ; Tracker commands for enabling and disabling modulation
000106FC                            ; ---------------------------------------------------------------------------
000106FC                            
000106FC                            dcModOn:
000106FC 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
00010700 4E75                       		rts
00010702                            
00010702                            dcModOff:
00010702 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
00010706 4E75                       		rts
00010708                            ; ===========================================================================
00010708                            ; ---------------------------------------------------------------------------
00010708                            ; Tracker command for returning from tracker subroutine
00010708                            ; ---------------------------------------------------------------------------
00010708                            
00010708                            dcReturn:
00010708                            		AMPS_Debug_dcReturn1		; check if this channel supports the stack
00010708 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001070C 6500                     M 	blo.s	.ok1
0001070E                          M 	raiseerror	"sRet on a SFX channel!",amps_debug_console_channel
0001070E 487A FFFE                M 	pea	*(pc)
00010712                          M 	raiseerror2	"sRet on a SFX channel!",amps_debug_console_channel
00010712 40E7                     M 	move.w	sr,-(sp)
00010714                          M 	__fstring_generateargumentscode	"sRet on a SFX channel!"
00010714 =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
00010714 =00000000                M 	__stack:set	0
00010714 =00000000                M 	__sp:	set 0
00010714                          M 	while	(__pos)
00010714                          M 	rept	__stack
00010714 4EB9 0000 0000           M 	jsr	errorhandler
0001071A                          M 	__fstring_generatedecodedstring	"sRet on a SFX channel!"
0001071A =00000001                M 	__lpos:	set 1
0001071A =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
0001071A                          M 	while	(__pos)
0001071A                          M 	__substr:	substr __lpos,,"sRet on a SFX channel!"
0001071A 7352 6574 206F 6E20 6120+M 	dc.b	"sRet on a SFX channel!"
00010730 00                       M 	dc.b	0
00010731 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010732                          M 	even
00010732 4EFA CC18                M 	jmp	amps_debug_console_channel
00010736                          M 	even
00010736                          M .ok1
00010736 7000                       		moveq	#0,d0
00010738 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001073C 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
00010740                            
00010740 544C                       		addq.w	#2,a4			; skip the call address parameter
00010742 5800                       		addq.b	#4,d0			; deallocate stack space
00010744 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
00010748                            
00010748                            		AMPS_Debug_dcReturn2		; check if we underflowed the space
00010748 0C00 002C                M 	cmp.b	#csize,d0
0001074C 6300                     M 	bls.s	.ok2
0001074E                          M 	raiseerror	"sRet stack too shallow!",amps_debug_console_channel
0001074E 487A FFFE                M 	pea	*(pc)
00010752                          M 	raiseerror2	"sRet stack too shallow!",amps_debug_console_channel
00010752 40E7                     M 	move.w	sr,-(sp)
00010754                          M 	__fstring_generateargumentscode	"sRet stack too shallow!"
00010754 =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
00010754 =00000000                M 	__stack:set	0
00010754 =00000000                M 	__sp:	set 0
00010754                          M 	while	(__pos)
00010754                          M 	rept	__stack
00010754 4EB9 0000 0000           M 	jsr	errorhandler
0001075A                          M 	__fstring_generatedecodedstring	"sRet stack too shallow!"
0001075A =00000001                M 	__lpos:	set 1
0001075A =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
0001075A                          M 	while	(__pos)
0001075A                          M 	__substr:	substr __lpos,,"sRet stack too shallow!"
0001075A 7352 6574 2073 7461 636B+M 	dc.b	"sRet stack too shallow!"
00010771 00                       M 	dc.b	0
00010772 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010774 00                       M 	even
00010774 4EFA CBD6                M 	jmp	amps_debug_console_channel
00010778                          M 	even
00010778                          M .ok2
00010778 4E75                       		rts
0001077A                            ; ===========================================================================
0001077A                            ; ---------------------------------------------------------------------------
0001077A                            ; Tracker command for initializing special FM3 mode
0001077A                            ; ---------------------------------------------------------------------------
0001077A                            
0001077A                            dcSpecFM3:
0001077A                            		AMPS_Debug_dcInvalid		; this is an invalid command
0001077A                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
0001077A 487A FFFE                M 	pea	*(pc)
0001077E                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
0001077E 40E7                     M 	move.w	sr,-(sp)
00010780                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010780 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010780 =00000000                M 	__stack:set	0
00010780 =00000000                M 	__sp:	set 0
00010780                          M 	while	(__pos)
00010780                          M 	rept	__stack
00010780 4EB9 0000 0000           M 	jsr	errorhandler
00010786                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010786 =00000001                M 	__lpos:	set 1
00010786 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010786                          M 	while	(__pos)
00010786                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010786 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
0001079F 00                       M 	dc.b	0
000107A0 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000107A2 00                       M 	even
000107A2 4EFA CBA8                M 	jmp	amps_debug_console_channel
000107A6                          M 	even
000107A6 4E75                       		rts
000107A8                            ; ===========================================================================
000107A8                            ; ---------------------------------------------------------------------------
000107A8                            ; Tracker command for enabling raw frequency mode
000107A8                            ; ---------------------------------------------------------------------------
000107A8                            
000107A8                            dcFreqOn:
000107A8                            		AMPS_Debug_dcInvalid		; this is an invalid command
000107A8                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000107A8 487A FFFE                M 	pea	*(pc)
000107AC                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000107AC 40E7                     M 	move.w	sr,-(sp)
000107AE                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000107AE =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000107AE =00000000                M 	__stack:set	0
000107AE =00000000                M 	__sp:	set 0
000107AE                          M 	while	(__pos)
000107AE                          M 	rept	__stack
000107AE 4EB9 0000 0000           M 	jsr	errorhandler
000107B4                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000107B4 =00000001                M 	__lpos:	set 1
000107B4 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000107B4                          M 	while	(__pos)
000107B4                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000107B4 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000107CD 00                       M 	dc.b	0
000107CE 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000107D0 00                       M 	even
000107D0 4EFA CB7A                M 	jmp	amps_debug_console_channel
000107D4                          M 	even
000107D4 4E75                       		rts
000107D6                            ; ===========================================================================
000107D6                            ; ---------------------------------------------------------------------------
000107D6                            ; Tracker command for disabling raw frequency mode
000107D6                            ; ---------------------------------------------------------------------------
000107D6                            
000107D6                            dcFreqOff:
000107D6                            		AMPS_Debug_dcInvalid		; this is an invalid command
000107D6                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000107D6 487A FFFE                M 	pea	*(pc)
000107DA                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000107DA 40E7                     M 	move.w	sr,-(sp)
000107DC                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000107DC =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000107DC =00000000                M 	__stack:set	0
000107DC =00000000                M 	__sp:	set 0
000107DC                          M 	while	(__pos)
000107DC                          M 	rept	__stack
000107DC 4EB9 0000 0000           M 	jsr	errorhandler
000107E2                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000107E2 =00000001                M 	__lpos:	set 1
000107E2 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000107E2                          M 	while	(__pos)
000107E2                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000107E2 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000107FB 00                       M 	dc.b	0
000107FC 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000107FE 00                       M 	even
000107FE 4EFA CB4C                M 	jmp	amps_debug_console_channel
00010802                          M 	even
00010802                            
00010802                            locret_FreqOff:
00010802 4E75                       		rts
00010804                            ; ===========================================================================
00010804                            ; ---------------------------------------------------------------------------
00010804                            ; Tracker command for changing voice, volume envelope or sample
00010804                            ; ---------------------------------------------------------------------------
00010804                            
00010804                            dcVoice:
00010804 7000                       		moveq	#0,d0
00010806 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
00010808 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001080C                            
0001080C 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
00010810 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
00010812 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010818 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001081A                            
0001081A 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001081E 66E2                       		bne.s	locret_FreqOff		; if is, skip
00010820 224E                       		move.l	a6,a1			; load voice table to a1
00010822                            	; continue to send FM voice
00010822                            ; ===========================================================================
00010822                            ; ---------------------------------------------------------------------------
00010822                            ; Subroutine for sending the FM voice to YM2612
00010822                            ; This routine is speed optimized in a way that allows Dual PCM
00010822                            ; to only be stopped for as long as it must be. This will waste
00010822                            ; some cycles for 68000, but it will help improve DAC quality.
00010822                            ; ---------------------------------------------------------------------------
00010822                            
00010822                            dUpdateVoiceFM:
00010822                            	dCALC_VOICE				; get address of the specific voice to a1
00010822 EB48                     M 	lsl.w	#5,d0
00010824 D2C0                     M 	add.w	d0,a1
00010826 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001082A 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001082C                            
0001082C 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001082E 16C4                       		move.b	d4,(a3)+		; save it to free space
00010830 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
00010834                            
00010834 45FA ED86                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
00010838                            	rept VoiceRegs-5
00010838                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
00010838                            		move.b	(a2)+,(a3)+		; copy each command
00010838                            	endr
00010838 16D9                     M 	move.b	(a1)+,(a3)+
0001083A 16DA                     M 	move.b	(a2)+,(a3)+
0001083C 16D9                     M 	move.b	(a1)+,(a3)+
0001083E 16DA                     M 	move.b	(a2)+,(a3)+
00010840 16D9                     M 	move.b	(a1)+,(a3)+
00010842 16DA                     M 	move.b	(a2)+,(a3)+
00010844 16D9                     M 	move.b	(a1)+,(a3)+
00010846 16DA                     M 	move.b	(a2)+,(a3)+
00010848 16D9                     M 	move.b	(a1)+,(a3)+
0001084A 16DA                     M 	move.b	(a2)+,(a3)+
0001084C 16D9                     M 	move.b	(a1)+,(a3)+
0001084E 16DA                     M 	move.b	(a2)+,(a3)+
00010850 16D9                     M 	move.b	(a1)+,(a3)+
00010852 16DA                     M 	move.b	(a2)+,(a3)+
00010854 16D9                     M 	move.b	(a1)+,(a3)+
00010856 16DA                     M 	move.b	(a2)+,(a3)+
00010858 16D9                     M 	move.b	(a1)+,(a3)+
0001085A 16DA                     M 	move.b	(a2)+,(a3)+
0001085C 16D9                     M 	move.b	(a1)+,(a3)+
0001085E 16DA                     M 	move.b	(a2)+,(a3)+
00010860 16D9                     M 	move.b	(a1)+,(a3)+
00010862 16DA                     M 	move.b	(a2)+,(a3)+
00010864 16D9                     M 	move.b	(a1)+,(a3)+
00010866 16DA                     M 	move.b	(a2)+,(a3)+
00010868 16D9                     M 	move.b	(a1)+,(a3)+
0001086A 16DA                     M 	move.b	(a2)+,(a3)+
0001086C 16D9                     M 	move.b	(a1)+,(a3)+
0001086E 16DA                     M 	move.b	(a2)+,(a3)+
00010870 16D9                     M 	move.b	(a1)+,(a3)+
00010872 16DA                     M 	move.b	(a2)+,(a3)+
00010874 16D9                     M 	move.b	(a1)+,(a3)+
00010876 16DA                     M 	move.b	(a2)+,(a3)+
00010878 16D9                     M 	move.b	(a1)+,(a3)+
0001087A 16DA                     M 	move.b	(a2)+,(a3)+
0001087C 16D9                     M 	move.b	(a1)+,(a3)+
0001087E 16DA                     M 	move.b	(a2)+,(a3)+
00010880 16D9                     M 	move.b	(a1)+,(a3)+
00010882 16DA                     M 	move.b	(a2)+,(a3)+
00010884 16D9                     M 	move.b	(a1)+,(a3)+
00010886 16DA                     M 	move.b	(a2)+,(a3)+
00010888 16D9                     M 	move.b	(a1)+,(a3)+
0001088A 16DA                     M 	move.b	(a2)+,(a3)+
0001088C 16D9                     M 	move.b	(a1)+,(a3)+
0001088E 16DA                     M 	move.b	(a2)+,(a3)+
00010890 16D9                     M 	move.b	(a1)+,(a3)+
00010892 16DA                     M 	move.b	(a2)+,(a3)+
00010894 16D9                     M 	move.b	(a1)+,(a3)+
00010896 16DA                     M 	move.b	(a2)+,(a3)+
00010898                            
00010898 7C00                       		moveq	#0,d6			; reset the modulator offset
0001089A 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001089E D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
000108A2 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
000108A4 767F                       		moveq	#$7F,d3			; force FM volume to silence
000108A6                            
000108A6                            .noover
000108A6 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
000108AC 6700                       		beq.s	.uwdone			; if not, skip
000108AE 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
000108B0 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
000108B4 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
000108B6 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
000108B8                            
000108B8                            .uwdone
000108B8 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
000108BA                            
000108BA                            .tlloop
000108BA 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
000108BC 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
000108BE                            
000108BE D203                       		add.b	d3,d1			; add carrier offset to loaded value
000108C0 6B00                       		bmi.s	.slot			; if we did not overflow, branch
000108C2 727F                       		moveq	#$7F,d1			; cap to silent volume
000108C4 6000                       		bra.s	.slot
000108C6                            
000108C6                            .noslot
000108C6 D206                       		add.b	d6,d1			; add modulator offset to loaded value
000108C8                            .slot
000108C8 16C1                       		move.b	d1,(a3)+		; save the Total Level value
000108CA 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
000108CC 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
000108D0                            
000108D0                            		AMPS_Debug_UpdVoiceFM		; check if the voice was valid
000108D0 0C19 004E                M 	cmp.b	#'N',(a1)+
000108D4 6600                     M 	bne.s	.fail
000108D6 0C59 4154                M 	cmp.w	#'AT',(a1)+
000108DA 6700                     M 	beq.s	.ok
000108DC                          M .fail
000108DC                          M 	raiseerror	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
000108DC 487A FFFE                M 	pea	*(pc)
000108E0                          M 	raiseerror2	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
000108E0 40E7                     M 	move.w	sr,-(sp)
000108E2                          M 	__fstring_generateargumentscode	"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108E2 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000108E2 =00000000                M 	__stack:set	0
000108E2 =00000000                M 	__sp:	set 0
000108E2                          M 	while	(__pos)
000108E2 =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
000108E2 =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
000108E2 =0000002F                M 	__midpos:	= __endpos
000108E2                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108E2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108E2                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108E2                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108E2                          M 	pushp	"move.b cVoice(a5),1(sp)"
000108E2                          M 	pushp	"subq.w	#2, sp"
000108E2 =00000002                M 	__stack:	= __stack+2
000108E2 =00000002                M 	__sp:	= __sp+2
000108E2 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000108E2                          M 	rept	__stack
000108E2                          M 	popp	__command
000108E2 554F                     M 	subq.w	#2,sp
000108E4                          M 	popp	__command
000108E4 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
000108EA 4EB9 0000 0000           M 	jsr	errorhandler
000108F0                          M 	__fstring_generatedecodedstring	"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108F0 =00000001                M 	__lpos:	set 1
000108F0 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000108F0                          M 	while	(__pos)
000108F0                          M 	__substr:	substr __lpos,__pos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000108F0 464D 2076 6F69 6365 2055+M 	dc.b	"FM voice Update invalid voice: "
0001090F =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
0001090F =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
0001090F =0000002F                M 	__midpos:	= __endpos
0001090F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001090F                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001090F                          M 	__param:	substr ,,"hex"
0001090F 80                       M 	dc.b	hex
00010910 =00000030                M 	__lpos:	set __endpos+1
00010910 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
00010910                          M 	__substr:	substr __lpos,,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010910                          M 	dc.b	""
00010910 00                       M 	dc.b	0
00010911 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010912                          M 	even
00010912 4EFA CA38                M 	jmp	amps_debug_console_channel
00010916                          M 	even
00010916                          M .ok
00010916                            
00010916 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001091A 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001091E 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
00010922                            
00010922 7400                       		moveq	#0,d2			; prepare part 1 value
00010924 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
00010928 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001092C 6700                       		beq.s	.ptok			; if so, branch
0001092E 0203 0003                  		and.b	#3,d3			; get channel offset only
00010932 7402                       		moveq	#2,d2			; prepare part 2 value
00010934                            
00010934                            .ptok
00010934 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
00010936 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
00010938                            		AMPS_Debug_CuePtr 0		; make sure cue is valid
00010938 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0001093E 6500                     M 	blo.s	.fail_757
00010940 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
00010946 6500                     M 	blo.s	.ok_757
00010948                          M .fail_757
00010948 4EBA D782                M 	jsr	amps_debug_cueptr0
0001094C                          M .ok_757
0001094C                            	StopZ80					; wait for Z80 to stop
0001094C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
00010954                          M 	waitz80stop
00010954 0839 0000 00A1 1100      M .wait_759:	btst	#0,z80_bus_req
0001095C 66F6                     M 	bne.s	.wait_759
0001095E                            
0001095E                            .write
0001095E 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
00010960 10DB                       		move.b	(a3)+,(a0)+		; write command values
00010962                            
00010962 101B                       		move.b	(a3)+,d0		; load YM command
00010964 8003                       		or.b	d3,d0			; add the channel offset to command
00010966 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
00010968 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001096C 50D0                       		st	(a0)			; mark as end of the cue
0001096E                            
0001096E                            	StartZ80				; enable Z80 execution
0001096E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
00010976 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001097A 4E75                       		rts
0001097C                            ; ===========================================================================
0001097C                            ; ---------------------------------------------------------------------------
0001097C                            ; Tracker command for stopping the current channel
0001097C                            ; ---------------------------------------------------------------------------
0001097C                            
0001097C                            dcStop:
0001097C 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
00010980 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
00010984 6B00                       		bmi.s	.mutePSG		; if yes, mute it
00010986                            
00010986 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001098C 6600                       		bne.s	.cont			; if we are, skip
0001098E 4EBA EFB0                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
00010992 6000                       		bra.s	.cont
00010994                            ; ---------------------------------------------------------------------------
00010994                            
00010994                            .mutePSG
00010994 4EBA F87C                  		jsr	dMutePSGmus(pc)		; mute PSG channel
00010998                            
00010998                            .cont
00010998 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001099C 6500                       		blo.s	.exit			; if not, skip all this mess
0001099E 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
000109A2                            
000109A2 43FA E7F2                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
000109A6 7600                       		moveq	#0,d3
000109A8 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
000109AC 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
000109AE 3F0D                       		move.w	a5,-(sp)		; push channel pointer
000109B0                            
000109B0 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
000109B4 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
000109B6 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
000109B8 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
000109BC                            
000109BC                            .dacdone
000109BC 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
000109BE 6A00                       		bpl.s	.fixch			; if not, branch
000109C0                            
000109C0 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
000109C4 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
000109C8 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
000109CE 6600                       		bne.s	.fixch			; if yes, skip
000109D0                            
000109D0 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
000109D4 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
000109D8 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
000109DC 4EBA FE44                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
000109E0                            
000109E0                            .fixch
000109E0 3A5F                       		move.w	(sp)+,a5		; pop the current channel
000109E2                            .exit
000109E2 5497                       		addq.l	#2,(sp)			; go to next channel immediately
000109E4 4E75                       		rts
000109E6                            ; ---------------------------------------------------------------------------
000109E6                            ; There is nothing that would break even if the channel is not
000109E6                            ; running a tracker, so we do not bother checking
000109E6                            ; ---------------------------------------------------------------------------
000109E6                            
000109E6                            .psg
000109E6 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
000109E8 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
000109EC 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
000109F0 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
000109F4                            
000109F4 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
000109FA 66E6                       		bne.s	.exit			; if not, skip
000109FC 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
00010A04 60DC                       		bra.s	.exit
00010A06                            ; ===========================================================================
00010A06                            ; ---------------------------------------------------------------------------
00010A06                            ; Tracker command for enabling LFO
00010A06                            ; ---------------------------------------------------------------------------
00010A06                            
00010A06                            dcsLFO:
00010A06 7000                       		moveq	#0,d0
00010A08 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
00010A0C 224E                       		move.l	a6,a1			; load voice table to a1
00010A0E                            
00010A0E                            	dCALC_VOICE 9				; get address of the specific voice to a1
00010A0E EB48                     M 	lsl.w	#5,d0
00010A10 0640 0009                M 	add.w	#9,d0
00010A14 D2C0                     M 	add.w	d0,a1
00010A16 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
00010A18 45FA EBAA                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
00010A1C 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
00010A1E                            
00010A1E                            .decayloop
00010A1E 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
00010A20 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
00010A22                            
00010A22 D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
00010A24 6400                       		bcc.s	.noLFO			; if not, skip
00010A26 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
00010A2A 4EBA EF2E                  		jsr	WriteChYM(pc)		; write to YM according to channel
00010A2E                            
00010A2E                            .noLFO
00010A2E 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
00010A32                            
00010A32 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
00010A34 7022                       		moveq	#$22,d0			; YM command: LFO
00010A36 4EBA EF2E                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
00010A3A                            
00010A3A 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
00010A3C 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
00010A40                            
00010A40 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
00010A42 4EFA EF10                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
00010A46                            ; ===========================================================================
00010A46                            ; ---------------------------------------------------------------------------
00010A46                            ; Tracker command for resetting condition
00010A46                            ; ---------------------------------------------------------------------------
00010A46                            
00010A46                            dcResetCond:
00010A46 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
00010A4A 4E75                       		rts
00010A4C                            ; ===========================================================================
00010A4C                            ; ---------------------------------------------------------------------------
00010A4C                            ; Tracker command for writing to communications flags
00010A4C                            ; ---------------------------------------------------------------------------
00010A4C                            
00010A4C                            dcsComm:
00010A4C 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
00010A50 7000                       		moveq	#0,d0
00010A52 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
00010A54 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
00010A58 4E75                       		rts
00010A5A                            ; ===========================================================================
00010A5A                            ; ---------------------------------------------------------------------------
00010A5A                            ; RAM addresses for special condition code
00010A5A                            ; ---------------------------------------------------------------------------
00010A5A                            
00010A5A                            dcCondRegTable:
00010A5A C746 C4A6                  	dc.w hwVersion, mFlags	; 0
00010A5E C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
00010A62 0000 0000                  	dc.w 0, 0			; 4
00010A66 0000 0000                  	dc.w 0, 0			; 6
00010A6A 0000 0000                  	dc.w 0, 0			; 8
00010A6E 0000 0000                  	dc.w 0, 0			; $A
00010A72 0000 0000                  	dc.w 0, 0			; $C
00010A76 0000 0001                  	dc.w 0, cType			; $E
00010A7A                            ; ===========================================================================
00010A7A                            ; ---------------------------------------------------------------------------
00010A7A                            ; Tracker command for checking special RAM addresses
00010A7A                            ; ---------------------------------------------------------------------------
00010A7A                            
00010A7A                            dcCondReg:
00010A7A 101C                       		move.b	(a4)+,d0		; get value from tracker
00010A7C 1200                       		move.b	d0,d1			; copy to d1
00010A7E                            
00010A7E 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
00010A82 D040                       		add.w	d0,d0			; double it (each entry is 1 word)
00010A84 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
00010A88 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
00010A8A D04D                       		add.w	a5,d0			; else it was a channel offset
00010A8C                            
00010A8C                            .gotit
00010A8C 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
00010A8E 1011                       		move.b	(a1),d0			; read byte from it
00010A90 6000                       		bra.s	dcCondCom
00010A92                            ; ===========================================================================
00010A92                            ; ---------------------------------------------------------------------------
00010A92                            ; Tracker command for checking communications bytes
00010A92                            ; ---------------------------------------------------------------------------
00010A92                            
00010A92                            dcCond:
00010A92 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
00010A96 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
00010A98 1200                       		move.b	d0,d1			; copy to d1
00010A9A 0240 000F                  		and.w	#$F,d0			; get offset only
00010A9E 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
00010AA2                            
00010AA2                            dcCondCom:
00010AA2 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
00010AA6 0241 00F0                  		and.w	#$F0,d1			; get condition value only
00010AAA E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
00010AAC B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
00010AAE 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
00010AB2                            ; ===========================================================================
00010AB2                            ; ---------------------------------------------------------------------------
00010AB2                            ; Code for setting the condition flag
00010AB2                            ; ---------------------------------------------------------------------------
00010AB2                            
00010AB2                            .c	macro x
00010AB2                            	\x	.false
00010AB2                            	rts
00010AB2                                 endm
00010AB2                            
00010AB2                            .false
00010AB2 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
00010AB6                            
00010AB6 4E75                       .cond	rts		; T
00010AB8 4E75                       	rts
00010ABA                            	.c bra.s	; F
00010ABA 60F6                     M 	bra.s	.false
00010ABC 4E75                     M 	rts
00010ABE                            	.c bls.s	; HI
00010ABE 63F2                     M 	bls.s	.false
00010AC0 4E75                     M 	rts
00010AC2                            	.c bhi.s	; LS
00010AC2 62EE                     M 	bhi.s	.false
00010AC4 4E75                     M 	rts
00010AC6                            	.c blo.s	; HS/CC
00010AC6 65EA                     M 	blo.s	.false
00010AC8 4E75                     M 	rts
00010ACA                            	.c bhs.s	; LO/CS
00010ACA 64E6                     M 	bhs.s	.false
00010ACC 4E75                     M 	rts
00010ACE                            	.c beq.s	; NE
00010ACE 67E2                     M 	beq.s	.false
00010AD0 4E75                     M 	rts
00010AD2                            	.c bne.s	; EQ
00010AD2 66DE                     M 	bne.s	.false
00010AD4 4E75                     M 	rts
00010AD6                            	.c bvs.s	; VC
00010AD6 69DA                     M 	bvs.s	.false
00010AD8 4E75                     M 	rts
00010ADA                            	.c bvc.s	; VS
00010ADA 68D6                     M 	bvc.s	.false
00010ADC 4E75                     M 	rts
00010ADE                            	.c bmi.s	; PL
00010ADE 6BD2                     M 	bmi.s	.false
00010AE0 4E75                     M 	rts
00010AE2                            	.c bpl.s	; MI
00010AE2 6ACE                     M 	bpl.s	.false
00010AE4 4E75                     M 	rts
00010AE6                            	.c blt.s	; GE
00010AE6 6DCA                     M 	blt.s	.false
00010AE8 4E75                     M 	rts
00010AEA                            	.c bge.s	; LT
00010AEA 6CC6                     M 	bge.s	.false
00010AEC 4E75                     M 	rts
00010AEE                            	.c ble.s	; GT
00010AEE 6FC2                     M 	ble.s	.false
00010AF0 4E75                     M 	rts
00010AF2                            	.c bgt.s	; LE
00010AF2 6EBE                     M 	bgt.s	.false
00010AF4 4E75                     M 	rts
00010AF6                            ; ===========================================================================
00010AF6                            ; ---------------------------------------------------------------------------
00010AF6                            ; Tracker command for freezing the CPU. DEBUG FLAG
00010AF6                            ; ---------------------------------------------------------------------------
00010AF6                            
00010AF6                            dcFreeze:
00010AF6 6000 FFFE                  		bra.w	*		; Freeze CPU here
00010AFA 4E75                       		rts
00010AFC                            ; ===========================================================================
00010AFC                            ; ---------------------------------------------------------------------------
00010AFC                            ; Tracker command for debugging tracker data. DEBUG FLAG
00010AFC                            ; ---------------------------------------------------------------------------
00010AFC                            
00010AFC                            dcTracker:
00010AFC 50F8 C740                  		st	msChktracker.w	; set debug flag
00010B00 4E75                       		rts
00010B02                            ; ===========================================================================
00010B02                            ; ---------------------------------------------------------------------------
00010B02                            ; Check if a song is playing
00010B02                            ; ---------------------------------------------------------------------------
00010B02                            
00010B02                            dChkSongPlay:
00010B02 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
00010B06 7209                       	moveq	#Mus_Ch-1,d1
00010B08                            
00010B08                            .ChkTracks:
00010B08 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
00010B0A 6B00                       	bmi.s	.Playing		; If so, branch
00010B0C 43E9 002C                  	lea	cSize(a1),a1		; Next track
00010B10 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
00010B14 7200                       	moveq	#0,d1
00010B16 4E75                       	rts
00010B18                            
00010B18                            .Playing:
00010B18 50C1                       	st	d1
00010B1A 4E75                       	rts
00010B1C                            ; ===========================================================================
00010B1C                            ; ---------------------------------------------------------------------------
00010B1C                            ; Define music and SFX
00010B1C                            ; ---------------------------------------------------------------------------
00010B1C                            
00010B1C                            	opt oz-				; disable zero-offset optimization
00010B1C                            
00010B1C =00000082                  __sfx =		SFXoff
00010B1C =0000000A                  __mus =		MusOff
00010B1C                            	include	"Sound/sfx.asm"
00010B1C                            
00010B1C                            
00010B1C                            ; ------------------------------------------------------------------------
00010B1C                            ; AMPS SFX list
00010B1C                            ; -------------------------------------------------------------------------
00010B1C                            
00010B1C                            ; -------------------------------------------------------------------------
00010B1C                            ; SFX index
00010B1C                            ; -------------------------------------------------------------------------
00010B1C                            
00010B1C                            SoundIndex:
00010B1C                            	ptrSFX	$00, Snd_Jump
00010B1C =00000000                M .type	=	$00<<24
00010B1C                          M 	rept	narg-1
00010B1C 0000 0000                M 	dc.l	snd_jump|.type
00010B20 =00000083                M __sfx	=	__sfx+1
00010B20                          M 	shift
00010B20                            	ptrSFX	$00, Snd_Skid
00010B20 =00000000                M .type	=	$00<<24
00010B20                          M 	rept	narg-1
00010B20 0000 0000                M 	dc.l	snd_skid|.type
00010B24 =00000084                M __sfx	=	__sfx+1
00010B24                          M 	shift
00010B24                            	ptrSFX	$00, Snd_Death
00010B24 =00000000                M .type	=	$00<<24
00010B24                          M 	rept	narg-1
00010B24 0000 0000                M 	dc.l	snd_death|.type
00010B28 =00000085                M __sfx	=	__sfx+1
00010B28                          M 	shift
00010B28                            	ptrSFX	$00, Snd_Push
00010B28 =00000000                M .type	=	$00<<24
00010B28                          M 	rept	narg-1
00010B28 0000 0000                M 	dc.l	snd_push|.type
00010B2C =00000086                M __sfx	=	__sfx+1
00010B2C                          M 	shift
00010B2C                            	ptrSFX	$00, Snd_Bubble
00010B2C =00000000                M .type	=	$00<<24
00010B2C                          M 	rept	narg-1
00010B2C 0000 0000                M 	dc.l	snd_bubble|.type
00010B30 =00000087                M __sfx	=	__sfx+1
00010B30                          M 	shift
00010B30                            	ptrSFX	$00, Snd_Drown
00010B30 =00000000                M .type	=	$00<<24
00010B30                          M 	rept	narg-1
00010B30 0000 0000                M 	dc.l	snd_drown|.type
00010B34 =00000088                M __sfx	=	__sfx+1
00010B34                          M 	shift
00010B34                            	ptrSFX	$00, Snd_DrownWarning
00010B34 =00000000                M .type	=	$00<<24
00010B34                          M 	rept	narg-1
00010B34 0000 0000                M 	dc.l	snd_drownwarning|.type
00010B38 =00000089                M __sfx	=	__sfx+1
00010B38                          M 	shift
00010B38                            	ptrSFX	$00, Snd_DrownCountdown
00010B38 =00000000                M .type	=	$00<<24
00010B38                          M 	rept	narg-1
00010B38 0000 0000                M 	dc.l	snd_drowncountdown|.type
00010B3C =0000008A                M __sfx	=	__sfx+1
00010B3C                          M 	shift
00010B3C                            	ptrSFX	$00, Snd_Checkpoint
00010B3C =00000000                M .type	=	$00<<24
00010B3C                          M 	rept	narg-1
00010B3C 0000 0000                M 	dc.l	snd_checkpoint|.type
00010B40 =0000008B                M __sfx	=	__sfx+1
00010B40                          M 	shift
00010B40                            	ptrSFX	$00, Snd_SpikeMove
00010B40 =00000000                M .type	=	$00<<24
00010B40                          M 	rept	narg-1
00010B40 0000 0000                M 	dc.l	snd_spikemove|.type
00010B44 =0000008C                M __sfx	=	__sfx+1
00010B44                          M 	shift
00010B44                            	ptrSFX	$00, Snd_Ring
00010B44 =00000000                M .type	=	$00<<24
00010B44                          M 	rept	narg-1
00010B44 0000 0000                M 	dc.l	snd_ring|.type
00010B48 =0000008D                M __sfx	=	__sfx+1
00010B48                          M 	shift
00010B48                            	ptrSFX	$00, Snd_RingLoss
00010B48 =00000000                M .type	=	$00<<24
00010B48                          M 	rept	narg-1
00010B48 0000 0000                M 	dc.l	snd_ringloss|.type
00010B4C =0000008E                M __sfx	=	__sfx+1
00010B4C                          M 	shift
00010B4C                            	ptrSFX	$00, Snd_Spring
00010B4C =00000000                M .type	=	$00<<24
00010B4C                          M 	rept	narg-1
00010B4C 0000 0000                M 	dc.l	snd_spring|.type
00010B50 =0000008F                M __sfx	=	__sfx+1
00010B50                          M 	shift
00010B50                            	ptrSFX	$00, Snd_Shield
00010B50 =00000000                M .type	=	$00<<24
00010B50                          M 	rept	narg-1
00010B50 0000 0000                M 	dc.l	snd_shield|.type
00010B54 =00000090                M __sfx	=	__sfx+1
00010B54                          M 	shift
00010B54                            	ptrSFX	$00, Snd_Splash
00010B54 =00000000                M .type	=	$00<<24
00010B54                          M 	rept	narg-1
00010B54 0000 0000                M 	dc.l	snd_splash|.type
00010B58 =00000091                M __sfx	=	__sfx+1
00010B58                          M 	shift
00010B58                            	ptrSFX	$00, Snd_Bumper
00010B58 =00000000                M .type	=	$00<<24
00010B58                          M 	rept	narg-1
00010B58 0000 0000                M 	dc.l	snd_bumper|.type
00010B5C =00000092                M __sfx	=	__sfx+1
00010B5C                          M 	shift
00010B5C                            	ptrSFX	$00, Snd_Switch
00010B5C =00000000                M .type	=	$00<<24
00010B5C                          M 	rept	narg-1
00010B5C 0000 0000                M 	dc.l	snd_switch|.type
00010B60 =00000093                M __sfx	=	__sfx+1
00010B60                          M 	shift
00010B60                            	ptrSFX	$00, Snd_Signpost
00010B60 =00000000                M .type	=	$00<<24
00010B60                          M 	rept	narg-1
00010B60 0000 0000                M 	dc.l	snd_signpost|.type
00010B64 =00000094                M __sfx	=	__sfx+1
00010B64                          M 	shift
00010B64                            	ptrSFX	$00, Snd_Collapse
00010B64 =00000000                M .type	=	$00<<24
00010B64                          M 	rept	narg-1
00010B64 0000 0000                M 	dc.l	snd_collapse|.type
00010B68 =00000095                M __sfx	=	__sfx+1
00010B68                          M 	shift
00010B68                            	ptrSFX	$00, Snd_WallSmash
00010B68 =00000000                M .type	=	$00<<24
00010B68                          M 	rept	narg-1
00010B68 0000 0000                M 	dc.l	snd_wallsmash|.type
00010B6C =00000096                M __sfx	=	__sfx+1
00010B6C                          M 	shift
00010B6C                            	ptrSFX	$00, Snd_Rumble
00010B6C =00000000                M .type	=	$00<<24
00010B6C                          M 	rept	narg-1
00010B6C 0000 0000                M 	dc.l	snd_rumble|.type
00010B70 =00000097                M __sfx	=	__sfx+1
00010B70                          M 	shift
00010B70                            	ptrSFX	$00, Snd_Warp
00010B70 =00000000                M .type	=	$00<<24
00010B70                          M 	rept	narg-1
00010B70 0000 0000                M 	dc.l	snd_warp|.type
00010B74 =00000098                M __sfx	=	__sfx+1
00010B74                          M 	shift
00010B74                            	ptrSFX	$00, Snd_BossHit
00010B74 =00000000                M .type	=	$00<<24
00010B74                          M 	rept	narg-1
00010B74 0000 0000                M 	dc.l	snd_bosshit|.type
00010B78 =00000099                M __sfx	=	__sfx+1
00010B78                          M 	shift
00010B78                            	ptrSFX	$00, Snd_Bomb
00010B78 =00000000                M .type	=	$00<<24
00010B78                          M 	rept	narg-1
00010B78 0000 0000                M 	dc.l	snd_bomb|.type
00010B7C =0000009A                M __sfx	=	__sfx+1
00010B7C                          M 	shift
00010B7C                            	ptrSFX	$00, Snd_BreakItem
00010B7C =00000000                M .type	=	$00<<24
00010B7C                          M 	rept	narg-1
00010B7C 0000 0000                M 	dc.l	snd_breakitem|.type
00010B80 =0000009B                M __sfx	=	__sfx+1
00010B80                          M 	shift
00010B80                            	ptrSFX	$00, Snd_FloorBounce
00010B80 =00000000                M .type	=	$00<<24
00010B80                          M 	rept	narg-1
00010B80 0000 0000                M 	dc.l	snd_floorbounce|.type
00010B84 =0000009C                M __sfx	=	__sfx+1
00010B84                          M 	shift
00010B84                            	ptrSFX	$00, Snd_Charge
00010B84 =00000000                M .type	=	$00<<24
00010B84                          M 	rept	narg-1
00010B84 0000 0000                M 	dc.l	snd_charge|.type
00010B88 =0000009D                M __sfx	=	__sfx+1
00010B88                          M 	shift
00010B88                            	ptrSFX	$00, Snd_ChargeStop
00010B88 =00000000                M .type	=	$00<<24
00010B88                          M 	rept	narg-1
00010B88 0000 0000                M 	dc.l	snd_chargestop|.type
00010B8C =0000009E                M __sfx	=	__sfx+1
00010B8C                          M 	shift
00010B8C                            	ptrSFX	$00, Snd_ChargeRelease
00010B8C =00000000                M .type	=	$00<<24
00010B8C                          M 	rept	narg-1
00010B8C 0000 0000                M 	dc.l	snd_chargerelease|.type
00010B90 =0000009F                M __sfx	=	__sfx+1
00010B90                          M 	shift
00010B90                            	ptrSFX	$00, Snd_DiamondBreak
00010B90 =00000000                M .type	=	$00<<24
00010B90                          M 	rept	narg-1
00010B90 0000 0000                M 	dc.l	snd_diamondbreak|.type
00010B94 =000000A0                M __sfx	=	__sfx+1
00010B94                          M 	shift
00010B94                            SoundIndex_End:
00010B94                            
00010B94                            ; -------------------------------------------------------------------------
00010B94                            	include	"Sound/music.asm"
00010B94                            
00010B94                            
00010B94                            ; ------------------------------------------------------------------------
00010B94                            ; AMPS music list
00010B94                            ; -------------------------------------------------------------------------
00010B94                            
00010B94                            ; -------------------------------------------------------------------------
00010B94                            ; Music index
00010B94                            ; -------------------------------------------------------------------------
00010B94                            
00010B94                            MusicIndex:
00010B94                            	ptrMusic	Mus_WWZ,		$00
00010B94                          M 	rept	narg/2
00010B94 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010B98 =0000000B                M __mus	=	__mus+1
00010B98                          M 	shift
00010B98                          M 	shift
00010B98                            	ptrMusic	Mus_WWZ,		$00
00010B98                          M 	rept	narg/2
00010B98 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010B9C =0000000C                M __mus	=	__mus+1
00010B9C                          M 	shift
00010B9C                          M 	shift
00010B9C                            	ptrMusic	Mus_Boss,		$00
00010B9C                          M 	rept	narg/2
00010B9C 0000 0000                M 	dc.l	(($00)<<24)|mus_boss
00010BA0 =0000000D                M __mus	=	__mus+1
00010BA0                          M 	shift
00010BA0                          M 	shift
00010BA0                            MusicIndex_End:
00010BA0                            
00010BA0                            ; -------------------------------------------------------------------------
00010BA0                            ; ===========================================================================
00010BA0                            ; ---------------------------------------------------------------------------
00010BA0                            ; Define samples
00010BA0                            ; ---------------------------------------------------------------------------
00010BA0                            
00010BA0 =00000080                  __samp =	$80
00010BA0                            	include	"Sound/dac.asm"
00010BA0                            
00010BA0                            
00010BA0                            ; ------------------------------------------------------------------------
00010BA0                            ; AMPS DAC list
00010BA0                            ; -------------------------------------------------------------------------
00010BA0                            
00010BA0                            ; -------------------------------------------------------------------------
00010BA0                            ; Sample 68k PCM list
00010BA0                            ; -------------------------------------------------------------------------
00010BA0                            
00010BA0                            SampleList:
00010BA0                            	sample	$0000, Stop,		Stop,		Stop		; 80 (THIS IS A REST NOTE, DO NOT EDIT...)
00010BA0 =00000080                M dstop	=	__samp
00010BA0 =00000081                M __samp	=	__samp+1
00010BA0 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BA3 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BA6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BA9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BAC FF00                     M 	dc.w	$0000-$100
00010BAE 0000                     M 	dc.w	0
00010BB0                            	sample	$0100, Kick,		Stop,		Kick		; 81
00010BB0 =00000081                M dkick	=	__samp
00010BB0 =00000082                M __samp	=	__samp+1
00010BB0 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010BB3 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010BB6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BB9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BBC 0000                     M 	dc.w	$0100-$100
00010BBE 0000                     M 	dc.w	0
00010BC0                            	sample	$0100, Kick,		Stop,		Kick2		; 82
00010BC0 =00000082                M dkick2	=	__samp
00010BC0 =00000083                M __samp	=	__samp+1
00010BC0 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010BC3 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010BC6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BC9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BCC 0000                     M 	dc.w	$0100-$100
00010BCE 0000                     M 	dc.w	0
00010BD0                            	sample	$0100, Snare,		Stop,		Snare		; 83
00010BD0 =00000083                M dsnare	=	__samp
00010BD0 =00000084                M __samp	=	__samp+1
00010BD0 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010BD3 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010BD6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BD9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BDC 0000                     M 	dc.w	$0100-$100
00010BDE 0000                     M 	dc.w	0
00010BE0                            	sample	$0100, Snare,		Stop,		Snare2		; 84
00010BE0 =00000084                M dsnare2	=	__samp
00010BE0 =00000085                M __samp	=	__samp+1
00010BE0 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010BE3 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010BE6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BE9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BEC 0000                     M 	dc.w	$0100-$100
00010BEE 0000                     M 	dc.w	0
00010BF0                            	sample	$0100, Tom,		Stop,		Tom		; 85
00010BF0 =00000085                M dtom	=	__samp
00010BF0 =00000086                M __samp	=	__samp+1
00010BF0 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010BF3 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010BF6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BF9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BFC 0000                     M 	dc.w	$0100-$100
00010BFE 0000                     M 	dc.w	0
00010C00                            	sample	$0160, Tom,		Stop,		TomH 		; 86
00010C00 =00000086                M dtomh	=	__samp
00010C00 =00000087                M __samp	=	__samp+1
00010C00 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010C03 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010C06 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C09 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C0C 0060                     M 	dc.w	$0160-$100
00010C0E 0000                     M 	dc.w	0
00010C10                            	sample	$0130, Tom,		Stop,		TomMid		; 87
00010C10 =00000087                M dtommid	=	__samp
00010C10 =00000088                M __samp	=	__samp+1
00010C10 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010C13 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010C16 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C19 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C1C 0030                     M 	dc.w	$0130-$100
00010C1E 0000                     M 	dc.w	0
00010C20                            	sample	$0100, Tom,		Stop,		TomMidL		; 88
00010C20 =00000088                M dtommidl	=	__samp
00010C20 =00000089                M __samp	=	__samp+1
00010C20 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010C23 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010C26 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C29 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C2C 0000                     M 	dc.w	$0100-$100
00010C2E 0000                     M 	dc.w	0
00010C30                            	sample	$00E0, Tom,		Stop,		TomL		; 89
00010C30 =00000089                M dtoml	=	__samp
00010C30 =0000008A                M __samp	=	__samp+1
00010C30 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010C33 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010C36 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C39 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C3C FFE0                     M 	dc.w	$00e0-$100
00010C3E 0000                     M 	dc.w	0
00010C40                            	sample	$0100, Stop,		Stop,		Stop2		; 8A
00010C40 =0000008A                M dstop2	=	__samp
00010C40 =0000008B                M __samp	=	__samp+1
00010C40 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C43 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C46 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C49 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C4C 0000                     M 	dc.w	$0100-$100
00010C4E 0000                     M 	dc.w	0
00010C50                            	sample	$0100, Stop,		Stop,		Stop3		; 8B
00010C50 =0000008B                M dstop3	=	__samp
00010C50 =0000008C                M __samp	=	__samp+1
00010C50 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C53 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C56 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C59 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C5C 0000                     M 	dc.w	$0100-$100
00010C5E 0000                     M 	dc.w	0
00010C60                            	sample	$0104, Title,		Title,		Title		; 8C
00010C60 =0000008C                M dtitle	=	__samp
00010C60 =0000008D                M __samp	=	__samp+1
00010C60 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010C63 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010C66 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010C69 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010C6C 0004                     M 	dc.w	$0104-$100
00010C6E 0000                     M 	dc.w	0
00010C70                            	sample	$0104, Sega,		Stop,		Sega		; 8D
00010C70 =0000008D                M dsega	=	__samp
00010C70 =0000008E                M __samp	=	__samp+1
00010C70 0000 00                  M 	dc.b	swf_sega&$ff,((swf_sega>>$08)&$7f)|$80,(swf_sega>>$0f)&$ff
00010C73 0000 00                  M 	dc.b	(swfr_sega-1)&$ff,(((swfr_sega-1)>>$08)&$7f)|$80,((swfr_sega-1)>>$0f)&$ff
00010C76 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C79 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C7C 0004                     M 	dc.w	$0104-$100
00010C7E 0000                     M 	dc.w	0
00010C80                            	sample	$0104, Punch,		Stop,		Punch		; 8E
00010C80 =0000008E                M dpunch	=	__samp
00010C80 =0000008F                M __samp	=	__samp+1
00010C80 0000 00                  M 	dc.b	swf_punch&$ff,((swf_punch>>$08)&$7f)|$80,(swf_punch>>$0f)&$ff
00010C83 0000 00                  M 	dc.b	(swfr_punch-1)&$ff,(((swfr_punch-1)>>$08)&$7f)|$80,((swfr_punch-1)>>$0f)&$ff
00010C86 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C89 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C8C 0004                     M 	dc.w	$0104-$100
00010C8E 0000                     M 	dc.w	0
00010C90                            	sample	$0114, EndingSong,	EndingSong,	EndingSong	; 8F
00010C90 =0000008F                M dendingsong	=	__samp
00010C90 =00000090                M __samp	=	__samp+1
00010C90 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010C93 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010C96 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010C99 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010C9C 0014                     M 	dc.w	$0114-$100
00010C9E 0000                     M 	dc.w	0
00010CA0                            	sample	$0114, BinBowie,	Stop,		BinBowie	; 90
00010CA0 =00000090                M dbinbowie	=	__samp
00010CA0 =00000091                M __samp	=	__samp+1
00010CA0 0000 00                  M 	dc.b	swf_binbowie&$ff,((swf_binbowie>>$08)&$7f)|$80,(swf_binbowie>>$0f)&$ff
00010CA3 0000 00                  M 	dc.b	(swfr_binbowie-1)&$ff,(((swfr_binbowie-1)>>$08)&$7f)|$80,((swfr_binbowie-1)>>$0f)&$ff
00010CA6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010CA9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010CAC 0014                     M 	dc.w	$0114-$100
00010CAE 0000                     M 	dc.w	0
00010CB0                            	sample	$0114, Wacky_Base_Loud,	Stop,		WackyBase	; 91
00010CB0 =00000091                M dwackybase	=	__samp
00010CB0 =00000092                M __samp	=	__samp+1
00010CB0 0000 00                  M 	dc.b	swf_wacky_base_loud&$ff,((swf_wacky_base_loud>>$08)&$7f)|$80,(swf_wacky_base_loud>>$0f)&$ff
00010CB3 0000 00                  M 	dc.b	(swfr_wacky_base_loud-1)&$ff,(((swfr_wacky_base_loud-1)>>$08)&$7f)|$80,((swfr_wacky_base_loud-1)>>$0f)&$ff
00010CB6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010CB9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010CBC 0014                     M 	dc.w	$0114-$100
00010CBE 0000                     M 	dc.w	0
00010CC0                            SampleList_End:
00010CC0                            
00010CC0                            ; -------------------------------------------------------------------------
00010CC0                            ; ===========================================================================
00010CC0                            ; ---------------------------------------------------------------------------
00010CC0                            ; Define volume envelopes and their data
00010CC0                            ; ---------------------------------------------------------------------------
00010CC0                            
00010CC0 =00000001                  __venv =	$01
00010CC0                            	include	"Sound/psg.asm"
00010CC0                            
00010CC0                            
00010CC0                            ; ------------------------------------------------------------------------
00010CC0                            ; AMPS PSG envelopes
00010CC0                            ; -------------------------------------------------------------------------
00010CC0                            
00010CC0                            ; -------------------------------------------------------------------------
00010CC0                            ; PSG envelope index
00010CC0                            ; -------------------------------------------------------------------------
00010CC0                            
00010CC0                            VolEnvs:
00010CC0                            	volenv	01
00010CC0                          M 	rept	narg
00010CC0 =00000001                M v01	=	__venv
00010CC0 0000 0000                M 	dc.l	vd01
00010CC4 =00000002                M __venv	=	__venv+1
00010CC4                          M 	shift
00010CC4                            	volenv	02
00010CC4                          M 	rept	narg
00010CC4 =00000002                M v02	=	__venv
00010CC4 0000 0000                M 	dc.l	vd02
00010CC8 =00000003                M __venv	=	__venv+1
00010CC8                          M 	shift
00010CC8                            	volenv	03
00010CC8                          M 	rept	narg
00010CC8 =00000003                M v03	=	__venv
00010CC8 0000 0000                M 	dc.l	vd03
00010CCC =00000004                M __venv	=	__venv+1
00010CCC                          M 	shift
00010CCC                            	volenv	04
00010CCC                          M 	rept	narg
00010CCC =00000004                M v04	=	__venv
00010CCC 0000 0000                M 	dc.l	vd04
00010CD0 =00000005                M __venv	=	__venv+1
00010CD0                          M 	shift
00010CD0                            	volenv	05
00010CD0                          M 	rept	narg
00010CD0 =00000005                M v05	=	__venv
00010CD0 0000 0000                M 	dc.l	vd05
00010CD4 =00000006                M __venv	=	__venv+1
00010CD4                          M 	shift
00010CD4                            	volenv	06
00010CD4                          M 	rept	narg
00010CD4 =00000006                M v06	=	__venv
00010CD4 0000 0000                M 	dc.l	vd06
00010CD8 =00000007                M __venv	=	__venv+1
00010CD8                          M 	shift
00010CD8                            	volenv	07
00010CD8                          M 	rept	narg
00010CD8 =00000007                M v07	=	__venv
00010CD8 0000 0000                M 	dc.l	vd07
00010CDC =00000008                M __venv	=	__venv+1
00010CDC                          M 	shift
00010CDC                            	volenv	08
00010CDC                          M 	rept	narg
00010CDC =00000008                M v08	=	__venv
00010CDC 0000 0000                M 	dc.l	vd08
00010CE0 =00000009                M __venv	=	__venv+1
00010CE0                          M 	shift
00010CE0                            	volenv	09
00010CE0                          M 	rept	narg
00010CE0 =00000009                M v09	=	__venv
00010CE0 0000 0000                M 	dc.l	vd09
00010CE4 =0000000A                M __venv	=	__venv+1
00010CE4                          M 	shift
00010CE4                            	volenv	0A
00010CE4                          M 	rept	narg
00010CE4 =0000000A                M v0a	=	__venv
00010CE4 0000 0000                M 	dc.l	vd0a
00010CE8 =0000000B                M __venv	=	__venv+1
00010CE8                          M 	shift
00010CE8                            	volenv	0B
00010CE8                          M 	rept	narg
00010CE8 =0000000B                M v0b	=	__venv
00010CE8 0000 0000                M 	dc.l	vd0b
00010CEC =0000000C                M __venv	=	__venv+1
00010CEC                          M 	shift
00010CEC                            	volenv	0C
00010CEC                          M 	rept	narg
00010CEC =0000000C                M v0c	=	__venv
00010CEC 0000 0000                M 	dc.l	vd0c
00010CF0 =0000000D                M __venv	=	__venv+1
00010CF0                          M 	shift
00010CF0                            	volenv	0D
00010CF0                          M 	rept	narg
00010CF0 =0000000D                M v0d	=	__venv
00010CF0 0000 0000                M 	dc.l	vd0d
00010CF4 =0000000E                M __venv	=	__venv+1
00010CF4                          M 	shift
00010CF4                            VolEnvs_End:
00010CF4                            	opt ae-
00010CF4                            
00010CF4                            ; -------------------------------------------------------------------------
00010CF4                            ; PSG envelope data
00010CF4                            ; -------------------------------------------------------------------------
00010CF4                            
00010CF4 0000 0001 0101 0202        vd01:	dc.b	$00, $00, $00, $01, $01, $01, $02, $02
00010CFC 0203 0303 0404 0405        	dc.b	$02, $03, $03, $03, $04, $04, $04, $05
00010D04 0505 0606 0607 82          	dc.b	$05, $05, $06, $06, $06, $07, eHold
00010D0B                            
00010D0B 0002 0406 0810 82          vd02:	dc.b	$00, $02, $04, $06, $08, $10, eHold
00010D12                            
00010D12 0000 0101 0202 0303        vd03:	dc.b	$00, $00, $01, $01, $02, $02, $03, $03
00010D1A 0404 0505 0606 0707        	dc.b	$04, $04, $05, $05, $06, $06, $07, $07
00010D22 82                         	dc.b	eHold
00010D23                            
00010D23 0000 0203 0404 0505        vd04:	dc.b	$00, $00, $02, $03, $04, $04, $05, $05
00010D2B 0506 82                    	dc.b	$05, $06, eHold
00010D2E                            
00010D2E 0000 0000 0000 0000        vd05:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010D36 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010D3E 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D46 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010D4E 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010D56 0482                       	dc.b	$04, eHold
00010D58                            
00010D58 0303 0302 0202 0201        vd06:	dc.b	$03, $03, $03, $02, $02, $02, $02, $01
00010D60 0101 0000 0000 82          	dc.b	$01, $01, $00, $00, $00, $00, eHold
00010D67                            
00010D67 0000 0000 0000 0101        vd07:	dc.b	$00, $00, $00, $00, $00, $00, $01, $01
00010D6F 0101 0102 0202 0202        	dc.b	$01, $01, $01, $02, $02, $02, $02, $02
00010D77 0303 0304 0404 0505        	dc.b	$03, $03, $03, $04, $04, $04, $05, $05
00010D7F 0506 0782                  	dc.b	$05, $06, $07, eHold
00010D83                            
00010D83 0000 0000 0001 0101        vd08:	dc.b	$00, $00, $00, $00, $00, $01, $01, $01
00010D8B 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010D93 0303 0303 0304 0404        	dc.b	$03, $03, $03, $03, $03, $04, $04, $04
00010D9B 0404 0505 0505 0506        	dc.b	$04, $04, $05, $05, $05, $05, $05, $06
00010DA3 0606 0606 0707 0782        	dc.b	$06, $06, $06, $06, $07, $07, $07, eHold
00010DAB                            
00010DAB 0001 0203 0405 0607        vd09:	dc.b	$00, $01, $02, $03, $04, $05, $06, $07
00010DB3 0809 0A0B 0C0D 0E0F        	dc.b	$08, $09, $0A, $0B, $0C, $0D, $0E, $0F
00010DBB 82                         	dc.b	eHold
00010DBC                            	even
00010DBC                            
00010DBC 0000 0000 0000 0000        vd0A:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010DC4 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010DCC 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010DD4 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010DDC 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010DE4 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010DEC 0202 0303 0303 0303        	dc.b	$02, $02, $03, $03, $03, $03, $03, $03
00010DF4 0303 0303 0304 82          	dc.b	$03, $03, $03, $03, $03, $04, eHold
00010DFC 00                         	even
00010DFC                            
00010DFC 0404 0403 0303 0202        vd0B:	dc.b	$04, $04, $04, $03, $03, $03, $02, $02
00010E04 0201 0101 0101 0101        	dc.b	$02, $01, $01, $01, $01, $01, $01, $01
00010E0C 0202 0202 0203 0303        	dc.b	$02, $02, $02, $02, $02, $03, $03, $03
00010E14 0303 0482                  	dc.b	$03, $03, $04, eHold
00010E18                            	even
00010E18                            
00010E18 0404 0303 0202 0101        vd0C:	dc.b	$04, $04, $03, $03, $02, $02, $01, $01
00010E20 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010E28 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010E30 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010E38 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010E40 0202 0202 0202 0303        	dc.b	$02, $02, $02, $02, $02, $02, $03, $03
00010E48 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010E50 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010E58 0303 0404 0404 0404        	dc.b	$03, $03, $04, $04, $04, $04, $04, $04
00010E60 0404 0404 0404 0404        	dc.b	$04, $04, $04, $04, $04, $04, $04, $04
00010E68 0404 0404 0404 0505        	dc.b	$04, $04, $04, $04, $04, $04, $05, $05
00010E70 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010E78 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010E80 0505 0606 0606 0606        	dc.b	$05, $05, $06, $06, $06, $06, $06, $06
00010E88 0606 0606 0606 0606        	dc.b	$06, $06, $06, $06, $06, $06, $06, $06
00010E90 0606 0606 0606 0782        	dc.b	$06, $06, $06, $06, $06, $06, $07, eHold
00010E98                            	even
00010E98                            
00010E98 0E0D 0C0B 0A09 0807        vd0D:	dc.b	$0E, $0D, $0C, $0B, $0A, $09, $08, $07
00010EA0 0605 0403 0201 000F        	dc.b	$06, $05, $04, $03, $02, $01, $00, $0F
00010EA8 82                         	dc.b	eHold
00010EAA 00                         	even
00010EAA                            
00010EAA                            ; -------------------------------------------------------------------------
00010EAA                            ; ===========================================================================
00010EAA                            ; ---------------------------------------------------------------------------
00010EAA                            ; Include music, sound effects and voice table
00010EAA                            ; ---------------------------------------------------------------------------
00010EAA                            
00010EAA                            VoiceBankMusic:
00010EAA =00000000                  sPatNum = 0
00010EAA                            	include "Sound/unipatchmus.asm"; include universal Voice banks
00010EAA                            
00010EAA                            
00010EAA                            ; ------------------------------------------------------------------------
00010EAA                            ; AMPS music patch list
00010EAA                            ; -------------------------------------------------------------------------
00010EAA                            
00010EAA                            	; Patch $00
00010EAA                            	; $2A
00010EAA                            	; $02, $32, $03, $01,	$5F, $5F, $9F, $9C
00010EAA                            	; $9F, $1F, $9F, $04,	$00, $00, $00, $07
00010EAA                            	; $15, $15, $15, $F5,	$05, $08, $0C, $1A
00010EAA                            	spAlgorithm	$02
00010EAA =00000001                M spatnum	=	spatnum+1
00010EAA =00000002                M spal	=	val
00010EAA                            	spFeedback	$05
00010EAA =00000005                M spfe	=	val
00010EAA                            	spDetune	$00, $00, $03, $00
00010EAA =00000000                M spde1	=	op1
00010EAA =00000000                M spde2	=	op2
00010EAA =00000003                M spde3	=	op3
00010EAA =00000000                M spde4	=	op4
00010EAA                            	spMultiple	$02, $03, $02, $01
00010EAA =00000002                M spmu1	=	op1
00010EAA =00000003                M spmu2	=	op2
00010EAA =00000002                M spmu3	=	op3
00010EAA =00000001                M spmu4	=	op4
00010EAA                            	spRateScale	$01, $02, $01, $02
00010EAA =00000001                M sprs1	=	op1
00010EAA =00000002                M sprs2	=	op2
00010EAA =00000001                M sprs3	=	op3
00010EAA =00000002                M sprs4	=	op4
00010EAA                            	spAttackRt	$1F, $1F, $1F, $1C
00010EAA =0000001F                M spar1	=	op1
00010EAA =0000001F                M spar2	=	op2
00010EAA =0000001F                M spar3	=	op3
00010EAA =0000001C                M spar4	=	op4
00010EAA                            	spAmpMod	$01, $01, $00, $00
00010EAA =00000001                M spam1	=	op1
00010EAA =00000001                M spam2	=	op2
00010EAA =00000000                M spam3	=	op3
00010EAA =00000000                M spam4	=	op4
00010EAA                            	spSustainRt	$1F, $1F, $1F, $04
00010EAA =0000001F                M spsr1	=	op1
00010EAA =0000001F                M spsr2	=	op2
00010EAA =0000001F                M spsr3	=	op3
00010EAA =00000004                M spsr4	=	op4
00010EAA                            	spDecayRt	$00, $00, $00, $07
00010EAA =00000000                M spdr1	=	op1
00010EAA =00000000                M spdr2	=	op2
00010EAA =00000000                M spdr3	=	op3
00010EAA =00000007                M spdr4	=	op4
00010EAA                            	spSustainLv	$01, $01, $01, $0F
00010EAA =00000001                M spsl1	=	op1
00010EAA =00000001                M spsl2	=	op2
00010EAA =00000001                M spsl3	=	op3
00010EAA =0000000F                M spsl4	=	op4
00010EAA                            	spReleaseRt	$05, $05, $05, $05
00010EAA =00000005                M sprr1	=	op1
00010EAA =00000005                M sprr2	=	op2
00010EAA =00000005                M sprr3	=	op3
00010EAA =00000005                M sprr4	=	op4
00010EAA                            	spSSGEG		$00, $00, $00, $00
00010EAA =00000000                M spss1	=	op1
00010EAA =00000000                M spss2	=	op2
00010EAA =00000000                M spss3	=	op3
00010EAA =00000000                M spss4	=	op4
00010EAA                            	spTotalLv	$05, $0C, $08, $1A
00010EAA =00000005                M sptl1	=	op1
00010EAA =0000000C                M sptl2	=	op2
00010EAA =00000008                M sptl3	=	op3
00010EAA =0000001A                M sptl4	=	op4
00010EAA 2A                       M 	dc.b	(spfe<<3)+spal
00010EAB =00000080                M sptlmask4	set	$80
00010EAB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010EAB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010EAB =00000000                M sptlmask1	set	((spal=7)<<7)
00010EAB 0232 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EAF 5F5F 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EB3 9F1F 9F04                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EB7 0000 0007                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EBB 1515 15F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EBF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EC3 0508 0C9A                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EC7 4E41 54                  M 	dc.b	'NAT'
00010ECA                            
00010ECA                            	; Patch $01
00010ECA                            	; $38
00010ECA                            	; $01, $00, $01, $00,	$1F, $1F, $1F, $1F
00010ECA                            	; $00, $00, $00, $0D,	$0E, $00, $00, $1F
00010ECA                            	; $00, $00, $00, $30,	$1C, $11, $28, $04
00010ECA                            	spAlgorithm	$00
00010ECA =00000002                M spatnum	=	spatnum+1
00010ECA =00000000                M spal	=	val
00010ECA                            	spFeedback	$07
00010ECA =00000007                M spfe	=	val
00010ECA                            	spDetune	$00, $00, $00, $00
00010ECA =00000000                M spde1	=	op1
00010ECA =00000000                M spde2	=	op2
00010ECA =00000000                M spde3	=	op3
00010ECA =00000000                M spde4	=	op4
00010ECA                            	spMultiple	$01, $01, $00, $00
00010ECA =00000001                M spmu1	=	op1
00010ECA =00000001                M spmu2	=	op2
00010ECA =00000000                M spmu3	=	op3
00010ECA =00000000                M spmu4	=	op4
00010ECA                            	spRateScale	$00, $00, $00, $00
00010ECA =00000000                M sprs1	=	op1
00010ECA =00000000                M sprs2	=	op2
00010ECA =00000000                M sprs3	=	op3
00010ECA =00000000                M sprs4	=	op4
00010ECA                            	spAttackRt	$1F, $1F, $1F, $1F
00010ECA =0000001F                M spar1	=	op1
00010ECA =0000001F                M spar2	=	op2
00010ECA =0000001F                M spar3	=	op3
00010ECA =0000001F                M spar4	=	op4
00010ECA                            	spAmpMod	$00, $00, $00, $00
00010ECA =00000000                M spam1	=	op1
00010ECA =00000000                M spam2	=	op2
00010ECA =00000000                M spam3	=	op3
00010ECA =00000000                M spam4	=	op4
00010ECA                            	spSustainRt	$00, $00, $00, $0D
00010ECA =00000000                M spsr1	=	op1
00010ECA =00000000                M spsr2	=	op2
00010ECA =00000000                M spsr3	=	op3
00010ECA =0000000D                M spsr4	=	op4
00010ECA                            	spDecayRt	$0E, $00, $00, $1F
00010ECA =0000000E                M spdr1	=	op1
00010ECA =00000000                M spdr2	=	op2
00010ECA =00000000                M spdr3	=	op3
00010ECA =0000001F                M spdr4	=	op4
00010ECA                            	spSustainLv	$00, $00, $00, $03
00010ECA =00000000                M spsl1	=	op1
00010ECA =00000000                M spsl2	=	op2
00010ECA =00000000                M spsl3	=	op3
00010ECA =00000003                M spsl4	=	op4
00010ECA                            	spReleaseRt	$00, $00, $00, $00
00010ECA =00000000                M sprr1	=	op1
00010ECA =00000000                M sprr2	=	op2
00010ECA =00000000                M sprr3	=	op3
00010ECA =00000000                M sprr4	=	op4
00010ECA                            	spSSGEG		$00, $00, $00, $00
00010ECA =00000000                M spss1	=	op1
00010ECA =00000000                M spss2	=	op2
00010ECA =00000000                M spss3	=	op3
00010ECA =00000000                M spss4	=	op4
00010ECA                            	spTotalLv	$1C, $28, $11, $04
00010ECA =0000001C                M sptl1	=	op1
00010ECA =00000028                M sptl2	=	op2
00010ECA =00000011                M sptl3	=	op3
00010ECA =00000004                M sptl4	=	op4
00010ECA 38                       M 	dc.b	(spfe<<3)+spal
00010ECB =00000080                M sptlmask4	set	$80
00010ECB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010ECB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010ECB =00000000                M sptlmask1	set	((spal=7)<<7)
00010ECB 0100 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010ECF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010ED3 0000 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010ED7 0E00 001F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EDB 0000 0030                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EDF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EE3 1C11 2884                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EE7 4E41 54                  M 	dc.b	'NAT'
00010EEA                            
00010EEA                            	; Patch $02
00010EEA                            	; $21
00010EEA                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00010EEA                            	; $0B, $08, $0F, $0B,	$01, $13, $1F, $1F
00010EEA                            	; $14, $B4, $44, $14,	$7F, $7F, $14, $04
00010EEA                            	spAlgorithm	$01
00010EEA =00000003                M spatnum	=	spatnum+1
00010EEA =00000001                M spal	=	val
00010EEA                            	spFeedback	$04
00010EEA =00000004                M spfe	=	val
00010EEA                            	spDetune	$00, $00, $00, $00
00010EEA =00000000                M spde1	=	op1
00010EEA =00000000                M spde2	=	op2
00010EEA =00000000                M spde3	=	op3
00010EEA =00000000                M spde4	=	op4
00010EEA                            	spMultiple	$00, $00, $00, $00
00010EEA =00000000                M spmu1	=	op1
00010EEA =00000000                M spmu2	=	op2
00010EEA =00000000                M spmu3	=	op3
00010EEA =00000000                M spmu4	=	op4
00010EEA                            	spRateScale	$00, $00, $00, $00
00010EEA =00000000                M sprs1	=	op1
00010EEA =00000000                M sprs2	=	op2
00010EEA =00000000                M sprs3	=	op3
00010EEA =00000000                M sprs4	=	op4
00010EEA                            	spAttackRt	$1F, $1F, $1F, $1F
00010EEA =0000001F                M spar1	=	op1
00010EEA =0000001F                M spar2	=	op2
00010EEA =0000001F                M spar3	=	op3
00010EEA =0000001F                M spar4	=	op4
00010EEA                            	spAmpMod	$00, $00, $00, $00
00010EEA =00000000                M spam1	=	op1
00010EEA =00000000                M spam2	=	op2
00010EEA =00000000                M spam3	=	op3
00010EEA =00000000                M spam4	=	op4
00010EEA                            	spSustainRt	$0B, $0F, $08, $0B
00010EEA =0000000B                M spsr1	=	op1
00010EEA =0000000F                M spsr2	=	op2
00010EEA =00000008                M spsr3	=	op3
00010EEA =0000000B                M spsr4	=	op4
00010EEA                            	spDecayRt	$01, $1F, $13, $1F
00010EEA =00000001                M spdr1	=	op1
00010EEA =0000001F                M spdr2	=	op2
00010EEA =00000013                M spdr3	=	op3
00010EEA =0000001F                M spdr4	=	op4
00010EEA                            	spSustainLv	$01, $04, $0B, $01
00010EEA =00000001                M spsl1	=	op1
00010EEA =00000004                M spsl2	=	op2
00010EEA =0000000B                M spsl3	=	op3
00010EEA =00000001                M spsl4	=	op4
00010EEA                            	spReleaseRt	$04, $04, $04, $04
00010EEA =00000004                M sprr1	=	op1
00010EEA =00000004                M sprr2	=	op2
00010EEA =00000004                M sprr3	=	op3
00010EEA =00000004                M sprr4	=	op4
00010EEA                            	spSSGEG		$00, $00, $00, $00
00010EEA =00000000                M spss1	=	op1
00010EEA =00000000                M spss2	=	op2
00010EEA =00000000                M spss3	=	op3
00010EEA =00000000                M spss4	=	op4
00010EEA                            	spTotalLv	$7F, $14, $7F, $04
00010EEA =0000007F                M sptl1	=	op1
00010EEA =00000014                M sptl2	=	op2
00010EEA =0000007F                M sptl3	=	op3
00010EEA =00000004                M sptl4	=	op4
00010EEA 21                       M 	dc.b	(spfe<<3)+spal
00010EEB =00000080                M sptlmask4	set	$80
00010EEB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010EEB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010EEB =00000000                M sptlmask1	set	((spal=7)<<7)
00010EEB 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EEF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EF3 0B08 0F0B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EF7 0113 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EFB 14B4 4414                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EFF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F03 7F7F 1484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F07 4E41 54                  M 	dc.b	'NAT'
00010F0A                            
00010F0A                            	; Patch $03
00010F0A                            	; $34
00010F0A                            	; $74, $02, $6B, $02,	$1F, $53, $53, $11
00010F0A                            	; $11, $1F, $12, $01,	$00, $00, $00, $00
00010F0A                            	; $2B, $0B, $F9, $69,	$2A, $0C, $13, $04
00010F0A                            	spAlgorithm	$04
00010F0A =00000004                M spatnum	=	spatnum+1
00010F0A =00000004                M spal	=	val
00010F0A                            	spFeedback	$06
00010F0A =00000006                M spfe	=	val
00010F0A                            	spDetune	$07, $06, $00, $00
00010F0A =00000007                M spde1	=	op1
00010F0A =00000006                M spde2	=	op2
00010F0A =00000000                M spde3	=	op3
00010F0A =00000000                M spde4	=	op4
00010F0A                            	spMultiple	$04, $0B, $02, $02
00010F0A =00000004                M spmu1	=	op1
00010F0A =0000000B                M spmu2	=	op2
00010F0A =00000002                M spmu3	=	op3
00010F0A =00000002                M spmu4	=	op4
00010F0A                            	spRateScale	$00, $01, $01, $00
00010F0A =00000000                M sprs1	=	op1
00010F0A =00000001                M sprs2	=	op2
00010F0A =00000001                M sprs3	=	op3
00010F0A =00000000                M sprs4	=	op4
00010F0A                            	spAttackRt	$1F, $13, $13, $11
00010F0A =0000001F                M spar1	=	op1
00010F0A =00000013                M spar2	=	op2
00010F0A =00000013                M spar3	=	op3
00010F0A =00000011                M spar4	=	op4
00010F0A                            	spAmpMod	$00, $00, $00, $00
00010F0A =00000000                M spam1	=	op1
00010F0A =00000000                M spam2	=	op2
00010F0A =00000000                M spam3	=	op3
00010F0A =00000000                M spam4	=	op4
00010F0A                            	spSustainRt	$11, $12, $1F, $01
00010F0A =00000011                M spsr1	=	op1
00010F0A =00000012                M spsr2	=	op2
00010F0A =0000001F                M spsr3	=	op3
00010F0A =00000001                M spsr4	=	op4
00010F0A                            	spDecayRt	$00, $00, $00, $00
00010F0A =00000000                M spdr1	=	op1
00010F0A =00000000                M spdr2	=	op2
00010F0A =00000000                M spdr3	=	op3
00010F0A =00000000                M spdr4	=	op4
00010F0A                            	spSustainLv	$02, $0F, $00, $06
00010F0A =00000002                M spsl1	=	op1
00010F0A =0000000F                M spsl2	=	op2
00010F0A =00000000                M spsl3	=	op3
00010F0A =00000006                M spsl4	=	op4
00010F0A                            	spReleaseRt	$0B, $09, $0B, $09
00010F0A =0000000B                M sprr1	=	op1
00010F0A =00000009                M sprr2	=	op2
00010F0A =0000000B                M sprr3	=	op3
00010F0A =00000009                M sprr4	=	op4
00010F0A                            	spSSGEG		$00, $00, $00, $00
00010F0A =00000000                M spss1	=	op1
00010F0A =00000000                M spss2	=	op2
00010F0A =00000000                M spss3	=	op3
00010F0A =00000000                M spss4	=	op4
00010F0A                            	spTotalLv	$2A, $13, $0C, $04
00010F0A =0000002A                M sptl1	=	op1
00010F0A =00000013                M sptl2	=	op2
00010F0A =0000000C                M sptl3	=	op3
00010F0A =00000004                M sptl4	=	op4
00010F0A 34                       M 	dc.b	(spfe<<3)+spal
00010F0B =00000080                M sptlmask4	set	$80
00010F0B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F0B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F0B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F0B 7402 6B02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F0F 1F53 5311                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F13 111F 1201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F17 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F1B 2B0B F969                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F1F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F23 2A8C 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F27 4E41 54                  M 	dc.b	'NAT'
00010F2A                            
00010F2A                            	; Patch $04
00010F2A                            	; $24
00010F2A                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010F2A                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010F2A                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010F2A                            	spAlgorithm	$04
00010F2A =00000005                M spatnum	=	spatnum+1
00010F2A =00000004                M spal	=	val
00010F2A                            	spFeedback	$04
00010F2A =00000004                M spfe	=	val
00010F2A                            	spDetune	$01, $03, $00, $01
00010F2A =00000001                M spde1	=	op1
00010F2A =00000003                M spde2	=	op2
00010F2A =00000000                M spde3	=	op3
00010F2A =00000001                M spde4	=	op4
00010F2A                            	spMultiple	$00, $01, $01, $01
00010F2A =00000000                M spmu1	=	op1
00010F2A =00000001                M spmu2	=	op2
00010F2A =00000001                M spmu3	=	op3
00010F2A =00000001                M spmu4	=	op4
00010F2A                            	spRateScale	$02, $00, $01, $01
00010F2A =00000002                M sprs1	=	op1
00010F2A =00000000                M sprs2	=	op2
00010F2A =00000001                M sprs3	=	op3
00010F2A =00000001                M sprs4	=	op4
00010F2A                            	spAttackRt	$1B, $1B, $1C, $1C
00010F2A =0000001B                M spar1	=	op1
00010F2A =0000001B                M spar2	=	op2
00010F2A =0000001C                M spar3	=	op3
00010F2A =0000001C                M spar4	=	op4
00010F2A                            	spAmpMod	$00, $00, $00, $00
00010F2A =00000000                M spam1	=	op1
00010F2A =00000000                M spam2	=	op2
00010F2A =00000000                M spam3	=	op3
00010F2A =00000000                M spam4	=	op4
00010F2A                            	spSustainRt	$0A, $0A, $10, $10
00010F2A =0000000A                M spsr1	=	op1
00010F2A =0000000A                M spsr2	=	op2
00010F2A =00000010                M spsr3	=	op3
00010F2A =00000010                M spsr4	=	op4
00010F2A                            	spDecayRt	$03, $03, $04, $04
00010F2A =00000003                M spdr1	=	op1
00010F2A =00000003                M spdr2	=	op2
00010F2A =00000004                M spdr3	=	op3
00010F2A =00000004                M spdr4	=	op4
00010F2A                            	spSustainLv	$01, $08, $00, $00
00010F2A =00000001                M spsl1	=	op1
00010F2A =00000008                M spsl2	=	op2
00010F2A =00000000                M spsl3	=	op3
00010F2A =00000000                M spsl4	=	op4
00010F2A                            	spReleaseRt	$0F, $0F, $0C, $0C
00010F2A =0000000F                M sprr1	=	op1
00010F2A =0000000F                M sprr2	=	op2
00010F2A =0000000C                M sprr3	=	op3
00010F2A =0000000C                M sprr4	=	op4
00010F2A                            	spSSGEG		$00, $00, $00, $00
00010F2A =00000000                M spss1	=	op1
00010F2A =00000000                M spss2	=	op2
00010F2A =00000000                M spss3	=	op3
00010F2A =00000000                M spss4	=	op4
00010F2A                            	spTotalLv	$06, $04, $05, $05
00010F2A =00000006                M sptl1	=	op1
00010F2A =00000004                M sptl2	=	op2
00010F2A =00000005                M sptl3	=	op3
00010F2A =00000005                M sptl4	=	op4
00010F2A 24                       M 	dc.b	(spfe<<3)+spal
00010F2B =00000080                M sptlmask4	set	$80
00010F2B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F2B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F2B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F2B 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F2F 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F33 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F37 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F3B 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F3F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F43 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F47 4E41 54                  M 	dc.b	'NAT'
00010F4A                            
00010F4A                            	; Patch $05
00010F4A                            	; $38
00010F4A                            	; $56, $15, $10, $72,	$1F, $1F, $1F, $1F
00010F4A                            	; $08, $08, $0A, $00,	$07, $07, $07, $06
00010F4A                            	; $F0, $F5, $F6, $F8,	$2C, $28, $12, $05
00010F4A                            	spAlgorithm	$00
00010F4A =00000006                M spatnum	=	spatnum+1
00010F4A =00000000                M spal	=	val
00010F4A                            	spFeedback	$07
00010F4A =00000007                M spfe	=	val
00010F4A                            	spDetune	$05, $01, $01, $07
00010F4A =00000005                M spde1	=	op1
00010F4A =00000001                M spde2	=	op2
00010F4A =00000001                M spde3	=	op3
00010F4A =00000007                M spde4	=	op4
00010F4A                            	spMultiple	$06, $00, $05, $02
00010F4A =00000006                M spmu1	=	op1
00010F4A =00000000                M spmu2	=	op2
00010F4A =00000005                M spmu3	=	op3
00010F4A =00000002                M spmu4	=	op4
00010F4A                            	spRateScale	$00, $00, $00, $00
00010F4A =00000000                M sprs1	=	op1
00010F4A =00000000                M sprs2	=	op2
00010F4A =00000000                M sprs3	=	op3
00010F4A =00000000                M sprs4	=	op4
00010F4A                            	spAttackRt	$1F, $1F, $1F, $1F
00010F4A =0000001F                M spar1	=	op1
00010F4A =0000001F                M spar2	=	op2
00010F4A =0000001F                M spar3	=	op3
00010F4A =0000001F                M spar4	=	op4
00010F4A                            	spAmpMod	$00, $00, $00, $00
00010F4A =00000000                M spam1	=	op1
00010F4A =00000000                M spam2	=	op2
00010F4A =00000000                M spam3	=	op3
00010F4A =00000000                M spam4	=	op4
00010F4A                            	spSustainRt	$08, $0A, $08, $00
00010F4A =00000008                M spsr1	=	op1
00010F4A =0000000A                M spsr2	=	op2
00010F4A =00000008                M spsr3	=	op3
00010F4A =00000000                M spsr4	=	op4
00010F4A                            	spDecayRt	$07, $07, $07, $06
00010F4A =00000007                M spdr1	=	op1
00010F4A =00000007                M spdr2	=	op2
00010F4A =00000007                M spdr3	=	op3
00010F4A =00000006                M spdr4	=	op4
00010F4A                            	spSustainLv	$0F, $0F, $0F, $0F
00010F4A =0000000F                M spsl1	=	op1
00010F4A =0000000F                M spsl2	=	op2
00010F4A =0000000F                M spsl3	=	op3
00010F4A =0000000F                M spsl4	=	op4
00010F4A                            	spReleaseRt	$00, $06, $05, $08
00010F4A =00000000                M sprr1	=	op1
00010F4A =00000006                M sprr2	=	op2
00010F4A =00000005                M sprr3	=	op3
00010F4A =00000008                M sprr4	=	op4
00010F4A                            	spSSGEG		$00, $00, $00, $00
00010F4A =00000000                M spss1	=	op1
00010F4A =00000000                M spss2	=	op2
00010F4A =00000000                M spss3	=	op3
00010F4A =00000000                M spss4	=	op4
00010F4A                            	spTotalLv	$2C, $12, $28, $05
00010F4A =0000002C                M sptl1	=	op1
00010F4A =00000012                M sptl2	=	op2
00010F4A =00000028                M sptl3	=	op3
00010F4A =00000005                M sptl4	=	op4
00010F4A 38                       M 	dc.b	(spfe<<3)+spal
00010F4B =00000080                M sptlmask4	set	$80
00010F4B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F4B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F4B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F4B 5615 1072                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F4F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F53 0808 0A00                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F57 0707 0706                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F5B F0F5 F6F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F5F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F63 2C28 1285                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F67 4E41 54                  M 	dc.b	'NAT'
00010F6A                            
00010F6A                            	; Patch $06
00010F6A                            	; $02
00010F6A                            	; $71, $32, $06, $01,	$5F, $5E, $9F, $9C
00010F6A                            	; $02, $06, $05, $04,	$08, $07, $08, $07
00010F6A                            	; $F8, $F8, $F8, $F8,	$00, $10, $07, $05
00010F6A                            	spAlgorithm	$02
00010F6A =00000007                M spatnum	=	spatnum+1
00010F6A =00000002                M spal	=	val
00010F6A                            	spFeedback	$00
00010F6A =00000000                M spfe	=	val
00010F6A                            	spDetune	$07, $00, $03, $00
00010F6A =00000007                M spde1	=	op1
00010F6A =00000000                M spde2	=	op2
00010F6A =00000003                M spde3	=	op3
00010F6A =00000000                M spde4	=	op4
00010F6A                            	spMultiple	$01, $06, $02, $01
00010F6A =00000001                M spmu1	=	op1
00010F6A =00000006                M spmu2	=	op2
00010F6A =00000002                M spmu3	=	op3
00010F6A =00000001                M spmu4	=	op4
00010F6A                            	spRateScale	$01, $02, $01, $02
00010F6A =00000001                M sprs1	=	op1
00010F6A =00000002                M sprs2	=	op2
00010F6A =00000001                M sprs3	=	op3
00010F6A =00000002                M sprs4	=	op4
00010F6A                            	spAttackRt	$1F, $1F, $1E, $1C
00010F6A =0000001F                M spar1	=	op1
00010F6A =0000001F                M spar2	=	op2
00010F6A =0000001E                M spar3	=	op3
00010F6A =0000001C                M spar4	=	op4
00010F6A                            	spAmpMod	$00, $00, $00, $00
00010F6A =00000000                M spam1	=	op1
00010F6A =00000000                M spam2	=	op2
00010F6A =00000000                M spam3	=	op3
00010F6A =00000000                M spam4	=	op4
00010F6A                            	spSustainRt	$02, $05, $06, $04
00010F6A =00000002                M spsr1	=	op1
00010F6A =00000005                M spsr2	=	op2
00010F6A =00000006                M spsr3	=	op3
00010F6A =00000004                M spsr4	=	op4
00010F6A                            	spDecayRt	$08, $08, $07, $07
00010F6A =00000008                M spdr1	=	op1
00010F6A =00000008                M spdr2	=	op2
00010F6A =00000007                M spdr3	=	op3
00010F6A =00000007                M spdr4	=	op4
00010F6A                            	spSustainLv	$0F, $0F, $0F, $0F
00010F6A =0000000F                M spsl1	=	op1
00010F6A =0000000F                M spsl2	=	op2
00010F6A =0000000F                M spsl3	=	op3
00010F6A =0000000F                M spsl4	=	op4
00010F6A                            	spReleaseRt	$08, $08, $08, $08
00010F6A =00000008                M sprr1	=	op1
00010F6A =00000008                M sprr2	=	op2
00010F6A =00000008                M sprr3	=	op3
00010F6A =00000008                M sprr4	=	op4
00010F6A                            	spSSGEG		$00, $00, $00, $00
00010F6A =00000000                M spss1	=	op1
00010F6A =00000000                M spss2	=	op2
00010F6A =00000000                M spss3	=	op3
00010F6A =00000000                M spss4	=	op4
00010F6A                            	spTotalLv	$00, $07, $10, $05
00010F6A =00000000                M sptl1	=	op1
00010F6A =00000007                M sptl2	=	op2
00010F6A =00000010                M sptl3	=	op3
00010F6A =00000005                M sptl4	=	op4
00010F6A 02                       M 	dc.b	(spfe<<3)+spal
00010F6B =00000080                M sptlmask4	set	$80
00010F6B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F6B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F6B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F6B 7132 0601                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F6F 5F5E 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F73 0206 0504                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F77 0807 0807                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F7B F8F8 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F7F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F83 0010 0785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F87 4E41 54                  M 	dc.b	'NAT'
00010F8A                            
00010F8A                            	; Patch $07
00010F8A                            	; $3D
00010F8A                            	; $01, $01, $01, $01,	$8E, $52, $14, $4C
00010F8A                            	; $08, $08, $0E, $03,	$00, $00, $00, $00
00010F8A                            	; $1F, $1F, $1F, $1F,	$1B, $05, $05, $05
00010F8A                            	spAlgorithm	$05
00010F8A =00000008                M spatnum	=	spatnum+1
00010F8A =00000005                M spal	=	val
00010F8A                            	spFeedback	$07
00010F8A =00000007                M spfe	=	val
00010F8A                            	spDetune	$00, $00, $00, $00
00010F8A =00000000                M spde1	=	op1
00010F8A =00000000                M spde2	=	op2
00010F8A =00000000                M spde3	=	op3
00010F8A =00000000                M spde4	=	op4
00010F8A                            	spMultiple	$01, $01, $01, $01
00010F8A =00000001                M spmu1	=	op1
00010F8A =00000001                M spmu2	=	op2
00010F8A =00000001                M spmu3	=	op3
00010F8A =00000001                M spmu4	=	op4
00010F8A                            	spRateScale	$02, $00, $01, $01
00010F8A =00000002                M sprs1	=	op1
00010F8A =00000000                M sprs2	=	op2
00010F8A =00000001                M sprs3	=	op3
00010F8A =00000001                M sprs4	=	op4
00010F8A                            	spAttackRt	$0E, $14, $12, $0C
00010F8A =0000000E                M spar1	=	op1
00010F8A =00000014                M spar2	=	op2
00010F8A =00000012                M spar3	=	op3
00010F8A =0000000C                M spar4	=	op4
00010F8A                            	spAmpMod	$00, $00, $00, $00
00010F8A =00000000                M spam1	=	op1
00010F8A =00000000                M spam2	=	op2
00010F8A =00000000                M spam3	=	op3
00010F8A =00000000                M spam4	=	op4
00010F8A                            	spSustainRt	$08, $0E, $08, $03
00010F8A =00000008                M spsr1	=	op1
00010F8A =0000000E                M spsr2	=	op2
00010F8A =00000008                M spsr3	=	op3
00010F8A =00000003                M spsr4	=	op4
00010F8A                            	spDecayRt	$00, $00, $00, $00
00010F8A =00000000                M spdr1	=	op1
00010F8A =00000000                M spdr2	=	op2
00010F8A =00000000                M spdr3	=	op3
00010F8A =00000000                M spdr4	=	op4
00010F8A                            	spSustainLv	$01, $01, $01, $01
00010F8A =00000001                M spsl1	=	op1
00010F8A =00000001                M spsl2	=	op2
00010F8A =00000001                M spsl3	=	op3
00010F8A =00000001                M spsl4	=	op4
00010F8A                            	spReleaseRt	$0F, $0F, $0F, $0F
00010F8A =0000000F                M sprr1	=	op1
00010F8A =0000000F                M sprr2	=	op2
00010F8A =0000000F                M sprr3	=	op3
00010F8A =0000000F                M sprr4	=	op4
00010F8A                            	spSSGEG		$00, $00, $00, $00
00010F8A =00000000                M spss1	=	op1
00010F8A =00000000                M spss2	=	op2
00010F8A =00000000                M spss3	=	op3
00010F8A =00000000                M spss4	=	op4
00010F8A                            	spTotalLv	$1B, $05, $05, $05
00010F8A =0000001B                M sptl1	=	op1
00010F8A =00000005                M sptl2	=	op2
00010F8A =00000005                M sptl3	=	op3
00010F8A =00000005                M sptl4	=	op4
00010F8A 3D                       M 	dc.b	(spfe<<3)+spal
00010F8B =00000080                M sptlmask4	set	$80
00010F8B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F8B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F8B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F8B 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F8F 8E52 144C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F93 0808 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F97 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F9B 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F9F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FA3 1B85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FA7 4E41 54                  M 	dc.b	'NAT'
00010FAA                            
00010FAA                            	; Patch $08
00010FAA                            	; $0D
00010FAA                            	; $77, $65, $05, $15,	$1F, $5F, $5F, $5F
00010FAA                            	; $00, $10, $08, $10,	$00, $03, $05, $04
00010FAA                            	; $0F, $FC, $8C, $CC,	$1F, $05, $05, $05
00010FAA                            	spAlgorithm	$05
00010FAA =00000009                M spatnum	=	spatnum+1
00010FAA =00000005                M spal	=	val
00010FAA                            	spFeedback	$01
00010FAA =00000001                M spfe	=	val
00010FAA                            	spDetune	$07, $00, $06, $01
00010FAA =00000007                M spde1	=	op1
00010FAA =00000000                M spde2	=	op2
00010FAA =00000006                M spde3	=	op3
00010FAA =00000001                M spde4	=	op4
00010FAA                            	spMultiple	$07, $05, $05, $05
00010FAA =00000007                M spmu1	=	op1
00010FAA =00000005                M spmu2	=	op2
00010FAA =00000005                M spmu3	=	op3
00010FAA =00000005                M spmu4	=	op4
00010FAA                            	spRateScale	$00, $01, $01, $01
00010FAA =00000000                M sprs1	=	op1
00010FAA =00000001                M sprs2	=	op2
00010FAA =00000001                M sprs3	=	op3
00010FAA =00000001                M sprs4	=	op4
00010FAA                            	spAttackRt	$1F, $1F, $1F, $1F
00010FAA =0000001F                M spar1	=	op1
00010FAA =0000001F                M spar2	=	op2
00010FAA =0000001F                M spar3	=	op3
00010FAA =0000001F                M spar4	=	op4
00010FAA                            	spAmpMod	$00, $00, $00, $00
00010FAA =00000000                M spam1	=	op1
00010FAA =00000000                M spam2	=	op2
00010FAA =00000000                M spam3	=	op3
00010FAA =00000000                M spam4	=	op4
00010FAA                            	spSustainRt	$00, $08, $10, $10
00010FAA =00000000                M spsr1	=	op1
00010FAA =00000008                M spsr2	=	op2
00010FAA =00000010                M spsr3	=	op3
00010FAA =00000010                M spsr4	=	op4
00010FAA                            	spDecayRt	$00, $05, $03, $04
00010FAA =00000000                M spdr1	=	op1
00010FAA =00000005                M spdr2	=	op2
00010FAA =00000003                M spdr3	=	op3
00010FAA =00000004                M spdr4	=	op4
00010FAA                            	spSustainLv	$00, $08, $0F, $0C
00010FAA =00000000                M spsl1	=	op1
00010FAA =00000008                M spsl2	=	op2
00010FAA =0000000F                M spsl3	=	op3
00010FAA =0000000C                M spsl4	=	op4
00010FAA                            	spReleaseRt	$0F, $0C, $0C, $0C
00010FAA =0000000F                M sprr1	=	op1
00010FAA =0000000C                M sprr2	=	op2
00010FAA =0000000C                M sprr3	=	op3
00010FAA =0000000C                M sprr4	=	op4
00010FAA                            	spSSGEG		$00, $00, $00, $00
00010FAA =00000000                M spss1	=	op1
00010FAA =00000000                M spss2	=	op2
00010FAA =00000000                M spss3	=	op3
00010FAA =00000000                M spss4	=	op4
00010FAA                            	spTotalLv	$1F, $05, $05, $05
00010FAA =0000001F                M sptl1	=	op1
00010FAA =00000005                M sptl2	=	op2
00010FAA =00000005                M sptl3	=	op3
00010FAA =00000005                M sptl4	=	op4
00010FAA 0D                       M 	dc.b	(spfe<<3)+spal
00010FAB =00000080                M sptlmask4	set	$80
00010FAB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010FAB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FAB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FAB 7765 0515                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FAF 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FB3 0010 0810                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FB7 0003 0504                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FBB 0FFC 8CCC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FBF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FC3 1F85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FC7 4E41 54                  M 	dc.b	'NAT'
00010FCA                            
00010FCA                            	; Patch $09
00010FCA                            	; $32
00010FCA                            	; $71, $0D, $33, $01,	$5F, $99, $5F, $94
00010FCA                            	; $05, $05, $05, $07,	$02, $02, $02, $02
00010FCA                            	; $11, $11, $11, $72,	$23, $2D, $26, $05
00010FCA                            	spAlgorithm	$02
00010FCA =0000000A                M spatnum	=	spatnum+1
00010FCA =00000002                M spal	=	val
00010FCA                            	spFeedback	$06
00010FCA =00000006                M spfe	=	val
00010FCA                            	spDetune	$07, $03, $00, $00
00010FCA =00000007                M spde1	=	op1
00010FCA =00000003                M spde2	=	op2
00010FCA =00000000                M spde3	=	op3
00010FCA =00000000                M spde4	=	op4
00010FCA                            	spMultiple	$01, $03, $0D, $01
00010FCA =00000001                M spmu1	=	op1
00010FCA =00000003                M spmu2	=	op2
00010FCA =0000000D                M spmu3	=	op3
00010FCA =00000001                M spmu4	=	op4
00010FCA                            	spRateScale	$01, $01, $02, $02
00010FCA =00000001                M sprs1	=	op1
00010FCA =00000001                M sprs2	=	op2
00010FCA =00000002                M sprs3	=	op3
00010FCA =00000002                M sprs4	=	op4
00010FCA                            	spAttackRt	$1F, $1F, $19, $14
00010FCA =0000001F                M spar1	=	op1
00010FCA =0000001F                M spar2	=	op2
00010FCA =00000019                M spar3	=	op3
00010FCA =00000014                M spar4	=	op4
00010FCA                            	spAmpMod	$00, $00, $00, $00
00010FCA =00000000                M spam1	=	op1
00010FCA =00000000                M spam2	=	op2
00010FCA =00000000                M spam3	=	op3
00010FCA =00000000                M spam4	=	op4
00010FCA                            	spSustainRt	$05, $05, $05, $07
00010FCA =00000005                M spsr1	=	op1
00010FCA =00000005                M spsr2	=	op2
00010FCA =00000005                M spsr3	=	op3
00010FCA =00000007                M spsr4	=	op4
00010FCA                            	spDecayRt	$02, $02, $02, $02
00010FCA =00000002                M spdr1	=	op1
00010FCA =00000002                M spdr2	=	op2
00010FCA =00000002                M spdr3	=	op3
00010FCA =00000002                M spdr4	=	op4
00010FCA                            	spSustainLv	$01, $01, $01, $07
00010FCA =00000001                M spsl1	=	op1
00010FCA =00000001                M spsl2	=	op2
00010FCA =00000001                M spsl3	=	op3
00010FCA =00000007                M spsl4	=	op4
00010FCA                            	spReleaseRt	$01, $01, $01, $02
00010FCA =00000001                M sprr1	=	op1
00010FCA =00000001                M sprr2	=	op2
00010FCA =00000001                M sprr3	=	op3
00010FCA =00000002                M sprr4	=	op4
00010FCA                            	spSSGEG		$00, $00, $00, $00
00010FCA =00000000                M spss1	=	op1
00010FCA =00000000                M spss2	=	op2
00010FCA =00000000                M spss3	=	op3
00010FCA =00000000                M spss4	=	op4
00010FCA                            	spTotalLv	$23, $26, $2D, $05
00010FCA =00000023                M sptl1	=	op1
00010FCA =00000026                M sptl2	=	op2
00010FCA =0000002D                M sptl3	=	op3
00010FCA =00000005                M sptl4	=	op4
00010FCA 32                       M 	dc.b	(spfe<<3)+spal
00010FCB =00000080                M sptlmask4	set	$80
00010FCB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FCB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010FCB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FCB 710D 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FCF 5F99 5F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FD3 0505 0507                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FD7 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FDB 1111 1172                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FDF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FE3 232D 2685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FE7 4E41 54                  M 	dc.b	'NAT'
00010FEA                            
00010FEA                            	; Patch $0A
00010FEA                            	; $08
00010FEA                            	; $0A, $70, $30, $00,	$1F, $1F, $5F, $5F
00010FEA                            	; $12, $0E, $0A, $0A,	$00, $04, $04, $03
00010FEA                            	; $2F, $2F, $2F, $2F,	$22, $2E, $13, $04
00010FEA                            	spAlgorithm	$00
00010FEA =0000000B                M spatnum	=	spatnum+1
00010FEA =00000000                M spal	=	val
00010FEA                            	spFeedback	$01
00010FEA =00000001                M spfe	=	val
00010FEA                            	spDetune	$00, $03, $07, $00
00010FEA =00000000                M spde1	=	op1
00010FEA =00000003                M spde2	=	op2
00010FEA =00000007                M spde3	=	op3
00010FEA =00000000                M spde4	=	op4
00010FEA                            	spMultiple	$0A, $00, $00, $00
00010FEA =0000000A                M spmu1	=	op1
00010FEA =00000000                M spmu2	=	op2
00010FEA =00000000                M spmu3	=	op3
00010FEA =00000000                M spmu4	=	op4
00010FEA                            	spRateScale	$00, $01, $00, $01
00010FEA =00000000                M sprs1	=	op1
00010FEA =00000001                M sprs2	=	op2
00010FEA =00000000                M sprs3	=	op3
00010FEA =00000001                M sprs4	=	op4
00010FEA                            	spAttackRt	$1F, $1F, $1F, $1F
00010FEA =0000001F                M spar1	=	op1
00010FEA =0000001F                M spar2	=	op2
00010FEA =0000001F                M spar3	=	op3
00010FEA =0000001F                M spar4	=	op4
00010FEA                            	spAmpMod	$00, $00, $00, $00
00010FEA =00000000                M spam1	=	op1
00010FEA =00000000                M spam2	=	op2
00010FEA =00000000                M spam3	=	op3
00010FEA =00000000                M spam4	=	op4
00010FEA                            	spSustainRt	$12, $0A, $0E, $0A
00010FEA =00000012                M spsr1	=	op1
00010FEA =0000000A                M spsr2	=	op2
00010FEA =0000000E                M spsr3	=	op3
00010FEA =0000000A                M spsr4	=	op4
00010FEA                            	spDecayRt	$00, $04, $04, $03
00010FEA =00000000                M spdr1	=	op1
00010FEA =00000004                M spdr2	=	op2
00010FEA =00000004                M spdr3	=	op3
00010FEA =00000003                M spdr4	=	op4
00010FEA                            	spSustainLv	$02, $02, $02, $02
00010FEA =00000002                M spsl1	=	op1
00010FEA =00000002                M spsl2	=	op2
00010FEA =00000002                M spsl3	=	op3
00010FEA =00000002                M spsl4	=	op4
00010FEA                            	spReleaseRt	$0F, $0F, $0F, $0F
00010FEA =0000000F                M sprr1	=	op1
00010FEA =0000000F                M sprr2	=	op2
00010FEA =0000000F                M sprr3	=	op3
00010FEA =0000000F                M sprr4	=	op4
00010FEA                            	spSSGEG		$00, $00, $00, $00
00010FEA =00000000                M spss1	=	op1
00010FEA =00000000                M spss2	=	op2
00010FEA =00000000                M spss3	=	op3
00010FEA =00000000                M spss4	=	op4
00010FEA                            	spTotalLv	$22, $13, $2E, $04
00010FEA =00000022                M sptl1	=	op1
00010FEA =00000013                M sptl2	=	op2
00010FEA =0000002E                M sptl3	=	op3
00010FEA =00000004                M sptl4	=	op4
00010FEA 08                       M 	dc.b	(spfe<<3)+spal
00010FEB =00000080                M sptlmask4	set	$80
00010FEB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FEB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010FEB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FEB 0A70 3000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FEF 1F1F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FF3 120E 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FF7 0004 0403                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FFB 2F2F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FFF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011003 222E 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011007 4E41 54                  M 	dc.b	'NAT'
0001100A                            
0001100A                            	; Patch $0B
0001100A                            	; $28
0001100A                            	; $39, $35, $30, $31,	$1F, $1F, $1F, $1F
0001100A                            	; $0C, $0A, $07, $0A,	$07, $07, $07, $09
0001100A                            	; $26, $16, $16, $F6,	$17, $32, $14, $05
0001100A                            	spAlgorithm	$00
0001100A =0000000C                M spatnum	=	spatnum+1
0001100A =00000000                M spal	=	val
0001100A                            	spFeedback	$05
0001100A =00000005                M spfe	=	val
0001100A                            	spDetune	$03, $03, $03, $03
0001100A =00000003                M spde1	=	op1
0001100A =00000003                M spde2	=	op2
0001100A =00000003                M spde3	=	op3
0001100A =00000003                M spde4	=	op4
0001100A                            	spMultiple	$09, $00, $05, $01
0001100A =00000009                M spmu1	=	op1
0001100A =00000000                M spmu2	=	op2
0001100A =00000005                M spmu3	=	op3
0001100A =00000001                M spmu4	=	op4
0001100A                            	spRateScale	$00, $00, $00, $00
0001100A =00000000                M sprs1	=	op1
0001100A =00000000                M sprs2	=	op2
0001100A =00000000                M sprs3	=	op3
0001100A =00000000                M sprs4	=	op4
0001100A                            	spAttackRt	$1F, $1F, $1F, $1F
0001100A =0000001F                M spar1	=	op1
0001100A =0000001F                M spar2	=	op2
0001100A =0000001F                M spar3	=	op3
0001100A =0000001F                M spar4	=	op4
0001100A                            	spAmpMod	$00, $00, $00, $00
0001100A =00000000                M spam1	=	op1
0001100A =00000000                M spam2	=	op2
0001100A =00000000                M spam3	=	op3
0001100A =00000000                M spam4	=	op4
0001100A                            	spSustainRt	$0C, $07, $0A, $0A
0001100A =0000000C                M spsr1	=	op1
0001100A =00000007                M spsr2	=	op2
0001100A =0000000A                M spsr3	=	op3
0001100A =0000000A                M spsr4	=	op4
0001100A                            	spDecayRt	$07, $07, $07, $09
0001100A =00000007                M spdr1	=	op1
0001100A =00000007                M spdr2	=	op2
0001100A =00000007                M spdr3	=	op3
0001100A =00000009                M spdr4	=	op4
0001100A                            	spSustainLv	$02, $01, $01, $0F
0001100A =00000002                M spsl1	=	op1
0001100A =00000001                M spsl2	=	op2
0001100A =00000001                M spsl3	=	op3
0001100A =0000000F                M spsl4	=	op4
0001100A                            	spReleaseRt	$06, $06, $06, $06
0001100A =00000006                M sprr1	=	op1
0001100A =00000006                M sprr2	=	op2
0001100A =00000006                M sprr3	=	op3
0001100A =00000006                M sprr4	=	op4
0001100A                            	spSSGEG		$00, $00, $00, $00
0001100A =00000000                M spss1	=	op1
0001100A =00000000                M spss2	=	op2
0001100A =00000000                M spss3	=	op3
0001100A =00000000                M spss4	=	op4
0001100A                            	spTotalLv	$17, $14, $32, $05
0001100A =00000017                M sptl1	=	op1
0001100A =00000014                M sptl2	=	op2
0001100A =00000032                M sptl3	=	op3
0001100A =00000005                M sptl4	=	op4
0001100A 28                       M 	dc.b	(spfe<<3)+spal
0001100B =00000080                M sptlmask4	set	$80
0001100B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001100B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001100B =00000000                M sptlmask1	set	((spal=7)<<7)
0001100B 3935 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001100F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011013 0C0A 070A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011017 0707 0709                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001101B 2616 16F6                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001101F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011023 1732 1485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011027 4E41 54                  M 	dc.b	'NAT'
0001102A                            
0001102A                            	; Patch $0C
0001102A                            	; $3D
0001102A                            	; $6F, $22, $62, $22,	$1F, $1F, $1F, $1F
0001102A                            	; $0F, $0F, $0F, $0F,	$08, $08, $08, $08
0001102A                            	; $25, $25, $25, $25,	$1E, $36, $05, $09
0001102A                            	spAlgorithm	$05
0001102A =0000000D                M spatnum	=	spatnum+1
0001102A =00000005                M spal	=	val
0001102A                            	spFeedback	$07
0001102A =00000007                M spfe	=	val
0001102A                            	spDetune	$06, $06, $02, $02
0001102A =00000006                M spde1	=	op1
0001102A =00000006                M spde2	=	op2
0001102A =00000002                M spde3	=	op3
0001102A =00000002                M spde4	=	op4
0001102A                            	spMultiple	$0F, $02, $02, $02
0001102A =0000000F                M spmu1	=	op1
0001102A =00000002                M spmu2	=	op2
0001102A =00000002                M spmu3	=	op3
0001102A =00000002                M spmu4	=	op4
0001102A                            	spRateScale	$00, $00, $00, $00
0001102A =00000000                M sprs1	=	op1
0001102A =00000000                M sprs2	=	op2
0001102A =00000000                M sprs3	=	op3
0001102A =00000000                M sprs4	=	op4
0001102A                            	spAttackRt	$1F, $1F, $1F, $1F
0001102A =0000001F                M spar1	=	op1
0001102A =0000001F                M spar2	=	op2
0001102A =0000001F                M spar3	=	op3
0001102A =0000001F                M spar4	=	op4
0001102A                            	spAmpMod	$00, $00, $00, $00
0001102A =00000000                M spam1	=	op1
0001102A =00000000                M spam2	=	op2
0001102A =00000000                M spam3	=	op3
0001102A =00000000                M spam4	=	op4
0001102A                            	spSustainRt	$0F, $0F, $0F, $0F
0001102A =0000000F                M spsr1	=	op1
0001102A =0000000F                M spsr2	=	op2
0001102A =0000000F                M spsr3	=	op3
0001102A =0000000F                M spsr4	=	op4
0001102A                            	spDecayRt	$08, $08, $08, $08
0001102A =00000008                M spdr1	=	op1
0001102A =00000008                M spdr2	=	op2
0001102A =00000008                M spdr3	=	op3
0001102A =00000008                M spdr4	=	op4
0001102A                            	spSustainLv	$02, $02, $02, $02
0001102A =00000002                M spsl1	=	op1
0001102A =00000002                M spsl2	=	op2
0001102A =00000002                M spsl3	=	op3
0001102A =00000002                M spsl4	=	op4
0001102A                            	spReleaseRt	$05, $05, $05, $05
0001102A =00000005                M sprr1	=	op1
0001102A =00000005                M sprr2	=	op2
0001102A =00000005                M sprr3	=	op3
0001102A =00000005                M sprr4	=	op4
0001102A                            	spSSGEG		$00, $00, $00, $00
0001102A =00000000                M spss1	=	op1
0001102A =00000000                M spss2	=	op2
0001102A =00000000                M spss3	=	op3
0001102A =00000000                M spss4	=	op4
0001102A                            	spTotalLv	$1E, $05, $36, $09
0001102A =0000001E                M sptl1	=	op1
0001102A =00000005                M sptl2	=	op2
0001102A =00000036                M sptl3	=	op3
0001102A =00000009                M sptl4	=	op4
0001102A 3D                       M 	dc.b	(spfe<<3)+spal
0001102B =00000080                M sptlmask4	set	$80
0001102B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001102B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001102B =00000000                M sptlmask1	set	((spal=7)<<7)
0001102B 6F22 6222                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001102F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011033 0F0F 0F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011037 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001103B 2525 2525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001103F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011043 1EB6 8589                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011047 4E41 54                  M 	dc.b	'NAT'
0001104A                            
0001104A                            	; Patch $0D
0001104A                            	; $06
0001104A                            	; $61, $03, $32, $71,	$1F, $1F, $1F, $1F
0001104A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
0001104A                            	; $07, $07, $07, $07,	$1E, $0A, $05, $05
0001104A                            	spAlgorithm	$06
0001104A =0000000E                M spatnum	=	spatnum+1
0001104A =00000006                M spal	=	val
0001104A                            	spFeedback	$00
0001104A =00000000                M spfe	=	val
0001104A                            	spDetune	$06, $03, $00, $07
0001104A =00000006                M spde1	=	op1
0001104A =00000003                M spde2	=	op2
0001104A =00000000                M spde3	=	op3
0001104A =00000007                M spde4	=	op4
0001104A                            	spMultiple	$01, $02, $03, $01
0001104A =00000001                M spmu1	=	op1
0001104A =00000002                M spmu2	=	op2
0001104A =00000003                M spmu3	=	op3
0001104A =00000001                M spmu4	=	op4
0001104A                            	spRateScale	$00, $00, $00, $00
0001104A =00000000                M sprs1	=	op1
0001104A =00000000                M sprs2	=	op2
0001104A =00000000                M sprs3	=	op3
0001104A =00000000                M sprs4	=	op4
0001104A                            	spAttackRt	$1F, $1F, $1F, $1F
0001104A =0000001F                M spar1	=	op1
0001104A =0000001F                M spar2	=	op2
0001104A =0000001F                M spar3	=	op3
0001104A =0000001F                M spar4	=	op4
0001104A                            	spAmpMod	$00, $00, $00, $00
0001104A =00000000                M spam1	=	op1
0001104A =00000000                M spam2	=	op2
0001104A =00000000                M spam3	=	op3
0001104A =00000000                M spam4	=	op4
0001104A                            	spSustainRt	$00, $00, $00, $00
0001104A =00000000                M spsr1	=	op1
0001104A =00000000                M spsr2	=	op2
0001104A =00000000                M spsr3	=	op3
0001104A =00000000                M spsr4	=	op4
0001104A                            	spDecayRt	$00, $00, $00, $00
0001104A =00000000                M spdr1	=	op1
0001104A =00000000                M spdr2	=	op2
0001104A =00000000                M spdr3	=	op3
0001104A =00000000                M spdr4	=	op4
0001104A                            	spSustainLv	$00, $00, $00, $00
0001104A =00000000                M spsl1	=	op1
0001104A =00000000                M spsl2	=	op2
0001104A =00000000                M spsl3	=	op3
0001104A =00000000                M spsl4	=	op4
0001104A                            	spReleaseRt	$07, $07, $07, $07
0001104A =00000007                M sprr1	=	op1
0001104A =00000007                M sprr2	=	op2
0001104A =00000007                M sprr3	=	op3
0001104A =00000007                M sprr4	=	op4
0001104A                            	spSSGEG		$00, $00, $00, $00
0001104A =00000000                M spss1	=	op1
0001104A =00000000                M spss2	=	op2
0001104A =00000000                M spss3	=	op3
0001104A =00000000                M spss4	=	op4
0001104A                            	spTotalLv	$1E, $05, $0A, $05
0001104A =0000001E                M sptl1	=	op1
0001104A =00000005                M sptl2	=	op2
0001104A =0000000A                M sptl3	=	op3
0001104A =00000005                M sptl4	=	op4
0001104A 06                       M 	dc.b	(spfe<<3)+spal
0001104B =00000080                M sptlmask4	set	$80
0001104B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001104B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001104B =00000000                M sptlmask1	set	((spal=7)<<7)
0001104B 6103 3271                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001104F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011053 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011057 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001105B 0707 0707                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001105F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011063 1E8A 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011067 4E41 54                  M 	dc.b	'NAT'
0001106A                            
0001106A                            	; Patch $0E
0001106A                            	; $24
0001106A                            	; $31, $71, $61, $16,	$11, $55, $14, $55
0001106A                            	; $1F, $01, $00, $04,	$00, $00, $00, $01
0001106A                            	; $11, $97, $05, $A7,	$04, $05, $00, $05
0001106A                            	spAlgorithm	$04
0001106A =0000000F                M spatnum	=	spatnum+1
0001106A =00000004                M spal	=	val
0001106A                            	spFeedback	$04
0001106A =00000004                M spfe	=	val
0001106A                            	spDetune	$03, $06, $07, $01
0001106A =00000003                M spde1	=	op1
0001106A =00000006                M spde2	=	op2
0001106A =00000007                M spde3	=	op3
0001106A =00000001                M spde4	=	op4
0001106A                            	spMultiple	$01, $01, $01, $06
0001106A =00000001                M spmu1	=	op1
0001106A =00000001                M spmu2	=	op2
0001106A =00000001                M spmu3	=	op3
0001106A =00000006                M spmu4	=	op4
0001106A                            	spRateScale	$00, $00, $01, $01
0001106A =00000000                M sprs1	=	op1
0001106A =00000000                M sprs2	=	op2
0001106A =00000001                M sprs3	=	op3
0001106A =00000001                M sprs4	=	op4
0001106A                            	spAttackRt	$11, $14, $15, $15
0001106A =00000011                M spar1	=	op1
0001106A =00000014                M spar2	=	op2
0001106A =00000015                M spar3	=	op3
0001106A =00000015                M spar4	=	op4
0001106A                            	spAmpMod	$00, $00, $00, $00
0001106A =00000000                M spam1	=	op1
0001106A =00000000                M spam2	=	op2
0001106A =00000000                M spam3	=	op3
0001106A =00000000                M spam4	=	op4
0001106A                            	spSustainRt	$1F, $00, $01, $04
0001106A =0000001F                M spsr1	=	op1
0001106A =00000000                M spsr2	=	op2
0001106A =00000001                M spsr3	=	op3
0001106A =00000004                M spsr4	=	op4
0001106A                            	spDecayRt	$00, $00, $00, $01
0001106A =00000000                M spdr1	=	op1
0001106A =00000000                M spdr2	=	op2
0001106A =00000000                M spdr3	=	op3
0001106A =00000001                M spdr4	=	op4
0001106A                            	spSustainLv	$01, $00, $09, $0A
0001106A =00000001                M spsl1	=	op1
0001106A =00000000                M spsl2	=	op2
0001106A =00000009                M spsl3	=	op3
0001106A =0000000A                M spsl4	=	op4
0001106A                            	spReleaseRt	$01, $05, $07, $07
0001106A =00000001                M sprr1	=	op1
0001106A =00000005                M sprr2	=	op2
0001106A =00000007                M sprr3	=	op3
0001106A =00000007                M sprr4	=	op4
0001106A                            	spSSGEG		$00, $00, $00, $00
0001106A =00000000                M spss1	=	op1
0001106A =00000000                M spss2	=	op2
0001106A =00000000                M spss3	=	op3
0001106A =00000000                M spss4	=	op4
0001106A                            	spTotalLv	$04, $00, $05, $05
0001106A =00000004                M sptl1	=	op1
0001106A =00000000                M sptl2	=	op2
0001106A =00000005                M sptl3	=	op3
0001106A =00000005                M sptl4	=	op4
0001106A 24                       M 	dc.b	(spfe<<3)+spal
0001106B =00000080                M sptlmask4	set	$80
0001106B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001106B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001106B =00000000                M sptlmask1	set	((spal=7)<<7)
0001106B 3171 6116                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001106F 1155 1455                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011073 1F01 0004                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011077 0000 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001107B 1197 05A7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001107F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011083 0485 0085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011087 4E41 54                  M 	dc.b	'NAT'
0001108A                            
0001108A                            	; Patch $0F
0001108A                            	; $36
0001108A                            	; $72, $02, $01, $01,	$D8, $47, $8D, $87
0001108A                            	; $01, $04, $01, $05,	$00, $05, $07, $00
0001108A                            	; $51, $14, $15, $14,	$11, $05, $7F, $7F
0001108A                            	spAlgorithm	$06
0001108A =00000010                M spatnum	=	spatnum+1
0001108A =00000006                M spal	=	val
0001108A                            	spFeedback	$06
0001108A =00000006                M spfe	=	val
0001108A                            	spDetune	$07, $00, $00, $00
0001108A =00000007                M spde1	=	op1
0001108A =00000000                M spde2	=	op2
0001108A =00000000                M spde3	=	op3
0001108A =00000000                M spde4	=	op4
0001108A                            	spMultiple	$02, $01, $02, $01
0001108A =00000002                M spmu1	=	op1
0001108A =00000001                M spmu2	=	op2
0001108A =00000002                M spmu3	=	op3
0001108A =00000001                M spmu4	=	op4
0001108A                            	spRateScale	$03, $02, $01, $02
0001108A =00000003                M sprs1	=	op1
0001108A =00000002                M sprs2	=	op2
0001108A =00000001                M sprs3	=	op3
0001108A =00000002                M sprs4	=	op4
0001108A                            	spAttackRt	$18, $0D, $07, $07
0001108A =00000018                M spar1	=	op1
0001108A =0000000D                M spar2	=	op2
0001108A =00000007                M spar3	=	op3
0001108A =00000007                M spar4	=	op4
0001108A                            	spAmpMod	$00, $00, $00, $00
0001108A =00000000                M spam1	=	op1
0001108A =00000000                M spam2	=	op2
0001108A =00000000                M spam3	=	op3
0001108A =00000000                M spam4	=	op4
0001108A                            	spSustainRt	$01, $01, $04, $05
0001108A =00000001                M spsr1	=	op1
0001108A =00000001                M spsr2	=	op2
0001108A =00000004                M spsr3	=	op3
0001108A =00000005                M spsr4	=	op4
0001108A                            	spDecayRt	$00, $07, $05, $00
0001108A =00000000                M spdr1	=	op1
0001108A =00000007                M spdr2	=	op2
0001108A =00000005                M spdr3	=	op3
0001108A =00000000                M spdr4	=	op4
0001108A                            	spSustainLv	$05, $01, $01, $01
0001108A =00000005                M spsl1	=	op1
0001108A =00000001                M spsl2	=	op2
0001108A =00000001                M spsl3	=	op3
0001108A =00000001                M spsl4	=	op4
0001108A                            	spReleaseRt	$01, $05, $04, $04
0001108A =00000001                M sprr1	=	op1
0001108A =00000005                M sprr2	=	op2
0001108A =00000004                M sprr3	=	op3
0001108A =00000004                M sprr4	=	op4
0001108A                            	spSSGEG		$00, $00, $00, $00
0001108A =00000000                M spss1	=	op1
0001108A =00000000                M spss2	=	op2
0001108A =00000000                M spss3	=	op3
0001108A =00000000                M spss4	=	op4
0001108A                            	spTotalLv	$11, $7F, $05, $7F
0001108A =00000011                M sptl1	=	op1
0001108A =0000007F                M sptl2	=	op2
0001108A =00000005                M sptl3	=	op3
0001108A =0000007F                M sptl4	=	op4
0001108A 36                       M 	dc.b	(spfe<<3)+spal
0001108B =00000080                M sptlmask4	set	$80
0001108B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001108B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001108B =00000000                M sptlmask1	set	((spal=7)<<7)
0001108B 7202 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001108F D847 8D87                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011093 0104 0105                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011097 0005 0700                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001109B 5114 1514                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001109F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110A3 1185 FFFF                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110A7 4E41 54                  M 	dc.b	'NAT'
000110AA                            
000110AA                            	; Patch $10
000110AA                            	; $24
000110AA                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
000110AA                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
000110AA                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
000110AA                            	spAlgorithm	$04
000110AA =00000011                M spatnum	=	spatnum+1
000110AA =00000004                M spal	=	val
000110AA                            	spFeedback	$04
000110AA =00000004                M spfe	=	val
000110AA                            	spDetune	$01, $03, $00, $01
000110AA =00000001                M spde1	=	op1
000110AA =00000003                M spde2	=	op2
000110AA =00000000                M spde3	=	op3
000110AA =00000001                M spde4	=	op4
000110AA                            	spMultiple	$00, $01, $01, $01
000110AA =00000000                M spmu1	=	op1
000110AA =00000001                M spmu2	=	op2
000110AA =00000001                M spmu3	=	op3
000110AA =00000001                M spmu4	=	op4
000110AA                            	spRateScale	$02, $00, $01, $01
000110AA =00000002                M sprs1	=	op1
000110AA =00000000                M sprs2	=	op2
000110AA =00000001                M sprs3	=	op3
000110AA =00000001                M sprs4	=	op4
000110AA                            	spAttackRt	$1B, $1B, $1C, $1C
000110AA =0000001B                M spar1	=	op1
000110AA =0000001B                M spar2	=	op2
000110AA =0000001C                M spar3	=	op3
000110AA =0000001C                M spar4	=	op4
000110AA                            	spAmpMod	$00, $00, $00, $00
000110AA =00000000                M spam1	=	op1
000110AA =00000000                M spam2	=	op2
000110AA =00000000                M spam3	=	op3
000110AA =00000000                M spam4	=	op4
000110AA                            	spSustainRt	$0A, $0A, $10, $10
000110AA =0000000A                M spsr1	=	op1
000110AA =0000000A                M spsr2	=	op2
000110AA =00000010                M spsr3	=	op3
000110AA =00000010                M spsr4	=	op4
000110AA                            	spDecayRt	$03, $03, $04, $04
000110AA =00000003                M spdr1	=	op1
000110AA =00000003                M spdr2	=	op2
000110AA =00000004                M spdr3	=	op3
000110AA =00000004                M spdr4	=	op4
000110AA                            	spSustainLv	$01, $08, $00, $00
000110AA =00000001                M spsl1	=	op1
000110AA =00000008                M spsl2	=	op2
000110AA =00000000                M spsl3	=	op3
000110AA =00000000                M spsl4	=	op4
000110AA                            	spReleaseRt	$0F, $0F, $0C, $0C
000110AA =0000000F                M sprr1	=	op1
000110AA =0000000F                M sprr2	=	op2
000110AA =0000000C                M sprr3	=	op3
000110AA =0000000C                M sprr4	=	op4
000110AA                            	spSSGEG		$00, $00, $00, $00
000110AA =00000000                M spss1	=	op1
000110AA =00000000                M spss2	=	op2
000110AA =00000000                M spss3	=	op3
000110AA =00000000                M spss4	=	op4
000110AA                            	spTotalLv	$06, $04, $05, $05
000110AA =00000006                M sptl1	=	op1
000110AA =00000004                M sptl2	=	op2
000110AA =00000005                M sptl3	=	op3
000110AA =00000005                M sptl4	=	op4
000110AA 24                       M 	dc.b	(spfe<<3)+spal
000110AB =00000080                M sptlmask4	set	$80
000110AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110AB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110AB =00000000                M sptlmask1	set	((spal=7)<<7)
000110AB 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110AF 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110B3 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110B7 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110BB 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110C3 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110C7 4E41 54                  M 	dc.b	'NAT'
000110CA                            
000110CA                            	; Patch $11
000110CA                            	; $23
000110CA                            	; $30, $75, $30, $70,	$08, $1F, $1D, $5B
000110CA                            	; $8B, $16, $96, $95,	$01, $00, $00, $00
000110CA                            	; $8B, $3A, $3A, $3A,	$05, $0D, $0B, $02
000110CA                            	spAlgorithm	$03
000110CA =00000012                M spatnum	=	spatnum+1
000110CA =00000003                M spal	=	val
000110CA                            	spFeedback	$04
000110CA =00000004                M spfe	=	val
000110CA                            	spDetune	$03, $03, $07, $07
000110CA =00000003                M spde1	=	op1
000110CA =00000003                M spde2	=	op2
000110CA =00000007                M spde3	=	op3
000110CA =00000007                M spde4	=	op4
000110CA                            	spMultiple	$00, $00, $05, $00
000110CA =00000000                M spmu1	=	op1
000110CA =00000000                M spmu2	=	op2
000110CA =00000005                M spmu3	=	op3
000110CA =00000000                M spmu4	=	op4
000110CA                            	spRateScale	$00, $00, $00, $01
000110CA =00000000                M sprs1	=	op1
000110CA =00000000                M sprs2	=	op2
000110CA =00000000                M sprs3	=	op3
000110CA =00000001                M sprs4	=	op4
000110CA                            	spAttackRt	$08, $1D, $1F, $1B
000110CA =00000008                M spar1	=	op1
000110CA =0000001D                M spar2	=	op2
000110CA =0000001F                M spar3	=	op3
000110CA =0000001B                M spar4	=	op4
000110CA                            	spAmpMod	$01, $01, $00, $01
000110CA =00000001                M spam1	=	op1
000110CA =00000001                M spam2	=	op2
000110CA =00000000                M spam3	=	op3
000110CA =00000001                M spam4	=	op4
000110CA                            	spSustainRt	$0B, $16, $16, $15
000110CA =0000000B                M spsr1	=	op1
000110CA =00000016                M spsr2	=	op2
000110CA =00000016                M spsr3	=	op3
000110CA =00000015                M spsr4	=	op4
000110CA                            	spDecayRt	$01, $00, $00, $00
000110CA =00000001                M spdr1	=	op1
000110CA =00000000                M spdr2	=	op2
000110CA =00000000                M spdr3	=	op3
000110CA =00000000                M spdr4	=	op4
000110CA                            	spSustainLv	$08, $03, $03, $03
000110CA =00000008                M spsl1	=	op1
000110CA =00000003                M spsl2	=	op2
000110CA =00000003                M spsl3	=	op3
000110CA =00000003                M spsl4	=	op4
000110CA                            	spReleaseRt	$0B, $0A, $0A, $0A
000110CA =0000000B                M sprr1	=	op1
000110CA =0000000A                M sprr2	=	op2
000110CA =0000000A                M sprr3	=	op3
000110CA =0000000A                M sprr4	=	op4
000110CA                            	spSSGEG		$00, $00, $00, $00
000110CA =00000000                M spss1	=	op1
000110CA =00000000                M spss2	=	op2
000110CA =00000000                M spss3	=	op3
000110CA =00000000                M spss4	=	op4
000110CA                            	spTotalLv	$05, $0B, $0D, $02
000110CA =00000005                M sptl1	=	op1
000110CA =0000000B                M sptl2	=	op2
000110CA =0000000D                M sptl3	=	op3
000110CA =00000002                M sptl4	=	op4
000110CA 23                       M 	dc.b	(spfe<<3)+spal
000110CB =00000080                M sptlmask4	set	$80
000110CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000110CB =00000000                M sptlmask1	set	((spal=7)<<7)
000110CB 3075 3070                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110CF 081F 1D5B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110D3 8B16 9695                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110D7 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110DB 8B3A 3A3A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110E3 050D 0B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110E7 4E41 54                  M 	dc.b	'NAT'
000110EA                            
000110EA                            	; Patch $12
000110EA                            	; $2C
000110EA                            	; $70, $32, $00, $00,	$9F, $1F, $5F, $5E
000110EA                            	; $1A, $15, $0C, $05,	$08, $06, $02, $09
000110EA                            	; $28, $AA, $BA, $8A,	$08, $05, $0B, $05
000110EA                            	spAlgorithm	$04
000110EA =00000013                M spatnum	=	spatnum+1
000110EA =00000004                M spal	=	val
000110EA                            	spFeedback	$05
000110EA =00000005                M spfe	=	val
000110EA                            	spDetune	$07, $00, $03, $00
000110EA =00000007                M spde1	=	op1
000110EA =00000000                M spde2	=	op2
000110EA =00000003                M spde3	=	op3
000110EA =00000000                M spde4	=	op4
000110EA                            	spMultiple	$00, $00, $02, $00
000110EA =00000000                M spmu1	=	op1
000110EA =00000000                M spmu2	=	op2
000110EA =00000002                M spmu3	=	op3
000110EA =00000000                M spmu4	=	op4
000110EA                            	spRateScale	$02, $01, $00, $01
000110EA =00000002                M sprs1	=	op1
000110EA =00000001                M sprs2	=	op2
000110EA =00000000                M sprs3	=	op3
000110EA =00000001                M sprs4	=	op4
000110EA                            	spAttackRt	$1F, $1F, $1F, $1E
000110EA =0000001F                M spar1	=	op1
000110EA =0000001F                M spar2	=	op2
000110EA =0000001F                M spar3	=	op3
000110EA =0000001E                M spar4	=	op4
000110EA                            	spAmpMod	$00, $00, $00, $00
000110EA =00000000                M spam1	=	op1
000110EA =00000000                M spam2	=	op2
000110EA =00000000                M spam3	=	op3
000110EA =00000000                M spam4	=	op4
000110EA                            	spSustainRt	$1A, $0C, $15, $05
000110EA =0000001A                M spsr1	=	op1
000110EA =0000000C                M spsr2	=	op2
000110EA =00000015                M spsr3	=	op3
000110EA =00000005                M spsr4	=	op4
000110EA                            	spDecayRt	$08, $02, $06, $09
000110EA =00000008                M spdr1	=	op1
000110EA =00000002                M spdr2	=	op2
000110EA =00000006                M spdr3	=	op3
000110EA =00000009                M spdr4	=	op4
000110EA                            	spSustainLv	$02, $0B, $0A, $08
000110EA =00000002                M spsl1	=	op1
000110EA =0000000B                M spsl2	=	op2
000110EA =0000000A                M spsl3	=	op3
000110EA =00000008                M spsl4	=	op4
000110EA                            	spReleaseRt	$08, $0A, $0A, $0A
000110EA =00000008                M sprr1	=	op1
000110EA =0000000A                M sprr2	=	op2
000110EA =0000000A                M sprr3	=	op3
000110EA =0000000A                M sprr4	=	op4
000110EA                            	spSSGEG		$00, $00, $00, $00
000110EA =00000000                M spss1	=	op1
000110EA =00000000                M spss2	=	op2
000110EA =00000000                M spss3	=	op3
000110EA =00000000                M spss4	=	op4
000110EA                            	spTotalLv	$08, $0B, $05, $05
000110EA =00000008                M sptl1	=	op1
000110EA =0000000B                M sptl2	=	op2
000110EA =00000005                M sptl3	=	op3
000110EA =00000005                M sptl4	=	op4
000110EA 2C                       M 	dc.b	(spfe<<3)+spal
000110EB =00000080                M sptlmask4	set	$80
000110EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110EB =00000000                M sptlmask1	set	((spal=7)<<7)
000110EB 7032 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110EF 9F1F 5F5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110F3 1A15 0C05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110F7 0806 0209                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110FB 28AA BA8A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011103 0885 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011107 4E41 54                  M 	dc.b	'NAT'
0001110A                            
0001110A                            	; Patch $13
0001110A                            	; $35
0001110A                            	; $77, $03, $74, $32,	$1A, $14, $56, $17
0001110A                            	; $97, $9F, $9D, $9F,	$13, $0F, $0F, $0E
0001110A                            	; $7C, $1D, $1D, $1D,	$13, $04, $02, $06
0001110A                            	spAlgorithm	$05
0001110A =00000014                M spatnum	=	spatnum+1
0001110A =00000005                M spal	=	val
0001110A                            	spFeedback	$06
0001110A =00000006                M spfe	=	val
0001110A                            	spDetune	$07, $07, $00, $03
0001110A =00000007                M spde1	=	op1
0001110A =00000007                M spde2	=	op2
0001110A =00000000                M spde3	=	op3
0001110A =00000003                M spde4	=	op4
0001110A                            	spMultiple	$07, $04, $03, $02
0001110A =00000007                M spmu1	=	op1
0001110A =00000004                M spmu2	=	op2
0001110A =00000003                M spmu3	=	op3
0001110A =00000002                M spmu4	=	op4
0001110A                            	spRateScale	$00, $01, $00, $00
0001110A =00000000                M sprs1	=	op1
0001110A =00000001                M sprs2	=	op2
0001110A =00000000                M sprs3	=	op3
0001110A =00000000                M sprs4	=	op4
0001110A                            	spAttackRt	$1A, $16, $14, $17
0001110A =0000001A                M spar1	=	op1
0001110A =00000016                M spar2	=	op2
0001110A =00000014                M spar3	=	op3
0001110A =00000017                M spar4	=	op4
0001110A                            	spAmpMod	$01, $01, $01, $01
0001110A =00000001                M spam1	=	op1
0001110A =00000001                M spam2	=	op2
0001110A =00000001                M spam3	=	op3
0001110A =00000001                M spam4	=	op4
0001110A                            	spSustainRt	$17, $1D, $1F, $1F
0001110A =00000017                M spsr1	=	op1
0001110A =0000001D                M spsr2	=	op2
0001110A =0000001F                M spsr3	=	op3
0001110A =0000001F                M spsr4	=	op4
0001110A                            	spDecayRt	$13, $0F, $0F, $0E
0001110A =00000013                M spdr1	=	op1
0001110A =0000000F                M spdr2	=	op2
0001110A =0000000F                M spdr3	=	op3
0001110A =0000000E                M spdr4	=	op4
0001110A                            	spSustainLv	$07, $01, $01, $01
0001110A =00000007                M spsl1	=	op1
0001110A =00000001                M spsl2	=	op2
0001110A =00000001                M spsl3	=	op3
0001110A =00000001                M spsl4	=	op4
0001110A                            	spReleaseRt	$0C, $0D, $0D, $0D
0001110A =0000000C                M sprr1	=	op1
0001110A =0000000D                M sprr2	=	op2
0001110A =0000000D                M sprr3	=	op3
0001110A =0000000D                M sprr4	=	op4
0001110A                            	spSSGEG		$00, $00, $00, $00
0001110A =00000000                M spss1	=	op1
0001110A =00000000                M spss2	=	op2
0001110A =00000000                M spss3	=	op3
0001110A =00000000                M spss4	=	op4
0001110A                            	spTotalLv	$13, $02, $04, $06
0001110A =00000013                M sptl1	=	op1
0001110A =00000002                M sptl2	=	op2
0001110A =00000004                M sptl3	=	op3
0001110A =00000006                M sptl4	=	op4
0001110A 35                       M 	dc.b	(spfe<<3)+spal
0001110B =00000080                M sptlmask4	set	$80
0001110B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001110B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001110B =00000000                M sptlmask1	set	((spal=7)<<7)
0001110B 7703 7432                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001110F 1A14 5617                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011113 979F 9D9F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011117 130F 0F0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001111B 7C1D 1D1D                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001111F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011123 1384 8286                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011127 4E41 54                  M 	dc.b	'NAT'
0001112A                            
0001112A                            	; Patch $14
0001112A                            	; $35
0001112A                            	; $21, $31, $20, $15,	$8E, $9B, $95, $94
0001112A                            	; $00, $05, $00, $80,	$01, $02, $02, $02
0001112A                            	; $47, $37, $19, $07,	$19, $05, $0E, $08
0001112A                            	spAlgorithm	$05
0001112A =00000015                M spatnum	=	spatnum+1
0001112A =00000005                M spal	=	val
0001112A                            	spFeedback	$06
0001112A =00000006                M spfe	=	val
0001112A                            	spDetune	$02, $02, $03, $01
0001112A =00000002                M spde1	=	op1
0001112A =00000002                M spde2	=	op2
0001112A =00000003                M spde3	=	op3
0001112A =00000001                M spde4	=	op4
0001112A                            	spMultiple	$01, $00, $01, $05
0001112A =00000001                M spmu1	=	op1
0001112A =00000000                M spmu2	=	op2
0001112A =00000001                M spmu3	=	op3
0001112A =00000005                M spmu4	=	op4
0001112A                            	spRateScale	$02, $02, $02, $02
0001112A =00000002                M sprs1	=	op1
0001112A =00000002                M sprs2	=	op2
0001112A =00000002                M sprs3	=	op3
0001112A =00000002                M sprs4	=	op4
0001112A                            	spAttackRt	$0E, $15, $1B, $14
0001112A =0000000E                M spar1	=	op1
0001112A =00000015                M spar2	=	op2
0001112A =0000001B                M spar3	=	op3
0001112A =00000014                M spar4	=	op4
0001112A                            	spAmpMod	$00, $00, $00, $01
0001112A =00000000                M spam1	=	op1
0001112A =00000000                M spam2	=	op2
0001112A =00000000                M spam3	=	op3
0001112A =00000001                M spam4	=	op4
0001112A                            	spSustainRt	$00, $00, $05, $00
0001112A =00000000                M spsr1	=	op1
0001112A =00000000                M spsr2	=	op2
0001112A =00000005                M spsr3	=	op3
0001112A =00000000                M spsr4	=	op4
0001112A                            	spDecayRt	$01, $02, $02, $02
0001112A =00000001                M spdr1	=	op1
0001112A =00000002                M spdr2	=	op2
0001112A =00000002                M spdr3	=	op3
0001112A =00000002                M spdr4	=	op4
0001112A                            	spSustainLv	$04, $01, $03, $00
0001112A =00000004                M spsl1	=	op1
0001112A =00000001                M spsl2	=	op2
0001112A =00000003                M spsl3	=	op3
0001112A =00000000                M spsl4	=	op4
0001112A                            	spReleaseRt	$07, $09, $07, $07
0001112A =00000007                M sprr1	=	op1
0001112A =00000009                M sprr2	=	op2
0001112A =00000007                M sprr3	=	op3
0001112A =00000007                M sprr4	=	op4
0001112A                            	spSSGEG		$00, $00, $00, $00
0001112A =00000000                M spss1	=	op1
0001112A =00000000                M spss2	=	op2
0001112A =00000000                M spss3	=	op3
0001112A =00000000                M spss4	=	op4
0001112A                            	spTotalLv	$19, $0E, $05, $08
0001112A =00000019                M sptl1	=	op1
0001112A =0000000E                M sptl2	=	op2
0001112A =00000005                M sptl3	=	op3
0001112A =00000008                M sptl4	=	op4
0001112A 35                       M 	dc.b	(spfe<<3)+spal
0001112B =00000080                M sptlmask4	set	$80
0001112B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001112B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001112B =00000000                M sptlmask1	set	((spal=7)<<7)
0001112B 2131 2015                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001112F 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011133 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011137 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001113B 4737 1907                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001113F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011143 1985 8E88                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011147 4E41 54                  M 	dc.b	'NAT'
0001114A                            
0001114A                            	; Patch $15
0001114A                            	; $35
0001114A                            	; $22, $32, $21, $34,	$8E, $9B, $8F, $94
0001114A                            	; $00, $05, $00, $80,	$01, $02, $02, $02
0001114A                            	; $07, $36, $17, $08,	$15, $12, $14, $05
0001114A                            	spAlgorithm	$05
0001114A =00000016                M spatnum	=	spatnum+1
0001114A =00000005                M spal	=	val
0001114A                            	spFeedback	$06
0001114A =00000006                M spfe	=	val
0001114A                            	spDetune	$02, $02, $03, $03
0001114A =00000002                M spde1	=	op1
0001114A =00000002                M spde2	=	op2
0001114A =00000003                M spde3	=	op3
0001114A =00000003                M spde4	=	op4
0001114A                            	spMultiple	$02, $01, $02, $04
0001114A =00000002                M spmu1	=	op1
0001114A =00000001                M spmu2	=	op2
0001114A =00000002                M spmu3	=	op3
0001114A =00000004                M spmu4	=	op4
0001114A                            	spRateScale	$02, $02, $02, $02
0001114A =00000002                M sprs1	=	op1
0001114A =00000002                M sprs2	=	op2
0001114A =00000002                M sprs3	=	op3
0001114A =00000002                M sprs4	=	op4
0001114A                            	spAttackRt	$0E, $0F, $1B, $14
0001114A =0000000E                M spar1	=	op1
0001114A =0000000F                M spar2	=	op2
0001114A =0000001B                M spar3	=	op3
0001114A =00000014                M spar4	=	op4
0001114A                            	spAmpMod	$00, $00, $00, $01
0001114A =00000000                M spam1	=	op1
0001114A =00000000                M spam2	=	op2
0001114A =00000000                M spam3	=	op3
0001114A =00000001                M spam4	=	op4
0001114A                            	spSustainRt	$00, $00, $05, $00
0001114A =00000000                M spsr1	=	op1
0001114A =00000000                M spsr2	=	op2
0001114A =00000005                M spsr3	=	op3
0001114A =00000000                M spsr4	=	op4
0001114A                            	spDecayRt	$01, $02, $02, $02
0001114A =00000001                M spdr1	=	op1
0001114A =00000002                M spdr2	=	op2
0001114A =00000002                M spdr3	=	op3
0001114A =00000002                M spdr4	=	op4
0001114A                            	spSustainLv	$00, $01, $03, $00
0001114A =00000000                M spsl1	=	op1
0001114A =00000001                M spsl2	=	op2
0001114A =00000003                M spsl3	=	op3
0001114A =00000000                M spsl4	=	op4
0001114A                            	spReleaseRt	$07, $07, $06, $08
0001114A =00000007                M sprr1	=	op1
0001114A =00000007                M sprr2	=	op2
0001114A =00000006                M sprr3	=	op3
0001114A =00000008                M sprr4	=	op4
0001114A                            	spSSGEG		$00, $00, $00, $00
0001114A =00000000                M spss1	=	op1
0001114A =00000000                M spss2	=	op2
0001114A =00000000                M spss3	=	op3
0001114A =00000000                M spss4	=	op4
0001114A                            	spTotalLv	$15, $14, $12, $05
0001114A =00000015                M sptl1	=	op1
0001114A =00000014                M sptl2	=	op2
0001114A =00000012                M sptl3	=	op3
0001114A =00000005                M sptl4	=	op4
0001114A 35                       M 	dc.b	(spfe<<3)+spal
0001114B =00000080                M sptlmask4	set	$80
0001114B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001114B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001114B =00000000                M sptlmask1	set	((spal=7)<<7)
0001114B 2232 2134                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001114F 8E9B 8F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011153 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011157 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001115B 0736 1708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001115F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011163 1592 9485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011167 4E41 54                  M 	dc.b	'NAT'
0001116A                            
0001116A                            	; Patch $16
0001116A                            	; $2B
0001116A                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
0001116A                            	; $06, $80, $80, $85,	$01, $17, $12, $0A
0001116A                            	; $AA, $AF, $F9, $FC,	$0E, $12, $46, $05
0001116A                            	spAlgorithm	$03
0001116A =00000017                M spatnum	=	spatnum+1
0001116A =00000003                M spal	=	val
0001116A                            	spFeedback	$05
0001116A =00000005                M spfe	=	val
0001116A                            	spDetune	$03, $03, $03, $03
0001116A =00000003                M spde1	=	op1
0001116A =00000003                M spde2	=	op2
0001116A =00000003                M spde3	=	op3
0001116A =00000003                M spde4	=	op4
0001116A                            	spMultiple	$01, $05, $02, $01
0001116A =00000001                M spmu1	=	op1
0001116A =00000005                M spmu2	=	op2
0001116A =00000002                M spmu3	=	op3
0001116A =00000001                M spmu4	=	op4
0001116A                            	spRateScale	$00, $02, $01, $01
0001116A =00000000                M sprs1	=	op1
0001116A =00000002                M sprs2	=	op2
0001116A =00000001                M sprs3	=	op3
0001116A =00000001                M sprs4	=	op4
0001116A                            	spAttackRt	$1F, $1E, $19, $1E
0001116A =0000001F                M spar1	=	op1
0001116A =0000001E                M spar2	=	op2
0001116A =00000019                M spar3	=	op3
0001116A =0000001E                M spar4	=	op4
0001116A                            	spAmpMod	$00, $01, $01, $01
0001116A =00000000                M spam1	=	op1
0001116A =00000001                M spam2	=	op2
0001116A =00000001                M spam3	=	op3
0001116A =00000001                M spam4	=	op4
0001116A                            	spSustainRt	$06, $00, $00, $05
0001116A =00000006                M spsr1	=	op1
0001116A =00000000                M spsr2	=	op2
0001116A =00000000                M spsr3	=	op3
0001116A =00000005                M spsr4	=	op4
0001116A                            	spDecayRt	$01, $12, $17, $0A
0001116A =00000001                M spdr1	=	op1
0001116A =00000012                M spdr2	=	op2
0001116A =00000017                M spdr3	=	op3
0001116A =0000000A                M spdr4	=	op4
0001116A                            	spSustainLv	$0A, $0F, $0A, $0F
0001116A =0000000A                M spsl1	=	op1
0001116A =0000000F                M spsl2	=	op2
0001116A =0000000A                M spsl3	=	op3
0001116A =0000000F                M spsl4	=	op4
0001116A                            	spReleaseRt	$0A, $09, $0F, $0C
0001116A =0000000A                M sprr1	=	op1
0001116A =00000009                M sprr2	=	op2
0001116A =0000000F                M sprr3	=	op3
0001116A =0000000C                M sprr4	=	op4
0001116A                            	spSSGEG		$00, $00, $00, $00
0001116A =00000000                M spss1	=	op1
0001116A =00000000                M spss2	=	op2
0001116A =00000000                M spss3	=	op3
0001116A =00000000                M spss4	=	op4
0001116A                            	spTotalLv	$0E, $46, $12, $05
0001116A =0000000E                M sptl1	=	op1
0001116A =00000046                M sptl2	=	op2
0001116A =00000012                M sptl3	=	op3
0001116A =00000005                M sptl4	=	op4
0001116A 2B                       M 	dc.b	(spfe<<3)+spal
0001116B =00000080                M sptlmask4	set	$80
0001116B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001116B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001116B =00000000                M sptlmask1	set	((spal=7)<<7)
0001116B 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001116F 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011173 0680 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011177 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001117B AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001117F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011183 0E12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011187 4E41 54                  M 	dc.b	'NAT'
0001118A                            
0001118A                            	; Patch $17
0001118A                            	; $04
0001118A                            	; $00, $00, $01, $02,	$9F, $1F, $9F, $1F
0001118A                            	; $8A, $8A, $91, $94,	$0E, $0A, $0E, $0E
0001118A                            	; $F8, $48, $F8, $F8,	$17, $04, $07, $04
0001118A                            	spAlgorithm	$04
0001118A =00000018                M spatnum	=	spatnum+1
0001118A =00000004                M spal	=	val
0001118A                            	spFeedback	$00
0001118A =00000000                M spfe	=	val
0001118A                            	spDetune	$00, $00, $00, $00
0001118A =00000000                M spde1	=	op1
0001118A =00000000                M spde2	=	op2
0001118A =00000000                M spde3	=	op3
0001118A =00000000                M spde4	=	op4
0001118A                            	spMultiple	$00, $01, $00, $02
0001118A =00000000                M spmu1	=	op1
0001118A =00000001                M spmu2	=	op2
0001118A =00000000                M spmu3	=	op3
0001118A =00000002                M spmu4	=	op4
0001118A                            	spRateScale	$02, $02, $00, $00
0001118A =00000002                M sprs1	=	op1
0001118A =00000002                M sprs2	=	op2
0001118A =00000000                M sprs3	=	op3
0001118A =00000000                M sprs4	=	op4
0001118A                            	spAttackRt	$1F, $1F, $1F, $1F
0001118A =0000001F                M spar1	=	op1
0001118A =0000001F                M spar2	=	op2
0001118A =0000001F                M spar3	=	op3
0001118A =0000001F                M spar4	=	op4
0001118A                            	spAmpMod	$01, $01, $01, $01
0001118A =00000001                M spam1	=	op1
0001118A =00000001                M spam2	=	op2
0001118A =00000001                M spam3	=	op3
0001118A =00000001                M spam4	=	op4
0001118A                            	spSustainRt	$0A, $11, $0A, $14
0001118A =0000000A                M spsr1	=	op1
0001118A =00000011                M spsr2	=	op2
0001118A =0000000A                M spsr3	=	op3
0001118A =00000014                M spsr4	=	op4
0001118A                            	spDecayRt	$0E, $0E, $0A, $0E
0001118A =0000000E                M spdr1	=	op1
0001118A =0000000E                M spdr2	=	op2
0001118A =0000000A                M spdr3	=	op3
0001118A =0000000E                M spdr4	=	op4
0001118A                            	spSustainLv	$0F, $0F, $04, $0F
0001118A =0000000F                M spsl1	=	op1
0001118A =0000000F                M spsl2	=	op2
0001118A =00000004                M spsl3	=	op3
0001118A =0000000F                M spsl4	=	op4
0001118A                            	spReleaseRt	$08, $08, $08, $08
0001118A =00000008                M sprr1	=	op1
0001118A =00000008                M sprr2	=	op2
0001118A =00000008                M sprr3	=	op3
0001118A =00000008                M sprr4	=	op4
0001118A                            	spSSGEG		$00, $00, $00, $00
0001118A =00000000                M spss1	=	op1
0001118A =00000000                M spss2	=	op2
0001118A =00000000                M spss3	=	op3
0001118A =00000000                M spss4	=	op4
0001118A                            	spTotalLv	$17, $07, $04, $04
0001118A =00000017                M sptl1	=	op1
0001118A =00000007                M sptl2	=	op2
0001118A =00000004                M sptl3	=	op3
0001118A =00000004                M sptl4	=	op4
0001118A 04                       M 	dc.b	(spfe<<3)+spal
0001118B =00000080                M sptlmask4	set	$80
0001118B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001118B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001118B =00000000                M sptlmask1	set	((spal=7)<<7)
0001118B 0000 0102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001118F 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011193 8A8A 9194                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011197 0E0A 0E0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001119B F848 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001119F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111A3 1784 0784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111A7 4E41 54                  M 	dc.b	'NAT'
000111AA                            
000111AA                            	; Patch $18
000111AA                            	; $3A
000111AA                            	; $71, $0C, $33, $01,	$5F, $5F, $5F, $5F
000111AA                            	; $84, $89, $84, $8A,	$00, $01, $03, $06
000111AA                            	; $15, $12, $16, $28,	$25, $2F, $25, $03
000111AA                            	spAlgorithm	$02
000111AA =00000019                M spatnum	=	spatnum+1
000111AA =00000002                M spal	=	val
000111AA                            	spFeedback	$07
000111AA =00000007                M spfe	=	val
000111AA                            	spDetune	$07, $03, $00, $00
000111AA =00000007                M spde1	=	op1
000111AA =00000003                M spde2	=	op2
000111AA =00000000                M spde3	=	op3
000111AA =00000000                M spde4	=	op4
000111AA                            	spMultiple	$01, $03, $0C, $01
000111AA =00000001                M spmu1	=	op1
000111AA =00000003                M spmu2	=	op2
000111AA =0000000C                M spmu3	=	op3
000111AA =00000001                M spmu4	=	op4
000111AA                            	spRateScale	$01, $01, $01, $01
000111AA =00000001                M sprs1	=	op1
000111AA =00000001                M sprs2	=	op2
000111AA =00000001                M sprs3	=	op3
000111AA =00000001                M sprs4	=	op4
000111AA                            	spAttackRt	$1F, $1F, $1F, $1F
000111AA =0000001F                M spar1	=	op1
000111AA =0000001F                M spar2	=	op2
000111AA =0000001F                M spar3	=	op3
000111AA =0000001F                M spar4	=	op4
000111AA                            	spAmpMod	$01, $01, $01, $01
000111AA =00000001                M spam1	=	op1
000111AA =00000001                M spam2	=	op2
000111AA =00000001                M spam3	=	op3
000111AA =00000001                M spam4	=	op4
000111AA                            	spSustainRt	$04, $04, $09, $0A
000111AA =00000004                M spsr1	=	op1
000111AA =00000004                M spsr2	=	op2
000111AA =00000009                M spsr3	=	op3
000111AA =0000000A                M spsr4	=	op4
000111AA                            	spDecayRt	$00, $03, $01, $06
000111AA =00000000                M spdr1	=	op1
000111AA =00000003                M spdr2	=	op2
000111AA =00000001                M spdr3	=	op3
000111AA =00000006                M spdr4	=	op4
000111AA                            	spSustainLv	$01, $01, $01, $02
000111AA =00000001                M spsl1	=	op1
000111AA =00000001                M spsl2	=	op2
000111AA =00000001                M spsl3	=	op3
000111AA =00000002                M spsl4	=	op4
000111AA                            	spReleaseRt	$05, $06, $02, $08
000111AA =00000005                M sprr1	=	op1
000111AA =00000006                M sprr2	=	op2
000111AA =00000002                M sprr3	=	op3
000111AA =00000008                M sprr4	=	op4
000111AA                            	spSSGEG		$00, $00, $00, $00
000111AA =00000000                M spss1	=	op1
000111AA =00000000                M spss2	=	op2
000111AA =00000000                M spss3	=	op3
000111AA =00000000                M spss4	=	op4
000111AA                            	spTotalLv	$25, $25, $2F, $03
000111AA =00000025                M sptl1	=	op1
000111AA =00000025                M sptl2	=	op2
000111AA =0000002F                M sptl3	=	op3
000111AA =00000003                M sptl4	=	op4
000111AA 3A                       M 	dc.b	(spfe<<3)+spal
000111AB =00000080                M sptlmask4	set	$80
000111AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111AB =00000000                M sptlmask1	set	((spal=7)<<7)
000111AB 710C 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111AF 5F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111B3 8489 848A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111B7 0001 0306                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111BB 1512 1628                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111C3 252F 2583                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111C7 4E41 54                  M 	dc.b	'NAT'
000111CA                            
000111CA                            	; Patch $19
000111CA                            	; $3A
000111CA                            	; $04, $02, $08, $02,	$1F, $1F, $1F, $1F
000111CA                            	; $00, $00, $00, $11,	$15, $0F, $0B, $1F
000111CA                            	; $00, $00, $00, $50,	$09, $07, $3F, $04
000111CA                            	spAlgorithm	$02
000111CA =0000001A                M spatnum	=	spatnum+1
000111CA =00000002                M spal	=	val
000111CA                            	spFeedback	$07
000111CA =00000007                M spfe	=	val
000111CA                            	spDetune	$00, $00, $00, $00
000111CA =00000000                M spde1	=	op1
000111CA =00000000                M spde2	=	op2
000111CA =00000000                M spde3	=	op3
000111CA =00000000                M spde4	=	op4
000111CA                            	spMultiple	$04, $08, $02, $02
000111CA =00000004                M spmu1	=	op1
000111CA =00000008                M spmu2	=	op2
000111CA =00000002                M spmu3	=	op3
000111CA =00000002                M spmu4	=	op4
000111CA                            	spRateScale	$00, $00, $00, $00
000111CA =00000000                M sprs1	=	op1
000111CA =00000000                M sprs2	=	op2
000111CA =00000000                M sprs3	=	op3
000111CA =00000000                M sprs4	=	op4
000111CA                            	spAttackRt	$1F, $1F, $1F, $1F
000111CA =0000001F                M spar1	=	op1
000111CA =0000001F                M spar2	=	op2
000111CA =0000001F                M spar3	=	op3
000111CA =0000001F                M spar4	=	op4
000111CA                            	spAmpMod	$00, $00, $00, $00
000111CA =00000000                M spam1	=	op1
000111CA =00000000                M spam2	=	op2
000111CA =00000000                M spam3	=	op3
000111CA =00000000                M spam4	=	op4
000111CA                            	spSustainRt	$00, $00, $00, $11
000111CA =00000000                M spsr1	=	op1
000111CA =00000000                M spsr2	=	op2
000111CA =00000000                M spsr3	=	op3
000111CA =00000011                M spsr4	=	op4
000111CA                            	spDecayRt	$15, $0B, $0F, $1F
000111CA =00000015                M spdr1	=	op1
000111CA =0000000B                M spdr2	=	op2
000111CA =0000000F                M spdr3	=	op3
000111CA =0000001F                M spdr4	=	op4
000111CA                            	spSustainLv	$00, $00, $00, $05
000111CA =00000000                M spsl1	=	op1
000111CA =00000000                M spsl2	=	op2
000111CA =00000000                M spsl3	=	op3
000111CA =00000005                M spsl4	=	op4
000111CA                            	spReleaseRt	$00, $00, $00, $00
000111CA =00000000                M sprr1	=	op1
000111CA =00000000                M sprr2	=	op2
000111CA =00000000                M sprr3	=	op3
000111CA =00000000                M sprr4	=	op4
000111CA                            	spSSGEG		$00, $00, $00, $00
000111CA =00000000                M spss1	=	op1
000111CA =00000000                M spss2	=	op2
000111CA =00000000                M spss3	=	op3
000111CA =00000000                M spss4	=	op4
000111CA                            	spTotalLv	$09, $3F, $07, $04
000111CA =00000009                M sptl1	=	op1
000111CA =0000003F                M sptl2	=	op2
000111CA =00000007                M sptl3	=	op3
000111CA =00000004                M sptl4	=	op4
000111CA 3A                       M 	dc.b	(spfe<<3)+spal
000111CB =00000080                M sptlmask4	set	$80
000111CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111CB =00000000                M sptlmask1	set	((spal=7)<<7)
000111CB 0402 0802                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111CF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111D3 0000 0011                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111D7 150F 0B1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111DB 0000 0050                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111E3 0907 3F84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111E7 4E41 54                  M 	dc.b	'NAT'
000111EA                            
000111EA                            	; Patch $1A
000111EA                            	; $39
000111EA                            	; $11, $0C, $00, $00,	$1F, $5F, $D4, $D3
000111EA                            	; $07, $15, $0B, $0A,	$00, $10, $06, $01
000111EA                            	; $17, $8D, $06, $06,	$27, $24, $0C, $05
000111EA                            	spAlgorithm	$01
000111EA =0000001B                M spatnum	=	spatnum+1
000111EA =00000001                M spal	=	val
000111EA                            	spFeedback	$07
000111EA =00000007                M spfe	=	val
000111EA                            	spDetune	$01, $00, $00, $00
000111EA =00000001                M spde1	=	op1
000111EA =00000000                M spde2	=	op2
000111EA =00000000                M spde3	=	op3
000111EA =00000000                M spde4	=	op4
000111EA                            	spMultiple	$01, $00, $0C, $00
000111EA =00000001                M spmu1	=	op1
000111EA =00000000                M spmu2	=	op2
000111EA =0000000C                M spmu3	=	op3
000111EA =00000000                M spmu4	=	op4
000111EA                            	spRateScale	$00, $03, $01, $03
000111EA =00000000                M sprs1	=	op1
000111EA =00000003                M sprs2	=	op2
000111EA =00000001                M sprs3	=	op3
000111EA =00000003                M sprs4	=	op4
000111EA                            	spAttackRt	$1F, $14, $1F, $13
000111EA =0000001F                M spar1	=	op1
000111EA =00000014                M spar2	=	op2
000111EA =0000001F                M spar3	=	op3
000111EA =00000013                M spar4	=	op4
000111EA                            	spAmpMod	$00, $00, $00, $00
000111EA =00000000                M spam1	=	op1
000111EA =00000000                M spam2	=	op2
000111EA =00000000                M spam3	=	op3
000111EA =00000000                M spam4	=	op4
000111EA                            	spSustainRt	$07, $0B, $15, $0A
000111EA =00000007                M spsr1	=	op1
000111EA =0000000B                M spsr2	=	op2
000111EA =00000015                M spsr3	=	op3
000111EA =0000000A                M spsr4	=	op4
000111EA                            	spDecayRt	$00, $06, $10, $01
000111EA =00000000                M spdr1	=	op1
000111EA =00000006                M spdr2	=	op2
000111EA =00000010                M spdr3	=	op3
000111EA =00000001                M spdr4	=	op4
000111EA                            	spSustainLv	$01, $00, $08, $00
000111EA =00000001                M spsl1	=	op1
000111EA =00000000                M spsl2	=	op2
000111EA =00000008                M spsl3	=	op3
000111EA =00000000                M spsl4	=	op4
000111EA                            	spReleaseRt	$07, $06, $0D, $06
000111EA =00000007                M sprr1	=	op1
000111EA =00000006                M sprr2	=	op2
000111EA =0000000D                M sprr3	=	op3
000111EA =00000006                M sprr4	=	op4
000111EA                            	spSSGEG		$00, $00, $00, $00
000111EA =00000000                M spss1	=	op1
000111EA =00000000                M spss2	=	op2
000111EA =00000000                M spss3	=	op3
000111EA =00000000                M spss4	=	op4
000111EA                            	spTotalLv	$27, $0C, $24, $05
000111EA =00000027                M sptl1	=	op1
000111EA =0000000C                M sptl2	=	op2
000111EA =00000024                M sptl3	=	op3
000111EA =00000005                M sptl4	=	op4
000111EA 39                       M 	dc.b	(spfe<<3)+spal
000111EB =00000080                M sptlmask4	set	$80
000111EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111EB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111EB =00000000                M sptlmask1	set	((spal=7)<<7)
000111EB 110C 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111EF 1F5F D4D3                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111F3 0715 0B0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111F7 0010 0601                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111FB 178D 0606                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011203 2724 0C85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011207 4E41 54                  M 	dc.b	'NAT'
0001120A                            
0001120A                            	; Patch $1B
0001120A                            	; $3A
0001120A                            	; $60, $70, $21, $13,	$1F, $1F, $1F, $1F
0001120A                            	; $08, $09, $09, $09,	$00, $00, $00, $00
0001120A                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
0001120A                            	spAlgorithm	$02
0001120A =0000001C                M spatnum	=	spatnum+1
0001120A =00000002                M spal	=	val
0001120A                            	spFeedback	$07
0001120A =00000007                M spfe	=	val
0001120A                            	spDetune	$06, $02, $07, $01
0001120A =00000006                M spde1	=	op1
0001120A =00000002                M spde2	=	op2
0001120A =00000007                M spde3	=	op3
0001120A =00000001                M spde4	=	op4
0001120A                            	spMultiple	$00, $01, $00, $03
0001120A =00000000                M spmu1	=	op1
0001120A =00000001                M spmu2	=	op2
0001120A =00000000                M spmu3	=	op3
0001120A =00000003                M spmu4	=	op4
0001120A                            	spRateScale	$00, $00, $00, $00
0001120A =00000000                M sprs1	=	op1
0001120A =00000000                M sprs2	=	op2
0001120A =00000000                M sprs3	=	op3
0001120A =00000000                M sprs4	=	op4
0001120A                            	spAttackRt	$1F, $1F, $1F, $1F
0001120A =0000001F                M spar1	=	op1
0001120A =0000001F                M spar2	=	op2
0001120A =0000001F                M spar3	=	op3
0001120A =0000001F                M spar4	=	op4
0001120A                            	spAmpMod	$00, $00, $00, $00
0001120A =00000000                M spam1	=	op1
0001120A =00000000                M spam2	=	op2
0001120A =00000000                M spam3	=	op3
0001120A =00000000                M spam4	=	op4
0001120A                            	spSustainRt	$08, $09, $09, $09
0001120A =00000008                M spsr1	=	op1
0001120A =00000009                M spsr2	=	op2
0001120A =00000009                M spsr3	=	op3
0001120A =00000009                M spsr4	=	op4
0001120A                            	spDecayRt	$00, $00, $00, $00
0001120A =00000000                M spdr1	=	op1
0001120A =00000000                M spdr2	=	op2
0001120A =00000000                M spdr3	=	op3
0001120A =00000000                M spdr4	=	op4
0001120A                            	spSustainLv	$0F, $0F, $0F, $0F
0001120A =0000000F                M spsl1	=	op1
0001120A =0000000F                M spsl2	=	op2
0001120A =0000000F                M spsl3	=	op3
0001120A =0000000F                M spsl4	=	op4
0001120A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001120A =0000000F                M sprr1	=	op1
0001120A =0000000F                M sprr2	=	op2
0001120A =0000000F                M sprr3	=	op3
0001120A =0000000F                M sprr4	=	op4
0001120A                            	spSSGEG		$00, $00, $00, $00
0001120A =00000000                M spss1	=	op1
0001120A =00000000                M spss2	=	op2
0001120A =00000000                M spss3	=	op3
0001120A =00000000                M spss4	=	op4
0001120A                            	spTotalLv	$2C, $16, $3C, $05
0001120A =0000002C                M sptl1	=	op1
0001120A =00000016                M sptl2	=	op2
0001120A =0000003C                M sptl3	=	op3
0001120A =00000005                M sptl4	=	op4
0001120A 3A                       M 	dc.b	(spfe<<3)+spal
0001120B =00000080                M sptlmask4	set	$80
0001120B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001120B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001120B =00000000                M sptlmask1	set	((spal=7)<<7)
0001120B 6070 2113                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001120F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011213 0809 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011217 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001121B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001121F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011223 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011227 4E41 54                  M 	dc.b	'NAT'
0001122A                            
0001122A                            	; Patch $1C
0001122A                            	; $3A
0001122A                            	; $62, $62, $20, $13,	$1F, $1F, $1F, $1F
0001122A                            	; $05, $10, $05, $08,	$1F, $1F, $1F, $1F
0001122A                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
0001122A                            	spAlgorithm	$02
0001122A =0000001D                M spatnum	=	spatnum+1
0001122A =00000002                M spal	=	val
0001122A                            	spFeedback	$07
0001122A =00000007                M spfe	=	val
0001122A                            	spDetune	$06, $02, $06, $01
0001122A =00000006                M spde1	=	op1
0001122A =00000002                M spde2	=	op2
0001122A =00000006                M spde3	=	op3
0001122A =00000001                M spde4	=	op4
0001122A                            	spMultiple	$02, $00, $02, $03
0001122A =00000002                M spmu1	=	op1
0001122A =00000000                M spmu2	=	op2
0001122A =00000002                M spmu3	=	op3
0001122A =00000003                M spmu4	=	op4
0001122A                            	spRateScale	$00, $00, $00, $00
0001122A =00000000                M sprs1	=	op1
0001122A =00000000                M sprs2	=	op2
0001122A =00000000                M sprs3	=	op3
0001122A =00000000                M sprs4	=	op4
0001122A                            	spAttackRt	$1F, $1F, $1F, $1F
0001122A =0000001F                M spar1	=	op1
0001122A =0000001F                M spar2	=	op2
0001122A =0000001F                M spar3	=	op3
0001122A =0000001F                M spar4	=	op4
0001122A                            	spAmpMod	$00, $00, $00, $00
0001122A =00000000                M spam1	=	op1
0001122A =00000000                M spam2	=	op2
0001122A =00000000                M spam3	=	op3
0001122A =00000000                M spam4	=	op4
0001122A                            	spSustainRt	$05, $05, $10, $08
0001122A =00000005                M spsr1	=	op1
0001122A =00000005                M spsr2	=	op2
0001122A =00000010                M spsr3	=	op3
0001122A =00000008                M spsr4	=	op4
0001122A                            	spDecayRt	$1F, $1F, $1F, $1F
0001122A =0000001F                M spdr1	=	op1
0001122A =0000001F                M spdr2	=	op2
0001122A =0000001F                M spdr3	=	op3
0001122A =0000001F                M spdr4	=	op4
0001122A                            	spSustainLv	$0F, $0F, $0F, $0F
0001122A =0000000F                M spsl1	=	op1
0001122A =0000000F                M spsl2	=	op2
0001122A =0000000F                M spsl3	=	op3
0001122A =0000000F                M spsl4	=	op4
0001122A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001122A =0000000F                M sprr1	=	op1
0001122A =0000000F                M sprr2	=	op2
0001122A =0000000F                M sprr3	=	op3
0001122A =0000000F                M sprr4	=	op4
0001122A                            	spSSGEG		$00, $00, $00, $00
0001122A =00000000                M spss1	=	op1
0001122A =00000000                M spss2	=	op2
0001122A =00000000                M spss3	=	op3
0001122A =00000000                M spss4	=	op4
0001122A                            	spTotalLv	$2C, $16, $3C, $05
0001122A =0000002C                M sptl1	=	op1
0001122A =00000016                M sptl2	=	op2
0001122A =0000003C                M sptl3	=	op3
0001122A =00000005                M sptl4	=	op4
0001122A 3A                       M 	dc.b	(spfe<<3)+spal
0001122B =00000080                M sptlmask4	set	$80
0001122B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001122B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001122B =00000000                M sptlmask1	set	((spal=7)<<7)
0001122B 6262 2013                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001122F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011233 0510 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011237 1F1F 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001123B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001123F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011243 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011247 4E41 54                  M 	dc.b	'NAT'
0001124A                            
0001124A                            	; Patch $1D
0001124A                            	; $17
0001124A                            	; $08, $70, $70, $30,	$1F, $19, $1C, $5F
0001124A                            	; $93, $8F, $93, $95,	$00, $09, $06, $09
0001124A                            	; $2F, $3F, $0C, $1A,	$05, $13, $20, $0B
0001124A                            	spAlgorithm	$07
0001124A =0000001E                M spatnum	=	spatnum+1
0001124A =00000007                M spal	=	val
0001124A                            	spFeedback	$02
0001124A =00000002                M spfe	=	val
0001124A                            	spDetune	$00, $07, $07, $03
0001124A =00000000                M spde1	=	op1
0001124A =00000007                M spde2	=	op2
0001124A =00000007                M spde3	=	op3
0001124A =00000003                M spde4	=	op4
0001124A                            	spMultiple	$08, $00, $00, $00
0001124A =00000008                M spmu1	=	op1
0001124A =00000000                M spmu2	=	op2
0001124A =00000000                M spmu3	=	op3
0001124A =00000000                M spmu4	=	op4
0001124A                            	spRateScale	$00, $00, $00, $01
0001124A =00000000                M sprs1	=	op1
0001124A =00000000                M sprs2	=	op2
0001124A =00000000                M sprs3	=	op3
0001124A =00000001                M sprs4	=	op4
0001124A                            	spAttackRt	$1F, $1C, $19, $1F
0001124A =0000001F                M spar1	=	op1
0001124A =0000001C                M spar2	=	op2
0001124A =00000019                M spar3	=	op3
0001124A =0000001F                M spar4	=	op4
0001124A                            	spAmpMod	$01, $01, $01, $01
0001124A =00000001                M spam1	=	op1
0001124A =00000001                M spam2	=	op2
0001124A =00000001                M spam3	=	op3
0001124A =00000001                M spam4	=	op4
0001124A                            	spSustainRt	$13, $13, $0F, $15
0001124A =00000013                M spsr1	=	op1
0001124A =00000013                M spsr2	=	op2
0001124A =0000000F                M spsr3	=	op3
0001124A =00000015                M spsr4	=	op4
0001124A                            	spDecayRt	$00, $06, $09, $09
0001124A =00000000                M spdr1	=	op1
0001124A =00000006                M spdr2	=	op2
0001124A =00000009                M spdr3	=	op3
0001124A =00000009                M spdr4	=	op4
0001124A                            	spSustainLv	$02, $00, $03, $01
0001124A =00000002                M spsl1	=	op1
0001124A =00000000                M spsl2	=	op2
0001124A =00000003                M spsl3	=	op3
0001124A =00000001                M spsl4	=	op4
0001124A                            	spReleaseRt	$0F, $0C, $0F, $0A
0001124A =0000000F                M sprr1	=	op1
0001124A =0000000C                M sprr2	=	op2
0001124A =0000000F                M sprr3	=	op3
0001124A =0000000A                M sprr4	=	op4
0001124A                            	spSSGEG		$00, $00, $00, $00
0001124A =00000000                M spss1	=	op1
0001124A =00000000                M spss2	=	op2
0001124A =00000000                M spss3	=	op3
0001124A =00000000                M spss4	=	op4
0001124A                            	spTotalLv	$05, $20, $13, $0B
0001124A =00000005                M sptl1	=	op1
0001124A =00000020                M sptl2	=	op2
0001124A =00000013                M sptl3	=	op3
0001124A =0000000B                M sptl4	=	op4
0001124A 17                       M 	dc.b	(spfe<<3)+spal
0001124B =00000080                M sptlmask4	set	$80
0001124B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001124B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001124B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001124B 0870 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001124F 1F19 1C5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011253 938F 9395                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011257 0009 0609                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001125B 2F3F 0C1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001125F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011263 8593 A08B                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011267 4E41 54                  M 	dc.b	'NAT'
0001126A                            
0001126A                            	; Patch $1E
0001126A                            	; $33
0001126A                            	; $52, $60, $1B, $31,	$9A, $1F, $9C, $9F
0001126A                            	; $08, $1F, $09, $19,	$00, $00, $00, $02
0001126A                            	; $05, $16, $07, $08,	$23, $04, $19, $05
0001126A                            	spAlgorithm	$03
0001126A =0000001F                M spatnum	=	spatnum+1
0001126A =00000003                M spal	=	val
0001126A                            	spFeedback	$06
0001126A =00000006                M spfe	=	val
0001126A                            	spDetune	$05, $01, $06, $03
0001126A =00000005                M spde1	=	op1
0001126A =00000001                M spde2	=	op2
0001126A =00000006                M spde3	=	op3
0001126A =00000003                M spde4	=	op4
0001126A                            	spMultiple	$02, $0B, $00, $01
0001126A =00000002                M spmu1	=	op1
0001126A =0000000B                M spmu2	=	op2
0001126A =00000000                M spmu3	=	op3
0001126A =00000001                M spmu4	=	op4
0001126A                            	spRateScale	$02, $02, $00, $02
0001126A =00000002                M sprs1	=	op1
0001126A =00000002                M sprs2	=	op2
0001126A =00000000                M sprs3	=	op3
0001126A =00000002                M sprs4	=	op4
0001126A                            	spAttackRt	$1A, $1C, $1F, $1F
0001126A =0000001A                M spar1	=	op1
0001126A =0000001C                M spar2	=	op2
0001126A =0000001F                M spar3	=	op3
0001126A =0000001F                M spar4	=	op4
0001126A                            	spAmpMod	$00, $00, $00, $00
0001126A =00000000                M spam1	=	op1
0001126A =00000000                M spam2	=	op2
0001126A =00000000                M spam3	=	op3
0001126A =00000000                M spam4	=	op4
0001126A                            	spSustainRt	$08, $09, $1F, $19
0001126A =00000008                M spsr1	=	op1
0001126A =00000009                M spsr2	=	op2
0001126A =0000001F                M spsr3	=	op3
0001126A =00000019                M spsr4	=	op4
0001126A                            	spDecayRt	$00, $00, $00, $02
0001126A =00000000                M spdr1	=	op1
0001126A =00000000                M spdr2	=	op2
0001126A =00000000                M spdr3	=	op3
0001126A =00000002                M spdr4	=	op4
0001126A                            	spSustainLv	$00, $00, $01, $00
0001126A =00000000                M spsl1	=	op1
0001126A =00000000                M spsl2	=	op2
0001126A =00000001                M spsl3	=	op3
0001126A =00000000                M spsl4	=	op4
0001126A                            	spReleaseRt	$05, $07, $06, $08
0001126A =00000005                M sprr1	=	op1
0001126A =00000007                M sprr2	=	op2
0001126A =00000006                M sprr3	=	op3
0001126A =00000008                M sprr4	=	op4
0001126A                            	spSSGEG		$00, $00, $00, $00
0001126A =00000000                M spss1	=	op1
0001126A =00000000                M spss2	=	op2
0001126A =00000000                M spss3	=	op3
0001126A =00000000                M spss4	=	op4
0001126A                            	spTotalLv	$23, $19, $04, $05
0001126A =00000023                M sptl1	=	op1
0001126A =00000019                M sptl2	=	op2
0001126A =00000004                M sptl3	=	op3
0001126A =00000005                M sptl4	=	op4
0001126A 33                       M 	dc.b	(spfe<<3)+spal
0001126B =00000080                M sptlmask4	set	$80
0001126B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001126B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001126B =00000000                M sptlmask1	set	((spal=7)<<7)
0001126B 5260 1B31                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001126F 9A1F 9C9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011273 081F 0919                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011277 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001127B 0516 0708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001127F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011283 2304 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011287 4E41 54                  M 	dc.b	'NAT'
0001128A                            
0001128A                            	; Patch $1F
0001128A                            	; $1B
0001128A                            	; $31, $13, $71, $52,	$18, $10, $16, $13
0001128A                            	; $17, $9F, $1F, $1F,	$00, $00, $00, $00
0001128A                            	; $06, $01, $07, $0C,	$0C, $10, $0E, $05
0001128A                            	spAlgorithm	$03
0001128A =00000020                M spatnum	=	spatnum+1
0001128A =00000003                M spal	=	val
0001128A                            	spFeedback	$03
0001128A =00000003                M spfe	=	val
0001128A                            	spDetune	$03, $07, $01, $05
0001128A =00000003                M spde1	=	op1
0001128A =00000007                M spde2	=	op2
0001128A =00000001                M spde3	=	op3
0001128A =00000005                M spde4	=	op4
0001128A                            	spMultiple	$01, $01, $03, $02
0001128A =00000001                M spmu1	=	op1
0001128A =00000001                M spmu2	=	op2
0001128A =00000003                M spmu3	=	op3
0001128A =00000002                M spmu4	=	op4
0001128A                            	spRateScale	$00, $00, $00, $00
0001128A =00000000                M sprs1	=	op1
0001128A =00000000                M sprs2	=	op2
0001128A =00000000                M sprs3	=	op3
0001128A =00000000                M sprs4	=	op4
0001128A                            	spAttackRt	$18, $16, $10, $13
0001128A =00000018                M spar1	=	op1
0001128A =00000016                M spar2	=	op2
0001128A =00000010                M spar3	=	op3
0001128A =00000013                M spar4	=	op4
0001128A                            	spAmpMod	$00, $00, $01, $00
0001128A =00000000                M spam1	=	op1
0001128A =00000000                M spam2	=	op2
0001128A =00000001                M spam3	=	op3
0001128A =00000000                M spam4	=	op4
0001128A                            	spSustainRt	$17, $1F, $1F, $1F
0001128A =00000017                M spsr1	=	op1
0001128A =0000001F                M spsr2	=	op2
0001128A =0000001F                M spsr3	=	op3
0001128A =0000001F                M spsr4	=	op4
0001128A                            	spDecayRt	$00, $00, $00, $00
0001128A =00000000                M spdr1	=	op1
0001128A =00000000                M spdr2	=	op2
0001128A =00000000                M spdr3	=	op3
0001128A =00000000                M spdr4	=	op4
0001128A                            	spSustainLv	$00, $00, $00, $00
0001128A =00000000                M spsl1	=	op1
0001128A =00000000                M spsl2	=	op2
0001128A =00000000                M spsl3	=	op3
0001128A =00000000                M spsl4	=	op4
0001128A                            	spReleaseRt	$06, $07, $01, $0C
0001128A =00000006                M sprr1	=	op1
0001128A =00000007                M sprr2	=	op2
0001128A =00000001                M sprr3	=	op3
0001128A =0000000C                M sprr4	=	op4
0001128A                            	spSSGEG		$00, $00, $00, $00
0001128A =00000000                M spss1	=	op1
0001128A =00000000                M spss2	=	op2
0001128A =00000000                M spss3	=	op3
0001128A =00000000                M spss4	=	op4
0001128A                            	spTotalLv	$0C, $0E, $10, $05
0001128A =0000000C                M sptl1	=	op1
0001128A =0000000E                M sptl2	=	op2
0001128A =00000010                M sptl3	=	op3
0001128A =00000005                M sptl4	=	op4
0001128A 1B                       M 	dc.b	(spfe<<3)+spal
0001128B =00000080                M sptlmask4	set	$80
0001128B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001128B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001128B =00000000                M sptlmask1	set	((spal=7)<<7)
0001128B 3113 7152                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001128F 1810 1613                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011293 179F 1F1F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011297 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001129B 0601 070C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001129F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112A3 0C10 0E85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112A7 4E41 54                  M 	dc.b	'NAT'
000112AA                            
000112AA                            	; Patch $20
000112AA                            	; $11
000112AA                            	; $01, $75, $64, $31,	$1F, $9F, $5F, $9F
000112AA                            	; $04, $88, $06, $01,	$02, $02, $02, $02
000112AA                            	; $81, $31, $51, $6A,	$08, $12, $16, $05
000112AA                            	spAlgorithm	$01
000112AA =00000021                M spatnum	=	spatnum+1
000112AA =00000001                M spal	=	val
000112AA                            	spFeedback	$02
000112AA =00000002                M spfe	=	val
000112AA                            	spDetune	$00, $06, $07, $03
000112AA =00000000                M spde1	=	op1
000112AA =00000006                M spde2	=	op2
000112AA =00000007                M spde3	=	op3
000112AA =00000003                M spde4	=	op4
000112AA                            	spMultiple	$01, $04, $05, $01
000112AA =00000001                M spmu1	=	op1
000112AA =00000004                M spmu2	=	op2
000112AA =00000005                M spmu3	=	op3
000112AA =00000001                M spmu4	=	op4
000112AA                            	spRateScale	$00, $01, $02, $02
000112AA =00000000                M sprs1	=	op1
000112AA =00000001                M sprs2	=	op2
000112AA =00000002                M sprs3	=	op3
000112AA =00000002                M sprs4	=	op4
000112AA                            	spAttackRt	$1F, $1F, $1F, $1F
000112AA =0000001F                M spar1	=	op1
000112AA =0000001F                M spar2	=	op2
000112AA =0000001F                M spar3	=	op3
000112AA =0000001F                M spar4	=	op4
000112AA                            	spAmpMod	$00, $00, $01, $00
000112AA =00000000                M spam1	=	op1
000112AA =00000000                M spam2	=	op2
000112AA =00000001                M spam3	=	op3
000112AA =00000000                M spam4	=	op4
000112AA                            	spSustainRt	$04, $06, $08, $01
000112AA =00000004                M spsr1	=	op1
000112AA =00000006                M spsr2	=	op2
000112AA =00000008                M spsr3	=	op3
000112AA =00000001                M spsr4	=	op4
000112AA                            	spDecayRt	$02, $02, $02, $02
000112AA =00000002                M spdr1	=	op1
000112AA =00000002                M spdr2	=	op2
000112AA =00000002                M spdr3	=	op3
000112AA =00000002                M spdr4	=	op4
000112AA                            	spSustainLv	$08, $05, $03, $06
000112AA =00000008                M spsl1	=	op1
000112AA =00000005                M spsl2	=	op2
000112AA =00000003                M spsl3	=	op3
000112AA =00000006                M spsl4	=	op4
000112AA                            	spReleaseRt	$01, $01, $01, $0A
000112AA =00000001                M sprr1	=	op1
000112AA =00000001                M sprr2	=	op2
000112AA =00000001                M sprr3	=	op3
000112AA =0000000A                M sprr4	=	op4
000112AA                            	spSSGEG		$00, $00, $00, $00
000112AA =00000000                M spss1	=	op1
000112AA =00000000                M spss2	=	op2
000112AA =00000000                M spss3	=	op3
000112AA =00000000                M spss4	=	op4
000112AA                            	spTotalLv	$08, $16, $12, $05
000112AA =00000008                M sptl1	=	op1
000112AA =00000016                M sptl2	=	op2
000112AA =00000012                M sptl3	=	op3
000112AA =00000005                M sptl4	=	op4
000112AA 11                       M 	dc.b	(spfe<<3)+spal
000112AB =00000080                M sptlmask4	set	$80
000112AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000112AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000112AB =00000000                M sptlmask1	set	((spal=7)<<7)
000112AB 0175 6431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112AF 1F9F 5F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112B3 0488 0601                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112B7 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112BB 8131 516A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112C3 0812 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112C7 4E41 54                  M 	dc.b	'NAT'
000112CA                            
000112CA                            	; Patch $21
000112CA                            	; $22
000112CA                            	; $50, $05, $10, $00,	$D8, $DD, $DD, $9F
000112CA                            	; $04, $05, $08, $0B,	$00, $00, $00, $06
000112CA                            	; $FC, $FF, $FC, $FF,	$14, $16, $2B, $02
000112CA                            	spAlgorithm	$02
000112CA =00000022                M spatnum	=	spatnum+1
000112CA =00000002                M spal	=	val
000112CA                            	spFeedback	$04
000112CA =00000004                M spfe	=	val
000112CA                            	spDetune	$05, $01, $00, $00
000112CA =00000005                M spde1	=	op1
000112CA =00000001                M spde2	=	op2
000112CA =00000000                M spde3	=	op3
000112CA =00000000                M spde4	=	op4
000112CA                            	spMultiple	$00, $00, $05, $00
000112CA =00000000                M spmu1	=	op1
000112CA =00000000                M spmu2	=	op2
000112CA =00000005                M spmu3	=	op3
000112CA =00000000                M spmu4	=	op4
000112CA                            	spRateScale	$03, $03, $03, $02
000112CA =00000003                M sprs1	=	op1
000112CA =00000003                M sprs2	=	op2
000112CA =00000003                M sprs3	=	op3
000112CA =00000002                M sprs4	=	op4
000112CA                            	spAttackRt	$18, $1D, $1D, $1F
000112CA =00000018                M spar1	=	op1
000112CA =0000001D                M spar2	=	op2
000112CA =0000001D                M spar3	=	op3
000112CA =0000001F                M spar4	=	op4
000112CA                            	spAmpMod	$00, $00, $00, $00
000112CA =00000000                M spam1	=	op1
000112CA =00000000                M spam2	=	op2
000112CA =00000000                M spam3	=	op3
000112CA =00000000                M spam4	=	op4
000112CA                            	spSustainRt	$04, $08, $05, $0B
000112CA =00000004                M spsr1	=	op1
000112CA =00000008                M spsr2	=	op2
000112CA =00000005                M spsr3	=	op3
000112CA =0000000B                M spsr4	=	op4
000112CA                            	spDecayRt	$00, $00, $00, $06
000112CA =00000000                M spdr1	=	op1
000112CA =00000000                M spdr2	=	op2
000112CA =00000000                M spdr3	=	op3
000112CA =00000006                M spdr4	=	op4
000112CA                            	spSustainLv	$0F, $0F, $0F, $0F
000112CA =0000000F                M spsl1	=	op1
000112CA =0000000F                M spsl2	=	op2
000112CA =0000000F                M spsl3	=	op3
000112CA =0000000F                M spsl4	=	op4
000112CA                            	spReleaseRt	$0C, $0C, $0F, $0F
000112CA =0000000C                M sprr1	=	op1
000112CA =0000000C                M sprr2	=	op2
000112CA =0000000F                M sprr3	=	op3
000112CA =0000000F                M sprr4	=	op4
000112CA                            	spSSGEG		$00, $00, $00, $00
000112CA =00000000                M spss1	=	op1
000112CA =00000000                M spss2	=	op2
000112CA =00000000                M spss3	=	op3
000112CA =00000000                M spss4	=	op4
000112CA                            	spTotalLv	$14, $2B, $16, $02
000112CA =00000014                M sptl1	=	op1
000112CA =0000002B                M sptl2	=	op2
000112CA =00000016                M sptl3	=	op3
000112CA =00000002                M sptl4	=	op4
000112CA 22                       M 	dc.b	(spfe<<3)+spal
000112CB =00000080                M sptlmask4	set	$80
000112CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000112CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000112CB =00000000                M sptlmask1	set	((spal=7)<<7)
000112CB 5005 1000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112CF D8DD DD9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112D3 0405 080B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112D7 0000 0006                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112DB FCFF FCFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112E3 1416 2B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112E7 4E41 54                  M 	dc.b	'NAT'
000112EA                            
000112EA                            	; Patch $22
000112EA                            	; $35
000112EA                            	; $01, $00, $72, $31,	$9F, $14, $52, $52
000112EA                            	; $0A, $8A, $8A, $0A,	$09, $0E, $0F, $10
000112EA                            	; $11, $26, $26, $26,	$0F, $08, $05, $05
000112EA                            	spAlgorithm	$05
000112EA =00000023                M spatnum	=	spatnum+1
000112EA =00000005                M spal	=	val
000112EA                            	spFeedback	$06
000112EA =00000006                M spfe	=	val
000112EA                            	spDetune	$00, $07, $00, $03
000112EA =00000000                M spde1	=	op1
000112EA =00000007                M spde2	=	op2
000112EA =00000000                M spde3	=	op3
000112EA =00000003                M spde4	=	op4
000112EA                            	spMultiple	$01, $02, $00, $01
000112EA =00000001                M spmu1	=	op1
000112EA =00000002                M spmu2	=	op2
000112EA =00000000                M spmu3	=	op3
000112EA =00000001                M spmu4	=	op4
000112EA                            	spRateScale	$02, $01, $00, $01
000112EA =00000002                M sprs1	=	op1
000112EA =00000001                M sprs2	=	op2
000112EA =00000000                M sprs3	=	op3
000112EA =00000001                M sprs4	=	op4
000112EA                            	spAttackRt	$1F, $12, $14, $12
000112EA =0000001F                M spar1	=	op1
000112EA =00000012                M spar2	=	op2
000112EA =00000014                M spar3	=	op3
000112EA =00000012                M spar4	=	op4
000112EA                            	spAmpMod	$00, $01, $01, $00
000112EA =00000000                M spam1	=	op1
000112EA =00000001                M spam2	=	op2
000112EA =00000001                M spam3	=	op3
000112EA =00000000                M spam4	=	op4
000112EA                            	spSustainRt	$0A, $0A, $0A, $0A
000112EA =0000000A                M spsr1	=	op1
000112EA =0000000A                M spsr2	=	op2
000112EA =0000000A                M spsr3	=	op3
000112EA =0000000A                M spsr4	=	op4
000112EA                            	spDecayRt	$09, $0F, $0E, $10
000112EA =00000009                M spdr1	=	op1
000112EA =0000000F                M spdr2	=	op2
000112EA =0000000E                M spdr3	=	op3
000112EA =00000010                M spdr4	=	op4
000112EA                            	spSustainLv	$01, $02, $02, $02
000112EA =00000001                M spsl1	=	op1
000112EA =00000002                M spsl2	=	op2
000112EA =00000002                M spsl3	=	op3
000112EA =00000002                M spsl4	=	op4
000112EA                            	spReleaseRt	$01, $06, $06, $06
000112EA =00000001                M sprr1	=	op1
000112EA =00000006                M sprr2	=	op2
000112EA =00000006                M sprr3	=	op3
000112EA =00000006                M sprr4	=	op4
000112EA                            	spSSGEG		$00, $00, $00, $00
000112EA =00000000                M spss1	=	op1
000112EA =00000000                M spss2	=	op2
000112EA =00000000                M spss3	=	op3
000112EA =00000000                M spss4	=	op4
000112EA                            	spTotalLv	$0F, $05, $08, $05
000112EA =0000000F                M sptl1	=	op1
000112EA =00000005                M sptl2	=	op2
000112EA =00000008                M sptl3	=	op3
000112EA =00000005                M sptl4	=	op4
000112EA 35                       M 	dc.b	(spfe<<3)+spal
000112EB =00000080                M sptlmask4	set	$80
000112EB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000112EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000112EB =00000000                M sptlmask1	set	((spal=7)<<7)
000112EB 0100 7231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112EF 9F14 5252                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112F3 0A8A 8A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112F7 090E 0F10                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112FB 1126 2626                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011303 0F88 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011307 4E41 54                  M 	dc.b	'NAT'
0001130A                            
0001130A                            	; Patch $23
0001130A                            	; $0D
0001130A                            	; $50, $02, $14, $00,	$9D, $5E, $9D, $5C
0001130A                            	; $8C, $09, $8B, $02,	$00, $00, $09, $00
0001130A                            	; $FF, $FF, $FF, $FF,	$0C, $10, $0B, $05
0001130A                            	spAlgorithm	$05
0001130A =00000024                M spatnum	=	spatnum+1
0001130A =00000005                M spal	=	val
0001130A                            	spFeedback	$01
0001130A =00000001                M spfe	=	val
0001130A                            	spDetune	$05, $01, $00, $00
0001130A =00000005                M spde1	=	op1
0001130A =00000001                M spde2	=	op2
0001130A =00000000                M spde3	=	op3
0001130A =00000000                M spde4	=	op4
0001130A                            	spMultiple	$00, $04, $02, $00
0001130A =00000000                M spmu1	=	op1
0001130A =00000004                M spmu2	=	op2
0001130A =00000002                M spmu3	=	op3
0001130A =00000000                M spmu4	=	op4
0001130A                            	spRateScale	$02, $02, $01, $01
0001130A =00000002                M sprs1	=	op1
0001130A =00000002                M sprs2	=	op2
0001130A =00000001                M sprs3	=	op3
0001130A =00000001                M sprs4	=	op4
0001130A                            	spAttackRt	$1D, $1D, $1E, $1C
0001130A =0000001D                M spar1	=	op1
0001130A =0000001D                M spar2	=	op2
0001130A =0000001E                M spar3	=	op3
0001130A =0000001C                M spar4	=	op4
0001130A                            	spAmpMod	$01, $01, $00, $00
0001130A =00000001                M spam1	=	op1
0001130A =00000001                M spam2	=	op2
0001130A =00000000                M spam3	=	op3
0001130A =00000000                M spam4	=	op4
0001130A                            	spSustainRt	$0C, $0B, $09, $02
0001130A =0000000C                M spsr1	=	op1
0001130A =0000000B                M spsr2	=	op2
0001130A =00000009                M spsr3	=	op3
0001130A =00000002                M spsr4	=	op4
0001130A                            	spDecayRt	$00, $09, $00, $00
0001130A =00000000                M spdr1	=	op1
0001130A =00000009                M spdr2	=	op2
0001130A =00000000                M spdr3	=	op3
0001130A =00000000                M spdr4	=	op4
0001130A                            	spSustainLv	$0F, $0F, $0F, $0F
0001130A =0000000F                M spsl1	=	op1
0001130A =0000000F                M spsl2	=	op2
0001130A =0000000F                M spsl3	=	op3
0001130A =0000000F                M spsl4	=	op4
0001130A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001130A =0000000F                M sprr1	=	op1
0001130A =0000000F                M sprr2	=	op2
0001130A =0000000F                M sprr3	=	op3
0001130A =0000000F                M sprr4	=	op4
0001130A                            	spSSGEG		$00, $00, $00, $00
0001130A =00000000                M spss1	=	op1
0001130A =00000000                M spss2	=	op2
0001130A =00000000                M spss3	=	op3
0001130A =00000000                M spss4	=	op4
0001130A                            	spTotalLv	$0C, $0B, $10, $05
0001130A =0000000C                M sptl1	=	op1
0001130A =0000000B                M sptl2	=	op2
0001130A =00000010                M sptl3	=	op3
0001130A =00000005                M sptl4	=	op4
0001130A 0D                       M 	dc.b	(spfe<<3)+spal
0001130B =00000080                M sptlmask4	set	$80
0001130B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001130B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001130B =00000000                M sptlmask1	set	((spal=7)<<7)
0001130B 5002 1400                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001130F 9D5E 9D5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011313 8C09 8B02                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011317 0000 0900                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001131B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001131F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011323 0C90 8B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011327 4E41 54                  M 	dc.b	'NAT'
0001132A                            
0001132A                            	; Patch $24
0001132A                            	; $35
0001132A                            	; $30, $01, $70, $30,	$5F, $57, $56, $5F
0001132A                            	; $19, $0A, $0A, $0A,	$0F, $0F, $0F, $0F
0001132A                            	; $05, $35, $35, $35,	$13, $05, $05, $05
0001132A                            	spAlgorithm	$05
0001132A =00000025                M spatnum	=	spatnum+1
0001132A =00000005                M spal	=	val
0001132A                            	spFeedback	$06
0001132A =00000006                M spfe	=	val
0001132A                            	spDetune	$03, $07, $00, $03
0001132A =00000003                M spde1	=	op1
0001132A =00000007                M spde2	=	op2
0001132A =00000000                M spde3	=	op3
0001132A =00000003                M spde4	=	op4
0001132A                            	spMultiple	$00, $00, $01, $00
0001132A =00000000                M spmu1	=	op1
0001132A =00000000                M spmu2	=	op2
0001132A =00000001                M spmu3	=	op3
0001132A =00000000                M spmu4	=	op4
0001132A                            	spRateScale	$01, $01, $01, $01
0001132A =00000001                M sprs1	=	op1
0001132A =00000001                M sprs2	=	op2
0001132A =00000001                M sprs3	=	op3
0001132A =00000001                M sprs4	=	op4
0001132A                            	spAttackRt	$1F, $16, $17, $1F
0001132A =0000001F                M spar1	=	op1
0001132A =00000016                M spar2	=	op2
0001132A =00000017                M spar3	=	op3
0001132A =0000001F                M spar4	=	op4
0001132A                            	spAmpMod	$00, $00, $00, $00
0001132A =00000000                M spam1	=	op1
0001132A =00000000                M spam2	=	op2
0001132A =00000000                M spam3	=	op3
0001132A =00000000                M spam4	=	op4
0001132A                            	spSustainRt	$19, $0A, $0A, $0A
0001132A =00000019                M spsr1	=	op1
0001132A =0000000A                M spsr2	=	op2
0001132A =0000000A                M spsr3	=	op3
0001132A =0000000A                M spsr4	=	op4
0001132A                            	spDecayRt	$0F, $0F, $0F, $0F
0001132A =0000000F                M spdr1	=	op1
0001132A =0000000F                M spdr2	=	op2
0001132A =0000000F                M spdr3	=	op3
0001132A =0000000F                M spdr4	=	op4
0001132A                            	spSustainLv	$00, $03, $03, $03
0001132A =00000000                M spsl1	=	op1
0001132A =00000003                M spsl2	=	op2
0001132A =00000003                M spsl3	=	op3
0001132A =00000003                M spsl4	=	op4
0001132A                            	spReleaseRt	$05, $05, $05, $05
0001132A =00000005                M sprr1	=	op1
0001132A =00000005                M sprr2	=	op2
0001132A =00000005                M sprr3	=	op3
0001132A =00000005                M sprr4	=	op4
0001132A                            	spSSGEG		$00, $00, $00, $00
0001132A =00000000                M spss1	=	op1
0001132A =00000000                M spss2	=	op2
0001132A =00000000                M spss3	=	op3
0001132A =00000000                M spss4	=	op4
0001132A                            	spTotalLv	$13, $05, $05, $05
0001132A =00000013                M sptl1	=	op1
0001132A =00000005                M sptl2	=	op2
0001132A =00000005                M sptl3	=	op3
0001132A =00000005                M sptl4	=	op4
0001132A 35                       M 	dc.b	(spfe<<3)+spal
0001132B =00000080                M sptlmask4	set	$80
0001132B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001132B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001132B =00000000                M sptlmask1	set	((spal=7)<<7)
0001132B 3001 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001132F 5F57 565F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011333 190A 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011337 0F0F 0F0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001133B 0535 3535                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001133F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011343 1385 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011347 4E41 54                  M 	dc.b	'NAT'
0001134A                            
0001134A                            	; Patch $25
0001134A                            	; $3B
0001134A                            	; $00, $01, $00, $03,	$1F, $1F, $16, $14
0001134A                            	; $03, $02, $02, $00,	$02, $02, $02, $1F
0001134A                            	; $22, $14, $13, $15,	$0E, $04, $23, $04
0001134A                            	spAlgorithm	$03
0001134A =00000026                M spatnum	=	spatnum+1
0001134A =00000003                M spal	=	val
0001134A                            	spFeedback	$07
0001134A =00000007                M spfe	=	val
0001134A                            	spDetune	$00, $00, $00, $00
0001134A =00000000                M spde1	=	op1
0001134A =00000000                M spde2	=	op2
0001134A =00000000                M spde3	=	op3
0001134A =00000000                M spde4	=	op4
0001134A                            	spMultiple	$00, $00, $01, $03
0001134A =00000000                M spmu1	=	op1
0001134A =00000000                M spmu2	=	op2
0001134A =00000001                M spmu3	=	op3
0001134A =00000003                M spmu4	=	op4
0001134A                            	spRateScale	$00, $00, $00, $00
0001134A =00000000                M sprs1	=	op1
0001134A =00000000                M sprs2	=	op2
0001134A =00000000                M sprs3	=	op3
0001134A =00000000                M sprs4	=	op4
0001134A                            	spAttackRt	$1F, $16, $1F, $14
0001134A =0000001F                M spar1	=	op1
0001134A =00000016                M spar2	=	op2
0001134A =0000001F                M spar3	=	op3
0001134A =00000014                M spar4	=	op4
0001134A                            	spAmpMod	$00, $00, $00, $00
0001134A =00000000                M spam1	=	op1
0001134A =00000000                M spam2	=	op2
0001134A =00000000                M spam3	=	op3
0001134A =00000000                M spam4	=	op4
0001134A                            	spSustainRt	$03, $02, $02, $00
0001134A =00000003                M spsr1	=	op1
0001134A =00000002                M spsr2	=	op2
0001134A =00000002                M spsr3	=	op3
0001134A =00000000                M spsr4	=	op4
0001134A                            	spDecayRt	$02, $02, $02, $1F
0001134A =00000002                M spdr1	=	op1
0001134A =00000002                M spdr2	=	op2
0001134A =00000002                M spdr3	=	op3
0001134A =0000001F                M spdr4	=	op4
0001134A                            	spSustainLv	$02, $01, $01, $01
0001134A =00000002                M spsl1	=	op1
0001134A =00000001                M spsl2	=	op2
0001134A =00000001                M spsl3	=	op3
0001134A =00000001                M spsl4	=	op4
0001134A                            	spReleaseRt	$02, $03, $04, $05
0001134A =00000002                M sprr1	=	op1
0001134A =00000003                M sprr2	=	op2
0001134A =00000004                M sprr3	=	op3
0001134A =00000005                M sprr4	=	op4
0001134A                            	spSSGEG		$00, $00, $00, $00
0001134A =00000000                M spss1	=	op1
0001134A =00000000                M spss2	=	op2
0001134A =00000000                M spss3	=	op3
0001134A =00000000                M spss4	=	op4
0001134A                            	spTotalLv	$0E, $23, $04, $04
0001134A =0000000E                M sptl1	=	op1
0001134A =00000023                M sptl2	=	op2
0001134A =00000004                M sptl3	=	op3
0001134A =00000004                M sptl4	=	op4
0001134A 3B                       M 	dc.b	(spfe<<3)+spal
0001134B =00000080                M sptlmask4	set	$80
0001134B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001134B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001134B =00000000                M sptlmask1	set	((spal=7)<<7)
0001134B 0001 0003                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001134F 1F1F 1614                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011353 0302 0200                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011357 0202 021F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001135B 2214 1315                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001135F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011363 0E04 2384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011367 4E41 54                  M 	dc.b	'NAT'
0001136A                            
0001136A                            	; Patch $26
0001136A                            	; $3B
0001136A                            	; $30, $50, $33, $10,	$59, $55, $19, $1A
0001136A                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $03
0001136A                            	; $7E, $17, $27, $17,	$0F, $00, $0D, $05
0001136A                            	spAlgorithm	$03
0001136A =00000027                M spatnum	=	spatnum+1
0001136A =00000003                M spal	=	val
0001136A                            	spFeedback	$07
0001136A =00000007                M spfe	=	val
0001136A                            	spDetune	$03, $03, $05, $01
0001136A =00000003                M spde1	=	op1
0001136A =00000003                M spde2	=	op2
0001136A =00000005                M spde3	=	op3
0001136A =00000001                M spde4	=	op4
0001136A                            	spMultiple	$00, $03, $00, $00
0001136A =00000000                M spmu1	=	op1
0001136A =00000003                M spmu2	=	op2
0001136A =00000000                M spmu3	=	op3
0001136A =00000000                M spmu4	=	op4
0001136A                            	spRateScale	$01, $00, $01, $00
0001136A =00000001                M sprs1	=	op1
0001136A =00000000                M sprs2	=	op2
0001136A =00000001                M sprs3	=	op3
0001136A =00000000                M sprs4	=	op4
0001136A                            	spAttackRt	$19, $19, $15, $1A
0001136A =00000019                M spar1	=	op1
0001136A =00000019                M spar2	=	op2
0001136A =00000015                M spar3	=	op3
0001136A =0000001A                M spar4	=	op4
0001136A                            	spAmpMod	$00, $00, $00, $00
0001136A =00000000                M spam1	=	op1
0001136A =00000000                M spam2	=	op2
0001136A =00000000                M spam3	=	op3
0001136A =00000000                M spam4	=	op4
0001136A                            	spSustainRt	$00, $00, $00, $00
0001136A =00000000                M spsr1	=	op1
0001136A =00000000                M spsr2	=	op2
0001136A =00000000                M spsr3	=	op3
0001136A =00000000                M spsr4	=	op4
0001136A                            	spDecayRt	$1F, $1F, $1F, $03
0001136A =0000001F                M spdr1	=	op1
0001136A =0000001F                M spdr2	=	op2
0001136A =0000001F                M spdr3	=	op3
0001136A =00000003                M spdr4	=	op4
0001136A                            	spSustainLv	$07, $02, $01, $01
0001136A =00000007                M spsl1	=	op1
0001136A =00000002                M spsl2	=	op2
0001136A =00000001                M spsl3	=	op3
0001136A =00000001                M spsl4	=	op4
0001136A                            	spReleaseRt	$0E, $07, $07, $07
0001136A =0000000E                M sprr1	=	op1
0001136A =00000007                M sprr2	=	op2
0001136A =00000007                M sprr3	=	op3
0001136A =00000007                M sprr4	=	op4
0001136A                            	spSSGEG		$00, $00, $00, $00
0001136A =00000000                M spss1	=	op1
0001136A =00000000                M spss2	=	op2
0001136A =00000000                M spss3	=	op3
0001136A =00000000                M spss4	=	op4
0001136A                            	spTotalLv	$0F, $0D, $00, $05
0001136A =0000000F                M sptl1	=	op1
0001136A =0000000D                M sptl2	=	op2
0001136A =00000000                M sptl3	=	op3
0001136A =00000005                M sptl4	=	op4
0001136A 3B                       M 	dc.b	(spfe<<3)+spal
0001136B =00000080                M sptlmask4	set	$80
0001136B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001136B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001136B =00000000                M sptlmask1	set	((spal=7)<<7)
0001136B 3050 3310                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001136F 5955 191A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011373 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011377 1F1F 1F03                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001137B 7E17 2717                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001137F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011383 0F00 0D85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011387 4E41 54                  M 	dc.b	'NAT'
0001138A                            
0001138A                            	; Patch $27
0001138A                            	; $35
0001138A                            	; $21, $31, $20, $14,	$8E, $9B, $95, $94
0001138A                            	; $00, $05, $00, $80,	$01, $02, $02, $02
0001138A                            	; $4F, $3F, $1F, $0F,	$16, $06, $08, $05
0001138A                            	spAlgorithm	$05
0001138A =00000028                M spatnum	=	spatnum+1
0001138A =00000005                M spal	=	val
0001138A                            	spFeedback	$06
0001138A =00000006                M spfe	=	val
0001138A                            	spDetune	$02, $02, $03, $01
0001138A =00000002                M spde1	=	op1
0001138A =00000002                M spde2	=	op2
0001138A =00000003                M spde3	=	op3
0001138A =00000001                M spde4	=	op4
0001138A                            	spMultiple	$01, $00, $01, $04
0001138A =00000001                M spmu1	=	op1
0001138A =00000000                M spmu2	=	op2
0001138A =00000001                M spmu3	=	op3
0001138A =00000004                M spmu4	=	op4
0001138A                            	spRateScale	$02, $02, $02, $02
0001138A =00000002                M sprs1	=	op1
0001138A =00000002                M sprs2	=	op2
0001138A =00000002                M sprs3	=	op3
0001138A =00000002                M sprs4	=	op4
0001138A                            	spAttackRt	$0E, $15, $1B, $14
0001138A =0000000E                M spar1	=	op1
0001138A =00000015                M spar2	=	op2
0001138A =0000001B                M spar3	=	op3
0001138A =00000014                M spar4	=	op4
0001138A                            	spAmpMod	$00, $00, $00, $01
0001138A =00000000                M spam1	=	op1
0001138A =00000000                M spam2	=	op2
0001138A =00000000                M spam3	=	op3
0001138A =00000001                M spam4	=	op4
0001138A                            	spSustainRt	$00, $00, $05, $00
0001138A =00000000                M spsr1	=	op1
0001138A =00000000                M spsr2	=	op2
0001138A =00000005                M spsr3	=	op3
0001138A =00000000                M spsr4	=	op4
0001138A                            	spDecayRt	$01, $02, $02, $02
0001138A =00000001                M spdr1	=	op1
0001138A =00000002                M spdr2	=	op2
0001138A =00000002                M spdr3	=	op3
0001138A =00000002                M spdr4	=	op4
0001138A                            	spSustainLv	$04, $01, $03, $00
0001138A =00000004                M spsl1	=	op1
0001138A =00000001                M spsl2	=	op2
0001138A =00000003                M spsl3	=	op3
0001138A =00000000                M spsl4	=	op4
0001138A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001138A =0000000F                M sprr1	=	op1
0001138A =0000000F                M sprr2	=	op2
0001138A =0000000F                M sprr3	=	op3
0001138A =0000000F                M sprr4	=	op4
0001138A                            	spSSGEG		$00, $00, $00, $00
0001138A =00000000                M spss1	=	op1
0001138A =00000000                M spss2	=	op2
0001138A =00000000                M spss3	=	op3
0001138A =00000000                M spss4	=	op4
0001138A                            	spTotalLv	$16, $08, $06, $05
0001138A =00000016                M sptl1	=	op1
0001138A =00000008                M sptl2	=	op2
0001138A =00000006                M sptl3	=	op3
0001138A =00000005                M sptl4	=	op4
0001138A 35                       M 	dc.b	(spfe<<3)+spal
0001138B =00000080                M sptlmask4	set	$80
0001138B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001138B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001138B =00000000                M sptlmask1	set	((spal=7)<<7)
0001138B 2131 2014                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001138F 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011393 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011397 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001139B 4F3F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001139F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113A3 1686 8885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113A7 4E41 54                  M 	dc.b	'NAT'
000113AA                            
000113AA                            	; Patch $28
000113AA                            	; $24
000113AA                            	; $01, $33, $00, $00,	$12, $0A, $0D, $0C
000113AA                            	; $00, $8F, $03, $0F,	$00, $00, $00, $00
000113AA                            	; $4F, $1F, $1F, $1F,	$03, $05, $10, $05
000113AA                            	spAlgorithm	$04
000113AA =00000029                M spatnum	=	spatnum+1
000113AA =00000004                M spal	=	val
000113AA                            	spFeedback	$04
000113AA =00000004                M spfe	=	val
000113AA                            	spDetune	$00, $00, $03, $00
000113AA =00000000                M spde1	=	op1
000113AA =00000000                M spde2	=	op2
000113AA =00000003                M spde3	=	op3
000113AA =00000000                M spde4	=	op4
000113AA                            	spMultiple	$01, $00, $03, $00
000113AA =00000001                M spmu1	=	op1
000113AA =00000000                M spmu2	=	op2
000113AA =00000003                M spmu3	=	op3
000113AA =00000000                M spmu4	=	op4
000113AA                            	spRateScale	$00, $00, $00, $00
000113AA =00000000                M sprs1	=	op1
000113AA =00000000                M sprs2	=	op2
000113AA =00000000                M sprs3	=	op3
000113AA =00000000                M sprs4	=	op4
000113AA                            	spAttackRt	$12, $0D, $0A, $0C
000113AA =00000012                M spar1	=	op1
000113AA =0000000D                M spar2	=	op2
000113AA =0000000A                M spar3	=	op3
000113AA =0000000C                M spar4	=	op4
000113AA                            	spAmpMod	$00, $00, $01, $00
000113AA =00000000                M spam1	=	op1
000113AA =00000000                M spam2	=	op2
000113AA =00000001                M spam3	=	op3
000113AA =00000000                M spam4	=	op4
000113AA                            	spSustainRt	$00, $03, $0F, $0F
000113AA =00000000                M spsr1	=	op1
000113AA =00000003                M spsr2	=	op2
000113AA =0000000F                M spsr3	=	op3
000113AA =0000000F                M spsr4	=	op4
000113AA                            	spDecayRt	$00, $00, $00, $00
000113AA =00000000                M spdr1	=	op1
000113AA =00000000                M spdr2	=	op2
000113AA =00000000                M spdr3	=	op3
000113AA =00000000                M spdr4	=	op4
000113AA                            	spSustainLv	$04, $01, $01, $01
000113AA =00000004                M spsl1	=	op1
000113AA =00000001                M spsl2	=	op2
000113AA =00000001                M spsl3	=	op3
000113AA =00000001                M spsl4	=	op4
000113AA                            	spReleaseRt	$0F, $0F, $0F, $0F
000113AA =0000000F                M sprr1	=	op1
000113AA =0000000F                M sprr2	=	op2
000113AA =0000000F                M sprr3	=	op3
000113AA =0000000F                M sprr4	=	op4
000113AA                            	spSSGEG		$00, $00, $00, $00
000113AA =00000000                M spss1	=	op1
000113AA =00000000                M spss2	=	op2
000113AA =00000000                M spss3	=	op3
000113AA =00000000                M spss4	=	op4
000113AA                            	spTotalLv	$03, $10, $05, $05
000113AA =00000003                M sptl1	=	op1
000113AA =00000010                M sptl2	=	op2
000113AA =00000005                M sptl3	=	op3
000113AA =00000005                M sptl4	=	op4
000113AA 24                       M 	dc.b	(spfe<<3)+spal
000113AB =00000080                M sptlmask4	set	$80
000113AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113AB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000113AB =00000000                M sptlmask1	set	((spal=7)<<7)
000113AB 0133 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113AF 120A 0D0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113B3 008F 030F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113B7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113BB 4F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113C3 0385 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113C7 4E41 54                  M 	dc.b	'NAT'
000113CA                            
000113CA                            	; Patch $29
000113CA                            	; $29
000113CA                            	; $33, $50, $02, $25,	$9D, $56, $13, $5E
000113CA                            	; $01, $01, $00, $01,	$15, $0F, $0C, $0F
000113CA                            	; $4F, $3F, $3F, $3F,	$13, $10, $1B, $05
000113CA                            	spAlgorithm	$01
000113CA =0000002A                M spatnum	=	spatnum+1
000113CA =00000001                M spal	=	val
000113CA                            	spFeedback	$05
000113CA =00000005                M spfe	=	val
000113CA                            	spDetune	$03, $00, $05, $02
000113CA =00000003                M spde1	=	op1
000113CA =00000000                M spde2	=	op2
000113CA =00000005                M spde3	=	op3
000113CA =00000002                M spde4	=	op4
000113CA                            	spMultiple	$03, $02, $00, $05
000113CA =00000003                M spmu1	=	op1
000113CA =00000002                M spmu2	=	op2
000113CA =00000000                M spmu3	=	op3
000113CA =00000005                M spmu4	=	op4
000113CA                            	spRateScale	$02, $00, $01, $01
000113CA =00000002                M sprs1	=	op1
000113CA =00000000                M sprs2	=	op2
000113CA =00000001                M sprs3	=	op3
000113CA =00000001                M sprs4	=	op4
000113CA                            	spAttackRt	$1D, $13, $16, $1E
000113CA =0000001D                M spar1	=	op1
000113CA =00000013                M spar2	=	op2
000113CA =00000016                M spar3	=	op3
000113CA =0000001E                M spar4	=	op4
000113CA                            	spAmpMod	$00, $00, $00, $00
000113CA =00000000                M spam1	=	op1
000113CA =00000000                M spam2	=	op2
000113CA =00000000                M spam3	=	op3
000113CA =00000000                M spam4	=	op4
000113CA                            	spSustainRt	$01, $00, $01, $01
000113CA =00000001                M spsr1	=	op1
000113CA =00000000                M spsr2	=	op2
000113CA =00000001                M spsr3	=	op3
000113CA =00000001                M spsr4	=	op4
000113CA                            	spDecayRt	$15, $0C, $0F, $0F
000113CA =00000015                M spdr1	=	op1
000113CA =0000000C                M spdr2	=	op2
000113CA =0000000F                M spdr3	=	op3
000113CA =0000000F                M spdr4	=	op4
000113CA                            	spSustainLv	$04, $03, $03, $03
000113CA =00000004                M spsl1	=	op1
000113CA =00000003                M spsl2	=	op2
000113CA =00000003                M spsl3	=	op3
000113CA =00000003                M spsl4	=	op4
000113CA                            	spReleaseRt	$0F, $0F, $0F, $0F
000113CA =0000000F                M sprr1	=	op1
000113CA =0000000F                M sprr2	=	op2
000113CA =0000000F                M sprr3	=	op3
000113CA =0000000F                M sprr4	=	op4
000113CA                            	spSSGEG		$00, $00, $00, $00
000113CA =00000000                M spss1	=	op1
000113CA =00000000                M spss2	=	op2
000113CA =00000000                M spss3	=	op3
000113CA =00000000                M spss4	=	op4
000113CA                            	spTotalLv	$13, $1B, $10, $05
000113CA =00000013                M sptl1	=	op1
000113CA =0000001B                M sptl2	=	op2
000113CA =00000010                M sptl3	=	op3
000113CA =00000005                M sptl4	=	op4
000113CA 29                       M 	dc.b	(spfe<<3)+spal
000113CB =00000080                M sptlmask4	set	$80
000113CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000113CB =00000000                M sptlmask1	set	((spal=7)<<7)
000113CB 3350 0225                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113CF 9D56 135E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113D3 0101 0001                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113D7 150F 0C0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113DB 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113E3 1310 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113E7 4E41 54                  M 	dc.b	'NAT'
000113EA                            
000113EA                            	; Patch $2A
000113EA                            	; $2B
000113EA                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
000113EA                            	; $80, $80, $80, $85,	$01, $17, $12, $0A
000113EA                            	; $AA, $AF, $F9, $FC,	$0F, $12, $46, $05
000113EA                            	spAlgorithm	$03
000113EA =0000002B                M spatnum	=	spatnum+1
000113EA =00000003                M spal	=	val
000113EA                            	spFeedback	$05
000113EA =00000005                M spfe	=	val
000113EA                            	spDetune	$03, $03, $03, $03
000113EA =00000003                M spde1	=	op1
000113EA =00000003                M spde2	=	op2
000113EA =00000003                M spde3	=	op3
000113EA =00000003                M spde4	=	op4
000113EA                            	spMultiple	$01, $05, $02, $01
000113EA =00000001                M spmu1	=	op1
000113EA =00000005                M spmu2	=	op2
000113EA =00000002                M spmu3	=	op3
000113EA =00000001                M spmu4	=	op4
000113EA                            	spRateScale	$00, $02, $01, $01
000113EA =00000000                M sprs1	=	op1
000113EA =00000002                M sprs2	=	op2
000113EA =00000001                M sprs3	=	op3
000113EA =00000001                M sprs4	=	op4
000113EA                            	spAttackRt	$1F, $1E, $19, $1E
000113EA =0000001F                M spar1	=	op1
000113EA =0000001E                M spar2	=	op2
000113EA =00000019                M spar3	=	op3
000113EA =0000001E                M spar4	=	op4
000113EA                            	spAmpMod	$01, $01, $01, $01
000113EA =00000001                M spam1	=	op1
000113EA =00000001                M spam2	=	op2
000113EA =00000001                M spam3	=	op3
000113EA =00000001                M spam4	=	op4
000113EA                            	spSustainRt	$00, $00, $00, $05
000113EA =00000000                M spsr1	=	op1
000113EA =00000000                M spsr2	=	op2
000113EA =00000000                M spsr3	=	op3
000113EA =00000005                M spsr4	=	op4
000113EA                            	spDecayRt	$01, $12, $17, $0A
000113EA =00000001                M spdr1	=	op1
000113EA =00000012                M spdr2	=	op2
000113EA =00000017                M spdr3	=	op3
000113EA =0000000A                M spdr4	=	op4
000113EA                            	spSustainLv	$0A, $0F, $0A, $0F
000113EA =0000000A                M spsl1	=	op1
000113EA =0000000F                M spsl2	=	op2
000113EA =0000000A                M spsl3	=	op3
000113EA =0000000F                M spsl4	=	op4
000113EA                            	spReleaseRt	$0A, $09, $0F, $0C
000113EA =0000000A                M sprr1	=	op1
000113EA =00000009                M sprr2	=	op2
000113EA =0000000F                M sprr3	=	op3
000113EA =0000000C                M sprr4	=	op4
000113EA                            	spSSGEG		$00, $00, $00, $00
000113EA =00000000                M spss1	=	op1
000113EA =00000000                M spss2	=	op2
000113EA =00000000                M spss3	=	op3
000113EA =00000000                M spss4	=	op4
000113EA                            	spTotalLv	$0F, $46, $12, $05
000113EA =0000000F                M sptl1	=	op1
000113EA =00000046                M sptl2	=	op2
000113EA =00000012                M sptl3	=	op3
000113EA =00000005                M sptl4	=	op4
000113EA 2B                       M 	dc.b	(spfe<<3)+spal
000113EB =00000080                M sptlmask4	set	$80
000113EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113EB =00000000                M sptlmask3	set	((spal>=4)<<7)
000113EB =00000000                M sptlmask1	set	((spal=7)<<7)
000113EB 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113EF 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113F3 8080 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113F7 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113FB AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011403 0F12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011407 4E41 54                  M 	dc.b	'NAT'
0001140A                            
0001140A                            	; Patch $2B
0001140A                            	; $04
0001140A                            	; $70, $70, $30, $31,	$9F, $1F, $9F, $1F
0001140A                            	; $80, $80, $9F, $8E,	$00, $00, $12, $00
0001140A                            	; $09, $09, $09, $09,	$33, $05, $08, $05
0001140A                            	spAlgorithm	$04
0001140A =0000002C                M spatnum	=	spatnum+1
0001140A =00000004                M spal	=	val
0001140A                            	spFeedback	$00
0001140A =00000000                M spfe	=	val
0001140A                            	spDetune	$07, $03, $07, $03
0001140A =00000007                M spde1	=	op1
0001140A =00000003                M spde2	=	op2
0001140A =00000007                M spde3	=	op3
0001140A =00000003                M spde4	=	op4
0001140A                            	spMultiple	$00, $00, $00, $01
0001140A =00000000                M spmu1	=	op1
0001140A =00000000                M spmu2	=	op2
0001140A =00000000                M spmu3	=	op3
0001140A =00000001                M spmu4	=	op4
0001140A                            	spRateScale	$02, $02, $00, $00
0001140A =00000002                M sprs1	=	op1
0001140A =00000002                M sprs2	=	op2
0001140A =00000000                M sprs3	=	op3
0001140A =00000000                M sprs4	=	op4
0001140A                            	spAttackRt	$1F, $1F, $1F, $1F
0001140A =0000001F                M spar1	=	op1
0001140A =0000001F                M spar2	=	op2
0001140A =0000001F                M spar3	=	op3
0001140A =0000001F                M spar4	=	op4
0001140A                            	spAmpMod	$01, $01, $01, $01
0001140A =00000001                M spam1	=	op1
0001140A =00000001                M spam2	=	op2
0001140A =00000001                M spam3	=	op3
0001140A =00000001                M spam4	=	op4
0001140A                            	spSustainRt	$00, $1F, $00, $0E
0001140A =00000000                M spsr1	=	op1
0001140A =0000001F                M spsr2	=	op2
0001140A =00000000                M spsr3	=	op3
0001140A =0000000E                M spsr4	=	op4
0001140A                            	spDecayRt	$00, $12, $00, $00
0001140A =00000000                M spdr1	=	op1
0001140A =00000012                M spdr2	=	op2
0001140A =00000000                M spdr3	=	op3
0001140A =00000000                M spdr4	=	op4
0001140A                            	spSustainLv	$00, $00, $00, $00
0001140A =00000000                M spsl1	=	op1
0001140A =00000000                M spsl2	=	op2
0001140A =00000000                M spsl3	=	op3
0001140A =00000000                M spsl4	=	op4
0001140A                            	spReleaseRt	$09, $09, $09, $09
0001140A =00000009                M sprr1	=	op1
0001140A =00000009                M sprr2	=	op2
0001140A =00000009                M sprr3	=	op3
0001140A =00000009                M sprr4	=	op4
0001140A                            	spSSGEG		$00, $00, $00, $00
0001140A =00000000                M spss1	=	op1
0001140A =00000000                M spss2	=	op2
0001140A =00000000                M spss3	=	op3
0001140A =00000000                M spss4	=	op4
0001140A                            	spTotalLv	$33, $08, $05, $05
0001140A =00000033                M sptl1	=	op1
0001140A =00000008                M sptl2	=	op2
0001140A =00000005                M sptl3	=	op3
0001140A =00000005                M sptl4	=	op4
0001140A 04                       M 	dc.b	(spfe<<3)+spal
0001140B =00000080                M sptlmask4	set	$80
0001140B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001140B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001140B =00000000                M sptlmask1	set	((spal=7)<<7)
0001140B 7070 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001140F 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011413 8080 9F8E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011417 0000 1200                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001141B 0909 0909                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001141F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011423 3385 0885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011427 4E41 54                  M 	dc.b	'NAT'
0001142A                            
0001142A                            	; Patch $2C
0001142A                            	; $1F
0001142A                            	; $16, $61, $03, $52,	$1C, $9F, $1F, $1F
0001142A                            	; $92, $8F, $8F, $8F,	$00, $00, $00, $00
0001142A                            	; $FF, $0F, $0F, $0F,	$05, $05, $05, $05
0001142A                            	spAlgorithm	$07
0001142A =0000002D                M spatnum	=	spatnum+1
0001142A =00000007                M spal	=	val
0001142A                            	spFeedback	$03
0001142A =00000003                M spfe	=	val
0001142A                            	spDetune	$01, $00, $06, $05
0001142A =00000001                M spde1	=	op1
0001142A =00000000                M spde2	=	op2
0001142A =00000006                M spde3	=	op3
0001142A =00000005                M spde4	=	op4
0001142A                            	spMultiple	$06, $03, $01, $02
0001142A =00000006                M spmu1	=	op1
0001142A =00000003                M spmu2	=	op2
0001142A =00000001                M spmu3	=	op3
0001142A =00000002                M spmu4	=	op4
0001142A                            	spRateScale	$00, $00, $02, $00
0001142A =00000000                M sprs1	=	op1
0001142A =00000000                M sprs2	=	op2
0001142A =00000002                M sprs3	=	op3
0001142A =00000000                M sprs4	=	op4
0001142A                            	spAttackRt	$1C, $1F, $1F, $1F
0001142A =0000001C                M spar1	=	op1
0001142A =0000001F                M spar2	=	op2
0001142A =0000001F                M spar3	=	op3
0001142A =0000001F                M spar4	=	op4
0001142A                            	spAmpMod	$01, $01, $01, $01
0001142A =00000001                M spam1	=	op1
0001142A =00000001                M spam2	=	op2
0001142A =00000001                M spam3	=	op3
0001142A =00000001                M spam4	=	op4
0001142A                            	spSustainRt	$12, $0F, $0F, $0F
0001142A =00000012                M spsr1	=	op1
0001142A =0000000F                M spsr2	=	op2
0001142A =0000000F                M spsr3	=	op3
0001142A =0000000F                M spsr4	=	op4
0001142A                            	spDecayRt	$00, $00, $00, $00
0001142A =00000000                M spdr1	=	op1
0001142A =00000000                M spdr2	=	op2
0001142A =00000000                M spdr3	=	op3
0001142A =00000000                M spdr4	=	op4
0001142A                            	spSustainLv	$0F, $00, $00, $00
0001142A =0000000F                M spsl1	=	op1
0001142A =00000000                M spsl2	=	op2
0001142A =00000000                M spsl3	=	op3
0001142A =00000000                M spsl4	=	op4
0001142A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001142A =0000000F                M sprr1	=	op1
0001142A =0000000F                M sprr2	=	op2
0001142A =0000000F                M sprr3	=	op3
0001142A =0000000F                M sprr4	=	op4
0001142A                            	spSSGEG		$00, $00, $00, $00
0001142A =00000000                M spss1	=	op1
0001142A =00000000                M spss2	=	op2
0001142A =00000000                M spss3	=	op3
0001142A =00000000                M spss4	=	op4
0001142A                            	spTotalLv	$05, $05, $05, $05
0001142A =00000005                M sptl1	=	op1
0001142A =00000005                M sptl2	=	op2
0001142A =00000005                M sptl3	=	op3
0001142A =00000005                M sptl4	=	op4
0001142A 1F                       M 	dc.b	(spfe<<3)+spal
0001142B =00000080                M sptlmask4	set	$80
0001142B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001142B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001142B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001142B 1661 0352                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001142F 1C9F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011433 928F 8F8F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011437 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001143B FF0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001143F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011443 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011447 4E41 54                  M 	dc.b	'NAT'
0001144A                            
0001144A                            	; Patch $2D
0001144A                            	; $2C
0001144A                            	; $74, $74, $34, $34,	$12, $12, $12, $12
0001144A                            	; $80, $80, $80, $80,	$00, $01, $00, $01
0001144A                            	; $07, $37, $07, $37,	$16, $05, $17, $05
0001144A                            	spAlgorithm	$04
0001144A =0000002E                M spatnum	=	spatnum+1
0001144A =00000004                M spal	=	val
0001144A                            	spFeedback	$05
0001144A =00000005                M spfe	=	val
0001144A                            	spDetune	$07, $03, $07, $03
0001144A =00000007                M spde1	=	op1
0001144A =00000003                M spde2	=	op2
0001144A =00000007                M spde3	=	op3
0001144A =00000003                M spde4	=	op4
0001144A                            	spMultiple	$04, $04, $04, $04
0001144A =00000004                M spmu1	=	op1
0001144A =00000004                M spmu2	=	op2
0001144A =00000004                M spmu3	=	op3
0001144A =00000004                M spmu4	=	op4
0001144A                            	spRateScale	$00, $00, $00, $00
0001144A =00000000                M sprs1	=	op1
0001144A =00000000                M sprs2	=	op2
0001144A =00000000                M sprs3	=	op3
0001144A =00000000                M sprs4	=	op4
0001144A                            	spAttackRt	$12, $12, $12, $12
0001144A =00000012                M spar1	=	op1
0001144A =00000012                M spar2	=	op2
0001144A =00000012                M spar3	=	op3
0001144A =00000012                M spar4	=	op4
0001144A                            	spAmpMod	$01, $01, $01, $01
0001144A =00000001                M spam1	=	op1
0001144A =00000001                M spam2	=	op2
0001144A =00000001                M spam3	=	op3
0001144A =00000001                M spam4	=	op4
0001144A                            	spSustainRt	$00, $00, $00, $00
0001144A =00000000                M spsr1	=	op1
0001144A =00000000                M spsr2	=	op2
0001144A =00000000                M spsr3	=	op3
0001144A =00000000                M spsr4	=	op4
0001144A                            	spDecayRt	$00, $00, $01, $01
0001144A =00000000                M spdr1	=	op1
0001144A =00000000                M spdr2	=	op2
0001144A =00000001                M spdr3	=	op3
0001144A =00000001                M spdr4	=	op4
0001144A                            	spSustainLv	$00, $00, $03, $03
0001144A =00000000                M spsl1	=	op1
0001144A =00000000                M spsl2	=	op2
0001144A =00000003                M spsl3	=	op3
0001144A =00000003                M spsl4	=	op4
0001144A                            	spReleaseRt	$07, $07, $07, $07
0001144A =00000007                M sprr1	=	op1
0001144A =00000007                M sprr2	=	op2
0001144A =00000007                M sprr3	=	op3
0001144A =00000007                M sprr4	=	op4
0001144A                            	spSSGEG		$00, $00, $00, $00
0001144A =00000000                M spss1	=	op1
0001144A =00000000                M spss2	=	op2
0001144A =00000000                M spss3	=	op3
0001144A =00000000                M spss4	=	op4
0001144A                            	spTotalLv	$16, $17, $05, $05
0001144A =00000016                M sptl1	=	op1
0001144A =00000017                M sptl2	=	op2
0001144A =00000005                M sptl3	=	op3
0001144A =00000005                M sptl4	=	op4
0001144A 2C                       M 	dc.b	(spfe<<3)+spal
0001144B =00000080                M sptlmask4	set	$80
0001144B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001144B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001144B =00000000                M sptlmask1	set	((spal=7)<<7)
0001144B 7474 3434                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001144F 1212 1212                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011453 8080 8080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011457 0001 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001145B 0737 0737                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001145F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011463 1685 1785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011467 4E41 54                  M 	dc.b	'NAT'
0001146A                            
0001146A                            	; Patch $2E
0001146A                            	; $07
0001146A                            	; $34, $74, $32, $70,	$1F, $1F, $1F, $1F
0001146A                            	; $0A, $0A, $05, $03,	$00, $00, $00, $00
0001146A                            	; $3F, $3F, $2F, $2F,	$05, $05, $05, $05
0001146A                            	spAlgorithm	$07
0001146A =0000002F                M spatnum	=	spatnum+1
0001146A =00000007                M spal	=	val
0001146A                            	spFeedback	$00
0001146A =00000000                M spfe	=	val
0001146A                            	spDetune	$03, $03, $07, $07
0001146A =00000003                M spde1	=	op1
0001146A =00000003                M spde2	=	op2
0001146A =00000007                M spde3	=	op3
0001146A =00000007                M spde4	=	op4
0001146A                            	spMultiple	$04, $02, $04, $00
0001146A =00000004                M spmu1	=	op1
0001146A =00000002                M spmu2	=	op2
0001146A =00000004                M spmu3	=	op3
0001146A =00000000                M spmu4	=	op4
0001146A                            	spRateScale	$00, $00, $00, $00
0001146A =00000000                M sprs1	=	op1
0001146A =00000000                M sprs2	=	op2
0001146A =00000000                M sprs3	=	op3
0001146A =00000000                M sprs4	=	op4
0001146A                            	spAttackRt	$1F, $1F, $1F, $1F
0001146A =0000001F                M spar1	=	op1
0001146A =0000001F                M spar2	=	op2
0001146A =0000001F                M spar3	=	op3
0001146A =0000001F                M spar4	=	op4
0001146A                            	spAmpMod	$00, $00, $00, $00
0001146A =00000000                M spam1	=	op1
0001146A =00000000                M spam2	=	op2
0001146A =00000000                M spam3	=	op3
0001146A =00000000                M spam4	=	op4
0001146A                            	spSustainRt	$0A, $05, $0A, $03
0001146A =0000000A                M spsr1	=	op1
0001146A =00000005                M spsr2	=	op2
0001146A =0000000A                M spsr3	=	op3
0001146A =00000003                M spsr4	=	op4
0001146A                            	spDecayRt	$00, $00, $00, $00
0001146A =00000000                M spdr1	=	op1
0001146A =00000000                M spdr2	=	op2
0001146A =00000000                M spdr3	=	op3
0001146A =00000000                M spdr4	=	op4
0001146A                            	spSustainLv	$03, $02, $03, $02
0001146A =00000003                M spsl1	=	op1
0001146A =00000002                M spsl2	=	op2
0001146A =00000003                M spsl3	=	op3
0001146A =00000002                M spsl4	=	op4
0001146A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001146A =0000000F                M sprr1	=	op1
0001146A =0000000F                M sprr2	=	op2
0001146A =0000000F                M sprr3	=	op3
0001146A =0000000F                M sprr4	=	op4
0001146A                            	spSSGEG		$00, $00, $00, $00
0001146A =00000000                M spss1	=	op1
0001146A =00000000                M spss2	=	op2
0001146A =00000000                M spss3	=	op3
0001146A =00000000                M spss4	=	op4
0001146A                            	spTotalLv	$05, $05, $05, $05
0001146A =00000005                M sptl1	=	op1
0001146A =00000005                M sptl2	=	op2
0001146A =00000005                M sptl3	=	op3
0001146A =00000005                M sptl4	=	op4
0001146A 07                       M 	dc.b	(spfe<<3)+spal
0001146B =00000080                M sptlmask4	set	$80
0001146B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001146B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001146B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001146B 3474 3270                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001146F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011473 0A0A 0503                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011477 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001147B 3F3F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001147F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011483 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011487 4E41 54                  M 	dc.b	'NAT'
0001148A                            
0001148A                            	; Patch $2F
0001148A                            	; $3A
0001148A                            	; $70, $76, $30, $71,	$1F, $95, $1F, $1F
0001148A                            	; $0E, $0F, $05, $0C,	$07, $06, $06, $07
0001148A                            	; $2F, $4F, $1F, $5F,	$18, $0E, $0F, $02
0001148A                            	spAlgorithm	$02
0001148A =00000030                M spatnum	=	spatnum+1
0001148A =00000002                M spal	=	val
0001148A                            	spFeedback	$07
0001148A =00000007                M spfe	=	val
0001148A                            	spDetune	$07, $03, $07, $07
0001148A =00000007                M spde1	=	op1
0001148A =00000003                M spde2	=	op2
0001148A =00000007                M spde3	=	op3
0001148A =00000007                M spde4	=	op4
0001148A                            	spMultiple	$00, $00, $06, $01
0001148A =00000000                M spmu1	=	op1
0001148A =00000000                M spmu2	=	op2
0001148A =00000006                M spmu3	=	op3
0001148A =00000001                M spmu4	=	op4
0001148A                            	spRateScale	$00, $00, $02, $00
0001148A =00000000                M sprs1	=	op1
0001148A =00000000                M sprs2	=	op2
0001148A =00000002                M sprs3	=	op3
0001148A =00000000                M sprs4	=	op4
0001148A                            	spAttackRt	$1F, $1F, $15, $1F
0001148A =0000001F                M spar1	=	op1
0001148A =0000001F                M spar2	=	op2
0001148A =00000015                M spar3	=	op3
0001148A =0000001F                M spar4	=	op4
0001148A                            	spAmpMod	$00, $00, $00, $00
0001148A =00000000                M spam1	=	op1
0001148A =00000000                M spam2	=	op2
0001148A =00000000                M spam3	=	op3
0001148A =00000000                M spam4	=	op4
0001148A                            	spSustainRt	$0E, $05, $0F, $0C
0001148A =0000000E                M spsr1	=	op1
0001148A =00000005                M spsr2	=	op2
0001148A =0000000F                M spsr3	=	op3
0001148A =0000000C                M spsr4	=	op4
0001148A                            	spDecayRt	$07, $06, $06, $07
0001148A =00000007                M spdr1	=	op1
0001148A =00000006                M spdr2	=	op2
0001148A =00000006                M spdr3	=	op3
0001148A =00000007                M spdr4	=	op4
0001148A                            	spSustainLv	$02, $01, $04, $05
0001148A =00000002                M spsl1	=	op1
0001148A =00000001                M spsl2	=	op2
0001148A =00000004                M spsl3	=	op3
0001148A =00000005                M spsl4	=	op4
0001148A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001148A =0000000F                M sprr1	=	op1
0001148A =0000000F                M sprr2	=	op2
0001148A =0000000F                M sprr3	=	op3
0001148A =0000000F                M sprr4	=	op4
0001148A                            	spSSGEG		$00, $00, $00, $00
0001148A =00000000                M spss1	=	op1
0001148A =00000000                M spss2	=	op2
0001148A =00000000                M spss3	=	op3
0001148A =00000000                M spss4	=	op4
0001148A                            	spTotalLv	$18, $0F, $0E, $02
0001148A =00000018                M sptl1	=	op1
0001148A =0000000F                M sptl2	=	op2
0001148A =0000000E                M sptl3	=	op3
0001148A =00000002                M sptl4	=	op4
0001148A 3A                       M 	dc.b	(spfe<<3)+spal
0001148B =00000080                M sptlmask4	set	$80
0001148B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001148B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001148B =00000000                M sptlmask1	set	((spal=7)<<7)
0001148B 7076 3071                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001148F 1F95 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011493 0E0F 050C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011497 0706 0607                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001149B 2F4F 1F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001149F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114A3 180E 0F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114A7 4E41 54                  M 	dc.b	'NAT'
000114AA                            
000114AA                            	; Patch $30
000114AA                            	; $20
000114AA                            	; $34, $38, $30, $31,	$DF, $DF, $9F, $9F
000114AA                            	; $07, $08, $08, $0A,	$07, $0E, $0A, $11
000114AA                            	; $20, $1F, $1F, $1F,	$22, $37, $14, $00
000114AA                            	spAlgorithm	$00
000114AA =00000031                M spatnum	=	spatnum+1
000114AA =00000000                M spal	=	val
000114AA                            	spFeedback	$04
000114AA =00000004                M spfe	=	val
000114AA                            	spDetune	$03, $03, $03, $03
000114AA =00000003                M spde1	=	op1
000114AA =00000003                M spde2	=	op2
000114AA =00000003                M spde3	=	op3
000114AA =00000003                M spde4	=	op4
000114AA                            	spMultiple	$04, $00, $08, $01
000114AA =00000004                M spmu1	=	op1
000114AA =00000000                M spmu2	=	op2
000114AA =00000008                M spmu3	=	op3
000114AA =00000001                M spmu4	=	op4
000114AA                            	spRateScale	$03, $02, $03, $02
000114AA =00000003                M sprs1	=	op1
000114AA =00000002                M sprs2	=	op2
000114AA =00000003                M sprs3	=	op3
000114AA =00000002                M sprs4	=	op4
000114AA                            	spAttackRt	$1F, $1F, $1F, $1F
000114AA =0000001F                M spar1	=	op1
000114AA =0000001F                M spar2	=	op2
000114AA =0000001F                M spar3	=	op3
000114AA =0000001F                M spar4	=	op4
000114AA                            	spAmpMod	$00, $00, $00, $00
000114AA =00000000                M spam1	=	op1
000114AA =00000000                M spam2	=	op2
000114AA =00000000                M spam3	=	op3
000114AA =00000000                M spam4	=	op4
000114AA                            	spSustainRt	$07, $08, $08, $0A
000114AA =00000007                M spsr1	=	op1
000114AA =00000008                M spsr2	=	op2
000114AA =00000008                M spsr3	=	op3
000114AA =0000000A                M spsr4	=	op4
000114AA                            	spDecayRt	$07, $0A, $0E, $11
000114AA =00000007                M spdr1	=	op1
000114AA =0000000A                M spdr2	=	op2
000114AA =0000000E                M spdr3	=	op3
000114AA =00000011                M spdr4	=	op4
000114AA                            	spSustainLv	$02, $01, $01, $01
000114AA =00000002                M spsl1	=	op1
000114AA =00000001                M spsl2	=	op2
000114AA =00000001                M spsl3	=	op3
000114AA =00000001                M spsl4	=	op4
000114AA                            	spReleaseRt	$00, $0F, $0F, $0F
000114AA =00000000                M sprr1	=	op1
000114AA =0000000F                M sprr2	=	op2
000114AA =0000000F                M sprr3	=	op3
000114AA =0000000F                M sprr4	=	op4
000114AA                            	spSSGEG		$00, $00, $00, $00
000114AA =00000000                M spss1	=	op1
000114AA =00000000                M spss2	=	op2
000114AA =00000000                M spss3	=	op3
000114AA =00000000                M spss4	=	op4
000114AA                            	spTotalLv	$22, $14, $37, $00
000114AA =00000022                M sptl1	=	op1
000114AA =00000014                M sptl2	=	op2
000114AA =00000037                M sptl3	=	op3
000114AA =00000000                M sptl4	=	op4
000114AA 20                       M 	dc.b	(spfe<<3)+spal
000114AB =00000080                M sptlmask4	set	$80
000114AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000114AB =00000000                M sptlmask1	set	((spal=7)<<7)
000114AB 3438 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114AF DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114B3 0708 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114B7 070E 0A11                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114BB 201F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114C3 2237 1480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114C7 4E41 54                  M 	dc.b	'NAT'
000114CA                            
000114CA                            	; Patch $31
000114CA                            	; $3A
000114CA                            	; $31, $7F, $61, $0A,	$9C, $DB, $9C, $9A
000114CA                            	; $04, $08, $03, $09,	$03, $01, $00, $00
000114CA                            	; $1F, $0F, $FF, $FF,	$23, $25, $1B, $06
000114CA                            	spAlgorithm	$02
000114CA =00000032                M spatnum	=	spatnum+1
000114CA =00000002                M spal	=	val
000114CA                            	spFeedback	$07
000114CA =00000007                M spfe	=	val
000114CA                            	spDetune	$03, $06, $07, $00
000114CA =00000003                M spde1	=	op1
000114CA =00000006                M spde2	=	op2
000114CA =00000007                M spde3	=	op3
000114CA =00000000                M spde4	=	op4
000114CA                            	spMultiple	$01, $01, $0F, $0A
000114CA =00000001                M spmu1	=	op1
000114CA =00000001                M spmu2	=	op2
000114CA =0000000F                M spmu3	=	op3
000114CA =0000000A                M spmu4	=	op4
000114CA                            	spRateScale	$02, $02, $03, $02
000114CA =00000002                M sprs1	=	op1
000114CA =00000002                M sprs2	=	op2
000114CA =00000003                M sprs3	=	op3
000114CA =00000002                M sprs4	=	op4
000114CA                            	spAttackRt	$1C, $1C, $1B, $1A
000114CA =0000001C                M spar1	=	op1
000114CA =0000001C                M spar2	=	op2
000114CA =0000001B                M spar3	=	op3
000114CA =0000001A                M spar4	=	op4
000114CA                            	spAmpMod	$00, $00, $00, $00
000114CA =00000000                M spam1	=	op1
000114CA =00000000                M spam2	=	op2
000114CA =00000000                M spam3	=	op3
000114CA =00000000                M spam4	=	op4
000114CA                            	spSustainRt	$04, $03, $08, $09
000114CA =00000004                M spsr1	=	op1
000114CA =00000003                M spsr2	=	op2
000114CA =00000008                M spsr3	=	op3
000114CA =00000009                M spsr4	=	op4
000114CA                            	spDecayRt	$03, $00, $01, $00
000114CA =00000003                M spdr1	=	op1
000114CA =00000000                M spdr2	=	op2
000114CA =00000001                M spdr3	=	op3
000114CA =00000000                M spdr4	=	op4
000114CA                            	spSustainLv	$01, $0F, $00, $0F
000114CA =00000001                M spsl1	=	op1
000114CA =0000000F                M spsl2	=	op2
000114CA =00000000                M spsl3	=	op3
000114CA =0000000F                M spsl4	=	op4
000114CA                            	spReleaseRt	$0F, $0F, $0F, $0F
000114CA =0000000F                M sprr1	=	op1
000114CA =0000000F                M sprr2	=	op2
000114CA =0000000F                M sprr3	=	op3
000114CA =0000000F                M sprr4	=	op4
000114CA                            	spSSGEG		$00, $00, $00, $00
000114CA =00000000                M spss1	=	op1
000114CA =00000000                M spss2	=	op2
000114CA =00000000                M spss3	=	op3
000114CA =00000000                M spss4	=	op4
000114CA                            	spTotalLv	$23, $1B, $25, $06
000114CA =00000023                M sptl1	=	op1
000114CA =0000001B                M sptl2	=	op2
000114CA =00000025                M sptl3	=	op3
000114CA =00000006                M sptl4	=	op4
000114CA 3A                       M 	dc.b	(spfe<<3)+spal
000114CB =00000080                M sptlmask4	set	$80
000114CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000114CB =00000000                M sptlmask1	set	((spal=7)<<7)
000114CB 317F 610A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114CF 9CDB 9C9A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114D3 0408 0309                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114D7 0301 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114DB 1F0F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114E3 2325 1B86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114E7 4E41 54                  M 	dc.b	'NAT'
000114EA                            
000114EA                            	; Patch $32
000114EA                            	; $04
000114EA                            	; $02, $02, $03, $03,	$13, $10, $13, $10
000114EA                            	; $06, $0C, $06, $0C,	$00, $00, $00, $00
000114EA                            	; $4F, $2F, $4F, $2F,	$18, $06, $18, $06
000114EA                            	spAlgorithm	$04
000114EA =00000033                M spatnum	=	spatnum+1
000114EA =00000004                M spal	=	val
000114EA                            	spFeedback	$00
000114EA =00000000                M spfe	=	val
000114EA                            	spDetune	$00, $00, $00, $00
000114EA =00000000                M spde1	=	op1
000114EA =00000000                M spde2	=	op2
000114EA =00000000                M spde3	=	op3
000114EA =00000000                M spde4	=	op4
000114EA                            	spMultiple	$02, $03, $02, $03
000114EA =00000002                M spmu1	=	op1
000114EA =00000003                M spmu2	=	op2
000114EA =00000002                M spmu3	=	op3
000114EA =00000003                M spmu4	=	op4
000114EA                            	spRateScale	$00, $00, $00, $00
000114EA =00000000                M sprs1	=	op1
000114EA =00000000                M sprs2	=	op2
000114EA =00000000                M sprs3	=	op3
000114EA =00000000                M sprs4	=	op4
000114EA                            	spAttackRt	$13, $13, $10, $10
000114EA =00000013                M spar1	=	op1
000114EA =00000013                M spar2	=	op2
000114EA =00000010                M spar3	=	op3
000114EA =00000010                M spar4	=	op4
000114EA                            	spAmpMod	$00, $00, $00, $00
000114EA =00000000                M spam1	=	op1
000114EA =00000000                M spam2	=	op2
000114EA =00000000                M spam3	=	op3
000114EA =00000000                M spam4	=	op4
000114EA                            	spSustainRt	$06, $06, $0C, $0C
000114EA =00000006                M spsr1	=	op1
000114EA =00000006                M spsr2	=	op2
000114EA =0000000C                M spsr3	=	op3
000114EA =0000000C                M spsr4	=	op4
000114EA                            	spDecayRt	$00, $00, $00, $00
000114EA =00000000                M spdr1	=	op1
000114EA =00000000                M spdr2	=	op2
000114EA =00000000                M spdr3	=	op3
000114EA =00000000                M spdr4	=	op4
000114EA                            	spSustainLv	$04, $04, $02, $02
000114EA =00000004                M spsl1	=	op1
000114EA =00000004                M spsl2	=	op2
000114EA =00000002                M spsl3	=	op3
000114EA =00000002                M spsl4	=	op4
000114EA                            	spReleaseRt	$0F, $0F, $0F, $0F
000114EA =0000000F                M sprr1	=	op1
000114EA =0000000F                M sprr2	=	op2
000114EA =0000000F                M sprr3	=	op3
000114EA =0000000F                M sprr4	=	op4
000114EA                            	spSSGEG		$00, $00, $00, $00
000114EA =00000000                M spss1	=	op1
000114EA =00000000                M spss2	=	op2
000114EA =00000000                M spss3	=	op3
000114EA =00000000                M spss4	=	op4
000114EA                            	spTotalLv	$18, $18, $06, $06
000114EA =00000018                M sptl1	=	op1
000114EA =00000018                M sptl2	=	op2
000114EA =00000006                M sptl3	=	op3
000114EA =00000006                M sptl4	=	op4
000114EA 04                       M 	dc.b	(spfe<<3)+spal
000114EB =00000080                M sptlmask4	set	$80
000114EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000114EB =00000000                M sptlmask1	set	((spal=7)<<7)
000114EB 0202 0303                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114EF 1310 1310                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114F3 060C 060C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114F7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114FB 4F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011503 1886 1886                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011507 4E41 54                  M 	dc.b	'NAT'
0001150A                            
0001150A                            	; Patch $33
0001150A                            	; $38
0001150A                            	; $75, $13, $71, $11,	$DF, $5F, $1F, $1F
0001150A                            	; $0C, $0D, $01, $01,	$00, $00, $00, $00
0001150A                            	; $FF, $FF, $FF, $FF,	$1E, $1E, $1E, $03
0001150A                            	spAlgorithm	$00
0001150A =00000034                M spatnum	=	spatnum+1
0001150A =00000000                M spal	=	val
0001150A                            	spFeedback	$07
0001150A =00000007                M spfe	=	val
0001150A                            	spDetune	$07, $07, $01, $01
0001150A =00000007                M spde1	=	op1
0001150A =00000007                M spde2	=	op2
0001150A =00000001                M spde3	=	op3
0001150A =00000001                M spde4	=	op4
0001150A                            	spMultiple	$05, $01, $03, $01
0001150A =00000005                M spmu1	=	op1
0001150A =00000001                M spmu2	=	op2
0001150A =00000003                M spmu3	=	op3
0001150A =00000001                M spmu4	=	op4
0001150A                            	spRateScale	$03, $00, $01, $00
0001150A =00000003                M sprs1	=	op1
0001150A =00000000                M sprs2	=	op2
0001150A =00000001                M sprs3	=	op3
0001150A =00000000                M sprs4	=	op4
0001150A                            	spAttackRt	$1F, $1F, $1F, $1F
0001150A =0000001F                M spar1	=	op1
0001150A =0000001F                M spar2	=	op2
0001150A =0000001F                M spar3	=	op3
0001150A =0000001F                M spar4	=	op4
0001150A                            	spAmpMod	$00, $00, $00, $00
0001150A =00000000                M spam1	=	op1
0001150A =00000000                M spam2	=	op2
0001150A =00000000                M spam3	=	op3
0001150A =00000000                M spam4	=	op4
0001150A                            	spSustainRt	$0C, $01, $0D, $01
0001150A =0000000C                M spsr1	=	op1
0001150A =00000001                M spsr2	=	op2
0001150A =0000000D                M spsr3	=	op3
0001150A =00000001                M spsr4	=	op4
0001150A                            	spDecayRt	$00, $00, $00, $00
0001150A =00000000                M spdr1	=	op1
0001150A =00000000                M spdr2	=	op2
0001150A =00000000                M spdr3	=	op3
0001150A =00000000                M spdr4	=	op4
0001150A                            	spSustainLv	$0F, $0F, $0F, $0F
0001150A =0000000F                M spsl1	=	op1
0001150A =0000000F                M spsl2	=	op2
0001150A =0000000F                M spsl3	=	op3
0001150A =0000000F                M spsl4	=	op4
0001150A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001150A =0000000F                M sprr1	=	op1
0001150A =0000000F                M sprr2	=	op2
0001150A =0000000F                M sprr3	=	op3
0001150A =0000000F                M sprr4	=	op4
0001150A                            	spSSGEG		$00, $00, $00, $00
0001150A =00000000                M spss1	=	op1
0001150A =00000000                M spss2	=	op2
0001150A =00000000                M spss3	=	op3
0001150A =00000000                M spss4	=	op4
0001150A                            	spTotalLv	$1E, $1E, $1E, $03
0001150A =0000001E                M sptl1	=	op1
0001150A =0000001E                M sptl2	=	op2
0001150A =0000001E                M sptl3	=	op3
0001150A =00000003                M sptl4	=	op4
0001150A 38                       M 	dc.b	(spfe<<3)+spal
0001150B =00000080                M sptlmask4	set	$80
0001150B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001150B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001150B =00000000                M sptlmask1	set	((spal=7)<<7)
0001150B 7513 7111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001150F DF5F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011513 0C0D 0101                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011517 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001151B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001151F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011523 1E1E 1E83                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011527 4E41 54                  M 	dc.b	'NAT'
0001152A                            
0001152A                            	; Patch $34
0001152A                            	; $34
0001152A                            	; $74, $21, $16, $71,	$11, $1F, $1F, $1F
0001152A                            	; $08, $05, $08, $09,	$00, $00, $00, $00
0001152A                            	; $FF, $FF, $FF, $FF,	$17, $05, $10, $05
0001152A                            	spAlgorithm	$04
0001152A =00000035                M spatnum	=	spatnum+1
0001152A =00000004                M spal	=	val
0001152A                            	spFeedback	$06
0001152A =00000006                M spfe	=	val
0001152A                            	spDetune	$07, $01, $02, $07
0001152A =00000007                M spde1	=	op1
0001152A =00000001                M spde2	=	op2
0001152A =00000002                M spde3	=	op3
0001152A =00000007                M spde4	=	op4
0001152A                            	spMultiple	$04, $06, $01, $01
0001152A =00000004                M spmu1	=	op1
0001152A =00000006                M spmu2	=	op2
0001152A =00000001                M spmu3	=	op3
0001152A =00000001                M spmu4	=	op4
0001152A                            	spRateScale	$00, $00, $00, $00
0001152A =00000000                M sprs1	=	op1
0001152A =00000000                M sprs2	=	op2
0001152A =00000000                M sprs3	=	op3
0001152A =00000000                M sprs4	=	op4
0001152A                            	spAttackRt	$11, $1F, $1F, $1F
0001152A =00000011                M spar1	=	op1
0001152A =0000001F                M spar2	=	op2
0001152A =0000001F                M spar3	=	op3
0001152A =0000001F                M spar4	=	op4
0001152A                            	spAmpMod	$00, $00, $00, $00
0001152A =00000000                M spam1	=	op1
0001152A =00000000                M spam2	=	op2
0001152A =00000000                M spam3	=	op3
0001152A =00000000                M spam4	=	op4
0001152A                            	spSustainRt	$08, $08, $05, $09
0001152A =00000008                M spsr1	=	op1
0001152A =00000008                M spsr2	=	op2
0001152A =00000005                M spsr3	=	op3
0001152A =00000009                M spsr4	=	op4
0001152A                            	spDecayRt	$00, $00, $00, $00
0001152A =00000000                M spdr1	=	op1
0001152A =00000000                M spdr2	=	op2
0001152A =00000000                M spdr3	=	op3
0001152A =00000000                M spdr4	=	op4
0001152A                            	spSustainLv	$0F, $0F, $0F, $0F
0001152A =0000000F                M spsl1	=	op1
0001152A =0000000F                M spsl2	=	op2
0001152A =0000000F                M spsl3	=	op3
0001152A =0000000F                M spsl4	=	op4
0001152A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001152A =0000000F                M sprr1	=	op1
0001152A =0000000F                M sprr2	=	op2
0001152A =0000000F                M sprr3	=	op3
0001152A =0000000F                M sprr4	=	op4
0001152A                            	spSSGEG		$00, $00, $00, $00
0001152A =00000000                M spss1	=	op1
0001152A =00000000                M spss2	=	op2
0001152A =00000000                M spss3	=	op3
0001152A =00000000                M spss4	=	op4
0001152A                            	spTotalLv	$17, $10, $05, $05
0001152A =00000017                M sptl1	=	op1
0001152A =00000010                M sptl2	=	op2
0001152A =00000005                M sptl3	=	op3
0001152A =00000005                M sptl4	=	op4
0001152A 34                       M 	dc.b	(spfe<<3)+spal
0001152B =00000080                M sptlmask4	set	$80
0001152B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001152B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001152B =00000000                M sptlmask1	set	((spal=7)<<7)
0001152B 7421 1671                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001152F 111F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011533 0805 0809                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011537 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001153B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001153F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011543 1785 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011547 4E41 54                  M 	dc.b	'NAT'
0001154A                            
0001154A                            	; Patch $35
0001154A                            	; $38
0001154A                            	; $41, $11, $71, $41,	$16, $13, $0F, $17
0001154A                            	; $02, $0C, $05, $01,	$00, $0F, $00, $00
0001154A                            	; $1F, $3F, $5F, $1F,	$2A, $12, $24, $04
0001154A                            	spAlgorithm	$00
0001154A =00000036                M spatnum	=	spatnum+1
0001154A =00000000                M spal	=	val
0001154A                            	spFeedback	$07
0001154A =00000007                M spfe	=	val
0001154A                            	spDetune	$04, $07, $01, $04
0001154A =00000004                M spde1	=	op1
0001154A =00000007                M spde2	=	op2
0001154A =00000001                M spde3	=	op3
0001154A =00000004                M spde4	=	op4
0001154A                            	spMultiple	$01, $01, $01, $01
0001154A =00000001                M spmu1	=	op1
0001154A =00000001                M spmu2	=	op2
0001154A =00000001                M spmu3	=	op3
0001154A =00000001                M spmu4	=	op4
0001154A                            	spRateScale	$00, $00, $00, $00
0001154A =00000000                M sprs1	=	op1
0001154A =00000000                M sprs2	=	op2
0001154A =00000000                M sprs3	=	op3
0001154A =00000000                M sprs4	=	op4
0001154A                            	spAttackRt	$16, $0F, $13, $17
0001154A =00000016                M spar1	=	op1
0001154A =0000000F                M spar2	=	op2
0001154A =00000013                M spar3	=	op3
0001154A =00000017                M spar4	=	op4
0001154A                            	spAmpMod	$00, $00, $00, $00
0001154A =00000000                M spam1	=	op1
0001154A =00000000                M spam2	=	op2
0001154A =00000000                M spam3	=	op3
0001154A =00000000                M spam4	=	op4
0001154A                            	spSustainRt	$02, $05, $0C, $01
0001154A =00000002                M spsr1	=	op1
0001154A =00000005                M spsr2	=	op2
0001154A =0000000C                M spsr3	=	op3
0001154A =00000001                M spsr4	=	op4
0001154A                            	spDecayRt	$00, $00, $0F, $00
0001154A =00000000                M spdr1	=	op1
0001154A =00000000                M spdr2	=	op2
0001154A =0000000F                M spdr3	=	op3
0001154A =00000000                M spdr4	=	op4
0001154A                            	spSustainLv	$01, $05, $03, $01
0001154A =00000001                M spsl1	=	op1
0001154A =00000005                M spsl2	=	op2
0001154A =00000003                M spsl3	=	op3
0001154A =00000001                M spsl4	=	op4
0001154A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001154A =0000000F                M sprr1	=	op1
0001154A =0000000F                M sprr2	=	op2
0001154A =0000000F                M sprr3	=	op3
0001154A =0000000F                M sprr4	=	op4
0001154A                            	spSSGEG		$00, $00, $00, $00
0001154A =00000000                M spss1	=	op1
0001154A =00000000                M spss2	=	op2
0001154A =00000000                M spss3	=	op3
0001154A =00000000                M spss4	=	op4
0001154A                            	spTotalLv	$2A, $24, $12, $04
0001154A =0000002A                M sptl1	=	op1
0001154A =00000024                M sptl2	=	op2
0001154A =00000012                M sptl3	=	op3
0001154A =00000004                M sptl4	=	op4
0001154A 38                       M 	dc.b	(spfe<<3)+spal
0001154B =00000080                M sptlmask4	set	$80
0001154B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001154B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001154B =00000000                M sptlmask1	set	((spal=7)<<7)
0001154B 4111 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001154F 1613 0F17                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011553 020C 0501                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011557 000F 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001155B 1F3F 5F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001155F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011563 2A12 2484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011567 4E41 54                  M 	dc.b	'NAT'
0001156A                            
0001156A                            	; Patch $36
0001156A                            	; $3D
0001156A                            	; $01, $01, $01, $01,	$94, $19, $19, $19
0001156A                            	; $0F, $0D, $0D, $0D,	$07, $04, $04, $04
0001156A                            	; $25, $1A, $1A, $1A,	$15, $05, $05, $05
0001156A                            	spAlgorithm	$05
0001156A =00000037                M spatnum	=	spatnum+1
0001156A =00000005                M spal	=	val
0001156A                            	spFeedback	$07
0001156A =00000007                M spfe	=	val
0001156A                            	spDetune	$00, $00, $00, $00
0001156A =00000000                M spde1	=	op1
0001156A =00000000                M spde2	=	op2
0001156A =00000000                M spde3	=	op3
0001156A =00000000                M spde4	=	op4
0001156A                            	spMultiple	$01, $01, $01, $01
0001156A =00000001                M spmu1	=	op1
0001156A =00000001                M spmu2	=	op2
0001156A =00000001                M spmu3	=	op3
0001156A =00000001                M spmu4	=	op4
0001156A                            	spRateScale	$02, $00, $00, $00
0001156A =00000002                M sprs1	=	op1
0001156A =00000000                M sprs2	=	op2
0001156A =00000000                M sprs3	=	op3
0001156A =00000000                M sprs4	=	op4
0001156A                            	spAttackRt	$14, $19, $19, $19
0001156A =00000014                M spar1	=	op1
0001156A =00000019                M spar2	=	op2
0001156A =00000019                M spar3	=	op3
0001156A =00000019                M spar4	=	op4
0001156A                            	spAmpMod	$00, $00, $00, $00
0001156A =00000000                M spam1	=	op1
0001156A =00000000                M spam2	=	op2
0001156A =00000000                M spam3	=	op3
0001156A =00000000                M spam4	=	op4
0001156A                            	spSustainRt	$0F, $0D, $0D, $0D
0001156A =0000000F                M spsr1	=	op1
0001156A =0000000D                M spsr2	=	op2
0001156A =0000000D                M spsr3	=	op3
0001156A =0000000D                M spsr4	=	op4
0001156A                            	spDecayRt	$07, $04, $04, $04
0001156A =00000007                M spdr1	=	op1
0001156A =00000004                M spdr2	=	op2
0001156A =00000004                M spdr3	=	op3
0001156A =00000004                M spdr4	=	op4
0001156A                            	spSustainLv	$02, $01, $01, $01
0001156A =00000002                M spsl1	=	op1
0001156A =00000001                M spsl2	=	op2
0001156A =00000001                M spsl3	=	op3
0001156A =00000001                M spsl4	=	op4
0001156A                            	spReleaseRt	$05, $0A, $0A, $0A
0001156A =00000005                M sprr1	=	op1
0001156A =0000000A                M sprr2	=	op2
0001156A =0000000A                M sprr3	=	op3
0001156A =0000000A                M sprr4	=	op4
0001156A                            	spSSGEG		$00, $00, $00, $00
0001156A =00000000                M spss1	=	op1
0001156A =00000000                M spss2	=	op2
0001156A =00000000                M spss3	=	op3
0001156A =00000000                M spss4	=	op4
0001156A                            	spTotalLv	$15, $05, $05, $05
0001156A =00000015                M sptl1	=	op1
0001156A =00000005                M sptl2	=	op2
0001156A =00000005                M sptl3	=	op3
0001156A =00000005                M sptl4	=	op4
0001156A 3D                       M 	dc.b	(spfe<<3)+spal
0001156B =00000080                M sptlmask4	set	$80
0001156B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001156B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001156B =00000000                M sptlmask1	set	((spal=7)<<7)
0001156B 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001156F 9419 1919                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011573 0F0D 0D0D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011577 0704 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001157B 251A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001157F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011583 1585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011587 4E41 54                  M 	dc.b	'NAT'
0001158A                            
0001158A                            	; Patch $37
0001158A                            	; $3A
0001158A                            	; $31, $77, $32, $02,	$1C, $13, $0E, $4E
0001158A                            	; $04, $10, $09, $0A,	$0C, $00, $03, $00
0001158A                            	; $16, $2B, $24, $18,	$1D, $13, $2A, $04
0001158A                            	spAlgorithm	$02
0001158A =00000038                M spatnum	=	spatnum+1
0001158A =00000002                M spal	=	val
0001158A                            	spFeedback	$07
0001158A =00000007                M spfe	=	val
0001158A                            	spDetune	$03, $03, $07, $00
0001158A =00000003                M spde1	=	op1
0001158A =00000003                M spde2	=	op2
0001158A =00000007                M spde3	=	op3
0001158A =00000000                M spde4	=	op4
0001158A                            	spMultiple	$01, $02, $07, $02
0001158A =00000001                M spmu1	=	op1
0001158A =00000002                M spmu2	=	op2
0001158A =00000007                M spmu3	=	op3
0001158A =00000002                M spmu4	=	op4
0001158A                            	spRateScale	$00, $00, $00, $01
0001158A =00000000                M sprs1	=	op1
0001158A =00000000                M sprs2	=	op2
0001158A =00000000                M sprs3	=	op3
0001158A =00000001                M sprs4	=	op4
0001158A                            	spAttackRt	$1C, $0E, $13, $0E
0001158A =0000001C                M spar1	=	op1
0001158A =0000000E                M spar2	=	op2
0001158A =00000013                M spar3	=	op3
0001158A =0000000E                M spar4	=	op4
0001158A                            	spAmpMod	$00, $00, $00, $00
0001158A =00000000                M spam1	=	op1
0001158A =00000000                M spam2	=	op2
0001158A =00000000                M spam3	=	op3
0001158A =00000000                M spam4	=	op4
0001158A                            	spSustainRt	$04, $09, $10, $0A
0001158A =00000004                M spsr1	=	op1
0001158A =00000009                M spsr2	=	op2
0001158A =00000010                M spsr3	=	op3
0001158A =0000000A                M spsr4	=	op4
0001158A                            	spDecayRt	$0C, $03, $00, $00
0001158A =0000000C                M spdr1	=	op1
0001158A =00000003                M spdr2	=	op2
0001158A =00000000                M spdr3	=	op3
0001158A =00000000                M spdr4	=	op4
0001158A                            	spSustainLv	$01, $02, $02, $01
0001158A =00000001                M spsl1	=	op1
0001158A =00000002                M spsl2	=	op2
0001158A =00000002                M spsl3	=	op3
0001158A =00000001                M spsl4	=	op4
0001158A                            	spReleaseRt	$06, $04, $0B, $08
0001158A =00000006                M sprr1	=	op1
0001158A =00000004                M sprr2	=	op2
0001158A =0000000B                M sprr3	=	op3
0001158A =00000008                M sprr4	=	op4
0001158A                            	spSSGEG		$00, $00, $00, $00
0001158A =00000000                M spss1	=	op1
0001158A =00000000                M spss2	=	op2
0001158A =00000000                M spss3	=	op3
0001158A =00000000                M spss4	=	op4
0001158A                            	spTotalLv	$1D, $2A, $13, $04
0001158A =0000001D                M sptl1	=	op1
0001158A =0000002A                M sptl2	=	op2
0001158A =00000013                M sptl3	=	op3
0001158A =00000004                M sptl4	=	op4
0001158A 3A                       M 	dc.b	(spfe<<3)+spal
0001158B =00000080                M sptlmask4	set	$80
0001158B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001158B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001158B =00000000                M sptlmask1	set	((spal=7)<<7)
0001158B 3177 3202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001158F 1C13 0E4E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011593 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011597 0C00 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001159B 162B 2418                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001159F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115A3 1D13 2A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115A7 4E41 54                  M 	dc.b	'NAT'
000115AA                            
000115AA                            	; Patch $38
000115AA                            	; $03
000115AA                            	; $01, $78, $39, $3A,	$1F, $1F, $1F, $1F
000115AA                            	; $06, $00, $08, $0A,	$00, $00, $00, $00
000115AA                            	; $F4, $02, $56, $F5,	$33, $1B, $43, $04
000115AA                            	spAlgorithm	$03
000115AA =00000039                M spatnum	=	spatnum+1
000115AA =00000003                M spal	=	val
000115AA                            	spFeedback	$00
000115AA =00000000                M spfe	=	val
000115AA                            	spDetune	$00, $03, $07, $03
000115AA =00000000                M spde1	=	op1
000115AA =00000003                M spde2	=	op2
000115AA =00000007                M spde3	=	op3
000115AA =00000003                M spde4	=	op4
000115AA                            	spMultiple	$01, $09, $08, $0A
000115AA =00000001                M spmu1	=	op1
000115AA =00000009                M spmu2	=	op2
000115AA =00000008                M spmu3	=	op3
000115AA =0000000A                M spmu4	=	op4
000115AA                            	spRateScale	$00, $00, $00, $00
000115AA =00000000                M sprs1	=	op1
000115AA =00000000                M sprs2	=	op2
000115AA =00000000                M sprs3	=	op3
000115AA =00000000                M sprs4	=	op4
000115AA                            	spAttackRt	$1F, $1F, $1F, $1F
000115AA =0000001F                M spar1	=	op1
000115AA =0000001F                M spar2	=	op2
000115AA =0000001F                M spar3	=	op3
000115AA =0000001F                M spar4	=	op4
000115AA                            	spAmpMod	$00, $00, $00, $00
000115AA =00000000                M spam1	=	op1
000115AA =00000000                M spam2	=	op2
000115AA =00000000                M spam3	=	op3
000115AA =00000000                M spam4	=	op4
000115AA                            	spSustainRt	$06, $08, $00, $0A
000115AA =00000006                M spsr1	=	op1
000115AA =00000008                M spsr2	=	op2
000115AA =00000000                M spsr3	=	op3
000115AA =0000000A                M spsr4	=	op4
000115AA                            	spDecayRt	$00, $00, $00, $00
000115AA =00000000                M spdr1	=	op1
000115AA =00000000                M spdr2	=	op2
000115AA =00000000                M spdr3	=	op3
000115AA =00000000                M spdr4	=	op4
000115AA                            	spSustainLv	$0F, $05, $00, $0F
000115AA =0000000F                M spsl1	=	op1
000115AA =00000005                M spsl2	=	op2
000115AA =00000000                M spsl3	=	op3
000115AA =0000000F                M spsl4	=	op4
000115AA                            	spReleaseRt	$04, $06, $02, $05
000115AA =00000004                M sprr1	=	op1
000115AA =00000006                M sprr2	=	op2
000115AA =00000002                M sprr3	=	op3
000115AA =00000005                M sprr4	=	op4
000115AA                            	spSSGEG		$00, $00, $00, $00
000115AA =00000000                M spss1	=	op1
000115AA =00000000                M spss2	=	op2
000115AA =00000000                M spss3	=	op3
000115AA =00000000                M spss4	=	op4
000115AA                            	spTotalLv	$33, $43, $1B, $04
000115AA =00000033                M sptl1	=	op1
000115AA =00000043                M sptl2	=	op2
000115AA =0000001B                M sptl3	=	op3
000115AA =00000004                M sptl4	=	op4
000115AA 03                       M 	dc.b	(spfe<<3)+spal
000115AB =00000080                M sptlmask4	set	$80
000115AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000115AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000115AB =00000000                M sptlmask1	set	((spal=7)<<7)
000115AB 0178 393A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115AF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115B3 0600 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115B7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115BB F402 56F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115C3 331B 4384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115C7 4E41 54                  M 	dc.b	'NAT'
000115CA                            
000115CA                            	; Patch $39
000115CA                            	; $3A
000115CA                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
000115CA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000115CA                            	; $13, $FA, $13, $0A,	$18, $1E, $27, $04
000115CA                            	spAlgorithm	$02
000115CA =0000003A                M spatnum	=	spatnum+1
000115CA =00000002                M spal	=	val
000115CA                            	spFeedback	$07
000115CA =00000007                M spfe	=	val
000115CA                            	spDetune	$00, $00, $00, $00
000115CA =00000000                M spde1	=	op1
000115CA =00000000                M spde2	=	op2
000115CA =00000000                M spde3	=	op3
000115CA =00000000                M spde4	=	op4
000115CA                            	spMultiple	$01, $01, $07, $01
000115CA =00000001                M spmu1	=	op1
000115CA =00000001                M spmu2	=	op2
000115CA =00000007                M spmu3	=	op3
000115CA =00000001                M spmu4	=	op4
000115CA                            	spRateScale	$02, $02, $02, $01
000115CA =00000002                M sprs1	=	op1
000115CA =00000002                M sprs2	=	op2
000115CA =00000002                M sprs3	=	op3
000115CA =00000001                M sprs4	=	op4
000115CA                            	spAttackRt	$0E, $0D, $0E, $13
000115CA =0000000E                M spar1	=	op1
000115CA =0000000D                M spar2	=	op2
000115CA =0000000E                M spar3	=	op3
000115CA =00000013                M spar4	=	op4
000115CA                            	spAmpMod	$00, $00, $00, $00
000115CA =00000000                M spam1	=	op1
000115CA =00000000                M spam2	=	op2
000115CA =00000000                M spam3	=	op3
000115CA =00000000                M spam4	=	op4
000115CA                            	spSustainRt	$0E, $0E, $0E, $03
000115CA =0000000E                M spsr1	=	op1
000115CA =0000000E                M spsr2	=	op2
000115CA =0000000E                M spsr3	=	op3
000115CA =00000003                M spsr4	=	op4
000115CA                            	spDecayRt	$00, $00, $00, $00
000115CA =00000000                M spdr1	=	op1
000115CA =00000000                M spdr2	=	op2
000115CA =00000000                M spdr3	=	op3
000115CA =00000000                M spdr4	=	op4
000115CA                            	spSustainLv	$01, $01, $0F, $00
000115CA =00000001                M spsl1	=	op1
000115CA =00000001                M spsl2	=	op2
000115CA =0000000F                M spsl3	=	op3
000115CA =00000000                M spsl4	=	op4
000115CA                            	spReleaseRt	$03, $03, $0A, $0A
000115CA =00000003                M sprr1	=	op1
000115CA =00000003                M sprr2	=	op2
000115CA =0000000A                M sprr3	=	op3
000115CA =0000000A                M sprr4	=	op4
000115CA                            	spSSGEG		$00, $00, $00, $00
000115CA =00000000                M spss1	=	op1
000115CA =00000000                M spss2	=	op2
000115CA =00000000                M spss3	=	op3
000115CA =00000000                M spss4	=	op4
000115CA                            	spTotalLv	$18, $27, $1E, $04
000115CA =00000018                M sptl1	=	op1
000115CA =00000027                M sptl2	=	op2
000115CA =0000001E                M sptl3	=	op3
000115CA =00000004                M sptl4	=	op4
000115CA 3A                       M 	dc.b	(spfe<<3)+spal
000115CB =00000080                M sptlmask4	set	$80
000115CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000115CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000115CB =00000000                M sptlmask1	set	((spal=7)<<7)
000115CB 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115CF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115D3 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115D7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115DB 13FA 130A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115E3 181E 2784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115E7 4E41 54                  M 	dc.b	'NAT'
000115EA                            
000115EA                            	; Patch $3A
000115EA                            	; $24
000115EA                            	; $7D, $35, $3D, $75,	$1F, $1F, $1F, $1F
000115EA                            	; $01, $0D, $01, $0D,	$10, $12, $10, $12
000115EA                            	; $F5, $38, $F5, $38,	$00, $04, $00, $04
000115EA                            	spAlgorithm	$04
000115EA =0000003B                M spatnum	=	spatnum+1
000115EA =00000004                M spal	=	val
000115EA                            	spFeedback	$04
000115EA =00000004                M spfe	=	val
000115EA                            	spDetune	$07, $03, $03, $07
000115EA =00000007                M spde1	=	op1
000115EA =00000003                M spde2	=	op2
000115EA =00000003                M spde3	=	op3
000115EA =00000007                M spde4	=	op4
000115EA                            	spMultiple	$0D, $0D, $05, $05
000115EA =0000000D                M spmu1	=	op1
000115EA =0000000D                M spmu2	=	op2
000115EA =00000005                M spmu3	=	op3
000115EA =00000005                M spmu4	=	op4
000115EA                            	spRateScale	$00, $00, $00, $00
000115EA =00000000                M sprs1	=	op1
000115EA =00000000                M sprs2	=	op2
000115EA =00000000                M sprs3	=	op3
000115EA =00000000                M sprs4	=	op4
000115EA                            	spAttackRt	$1F, $1F, $1F, $1F
000115EA =0000001F                M spar1	=	op1
000115EA =0000001F                M spar2	=	op2
000115EA =0000001F                M spar3	=	op3
000115EA =0000001F                M spar4	=	op4
000115EA                            	spAmpMod	$00, $00, $00, $00
000115EA =00000000                M spam1	=	op1
000115EA =00000000                M spam2	=	op2
000115EA =00000000                M spam3	=	op3
000115EA =00000000                M spam4	=	op4
000115EA                            	spSustainRt	$01, $01, $0D, $0D
000115EA =00000001                M spsr1	=	op1
000115EA =00000001                M spsr2	=	op2
000115EA =0000000D                M spsr3	=	op3
000115EA =0000000D                M spsr4	=	op4
000115EA                            	spDecayRt	$10, $10, $12, $12
000115EA =00000010                M spdr1	=	op1
000115EA =00000010                M spdr2	=	op2
000115EA =00000012                M spdr3	=	op3
000115EA =00000012                M spdr4	=	op4
000115EA                            	spSustainLv	$0F, $0F, $03, $03
000115EA =0000000F                M spsl1	=	op1
000115EA =0000000F                M spsl2	=	op2
000115EA =00000003                M spsl3	=	op3
000115EA =00000003                M spsl4	=	op4
000115EA                            	spReleaseRt	$05, $05, $08, $08
000115EA =00000005                M sprr1	=	op1
000115EA =00000005                M sprr2	=	op2
000115EA =00000008                M sprr3	=	op3
000115EA =00000008                M sprr4	=	op4
000115EA                            	spSSGEG		$00, $00, $00, $00
000115EA =00000000                M spss1	=	op1
000115EA =00000000                M spss2	=	op2
000115EA =00000000                M spss3	=	op3
000115EA =00000000                M spss4	=	op4
000115EA                            	spTotalLv	$00, $00, $04, $04
000115EA =00000000                M sptl1	=	op1
000115EA =00000000                M sptl2	=	op2
000115EA =00000004                M sptl3	=	op3
000115EA =00000004                M sptl4	=	op4
000115EA 24                       M 	dc.b	(spfe<<3)+spal
000115EB =00000080                M sptlmask4	set	$80
000115EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000115EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000115EB =00000000                M sptlmask1	set	((spal=7)<<7)
000115EB 7D35 3D75                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115EF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115F3 010D 010D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115F7 1012 1012                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115FB F538 F538                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011603 0084 0084                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011607 4E41 54                  M 	dc.b	'NAT'
0001160A                            
0001160A                            	; Patch $3B
0001160A                            	; $32
0001160A                            	; $2A, $61, $65, $23,	$94, $10, $54, $19
0001160A                            	; $85, $0B, $0E, $05,	$06, $04, $03, $03
0001160A                            	; $12, $14, $24, $27,	$2E, $0A, $1B, $05
0001160A                            	spAlgorithm	$02
0001160A =0000003C                M spatnum	=	spatnum+1
0001160A =00000002                M spal	=	val
0001160A                            	spFeedback	$06
0001160A =00000006                M spfe	=	val
0001160A                            	spDetune	$02, $06, $06, $02
0001160A =00000002                M spde1	=	op1
0001160A =00000006                M spde2	=	op2
0001160A =00000006                M spde3	=	op3
0001160A =00000002                M spde4	=	op4
0001160A                            	spMultiple	$0A, $05, $01, $03
0001160A =0000000A                M spmu1	=	op1
0001160A =00000005                M spmu2	=	op2
0001160A =00000001                M spmu3	=	op3
0001160A =00000003                M spmu4	=	op4
0001160A                            	spRateScale	$02, $01, $00, $00
0001160A =00000002                M sprs1	=	op1
0001160A =00000001                M sprs2	=	op2
0001160A =00000000                M sprs3	=	op3
0001160A =00000000                M sprs4	=	op4
0001160A                            	spAttackRt	$14, $14, $10, $19
0001160A =00000014                M spar1	=	op1
0001160A =00000014                M spar2	=	op2
0001160A =00000010                M spar3	=	op3
0001160A =00000019                M spar4	=	op4
0001160A                            	spAmpMod	$01, $00, $00, $00
0001160A =00000001                M spam1	=	op1
0001160A =00000000                M spam2	=	op2
0001160A =00000000                M spam3	=	op3
0001160A =00000000                M spam4	=	op4
0001160A                            	spSustainRt	$05, $0E, $0B, $05
0001160A =00000005                M spsr1	=	op1
0001160A =0000000E                M spsr2	=	op2
0001160A =0000000B                M spsr3	=	op3
0001160A =00000005                M spsr4	=	op4
0001160A                            	spDecayRt	$06, $03, $04, $03
0001160A =00000006                M spdr1	=	op1
0001160A =00000003                M spdr2	=	op2
0001160A =00000004                M spdr3	=	op3
0001160A =00000003                M spdr4	=	op4
0001160A                            	spSustainLv	$01, $02, $01, $02
0001160A =00000001                M spsl1	=	op1
0001160A =00000002                M spsl2	=	op2
0001160A =00000001                M spsl3	=	op3
0001160A =00000002                M spsl4	=	op4
0001160A                            	spReleaseRt	$02, $04, $04, $07
0001160A =00000002                M sprr1	=	op1
0001160A =00000004                M sprr2	=	op2
0001160A =00000004                M sprr3	=	op3
0001160A =00000007                M sprr4	=	op4
0001160A                            	spSSGEG		$00, $00, $00, $00
0001160A =00000000                M spss1	=	op1
0001160A =00000000                M spss2	=	op2
0001160A =00000000                M spss3	=	op3
0001160A =00000000                M spss4	=	op4
0001160A                            	spTotalLv	$2E, $1B, $0A, $05
0001160A =0000002E                M sptl1	=	op1
0001160A =0000001B                M sptl2	=	op2
0001160A =0000000A                M sptl3	=	op3
0001160A =00000005                M sptl4	=	op4
0001160A 32                       M 	dc.b	(spfe<<3)+spal
0001160B =00000080                M sptlmask4	set	$80
0001160B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001160B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001160B =00000000                M sptlmask1	set	((spal=7)<<7)
0001160B 2A61 6523                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001160F 9410 5419                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011613 850B 0E05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011617 0604 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001161B 1214 2427                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001161F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011623 2E0A 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011627 4E41 54                  M 	dc.b	'NAT'
0001162A                            
0001162A                            	; Patch $3C
0001162A                            	; $38
0001162A                            	; $71, $31, $71, $41,	$5F, $1F, $1F, $1F
0001162A                            	; $07, $06, $09, $1F,	$00, $00, $00, $00
0001162A                            	; $98, $9A, $09, $0C,	$1C, $1B, $1A, $04
0001162A                            	spAlgorithm	$00
0001162A =0000003D                M spatnum	=	spatnum+1
0001162A =00000000                M spal	=	val
0001162A                            	spFeedback	$07
0001162A =00000007                M spfe	=	val
0001162A                            	spDetune	$07, $07, $03, $04
0001162A =00000007                M spde1	=	op1
0001162A =00000007                M spde2	=	op2
0001162A =00000003                M spde3	=	op3
0001162A =00000004                M spde4	=	op4
0001162A                            	spMultiple	$01, $01, $01, $01
0001162A =00000001                M spmu1	=	op1
0001162A =00000001                M spmu2	=	op2
0001162A =00000001                M spmu3	=	op3
0001162A =00000001                M spmu4	=	op4
0001162A                            	spRateScale	$01, $00, $00, $00
0001162A =00000001                M sprs1	=	op1
0001162A =00000000                M sprs2	=	op2
0001162A =00000000                M sprs3	=	op3
0001162A =00000000                M sprs4	=	op4
0001162A                            	spAttackRt	$1F, $1F, $1F, $1F
0001162A =0000001F                M spar1	=	op1
0001162A =0000001F                M spar2	=	op2
0001162A =0000001F                M spar3	=	op3
0001162A =0000001F                M spar4	=	op4
0001162A                            	spAmpMod	$00, $00, $00, $00
0001162A =00000000                M spam1	=	op1
0001162A =00000000                M spam2	=	op2
0001162A =00000000                M spam3	=	op3
0001162A =00000000                M spam4	=	op4
0001162A                            	spSustainRt	$07, $09, $06, $1F
0001162A =00000007                M spsr1	=	op1
0001162A =00000009                M spsr2	=	op2
0001162A =00000006                M spsr3	=	op3
0001162A =0000001F                M spsr4	=	op4
0001162A                            	spDecayRt	$00, $00, $00, $00
0001162A =00000000                M spdr1	=	op1
0001162A =00000000                M spdr2	=	op2
0001162A =00000000                M spdr3	=	op3
0001162A =00000000                M spdr4	=	op4
0001162A                            	spSustainLv	$09, $00, $09, $00
0001162A =00000009                M spsl1	=	op1
0001162A =00000000                M spsl2	=	op2
0001162A =00000009                M spsl3	=	op3
0001162A =00000000                M spsl4	=	op4
0001162A                            	spReleaseRt	$08, $09, $0A, $0C
0001162A =00000008                M sprr1	=	op1
0001162A =00000009                M sprr2	=	op2
0001162A =0000000A                M sprr3	=	op3
0001162A =0000000C                M sprr4	=	op4
0001162A                            	spSSGEG		$00, $00, $00, $00
0001162A =00000000                M spss1	=	op1
0001162A =00000000                M spss2	=	op2
0001162A =00000000                M spss3	=	op3
0001162A =00000000                M spss4	=	op4
0001162A                            	spTotalLv	$1C, $1A, $1B, $04
0001162A =0000001C                M sptl1	=	op1
0001162A =0000001A                M sptl2	=	op2
0001162A =0000001B                M sptl3	=	op3
0001162A =00000004                M sptl4	=	op4
0001162A 38                       M 	dc.b	(spfe<<3)+spal
0001162B =00000080                M sptlmask4	set	$80
0001162B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001162B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001162B =00000000                M sptlmask1	set	((spal=7)<<7)
0001162B 7131 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001162F 5F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011633 0706 091F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011637 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001163B 989A 090C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001163F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011643 1C1B 1A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011647 4E41 54                  M 	dc.b	'NAT'
0001164A                            
0001164A                            	; Patch $3D
0001164A                            	; $02
0001164A                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
0001164A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001164A                            	; $01, $11, $31, $88,	$1C, $2D, $27, $05
0001164A                            	spAlgorithm	$02
0001164A =0000003E                M spatnum	=	spatnum+1
0001164A =00000002                M spal	=	val
0001164A                            	spFeedback	$00
0001164A =00000000                M spfe	=	val
0001164A                            	spDetune	$06, $00, $07, $03
0001164A =00000006                M spde1	=	op1
0001164A =00000000                M spde2	=	op2
0001164A =00000007                M spde3	=	op3
0001164A =00000003                M spde4	=	op4
0001164A                            	spMultiple	$01, $04, $0C, $01
0001164A =00000001                M spmu1	=	op1
0001164A =00000004                M spmu2	=	op2
0001164A =0000000C                M spmu3	=	op3
0001164A =00000001                M spmu4	=	op4
0001164A                            	spRateScale	$00, $02, $03, $01
0001164A =00000000                M sprs1	=	op1
0001164A =00000002                M sprs2	=	op2
0001164A =00000003                M sprs3	=	op3
0001164A =00000001                M sprs4	=	op4
0001164A                            	spAttackRt	$14, $0F, $10, $14
0001164A =00000014                M spar1	=	op1
0001164A =0000000F                M spar2	=	op2
0001164A =00000010                M spar3	=	op3
0001164A =00000014                M spar4	=	op4
0001164A                            	spAmpMod	$00, $00, $00, $00
0001164A =00000000                M spam1	=	op1
0001164A =00000000                M spam2	=	op2
0001164A =00000000                M spam3	=	op3
0001164A =00000000                M spam4	=	op4
0001164A                            	spSustainRt	$01, $05, $05, $08
0001164A =00000001                M spsr1	=	op1
0001164A =00000005                M spsr2	=	op2
0001164A =00000005                M spsr3	=	op3
0001164A =00000008                M spsr4	=	op4
0001164A                            	spDecayRt	$02, $05, $02, $1F
0001164A =00000002                M spdr1	=	op1
0001164A =00000005                M spdr2	=	op2
0001164A =00000002                M spdr3	=	op3
0001164A =0000001F                M spdr4	=	op4
0001164A                            	spSustainLv	$00, $03, $01, $08
0001164A =00000000                M spsl1	=	op1
0001164A =00000003                M spsl2	=	op2
0001164A =00000001                M spsl3	=	op3
0001164A =00000008                M spsl4	=	op4
0001164A                            	spReleaseRt	$01, $01, $01, $08
0001164A =00000001                M sprr1	=	op1
0001164A =00000001                M sprr2	=	op2
0001164A =00000001                M sprr3	=	op3
0001164A =00000008                M sprr4	=	op4
0001164A                            	spSSGEG		$00, $00, $00, $00
0001164A =00000000                M spss1	=	op1
0001164A =00000000                M spss2	=	op2
0001164A =00000000                M spss3	=	op3
0001164A =00000000                M spss4	=	op4
0001164A                            	spTotalLv	$1C, $27, $2D, $05
0001164A =0000001C                M sptl1	=	op1
0001164A =00000027                M sptl2	=	op2
0001164A =0000002D                M sptl3	=	op3
0001164A =00000005                M sptl4	=	op4
0001164A 02                       M 	dc.b	(spfe<<3)+spal
0001164B =00000080                M sptlmask4	set	$80
0001164B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001164B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001164B =00000000                M sptlmask1	set	((spal=7)<<7)
0001164B 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001164F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011653 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011657 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001165B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001165F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011663 1C2D 2785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011667 4E41 54                  M 	dc.b	'NAT'
0001166A                            
0001166A                            	; Patch $3E
0001166A                            	; $13
0001166A                            	; $01, $04, $00, $01,	$1C, $9D, $DE, $DF
0001166A                            	; $11, $0D, $02, $01,	$1F, $18, $0B, $01
0001166A                            	; $6F, $63, $FF, $3F,	$1E, $1C, $19, $05
0001166A                            	spAlgorithm	$03
0001166A =0000003F                M spatnum	=	spatnum+1
0001166A =00000003                M spal	=	val
0001166A                            	spFeedback	$02
0001166A =00000002                M spfe	=	val
0001166A                            	spDetune	$00, $00, $00, $00
0001166A =00000000                M spde1	=	op1
0001166A =00000000                M spde2	=	op2
0001166A =00000000                M spde3	=	op3
0001166A =00000000                M spde4	=	op4
0001166A                            	spMultiple	$01, $00, $04, $01
0001166A =00000001                M spmu1	=	op1
0001166A =00000000                M spmu2	=	op2
0001166A =00000004                M spmu3	=	op3
0001166A =00000001                M spmu4	=	op4
0001166A                            	spRateScale	$00, $03, $02, $03
0001166A =00000000                M sprs1	=	op1
0001166A =00000003                M sprs2	=	op2
0001166A =00000002                M sprs3	=	op3
0001166A =00000003                M sprs4	=	op4
0001166A                            	spAttackRt	$1C, $1E, $1D, $1F
0001166A =0000001C                M spar1	=	op1
0001166A =0000001E                M spar2	=	op2
0001166A =0000001D                M spar3	=	op3
0001166A =0000001F                M spar4	=	op4
0001166A                            	spAmpMod	$00, $00, $00, $00
0001166A =00000000                M spam1	=	op1
0001166A =00000000                M spam2	=	op2
0001166A =00000000                M spam3	=	op3
0001166A =00000000                M spam4	=	op4
0001166A                            	spSustainRt	$11, $02, $0D, $01
0001166A =00000011                M spsr1	=	op1
0001166A =00000002                M spsr2	=	op2
0001166A =0000000D                M spsr3	=	op3
0001166A =00000001                M spsr4	=	op4
0001166A                            	spDecayRt	$1F, $0B, $18, $01
0001166A =0000001F                M spdr1	=	op1
0001166A =0000000B                M spdr2	=	op2
0001166A =00000018                M spdr3	=	op3
0001166A =00000001                M spdr4	=	op4
0001166A                            	spSustainLv	$06, $0F, $06, $03
0001166A =00000006                M spsl1	=	op1
0001166A =0000000F                M spsl2	=	op2
0001166A =00000006                M spsl3	=	op3
0001166A =00000003                M spsl4	=	op4
0001166A                            	spReleaseRt	$0F, $0F, $03, $0F
0001166A =0000000F                M sprr1	=	op1
0001166A =0000000F                M sprr2	=	op2
0001166A =00000003                M sprr3	=	op3
0001166A =0000000F                M sprr4	=	op4
0001166A                            	spSSGEG		$00, $00, $00, $00
0001166A =00000000                M spss1	=	op1
0001166A =00000000                M spss2	=	op2
0001166A =00000000                M spss3	=	op3
0001166A =00000000                M spss4	=	op4
0001166A                            	spTotalLv	$1E, $19, $1C, $05
0001166A =0000001E                M sptl1	=	op1
0001166A =00000019                M sptl2	=	op2
0001166A =0000001C                M sptl3	=	op3
0001166A =00000005                M sptl4	=	op4
0001166A 13                       M 	dc.b	(spfe<<3)+spal
0001166B =00000080                M sptlmask4	set	$80
0001166B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001166B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001166B =00000000                M sptlmask1	set	((spal=7)<<7)
0001166B 0104 0001                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001166F 1C9D DEDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011673 110D 0201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011677 1F18 0B01                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001167B 6F63 FF3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001167F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011683 1E1C 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011687 4E41 54                  M 	dc.b	'NAT'
0001168A                            
0001168A                            	; Patch $3F
0001168A                            	; $17
0001168A                            	; $32, $72, $32, $12,	$C8, $88, $8C, $C8
0001168A                            	; $00, $13, $8C, $8D,	$01, $01, $01, $00
0001168A                            	; $08, $58, $A8, $78,	$04, $08, $09, $07
0001168A                            	spAlgorithm	$07
0001168A =00000040                M spatnum	=	spatnum+1
0001168A =00000007                M spal	=	val
0001168A                            	spFeedback	$02
0001168A =00000002                M spfe	=	val
0001168A                            	spDetune	$03, $03, $07, $01
0001168A =00000003                M spde1	=	op1
0001168A =00000003                M spde2	=	op2
0001168A =00000007                M spde3	=	op3
0001168A =00000001                M spde4	=	op4
0001168A                            	spMultiple	$02, $02, $02, $02
0001168A =00000002                M spmu1	=	op1
0001168A =00000002                M spmu2	=	op2
0001168A =00000002                M spmu3	=	op3
0001168A =00000002                M spmu4	=	op4
0001168A                            	spRateScale	$03, $02, $02, $03
0001168A =00000003                M sprs1	=	op1
0001168A =00000002                M sprs2	=	op2
0001168A =00000002                M sprs3	=	op3
0001168A =00000003                M sprs4	=	op4
0001168A                            	spAttackRt	$08, $0C, $08, $08
0001168A =00000008                M spar1	=	op1
0001168A =0000000C                M spar2	=	op2
0001168A =00000008                M spar3	=	op3
0001168A =00000008                M spar4	=	op4
0001168A                            	spAmpMod	$00, $01, $00, $01
0001168A =00000000                M spam1	=	op1
0001168A =00000001                M spam2	=	op2
0001168A =00000000                M spam3	=	op3
0001168A =00000001                M spam4	=	op4
0001168A                            	spSustainRt	$00, $0C, $13, $0D
0001168A =00000000                M spsr1	=	op1
0001168A =0000000C                M spsr2	=	op2
0001168A =00000013                M spsr3	=	op3
0001168A =0000000D                M spsr4	=	op4
0001168A                            	spDecayRt	$01, $01, $01, $00
0001168A =00000001                M spdr1	=	op1
0001168A =00000001                M spdr2	=	op2
0001168A =00000001                M spdr3	=	op3
0001168A =00000000                M spdr4	=	op4
0001168A                            	spSustainLv	$00, $0A, $05, $07
0001168A =00000000                M spsl1	=	op1
0001168A =0000000A                M spsl2	=	op2
0001168A =00000005                M spsl3	=	op3
0001168A =00000007                M spsl4	=	op4
0001168A                            	spReleaseRt	$08, $08, $08, $08
0001168A =00000008                M sprr1	=	op1
0001168A =00000008                M sprr2	=	op2
0001168A =00000008                M sprr3	=	op3
0001168A =00000008                M sprr4	=	op4
0001168A                            	spSSGEG		$00, $00, $00, $00
0001168A =00000000                M spss1	=	op1
0001168A =00000000                M spss2	=	op2
0001168A =00000000                M spss3	=	op3
0001168A =00000000                M spss4	=	op4
0001168A                            	spTotalLv	$04, $09, $08, $07
0001168A =00000004                M sptl1	=	op1
0001168A =00000009                M sptl2	=	op2
0001168A =00000008                M sptl3	=	op3
0001168A =00000007                M sptl4	=	op4
0001168A 17                       M 	dc.b	(spfe<<3)+spal
0001168B =00000080                M sptlmask4	set	$80
0001168B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001168B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001168B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001168B 3272 3212                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001168F C888 8CC8                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011693 0013 8C8D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011697 0101 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001169B 0858 A878                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001169F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116A3 8488 8987                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116A7 4E41 54                  M 	dc.b	'NAT'
000116AA                            
000116AA                            	; Patch $40
000116AA                            	; $3D
000116AA                            	; $01, $01, $01, $01,	$10, $50, $50, $50
000116AA                            	; $07, $08, $08, $08,	$01, $00, $00, $00
000116AA                            	; $20, $1A, $1A, $1A,	$19, $05, $05, $05
000116AA                            	spAlgorithm	$05
000116AA =00000041                M spatnum	=	spatnum+1
000116AA =00000005                M spal	=	val
000116AA                            	spFeedback	$07
000116AA =00000007                M spfe	=	val
000116AA                            	spDetune	$00, $00, $00, $00
000116AA =00000000                M spde1	=	op1
000116AA =00000000                M spde2	=	op2
000116AA =00000000                M spde3	=	op3
000116AA =00000000                M spde4	=	op4
000116AA                            	spMultiple	$01, $01, $01, $01
000116AA =00000001                M spmu1	=	op1
000116AA =00000001                M spmu2	=	op2
000116AA =00000001                M spmu3	=	op3
000116AA =00000001                M spmu4	=	op4
000116AA                            	spRateScale	$00, $01, $01, $01
000116AA =00000000                M sprs1	=	op1
000116AA =00000001                M sprs2	=	op2
000116AA =00000001                M sprs3	=	op3
000116AA =00000001                M sprs4	=	op4
000116AA                            	spAttackRt	$10, $10, $10, $10
000116AA =00000010                M spar1	=	op1
000116AA =00000010                M spar2	=	op2
000116AA =00000010                M spar3	=	op3
000116AA =00000010                M spar4	=	op4
000116AA                            	spAmpMod	$00, $00, $00, $00
000116AA =00000000                M spam1	=	op1
000116AA =00000000                M spam2	=	op2
000116AA =00000000                M spam3	=	op3
000116AA =00000000                M spam4	=	op4
000116AA                            	spSustainRt	$07, $08, $08, $08
000116AA =00000007                M spsr1	=	op1
000116AA =00000008                M spsr2	=	op2
000116AA =00000008                M spsr3	=	op3
000116AA =00000008                M spsr4	=	op4
000116AA                            	spDecayRt	$01, $00, $00, $00
000116AA =00000001                M spdr1	=	op1
000116AA =00000000                M spdr2	=	op2
000116AA =00000000                M spdr3	=	op3
000116AA =00000000                M spdr4	=	op4
000116AA                            	spSustainLv	$02, $01, $01, $01
000116AA =00000002                M spsl1	=	op1
000116AA =00000001                M spsl2	=	op2
000116AA =00000001                M spsl3	=	op3
000116AA =00000001                M spsl4	=	op4
000116AA                            	spReleaseRt	$00, $0A, $0A, $0A
000116AA =00000000                M sprr1	=	op1
000116AA =0000000A                M sprr2	=	op2
000116AA =0000000A                M sprr3	=	op3
000116AA =0000000A                M sprr4	=	op4
000116AA                            	spSSGEG		$00, $00, $00, $00
000116AA =00000000                M spss1	=	op1
000116AA =00000000                M spss2	=	op2
000116AA =00000000                M spss3	=	op3
000116AA =00000000                M spss4	=	op4
000116AA                            	spTotalLv	$19, $05, $05, $05
000116AA =00000019                M sptl1	=	op1
000116AA =00000005                M sptl2	=	op2
000116AA =00000005                M sptl3	=	op3
000116AA =00000005                M sptl4	=	op4
000116AA 3D                       M 	dc.b	(spfe<<3)+spal
000116AB =00000080                M sptlmask4	set	$80
000116AB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000116AB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116AB =00000000                M sptlmask1	set	((spal=7)<<7)
000116AB 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116AF 1050 5050                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116B3 0708 0808                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116B7 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116BB 201A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116C3 1985 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116C7 4E41 54                  M 	dc.b	'NAT'
000116CA                            
000116CA                            	; Patch $41
000116CA                            	; $3A
000116CA                            	; $03, $08, $03, $01,	$8E, $8E, $8D, $53
000116CA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000116CA                            	; $1F, $FF, $1F, $0F,	$17, $28, $20, $05
000116CA                            	spAlgorithm	$02
000116CA =00000042                M spatnum	=	spatnum+1
000116CA =00000002                M spal	=	val
000116CA                            	spFeedback	$07
000116CA =00000007                M spfe	=	val
000116CA                            	spDetune	$00, $00, $00, $00
000116CA =00000000                M spde1	=	op1
000116CA =00000000                M spde2	=	op2
000116CA =00000000                M spde3	=	op3
000116CA =00000000                M spde4	=	op4
000116CA                            	spMultiple	$03, $03, $08, $01
000116CA =00000003                M spmu1	=	op1
000116CA =00000003                M spmu2	=	op2
000116CA =00000008                M spmu3	=	op3
000116CA =00000001                M spmu4	=	op4
000116CA                            	spRateScale	$02, $02, $02, $01
000116CA =00000002                M sprs1	=	op1
000116CA =00000002                M sprs2	=	op2
000116CA =00000002                M sprs3	=	op3
000116CA =00000001                M sprs4	=	op4
000116CA                            	spAttackRt	$0E, $0D, $0E, $13
000116CA =0000000E                M spar1	=	op1
000116CA =0000000D                M spar2	=	op2
000116CA =0000000E                M spar3	=	op3
000116CA =00000013                M spar4	=	op4
000116CA                            	spAmpMod	$00, $00, $00, $00
000116CA =00000000                M spam1	=	op1
000116CA =00000000                M spam2	=	op2
000116CA =00000000                M spam3	=	op3
000116CA =00000000                M spam4	=	op4
000116CA                            	spSustainRt	$0E, $0E, $0E, $03
000116CA =0000000E                M spsr1	=	op1
000116CA =0000000E                M spsr2	=	op2
000116CA =0000000E                M spsr3	=	op3
000116CA =00000003                M spsr4	=	op4
000116CA                            	spDecayRt	$00, $00, $00, $00
000116CA =00000000                M spdr1	=	op1
000116CA =00000000                M spdr2	=	op2
000116CA =00000000                M spdr3	=	op3
000116CA =00000000                M spdr4	=	op4
000116CA                            	spSustainLv	$01, $01, $0F, $00
000116CA =00000001                M spsl1	=	op1
000116CA =00000001                M spsl2	=	op2
000116CA =0000000F                M spsl3	=	op3
000116CA =00000000                M spsl4	=	op4
000116CA                            	spReleaseRt	$0F, $0F, $0F, $0F
000116CA =0000000F                M sprr1	=	op1
000116CA =0000000F                M sprr2	=	op2
000116CA =0000000F                M sprr3	=	op3
000116CA =0000000F                M sprr4	=	op4
000116CA                            	spSSGEG		$00, $00, $00, $00
000116CA =00000000                M spss1	=	op1
000116CA =00000000                M spss2	=	op2
000116CA =00000000                M spss3	=	op3
000116CA =00000000                M spss4	=	op4
000116CA                            	spTotalLv	$17, $20, $28, $05
000116CA =00000017                M sptl1	=	op1
000116CA =00000020                M sptl2	=	op2
000116CA =00000028                M sptl3	=	op3
000116CA =00000005                M sptl4	=	op4
000116CA 3A                       M 	dc.b	(spfe<<3)+spal
000116CB =00000080                M sptlmask4	set	$80
000116CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000116CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000116CB =00000000                M sptlmask1	set	((spal=7)<<7)
000116CB 0308 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116CF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116D3 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116D7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116DB 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116E3 1728 2085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116E7 4E41 54                  M 	dc.b	'NAT'
000116EA                            
000116EA                            	; Patch $42
000116EA                            	; $07
000116EA                            	; $06, $7C, $75, $0A,	$1F, $1F, $1F, $1F
000116EA                            	; $00, $00, $00, $00,	$00, $00, $00, $00
000116EA                            	; $0F, $0F, $0F, $0F,	$07, $07, $07, $07
000116EA                            	spAlgorithm	$07
000116EA =00000043                M spatnum	=	spatnum+1
000116EA =00000007                M spal	=	val
000116EA                            	spFeedback	$00
000116EA =00000000                M spfe	=	val
000116EA                            	spDetune	$00, $07, $07, $00
000116EA =00000000                M spde1	=	op1
000116EA =00000007                M spde2	=	op2
000116EA =00000007                M spde3	=	op3
000116EA =00000000                M spde4	=	op4
000116EA                            	spMultiple	$06, $05, $0C, $0A
000116EA =00000006                M spmu1	=	op1
000116EA =00000005                M spmu2	=	op2
000116EA =0000000C                M spmu3	=	op3
000116EA =0000000A                M spmu4	=	op4
000116EA                            	spRateScale	$00, $00, $00, $00
000116EA =00000000                M sprs1	=	op1
000116EA =00000000                M sprs2	=	op2
000116EA =00000000                M sprs3	=	op3
000116EA =00000000                M sprs4	=	op4
000116EA                            	spAttackRt	$1F, $1F, $1F, $1F
000116EA =0000001F                M spar1	=	op1
000116EA =0000001F                M spar2	=	op2
000116EA =0000001F                M spar3	=	op3
000116EA =0000001F                M spar4	=	op4
000116EA                            	spAmpMod	$00, $00, $00, $00
000116EA =00000000                M spam1	=	op1
000116EA =00000000                M spam2	=	op2
000116EA =00000000                M spam3	=	op3
000116EA =00000000                M spam4	=	op4
000116EA                            	spSustainRt	$00, $00, $00, $00
000116EA =00000000                M spsr1	=	op1
000116EA =00000000                M spsr2	=	op2
000116EA =00000000                M spsr3	=	op3
000116EA =00000000                M spsr4	=	op4
000116EA                            	spDecayRt	$00, $00, $00, $00
000116EA =00000000                M spdr1	=	op1
000116EA =00000000                M spdr2	=	op2
000116EA =00000000                M spdr3	=	op3
000116EA =00000000                M spdr4	=	op4
000116EA                            	spSustainLv	$00, $00, $00, $00
000116EA =00000000                M spsl1	=	op1
000116EA =00000000                M spsl2	=	op2
000116EA =00000000                M spsl3	=	op3
000116EA =00000000                M spsl4	=	op4
000116EA                            	spReleaseRt	$0F, $0F, $0F, $0F
000116EA =0000000F                M sprr1	=	op1
000116EA =0000000F                M sprr2	=	op2
000116EA =0000000F                M sprr3	=	op3
000116EA =0000000F                M sprr4	=	op4
000116EA                            	spSSGEG		$00, $00, $00, $00
000116EA =00000000                M spss1	=	op1
000116EA =00000000                M spss2	=	op2
000116EA =00000000                M spss3	=	op3
000116EA =00000000                M spss4	=	op4
000116EA                            	spTotalLv	$07, $07, $07, $07
000116EA =00000007                M sptl1	=	op1
000116EA =00000007                M sptl2	=	op2
000116EA =00000007                M sptl3	=	op3
000116EA =00000007                M sptl4	=	op4
000116EA 07                       M 	dc.b	(spfe<<3)+spal
000116EB =00000080                M sptlmask4	set	$80
000116EB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000116EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116EB =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000116EB 067C 750A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116EF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116F3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116F7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116FB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011703 8787 8787                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011707 4E41 54                  M 	dc.b	'NAT'
0001170A                            
0001170A                            	; Patch $43
0001170A                            	; $3A
0001170A                            	; $01, $40, $01, $31,	$1F, $1F, $1F, $1F
0001170A                            	; $0B, $04, $04, $04,	$02, $04, $03, $02
0001170A                            	; $5F, $1F, $5F, $2F,	$18, $05, $11, $05
0001170A                            	spAlgorithm	$02
0001170A =00000044                M spatnum	=	spatnum+1
0001170A =00000002                M spal	=	val
0001170A                            	spFeedback	$07
0001170A =00000007                M spfe	=	val
0001170A                            	spDetune	$00, $00, $04, $03
0001170A =00000000                M spde1	=	op1
0001170A =00000000                M spde2	=	op2
0001170A =00000004                M spde3	=	op3
0001170A =00000003                M spde4	=	op4
0001170A                            	spMultiple	$01, $01, $00, $01
0001170A =00000001                M spmu1	=	op1
0001170A =00000001                M spmu2	=	op2
0001170A =00000000                M spmu3	=	op3
0001170A =00000001                M spmu4	=	op4
0001170A                            	spRateScale	$00, $00, $00, $00
0001170A =00000000                M sprs1	=	op1
0001170A =00000000                M sprs2	=	op2
0001170A =00000000                M sprs3	=	op3
0001170A =00000000                M sprs4	=	op4
0001170A                            	spAttackRt	$1F, $1F, $1F, $1F
0001170A =0000001F                M spar1	=	op1
0001170A =0000001F                M spar2	=	op2
0001170A =0000001F                M spar3	=	op3
0001170A =0000001F                M spar4	=	op4
0001170A                            	spAmpMod	$00, $00, $00, $00
0001170A =00000000                M spam1	=	op1
0001170A =00000000                M spam2	=	op2
0001170A =00000000                M spam3	=	op3
0001170A =00000000                M spam4	=	op4
0001170A                            	spSustainRt	$0B, $04, $04, $04
0001170A =0000000B                M spsr1	=	op1
0001170A =00000004                M spsr2	=	op2
0001170A =00000004                M spsr3	=	op3
0001170A =00000004                M spsr4	=	op4
0001170A                            	spDecayRt	$02, $03, $04, $02
0001170A =00000002                M spdr1	=	op1
0001170A =00000003                M spdr2	=	op2
0001170A =00000004                M spdr3	=	op3
0001170A =00000002                M spdr4	=	op4
0001170A                            	spSustainLv	$05, $05, $01, $02
0001170A =00000005                M spsl1	=	op1
0001170A =00000005                M spsl2	=	op2
0001170A =00000001                M spsl3	=	op3
0001170A =00000002                M spsl4	=	op4
0001170A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001170A =0000000F                M sprr1	=	op1
0001170A =0000000F                M sprr2	=	op2
0001170A =0000000F                M sprr3	=	op3
0001170A =0000000F                M sprr4	=	op4
0001170A                            	spSSGEG		$00, $00, $00, $00
0001170A =00000000                M spss1	=	op1
0001170A =00000000                M spss2	=	op2
0001170A =00000000                M spss3	=	op3
0001170A =00000000                M spss4	=	op4
0001170A                            	spTotalLv	$18, $11, $05, $05
0001170A =00000018                M sptl1	=	op1
0001170A =00000011                M sptl2	=	op2
0001170A =00000005                M sptl3	=	op3
0001170A =00000005                M sptl4	=	op4
0001170A 3A                       M 	dc.b	(spfe<<3)+spal
0001170B =00000080                M sptlmask4	set	$80
0001170B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001170B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001170B =00000000                M sptlmask1	set	((spal=7)<<7)
0001170B 0140 0131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001170F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011713 0B04 0404                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011717 0204 0302                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001171B 5F1F 5F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001171F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011723 1805 1185                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011727 4E41 54                  M 	dc.b	'NAT'
0001172A                            
0001172A                            	; Patch $44
0001172A                            	; $3C
0001172A                            	; $01, $01, $0E, $04,	$8D, $52, $9F, $1F
0001172A                            	; $09, $00, $00, $0D,	$00, $00, $00, $00
0001172A                            	; $23, $08, $02, $6F,	$15, $02, $10, $05
0001172A                            	spAlgorithm	$04
0001172A =00000045                M spatnum	=	spatnum+1
0001172A =00000004                M spal	=	val
0001172A                            	spFeedback	$07
0001172A =00000007                M spfe	=	val
0001172A                            	spDetune	$00, $00, $00, $00
0001172A =00000000                M spde1	=	op1
0001172A =00000000                M spde2	=	op2
0001172A =00000000                M spde3	=	op3
0001172A =00000000                M spde4	=	op4
0001172A                            	spMultiple	$01, $0E, $01, $04
0001172A =00000001                M spmu1	=	op1
0001172A =0000000E                M spmu2	=	op2
0001172A =00000001                M spmu3	=	op3
0001172A =00000004                M spmu4	=	op4
0001172A                            	spRateScale	$02, $02, $01, $00
0001172A =00000002                M sprs1	=	op1
0001172A =00000002                M sprs2	=	op2
0001172A =00000001                M sprs3	=	op3
0001172A =00000000                M sprs4	=	op4
0001172A                            	spAttackRt	$0D, $1F, $12, $1F
0001172A =0000000D                M spar1	=	op1
0001172A =0000001F                M spar2	=	op2
0001172A =00000012                M spar3	=	op3
0001172A =0000001F                M spar4	=	op4
0001172A                            	spAmpMod	$00, $00, $00, $00
0001172A =00000000                M spam1	=	op1
0001172A =00000000                M spam2	=	op2
0001172A =00000000                M spam3	=	op3
0001172A =00000000                M spam4	=	op4
0001172A                            	spSustainRt	$09, $00, $00, $0D
0001172A =00000009                M spsr1	=	op1
0001172A =00000000                M spsr2	=	op2
0001172A =00000000                M spsr3	=	op3
0001172A =0000000D                M spsr4	=	op4
0001172A                            	spDecayRt	$00, $00, $00, $00
0001172A =00000000                M spdr1	=	op1
0001172A =00000000                M spdr2	=	op2
0001172A =00000000                M spdr3	=	op3
0001172A =00000000                M spdr4	=	op4
0001172A                            	spSustainLv	$02, $00, $00, $06
0001172A =00000002                M spsl1	=	op1
0001172A =00000000                M spsl2	=	op2
0001172A =00000000                M spsl3	=	op3
0001172A =00000006                M spsl4	=	op4
0001172A                            	spReleaseRt	$03, $02, $08, $0F
0001172A =00000003                M sprr1	=	op1
0001172A =00000002                M sprr2	=	op2
0001172A =00000008                M sprr3	=	op3
0001172A =0000000F                M sprr4	=	op4
0001172A                            	spSSGEG		$00, $00, $00, $00
0001172A =00000000                M spss1	=	op1
0001172A =00000000                M spss2	=	op2
0001172A =00000000                M spss3	=	op3
0001172A =00000000                M spss4	=	op4
0001172A                            	spTotalLv	$15, $10, $02, $05
0001172A =00000015                M sptl1	=	op1
0001172A =00000010                M sptl2	=	op2
0001172A =00000002                M sptl3	=	op3
0001172A =00000005                M sptl4	=	op4
0001172A 3C                       M 	dc.b	(spfe<<3)+spal
0001172B =00000080                M sptlmask4	set	$80
0001172B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001172B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001172B =00000000                M sptlmask1	set	((spal=7)<<7)
0001172B 0101 0E04                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001172F 8D52 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011733 0900 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011737 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001173B 2308 026F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001173F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011743 1582 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011747 4E41 54                  M 	dc.b	'NAT'
0001174A                            
0001174A                            	; Patch $45
0001174A                            	; $04
0001174A                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
0001174A                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
0001174A                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
0001174A                            	spAlgorithm	$04
0001174A =00000046                M spatnum	=	spatnum+1
0001174A =00000004                M spal	=	val
0001174A                            	spFeedback	$00
0001174A =00000000                M spfe	=	val
0001174A                            	spDetune	$03, $07, $07, $04
0001174A =00000003                M spde1	=	op1
0001174A =00000007                M spde2	=	op2
0001174A =00000007                M spde3	=	op3
0001174A =00000004                M spde4	=	op4
0001174A                            	spMultiple	$07, $07, $02, $09
0001174A =00000007                M spmu1	=	op1
0001174A =00000007                M spmu2	=	op2
0001174A =00000002                M spmu3	=	op3
0001174A =00000009                M spmu4	=	op4
0001174A                            	spRateScale	$00, $00, $00, $00
0001174A =00000000                M sprs1	=	op1
0001174A =00000000                M sprs2	=	op2
0001174A =00000000                M sprs3	=	op3
0001174A =00000000                M sprs4	=	op4
0001174A                            	spAttackRt	$1F, $1F, $1F, $1F
0001174A =0000001F                M spar1	=	op1
0001174A =0000001F                M spar2	=	op2
0001174A =0000001F                M spar3	=	op3
0001174A =0000001F                M spar4	=	op4
0001174A                            	spAmpMod	$00, $00, $00, $00
0001174A =00000000                M spam1	=	op1
0001174A =00000000                M spam2	=	op2
0001174A =00000000                M spam3	=	op3
0001174A =00000000                M spam4	=	op4
0001174A                            	spSustainRt	$07, $07, $0A, $0D
0001174A =00000007                M spsr1	=	op1
0001174A =00000007                M spsr2	=	op2
0001174A =0000000A                M spsr3	=	op3
0001174A =0000000D                M spsr4	=	op4
0001174A                            	spDecayRt	$00, $00, $0B, $0B
0001174A =00000000                M spdr1	=	op1
0001174A =00000000                M spdr2	=	op2
0001174A =0000000B                M spdr3	=	op3
0001174A =0000000B                M spdr4	=	op4
0001174A                            	spSustainLv	$01, $01, $00, $00
0001174A =00000001                M spsl1	=	op1
0001174A =00000001                M spsl2	=	op2
0001174A =00000000                M spsl3	=	op3
0001174A =00000000                M spsl4	=	op4
0001174A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001174A =0000000F                M sprr1	=	op1
0001174A =0000000F                M sprr2	=	op2
0001174A =0000000F                M sprr3	=	op3
0001174A =0000000F                M sprr4	=	op4
0001174A                            	spSSGEG		$00, $00, $00, $00
0001174A =00000000                M spss1	=	op1
0001174A =00000000                M spss2	=	op2
0001174A =00000000                M spss3	=	op3
0001174A =00000000                M spss4	=	op4
0001174A                            	spTotalLv	$23, $23, $00, $00
0001174A =00000023                M sptl1	=	op1
0001174A =00000023                M sptl2	=	op2
0001174A =00000000                M sptl3	=	op3
0001174A =00000000                M sptl4	=	op4
0001174A 04                       M 	dc.b	(spfe<<3)+spal
0001174B =00000080                M sptlmask4	set	$80
0001174B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001174B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001174B =00000000                M sptlmask1	set	((spal=7)<<7)
0001174B 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001174F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011753 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011757 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001175B 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001175F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011763 2380 2380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011767 4E41 54                  M 	dc.b	'NAT'
0001176A                            
0001176A                            	; Patch $46
0001176A                            	; $3C
0001176A                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
0001176A                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
0001176A                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
0001176A                            	spAlgorithm	$04
0001176A =00000047                M spatnum	=	spatnum+1
0001176A =00000004                M spal	=	val
0001176A                            	spFeedback	$07
0001176A =00000007                M spfe	=	val
0001176A                            	spDetune	$03, $07, $07, $03
0001176A =00000003                M spde1	=	op1
0001176A =00000007                M spde2	=	op2
0001176A =00000007                M spde3	=	op3
0001176A =00000003                M spde4	=	op4
0001176A                            	spMultiple	$01, $01, $03, $01
0001176A =00000001                M spmu1	=	op1
0001176A =00000001                M spmu2	=	op2
0001176A =00000003                M spmu3	=	op3
0001176A =00000001                M spmu4	=	op4
0001176A                            	spRateScale	$00, $00, $02, $00
0001176A =00000000                M sprs1	=	op1
0001176A =00000000                M sprs2	=	op2
0001176A =00000002                M sprs3	=	op3
0001176A =00000000                M sprs4	=	op4
0001176A                            	spAttackRt	$10, $0A, $0C, $13
0001176A =00000010                M spar1	=	op1
0001176A =0000000A                M spar2	=	op2
0001176A =0000000C                M spar3	=	op3
0001176A =00000013                M spar4	=	op4
0001176A                            	spAmpMod	$00, $00, $00, $00
0001176A =00000000                M spam1	=	op1
0001176A =00000000                M spam2	=	op2
0001176A =00000000                M spam3	=	op3
0001176A =00000000                M spam4	=	op4
0001176A                            	spSustainRt	$00, $00, $00, $00
0001176A =00000000                M spsr1	=	op1
0001176A =00000000                M spsr2	=	op2
0001176A =00000000                M spsr3	=	op3
0001176A =00000000                M spsr4	=	op4
0001176A                            	spDecayRt	$00, $00, $0C, $03
0001176A =00000000                M spdr1	=	op1
0001176A =00000000                M spdr2	=	op2
0001176A =0000000C                M spdr3	=	op3
0001176A =00000003                M spdr4	=	op4
0001176A                            	spSustainLv	$00, $00, $00, $00
0001176A =00000000                M spsl1	=	op1
0001176A =00000000                M spsl2	=	op2
0001176A =00000000                M spsl3	=	op3
0001176A =00000000                M spsl4	=	op4
0001176A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001176A =0000000F                M sprr1	=	op1
0001176A =0000000F                M sprr2	=	op2
0001176A =0000000F                M sprr3	=	op3
0001176A =0000000F                M sprr4	=	op4
0001176A                            	spSSGEG		$00, $00, $00, $00
0001176A =00000000                M spss1	=	op1
0001176A =00000000                M spss2	=	op2
0001176A =00000000                M spss3	=	op3
0001176A =00000000                M spss4	=	op4
0001176A                            	spTotalLv	$20, $20, $00, $00
0001176A =00000020                M sptl1	=	op1
0001176A =00000020                M sptl2	=	op2
0001176A =00000000                M sptl3	=	op3
0001176A =00000000                M sptl4	=	op4
0001176A 3C                       M 	dc.b	(spfe<<3)+spal
0001176B =00000080                M sptlmask4	set	$80
0001176B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001176B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001176B =00000000                M sptlmask1	set	((spal=7)<<7)
0001176B 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001176F 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011773 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011777 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001177B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001177F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011783 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011787 4E41 54                  M 	dc.b	'NAT'
0001178A                            
0001178A                            	; Patch $47
0001178A                            	; $24
0001178A                            	; $00, $04, $01, $04,	$10, $19, $10, $0D
0001178A                            	; $00, $03, $00, $00,	$02, $00, $01, $00
0001178A                            	; $0A, $0C, $0D, $0C,	$08, $04, $0B, $05
0001178A                            	spAlgorithm	$04
0001178A =00000048                M spatnum	=	spatnum+1
0001178A =00000004                M spal	=	val
0001178A                            	spFeedback	$04
0001178A =00000004                M spfe	=	val
0001178A                            	spDetune	$00, $00, $00, $00
0001178A =00000000                M spde1	=	op1
0001178A =00000000                M spde2	=	op2
0001178A =00000000                M spde3	=	op3
0001178A =00000000                M spde4	=	op4
0001178A                            	spMultiple	$00, $01, $04, $04
0001178A =00000000                M spmu1	=	op1
0001178A =00000001                M spmu2	=	op2
0001178A =00000004                M spmu3	=	op3
0001178A =00000004                M spmu4	=	op4
0001178A                            	spRateScale	$00, $00, $00, $00
0001178A =00000000                M sprs1	=	op1
0001178A =00000000                M sprs2	=	op2
0001178A =00000000                M sprs3	=	op3
0001178A =00000000                M sprs4	=	op4
0001178A                            	spAttackRt	$10, $10, $19, $0D
0001178A =00000010                M spar1	=	op1
0001178A =00000010                M spar2	=	op2
0001178A =00000019                M spar3	=	op3
0001178A =0000000D                M spar4	=	op4
0001178A                            	spAmpMod	$00, $00, $00, $00
0001178A =00000000                M spam1	=	op1
0001178A =00000000                M spam2	=	op2
0001178A =00000000                M spam3	=	op3
0001178A =00000000                M spam4	=	op4
0001178A                            	spSustainRt	$00, $00, $03, $00
0001178A =00000000                M spsr1	=	op1
0001178A =00000000                M spsr2	=	op2
0001178A =00000003                M spsr3	=	op3
0001178A =00000000                M spsr4	=	op4
0001178A                            	spDecayRt	$02, $01, $00, $00
0001178A =00000002                M spdr1	=	op1
0001178A =00000001                M spdr2	=	op2
0001178A =00000000                M spdr3	=	op3
0001178A =00000000                M spdr4	=	op4
0001178A                            	spSustainLv	$00, $00, $00, $00
0001178A =00000000                M spsl1	=	op1
0001178A =00000000                M spsl2	=	op2
0001178A =00000000                M spsl3	=	op3
0001178A =00000000                M spsl4	=	op4
0001178A                            	spReleaseRt	$0A, $0D, $0C, $0C
0001178A =0000000A                M sprr1	=	op1
0001178A =0000000D                M sprr2	=	op2
0001178A =0000000C                M sprr3	=	op3
0001178A =0000000C                M sprr4	=	op4
0001178A                            	spSSGEG		$00, $00, $00, $00
0001178A =00000000                M spss1	=	op1
0001178A =00000000                M spss2	=	op2
0001178A =00000000                M spss3	=	op3
0001178A =00000000                M spss4	=	op4
0001178A                            	spTotalLv	$08, $0B, $04, $05
0001178A =00000008                M sptl1	=	op1
0001178A =0000000B                M sptl2	=	op2
0001178A =00000004                M sptl3	=	op3
0001178A =00000005                M sptl4	=	op4
0001178A 24                       M 	dc.b	(spfe<<3)+spal
0001178B =00000080                M sptlmask4	set	$80
0001178B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001178B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001178B =00000000                M sptlmask1	set	((spal=7)<<7)
0001178B 0004 0104                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001178F 1019 100D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011793 0003 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011797 0200 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001179B 0A0C 0D0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001179F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117A3 0884 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117A7 4E41 54                  M 	dc.b	'NAT'
000117AA                            
000117AA                            	; Patch $48
000117AA                            	; $22
000117AA                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
000117AA                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
000117AA                            	; $01, $11, $31, $88,	$19, $28, $24, $00
000117AA                            	spAlgorithm	$02
000117AA =00000049                M spatnum	=	spatnum+1
000117AA =00000002                M spal	=	val
000117AA                            	spFeedback	$04
000117AA =00000004                M spfe	=	val
000117AA                            	spDetune	$06, $00, $07, $03
000117AA =00000006                M spde1	=	op1
000117AA =00000000                M spde2	=	op2
000117AA =00000007                M spde3	=	op3
000117AA =00000003                M spde4	=	op4
000117AA                            	spMultiple	$01, $04, $0C, $01
000117AA =00000001                M spmu1	=	op1
000117AA =00000004                M spmu2	=	op2
000117AA =0000000C                M spmu3	=	op3
000117AA =00000001                M spmu4	=	op4
000117AA                            	spRateScale	$00, $02, $03, $01
000117AA =00000000                M sprs1	=	op1
000117AA =00000002                M sprs2	=	op2
000117AA =00000003                M sprs3	=	op3
000117AA =00000001                M sprs4	=	op4
000117AA                            	spAttackRt	$14, $0F, $10, $14
000117AA =00000014                M spar1	=	op1
000117AA =0000000F                M spar2	=	op2
000117AA =00000010                M spar3	=	op3
000117AA =00000014                M spar4	=	op4
000117AA                            	spAmpMod	$00, $00, $00, $00
000117AA =00000000                M spam1	=	op1
000117AA =00000000                M spam2	=	op2
000117AA =00000000                M spam3	=	op3
000117AA =00000000                M spam4	=	op4
000117AA                            	spSustainRt	$01, $05, $05, $08
000117AA =00000001                M spsr1	=	op1
000117AA =00000005                M spsr2	=	op2
000117AA =00000005                M spsr3	=	op3
000117AA =00000008                M spsr4	=	op4
000117AA                            	spDecayRt	$02, $05, $02, $1F
000117AA =00000002                M spdr1	=	op1
000117AA =00000005                M spdr2	=	op2
000117AA =00000002                M spdr3	=	op3
000117AA =0000001F                M spdr4	=	op4
000117AA                            	spSustainLv	$00, $03, $01, $08
000117AA =00000000                M spsl1	=	op1
000117AA =00000003                M spsl2	=	op2
000117AA =00000001                M spsl3	=	op3
000117AA =00000008                M spsl4	=	op4
000117AA                            	spReleaseRt	$01, $01, $01, $08
000117AA =00000001                M sprr1	=	op1
000117AA =00000001                M sprr2	=	op2
000117AA =00000001                M sprr3	=	op3
000117AA =00000008                M sprr4	=	op4
000117AA                            	spSSGEG		$00, $00, $00, $00
000117AA =00000000                M spss1	=	op1
000117AA =00000000                M spss2	=	op2
000117AA =00000000                M spss3	=	op3
000117AA =00000000                M spss4	=	op4
000117AA                            	spTotalLv	$19, $24, $28, $00
000117AA =00000019                M sptl1	=	op1
000117AA =00000024                M sptl2	=	op2
000117AA =00000028                M sptl3	=	op3
000117AA =00000000                M sptl4	=	op4
000117AA 22                       M 	dc.b	(spfe<<3)+spal
000117AB =00000080                M sptlmask4	set	$80
000117AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000117AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000117AB =00000000                M sptlmask1	set	((spal=7)<<7)
000117AB 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117AF 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117B3 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117B7 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117BB 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117C3 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117C7 4E41 54                  M 	dc.b	'NAT'
000117CA                            
000117CA                            	; Patch $49
000117CA                            	; $3B
000117CA                            	; $51, $71, $61, $41,	$51, $16, $18, $1A
000117CA                            	; $05, $01, $01, $00,	$09, $01, $01, $01
000117CA                            	; $17, $97, $27, $87,	$1C, $22, $15, $00
000117CA                            	spAlgorithm	$03
000117CA =0000004A                M spatnum	=	spatnum+1
000117CA =00000003                M spal	=	val
000117CA                            	spFeedback	$07
000117CA =00000007                M spfe	=	val
000117CA                            	spDetune	$05, $06, $07, $04
000117CA =00000005                M spde1	=	op1
000117CA =00000006                M spde2	=	op2
000117CA =00000007                M spde3	=	op3
000117CA =00000004                M spde4	=	op4
000117CA                            	spMultiple	$01, $01, $01, $01
000117CA =00000001                M spmu1	=	op1
000117CA =00000001                M spmu2	=	op2
000117CA =00000001                M spmu3	=	op3
000117CA =00000001                M spmu4	=	op4
000117CA                            	spRateScale	$01, $00, $00, $00
000117CA =00000001                M sprs1	=	op1
000117CA =00000000                M sprs2	=	op2
000117CA =00000000                M sprs3	=	op3
000117CA =00000000                M sprs4	=	op4
000117CA                            	spAttackRt	$11, $18, $16, $1A
000117CA =00000011                M spar1	=	op1
000117CA =00000018                M spar2	=	op2
000117CA =00000016                M spar3	=	op3
000117CA =0000001A                M spar4	=	op4
000117CA                            	spAmpMod	$00, $00, $00, $00
000117CA =00000000                M spam1	=	op1
000117CA =00000000                M spam2	=	op2
000117CA =00000000                M spam3	=	op3
000117CA =00000000                M spam4	=	op4
000117CA                            	spSustainRt	$05, $01, $01, $00
000117CA =00000005                M spsr1	=	op1
000117CA =00000001                M spsr2	=	op2
000117CA =00000001                M spsr3	=	op3
000117CA =00000000                M spsr4	=	op4
000117CA                            	spDecayRt	$09, $01, $01, $01
000117CA =00000009                M spdr1	=	op1
000117CA =00000001                M spdr2	=	op2
000117CA =00000001                M spdr3	=	op3
000117CA =00000001                M spdr4	=	op4
000117CA                            	spSustainLv	$01, $02, $09, $08
000117CA =00000001                M spsl1	=	op1
000117CA =00000002                M spsl2	=	op2
000117CA =00000009                M spsl3	=	op3
000117CA =00000008                M spsl4	=	op4
000117CA                            	spReleaseRt	$07, $07, $07, $07
000117CA =00000007                M sprr1	=	op1
000117CA =00000007                M sprr2	=	op2
000117CA =00000007                M sprr3	=	op3
000117CA =00000007                M sprr4	=	op4
000117CA                            	spSSGEG		$00, $00, $00, $00
000117CA =00000000                M spss1	=	op1
000117CA =00000000                M spss2	=	op2
000117CA =00000000                M spss3	=	op3
000117CA =00000000                M spss4	=	op4
000117CA                            	spTotalLv	$1C, $15, $22, $00
000117CA =0000001C                M sptl1	=	op1
000117CA =00000015                M sptl2	=	op2
000117CA =00000022                M sptl3	=	op3
000117CA =00000000                M sptl4	=	op4
000117CA 3B                       M 	dc.b	(spfe<<3)+spal
000117CB =00000080                M sptlmask4	set	$80
000117CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000117CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000117CB =00000000                M sptlmask1	set	((spal=7)<<7)
000117CB 5171 6141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117CF 5116 181A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117D3 0501 0100                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117D7 0901 0101                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117DB 1797 2787                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117E3 1C22 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117E7 4E41 54                  M 	dc.b	'NAT'
000117EA                            
000117EA                            	; Patch $4A
000117EA                            	; $32
000117EA                            	; $00, $01, $04, $04,	$1F, $16, $18, $1B
000117EA                            	; $08, $07, $07, $04,	$07, $08, $06, $1F
000117EA                            	; $04, $58, $05, $77,	$06, $05, $15, $00
000117EA                            	spAlgorithm	$02
000117EA =0000004B                M spatnum	=	spatnum+1
000117EA =00000002                M spal	=	val
000117EA                            	spFeedback	$06
000117EA =00000006                M spfe	=	val
000117EA                            	spDetune	$00, $00, $00, $00
000117EA =00000000                M spde1	=	op1
000117EA =00000000                M spde2	=	op2
000117EA =00000000                M spde3	=	op3
000117EA =00000000                M spde4	=	op4
000117EA                            	spMultiple	$00, $04, $01, $04
000117EA =00000000                M spmu1	=	op1
000117EA =00000004                M spmu2	=	op2
000117EA =00000001                M spmu3	=	op3
000117EA =00000004                M spmu4	=	op4
000117EA                            	spRateScale	$00, $00, $00, $00
000117EA =00000000                M sprs1	=	op1
000117EA =00000000                M sprs2	=	op2
000117EA =00000000                M sprs3	=	op3
000117EA =00000000                M sprs4	=	op4
000117EA                            	spAttackRt	$1F, $18, $16, $1B
000117EA =0000001F                M spar1	=	op1
000117EA =00000018                M spar2	=	op2
000117EA =00000016                M spar3	=	op3
000117EA =0000001B                M spar4	=	op4
000117EA                            	spAmpMod	$00, $00, $00, $00
000117EA =00000000                M spam1	=	op1
000117EA =00000000                M spam2	=	op2
000117EA =00000000                M spam3	=	op3
000117EA =00000000                M spam4	=	op4
000117EA                            	spSustainRt	$08, $07, $07, $04
000117EA =00000008                M spsr1	=	op1
000117EA =00000007                M spsr2	=	op2
000117EA =00000007                M spsr3	=	op3
000117EA =00000004                M spsr4	=	op4
000117EA                            	spDecayRt	$07, $06, $08, $1F
000117EA =00000007                M spdr1	=	op1
000117EA =00000006                M spdr2	=	op2
000117EA =00000008                M spdr3	=	op3
000117EA =0000001F                M spdr4	=	op4
000117EA                            	spSustainLv	$00, $00, $05, $07
000117EA =00000000                M spsl1	=	op1
000117EA =00000000                M spsl2	=	op2
000117EA =00000005                M spsl3	=	op3
000117EA =00000007                M spsl4	=	op4
000117EA                            	spReleaseRt	$04, $05, $08, $07
000117EA =00000004                M sprr1	=	op1
000117EA =00000005                M sprr2	=	op2
000117EA =00000008                M sprr3	=	op3
000117EA =00000007                M sprr4	=	op4
000117EA                            	spSSGEG		$00, $00, $00, $00
000117EA =00000000                M spss1	=	op1
000117EA =00000000                M spss2	=	op2
000117EA =00000000                M spss3	=	op3
000117EA =00000000                M spss4	=	op4
000117EA                            	spTotalLv	$06, $15, $05, $00
000117EA =00000006                M sptl1	=	op1
000117EA =00000015                M sptl2	=	op2
000117EA =00000005                M sptl3	=	op3
000117EA =00000000                M sptl4	=	op4
000117EA 32                       M 	dc.b	(spfe<<3)+spal
000117EB =00000080                M sptlmask4	set	$80
000117EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000117EB =00000000                M sptlmask3	set	((spal>=4)<<7)
000117EB =00000000                M sptlmask1	set	((spal=7)<<7)
000117EB 0001 0404                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117EF 1F16 181B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117F3 0807 0704                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117F7 0708 061F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117FB 0458 0577                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011803 0605 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011807 4E41 54                  M 	dc.b	'NAT'
0001180A                            
0001180A                            	; Patch $4B
0001180A                            	; $39
0001180A                            	; $01, $61, $00, $00,	$1F, $5F, $5F, $5F
0001180A                            	; $10, $11, $09, $09,	$1F, $1F, $1E, $1C
0001180A                            	; $FF, $FF, $FF, $FF,	$1C, $22, $1F, $02
0001180A                            	spAlgorithm	$01
0001180A =0000004C                M spatnum	=	spatnum+1
0001180A =00000001                M spal	=	val
0001180A                            	spFeedback	$07
0001180A =00000007                M spfe	=	val
0001180A                            	spDetune	$00, $00, $06, $00
0001180A =00000000                M spde1	=	op1
0001180A =00000000                M spde2	=	op2
0001180A =00000006                M spde3	=	op3
0001180A =00000000                M spde4	=	op4
0001180A                            	spMultiple	$01, $00, $01, $00
0001180A =00000001                M spmu1	=	op1
0001180A =00000000                M spmu2	=	op2
0001180A =00000001                M spmu3	=	op3
0001180A =00000000                M spmu4	=	op4
0001180A                            	spRateScale	$00, $01, $01, $01
0001180A =00000000                M sprs1	=	op1
0001180A =00000001                M sprs2	=	op2
0001180A =00000001                M sprs3	=	op3
0001180A =00000001                M sprs4	=	op4
0001180A                            	spAttackRt	$1F, $1F, $1F, $1F
0001180A =0000001F                M spar1	=	op1
0001180A =0000001F                M spar2	=	op2
0001180A =0000001F                M spar3	=	op3
0001180A =0000001F                M spar4	=	op4
0001180A                            	spAmpMod	$00, $00, $00, $00
0001180A =00000000                M spam1	=	op1
0001180A =00000000                M spam2	=	op2
0001180A =00000000                M spam3	=	op3
0001180A =00000000                M spam4	=	op4
0001180A                            	spSustainRt	$10, $09, $11, $09
0001180A =00000010                M spsr1	=	op1
0001180A =00000009                M spsr2	=	op2
0001180A =00000011                M spsr3	=	op3
0001180A =00000009                M spsr4	=	op4
0001180A                            	spDecayRt	$1F, $1E, $1F, $1C
0001180A =0000001F                M spdr1	=	op1
0001180A =0000001E                M spdr2	=	op2
0001180A =0000001F                M spdr3	=	op3
0001180A =0000001C                M spdr4	=	op4
0001180A                            	spSustainLv	$0F, $0F, $0F, $0F
0001180A =0000000F                M spsl1	=	op1
0001180A =0000000F                M spsl2	=	op2
0001180A =0000000F                M spsl3	=	op3
0001180A =0000000F                M spsl4	=	op4
0001180A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001180A =0000000F                M sprr1	=	op1
0001180A =0000000F                M sprr2	=	op2
0001180A =0000000F                M sprr3	=	op3
0001180A =0000000F                M sprr4	=	op4
0001180A                            	spSSGEG		$00, $00, $00, $00
0001180A =00000000                M spss1	=	op1
0001180A =00000000                M spss2	=	op2
0001180A =00000000                M spss3	=	op3
0001180A =00000000                M spss4	=	op4
0001180A                            	spTotalLv	$1C, $1F, $22, $02
0001180A =0000001C                M sptl1	=	op1
0001180A =0000001F                M sptl2	=	op2
0001180A =00000022                M sptl3	=	op3
0001180A =00000002                M sptl4	=	op4
0001180A 39                       M 	dc.b	(spfe<<3)+spal
0001180B =00000080                M sptlmask4	set	$80
0001180B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001180B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001180B =00000000                M sptlmask1	set	((spal=7)<<7)
0001180B 0161 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001180F 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011813 1011 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011817 1F1F 1E1C                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001181B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001181F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011823 1C22 1F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011827 4E41 54                  M 	dc.b	'NAT'
0001182A                            
0001182A                            	; Patch $4C
0001182A                            	; $27
0001182A                            	; $14, $30, $51, $62,	$5C, $5C, $5C, $5C
0001182A                            	; $00, $00, $00, $00,	$04, $1B, $04, $04
0001182A                            	; $FA, $F8, $F8, $FA,	$08, $08, $08, $08
0001182A                            	spAlgorithm	$07
0001182A =0000004D                M spatnum	=	spatnum+1
0001182A =00000007                M spal	=	val
0001182A                            	spFeedback	$04
0001182A =00000004                M spfe	=	val
0001182A                            	spDetune	$01, $05, $03, $06
0001182A =00000001                M spde1	=	op1
0001182A =00000005                M spde2	=	op2
0001182A =00000003                M spde3	=	op3
0001182A =00000006                M spde4	=	op4
0001182A                            	spMultiple	$04, $01, $00, $02
0001182A =00000004                M spmu1	=	op1
0001182A =00000001                M spmu2	=	op2
0001182A =00000000                M spmu3	=	op3
0001182A =00000002                M spmu4	=	op4
0001182A                            	spRateScale	$01, $01, $01, $01
0001182A =00000001                M sprs1	=	op1
0001182A =00000001                M sprs2	=	op2
0001182A =00000001                M sprs3	=	op3
0001182A =00000001                M sprs4	=	op4
0001182A                            	spAttackRt	$1C, $1C, $1C, $1C
0001182A =0000001C                M spar1	=	op1
0001182A =0000001C                M spar2	=	op2
0001182A =0000001C                M spar3	=	op3
0001182A =0000001C                M spar4	=	op4
0001182A                            	spAmpMod	$00, $00, $00, $00
0001182A =00000000                M spam1	=	op1
0001182A =00000000                M spam2	=	op2
0001182A =00000000                M spam3	=	op3
0001182A =00000000                M spam4	=	op4
0001182A                            	spSustainRt	$00, $00, $00, $00
0001182A =00000000                M spsr1	=	op1
0001182A =00000000                M spsr2	=	op2
0001182A =00000000                M spsr3	=	op3
0001182A =00000000                M spsr4	=	op4
0001182A                            	spDecayRt	$04, $04, $1B, $04
0001182A =00000004                M spdr1	=	op1
0001182A =00000004                M spdr2	=	op2
0001182A =0000001B                M spdr3	=	op3
0001182A =00000004                M spdr4	=	op4
0001182A                            	spSustainLv	$0F, $0F, $0F, $0F
0001182A =0000000F                M spsl1	=	op1
0001182A =0000000F                M spsl2	=	op2
0001182A =0000000F                M spsl3	=	op3
0001182A =0000000F                M spsl4	=	op4
0001182A                            	spReleaseRt	$0A, $08, $08, $0A
0001182A =0000000A                M sprr1	=	op1
0001182A =00000008                M sprr2	=	op2
0001182A =00000008                M sprr3	=	op3
0001182A =0000000A                M sprr4	=	op4
0001182A                            	spSSGEG		$00, $00, $00, $00
0001182A =00000000                M spss1	=	op1
0001182A =00000000                M spss2	=	op2
0001182A =00000000                M spss3	=	op3
0001182A =00000000                M spss4	=	op4
0001182A                            	spTotalLv	$08, $08, $08, $08
0001182A =00000008                M sptl1	=	op1
0001182A =00000008                M sptl2	=	op2
0001182A =00000008                M sptl3	=	op3
0001182A =00000008                M sptl4	=	op4
0001182A 27                       M 	dc.b	(spfe<<3)+spal
0001182B =00000080                M sptlmask4	set	$80
0001182B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001182B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001182B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001182B 1430 5162                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001182F 5C5C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011833 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011837 041B 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001183B FAF8 F8FA                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001183F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011843 8888 8888                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011847 4E41 54                  M 	dc.b	'NAT'
0001184A                            
0001184A                            	; Patch $4D
0001184A                            	; $26
0001184A                            	; $01, $02, $01, $00,	$11, $19, $10, $17
0001184A                            	; $01, $01, $03, $01,	$07, $04, $03, $03
0001184A                            	; $05, $45, $3A, $0A,	$0A, $02, $0E, $00
0001184A                            	spAlgorithm	$06
0001184A =0000004E                M spatnum	=	spatnum+1
0001184A =00000006                M spal	=	val
0001184A                            	spFeedback	$04
0001184A =00000004                M spfe	=	val
0001184A                            	spDetune	$00, $00, $00, $00
0001184A =00000000                M spde1	=	op1
0001184A =00000000                M spde2	=	op2
0001184A =00000000                M spde3	=	op3
0001184A =00000000                M spde4	=	op4
0001184A                            	spMultiple	$01, $01, $02, $00
0001184A =00000001                M spmu1	=	op1
0001184A =00000001                M spmu2	=	op2
0001184A =00000002                M spmu3	=	op3
0001184A =00000000                M spmu4	=	op4
0001184A                            	spRateScale	$00, $00, $00, $00
0001184A =00000000                M sprs1	=	op1
0001184A =00000000                M sprs2	=	op2
0001184A =00000000                M sprs3	=	op3
0001184A =00000000                M sprs4	=	op4
0001184A                            	spAttackRt	$11, $10, $19, $17
0001184A =00000011                M spar1	=	op1
0001184A =00000010                M spar2	=	op2
0001184A =00000019                M spar3	=	op3
0001184A =00000017                M spar4	=	op4
0001184A                            	spAmpMod	$00, $00, $00, $00
0001184A =00000000                M spam1	=	op1
0001184A =00000000                M spam2	=	op2
0001184A =00000000                M spam3	=	op3
0001184A =00000000                M spam4	=	op4
0001184A                            	spSustainRt	$01, $03, $01, $01
0001184A =00000001                M spsr1	=	op1
0001184A =00000003                M spsr2	=	op2
0001184A =00000001                M spsr3	=	op3
0001184A =00000001                M spsr4	=	op4
0001184A                            	spDecayRt	$07, $03, $04, $03
0001184A =00000007                M spdr1	=	op1
0001184A =00000003                M spdr2	=	op2
0001184A =00000004                M spdr3	=	op3
0001184A =00000003                M spdr4	=	op4
0001184A                            	spSustainLv	$00, $03, $04, $00
0001184A =00000000                M spsl1	=	op1
0001184A =00000003                M spsl2	=	op2
0001184A =00000004                M spsl3	=	op3
0001184A =00000000                M spsl4	=	op4
0001184A                            	spReleaseRt	$05, $0A, $05, $0A
0001184A =00000005                M sprr1	=	op1
0001184A =0000000A                M sprr2	=	op2
0001184A =00000005                M sprr3	=	op3
0001184A =0000000A                M sprr4	=	op4
0001184A                            	spSSGEG		$00, $00, $00, $00
0001184A =00000000                M spss1	=	op1
0001184A =00000000                M spss2	=	op2
0001184A =00000000                M spss3	=	op3
0001184A =00000000                M spss4	=	op4
0001184A                            	spTotalLv	$0A, $0E, $02, $00
0001184A =0000000A                M sptl1	=	op1
0001184A =0000000E                M sptl2	=	op2
0001184A =00000002                M sptl3	=	op3
0001184A =00000000                M sptl4	=	op4
0001184A 26                       M 	dc.b	(spfe<<3)+spal
0001184B =00000080                M sptlmask4	set	$80
0001184B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001184B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001184B =00000000                M sptlmask1	set	((spal=7)<<7)
0001184B 0102 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001184F 1119 1017                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011853 0101 0301                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011857 0704 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001185B 0545 3A0A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001185F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011863 0A82 8E80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011867 4E41 54                  M 	dc.b	'NAT'
0001186A                            
0001186A                            	; Patch $4E
0001186A                            	; $32
0001186A                            	; $30, $51, $72, $72,	$13, $18, $1F, $1F
0001186A                            	; $18, $1E, $1A, $05,	$05, $04, $02, $04
0001186A                            	; $25, $D5, $35, $25,	$15, $04, $1C, $00
0001186A                            	spAlgorithm	$02
0001186A =0000004F                M spatnum	=	spatnum+1
0001186A =00000002                M spal	=	val
0001186A                            	spFeedback	$06
0001186A =00000006                M spfe	=	val
0001186A                            	spDetune	$03, $07, $05, $07
0001186A =00000003                M spde1	=	op1
0001186A =00000007                M spde2	=	op2
0001186A =00000005                M spde3	=	op3
0001186A =00000007                M spde4	=	op4
0001186A                            	spMultiple	$00, $02, $01, $02
0001186A =00000000                M spmu1	=	op1
0001186A =00000002                M spmu2	=	op2
0001186A =00000001                M spmu3	=	op3
0001186A =00000002                M spmu4	=	op4
0001186A                            	spRateScale	$00, $00, $00, $00
0001186A =00000000                M sprs1	=	op1
0001186A =00000000                M sprs2	=	op2
0001186A =00000000                M sprs3	=	op3
0001186A =00000000                M sprs4	=	op4
0001186A                            	spAttackRt	$13, $1F, $18, $1F
0001186A =00000013                M spar1	=	op1
0001186A =0000001F                M spar2	=	op2
0001186A =00000018                M spar3	=	op3
0001186A =0000001F                M spar4	=	op4
0001186A                            	spAmpMod	$00, $00, $00, $00
0001186A =00000000                M spam1	=	op1
0001186A =00000000                M spam2	=	op2
0001186A =00000000                M spam3	=	op3
0001186A =00000000                M spam4	=	op4
0001186A                            	spSustainRt	$18, $1A, $1E, $05
0001186A =00000018                M spsr1	=	op1
0001186A =0000001A                M spsr2	=	op2
0001186A =0000001E                M spsr3	=	op3
0001186A =00000005                M spsr4	=	op4
0001186A                            	spDecayRt	$05, $02, $04, $04
0001186A =00000005                M spdr1	=	op1
0001186A =00000002                M spdr2	=	op2
0001186A =00000004                M spdr3	=	op3
0001186A =00000004                M spdr4	=	op4
0001186A                            	spSustainLv	$02, $03, $0D, $02
0001186A =00000002                M spsl1	=	op1
0001186A =00000003                M spsl2	=	op2
0001186A =0000000D                M spsl3	=	op3
0001186A =00000002                M spsl4	=	op4
0001186A                            	spReleaseRt	$05, $05, $05, $05
0001186A =00000005                M sprr1	=	op1
0001186A =00000005                M sprr2	=	op2
0001186A =00000005                M sprr3	=	op3
0001186A =00000005                M sprr4	=	op4
0001186A                            	spSSGEG		$00, $00, $00, $00
0001186A =00000000                M spss1	=	op1
0001186A =00000000                M spss2	=	op2
0001186A =00000000                M spss3	=	op3
0001186A =00000000                M spss4	=	op4
0001186A                            	spTotalLv	$15, $1C, $04, $00
0001186A =00000015                M sptl1	=	op1
0001186A =0000001C                M sptl2	=	op2
0001186A =00000004                M sptl3	=	op3
0001186A =00000000                M sptl4	=	op4
0001186A 32                       M 	dc.b	(spfe<<3)+spal
0001186B =00000080                M sptlmask4	set	$80
0001186B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001186B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001186B =00000000                M sptlmask1	set	((spal=7)<<7)
0001186B 3051 7272                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001186F 1318 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011873 181E 1A05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011877 0504 0204                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001187B 25D5 3525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001187F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011883 1504 1C80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011887 4E41 54                  M 	dc.b	'NAT'
0001188A                            
0001188A                            	; Patch $4F
0001188A                            	; $3E
0001188A                            	; $38, $01, $7A, $34,	$59, $D9, $5F, $9C
0001188A                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
0001188A                            	; $AF, $AF, $66, $66,	$28, $00, $23, $00
0001188A                            	spAlgorithm	$06
0001188A =00000050                M spatnum	=	spatnum+1
0001188A =00000006                M spal	=	val
0001188A                            	spFeedback	$07
0001188A =00000007                M spfe	=	val
0001188A                            	spDetune	$03, $07, $00, $03
0001188A =00000003                M spde1	=	op1
0001188A =00000007                M spde2	=	op2
0001188A =00000000                M spde3	=	op3
0001188A =00000003                M spde4	=	op4
0001188A                            	spMultiple	$08, $0A, $01, $04
0001188A =00000008                M spmu1	=	op1
0001188A =0000000A                M spmu2	=	op2
0001188A =00000001                M spmu3	=	op3
0001188A =00000004                M spmu4	=	op4
0001188A                            	spRateScale	$01, $01, $03, $02
0001188A =00000001                M sprs1	=	op1
0001188A =00000001                M sprs2	=	op2
0001188A =00000003                M sprs3	=	op3
0001188A =00000002                M sprs4	=	op4
0001188A                            	spAttackRt	$19, $1F, $19, $1C
0001188A =00000019                M spar1	=	op1
0001188A =0000001F                M spar2	=	op2
0001188A =00000019                M spar3	=	op3
0001188A =0000001C                M spar4	=	op4
0001188A                            	spAmpMod	$00, $00, $00, $00
0001188A =00000000                M spam1	=	op1
0001188A =00000000                M spam2	=	op2
0001188A =00000000                M spam3	=	op3
0001188A =00000000                M spam4	=	op4
0001188A                            	spSustainRt	$0F, $0F, $04, $0A
0001188A =0000000F                M spsr1	=	op1
0001188A =0000000F                M spsr2	=	op2
0001188A =00000004                M spsr3	=	op3
0001188A =0000000A                M spsr4	=	op4
0001188A                            	spDecayRt	$02, $05, $02, $05
0001188A =00000002                M spdr1	=	op1
0001188A =00000005                M spdr2	=	op2
0001188A =00000002                M spdr3	=	op3
0001188A =00000005                M spdr4	=	op4
0001188A                            	spSustainLv	$0A, $06, $0A, $06
0001188A =0000000A                M spsl1	=	op1
0001188A =00000006                M spsl2	=	op2
0001188A =0000000A                M spsl3	=	op3
0001188A =00000006                M spsl4	=	op4
0001188A                            	spReleaseRt	$0F, $06, $0F, $06
0001188A =0000000F                M sprr1	=	op1
0001188A =00000006                M sprr2	=	op2
0001188A =0000000F                M sprr3	=	op3
0001188A =00000006                M sprr4	=	op4
0001188A                            	spSSGEG		$00, $00, $00, $00
0001188A =00000000                M spss1	=	op1
0001188A =00000000                M spss2	=	op2
0001188A =00000000                M spss3	=	op3
0001188A =00000000                M spss4	=	op4
0001188A                            	spTotalLv	$28, $23, $00, $00
0001188A =00000028                M sptl1	=	op1
0001188A =00000023                M sptl2	=	op2
0001188A =00000000                M sptl3	=	op3
0001188A =00000000                M sptl4	=	op4
0001188A 3E                       M 	dc.b	(spfe<<3)+spal
0001188B =00000080                M sptlmask4	set	$80
0001188B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001188B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001188B =00000000                M sptlmask1	set	((spal=7)<<7)
0001188B 3801 7A34                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001188F 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011893 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011897 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001189B AFAF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001189F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118A3 2880 A380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118A7 4E41 54                  M 	dc.b	'NAT'
000118AA                            
000118AA                            	; Patch $50
000118AA                            	; $3A
000118AA                            	; $31, $37, $72, $02,	$0F, $0B, $0B, $8B
000118AA                            	; $04, $10, $09, $0A,	$00, $00, $03, $00
000118AA                            	; $19, $08, $08, $18,	$1E, $21, $37, $00
000118AA                            	spAlgorithm	$02
000118AA =00000051                M spatnum	=	spatnum+1
000118AA =00000002                M spal	=	val
000118AA                            	spFeedback	$07
000118AA =00000007                M spfe	=	val
000118AA                            	spDetune	$03, $07, $03, $00
000118AA =00000003                M spde1	=	op1
000118AA =00000007                M spde2	=	op2
000118AA =00000003                M spde3	=	op3
000118AA =00000000                M spde4	=	op4
000118AA                            	spMultiple	$01, $02, $07, $02
000118AA =00000001                M spmu1	=	op1
000118AA =00000002                M spmu2	=	op2
000118AA =00000007                M spmu3	=	op3
000118AA =00000002                M spmu4	=	op4
000118AA                            	spRateScale	$00, $00, $00, $02
000118AA =00000000                M sprs1	=	op1
000118AA =00000000                M sprs2	=	op2
000118AA =00000000                M sprs3	=	op3
000118AA =00000002                M sprs4	=	op4
000118AA                            	spAttackRt	$0F, $0B, $0B, $0B
000118AA =0000000F                M spar1	=	op1
000118AA =0000000B                M spar2	=	op2
000118AA =0000000B                M spar3	=	op3
000118AA =0000000B                M spar4	=	op4
000118AA                            	spAmpMod	$00, $00, $00, $00
000118AA =00000000                M spam1	=	op1
000118AA =00000000                M spam2	=	op2
000118AA =00000000                M spam3	=	op3
000118AA =00000000                M spam4	=	op4
000118AA                            	spSustainRt	$04, $09, $10, $0A
000118AA =00000004                M spsr1	=	op1
000118AA =00000009                M spsr2	=	op2
000118AA =00000010                M spsr3	=	op3
000118AA =0000000A                M spsr4	=	op4
000118AA                            	spDecayRt	$00, $03, $00, $00
000118AA =00000000                M spdr1	=	op1
000118AA =00000003                M spdr2	=	op2
000118AA =00000000                M spdr3	=	op3
000118AA =00000000                M spdr4	=	op4
000118AA                            	spSustainLv	$01, $00, $00, $01
000118AA =00000001                M spsl1	=	op1
000118AA =00000000                M spsl2	=	op2
000118AA =00000000                M spsl3	=	op3
000118AA =00000001                M spsl4	=	op4
000118AA                            	spReleaseRt	$09, $08, $08, $08
000118AA =00000009                M sprr1	=	op1
000118AA =00000008                M sprr2	=	op2
000118AA =00000008                M sprr3	=	op3
000118AA =00000008                M sprr4	=	op4
000118AA                            	spSSGEG		$00, $00, $00, $00
000118AA =00000000                M spss1	=	op1
000118AA =00000000                M spss2	=	op2
000118AA =00000000                M spss3	=	op3
000118AA =00000000                M spss4	=	op4
000118AA                            	spTotalLv	$1E, $37, $21, $00
000118AA =0000001E                M sptl1	=	op1
000118AA =00000037                M sptl2	=	op2
000118AA =00000021                M sptl3	=	op3
000118AA =00000000                M sptl4	=	op4
000118AA 3A                       M 	dc.b	(spfe<<3)+spal
000118AB =00000080                M sptlmask4	set	$80
000118AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000118AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000118AB =00000000                M sptlmask1	set	((spal=7)<<7)
000118AB 3137 7202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118AF 0F0B 0B8B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118B3 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118B7 0000 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118BB 1908 0818                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118C3 1E21 3780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118C7 4E41 54                  M 	dc.b	'NAT'
000118CA                            
000118CA                            	; Patch $51
000118CA                            	; $3D
000118CA                            	; $0A, $06, $06, $06,	$1F, $0C, $0C, $0C
000118CA                            	; $00, $09, $09, $01,	$01, $02, $05, $01
000118CA                            	; $F6, $F8, $F7, $F7,	$00, $00, $00, $00
000118CA                            	spAlgorithm	$05
000118CA =00000052                M spatnum	=	spatnum+1
000118CA =00000005                M spal	=	val
000118CA                            	spFeedback	$07
000118CA =00000007                M spfe	=	val
000118CA                            	spDetune	$00, $00, $00, $00
000118CA =00000000                M spde1	=	op1
000118CA =00000000                M spde2	=	op2
000118CA =00000000                M spde3	=	op3
000118CA =00000000                M spde4	=	op4
000118CA                            	spMultiple	$0A, $06, $06, $06
000118CA =0000000A                M spmu1	=	op1
000118CA =00000006                M spmu2	=	op2
000118CA =00000006                M spmu3	=	op3
000118CA =00000006                M spmu4	=	op4
000118CA                            	spRateScale	$00, $00, $00, $00
000118CA =00000000                M sprs1	=	op1
000118CA =00000000                M sprs2	=	op2
000118CA =00000000                M sprs3	=	op3
000118CA =00000000                M sprs4	=	op4
000118CA                            	spAttackRt	$1F, $0C, $0C, $0C
000118CA =0000001F                M spar1	=	op1
000118CA =0000000C                M spar2	=	op2
000118CA =0000000C                M spar3	=	op3
000118CA =0000000C                M spar4	=	op4
000118CA                            	spAmpMod	$00, $00, $00, $00
000118CA =00000000                M spam1	=	op1
000118CA =00000000                M spam2	=	op2
000118CA =00000000                M spam3	=	op3
000118CA =00000000                M spam4	=	op4
000118CA                            	spSustainRt	$00, $09, $09, $01
000118CA =00000000                M spsr1	=	op1
000118CA =00000009                M spsr2	=	op2
000118CA =00000009                M spsr3	=	op3
000118CA =00000001                M spsr4	=	op4
000118CA                            	spSustainLv	$0F, $0F, $0F, $0F
000118CA =0000000F                M spsl1	=	op1
000118CA =0000000F                M spsl2	=	op2
000118CA =0000000F                M spsl3	=	op3
000118CA =0000000F                M spsl4	=	op4
000118CA                            	spDecayRt	$01, $05, $02, $01
000118CA =00000001                M spdr1	=	op1
000118CA =00000005                M spdr2	=	op2
000118CA =00000002                M spdr3	=	op3
000118CA =00000001                M spdr4	=	op4
000118CA                            	spReleaseRt	$06, $07, $08, $07
000118CA =00000006                M sprr1	=	op1
000118CA =00000007                M sprr2	=	op2
000118CA =00000008                M sprr3	=	op3
000118CA =00000007                M sprr4	=	op4
000118CA                            	spSSGEG		$00, $00, $00, $00
000118CA =00000000                M spss1	=	op1
000118CA =00000000                M spss2	=	op2
000118CA =00000000                M spss3	=	op3
000118CA =00000000                M spss4	=	op4
000118CA                            	spTotalLv	$00, $00, $00, $00
000118CA =00000000                M sptl1	=	op1
000118CA =00000000                M sptl2	=	op2
000118CA =00000000                M sptl3	=	op3
000118CA =00000000                M sptl4	=	op4
000118CA 3D                       M 	dc.b	(spfe<<3)+spal
000118CB =00000080                M sptlmask4	set	$80
000118CB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000118CB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000118CB =00000000                M sptlmask1	set	((spal=7)<<7)
000118CB 0A06 0606                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118CF 1F0C 0C0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118D3 0009 0901                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118D7 0102 0501                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118DB F6F8 F7F7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118E3 0080 8080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118E7 4E41 54                  M 	dc.b	'NAT'
000118EA                            
000118EA                            	; Patch $52
000118EA                            	; $3C
000118EA                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
000118EA                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
000118EA                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
000118EA                            	spAlgorithm	$04
000118EA =00000053                M spatnum	=	spatnum+1
000118EA =00000004                M spal	=	val
000118EA                            	spFeedback	$07
000118EA =00000007                M spfe	=	val
000118EA                            	spDetune	$03, $07, $07, $03
000118EA =00000003                M spde1	=	op1
000118EA =00000007                M spde2	=	op2
000118EA =00000007                M spde3	=	op3
000118EA =00000003                M spde4	=	op4
000118EA                            	spMultiple	$01, $01, $03, $01
000118EA =00000001                M spmu1	=	op1
000118EA =00000001                M spmu2	=	op2
000118EA =00000003                M spmu3	=	op3
000118EA =00000001                M spmu4	=	op4
000118EA                            	spRateScale	$00, $00, $02, $00
000118EA =00000000                M sprs1	=	op1
000118EA =00000000                M sprs2	=	op2
000118EA =00000002                M sprs3	=	op3
000118EA =00000000                M sprs4	=	op4
000118EA                            	spAttackRt	$10, $0A, $0C, $13
000118EA =00000010                M spar1	=	op1
000118EA =0000000A                M spar2	=	op2
000118EA =0000000C                M spar3	=	op3
000118EA =00000013                M spar4	=	op4
000118EA                            	spAmpMod	$00, $00, $00, $00
000118EA =00000000                M spam1	=	op1
000118EA =00000000                M spam2	=	op2
000118EA =00000000                M spam3	=	op3
000118EA =00000000                M spam4	=	op4
000118EA                            	spSustainRt	$00, $00, $00, $00
000118EA =00000000                M spsr1	=	op1
000118EA =00000000                M spsr2	=	op2
000118EA =00000000                M spsr3	=	op3
000118EA =00000000                M spsr4	=	op4
000118EA                            	spSustainLv	$00, $00, $00, $00
000118EA =00000000                M spsl1	=	op1
000118EA =00000000                M spsl2	=	op2
000118EA =00000000                M spsl3	=	op3
000118EA =00000000                M spsl4	=	op4
000118EA                            	spDecayRt	$00, $00, $0C, $03
000118EA =00000000                M spdr1	=	op1
000118EA =00000000                M spdr2	=	op2
000118EA =0000000C                M spdr3	=	op3
000118EA =00000003                M spdr4	=	op4
000118EA                            	spReleaseRt	$0F, $0F, $0F, $0F
000118EA =0000000F                M sprr1	=	op1
000118EA =0000000F                M sprr2	=	op2
000118EA =0000000F                M sprr3	=	op3
000118EA =0000000F                M sprr4	=	op4
000118EA                            	spSSGEG		$00, $00, $00, $00
000118EA =00000000                M spss1	=	op1
000118EA =00000000                M spss2	=	op2
000118EA =00000000                M spss3	=	op3
000118EA =00000000                M spss4	=	op4
000118EA                            	spTotalLv	$20, $20, $00, $00
000118EA =00000020                M sptl1	=	op1
000118EA =00000020                M sptl2	=	op2
000118EA =00000000                M sptl3	=	op3
000118EA =00000000                M sptl4	=	op4
000118EA 3C                       M 	dc.b	(spfe<<3)+spal
000118EB =00000080                M sptlmask4	set	$80
000118EB =00000000                M sptlmask2	set	((spal>=5)<<7)
000118EB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000118EB =00000000                M sptlmask1	set	((spal=7)<<7)
000118EB 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118EF 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118F3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118F7 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118FB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011903 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011907 4E41 54                  M 	dc.b	'NAT'
0001190A                            
0001190A                            	; Patch $53
0001190A                            	; $3C
0001190A                            	; $33, $41, $7F, $74,	$5B, $9F, $5F, $1F
0001190A                            	; $04, $07, $07, $08,	$00, $00, $00, $00
0001190A                            	; $A7, $C6, $C9, $D9,	$21, $00, $2D, $06
0001190A                            	spAlgorithm	$04
0001190A =00000054                M spatnum	=	spatnum+1
0001190A =00000004                M spal	=	val
0001190A                            	spFeedback	$07
0001190A =00000007                M spfe	=	val
0001190A                            	spDetune	$03, $07, $04, $07
0001190A =00000003                M spde1	=	op1
0001190A =00000007                M spde2	=	op2
0001190A =00000004                M spde3	=	op3
0001190A =00000007                M spde4	=	op4
0001190A                            	spMultiple	$03, $0F, $01, $04
0001190A =00000003                M spmu1	=	op1
0001190A =0000000F                M spmu2	=	op2
0001190A =00000001                M spmu3	=	op3
0001190A =00000004                M spmu4	=	op4
0001190A                            	spRateScale	$01, $01, $02, $00
0001190A =00000001                M sprs1	=	op1
0001190A =00000001                M sprs2	=	op2
0001190A =00000002                M sprs3	=	op3
0001190A =00000000                M sprs4	=	op4
0001190A                            	spAttackRt	$1B, $1F, $1F, $1F
0001190A =0000001B                M spar1	=	op1
0001190A =0000001F                M spar2	=	op2
0001190A =0000001F                M spar3	=	op3
0001190A =0000001F                M spar4	=	op4
0001190A                            	spAmpMod	$00, $00, $00, $00
0001190A =00000000                M spam1	=	op1
0001190A =00000000                M spam2	=	op2
0001190A =00000000                M spam3	=	op3
0001190A =00000000                M spam4	=	op4
0001190A                            	spSustainRt	$04, $07, $07, $08
0001190A =00000004                M spsr1	=	op1
0001190A =00000007                M spsr2	=	op2
0001190A =00000007                M spsr3	=	op3
0001190A =00000008                M spsr4	=	op4
0001190A                            	spSustainLv	$0A, $0C, $0C, $0D
0001190A =0000000A                M spsl1	=	op1
0001190A =0000000C                M spsl2	=	op2
0001190A =0000000C                M spsl3	=	op3
0001190A =0000000D                M spsl4	=	op4
0001190A                            	spDecayRt	$00, $00, $00, $00
0001190A =00000000                M spdr1	=	op1
0001190A =00000000                M spdr2	=	op2
0001190A =00000000                M spdr3	=	op3
0001190A =00000000                M spdr4	=	op4
0001190A                            	spReleaseRt	$07, $09, $06, $09
0001190A =00000007                M sprr1	=	op1
0001190A =00000009                M sprr2	=	op2
0001190A =00000006                M sprr3	=	op3
0001190A =00000009                M sprr4	=	op4
0001190A                            	spSSGEG		$00, $00, $00, $00
0001190A =00000000                M spss1	=	op1
0001190A =00000000                M spss2	=	op2
0001190A =00000000                M spss3	=	op3
0001190A =00000000                M spss4	=	op4
0001190A                            	spTotalLv	$21, $2D, $00, $06
0001190A =00000021                M sptl1	=	op1
0001190A =0000002D                M sptl2	=	op2
0001190A =00000000                M sptl3	=	op3
0001190A =00000006                M sptl4	=	op4
0001190A 3C                       M 	dc.b	(spfe<<3)+spal
0001190B =00000080                M sptlmask4	set	$80
0001190B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001190B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001190B =00000000                M sptlmask1	set	((spal=7)<<7)
0001190B 3341 7F74                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001190F 5B9F 5F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011913 0407 0708                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011917 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001191B A7C6 C9D9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001191F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011923 2180 2D86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011927 4E41 54                  M 	dc.b	'NAT'
0001192A                            
0001192A                            	; Patch $54
0001192A                            	; $22
0001192A                            	; $61, $77, $02, $31,	$14, $D0, $8F, $54
0001192A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001192A                            	; $01, $11, $31, $88,	$19, $28, $20, $00
0001192A                            	spAlgorithm	$02
0001192A =00000055                M spatnum	=	spatnum+1
0001192A =00000002                M spal	=	val
0001192A                            	spFeedback	$04
0001192A =00000004                M spfe	=	val
0001192A                            	spDetune	$06, $00, $07, $03
0001192A =00000006                M spde1	=	op1
0001192A =00000000                M spde2	=	op2
0001192A =00000007                M spde3	=	op3
0001192A =00000003                M spde4	=	op4
0001192A                            	spMultiple	$01, $02, $07, $01
0001192A =00000001                M spmu1	=	op1
0001192A =00000002                M spmu2	=	op2
0001192A =00000007                M spmu3	=	op3
0001192A =00000001                M spmu4	=	op4
0001192A                            	spRateScale	$00, $02, $03, $01
0001192A =00000000                M sprs1	=	op1
0001192A =00000002                M sprs2	=	op2
0001192A =00000003                M sprs3	=	op3
0001192A =00000001                M sprs4	=	op4
0001192A                            	spAttackRt	$14, $0F, $10, $14
0001192A =00000014                M spar1	=	op1
0001192A =0000000F                M spar2	=	op2
0001192A =00000010                M spar3	=	op3
0001192A =00000014                M spar4	=	op4
0001192A                            	spAmpMod	$00, $00, $00, $00
0001192A =00000000                M spam1	=	op1
0001192A =00000000                M spam2	=	op2
0001192A =00000000                M spam3	=	op3
0001192A =00000000                M spam4	=	op4
0001192A                            	spSustainRt	$01, $05, $05, $08
0001192A =00000001                M spsr1	=	op1
0001192A =00000005                M spsr2	=	op2
0001192A =00000005                M spsr3	=	op3
0001192A =00000008                M spsr4	=	op4
0001192A                            	spSustainLv	$00, $03, $01, $08
0001192A =00000000                M spsl1	=	op1
0001192A =00000003                M spsl2	=	op2
0001192A =00000001                M spsl3	=	op3
0001192A =00000008                M spsl4	=	op4
0001192A                            	spDecayRt	$02, $05, $02, $1F
0001192A =00000002                M spdr1	=	op1
0001192A =00000005                M spdr2	=	op2
0001192A =00000002                M spdr3	=	op3
0001192A =0000001F                M spdr4	=	op4
0001192A                            	spReleaseRt	$01, $01, $01, $08
0001192A =00000001                M sprr1	=	op1
0001192A =00000001                M sprr2	=	op2
0001192A =00000001                M sprr3	=	op3
0001192A =00000008                M sprr4	=	op4
0001192A                            	spSSGEG		$00, $00, $00, $00
0001192A =00000000                M spss1	=	op1
0001192A =00000000                M spss2	=	op2
0001192A =00000000                M spss3	=	op3
0001192A =00000000                M spss4	=	op4
0001192A                            	spTotalLv	$19, $20, $28, $00
0001192A =00000019                M sptl1	=	op1
0001192A =00000020                M sptl2	=	op2
0001192A =00000028                M sptl3	=	op3
0001192A =00000000                M sptl4	=	op4
0001192A 22                       M 	dc.b	(spfe<<3)+spal
0001192B =00000080                M sptlmask4	set	$80
0001192B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001192B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001192B =00000000                M sptlmask1	set	((spal=7)<<7)
0001192B 6177 0231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001192F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011933 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011937 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001193B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001193F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011943 1928 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011947 4E41 54                  M 	dc.b	'NAT'
0001194A                            
0001194A                            	; Patch $55
0001194A                            	; $22
0001194A                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
0001194A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001194A                            	; $01, $11, $31, $88,	$19, $28, $24, $00
0001194A                            	spAlgorithm	$02
0001194A =00000056                M spatnum	=	spatnum+1
0001194A =00000002                M spal	=	val
0001194A                            	spFeedback	$04
0001194A =00000004                M spfe	=	val
0001194A                            	spDetune	$06, $00, $07, $03
0001194A =00000006                M spde1	=	op1
0001194A =00000000                M spde2	=	op2
0001194A =00000007                M spde3	=	op3
0001194A =00000003                M spde4	=	op4
0001194A                            	spMultiple	$01, $04, $0C, $01
0001194A =00000001                M spmu1	=	op1
0001194A =00000004                M spmu2	=	op2
0001194A =0000000C                M spmu3	=	op3
0001194A =00000001                M spmu4	=	op4
0001194A                            	spRateScale	$00, $02, $03, $01
0001194A =00000000                M sprs1	=	op1
0001194A =00000002                M sprs2	=	op2
0001194A =00000003                M sprs3	=	op3
0001194A =00000001                M sprs4	=	op4
0001194A                            	spAttackRt	$14, $0F, $10, $14
0001194A =00000014                M spar1	=	op1
0001194A =0000000F                M spar2	=	op2
0001194A =00000010                M spar3	=	op3
0001194A =00000014                M spar4	=	op4
0001194A                            	spAmpMod	$00, $00, $00, $00
0001194A =00000000                M spam1	=	op1
0001194A =00000000                M spam2	=	op2
0001194A =00000000                M spam3	=	op3
0001194A =00000000                M spam4	=	op4
0001194A                            	spSustainRt	$01, $05, $05, $08
0001194A =00000001                M spsr1	=	op1
0001194A =00000005                M spsr2	=	op2
0001194A =00000005                M spsr3	=	op3
0001194A =00000008                M spsr4	=	op4
0001194A                            	spSustainLv	$00, $03, $01, $08
0001194A =00000000                M spsl1	=	op1
0001194A =00000003                M spsl2	=	op2
0001194A =00000001                M spsl3	=	op3
0001194A =00000008                M spsl4	=	op4
0001194A                            	spDecayRt	$02, $05, $02, $1F
0001194A =00000002                M spdr1	=	op1
0001194A =00000005                M spdr2	=	op2
0001194A =00000002                M spdr3	=	op3
0001194A =0000001F                M spdr4	=	op4
0001194A                            	spReleaseRt	$01, $01, $01, $08
0001194A =00000001                M sprr1	=	op1
0001194A =00000001                M sprr2	=	op2
0001194A =00000001                M sprr3	=	op3
0001194A =00000008                M sprr4	=	op4
0001194A                            	spSSGEG		$00, $00, $00, $00
0001194A =00000000                M spss1	=	op1
0001194A =00000000                M spss2	=	op2
0001194A =00000000                M spss3	=	op3
0001194A =00000000                M spss4	=	op4
0001194A                            	spTotalLv	$19, $24, $28, $00
0001194A =00000019                M sptl1	=	op1
0001194A =00000024                M sptl2	=	op2
0001194A =00000028                M sptl3	=	op3
0001194A =00000000                M sptl4	=	op4
0001194A 22                       M 	dc.b	(spfe<<3)+spal
0001194B =00000080                M sptlmask4	set	$80
0001194B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001194B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001194B =00000000                M sptlmask1	set	((spal=7)<<7)
0001194B 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001194F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011953 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011957 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001195B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001195F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011963 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011967 4E41 54                  M 	dc.b	'NAT'
0001196A                            
0001196A                            	; Patch $56
0001196A                            	; $20
0001196A                            	; $66, $65, $60, $61,	$DF, $DF, $9F, $9F
0001196A                            	; $07, $06, $09, $06,	$07, $06, $06, $08
0001196A                            	; $29, $19, $19, $F9,	$1C, $3A, $16, $00
0001196A                            	spAlgorithm	$00
0001196A =00000057                M spatnum	=	spatnum+1
0001196A =00000000                M spal	=	val
0001196A                            	spFeedback	$04
0001196A =00000004                M spfe	=	val
0001196A                            	spDetune	$06, $06, $06, $06
0001196A =00000006                M spde1	=	op1
0001196A =00000006                M spde2	=	op2
0001196A =00000006                M spde3	=	op3
0001196A =00000006                M spde4	=	op4
0001196A                            	spMultiple	$06, $00, $05, $01
0001196A =00000006                M spmu1	=	op1
0001196A =00000000                M spmu2	=	op2
0001196A =00000005                M spmu3	=	op3
0001196A =00000001                M spmu4	=	op4
0001196A                            	spRateScale	$03, $02, $03, $02
0001196A =00000003                M sprs1	=	op1
0001196A =00000002                M sprs2	=	op2
0001196A =00000003                M sprs3	=	op3
0001196A =00000002                M sprs4	=	op4
0001196A                            	spAttackRt	$1F, $1F, $1F, $1F
0001196A =0000001F                M spar1	=	op1
0001196A =0000001F                M spar2	=	op2
0001196A =0000001F                M spar3	=	op3
0001196A =0000001F                M spar4	=	op4
0001196A                            	spAmpMod	$00, $00, $00, $00
0001196A =00000000                M spam1	=	op1
0001196A =00000000                M spam2	=	op2
0001196A =00000000                M spam3	=	op3
0001196A =00000000                M spam4	=	op4
0001196A                            	spSustainRt	$07, $09, $06, $06
0001196A =00000007                M spsr1	=	op1
0001196A =00000009                M spsr2	=	op2
0001196A =00000006                M spsr3	=	op3
0001196A =00000006                M spsr4	=	op4
0001196A                            	spDecayRt	$07, $06, $06, $08
0001196A =00000007                M spdr1	=	op1
0001196A =00000006                M spdr2	=	op2
0001196A =00000006                M spdr3	=	op3
0001196A =00000008                M spdr4	=	op4
0001196A                            	spSustainLv	$02, $01, $01, $0F
0001196A =00000002                M spsl1	=	op1
0001196A =00000001                M spsl2	=	op2
0001196A =00000001                M spsl3	=	op3
0001196A =0000000F                M spsl4	=	op4
0001196A                            	spReleaseRt	$09, $09, $09, $09
0001196A =00000009                M sprr1	=	op1
0001196A =00000009                M sprr2	=	op2
0001196A =00000009                M sprr3	=	op3
0001196A =00000009                M sprr4	=	op4
0001196A                            	spSSGEG		$00, $00, $00, $00
0001196A =00000000                M spss1	=	op1
0001196A =00000000                M spss2	=	op2
0001196A =00000000                M spss3	=	op3
0001196A =00000000                M spss4	=	op4
0001196A                            	spTotalLv	$1C, $16, $3A, $00
0001196A =0000001C                M sptl1	=	op1
0001196A =00000016                M sptl2	=	op2
0001196A =0000003A                M sptl3	=	op3
0001196A =00000000                M sptl4	=	op4
0001196A 20                       M 	dc.b	(spfe<<3)+spal
0001196B =00000080                M sptlmask4	set	$80
0001196B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001196B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001196B =00000000                M sptlmask1	set	((spal=7)<<7)
0001196B 6665 6061                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001196F DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011973 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011977 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001197B 2919 19F9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001197F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011983 1C3A 1680                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011987 4E41 54                  M 	dc.b	'NAT'
0001198A                            
0001198A                            	; Patch $57
0001198A                            	; $3A
0001198A                            	; $31, $01, $01, $71,	$8F, $8F, $4F, $4D
0001198A                            	; $09, $09, $00, $03,	$00, $00, $00, $00
0001198A                            	; $15, $F5, $05, $0A,	$19, $1F, $19, $01
0001198A                            	spAlgorithm	$02
0001198A =00000058                M spatnum	=	spatnum+1
0001198A =00000002                M spal	=	val
0001198A                            	spFeedback	$07
0001198A =00000007                M spfe	=	val
0001198A                            	spDetune	$03, $00, $00, $07
0001198A =00000003                M spde1	=	op1
0001198A =00000000                M spde2	=	op2
0001198A =00000000                M spde3	=	op3
0001198A =00000007                M spde4	=	op4
0001198A                            	spMultiple	$01, $01, $01, $01
0001198A =00000001                M spmu1	=	op1
0001198A =00000001                M spmu2	=	op2
0001198A =00000001                M spmu3	=	op3
0001198A =00000001                M spmu4	=	op4
0001198A                            	spRateScale	$02, $01, $02, $01
0001198A =00000002                M sprs1	=	op1
0001198A =00000001                M sprs2	=	op2
0001198A =00000002                M sprs3	=	op3
0001198A =00000001                M sprs4	=	op4
0001198A                            	spAttackRt	$0F, $0F, $0F, $0D
0001198A =0000000F                M spar1	=	op1
0001198A =0000000F                M spar2	=	op2
0001198A =0000000F                M spar3	=	op3
0001198A =0000000D                M spar4	=	op4
0001198A                            	spAmpMod	$00, $00, $00, $00
0001198A =00000000                M spam1	=	op1
0001198A =00000000                M spam2	=	op2
0001198A =00000000                M spam3	=	op3
0001198A =00000000                M spam4	=	op4
0001198A                            	spSustainRt	$09, $00, $09, $03
0001198A =00000009                M spsr1	=	op1
0001198A =00000000                M spsr2	=	op2
0001198A =00000009                M spsr3	=	op3
0001198A =00000003                M spsr4	=	op4
0001198A                            	spDecayRt	$00, $00, $00, $00
0001198A =00000000                M spdr1	=	op1
0001198A =00000000                M spdr2	=	op2
0001198A =00000000                M spdr3	=	op3
0001198A =00000000                M spdr4	=	op4
0001198A                            	spSustainLv	$01, $00, $0F, $00
0001198A =00000001                M spsl1	=	op1
0001198A =00000000                M spsl2	=	op2
0001198A =0000000F                M spsl3	=	op3
0001198A =00000000                M spsl4	=	op4
0001198A                            	spReleaseRt	$05, $05, $05, $0A
0001198A =00000005                M sprr1	=	op1
0001198A =00000005                M sprr2	=	op2
0001198A =00000005                M sprr3	=	op3
0001198A =0000000A                M sprr4	=	op4
0001198A                            	spSSGEG		$00, $00, $00, $00
0001198A =00000000                M spss1	=	op1
0001198A =00000000                M spss2	=	op2
0001198A =00000000                M spss3	=	op3
0001198A =00000000                M spss4	=	op4
0001198A                            	spTotalLv	$19, $19, $1F, $01
0001198A =00000019                M sptl1	=	op1
0001198A =00000019                M sptl2	=	op2
0001198A =0000001F                M sptl3	=	op3
0001198A =00000001                M sptl4	=	op4
0001198A 3A                       M 	dc.b	(spfe<<3)+spal
0001198B =00000080                M sptlmask4	set	$80
0001198B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001198B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001198B =00000000                M sptlmask1	set	((spal=7)<<7)
0001198B 3101 0171                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001198F 8F8F 4F4D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011993 0909 0003                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011997 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001199B 15F5 050A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001199F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119A3 191F 1981                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000119A7 4E41 54                  M 	dc.b	'NAT'
000119AA                            
000119AA                            	; Patch $58
000119AA                            	; $3A
000119AA                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
000119AA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000119AA                            	; $1F, $FF, $1F, $0F,	$17, $28, $27, $86
000119AA                            	spAlgorithm	$02
000119AA =00000059                M spatnum	=	spatnum+1
000119AA =00000002                M spal	=	val
000119AA                            	spFeedback	$07
000119AA =00000007                M spfe	=	val
000119AA                            	spDetune	$00, $00, $00, $00
000119AA =00000000                M spde1	=	op1
000119AA =00000000                M spde2	=	op2
000119AA =00000000                M spde3	=	op3
000119AA =00000000                M spde4	=	op4
000119AA                            	spMultiple	$01, $01, $07, $01
000119AA =00000001                M spmu1	=	op1
000119AA =00000001                M spmu2	=	op2
000119AA =00000007                M spmu3	=	op3
000119AA =00000001                M spmu4	=	op4
000119AA                            	spRateScale	$02, $02, $02, $01
000119AA =00000002                M sprs1	=	op1
000119AA =00000002                M sprs2	=	op2
000119AA =00000002                M sprs3	=	op3
000119AA =00000001                M sprs4	=	op4
000119AA                            	spAttackRt	$0E, $0D, $0E, $13
000119AA =0000000E                M spar1	=	op1
000119AA =0000000D                M spar2	=	op2
000119AA =0000000E                M spar3	=	op3
000119AA =00000013                M spar4	=	op4
000119AA                            	spAmpMod	$00, $00, $00, $00
000119AA =00000000                M spam1	=	op1
000119AA =00000000                M spam2	=	op2
000119AA =00000000                M spam3	=	op3
000119AA =00000000                M spam4	=	op4
000119AA                            	spSustainRt	$0E, $0E, $0E, $03
000119AA =0000000E                M spsr1	=	op1
000119AA =0000000E                M spsr2	=	op2
000119AA =0000000E                M spsr3	=	op3
000119AA =00000003                M spsr4	=	op4
000119AA                            	spDecayRt	$00, $00, $00, $00
000119AA =00000000                M spdr1	=	op1
000119AA =00000000                M spdr2	=	op2
000119AA =00000000                M spdr3	=	op3
000119AA =00000000                M spdr4	=	op4
000119AA                            	spSustainLv	$01, $01, $0F, $00
000119AA =00000001                M spsl1	=	op1
000119AA =00000001                M spsl2	=	op2
000119AA =0000000F                M spsl3	=	op3
000119AA =00000000                M spsl4	=	op4
000119AA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119AA =0000000F                M sprr1	=	op1
000119AA =0000000F                M sprr2	=	op2
000119AA =0000000F                M sprr3	=	op3
000119AA =0000000F                M sprr4	=	op4
000119AA                            	spSSGEG		$00, $00, $00, $00
000119AA =00000000                M spss1	=	op1
000119AA =00000000                M spss2	=	op2
000119AA =00000000                M spss3	=	op3
000119AA =00000000                M spss4	=	op4
000119AA                            	spTotalLv	$17, $27, $28, $06
000119AA =00000017                M sptl1	=	op1
000119AA =00000027                M sptl2	=	op2
000119AA =00000028                M sptl3	=	op3
000119AA =00000006                M sptl4	=	op4
000119AA 3A                       M 	dc.b	(spfe<<3)+spal
000119AB =00000080                M sptlmask4	set	$80
000119AB =00000000                M sptlmask2	set	((spal>=5)<<7)
000119AB =00000000                M sptlmask3	set	((spal>=4)<<7)
000119AB =00000000                M sptlmask1	set	((spal=7)<<7)
000119AB 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119AF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119B3 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119B7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119BB 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119BF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119C3 1728 2786                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000119C7 4E41 54                  M 	dc.b	'NAT'
000119CA                            
000119CA                            	; Patch $59
000119CA                            	; $3A
000119CA                            	; $51, $07, $51, $02,	$0F, $0B, $0F, $0F
000119CA                            	; $1F, $1F, $1F, $0F,	$00, $00, $00, $02
000119CA                            	; $0F, $0F, $0F, $1F,	$1C, $28, $22, $81
000119CA                            	spAlgorithm	$02
000119CA =0000005A                M spatnum	=	spatnum+1
000119CA =00000002                M spal	=	val
000119CA                            	spFeedback	$07
000119CA =00000007                M spfe	=	val
000119CA                            	spDetune	$05, $05, $00, $00
000119CA =00000005                M spde1	=	op1
000119CA =00000005                M spde2	=	op2
000119CA =00000000                M spde3	=	op3
000119CA =00000000                M spde4	=	op4
000119CA                            	spMultiple	$01, $01, $07, $02
000119CA =00000001                M spmu1	=	op1
000119CA =00000001                M spmu2	=	op2
000119CA =00000007                M spmu3	=	op3
000119CA =00000002                M spmu4	=	op4
000119CA                            	spRateScale	$00, $00, $00, $00
000119CA =00000000                M sprs1	=	op1
000119CA =00000000                M sprs2	=	op2
000119CA =00000000                M sprs3	=	op3
000119CA =00000000                M sprs4	=	op4
000119CA                            	spAttackRt	$0F, $0F, $0B, $0F
000119CA =0000000F                M spar1	=	op1
000119CA =0000000F                M spar2	=	op2
000119CA =0000000B                M spar3	=	op3
000119CA =0000000F                M spar4	=	op4
000119CA                            	spAmpMod	$00, $00, $00, $00
000119CA =00000000                M spam1	=	op1
000119CA =00000000                M spam2	=	op2
000119CA =00000000                M spam3	=	op3
000119CA =00000000                M spam4	=	op4
000119CA                            	spSustainRt	$1F, $1F, $1F, $0F
000119CA =0000001F                M spsr1	=	op1
000119CA =0000001F                M spsr2	=	op2
000119CA =0000001F                M spsr3	=	op3
000119CA =0000000F                M spsr4	=	op4
000119CA                            	spDecayRt	$00, $00, $00, $02
000119CA =00000000                M spdr1	=	op1
000119CA =00000000                M spdr2	=	op2
000119CA =00000000                M spdr3	=	op3
000119CA =00000002                M spdr4	=	op4
000119CA                            	spSustainLv	$00, $00, $00, $01
000119CA =00000000                M spsl1	=	op1
000119CA =00000000                M spsl2	=	op2
000119CA =00000000                M spsl3	=	op3
000119CA =00000001                M spsl4	=	op4
000119CA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119CA =0000000F                M sprr1	=	op1
000119CA =0000000F                M sprr2	=	op2
000119CA =0000000F                M sprr3	=	op3
000119CA =0000000F                M sprr4	=	op4
000119CA                            	spSSGEG		$00, $00, $00, $00
000119CA =00000000                M spss1	=	op1
000119CA =00000000                M spss2	=	op2
000119CA =00000000                M spss3	=	op3
000119CA =00000000                M spss4	=	op4
000119CA                            	spTotalLv	$1C, $22, $28, $01
000119CA =0000001C                M sptl1	=	op1
000119CA =00000022                M sptl2	=	op2
000119CA =00000028                M sptl3	=	op3
000119CA =00000001                M sptl4	=	op4
000119CA 3A                       M 	dc.b	(spfe<<3)+spal
000119CB =00000080                M sptlmask4	set	$80
000119CB =00000000                M sptlmask2	set	((spal>=5)<<7)
000119CB =00000000                M sptlmask3	set	((spal>=4)<<7)
000119CB =00000000                M sptlmask1	set	((spal=7)<<7)
000119CB 5107 5102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119CF 0F0B 0F0F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119D3 1F1F 1F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119D7 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119DB 0F0F 0F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119DF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119E3 1C28 2281                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000119E7 4E41 54                  M 	dc.b	'NAT'
000119EA                            
000119EA                            	even
000119EA                            
000119EA                            ; -------------------------------------------------------------------------
000119EA                            VoiceBankSFX:
000119EA =00000000                  sPatNum = 0
000119EA                            	include "Sound/unipatchsfx.asm"; include universal Voice banks
000119EA                            
000119EA                            ; ------------------------------------------------------------------------
000119EA                            ; AMPS SFX patch list
000119EA                            ; -------------------------------------------------------------------------
000119EA                            
000119EA                            	; Patch $00
000119EA                            	; $07
000119EA                            	; $07, $07, $08, $08,	$1F, $1F, $1F, $1F
000119EA                            	; $00, $00, $00, $00,	$00, $00, $00, $00
000119EA                            	; $0F, $0F, $0F, $0F,	$80, $80, $80, $80
000119EA                            	spAlgorithm	$07
000119EA =00000001                M spatnum	=	spatnum+1
000119EA =00000007                M spal	=	val
000119EA                            	spFeedback	$00
000119EA =00000000                M spfe	=	val
000119EA                            	spDetune	$00, $00, $00, $00
000119EA =00000000                M spde1	=	op1
000119EA =00000000                M spde2	=	op2
000119EA =00000000                M spde3	=	op3
000119EA =00000000                M spde4	=	op4
000119EA                            	spMultiple	$07, $08, $07, $08
000119EA =00000007                M spmu1	=	op1
000119EA =00000008                M spmu2	=	op2
000119EA =00000007                M spmu3	=	op3
000119EA =00000008                M spmu4	=	op4
000119EA                            	spRateScale	$00, $00, $00, $00
000119EA =00000000                M sprs1	=	op1
000119EA =00000000                M sprs2	=	op2
000119EA =00000000                M sprs3	=	op3
000119EA =00000000                M sprs4	=	op4
000119EA                            	spAttackRt	$1F, $1F, $1F, $1F
000119EA =0000001F                M spar1	=	op1
000119EA =0000001F                M spar2	=	op2
000119EA =0000001F                M spar3	=	op3
000119EA =0000001F                M spar4	=	op4
000119EA                            	spAmpMod	$00, $00, $00, $00
000119EA =00000000                M spam1	=	op1
000119EA =00000000                M spam2	=	op2
000119EA =00000000                M spam3	=	op3
000119EA =00000000                M spam4	=	op4
000119EA                            	spSustainRt	$00, $00, $00, $00
000119EA =00000000                M spsr1	=	op1
000119EA =00000000                M spsr2	=	op2
000119EA =00000000                M spsr3	=	op3
000119EA =00000000                M spsr4	=	op4
000119EA                            	spDecayRt	$00, $00, $00, $00
000119EA =00000000                M spdr1	=	op1
000119EA =00000000                M spdr2	=	op2
000119EA =00000000                M spdr3	=	op3
000119EA =00000000                M spdr4	=	op4
000119EA                            	spSustainLv	$00, $00, $00, $00
000119EA =00000000                M spsl1	=	op1
000119EA =00000000                M spsl2	=	op2
000119EA =00000000                M spsl3	=	op3
000119EA =00000000                M spsl4	=	op4
000119EA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119EA =0000000F                M sprr1	=	op1
000119EA =0000000F                M sprr2	=	op2
000119EA =0000000F                M sprr3	=	op3
000119EA =0000000F                M sprr4	=	op4
000119EA                            	spSSGEG		$00, $00, $00, $00
000119EA =00000000                M spss1	=	op1
000119EA =00000000                M spss2	=	op2
000119EA =00000000                M spss3	=	op3
000119EA =00000000                M spss4	=	op4
000119EA                            	spTotalLv2	$80, $80, $80, $80
000119EA =00000080                M sptl1	=	op1
000119EA =00000080                M sptl2	=	op2
000119EA =00000080                M sptl3	=	op3
000119EA =00000080                M sptl4	=	op4
000119EA 07                       M 	dc.b	(spfe<<3)+spal
000119EB 0707 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119EF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119F3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119F7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119FB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119FF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A03 8080 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A07 4E41 54                  M 	dc.b	'NAT'
00011A0A                            
00011A0A                            	; Patch $01
00011A0A                            	; $0C
00011A0A                            	; $08, $08, $08, $08,	$1F, $1F, $1F, $1F
00011A0A                            	; $00, $0A, $00, $0A,	$00, $00, $00, $0A
00011A0A                            	; $FF, $FF, $FF, $FF,	$55, $81, $33, $81
00011A0A                            	spAlgorithm	$04
00011A0A =00000002                M spatnum	=	spatnum+1
00011A0A =00000004                M spal	=	val
00011A0A                            	spFeedback	$01
00011A0A =00000001                M spfe	=	val
00011A0A                            	spDetune	$00, $00, $00, $00
00011A0A =00000000                M spde1	=	op1
00011A0A =00000000                M spde2	=	op2
00011A0A =00000000                M spde3	=	op3
00011A0A =00000000                M spde4	=	op4
00011A0A                            	spMultiple	$08, $08, $08, $08
00011A0A =00000008                M spmu1	=	op1
00011A0A =00000008                M spmu2	=	op2
00011A0A =00000008                M spmu3	=	op3
00011A0A =00000008                M spmu4	=	op4
00011A0A                            	spRateScale	$00, $00, $00, $00
00011A0A =00000000                M sprs1	=	op1
00011A0A =00000000                M sprs2	=	op2
00011A0A =00000000                M sprs3	=	op3
00011A0A =00000000                M sprs4	=	op4
00011A0A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A0A =0000001F                M spar1	=	op1
00011A0A =0000001F                M spar2	=	op2
00011A0A =0000001F                M spar3	=	op3
00011A0A =0000001F                M spar4	=	op4
00011A0A                            	spAmpMod	$00, $00, $00, $00
00011A0A =00000000                M spam1	=	op1
00011A0A =00000000                M spam2	=	op2
00011A0A =00000000                M spam3	=	op3
00011A0A =00000000                M spam4	=	op4
00011A0A                            	spSustainRt	$00, $00, $0A, $0A
00011A0A =00000000                M spsr1	=	op1
00011A0A =00000000                M spsr2	=	op2
00011A0A =0000000A                M spsr3	=	op3
00011A0A =0000000A                M spsr4	=	op4
00011A0A                            	spDecayRt	$00, $00, $00, $0A
00011A0A =00000000                M spdr1	=	op1
00011A0A =00000000                M spdr2	=	op2
00011A0A =00000000                M spdr3	=	op3
00011A0A =0000000A                M spdr4	=	op4
00011A0A                            	spSustainLv	$0F, $0F, $0F, $0F
00011A0A =0000000F                M spsl1	=	op1
00011A0A =0000000F                M spsl2	=	op2
00011A0A =0000000F                M spsl3	=	op3
00011A0A =0000000F                M spsl4	=	op4
00011A0A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A0A =0000000F                M sprr1	=	op1
00011A0A =0000000F                M sprr2	=	op2
00011A0A =0000000F                M sprr3	=	op3
00011A0A =0000000F                M sprr4	=	op4
00011A0A                            	spSSGEG		$00, $00, $00, $00
00011A0A =00000000                M spss1	=	op1
00011A0A =00000000                M spss2	=	op2
00011A0A =00000000                M spss3	=	op3
00011A0A =00000000                M spss4	=	op4
00011A0A                            	spTotalLv	$55, $33, $01, $01
00011A0A =00000055                M sptl1	=	op1
00011A0A =00000033                M sptl2	=	op2
00011A0A =00000001                M sptl3	=	op3
00011A0A =00000001                M sptl4	=	op4
00011A0A 0C                       M 	dc.b	(spfe<<3)+spal
00011A0B =00000080                M sptlmask4	set	$80
00011A0B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011A0B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011A0B =00000000                M sptlmask1	set	((spal=7)<<7)
00011A0B 0808 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A0F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A13 000A 000A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A17 0000 000A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A1B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A1F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A23 5581 3381                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011A27 4E41 54                  M 	dc.b	'NAT'
00011A2A                            
00011A2A                            	; Patch $02
00011A2A                            	; $30
00011A2A                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011A2A                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011A2A                            	; $BF, $BF, $BF, $BF,	$14, $3A, $14, $80
00011A2A                            	spAlgorithm	$00
00011A2A =00000003                M spatnum	=	spatnum+1
00011A2A =00000000                M spal	=	val
00011A2A                            	spFeedback	$06
00011A2A =00000006                M spfe	=	val
00011A2A                            	spDetune	$03, $03, $03, $03
00011A2A =00000003                M spde1	=	op1
00011A2A =00000003                M spde2	=	op2
00011A2A =00000003                M spde3	=	op3
00011A2A =00000003                M spde4	=	op4
00011A2A                            	spMultiple	$00, $00, $00, $00
00011A2A =00000000                M spmu1	=	op1
00011A2A =00000000                M spmu2	=	op2
00011A2A =00000000                M spmu3	=	op3
00011A2A =00000000                M spmu4	=	op4
00011A2A                            	spRateScale	$02, $03, $03, $03
00011A2A =00000002                M sprs1	=	op1
00011A2A =00000003                M sprs2	=	op2
00011A2A =00000003                M sprs3	=	op3
00011A2A =00000003                M sprs4	=	op4
00011A2A                            	spAttackRt	$1E, $1C, $18, $1C
00011A2A =0000001E                M spar1	=	op1
00011A2A =0000001C                M spar2	=	op2
00011A2A =00000018                M spar3	=	op3
00011A2A =0000001C                M spar4	=	op4
00011A2A                            	spAmpMod	$00, $00, $00, $00
00011A2A =00000000                M spam1	=	op1
00011A2A =00000000                M spam2	=	op2
00011A2A =00000000                M spam3	=	op3
00011A2A =00000000                M spam4	=	op4
00011A2A                            	spSustainRt	$0E, $04, $0A, $05
00011A2A =0000000E                M spsr1	=	op1
00011A2A =00000004                M spsr2	=	op2
00011A2A =0000000A                M spsr3	=	op3
00011A2A =00000005                M spsr4	=	op4
00011A2A                            	spDecayRt	$08, $08, $08, $08
00011A2A =00000008                M spdr1	=	op1
00011A2A =00000008                M spdr2	=	op2
00011A2A =00000008                M spdr3	=	op3
00011A2A =00000008                M spdr4	=	op4
00011A2A                            	spSustainLv	$0B, $0B, $0B, $0B
00011A2A =0000000B                M spsl1	=	op1
00011A2A =0000000B                M spsl2	=	op2
00011A2A =0000000B                M spsl3	=	op3
00011A2A =0000000B                M spsl4	=	op4
00011A2A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A2A =0000000F                M sprr1	=	op1
00011A2A =0000000F                M sprr2	=	op2
00011A2A =0000000F                M sprr3	=	op3
00011A2A =0000000F                M sprr4	=	op4
00011A2A                            	spSSGEG		$00, $00, $00, $00
00011A2A =00000000                M spss1	=	op1
00011A2A =00000000                M spss2	=	op2
00011A2A =00000000                M spss3	=	op3
00011A2A =00000000                M spss4	=	op4
00011A2A                            	spTotalLv2	$14, $14, $3A, $80
00011A2A =00000014                M sptl1	=	op1
00011A2A =00000014                M sptl2	=	op2
00011A2A =0000003A                M sptl3	=	op3
00011A2A =00000080                M sptl4	=	op4
00011A2A 30                       M 	dc.b	(spfe<<3)+spal
00011A2B 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A2F 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A33 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A37 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A3B BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A3F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A43 143A 1480                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A47 4E41 54                  M 	dc.b	'NAT'
00011A4A                            
00011A4A                            	; Patch $03
00011A4A                            	; $04
00011A4A                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
00011A4A                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
00011A4A                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
00011A4A                            	spAlgorithm	$04
00011A4A =00000004                M spatnum	=	spatnum+1
00011A4A =00000004                M spal	=	val
00011A4A                            	spFeedback	$00
00011A4A =00000000                M spfe	=	val
00011A4A                            	spDetune	$03, $07, $07, $04
00011A4A =00000003                M spde1	=	op1
00011A4A =00000007                M spde2	=	op2
00011A4A =00000007                M spde3	=	op3
00011A4A =00000004                M spde4	=	op4
00011A4A                            	spMultiple	$07, $07, $02, $09
00011A4A =00000007                M spmu1	=	op1
00011A4A =00000007                M spmu2	=	op2
00011A4A =00000002                M spmu3	=	op3
00011A4A =00000009                M spmu4	=	op4
00011A4A                            	spRateScale	$00, $00, $00, $00
00011A4A =00000000                M sprs1	=	op1
00011A4A =00000000                M sprs2	=	op2
00011A4A =00000000                M sprs3	=	op3
00011A4A =00000000                M sprs4	=	op4
00011A4A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A4A =0000001F                M spar1	=	op1
00011A4A =0000001F                M spar2	=	op2
00011A4A =0000001F                M spar3	=	op3
00011A4A =0000001F                M spar4	=	op4
00011A4A                            	spAmpMod	$00, $00, $00, $00
00011A4A =00000000                M spam1	=	op1
00011A4A =00000000                M spam2	=	op2
00011A4A =00000000                M spam3	=	op3
00011A4A =00000000                M spam4	=	op4
00011A4A                            	spSustainRt	$07, $07, $0A, $0D
00011A4A =00000007                M spsr1	=	op1
00011A4A =00000007                M spsr2	=	op2
00011A4A =0000000A                M spsr3	=	op3
00011A4A =0000000D                M spsr4	=	op4
00011A4A                            	spDecayRt	$00, $00, $0B, $0B
00011A4A =00000000                M spdr1	=	op1
00011A4A =00000000                M spdr2	=	op2
00011A4A =0000000B                M spdr3	=	op3
00011A4A =0000000B                M spdr4	=	op4
00011A4A                            	spSustainLv	$01, $01, $00, $00
00011A4A =00000001                M spsl1	=	op1
00011A4A =00000001                M spsl2	=	op2
00011A4A =00000000                M spsl3	=	op3
00011A4A =00000000                M spsl4	=	op4
00011A4A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A4A =0000000F                M sprr1	=	op1
00011A4A =0000000F                M sprr2	=	op2
00011A4A =0000000F                M sprr3	=	op3
00011A4A =0000000F                M sprr4	=	op4
00011A4A                            	spSSGEG		$00, $00, $00, $00
00011A4A =00000000                M spss1	=	op1
00011A4A =00000000                M spss2	=	op2
00011A4A =00000000                M spss3	=	op3
00011A4A =00000000                M spss4	=	op4
00011A4A                            	spTotalLv2	$23, $23, $00, $00
00011A4A =00000023                M sptl1	=	op1
00011A4A =00000023                M sptl2	=	op2
00011A4A =00000000                M sptl3	=	op3
00011A4A =00000000                M sptl4	=	op4
00011A4A 04                       M 	dc.b	(spfe<<3)+spal
00011A4B 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A4F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A53 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A57 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A5B 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A5F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A63 2300 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A67 4E41 54                  M 	dc.b	'NAT'
00011A6A                            
00011A6A                            	; Patch $04
00011A6A                            	; $3C
00011A6A                            	; $0F, $01, $03, $01,	$1F, $1F, $1F, $1F
00011A6A                            	; $19, $12, $19, $0E,	$05, $12, $00, $0F
00011A6A                            	; $0F, $7F, $FF, $FF,	$00, $00, $00, $00
00011A6A                            	spAlgorithm	$04
00011A6A =00000005                M spatnum	=	spatnum+1
00011A6A =00000004                M spal	=	val
00011A6A                            	spFeedback	$07
00011A6A =00000007                M spfe	=	val
00011A6A                            	spDetune	$00, $00, $00, $00
00011A6A =00000000                M spde1	=	op1
00011A6A =00000000                M spde2	=	op2
00011A6A =00000000                M spde3	=	op3
00011A6A =00000000                M spde4	=	op4
00011A6A                            	spMultiple	$0F, $03, $01, $01
00011A6A =0000000F                M spmu1	=	op1
00011A6A =00000003                M spmu2	=	op2
00011A6A =00000001                M spmu3	=	op3
00011A6A =00000001                M spmu4	=	op4
00011A6A                            	spRateScale	$00, $00, $00, $00
00011A6A =00000000                M sprs1	=	op1
00011A6A =00000000                M sprs2	=	op2
00011A6A =00000000                M sprs3	=	op3
00011A6A =00000000                M sprs4	=	op4
00011A6A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A6A =0000001F                M spar1	=	op1
00011A6A =0000001F                M spar2	=	op2
00011A6A =0000001F                M spar3	=	op3
00011A6A =0000001F                M spar4	=	op4
00011A6A                            	spAmpMod	$00, $00, $00, $00
00011A6A =00000000                M spam1	=	op1
00011A6A =00000000                M spam2	=	op2
00011A6A =00000000                M spam3	=	op3
00011A6A =00000000                M spam4	=	op4
00011A6A                            	spSustainRt	$19, $19, $12, $0E
00011A6A =00000019                M spsr1	=	op1
00011A6A =00000019                M spsr2	=	op2
00011A6A =00000012                M spsr3	=	op3
00011A6A =0000000E                M spsr4	=	op4
00011A6A                            	spDecayRt	$05, $00, $12, $0F
00011A6A =00000005                M spdr1	=	op1
00011A6A =00000000                M spdr2	=	op2
00011A6A =00000012                M spdr3	=	op3
00011A6A =0000000F                M spdr4	=	op4
00011A6A                            	spSustainLv	$00, $0F, $07, $0F
00011A6A =00000000                M spsl1	=	op1
00011A6A =0000000F                M spsl2	=	op2
00011A6A =00000007                M spsl3	=	op3
00011A6A =0000000F                M spsl4	=	op4
00011A6A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A6A =0000000F                M sprr1	=	op1
00011A6A =0000000F                M sprr2	=	op2
00011A6A =0000000F                M sprr3	=	op3
00011A6A =0000000F                M sprr4	=	op4
00011A6A                            	spSSGEG		$00, $00, $00, $00
00011A6A =00000000                M spss1	=	op1
00011A6A =00000000                M spss2	=	op2
00011A6A =00000000                M spss3	=	op3
00011A6A =00000000                M spss4	=	op4
00011A6A                            	spTotalLv2	$00, $00, $00, $00
00011A6A =00000000                M sptl1	=	op1
00011A6A =00000000                M sptl2	=	op2
00011A6A =00000000                M sptl3	=	op3
00011A6A =00000000                M sptl4	=	op4
00011A6A 3C                       M 	dc.b	(spfe<<3)+spal
00011A6B 0F01 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A6F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A73 1912 190E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A77 0512 000F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A7B 0F7F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A7F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A83 0000 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A87 4E41 54                  M 	dc.b	'NAT'
00011A8A                            
00011A8A                            	; Patch $05
00011A8A                            	; $30
00011A8A                            	; $30, $30, $30, $30,	$9E, $A8, $AC, $DC
00011A8A                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011A8A                            	; $BF, $BF, $BF, $BF,	$04, $2C, $14, $00
00011A8A                            	spAlgorithm	$00
00011A8A =00000006                M spatnum	=	spatnum+1
00011A8A =00000000                M spal	=	val
00011A8A                            	spFeedback	$06
00011A8A =00000006                M spfe	=	val
00011A8A                            	spDetune	$03, $03, $03, $03
00011A8A =00000003                M spde1	=	op1
00011A8A =00000003                M spde2	=	op2
00011A8A =00000003                M spde3	=	op3
00011A8A =00000003                M spde4	=	op4
00011A8A                            	spMultiple	$00, $00, $00, $00
00011A8A =00000000                M spmu1	=	op1
00011A8A =00000000                M spmu2	=	op2
00011A8A =00000000                M spmu3	=	op3
00011A8A =00000000                M spmu4	=	op4
00011A8A                            	spRateScale	$02, $02, $02, $03
00011A8A =00000002                M sprs1	=	op1
00011A8A =00000002                M sprs2	=	op2
00011A8A =00000002                M sprs3	=	op3
00011A8A =00000003                M sprs4	=	op4
00011A8A                            	spAttackRt	$1E, $0C, $08, $1C
00011A8A =0000001E                M spar1	=	op1
00011A8A =0000000C                M spar2	=	op2
00011A8A =00000008                M spar3	=	op3
00011A8A =0000001C                M spar4	=	op4
00011A8A                            	spAmpMod	$00, $00, $00, $00
00011A8A =00000000                M spam1	=	op1
00011A8A =00000000                M spam2	=	op2
00011A8A =00000000                M spam3	=	op3
00011A8A =00000000                M spam4	=	op4
00011A8A                            	spSustainRt	$0E, $04, $0A, $05
00011A8A =0000000E                M spsr1	=	op1
00011A8A =00000004                M spsr2	=	op2
00011A8A =0000000A                M spsr3	=	op3
00011A8A =00000005                M spsr4	=	op4
00011A8A                            	spDecayRt	$08, $08, $08, $08
00011A8A =00000008                M spdr1	=	op1
00011A8A =00000008                M spdr2	=	op2
00011A8A =00000008                M spdr3	=	op3
00011A8A =00000008                M spdr4	=	op4
00011A8A                            	spSustainLv	$0B, $0B, $0B, $0B
00011A8A =0000000B                M spsl1	=	op1
00011A8A =0000000B                M spsl2	=	op2
00011A8A =0000000B                M spsl3	=	op3
00011A8A =0000000B                M spsl4	=	op4
00011A8A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A8A =0000000F                M sprr1	=	op1
00011A8A =0000000F                M sprr2	=	op2
00011A8A =0000000F                M sprr3	=	op3
00011A8A =0000000F                M sprr4	=	op4
00011A8A                            	spSSGEG		$00, $00, $00, $00
00011A8A =00000000                M spss1	=	op1
00011A8A =00000000                M spss2	=	op2
00011A8A =00000000                M spss3	=	op3
00011A8A =00000000                M spss4	=	op4
00011A8A                            	spTotalLv2	$04, $14, $2C, $00
00011A8A =00000004                M sptl1	=	op1
00011A8A =00000014                M sptl2	=	op2
00011A8A =0000002C                M sptl3	=	op3
00011A8A =00000000                M sptl4	=	op4
00011A8A 30                       M 	dc.b	(spfe<<3)+spal
00011A8B 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A8F 9E88 8CDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A93 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A97 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A9B BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A9F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AA3 042C 1400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AA7 4E41 54                  M 	dc.b	'NAT'
00011AAA                            
00011AAA                            	; Patch $06
00011AAA                            	; $20
00011AAA                            	; $36, $35, $30, $31,	$DF, $DF, $9F, $9F
00011AAA                            	; $07, $06, $09, $06,	$07, $06, $06, $08
00011AAA                            	; $2F, $1F, $1F, $FF,	$16, $30, $13, $00
00011AAA                            	spAlgorithm	$00
00011AAA =00000007                M spatnum	=	spatnum+1
00011AAA =00000000                M spal	=	val
00011AAA                            	spFeedback	$04
00011AAA =00000004                M spfe	=	val
00011AAA                            	spDetune	$03, $03, $03, $03
00011AAA =00000003                M spde1	=	op1
00011AAA =00000003                M spde2	=	op2
00011AAA =00000003                M spde3	=	op3
00011AAA =00000003                M spde4	=	op4
00011AAA                            	spMultiple	$06, $00, $05, $01
00011AAA =00000006                M spmu1	=	op1
00011AAA =00000000                M spmu2	=	op2
00011AAA =00000005                M spmu3	=	op3
00011AAA =00000001                M spmu4	=	op4
00011AAA                            	spRateScale	$03, $02, $03, $02
00011AAA =00000003                M sprs1	=	op1
00011AAA =00000002                M sprs2	=	op2
00011AAA =00000003                M sprs3	=	op3
00011AAA =00000002                M sprs4	=	op4
00011AAA                            	spAttackRt	$1F, $1F, $1F, $1F
00011AAA =0000001F                M spar1	=	op1
00011AAA =0000001F                M spar2	=	op2
00011AAA =0000001F                M spar3	=	op3
00011AAA =0000001F                M spar4	=	op4
00011AAA                            	spAmpMod	$00, $00, $00, $00
00011AAA =00000000                M spam1	=	op1
00011AAA =00000000                M spam2	=	op2
00011AAA =00000000                M spam3	=	op3
00011AAA =00000000                M spam4	=	op4
00011AAA                            	spSustainRt	$07, $09, $06, $06
00011AAA =00000007                M spsr1	=	op1
00011AAA =00000009                M spsr2	=	op2
00011AAA =00000006                M spsr3	=	op3
00011AAA =00000006                M spsr4	=	op4
00011AAA                            	spDecayRt	$07, $06, $06, $08
00011AAA =00000007                M spdr1	=	op1
00011AAA =00000006                M spdr2	=	op2
00011AAA =00000006                M spdr3	=	op3
00011AAA =00000008                M spdr4	=	op4
00011AAA                            	spSustainLv	$02, $01, $01, $0F
00011AAA =00000002                M spsl1	=	op1
00011AAA =00000001                M spsl2	=	op2
00011AAA =00000001                M spsl3	=	op3
00011AAA =0000000F                M spsl4	=	op4
00011AAA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011AAA =0000000F                M sprr1	=	op1
00011AAA =0000000F                M sprr2	=	op2
00011AAA =0000000F                M sprr3	=	op3
00011AAA =0000000F                M sprr4	=	op4
00011AAA                            	spSSGEG		$00, $00, $00, $00
00011AAA =00000000                M spss1	=	op1
00011AAA =00000000                M spss2	=	op2
00011AAA =00000000                M spss3	=	op3
00011AAA =00000000                M spss4	=	op4
00011AAA                            	spTotalLv2	$16, $13, $30, $00
00011AAA =00000016                M sptl1	=	op1
00011AAA =00000013                M sptl2	=	op2
00011AAA =00000030                M sptl3	=	op3
00011AAA =00000000                M sptl4	=	op4
00011AAA 20                       M 	dc.b	(spfe<<3)+spal
00011AAB 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011AAF DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AB3 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AB7 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011ABB 2F1F 1FFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011ABF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AC3 1630 1300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AC7 4E41 54                  M 	dc.b	'NAT'
00011ACA                            
00011ACA                            	; Patch $07
00011ACA                            	; $35
00011ACA                            	; $05, $09, $08, $07,	$1E, $0D, $0D, $0E
00011ACA                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
00011ACA                            	; $2F, $2F, $1F, $1F,	$15, $12, $12, $00
00011ACA                            	spAlgorithm	$05
00011ACA =00000008                M spatnum	=	spatnum+1
00011ACA =00000005                M spal	=	val
00011ACA                            	spFeedback	$06
00011ACA =00000006                M spfe	=	val
00011ACA                            	spDetune	$00, $00, $00, $00
00011ACA =00000000                M spde1	=	op1
00011ACA =00000000                M spde2	=	op2
00011ACA =00000000                M spde3	=	op3
00011ACA =00000000                M spde4	=	op4
00011ACA                            	spMultiple	$05, $08, $09, $07
00011ACA =00000005                M spmu1	=	op1
00011ACA =00000008                M spmu2	=	op2
00011ACA =00000009                M spmu3	=	op3
00011ACA =00000007                M spmu4	=	op4
00011ACA                            	spRateScale	$00, $00, $00, $00
00011ACA =00000000                M sprs1	=	op1
00011ACA =00000000                M sprs2	=	op2
00011ACA =00000000                M sprs3	=	op3
00011ACA =00000000                M sprs4	=	op4
00011ACA                            	spAttackRt	$1E, $0D, $0D, $0E
00011ACA =0000001E                M spar1	=	op1
00011ACA =0000000D                M spar2	=	op2
00011ACA =0000000D                M spar3	=	op3
00011ACA =0000000E                M spar4	=	op4
00011ACA                            	spAmpMod	$00, $00, $00, $00
00011ACA =00000000                M spam1	=	op1
00011ACA =00000000                M spam2	=	op2
00011ACA =00000000                M spam3	=	op3
00011ACA =00000000                M spam4	=	op4
00011ACA                            	spSustainRt	$0C, $03, $15, $06
00011ACA =0000000C                M spsr1	=	op1
00011ACA =00000003                M spsr2	=	op2
00011ACA =00000015                M spsr3	=	op3
00011ACA =00000006                M spsr4	=	op4
00011ACA                            	spDecayRt	$16, $09, $0E, $10
00011ACA =00000016                M spdr1	=	op1
00011ACA =00000009                M spdr2	=	op2
00011ACA =0000000E                M spdr3	=	op3
00011ACA =00000010                M spdr4	=	op4
00011ACA                            	spSustainLv	$02, $01, $02, $01
00011ACA =00000002                M spsl1	=	op1
00011ACA =00000001                M spsl2	=	op2
00011ACA =00000002                M spsl3	=	op3
00011ACA =00000001                M spsl4	=	op4
00011ACA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011ACA =0000000F                M sprr1	=	op1
00011ACA =0000000F                M sprr2	=	op2
00011ACA =0000000F                M sprr3	=	op3
00011ACA =0000000F                M sprr4	=	op4
00011ACA                            	spSSGEG		$00, $00, $00, $00
00011ACA =00000000                M spss1	=	op1
00011ACA =00000000                M spss2	=	op2
00011ACA =00000000                M spss3	=	op3
00011ACA =00000000                M spss4	=	op4
00011ACA                            	spTotalLv2	$15, $12, $12, $00
00011ACA =00000015                M sptl1	=	op1
00011ACA =00000012                M sptl2	=	op2
00011ACA =00000012                M sptl3	=	op3
00011ACA =00000000                M sptl4	=	op4
00011ACA 35                       M 	dc.b	(spfe<<3)+spal
00011ACB 0509 0807                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011ACF 1E0D 0D0E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AD3 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AD7 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011ADB 2F2F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011ADF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AE3 1512 1200                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AE7 4E41 54                  M 	dc.b	'NAT'
00011AEA                            
00011AEA                            	; Patch $08
00011AEA                            	; $3E
00011AEA                            	; $36, $01, $00, $04,	$59, $D9, $5F, $9C
00011AEA                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
00011AEA                            	; $A9, $AF, $66, $66,	$20, $00, $0A, $00
00011AEA                            	spAlgorithm	$06
00011AEA =00000009                M spatnum	=	spatnum+1
00011AEA =00000006                M spal	=	val
00011AEA                            	spFeedback	$07
00011AEA =00000007                M spfe	=	val
00011AEA                            	spDetune	$03, $00, $00, $00
00011AEA =00000003                M spde1	=	op1
00011AEA =00000000                M spde2	=	op2
00011AEA =00000000                M spde3	=	op3
00011AEA =00000000                M spde4	=	op4
00011AEA                            	spMultiple	$06, $00, $01, $04
00011AEA =00000006                M spmu1	=	op1
00011AEA =00000000                M spmu2	=	op2
00011AEA =00000001                M spmu3	=	op3
00011AEA =00000004                M spmu4	=	op4
00011AEA                            	spRateScale	$01, $01, $03, $02
00011AEA =00000001                M sprs1	=	op1
00011AEA =00000001                M sprs2	=	op2
00011AEA =00000003                M sprs3	=	op3
00011AEA =00000002                M sprs4	=	op4
00011AEA                            	spAttackRt	$19, $1F, $19, $1C
00011AEA =00000019                M spar1	=	op1
00011AEA =0000001F                M spar2	=	op2
00011AEA =00000019                M spar3	=	op3
00011AEA =0000001C                M spar4	=	op4
00011AEA                            	spAmpMod	$00, $00, $00, $00
00011AEA =00000000                M spam1	=	op1
00011AEA =00000000                M spam2	=	op2
00011AEA =00000000                M spam3	=	op3
00011AEA =00000000                M spam4	=	op4
00011AEA                            	spSustainRt	$0F, $0F, $04, $0A
00011AEA =0000000F                M spsr1	=	op1
00011AEA =0000000F                M spsr2	=	op2
00011AEA =00000004                M spsr3	=	op3
00011AEA =0000000A                M spsr4	=	op4
00011AEA                            	spDecayRt	$02, $05, $02, $05
00011AEA =00000002                M spdr1	=	op1
00011AEA =00000005                M spdr2	=	op2
00011AEA =00000002                M spdr3	=	op3
00011AEA =00000005                M spdr4	=	op4
00011AEA                            	spSustainLv	$0A, $06, $0A, $06
00011AEA =0000000A                M spsl1	=	op1
00011AEA =00000006                M spsl2	=	op2
00011AEA =0000000A                M spsl3	=	op3
00011AEA =00000006                M spsl4	=	op4
00011AEA                            	spReleaseRt	$09, $06, $0F, $06
00011AEA =00000009                M sprr1	=	op1
00011AEA =00000006                M sprr2	=	op2
00011AEA =0000000F                M sprr3	=	op3
00011AEA =00000006                M sprr4	=	op4
00011AEA                            	spSSGEG		$00, $00, $00, $00
00011AEA =00000000                M spss1	=	op1
00011AEA =00000000                M spss2	=	op2
00011AEA =00000000                M spss3	=	op3
00011AEA =00000000                M spss4	=	op4
00011AEA                            	spTotalLv2	$20, $0A, $00, $00
00011AEA =00000020                M sptl1	=	op1
00011AEA =0000000A                M sptl2	=	op2
00011AEA =00000000                M sptl3	=	op3
00011AEA =00000000                M sptl4	=	op4
00011AEA 3E                       M 	dc.b	(spfe<<3)+spal
00011AEB 3601 0004                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011AEF 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AF3 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AF7 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AFB A9AF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011AFF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B03 2000 0A00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B07 4E41 54                  M 	dc.b	'NAT'
00011B0A                            
00011B0A                            	; Patch $09
00011B0A                            	; $3A
00011B0A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011B0A                            	; $05, $18, $05, $10,	$0B, $1F, $10, $10
00011B0A                            	; $1F, $2F, $4F, $2F,	$0D, $07, $04, $00
00011B0A                            	spAlgorithm	$02
00011B0A =0000000A                M spatnum	=	spatnum+1
00011B0A =00000002                M spal	=	val
00011B0A                            	spFeedback	$07
00011B0A =00000007                M spfe	=	val
00011B0A                            	spDetune	$02, $01, $03, $03
00011B0A =00000002                M spde1	=	op1
00011B0A =00000001                M spde2	=	op2
00011B0A =00000003                M spde3	=	op3
00011B0A =00000003                M spde4	=	op4
00011B0A                            	spMultiple	$01, $00, $00, $02
00011B0A =00000001                M spmu1	=	op1
00011B0A =00000000                M spmu2	=	op2
00011B0A =00000000                M spmu3	=	op3
00011B0A =00000002                M spmu4	=	op4
00011B0A                            	spRateScale	$00, $00, $00, $00
00011B0A =00000000                M sprs1	=	op1
00011B0A =00000000                M sprs2	=	op2
00011B0A =00000000                M sprs3	=	op3
00011B0A =00000000                M sprs4	=	op4
00011B0A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B0A =0000001F                M spar1	=	op1
00011B0A =0000001F                M spar2	=	op2
00011B0A =0000001F                M spar3	=	op3
00011B0A =0000001F                M spar4	=	op4
00011B0A                            	spAmpMod	$00, $00, $00, $00
00011B0A =00000000                M spam1	=	op1
00011B0A =00000000                M spam2	=	op2
00011B0A =00000000                M spam3	=	op3
00011B0A =00000000                M spam4	=	op4
00011B0A                            	spSustainRt	$05, $05, $18, $10
00011B0A =00000005                M spsr1	=	op1
00011B0A =00000005                M spsr2	=	op2
00011B0A =00000018                M spsr3	=	op3
00011B0A =00000010                M spsr4	=	op4
00011B0A                            	spDecayRt	$0B, $10, $1F, $10
00011B0A =0000000B                M spdr1	=	op1
00011B0A =00000010                M spdr2	=	op2
00011B0A =0000001F                M spdr3	=	op3
00011B0A =00000010                M spdr4	=	op4
00011B0A                            	spSustainLv	$01, $04, $02, $02
00011B0A =00000001                M spsl1	=	op1
00011B0A =00000004                M spsl2	=	op2
00011B0A =00000002                M spsl3	=	op3
00011B0A =00000002                M spsl4	=	op4
00011B0A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B0A =0000000F                M sprr1	=	op1
00011B0A =0000000F                M sprr2	=	op2
00011B0A =0000000F                M sprr3	=	op3
00011B0A =0000000F                M sprr4	=	op4
00011B0A                            	spSSGEG		$00, $00, $00, $00
00011B0A =00000000                M spss1	=	op1
00011B0A =00000000                M spss2	=	op2
00011B0A =00000000                M spss3	=	op3
00011B0A =00000000                M spss4	=	op4
00011B0A                            	spTotalLv2	$0D, $04, $07, $00
00011B0A =0000000D                M sptl1	=	op1
00011B0A =00000004                M sptl2	=	op2
00011B0A =00000007                M sptl3	=	op3
00011B0A =00000000                M sptl4	=	op4
00011B0A 3A                       M 	dc.b	(spfe<<3)+spal
00011B0B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B0F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B13 0518 0510                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B17 0B1F 1010                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B1B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B1F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B23 0D07 0400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B27 4E41 54                  M 	dc.b	'NAT'
00011B2A                            
00011B2A                            	; Patch $0A
00011B2A                            	; $3C
00011B2A                            	; $00, $44, $02, $02, 	$1F, $1F, $1F, $15
00011B2A                            	; $00, $1F, $00, $00,	$00, $00, $00, $00
00011B2A                            	; $0F, $0F, $0F, $0F, 	$0D, $80, $28, $80
00011B2A                            	spAlgorithm	$04
00011B2A =0000000B                M spatnum	=	spatnum+1
00011B2A =00000004                M spal	=	val
00011B2A                            	spFeedback	$07
00011B2A =00000007                M spfe	=	val
00011B2A                            	spDetune	$00, $00, $04, $00
00011B2A =00000000                M spde1	=	op1
00011B2A =00000000                M spde2	=	op2
00011B2A =00000004                M spde3	=	op3
00011B2A =00000000                M spde4	=	op4
00011B2A                            	spMultiple	$00, $02, $04, $02
00011B2A =00000000                M spmu1	=	op1
00011B2A =00000002                M spmu2	=	op2
00011B2A =00000004                M spmu3	=	op3
00011B2A =00000002                M spmu4	=	op4
00011B2A                            	spRateScale	$00, $00, $00, $00
00011B2A =00000000                M sprs1	=	op1
00011B2A =00000000                M sprs2	=	op2
00011B2A =00000000                M sprs3	=	op3
00011B2A =00000000                M sprs4	=	op4
00011B2A                            	spAttackRt	$1F, $1F, $1F, $15
00011B2A =0000001F                M spar1	=	op1
00011B2A =0000001F                M spar2	=	op2
00011B2A =0000001F                M spar3	=	op3
00011B2A =00000015                M spar4	=	op4
00011B2A                            	spAmpMod	$00, $00, $00, $00
00011B2A =00000000                M spam1	=	op1
00011B2A =00000000                M spam2	=	op2
00011B2A =00000000                M spam3	=	op3
00011B2A =00000000                M spam4	=	op4
00011B2A                            	spSustainRt	$00, $00, $1F, $00
00011B2A =00000000                M spsr1	=	op1
00011B2A =00000000                M spsr2	=	op2
00011B2A =0000001F                M spsr3	=	op3
00011B2A =00000000                M spsr4	=	op4
00011B2A                            	spDecayRt	$00, $00, $00, $00
00011B2A =00000000                M spdr1	=	op1
00011B2A =00000000                M spdr2	=	op2
00011B2A =00000000                M spdr3	=	op3
00011B2A =00000000                M spdr4	=	op4
00011B2A                            	spSustainLv	$00, $00, $00, $00
00011B2A =00000000                M spsl1	=	op1
00011B2A =00000000                M spsl2	=	op2
00011B2A =00000000                M spsl3	=	op3
00011B2A =00000000                M spsl4	=	op4
00011B2A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B2A =0000000F                M sprr1	=	op1
00011B2A =0000000F                M sprr2	=	op2
00011B2A =0000000F                M sprr3	=	op3
00011B2A =0000000F                M sprr4	=	op4
00011B2A                            	spSSGEG		$00, $00, $00, $00
00011B2A =00000000                M spss1	=	op1
00011B2A =00000000                M spss2	=	op2
00011B2A =00000000                M spss3	=	op3
00011B2A =00000000                M spss4	=	op4
00011B2A                            	spTotalLv2	$0D, $28, $80, $80
00011B2A =0000000D                M sptl1	=	op1
00011B2A =00000028                M sptl2	=	op2
00011B2A =00000080                M sptl3	=	op3
00011B2A =00000080                M sptl4	=	op4
00011B2A 3C                       M 	dc.b	(spfe<<3)+spal
00011B2B 0044 0202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B2F 1F1F 1F15                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B33 001F 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B37 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B3B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B3F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B43 0D80 2880                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B47 4E41 54                  M 	dc.b	'NAT'
00011B4A                            
00011B4A                            	; Patch $0B
00011B4A                            	; $3A
00011B4A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011B4A                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011B4A                            	; $1F, $2F, $4F, $2F,	$0F, $1A, $0E, $00
00011B4A                            	spAlgorithm	$02
00011B4A =0000000C                M spatnum	=	spatnum+1
00011B4A =00000002                M spal	=	val
00011B4A                            	spFeedback	$07
00011B4A =00000007                M spfe	=	val
00011B4A                            	spDetune	$02, $01, $03, $03
00011B4A =00000002                M spde1	=	op1
00011B4A =00000001                M spde2	=	op2
00011B4A =00000003                M spde3	=	op3
00011B4A =00000003                M spde4	=	op4
00011B4A                            	spMultiple	$01, $00, $00, $02
00011B4A =00000001                M spmu1	=	op1
00011B4A =00000000                M spmu2	=	op2
00011B4A =00000000                M spmu3	=	op3
00011B4A =00000002                M spmu4	=	op4
00011B4A                            	spRateScale	$00, $00, $00, $00
00011B4A =00000000                M sprs1	=	op1
00011B4A =00000000                M sprs2	=	op2
00011B4A =00000000                M sprs3	=	op3
00011B4A =00000000                M sprs4	=	op4
00011B4A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B4A =0000001F                M spar1	=	op1
00011B4A =0000001F                M spar2	=	op2
00011B4A =0000001F                M spar3	=	op3
00011B4A =0000001F                M spar4	=	op4
00011B4A                            	spAmpMod	$00, $00, $00, $00
00011B4A =00000000                M spam1	=	op1
00011B4A =00000000                M spam2	=	op2
00011B4A =00000000                M spam3	=	op3
00011B4A =00000000                M spam4	=	op4
00011B4A                            	spSustainRt	$05, $09, $18, $02
00011B4A =00000005                M spsr1	=	op1
00011B4A =00000009                M spsr2	=	op2
00011B4A =00000018                M spsr3	=	op3
00011B4A =00000002                M spsr4	=	op4
00011B4A                            	spDecayRt	$06, $06, $0F, $02
00011B4A =00000006                M spdr1	=	op1
00011B4A =00000006                M spdr2	=	op2
00011B4A =0000000F                M spdr3	=	op3
00011B4A =00000002                M spdr4	=	op4
00011B4A                            	spSustainLv	$01, $04, $02, $02
00011B4A =00000001                M spsl1	=	op1
00011B4A =00000004                M spsl2	=	op2
00011B4A =00000002                M spsl3	=	op3
00011B4A =00000002                M spsl4	=	op4
00011B4A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B4A =0000000F                M sprr1	=	op1
00011B4A =0000000F                M sprr2	=	op2
00011B4A =0000000F                M sprr3	=	op3
00011B4A =0000000F                M sprr4	=	op4
00011B4A                            	spSSGEG		$00, $00, $00, $00
00011B4A =00000000                M spss1	=	op1
00011B4A =00000000                M spss2	=	op2
00011B4A =00000000                M spss3	=	op3
00011B4A =00000000                M spss4	=	op4
00011B4A                            	spTotalLv2	$0F, $0E, $1A, $00
00011B4A =0000000F                M sptl1	=	op1
00011B4A =0000000E                M sptl2	=	op2
00011B4A =0000001A                M sptl3	=	op3
00011B4A =00000000                M sptl4	=	op4
00011B4A 3A                       M 	dc.b	(spfe<<3)+spal
00011B4B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B4F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B53 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B57 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B5B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B5F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B63 0F1A 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B67 4E41 54                  M 	dc.b	'NAT'
00011B6A                            
00011B6A                            	; Patch $0C
00011B6A                            	; $FD
00011B6A                            	; $09, $03, $00, $00, 	$1F, $1F, $1F, $1F
00011B6A                            	; $10, $0C, $0C, $0C,	$0B, $1F, $10, $05
00011B6A                            	; $1F, $2F, $4F, $2F, 	$09, $80, $8E, $88
00011B6A                            	spAlgorithm	$05
00011B6A =0000000D                M spatnum	=	spatnum+1
00011B6A =00000005                M spal	=	val
00011B6A                            	spFeedback	$07
00011B6A =00000007                M spfe	=	val
00011B6A                            	spDetune	$00, $00, $00, $00
00011B6A =00000000                M spde1	=	op1
00011B6A =00000000                M spde2	=	op2
00011B6A =00000000                M spde3	=	op3
00011B6A =00000000                M spde4	=	op4
00011B6A                            	spMultiple	$09, $00, $03, $00
00011B6A =00000009                M spmu1	=	op1
00011B6A =00000000                M spmu2	=	op2
00011B6A =00000003                M spmu3	=	op3
00011B6A =00000000                M spmu4	=	op4
00011B6A                            	spRateScale	$00, $00, $00, $00
00011B6A =00000000                M sprs1	=	op1
00011B6A =00000000                M sprs2	=	op2
00011B6A =00000000                M sprs3	=	op3
00011B6A =00000000                M sprs4	=	op4
00011B6A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B6A =0000001F                M spar1	=	op1
00011B6A =0000001F                M spar2	=	op2
00011B6A =0000001F                M spar3	=	op3
00011B6A =0000001F                M spar4	=	op4
00011B6A                            	spAmpMod	$00, $00, $00, $00
00011B6A =00000000                M spam1	=	op1
00011B6A =00000000                M spam2	=	op2
00011B6A =00000000                M spam3	=	op3
00011B6A =00000000                M spam4	=	op4
00011B6A                            	spSustainRt	$10, $0C, $0C, $0C
00011B6A =00000010                M spsr1	=	op1
00011B6A =0000000C                M spsr2	=	op2
00011B6A =0000000C                M spsr3	=	op3
00011B6A =0000000C                M spsr4	=	op4
00011B6A                            	spDecayRt	$0B, $10, $1F, $05
00011B6A =0000000B                M spdr1	=	op1
00011B6A =00000010                M spdr2	=	op2
00011B6A =0000001F                M spdr3	=	op3
00011B6A =00000005                M spdr4	=	op4
00011B6A                            	spSustainLv	$01, $04, $02, $02
00011B6A =00000001                M spsl1	=	op1
00011B6A =00000004                M spsl2	=	op2
00011B6A =00000002                M spsl3	=	op3
00011B6A =00000002                M spsl4	=	op4
00011B6A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B6A =0000000F                M sprr1	=	op1
00011B6A =0000000F                M sprr2	=	op2
00011B6A =0000000F                M sprr3	=	op3
00011B6A =0000000F                M sprr4	=	op4
00011B6A                            	spSSGEG		$00, $00, $00, $00
00011B6A =00000000                M spss1	=	op1
00011B6A =00000000                M spss2	=	op2
00011B6A =00000000                M spss3	=	op3
00011B6A =00000000                M spss4	=	op4
00011B6A                            	spTotalLv2	$09, $8E, $80, $88
00011B6A =00000009                M sptl1	=	op1
00011B6A =0000008E                M sptl2	=	op2
00011B6A =00000080                M sptl3	=	op3
00011B6A =00000088                M sptl4	=	op4
00011B6A 3D                       M 	dc.b	(spfe<<3)+spal
00011B6B 0903 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B6F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B73 100C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B77 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B7B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B7F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B83 0980 8E88                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B87 4E41 54                  M 	dc.b	'NAT'
00011B8A                            
00011B8A                            	; Patch $0D
00011B8A                            	; $3C
00011B8A                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011B8A                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011B8A                            	; $4F, $3F, $3F, $3F,	$1F, $00, $2B, $00
00011B8A                            	spAlgorithm	$04
00011B8A =0000000E                M spatnum	=	spatnum+1
00011B8A =00000004                M spal	=	val
00011B8A                            	spFeedback	$07
00011B8A =00000007                M spfe	=	val
00011B8A                            	spDetune	$00, $00, $00, $00
00011B8A =00000000                M spde1	=	op1
00011B8A =00000000                M spde2	=	op2
00011B8A =00000000                M spde3	=	op3
00011B8A =00000000                M spde4	=	op4
00011B8A                            	spMultiple	$05, $0A, $01, $01
00011B8A =00000005                M spmu1	=	op1
00011B8A =0000000A                M spmu2	=	op2
00011B8A =00000001                M spmu3	=	op3
00011B8A =00000001                M spmu4	=	op4
00011B8A                            	spRateScale	$01, $01, $01, $01
00011B8A =00000001                M sprs1	=	op1
00011B8A =00000001                M sprs2	=	op2
00011B8A =00000001                M sprs3	=	op3
00011B8A =00000001                M sprs4	=	op4
00011B8A                            	spAttackRt	$16, $1C, $1C, $1C
00011B8A =00000016                M spar1	=	op1
00011B8A =0000001C                M spar2	=	op2
00011B8A =0000001C                M spar3	=	op3
00011B8A =0000001C                M spar4	=	op4
00011B8A                            	spAmpMod	$00, $00, $00, $00
00011B8A =00000000                M spam1	=	op1
00011B8A =00000000                M spam2	=	op2
00011B8A =00000000                M spam3	=	op3
00011B8A =00000000                M spam4	=	op4
00011B8A                            	spSustainRt	$0E, $11, $11, $11
00011B8A =0000000E                M spsr1	=	op1
00011B8A =00000011                M spsr2	=	op2
00011B8A =00000011                M spsr3	=	op3
00011B8A =00000011                M spsr4	=	op4
00011B8A                            	spDecayRt	$09, $06, $0A, $0A
00011B8A =00000009                M spdr1	=	op1
00011B8A =00000006                M spdr2	=	op2
00011B8A =0000000A                M spdr3	=	op3
00011B8A =0000000A                M spdr4	=	op4
00011B8A                            	spSustainLv	$04, $03, $03, $03
00011B8A =00000004                M spsl1	=	op1
00011B8A =00000003                M spsl2	=	op2
00011B8A =00000003                M spsl3	=	op3
00011B8A =00000003                M spsl4	=	op4
00011B8A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B8A =0000000F                M sprr1	=	op1
00011B8A =0000000F                M sprr2	=	op2
00011B8A =0000000F                M sprr3	=	op3
00011B8A =0000000F                M sprr4	=	op4
00011B8A                            	spSSGEG		$00, $00, $00, $00
00011B8A =00000000                M spss1	=	op1
00011B8A =00000000                M spss2	=	op2
00011B8A =00000000                M spss3	=	op3
00011B8A =00000000                M spss4	=	op4
00011B8A                            	spTotalLv2	$1F, $2B, $00, $00
00011B8A =0000001F                M sptl1	=	op1
00011B8A =0000002B                M sptl2	=	op2
00011B8A =00000000                M sptl3	=	op3
00011B8A =00000000                M sptl4	=	op4
00011B8A 3C                       M 	dc.b	(spfe<<3)+spal
00011B8B 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B8F 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B93 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B97 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B9B 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B9F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BA3 1F00 2B00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BA7 4E41 54                  M 	dc.b	'NAT'
00011BAA                            
00011BAA                            	; Patch $0E
00011BAA                            	; $05
00011BAA                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00011BAA                            	; $12, $0C, $0C, $0C,	$12, $08, $08, $08
00011BAA                            	; $1F, $5F, $5F, $5F,	$07, $00, $00, $00
00011BAA                            	spAlgorithm	$05
00011BAA =0000000F                M spatnum	=	spatnum+1
00011BAA =00000005                M spal	=	val
00011BAA                            	spFeedback	$00
00011BAA =00000000                M spfe	=	val
00011BAA                            	spDetune	$00, $00, $00, $00
00011BAA =00000000                M spde1	=	op1
00011BAA =00000000                M spde2	=	op2
00011BAA =00000000                M spde3	=	op3
00011BAA =00000000                M spde4	=	op4
00011BAA                            	spMultiple	$00, $00, $00, $00
00011BAA =00000000                M spmu1	=	op1
00011BAA =00000000                M spmu2	=	op2
00011BAA =00000000                M spmu3	=	op3
00011BAA =00000000                M spmu4	=	op4
00011BAA                            	spRateScale	$00, $00, $00, $00
00011BAA =00000000                M sprs1	=	op1
00011BAA =00000000                M sprs2	=	op2
00011BAA =00000000                M sprs3	=	op3
00011BAA =00000000                M sprs4	=	op4
00011BAA                            	spAttackRt	$1F, $1F, $1F, $1F
00011BAA =0000001F                M spar1	=	op1
00011BAA =0000001F                M spar2	=	op2
00011BAA =0000001F                M spar3	=	op3
00011BAA =0000001F                M spar4	=	op4
00011BAA                            	spAmpMod	$00, $00, $00, $00
00011BAA =00000000                M spam1	=	op1
00011BAA =00000000                M spam2	=	op2
00011BAA =00000000                M spam3	=	op3
00011BAA =00000000                M spam4	=	op4
00011BAA                            	spSustainRt	$12, $0C, $0C, $0C
00011BAA =00000012                M spsr1	=	op1
00011BAA =0000000C                M spsr2	=	op2
00011BAA =0000000C                M spsr3	=	op3
00011BAA =0000000C                M spsr4	=	op4
00011BAA                            	spDecayRt	$12, $08, $08, $08
00011BAA =00000012                M spdr1	=	op1
00011BAA =00000008                M spdr2	=	op2
00011BAA =00000008                M spdr3	=	op3
00011BAA =00000008                M spdr4	=	op4
00011BAA                            	spSustainLv	$01, $05, $05, $05
00011BAA =00000001                M spsl1	=	op1
00011BAA =00000005                M spsl2	=	op2
00011BAA =00000005                M spsl3	=	op3
00011BAA =00000005                M spsl4	=	op4
00011BAA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BAA =0000000F                M sprr1	=	op1
00011BAA =0000000F                M sprr2	=	op2
00011BAA =0000000F                M sprr3	=	op3
00011BAA =0000000F                M sprr4	=	op4
00011BAA                            	spSSGEG		$00, $00, $00, $00
00011BAA =00000000                M spss1	=	op1
00011BAA =00000000                M spss2	=	op2
00011BAA =00000000                M spss3	=	op3
00011BAA =00000000                M spss4	=	op4
00011BAA                            	spTotalLv2	$07, $00, $00, $00
00011BAA =00000007                M sptl1	=	op1
00011BAA =00000000                M sptl2	=	op2
00011BAA =00000000                M sptl3	=	op3
00011BAA =00000000                M sptl4	=	op4
00011BAA 05                       M 	dc.b	(spfe<<3)+spal
00011BAB 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BAF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BB3 120C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BB7 1208 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BBB 1F5F 5F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BBF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BC3 0700 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BC7 4E41 54                  M 	dc.b	'NAT'
00011BCA                            
00011BCA                            	; Patch $0F
00011BCA                            	; $39
00011BCA                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011BCA                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011BCA                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $00
00011BCA                            	spAlgorithm	$01
00011BCA =00000010                M spatnum	=	spatnum+1
00011BCA =00000001                M spal	=	val
00011BCA                            	spFeedback	$07
00011BCA =00000007                M spfe	=	val
00011BCA                            	spDetune	$02, $01, $03, $03
00011BCA =00000002                M spde1	=	op1
00011BCA =00000001                M spde2	=	op2
00011BCA =00000003                M spde3	=	op3
00011BCA =00000003                M spde4	=	op4
00011BCA                            	spMultiple	$01, $00, $00, $02
00011BCA =00000001                M spmu1	=	op1
00011BCA =00000000                M spmu2	=	op2
00011BCA =00000000                M spmu3	=	op3
00011BCA =00000002                M spmu4	=	op4
00011BCA                            	spRateScale	$00, $00, $00, $00
00011BCA =00000000                M sprs1	=	op1
00011BCA =00000000                M sprs2	=	op2
00011BCA =00000000                M sprs3	=	op3
00011BCA =00000000                M sprs4	=	op4
00011BCA                            	spAttackRt	$1F, $1F, $1F, $1F
00011BCA =0000001F                M spar1	=	op1
00011BCA =0000001F                M spar2	=	op2
00011BCA =0000001F                M spar3	=	op3
00011BCA =0000001F                M spar4	=	op4
00011BCA                            	spAmpMod	$00, $00, $00, $00
00011BCA =00000000                M spam1	=	op1
00011BCA =00000000                M spam2	=	op2
00011BCA =00000000                M spam3	=	op3
00011BCA =00000000                M spam4	=	op4
00011BCA                            	spSustainRt	$05, $09, $18, $02
00011BCA =00000005                M spsr1	=	op1
00011BCA =00000009                M spsr2	=	op2
00011BCA =00000018                M spsr3	=	op3
00011BCA =00000002                M spsr4	=	op4
00011BCA                            	spDecayRt	$0B, $10, $1F, $05
00011BCA =0000000B                M spdr1	=	op1
00011BCA =00000010                M spdr2	=	op2
00011BCA =0000001F                M spdr3	=	op3
00011BCA =00000005                M spdr4	=	op4
00011BCA                            	spSustainLv	$01, $04, $02, $02
00011BCA =00000001                M spsl1	=	op1
00011BCA =00000004                M spsl2	=	op2
00011BCA =00000002                M spsl3	=	op3
00011BCA =00000002                M spsl4	=	op4
00011BCA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BCA =0000000F                M sprr1	=	op1
00011BCA =0000000F                M sprr2	=	op2
00011BCA =0000000F                M sprr3	=	op3
00011BCA =0000000F                M sprr4	=	op4
00011BCA                            	spSSGEG		$00, $00, $00, $00
00011BCA =00000000                M spss1	=	op1
00011BCA =00000000                M spss2	=	op2
00011BCA =00000000                M spss3	=	op3
00011BCA =00000000                M spss4	=	op4
00011BCA                            	spTotalLv	$0E, $04, $07, $00
00011BCA =0000000E                M sptl1	=	op1
00011BCA =00000004                M sptl2	=	op2
00011BCA =00000007                M sptl3	=	op3
00011BCA =00000000                M sptl4	=	op4
00011BCA 39                       M 	dc.b	(spfe<<3)+spal
00011BCB =00000080                M sptlmask4	set	$80
00011BCB =00000000                M sptlmask2	set	((spal>=5)<<7)
00011BCB =00000000                M sptlmask3	set	((spal>=4)<<7)
00011BCB =00000000                M sptlmask1	set	((spal=7)<<7)
00011BCB 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BCF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BD3 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BD7 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BDB 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BDF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BE3 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011BE7 4E41 54                  M 	dc.b	'NAT'
00011BEA                            
00011BEA                            	; Patch $10
00011BEA                            	; $35
00011BEA                            	; $14, $1A, $04, $09,	$0E, $10, $11, $0E
00011BEA                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
00011BEA                            	; $2F, $2F, $4F, $4F,	$2F, $12, $12, $80
00011BEA                            	spAlgorithm	$05
00011BEA =00000011                M spatnum	=	spatnum+1
00011BEA =00000005                M spal	=	val
00011BEA                            	spFeedback	$06
00011BEA =00000006                M spfe	=	val
00011BEA                            	spDetune	$01, $00, $01, $00
00011BEA =00000001                M spde1	=	op1
00011BEA =00000000                M spde2	=	op2
00011BEA =00000001                M spde3	=	op3
00011BEA =00000000                M spde4	=	op4
00011BEA                            	spMultiple	$04, $04, $0A, $09
00011BEA =00000004                M spmu1	=	op1
00011BEA =00000004                M spmu2	=	op2
00011BEA =0000000A                M spmu3	=	op3
00011BEA =00000009                M spmu4	=	op4
00011BEA                            	spRateScale	$00, $00, $00, $00
00011BEA =00000000                M sprs1	=	op1
00011BEA =00000000                M sprs2	=	op2
00011BEA =00000000                M sprs3	=	op3
00011BEA =00000000                M sprs4	=	op4
00011BEA                            	spAttackRt	$0E, $11, $10, $0E
00011BEA =0000000E                M spar1	=	op1
00011BEA =00000011                M spar2	=	op2
00011BEA =00000010                M spar3	=	op3
00011BEA =0000000E                M spar4	=	op4
00011BEA                            	spAmpMod	$00, $00, $00, $00
00011BEA =00000000                M spam1	=	op1
00011BEA =00000000                M spam2	=	op2
00011BEA =00000000                M spam3	=	op3
00011BEA =00000000                M spam4	=	op4
00011BEA                            	spSustainRt	$0C, $03, $15, $06
00011BEA =0000000C                M spsr1	=	op1
00011BEA =00000003                M spsr2	=	op2
00011BEA =00000015                M spsr3	=	op3
00011BEA =00000006                M spsr4	=	op4
00011BEA                            	spDecayRt	$16, $09, $0E, $10
00011BEA =00000016                M spdr1	=	op1
00011BEA =00000009                M spdr2	=	op2
00011BEA =0000000E                M spdr3	=	op3
00011BEA =00000010                M spdr4	=	op4
00011BEA                            	spSustainLv	$02, $04, $02, $04
00011BEA =00000002                M spsl1	=	op1
00011BEA =00000004                M spsl2	=	op2
00011BEA =00000002                M spsl3	=	op3
00011BEA =00000004                M spsl4	=	op4
00011BEA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BEA =0000000F                M sprr1	=	op1
00011BEA =0000000F                M sprr2	=	op2
00011BEA =0000000F                M sprr3	=	op3
00011BEA =0000000F                M sprr4	=	op4
00011BEA                            	spSSGEG		$00, $00, $00, $00
00011BEA =00000000                M spss1	=	op1
00011BEA =00000000                M spss2	=	op2
00011BEA =00000000                M spss3	=	op3
00011BEA =00000000                M spss4	=	op4
00011BEA                            	spTotalLv2	$2F, $12, $12, $80
00011BEA =0000002F                M sptl1	=	op1
00011BEA =00000012                M sptl2	=	op2
00011BEA =00000012                M sptl3	=	op3
00011BEA =00000080                M sptl4	=	op4
00011BEA 35                       M 	dc.b	(spfe<<3)+spal
00011BEB 141A 0409                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BEF 0E10 110E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BF3 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BF7 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BFB 2F2F 4F4F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BFF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C03 2F12 1280                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C07 4E41 54                  M 	dc.b	'NAT'
00011C0A                            
00011C0A                            	; Patch $11
00011C0A                            	; $38
00011C0A                            	; $01, $00, $00, $00,	$1F, $1F, $1F, $1F
00011C0A                            	; $09, $09, $09, $0B,	$00, $00, $00, $00
00011C0A                            	; $FF, $FF, $FF, $FF,	$5C, $22, $27, $80
00011C0A                            	spAlgorithm	$00
00011C0A =00000012                M spatnum	=	spatnum+1
00011C0A =00000000                M spal	=	val
00011C0A                            	spFeedback	$07
00011C0A =00000007                M spfe	=	val
00011C0A                            	spDetune	$00, $00, $00, $00
00011C0A =00000000                M spde1	=	op1
00011C0A =00000000                M spde2	=	op2
00011C0A =00000000                M spde3	=	op3
00011C0A =00000000                M spde4	=	op4
00011C0A                            	spMultiple	$01, $00, $00, $00
00011C0A =00000001                M spmu1	=	op1
00011C0A =00000000                M spmu2	=	op2
00011C0A =00000000                M spmu3	=	op3
00011C0A =00000000                M spmu4	=	op4
00011C0A                            	spRateScale	$00, $00, $00, $00
00011C0A =00000000                M sprs1	=	op1
00011C0A =00000000                M sprs2	=	op2
00011C0A =00000000                M sprs3	=	op3
00011C0A =00000000                M sprs4	=	op4
00011C0A                            	spAttackRt	$1F, $1F, $1F, $1F
00011C0A =0000001F                M spar1	=	op1
00011C0A =0000001F                M spar2	=	op2
00011C0A =0000001F                M spar3	=	op3
00011C0A =0000001F                M spar4	=	op4
00011C0A                            	spAmpMod	$00, $00, $00, $00
00011C0A =00000000                M spam1	=	op1
00011C0A =00000000                M spam2	=	op2
00011C0A =00000000                M spam3	=	op3
00011C0A =00000000                M spam4	=	op4
00011C0A                            	spSustainRt	$09, $09, $09, $0B
00011C0A =00000009                M spsr1	=	op1
00011C0A =00000009                M spsr2	=	op2
00011C0A =00000009                M spsr3	=	op3
00011C0A =0000000B                M spsr4	=	op4
00011C0A                            	spDecayRt	$00, $00, $00, $00
00011C0A =00000000                M spdr1	=	op1
00011C0A =00000000                M spdr2	=	op2
00011C0A =00000000                M spdr3	=	op3
00011C0A =00000000                M spdr4	=	op4
00011C0A                            	spSustainLv	$0F, $0F, $0F, $0F
00011C0A =0000000F                M spsl1	=	op1
00011C0A =0000000F                M spsl2	=	op2
00011C0A =0000000F                M spsl3	=	op3
00011C0A =0000000F                M spsl4	=	op4
00011C0A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C0A =0000000F                M sprr1	=	op1
00011C0A =0000000F                M sprr2	=	op2
00011C0A =0000000F                M sprr3	=	op3
00011C0A =0000000F                M sprr4	=	op4
00011C0A                            	spSSGEG		$00, $00, $00, $00
00011C0A =00000000                M spss1	=	op1
00011C0A =00000000                M spss2	=	op2
00011C0A =00000000                M spss3	=	op3
00011C0A =00000000                M spss4	=	op4
00011C0A                            	spTotalLv2	$5C, $27, $22, $80
00011C0A =0000005C                M sptl1	=	op1
00011C0A =00000027                M sptl2	=	op2
00011C0A =00000022                M sptl3	=	op3
00011C0A =00000080                M sptl4	=	op4
00011C0A 38                       M 	dc.b	(spfe<<3)+spal
00011C0B 0100 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C0F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C13 0909 090B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C17 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C1B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C1F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C23 5C22 2780                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C27 4E41 54                  M 	dc.b	'NAT'
00011C2A                            
00011C2A                            	; Patch $12
00011C2A                            	; $3B
00011C2A                            	; $3C, $39, $30, $31,	$DF, $1F, $1F, $DF
00011C2A                            	; $04, $05, $04, $01,	$04, $04, $04, $02
00011C2A                            	; $FF, $0F, $1F, $AF,	$29, $20, $0F, $00
00011C2A                            	spAlgorithm	$03
00011C2A =00000013                M spatnum	=	spatnum+1
00011C2A =00000003                M spal	=	val
00011C2A                            	spFeedback	$07
00011C2A =00000007                M spfe	=	val
00011C2A                            	spDetune	$03, $03, $03, $03
00011C2A =00000003                M spde1	=	op1
00011C2A =00000003                M spde2	=	op2
00011C2A =00000003                M spde3	=	op3
00011C2A =00000003                M spde4	=	op4
00011C2A                            	spMultiple	$0C, $00, $09, $01
00011C2A =0000000C                M spmu1	=	op1
00011C2A =00000000                M spmu2	=	op2
00011C2A =00000009                M spmu3	=	op3
00011C2A =00000001                M spmu4	=	op4
00011C2A                            	spRateScale	$03, $00, $00, $03
00011C2A =00000003                M sprs1	=	op1
00011C2A =00000000                M sprs2	=	op2
00011C2A =00000000                M sprs3	=	op3
00011C2A =00000003                M sprs4	=	op4
00011C2A                            	spAttackRt	$1F, $1F, $1F, $1F
00011C2A =0000001F                M spar1	=	op1
00011C2A =0000001F                M spar2	=	op2
00011C2A =0000001F                M spar3	=	op3
00011C2A =0000001F                M spar4	=	op4
00011C2A                            	spAmpMod	$00, $00, $00, $00
00011C2A =00000000                M spam1	=	op1
00011C2A =00000000                M spam2	=	op2
00011C2A =00000000                M spam3	=	op3
00011C2A =00000000                M spam4	=	op4
00011C2A                            	spSustainRt	$04, $04, $05, $01
00011C2A =00000004                M spsr1	=	op1
00011C2A =00000004                M spsr2	=	op2
00011C2A =00000005                M spsr3	=	op3
00011C2A =00000001                M spsr4	=	op4
00011C2A                            	spDecayRt	$04, $04, $04, $02
00011C2A =00000004                M spdr1	=	op1
00011C2A =00000004                M spdr2	=	op2
00011C2A =00000004                M spdr3	=	op3
00011C2A =00000002                M spdr4	=	op4
00011C2A                            	spSustainLv	$0F, $01, $00, $0A
00011C2A =0000000F                M spsl1	=	op1
00011C2A =00000001                M spsl2	=	op2
00011C2A =00000000                M spsl3	=	op3
00011C2A =0000000A                M spsl4	=	op4
00011C2A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C2A =0000000F                M sprr1	=	op1
00011C2A =0000000F                M sprr2	=	op2
00011C2A =0000000F                M sprr3	=	op3
00011C2A =0000000F                M sprr4	=	op4
00011C2A                            	spSSGEG		$00, $00, $00, $00
00011C2A =00000000                M spss1	=	op1
00011C2A =00000000                M spss2	=	op2
00011C2A =00000000                M spss3	=	op3
00011C2A =00000000                M spss4	=	op4
00011C2A                            	spTotalLv2	$29, $0F, $20, $00
00011C2A =00000029                M sptl1	=	op1
00011C2A =0000000F                M sptl2	=	op2
00011C2A =00000020                M sptl3	=	op3
00011C2A =00000000                M sptl4	=	op4
00011C2A 3B                       M 	dc.b	(spfe<<3)+spal
00011C2B 3C39 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C2F DF1F 1FDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C33 0405 0401                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C37 0404 0402                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C3B FF0F 1FAF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C3F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C43 2920 0F00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C47 4E41 54                  M 	dc.b	'NAT'
00011C4A                            
00011C4A                            	; Patch $13
00011C4A                            	; $3A
00011C4A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011C4A                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011C4A                            	; $1F, $2F, $4F, $2F,	$0F, $0E, $0E, $00
00011C4A                            	spAlgorithm	$02
00011C4A =00000014                M spatnum	=	spatnum+1
00011C4A =00000002                M spal	=	val
00011C4A                            	spFeedback	$07
00011C4A =00000007                M spfe	=	val
00011C4A                            	spDetune	$02, $01, $03, $03
00011C4A =00000002                M spde1	=	op1
00011C4A =00000001                M spde2	=	op2
00011C4A =00000003                M spde3	=	op3
00011C4A =00000003                M spde4	=	op4
00011C4A                            	spMultiple	$01, $00, $00, $02
00011C4A =00000001                M spmu1	=	op1
00011C4A =00000000                M spmu2	=	op2
00011C4A =00000000                M spmu3	=	op3
00011C4A =00000002                M spmu4	=	op4
00011C4A                            	spRateScale	$00, $00, $00, $00
00011C4A =00000000                M sprs1	=	op1
00011C4A =00000000                M sprs2	=	op2
00011C4A =00000000                M sprs3	=	op3
00011C4A =00000000                M sprs4	=	op4
00011C4A                            	spAttackRt	$1F, $1F, $1F, $1F
00011C4A =0000001F                M spar1	=	op1
00011C4A =0000001F                M spar2	=	op2
00011C4A =0000001F                M spar3	=	op3
00011C4A =0000001F                M spar4	=	op4
00011C4A                            	spAmpMod	$00, $00, $00, $00
00011C4A =00000000                M spam1	=	op1
00011C4A =00000000                M spam2	=	op2
00011C4A =00000000                M spam3	=	op3
00011C4A =00000000                M spam4	=	op4
00011C4A                            	spSustainRt	$05, $09, $18, $02
00011C4A =00000005                M spsr1	=	op1
00011C4A =00000009                M spsr2	=	op2
00011C4A =00000018                M spsr3	=	op3
00011C4A =00000002                M spsr4	=	op4
00011C4A                            	spDecayRt	$06, $06, $0F, $02
00011C4A =00000006                M spdr1	=	op1
00011C4A =00000006                M spdr2	=	op2
00011C4A =0000000F                M spdr3	=	op3
00011C4A =00000002                M spdr4	=	op4
00011C4A                            	spSustainLv	$01, $04, $02, $02
00011C4A =00000001                M spsl1	=	op1
00011C4A =00000004                M spsl2	=	op2
00011C4A =00000002                M spsl3	=	op3
00011C4A =00000002                M spsl4	=	op4
00011C4A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C4A =0000000F                M sprr1	=	op1
00011C4A =0000000F                M sprr2	=	op2
00011C4A =0000000F                M sprr3	=	op3
00011C4A =0000000F                M sprr4	=	op4
00011C4A                            	spSSGEG		$00, $00, $00, $00
00011C4A =00000000                M spss1	=	op1
00011C4A =00000000                M spss2	=	op2
00011C4A =00000000                M spss3	=	op3
00011C4A =00000000                M spss4	=	op4
00011C4A                            	spTotalLv2	$0F, $0E, $0E, $00
00011C4A =0000000F                M sptl1	=	op1
00011C4A =0000000E                M sptl2	=	op2
00011C4A =0000000E                M sptl3	=	op3
00011C4A =00000000                M sptl4	=	op4
00011C4A 3A                       M 	dc.b	(spfe<<3)+spal
00011C4B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C4F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C53 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C57 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C5B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C5F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C63 0F0E 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C67 4E41 54                  M 	dc.b	'NAT'
00011C6A                            
00011C6A                            	; Patch $14
00011C6A                            	; $07
00011C6A                            	; $04, $04, $05, $04,	$1F, $1F, $15, $15
00011C6A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011C6A                            	; $1F, $1F, $1F, $1F,	$7F, $7F, $80, $80
00011C6A                            	spAlgorithm	$07
00011C6A =00000015                M spatnum	=	spatnum+1
00011C6A =00000007                M spal	=	val
00011C6A                            	spFeedback	$00
00011C6A =00000000                M spfe	=	val
00011C6A                            	spDetune	$00, $00, $00, $00
00011C6A =00000000                M spde1	=	op1
00011C6A =00000000                M spde2	=	op2
00011C6A =00000000                M spde3	=	op3
00011C6A =00000000                M spde4	=	op4
00011C6A                            	spMultiple	$04, $05, $04, $04
00011C6A =00000004                M spmu1	=	op1
00011C6A =00000005                M spmu2	=	op2
00011C6A =00000004                M spmu3	=	op3
00011C6A =00000004                M spmu4	=	op4
00011C6A                            	spRateScale	$00, $00, $00, $00
00011C6A =00000000                M sprs1	=	op1
00011C6A =00000000                M sprs2	=	op2
00011C6A =00000000                M sprs3	=	op3
00011C6A =00000000                M sprs4	=	op4
00011C6A                            	spAttackRt	$1F, $15, $1F, $15
00011C6A =0000001F                M spar1	=	op1
00011C6A =00000015                M spar2	=	op2
00011C6A =0000001F                M spar3	=	op3
00011C6A =00000015                M spar4	=	op4
00011C6A                            	spAmpMod	$00, $00, $00, $00
00011C6A =00000000                M spam1	=	op1
00011C6A =00000000                M spam2	=	op2
00011C6A =00000000                M spam3	=	op3
00011C6A =00000000                M spam4	=	op4
00011C6A                            	spSustainRt	$00, $00, $00, $00
00011C6A =00000000                M spsr1	=	op1
00011C6A =00000000                M spsr2	=	op2
00011C6A =00000000                M spsr3	=	op3
00011C6A =00000000                M spsr4	=	op4
00011C6A                            	spDecayRt	$00, $00, $00, $00
00011C6A =00000000                M spdr1	=	op1
00011C6A =00000000                M spdr2	=	op2
00011C6A =00000000                M spdr3	=	op3
00011C6A =00000000                M spdr4	=	op4
00011C6A                            	spSustainLv	$01, $01, $01, $01
00011C6A =00000001                M spsl1	=	op1
00011C6A =00000001                M spsl2	=	op2
00011C6A =00000001                M spsl3	=	op3
00011C6A =00000001                M spsl4	=	op4
00011C6A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C6A =0000000F                M sprr1	=	op1
00011C6A =0000000F                M sprr2	=	op2
00011C6A =0000000F                M sprr3	=	op3
00011C6A =0000000F                M sprr4	=	op4
00011C6A                            	spSSGEG		$00, $00, $00, $00
00011C6A =00000000                M spss1	=	op1
00011C6A =00000000                M spss2	=	op2
00011C6A =00000000                M spss3	=	op3
00011C6A =00000000                M spss4	=	op4
00011C6A                            	spTotalLv2	$7F, $80, $7F, $80
00011C6A =0000007F                M sptl1	=	op1
00011C6A =00000080                M sptl2	=	op2
00011C6A =0000007F                M sptl3	=	op3
00011C6A =00000080                M sptl4	=	op4
00011C6A 07                       M 	dc.b	(spfe<<3)+spal
00011C6B 0404 0504                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C6F 1F1F 1515                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C73 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C77 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C7B 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C7F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C83 7F7F 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C87 4E41 54                  M 	dc.b	'NAT'
00011C8A                            
00011C8A                            	; Patch $15
00011C8A                            	; $00
00011C8A                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011C8A                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011C8A                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $00
00011C8A                            	spAlgorithm	$00
00011C8A =00000016                M spatnum	=	spatnum+1
00011C8A =00000000                M spal	=	val
00011C8A                            	spFeedback	$00
00011C8A =00000000                M spfe	=	val
00011C8A                            	spDetune	$00, $00, $00, $00
00011C8A =00000000                M spde1	=	op1
00011C8A =00000000                M spde2	=	op2
00011C8A =00000000                M spde3	=	op3
00011C8A =00000000                M spde4	=	op4
00011C8A                            	spMultiple	$00, $02, $03, $00
00011C8A =00000000                M spmu1	=	op1
00011C8A =00000002                M spmu2	=	op2
00011C8A =00000003                M spmu3	=	op3
00011C8A =00000000                M spmu4	=	op4
00011C8A                            	spRateScale	$03, $00, $03, $00
00011C8A =00000003                M sprs1	=	op1
00011C8A =00000000                M sprs2	=	op2
00011C8A =00000003                M sprs3	=	op3
00011C8A =00000000                M sprs4	=	op4
00011C8A                            	spAttackRt	$19, $1F, $1F, $1F
00011C8A =00000019                M spar1	=	op1
00011C8A =0000001F                M spar2	=	op2
00011C8A =0000001F                M spar3	=	op3
00011C8A =0000001F                M spar4	=	op4
00011C8A                            	spAmpMod	$00, $00, $00, $00
00011C8A =00000000                M spam1	=	op1
00011C8A =00000000                M spam2	=	op2
00011C8A =00000000                M spam3	=	op3
00011C8A =00000000                M spam4	=	op4
00011C8A                            	spSustainRt	$12, $14, $11, $0F
00011C8A =00000012                M spsr1	=	op1
00011C8A =00000014                M spsr2	=	op2
00011C8A =00000011                M spsr3	=	op3
00011C8A =0000000F                M spsr4	=	op4
00011C8A                            	spDecayRt	$0A, $0A, $00, $0D
00011C8A =0000000A                M spdr1	=	op1
00011C8A =0000000A                M spdr2	=	op2
00011C8A =00000000                M spdr3	=	op3
00011C8A =0000000D                M spdr4	=	op4
00011C8A                            	spSustainLv	$0F, $0F, $0F, $0F
00011C8A =0000000F                M spsl1	=	op1
00011C8A =0000000F                M spsl2	=	op2
00011C8A =0000000F                M spsl3	=	op3
00011C8A =0000000F                M spsl4	=	op4
00011C8A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C8A =0000000F                M sprr1	=	op1
00011C8A =0000000F                M sprr2	=	op2
00011C8A =0000000F                M sprr3	=	op3
00011C8A =0000000F                M sprr4	=	op4
00011C8A                            	spSSGEG		$00, $00, $00, $00
00011C8A =00000000                M spss1	=	op1
00011C8A =00000000                M spss2	=	op2
00011C8A =00000000                M spss3	=	op3
00011C8A =00000000                M spss4	=	op4
00011C8A                            	spTotalLv2	$22, $27, $07, $00
00011C8A =00000022                M sptl1	=	op1
00011C8A =00000027                M sptl2	=	op2
00011C8A =00000007                M sptl3	=	op3
00011C8A =00000000                M sptl4	=	op4
00011C8A 00                       M 	dc.b	(spfe<<3)+spal
00011C8B 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C8F D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C93 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C97 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C9B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C9F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CA3 2207 2700                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011CA7 4E41 54                  M 	dc.b	'NAT'
00011CAA                            
00011CAA                            	; Patch $16
00011CAA                            	; $20
00011CAA                            	; $36, $35, $30, $31,	$41, $49, $3B, $4B
00011CAA                            	; $09, $06, $09, $08,	$01, $03, $02, $A9
00011CAA                            	; $0F, $0F, $0F, $0F,	$29, $27, $23, $00
00011CAA                            	spAlgorithm	$00
00011CAA =00000017                M spatnum	=	spatnum+1
00011CAA =00000000                M spal	=	val
00011CAA                            	spFeedback	$04
00011CAA =00000004                M spfe	=	val
00011CAA                            	spDetune	$03, $03, $03, $03
00011CAA =00000003                M spde1	=	op1
00011CAA =00000003                M spde2	=	op2
00011CAA =00000003                M spde3	=	op3
00011CAA =00000003                M spde4	=	op4
00011CAA                            	spMultiple	$06, $00, $05, $01
00011CAA =00000006                M spmu1	=	op1
00011CAA =00000000                M spmu2	=	op2
00011CAA =00000005                M spmu3	=	op3
00011CAA =00000001                M spmu4	=	op4
00011CAA                            	spRateScale	$01, $00, $01, $01
00011CAA =00000001                M sprs1	=	op1
00011CAA =00000000                M sprs2	=	op2
00011CAA =00000001                M sprs3	=	op3
00011CAA =00000001                M sprs4	=	op4
00011CAA                            	spAttackRt	$01, $1B, $09, $0B
00011CAA =00000001                M spar1	=	op1
00011CAA =0000001B                M spar2	=	op2
00011CAA =00000009                M spar3	=	op3
00011CAA =0000000B                M spar4	=	op4
00011CAA                            	spAmpMod	$00, $00, $00, $00
00011CAA =00000000                M spam1	=	op1
00011CAA =00000000                M spam2	=	op2
00011CAA =00000000                M spam3	=	op3
00011CAA =00000000                M spam4	=	op4
00011CAA                            	spSustainRt	$09, $09, $06, $08
00011CAA =00000009                M spsr1	=	op1
00011CAA =00000009                M spsr2	=	op2
00011CAA =00000006                M spsr3	=	op3
00011CAA =00000008                M spsr4	=	op4
00011CAA                            	spDecayRt	$01, $02, $03, $A9
00011CAA =00000001                M spdr1	=	op1
00011CAA =00000002                M spdr2	=	op2
00011CAA =00000003                M spdr3	=	op3
00011CAA =000000A9                M spdr4	=	op4
00011CAA                            	spSustainLv	$00, $00, $00, $00
00011CAA =00000000                M spsl1	=	op1
00011CAA =00000000                M spsl2	=	op2
00011CAA =00000000                M spsl3	=	op3
00011CAA =00000000                M spsl4	=	op4
00011CAA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CAA =0000000F                M sprr1	=	op1
00011CAA =0000000F                M sprr2	=	op2
00011CAA =0000000F                M sprr3	=	op3
00011CAA =0000000F                M sprr4	=	op4
00011CAA                            	spSSGEG		$00, $00, $00, $00
00011CAA =00000000                M spss1	=	op1
00011CAA =00000000                M spss2	=	op2
00011CAA =00000000                M spss3	=	op3
00011CAA =00000000                M spss4	=	op4
00011CAA                            	spTotalLv2	$29, $23, $27, $00
00011CAA =00000029                M sptl1	=	op1
00011CAA =00000023                M sptl2	=	op2
00011CAA =00000027                M sptl3	=	op3
00011CAA =00000000                M sptl4	=	op4
00011CAA 20                       M 	dc.b	(spfe<<3)+spal
00011CAB 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CAF 4149 1B4B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CB3 0906 0908                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CB7 0103 02A9                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CBB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CBF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CC3 2927 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011CC7 4E41 54                  M 	dc.b	'NAT'
00011CCA                            
00011CCA                            	; Patch $17
00011CCA                            	; $30
00011CCA                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011CCA                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011CCA                            	; $BF, $BF, $BF, $BF,	$10, $3A, $10, $00
00011CCA                            	spAlgorithm	$00
00011CCA =00000018                M spatnum	=	spatnum+1
00011CCA =00000000                M spal	=	val
00011CCA                            	spFeedback	$06
00011CCA =00000006                M spfe	=	val
00011CCA                            	spDetune	$03, $03, $03, $03
00011CCA =00000003                M spde1	=	op1
00011CCA =00000003                M spde2	=	op2
00011CCA =00000003                M spde3	=	op3
00011CCA =00000003                M spde4	=	op4
00011CCA                            	spMultiple	$00, $00, $00, $00
00011CCA =00000000                M spmu1	=	op1
00011CCA =00000000                M spmu2	=	op2
00011CCA =00000000                M spmu3	=	op3
00011CCA =00000000                M spmu4	=	op4
00011CCA                            	spRateScale	$02, $03, $03, $03
00011CCA =00000002                M sprs1	=	op1
00011CCA =00000003                M sprs2	=	op2
00011CCA =00000003                M sprs3	=	op3
00011CCA =00000003                M sprs4	=	op4
00011CCA                            	spAttackRt	$1E, $1C, $18, $1C
00011CCA =0000001E                M spar1	=	op1
00011CCA =0000001C                M spar2	=	op2
00011CCA =00000018                M spar3	=	op3
00011CCA =0000001C                M spar4	=	op4
00011CCA                            	spAmpMod	$00, $00, $00, $00
00011CCA =00000000                M spam1	=	op1
00011CCA =00000000                M spam2	=	op2
00011CCA =00000000                M spam3	=	op3
00011CCA =00000000                M spam4	=	op4
00011CCA                            	spSustainRt	$0E, $04, $0A, $05
00011CCA =0000000E                M spsr1	=	op1
00011CCA =00000004                M spsr2	=	op2
00011CCA =0000000A                M spsr3	=	op3
00011CCA =00000005                M spsr4	=	op4
00011CCA                            	spDecayRt	$08, $08, $08, $08
00011CCA =00000008                M spdr1	=	op1
00011CCA =00000008                M spdr2	=	op2
00011CCA =00000008                M spdr3	=	op3
00011CCA =00000008                M spdr4	=	op4
00011CCA                            	spSustainLv	$0B, $0B, $0B, $0B
00011CCA =0000000B                M spsl1	=	op1
00011CCA =0000000B                M spsl2	=	op2
00011CCA =0000000B                M spsl3	=	op3
00011CCA =0000000B                M spsl4	=	op4
00011CCA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CCA =0000000F                M sprr1	=	op1
00011CCA =0000000F                M sprr2	=	op2
00011CCA =0000000F                M sprr3	=	op3
00011CCA =0000000F                M sprr4	=	op4
00011CCA                            	spSSGEG		$00, $00, $00, $00
00011CCA =00000000                M spss1	=	op1
00011CCA =00000000                M spss2	=	op2
00011CCA =00000000                M spss3	=	op3
00011CCA =00000000                M spss4	=	op4
00011CCA                            	spTotalLv2	$10, $10, $3A, $00
00011CCA =00000010                M sptl1	=	op1
00011CCA =00000010                M sptl2	=	op2
00011CCA =0000003A                M sptl3	=	op3
00011CCA =00000000                M sptl4	=	op4
00011CCA 30                       M 	dc.b	(spfe<<3)+spal
00011CCB 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CCF 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CD3 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CD7 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CDB BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CDF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CE3 103A 1000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011CE7 4E41 54                  M 	dc.b	'NAT'
00011CEA                            
00011CEA                            	; Patch $18
00011CEA                            	; $04
00011CEA                            	; $00, $01, $00, $05,	$0F, $1F, $0F, $1F
00011CEA                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011CEA                            	; $8F, $8F, $8F, $8F,	$1F, $8D, $1F, $80
00011CEA                            	spAlgorithm	$04
00011CEA =00000019                M spatnum	=	spatnum+1
00011CEA =00000004                M spal	=	val
00011CEA                            	spFeedback	$00
00011CEA =00000000                M spfe	=	val
00011CEA                            	spDetune	$00, $00, $00, $00
00011CEA =00000000                M spde1	=	op1
00011CEA =00000000                M spde2	=	op2
00011CEA =00000000                M spde3	=	op3
00011CEA =00000000                M spde4	=	op4
00011CEA                            	spMultiple	$00, $00, $01, $05
00011CEA =00000000                M spmu1	=	op1
00011CEA =00000000                M spmu2	=	op2
00011CEA =00000001                M spmu3	=	op3
00011CEA =00000005                M spmu4	=	op4
00011CEA                            	spRateScale	$00, $00, $00, $00
00011CEA =00000000                M sprs1	=	op1
00011CEA =00000000                M sprs2	=	op2
00011CEA =00000000                M sprs3	=	op3
00011CEA =00000000                M sprs4	=	op4
00011CEA                            	spAttackRt	$0F, $0F, $1F, $1F
00011CEA =0000000F                M spar1	=	op1
00011CEA =0000000F                M spar2	=	op2
00011CEA =0000001F                M spar3	=	op3
00011CEA =0000001F                M spar4	=	op4
00011CEA                            	spAmpMod	$00, $00, $00, $00
00011CEA =00000000                M spam1	=	op1
00011CEA =00000000                M spam2	=	op2
00011CEA =00000000                M spam3	=	op3
00011CEA =00000000                M spam4	=	op4
00011CEA                            	spSustainRt	$00, $00, $00, $00
00011CEA =00000000                M spsr1	=	op1
00011CEA =00000000                M spsr2	=	op2
00011CEA =00000000                M spsr3	=	op3
00011CEA =00000000                M spsr4	=	op4
00011CEA                            	spDecayRt	$00, $00, $00, $00
00011CEA =00000000                M spdr1	=	op1
00011CEA =00000000                M spdr2	=	op2
00011CEA =00000000                M spdr3	=	op3
00011CEA =00000000                M spdr4	=	op4
00011CEA                            	spSustainLv	$08, $08, $08, $08
00011CEA =00000008                M spsl1	=	op1
00011CEA =00000008                M spsl2	=	op2
00011CEA =00000008                M spsl3	=	op3
00011CEA =00000008                M spsl4	=	op4
00011CEA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CEA =0000000F                M sprr1	=	op1
00011CEA =0000000F                M sprr2	=	op2
00011CEA =0000000F                M sprr3	=	op3
00011CEA =0000000F                M sprr4	=	op4
00011CEA                            	spSSGEG		$00, $00, $00, $00
00011CEA =00000000                M spss1	=	op1
00011CEA =00000000                M spss2	=	op2
00011CEA =00000000                M spss3	=	op3
00011CEA =00000000                M spss4	=	op4
00011CEA                            	spTotalLv2	$1F, $1F, $8D, $80
00011CEA =0000001F                M sptl1	=	op1
00011CEA =0000001F                M sptl2	=	op2
00011CEA =0000008D                M sptl3	=	op3
00011CEA =00000080                M sptl4	=	op4
00011CEA 04                       M 	dc.b	(spfe<<3)+spal
00011CEB 0001 0005                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CEF 0F1F 0F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CF3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CF7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CFB 8F8F 8F8F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CFF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D03 1F8D 1F80                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011D07 4E41 54                  M 	dc.b	'NAT'
00011D0A                            
00011D0A                            	; Patch $19
00011D0A                            	; $3C
00011D0A                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011D0A                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011D0A                            	; $4F, $3F, $3F, $3F,	$17, $80, $20, $80
00011D0A                            	spAlgorithm	$04
00011D0A =0000001A                M spatnum	=	spatnum+1
00011D0A =00000004                M spal	=	val
00011D0A                            	spFeedback	$07
00011D0A =00000007                M spfe	=	val
00011D0A                            	spDetune	$00, $00, $00, $00
00011D0A =00000000                M spde1	=	op1
00011D0A =00000000                M spde2	=	op2
00011D0A =00000000                M spde3	=	op3
00011D0A =00000000                M spde4	=	op4
00011D0A                            	spMultiple	$05, $0A, $01, $01
00011D0A =00000005                M spmu1	=	op1
00011D0A =0000000A                M spmu2	=	op2
00011D0A =00000001                M spmu3	=	op3
00011D0A =00000001                M spmu4	=	op4
00011D0A                            	spRateScale	$01, $01, $01, $01
00011D0A =00000001                M sprs1	=	op1
00011D0A =00000001                M sprs2	=	op2
00011D0A =00000001                M sprs3	=	op3
00011D0A =00000001                M sprs4	=	op4
00011D0A                            	spAttackRt	$16, $1C, $1C, $1C
00011D0A =00000016                M spar1	=	op1
00011D0A =0000001C                M spar2	=	op2
00011D0A =0000001C                M spar3	=	op3
00011D0A =0000001C                M spar4	=	op4
00011D0A                            	spAmpMod	$00, $00, $00, $00
00011D0A =00000000                M spam1	=	op1
00011D0A =00000000                M spam2	=	op2
00011D0A =00000000                M spam3	=	op3
00011D0A =00000000                M spam4	=	op4
00011D0A                            	spSustainRt	$0E, $11, $11, $11
00011D0A =0000000E                M spsr1	=	op1
00011D0A =00000011                M spsr2	=	op2
00011D0A =00000011                M spsr3	=	op3
00011D0A =00000011                M spsr4	=	op4
00011D0A                            	spDecayRt	$09, $06, $0A, $0A
00011D0A =00000009                M spdr1	=	op1
00011D0A =00000006                M spdr2	=	op2
00011D0A =0000000A                M spdr3	=	op3
00011D0A =0000000A                M spdr4	=	op4
00011D0A                            	spSustainLv	$04, $03, $03, $03
00011D0A =00000004                M spsl1	=	op1
00011D0A =00000003                M spsl2	=	op2
00011D0A =00000003                M spsl3	=	op3
00011D0A =00000003                M spsl4	=	op4
00011D0A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011D0A =0000000F                M sprr1	=	op1
00011D0A =0000000F                M sprr2	=	op2
00011D0A =0000000F                M sprr3	=	op3
00011D0A =0000000F                M sprr4	=	op4
00011D0A                            	spSSGEG		$00, $00, $00, $00
00011D0A =00000000                M spss1	=	op1
00011D0A =00000000                M spss2	=	op2
00011D0A =00000000                M spss3	=	op3
00011D0A =00000000                M spss4	=	op4
00011D0A                            	spTotalLv	$17, $20, $00, $00
00011D0A =00000017                M sptl1	=	op1
00011D0A =00000020                M sptl2	=	op2
00011D0A =00000000                M sptl3	=	op3
00011D0A =00000000                M sptl4	=	op4
00011D0A 3C                       M 	dc.b	(spfe<<3)+spal
00011D0B =00000080                M sptlmask4	set	$80
00011D0B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011D0B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011D0B =00000000                M sptlmask1	set	((spal=7)<<7)
00011D0B 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D0F 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D13 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D17 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D1B 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D1F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D23 1780 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D27 4E41 54                  M 	dc.b	'NAT'
00011D2A                            
00011D2A                            	; Patch $1A
00011D2A                            	; $F9
00011D2A                            	; $21, $30, $10, $32,	$1C, $1F, $1F, $10
00011D2A                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011D2A                            	; $1F, $2F, $4F, $2F,	$0C, $06, $04, $80
00011D2A                            	spAlgorithm	$01
00011D2A =0000001B                M spatnum	=	spatnum+1
00011D2A =00000001                M spal	=	val
00011D2A                            	spFeedback	$07
00011D2A =00000007                M spfe	=	val
00011D2A                            	spDetune	$02, $01, $03, $03
00011D2A =00000002                M spde1	=	op1
00011D2A =00000001                M spde2	=	op2
00011D2A =00000003                M spde3	=	op3
00011D2A =00000003                M spde4	=	op4
00011D2A                            	spMultiple	$01, $00, $00, $02
00011D2A =00000001                M spmu1	=	op1
00011D2A =00000000                M spmu2	=	op2
00011D2A =00000000                M spmu3	=	op3
00011D2A =00000002                M spmu4	=	op4
00011D2A                            	spRateScale	$00, $00, $00, $00
00011D2A =00000000                M sprs1	=	op1
00011D2A =00000000                M sprs2	=	op2
00011D2A =00000000                M sprs3	=	op3
00011D2A =00000000                M sprs4	=	op4
00011D2A                            	spAttackRt	$1C, $1F, $1F, $10
00011D2A =0000001C                M spar1	=	op1
00011D2A =0000001F                M spar2	=	op2
00011D2A =0000001F                M spar3	=	op3
00011D2A =00000010                M spar4	=	op4
00011D2A                            	spAmpMod	$00, $00, $00, $00
00011D2A =00000000                M spam1	=	op1
00011D2A =00000000                M spam2	=	op2
00011D2A =00000000                M spam3	=	op3
00011D2A =00000000                M spam4	=	op4
00011D2A                            	spSustainRt	$05, $09, $18, $02
00011D2A =00000005                M spsr1	=	op1
00011D2A =00000009                M spsr2	=	op2
00011D2A =00000018                M spsr3	=	op3
00011D2A =00000002                M spsr4	=	op4
00011D2A                            	spDecayRt	$0B, $10, $1F, $05
00011D2A =0000000B                M spdr1	=	op1
00011D2A =00000010                M spdr2	=	op2
00011D2A =0000001F                M spdr3	=	op3
00011D2A =00000005                M spdr4	=	op4
00011D2A                            	spSustainLv	$01, $04, $02, $02
00011D2A =00000001                M spsl1	=	op1
00011D2A =00000004                M spsl2	=	op2
00011D2A =00000002                M spsl3	=	op3
00011D2A =00000002                M spsl4	=	op4
00011D2A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011D2A =0000000F                M sprr1	=	op1
00011D2A =0000000F                M sprr2	=	op2
00011D2A =0000000F                M sprr3	=	op3
00011D2A =0000000F                M sprr4	=	op4
00011D2A                            	spSSGEG		$00, $00, $00, $00
00011D2A =00000000                M spss1	=	op1
00011D2A =00000000                M spss2	=	op2
00011D2A =00000000                M spss3	=	op3
00011D2A =00000000                M spss4	=	op4
00011D2A                            	spTotalLv	$0C, $04, $06, $00
00011D2A =0000000C                M sptl1	=	op1
00011D2A =00000004                M sptl2	=	op2
00011D2A =00000006                M sptl3	=	op3
00011D2A =00000000                M sptl4	=	op4
00011D2A 39                       M 	dc.b	(spfe<<3)+spal
00011D2B =00000080                M sptlmask4	set	$80
00011D2B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011D2B =00000000                M sptlmask3	set	((spal>=4)<<7)
00011D2B =00000000                M sptlmask1	set	((spal=7)<<7)
00011D2B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D2F 1C1F 1F10                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D33 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D37 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D3B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D3F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D43 0C06 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D47 4E41 54                  M 	dc.b	'NAT'
00011D4A                            
00011D4A                            	; Patch $1B
00011D4A                            	; $00
00011D4A                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011D4A                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011D4A                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $80
00011D4A                            	spAlgorithm	$00
00011D4A =0000001C                M spatnum	=	spatnum+1
00011D4A =00000000                M spal	=	val
00011D4A                            	spFeedback	$00
00011D4A =00000000                M spfe	=	val
00011D4A                            	spDetune	$00, $00, $00, $00
00011D4A =00000000                M spde1	=	op1
00011D4A =00000000                M spde2	=	op2
00011D4A =00000000                M spde3	=	op3
00011D4A =00000000                M spde4	=	op4
00011D4A                            	spMultiple	$00, $02, $03, $00
00011D4A =00000000                M spmu1	=	op1
00011D4A =00000002                M spmu2	=	op2
00011D4A =00000003                M spmu3	=	op3
00011D4A =00000000                M spmu4	=	op4
00011D4A                            	spRateScale	$03, $00, $03, $00
00011D4A =00000003                M sprs1	=	op1
00011D4A =00000000                M sprs2	=	op2
00011D4A =00000003                M sprs3	=	op3
00011D4A =00000000                M sprs4	=	op4
00011D4A                            	spAttackRt	$19, $1F, $1F, $1F
00011D4A =00000019                M spar1	=	op1
00011D4A =0000001F                M spar2	=	op2
00011D4A =0000001F                M spar3	=	op3
00011D4A =0000001F                M spar4	=	op4
00011D4A                            	spAmpMod	$00, $00, $00, $00
00011D4A =00000000                M spam1	=	op1
00011D4A =00000000                M spam2	=	op2
00011D4A =00000000                M spam3	=	op3
00011D4A =00000000                M spam4	=	op4
00011D4A                            	spSustainRt	$12, $14, $11, $0F
00011D4A =00000012                M spsr1	=	op1
00011D4A =00000014                M spsr2	=	op2
00011D4A =00000011                M spsr3	=	op3
00011D4A =0000000F                M spsr4	=	op4
00011D4A                            	spDecayRt	$0A, $0A, $00, $0D
00011D4A =0000000A                M spdr1	=	op1
00011D4A =0000000A                M spdr2	=	op2
00011D4A =00000000                M spdr3	=	op3
00011D4A =0000000D                M spdr4	=	op4
00011D4A                            	spSustainLv	$0F, $0F, $0F, $0F
00011D4A =0000000F                M spsl1	=	op1
00011D4A =0000000F                M spsl2	=	op2
00011D4A =0000000F                M spsl3	=	op3
00011D4A =0000000F                M spsl4	=	op4
00011D4A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011D4A =0000000F                M sprr1	=	op1
00011D4A =0000000F                M sprr2	=	op2
00011D4A =0000000F                M sprr3	=	op3
00011D4A =0000000F                M sprr4	=	op4
00011D4A                            	spSSGEG		$00, $00, $00, $00
00011D4A =00000000                M spss1	=	op1
00011D4A =00000000                M spss2	=	op2
00011D4A =00000000                M spss3	=	op3
00011D4A =00000000                M spss4	=	op4
00011D4A                            	spTotalLv	$22, $27, $07, $00
00011D4A =00000022                M sptl1	=	op1
00011D4A =00000027                M sptl2	=	op2
00011D4A =00000007                M sptl3	=	op3
00011D4A =00000000                M sptl4	=	op4
00011D4A 00                       M 	dc.b	(spfe<<3)+spal
00011D4B =00000080                M sptlmask4	set	$80
00011D4B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011D4B =00000000                M sptlmask3	set	((spal>=4)<<7)
00011D4B =00000000                M sptlmask1	set	((spal=7)<<7)
00011D4B 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D4F D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D53 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D57 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D5B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D5F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D63 2207 2780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D67 4E41 54                  M 	dc.b	'NAT'
00011D6A                            
00011D6A                            	; Patch $1C
00011D6A                            	; $34
00011D6A                            	; $09, $0F, $01, $D7,	$1F, $1F, $1F, $1F
00011D6A                            	; $0C, $11, $09, $0F,	$0A, $0E, $0D, $0E
00011D6A                            	; $35, $1A, $55, $3A,	$0C, $80, $0F, $80
00011D6A                            	spAlgorithm	$04
00011D6A =0000001D                M spatnum	=	spatnum+1
00011D6A =00000004                M spal	=	val
00011D6A                            	spFeedback	$06
00011D6A =00000006                M spfe	=	val
00011D6A                            	spDetune	$00, $00, $00, $0D
00011D6A =00000000                M spde1	=	op1
00011D6A =00000000                M spde2	=	op2
00011D6A =00000000                M spde3	=	op3
00011D6A =0000000D                M spde4	=	op4
00011D6A                            	spMultiple	$09, $01, $0F, $07
00011D6A =00000009                M spmu1	=	op1
00011D6A =00000001                M spmu2	=	op2
00011D6A =0000000F                M spmu3	=	op3
00011D6A =00000007                M spmu4	=	op4
00011D6A                            	spRateScale	$00, $00, $00, $00
00011D6A =00000000                M sprs1	=	op1
00011D6A =00000000                M sprs2	=	op2
00011D6A =00000000                M sprs3	=	op3
00011D6A =00000000                M sprs4	=	op4
00011D6A                            	spAttackRt	$1F, $1F, $1F, $1F
00011D6A =0000001F                M spar1	=	op1
00011D6A =0000001F                M spar2	=	op2
00011D6A =0000001F                M spar3	=	op3
00011D6A =0000001F                M spar4	=	op4
00011D6A                            	spAmpMod	$00, $00, $00, $00
00011D6A =00000000                M spam1	=	op1
00011D6A =00000000                M spam2	=	op2
00011D6A =00000000                M spam3	=	op3
00011D6A =00000000                M spam4	=	op4
00011D6A                            	spSustainRt	$0C, $09, $11, $0F
00011D6A =0000000C                M spsr1	=	op1
00011D6A =00000009                M spsr2	=	op2
00011D6A =00000011                M spsr3	=	op3
00011D6A =0000000F                M spsr4	=	op4
00011D6A                            	spDecayRt	$0A, $0D, $0E, $0E
00011D6A =0000000A                M spdr1	=	op1
00011D6A =0000000D                M spdr2	=	op2
00011D6A =0000000E                M spdr3	=	op3
00011D6A =0000000E                M spdr4	=	op4
00011D6A                            	spSustainLv	$03, $05, $01, $03
00011D6A =00000003                M spsl1	=	op1
00011D6A =00000005                M spsl2	=	op2
00011D6A =00000001                M spsl3	=	op3
00011D6A =00000003                M spsl4	=	op4
00011D6A                            	spReleaseRt	$05, $05, $0A, $0A
00011D6A =00000005                M sprr1	=	op1
00011D6A =00000005                M sprr2	=	op2
00011D6A =0000000A                M sprr3	=	op3
00011D6A =0000000A                M sprr4	=	op4
00011D6A                            	spSSGEG		$00, $00, $00, $00
00011D6A =00000000                M spss1	=	op1
00011D6A =00000000                M spss2	=	op2
00011D6A =00000000                M spss3	=	op3
00011D6A =00000000                M spss4	=	op4
00011D6A                            	spTotalLv	$0C, $0F, $00, $00
00011D6A =0000000C                M sptl1	=	op1
00011D6A =0000000F                M sptl2	=	op2
00011D6A =00000000                M sptl3	=	op3
00011D6A =00000000                M sptl4	=	op4
00011D6A 34                       M 	dc.b	(spfe<<3)+spal
00011D6B =00000080                M sptlmask4	set	$80
00011D6B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011D6B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011D6B =00000000                M sptlmask1	set	((spal=7)<<7)
00011D6B 090F 01D7                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D6F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D73 0C11 090F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D77 0A0E 0D0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D7B 351A 553A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D7F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D83 0C80 0F80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D87 4E41 54                  M 	dc.b	'NAT'
00011D8A                            
00011D8A                            	; Patch $1D
00011D8A                            	; $FA
00011D8A                            	; $21, $3A, $19, $30,	$1F, $1F, $1F, $1F
00011D8A                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011D8A                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $80
00011D8A                            	spAlgorithm	$02
00011D8A =0000001E                M spatnum	=	spatnum+1
00011D8A =00000002                M spal	=	val
00011D8A                            	spFeedback	$07
00011D8A =00000007                M spfe	=	val
00011D8A                            	spDetune	$02, $01, $03, $03
00011D8A =00000002                M spde1	=	op1
00011D8A =00000001                M spde2	=	op2
00011D8A =00000003                M spde3	=	op3
00011D8A =00000003                M spde4	=	op4
00011D8A                            	spMultiple	$01, $09, $0A, $00
00011D8A =00000001                M spmu1	=	op1
00011D8A =00000009                M spmu2	=	op2
00011D8A =0000000A                M spmu3	=	op3
00011D8A =00000000                M spmu4	=	op4
00011D8A                            	spRateScale	$00, $00, $00, $00
00011D8A =00000000                M sprs1	=	op1
00011D8A =00000000                M sprs2	=	op2
00011D8A =00000000                M sprs3	=	op3
00011D8A =00000000                M sprs4	=	op4
00011D8A                            	spAttackRt	$1F, $1F, $1F, $1F
00011D8A =0000001F                M spar1	=	op1
00011D8A =0000001F                M spar2	=	op2
00011D8A =0000001F                M spar3	=	op3
00011D8A =0000001F                M spar4	=	op4
00011D8A                            	spAmpMod	$00, $00, $00, $00
00011D8A =00000000                M spam1	=	op1
00011D8A =00000000                M spam2	=	op2
00011D8A =00000000                M spam3	=	op3
00011D8A =00000000                M spam4	=	op4
00011D8A                            	spSustainRt	$05, $09, $18, $02
00011D8A =00000005                M spsr1	=	op1
00011D8A =00000009                M spsr2	=	op2
00011D8A =00000018                M spsr3	=	op3
00011D8A =00000002                M spsr4	=	op4
00011D8A                            	spDecayRt	$0B, $10, $1F, $05
00011D8A =0000000B                M spdr1	=	op1
00011D8A =00000010                M spdr2	=	op2
00011D8A =0000001F                M spdr3	=	op3
00011D8A =00000005                M spdr4	=	op4
00011D8A                            	spSustainLv	$01, $04, $02, $02
00011D8A =00000001                M spsl1	=	op1
00011D8A =00000004                M spsl2	=	op2
00011D8A =00000002                M spsl3	=	op3
00011D8A =00000002                M spsl4	=	op4
00011D8A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011D8A =0000000F                M sprr1	=	op1
00011D8A =0000000F                M sprr2	=	op2
00011D8A =0000000F                M sprr3	=	op3
00011D8A =0000000F                M sprr4	=	op4
00011D8A                            	spSSGEG		$00, $00, $00, $00
00011D8A =00000000                M spss1	=	op1
00011D8A =00000000                M spss2	=	op2
00011D8A =00000000                M spss3	=	op3
00011D8A =00000000                M spss4	=	op4
00011D8A                            	spTotalLv	$0E, $04, $07, $00
00011D8A =0000000E                M sptl1	=	op1
00011D8A =00000004                M sptl2	=	op2
00011D8A =00000007                M sptl3	=	op3
00011D8A =00000000                M sptl4	=	op4
00011D8A 3A                       M 	dc.b	(spfe<<3)+spal
00011D8B =00000080                M sptlmask4	set	$80
00011D8B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011D8B =00000000                M sptlmask3	set	((spal>=4)<<7)
00011D8B =00000000                M sptlmask1	set	((spal=7)<<7)
00011D8B 213A 1930                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D8F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D93 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D97 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D9B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D9F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011DA3 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011DA7 4E41 54                  M 	dc.b	'NAT'
00011DAA                            
00011DAA                            	; Patch $1E
00011DAA                            	; $1C
00011DAA                            	; $2E, $02, $0F, $02,	$1F, $1F, $1F, $1F
00011DAA                            	; $18, $04, $14, $0E,	$00, $00, $00, $00
00011DAA                            	; $FF, $FF, $FF, $FF,	$20, $80, $1B, $80
00011DAA                            	spAlgorithm	$0C
00011DAA =0000001F                M spatnum	=	spatnum+1
00011DAA =0000000C                M spal	=	val
00011DAA                            	spFeedback	$01
00011DAA =00000001                M spfe	=	val
00011DAA                            	spDetune	$02, $00, $00, $00
00011DAA =00000002                M spde1	=	op1
00011DAA =00000000                M spde2	=	op2
00011DAA =00000000                M spde3	=	op3
00011DAA =00000000                M spde4	=	op4
00011DAA                            	spMultiple	$0E, $0F, $02, $02
00011DAA =0000000E                M spmu1	=	op1
00011DAA =0000000F                M spmu2	=	op2
00011DAA =00000002                M spmu3	=	op3
00011DAA =00000002                M spmu4	=	op4
00011DAA                            	spRateScale	$00, $00, $00, $00
00011DAA =00000000                M sprs1	=	op1
00011DAA =00000000                M sprs2	=	op2
00011DAA =00000000                M sprs3	=	op3
00011DAA =00000000                M sprs4	=	op4
00011DAA                            	spAttackRt	$1F, $1F, $1F, $1F
00011DAA =0000001F                M spar1	=	op1
00011DAA =0000001F                M spar2	=	op2
00011DAA =0000001F                M spar3	=	op3
00011DAA =0000001F                M spar4	=	op4
00011DAA                            	spAmpMod	$00, $00, $00, $00
00011DAA =00000000                M spam1	=	op1
00011DAA =00000000                M spam2	=	op2
00011DAA =00000000                M spam3	=	op3
00011DAA =00000000                M spam4	=	op4
00011DAA                            	spSustainRt	$18, $14, $04, $0E
00011DAA =00000018                M spsr1	=	op1
00011DAA =00000014                M spsr2	=	op2
00011DAA =00000004                M spsr3	=	op3
00011DAA =0000000E                M spsr4	=	op4
00011DAA                            	spDecayRt	$00, $00, $00, $00
00011DAA =00000000                M spdr1	=	op1
00011DAA =00000000                M spdr2	=	op2
00011DAA =00000000                M spdr3	=	op3
00011DAA =00000000                M spdr4	=	op4
00011DAA                            	spSustainLv	$0F, $0F, $0F, $0F
00011DAA =0000000F                M spsl1	=	op1
00011DAA =0000000F                M spsl2	=	op2
00011DAA =0000000F                M spsl3	=	op3
00011DAA =0000000F                M spsl4	=	op4
00011DAA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011DAA =0000000F                M sprr1	=	op1
00011DAA =0000000F                M sprr2	=	op2
00011DAA =0000000F                M sprr3	=	op3
00011DAA =0000000F                M sprr4	=	op4
00011DAA                            	spSSGEG		$00, $00, $00, $00
00011DAA =00000000                M spss1	=	op1
00011DAA =00000000                M spss2	=	op2
00011DAA =00000000                M spss3	=	op3
00011DAA =00000000                M spss4	=	op4
00011DAA                            	spTotalLv	$20, $1B, $00, $00
00011DAA =00000020                M sptl1	=	op1
00011DAA =0000001B                M sptl2	=	op2
00011DAA =00000000                M sptl3	=	op3
00011DAA =00000000                M sptl4	=	op4
00011DAA 14                       M 	dc.b	(spfe<<3)+spal
00011DAB =00000080                M sptlmask4	set	$80
00011DAB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011DAB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011DAB =00000000                M sptlmask1	set	((spal=7)<<7)
00011DAB 2E02 0F02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011DAF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011DB3 1804 140E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011DB7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011DBB FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011DBF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011DC3 2080 9B80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011DC7 4E41 54                  M 	dc.b	'NAT'
00011DCA                            
00011DCA                            	even
00011DCA                            
00011DCA                            ; -------------------------------------------------------------------------
00011DCA                            	opt ae-				; disable automatic evens
00011DCA                            
00011DCA                            sfxaddr	include	"Sound/sfxdata.asm"	; include all sfx
00011DCA                            
00011DCA                            
00011DCA                            ; ------------------------------------------------------------------------
00011DCA                            ; AMPS SFX data
00011DCA                            ; -------------------------------------------------------------------------
00011DCA                            
00011DCA                            Snd_Jump:
00011DCA                            		include	"Sound/sfx/Jump.asm"
00011DCA                            SndJump_Header:
00011DCA                            	sHeaderInit	
00011DCA =00011DCA                M spointzero	=	*
00011DCA =00000000                M spatnum	=	0
00011DCA                            	sHeaderPrio	$60
00011DCA 60                       M 	dc.b	$60
00011DCB                            	sHeaderCh	$01
00011DCB 00                       M 	dc.b	$01-1
00011DCC                            	sHeaderSFX	$80, $C0, SndJump_FM5, -1, $00
00011DCC 80C0                     M 	dc.b	$80,$c0
00011DCE 0000                     M 	dc.w	sndjump_fm5-spointzero
00011DD0 FF00                     M 	dc.b	-1,$00
00011DD2                            
00011DD2                            SndJump_FM5:
00011DD2 F3E7                       	dc.b	$F3,	$E7
00011DD4                            	ssMod68k	$00, $01, -5, $10
00011DD4 F000 01FB 10             M 	dc.b	$f0,$00,$01,-5,$10
00011DD9 A510                       	dc.b nC3, $10
00011DDB                            	sModOff
00011DDB EC                       M 	dc.b	$ec
00011DDC                            	
00011DDC                            Jumploop:
00011DDC E702                       	dc.b	$E7,	$02
00011DDE                            	saVol	$01
00011DDE ED01                     M 	dc.b	$ed,$01
00011DE0                            	sLoop		$00, $0B, Jumploop
00011DE0 F700                     M 	dc.b	$f7,$00
00011DE2 FFF9                     M 	dc.w	jumploop-*-1
00011DE4 0B                       M 	dc.b	$0b
00011DE5                            	
00011DE5                            	sStop	
00011DE5 F5                       M 	dc.b	$f5
00011DE6                            		even
00011DE6                            Snd_Skid:
00011DE6                            		include	"Sound/sfx/Skid.asm"
00011DE6                            Skid_Header:
00011DE6                            	sHeaderInit	
00011DE6 =00011DE6                M spointzero	=	*
00011DE6 =00000000                M spatnum	=	0
00011DE6                            	sHeaderPrio	$60
00011DE6 60                       M 	dc.b	$60
00011DE7                            	sHeaderCh	$01
00011DE7 00                       M 	dc.b	$01-1
00011DE8                            	sHeaderSFX	$80, $C0, Skid_FM5, $00, $00
00011DE8 80C0                     M 	dc.b	$80,$c0
00011DEA 0000                     M 	dc.w	skid_fm5-spointzero
00011DEC 0000                     M 	dc.b	$00,$00
00011DEE                            
00011DEE                            Skid_FM5:
00011DEE F3E7                       	dc.b	$F3,	$E7
00011DF0 8001                       	dc.b nRst, $01
00011DF2                            	
00011DF2                            Skid_Loop1:
00011DF2 AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011DF6                            	sLoop		$00, $03, Skid_Loop1
00011DF6 F700                     M 	dc.b	$f7,$00
00011DF8 FFF9                     M 	dc.w	skid_loop1-*-1
00011DFA 03                       M 	dc.b	$03
00011DFB                            
00011DFB                            Skid_Loop2:
00011DFB AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011DFF                            	saVol	$01
00011DFF ED01                     M 	dc.b	$ed,$01
00011E01                            	sLoop		$00, $09, Skid_Loop2
00011E01 F700                     M 	dc.b	$f7,$00
00011E03 FFF7                     M 	dc.w	skid_loop2-*-1
00011E05 09                       M 	dc.b	$09
00011E06                            	sStop	
00011E06 F5                       M 	dc.b	$f5
00011E08 00                         		even
00011E08                            Snd_Death:
00011E08                            		include	"Sound/sfx/Death.asm"
00011E08                            Death_Header:
00011E08                            	sHeaderInit	
00011E08 =00011E08                M spointzero	=	*
00011E08 =00000000                M spatnum	=	0
00011E08                            	sHeaderPrio	$60
00011E08 60                       M 	dc.b	$60
00011E09                            	sHeaderCh	$01
00011E09 00                       M 	dc.b	$01-1
00011E0A                            	sHeaderSFX	$80, $05, Death_FM5, $F4, $00
00011E0A 8005                     M 	dc.b	$80,$05
00011E0C 0000                     M 	dc.w	death_fm5-spointzero
00011E0E F400                     M 	dc.b	$f4,$00
00011E10                            
00011E10                            Death_FM5:
00011E10                            	sVoice		$02
00011E10 E802                     M 	dc.b	$e8,$02
00011E12 B007 E7AD                  	dc.b nB3, $07, sHold, nAb3
00011E16                            
00011E16                            Death_Loop1:
00011E16 01                         	dc.b $01
00011E17                            	saVol		$01
00011E17 ED01                     M 	dc.b	$ed,$01
00011E19                            	sLoop		$00, $2F, Death_Loop1
00011E19 F700                     M 	dc.b	$f7,$00
00011E1B FFFA                     M 	dc.w	death_loop1-*-1
00011E1D 2F                       M 	dc.b	$2f
00011E1E                            	sStop	
00011E1E F5                       M 	dc.b	$f5
00011E20 00                         		even
00011E20                            Snd_Push:
00011E20                            		include	"Sound/sfx/Push.asm"
00011E20                            Push_Header:
00011E20                            	sHeaderInit	
00011E20 =00011E20                M spointzero	=	*
00011E20 =00000000                M spatnum	=	0
00011E20                            	sHeaderPrio	$60
00011E20 60                       M 	dc.b	$60
00011E21                            	sHeaderCh	$01
00011E21 00                       M 	dc.b	$01-1
00011E22                            	sHeaderSFX	$80, $05, Push_FM5, $00, $06
00011E22 8005                     M 	dc.b	$80,$05
00011E24 0000                     M 	dc.w	push_fm5-spointzero
00011E26 0006                     M 	dc.b	$00,$06
00011E28                            
00011E28                            Push_FM5:
00011E28                            	sVoice		$13
00011E28 E813                     M 	dc.b	$e8,$13
00011E2A 8F07 8002 8F06 8010        	dc.b nD1, $07, nRst, $02, nD1, $06, nRst, $10
00011E32                            	sStop	
00011E32 F5                       M 	dc.b	$f5
00011E34 00                         		even
00011E34                            Snd_Bubble:
00011E34                            Snd_Drown:
00011E34                            Snd_DrownWarning:
00011E34                            Snd_DrownCountdown:
00011E34                            Snd_Checkpoint:
00011E34                            		include	"Sound/sfx/Checkpoint.asm"
00011E34                            Attack_Header:
00011E34                            	sHeaderInit	
00011E34 =00011E34                M spointzero	=	*
00011E34 =00000000                M spatnum	=	0
00011E34                            	sHeaderPrio	$60
00011E34 60                       M 	dc.b	$60
00011E35                            	sHeaderCh	$02
00011E35 01                       M 	dc.b	$02-1
00011E36                            	sHeaderSFX	$80, $80, Attack_FM5, $00, $00
00011E36 8080                     M 	dc.b	$80,$80
00011E38 0000                     M 	dc.w	attack_fm5-spointzero
00011E3A 0000                     M 	dc.b	$00,$00
00011E3C                            	sHeaderSFX	$80, $A0, Attack_FM5B, $00, $04
00011E3C 80A0                     M 	dc.b	$80,$a0
00011E3E 0000                     M 	dc.w	attack_fm5b-spointzero
00011E40 0004                     M 	dc.b	$00,$04
00011E42                            
00011E42                            Attack_FM5B:
00011E42 8002                       	dc.b	nRst,	$02
00011E44                            
00011E44                            Attack_FM5:
00011E44                            
00011E44                            Attack_Loop1:
00011E44 B103 8001                  	dc.b nC4, $03, nRst, $01
00011E48                            	sLoop		$00, $01, Attack_Loop1
00011E48 F700                     M 	dc.b	$f7,$00
00011E4A FFF9                     M 	dc.w	attack_loop1-*-1
00011E4C 01                       M 	dc.b	$01
00011E4D                            
00011E4D                            Attack_Loop2:
00011E4D B103 8001                  	dc.b nC4, $03, nRst, $01
00011E51                            	saVol	$01
00011E51 ED01                     M 	dc.b	$ed,$01
00011E53 B003 8001                  	dc.b nB3, $03, nRst, $01
00011E57                            	saVol	$01
00011E57 ED01                     M 	dc.b	$ed,$01
00011E59 AF03 8001                  	dc.b nBb3, $03, nRst, $01
00011E5D                            	saVol	$01
00011E5D ED01                     M 	dc.b	$ed,$01
00011E5F AE03 8001                  	dc.b nBb3-1, $03, nRst, $01
00011E63                            	saVol	$01
00011E63 ED01                     M 	dc.b	$ed,$01
00011E65                            	sLoop		$00, $03, Attack_Loop2
00011E65 F700                     M 	dc.b	$f7,$00
00011E67 FFE5                     M 	dc.w	attack_loop2-*-1
00011E69 03                       M 	dc.b	$03
00011E6A                            	sStop	
00011E6A F5                       M 	dc.b	$f5
00011E6C 00                         		even
00011E6C                            Snd_SpikeMove:
00011E6C                            Snd_Ring:
00011E6C                            		include	"Sound/sfx/Ring.asm"
00011E6C                            Ring_Header:
00011E6C                            	sHeaderInit	
00011E6C =00011E6C                M spointzero	=	*
00011E6C =00000000                M spatnum	=	0
00011E6C                            	sHeaderPrio	$60
00011E6C 60                       M 	dc.b	$60
00011E6D                            	sHeaderCh	$01
00011E6D 00                       M 	dc.b	$01-1
00011E6E                            	sHeaderSFX	$80, $05, Ring_FM5, $00, $0A
00011E6E 8005                     M 	dc.b	$80,$05
00011E70 0000                     M 	dc.w	ring_fm5-spointzero
00011E72 000A                     M 	dc.b	$00,$0a
00011E74                            
00011E74                            Ring_FM5:
00011E74                            	sVoice		$03
00011E74 E803                     M 	dc.b	$e8,$03
00011E76 C105 C405 C91B             	dc.b nE5, $05, nG5, $05, nC6, $1B
00011E7C                            	sStop	
00011E7C F5                       M 	dc.b	$f5
00011E7E 00                         		even
00011E7E                            Snd_RingLoss:
00011E7E                            		include	"Sound/sfx/Ring Loss.asm"
00011E7E                            RingLoss_Header:
00011E7E                            	sHeaderInit	
00011E7E =00011E7E                M spointzero	=	*
00011E7E =00000000                M spatnum	=	0
00011E7E                            	sHeaderPrio	$60
00011E7E 60                       M 	dc.b	$60
00011E7F                            	sHeaderCh	$02
00011E7F 01                       M 	dc.b	$02-1
00011E80                            	sHeaderSFX	$80, $04, RingLoss_FM4, $00, $05
00011E80 8004                     M 	dc.b	$80,$04
00011E82 0000                     M 	dc.w	ringloss_fm4-spointzero
00011E84 0005                     M 	dc.b	$00,$05
00011E86                            	sHeaderSFX	$80, $05, RingLoss_FM5, $00, $08
00011E86 8005                     M 	dc.b	$80,$05
00011E88 0000                     M 	dc.w	ringloss_fm5-spointzero
00011E8A 0008                     M 	dc.b	$00,$08
00011E8C                            
00011E8C                            RingLoss_FM4:
00011E8C                            	sVoice		$03
00011E8C E803                     M 	dc.b	$e8,$03
00011E8E C602 0505 0505 0505 3A     	dc.b nA5, $02, $05, $05, $05, $05, $05, $05, $3A
00011E97                            	sStop	
00011E97 F5                       M 	dc.b	$f5
00011E98                            
00011E98                            RingLoss_FM5:
00011E98                            	sVoice		$03
00011E98 E803                     M 	dc.b	$e8,$03
00011E9A 8002 C402 0515 0205 32     	dc.b nRst, $02, nG5, $02, $05, $15, $02, $05, $32
00011EA3                            	sStop	
00011EA3 F5                       M 	dc.b	$f5
00011EA4                            		even
00011EA4                            Snd_Spring:
00011EA4                            		include	"Sound/sfx/Spring.asm"
00011EA4                            Spring_Header:
00011EA4                            	sHeaderInit	
00011EA4 =00011EA4                M spointzero	=	*
00011EA4 =00000000                M spatnum	=	0
00011EA4                            	sHeaderPrio	$60
00011EA4 60                       M 	dc.b	$60
00011EA5                            	sHeaderCh	$01
00011EA5 00                       M 	dc.b	$01-1
00011EA6                            	sHeaderSFX	$80, $04, Spring_FM4, $00, $02
00011EA6 8004                     M 	dc.b	$80,$04
00011EA8 0000                     M 	dc.w	spring_fm4-spointzero
00011EAA 0002                     M 	dc.b	$00,$02
00011EAC                            
00011EAC                            Spring_FM4:
00011EAC                            	sVoice		$06
00011EAC E806                     M 	dc.b	$e8,$06
00011EAE 8001                       	dc.b nRst, $01
00011EB0                            	ssMod68k	$03, $01, $5D, $0F
00011EB0 F003 015D 0F             M 	dc.b	$f0,$03,$01,$5d,$0f
00011EB5 B00C                       	dc.b nB3, $0C
00011EB7                            	sModOff	
00011EB7 EC                       M 	dc.b	$ec
00011EB8                            
00011EB8                            Spring_Loop1:
00011EB8 E7                         	dc.b sHold
00011EB9                            	saVol		$02
00011EB9 ED02                     M 	dc.b	$ed,$02
00011EBB BD02                       	dc.b nC5, $02
00011EBD                            	sLoop		$00, $19, Spring_Loop1
00011EBD F700                     M 	dc.b	$f7,$00
00011EBF FFF8                     M 	dc.w	spring_loop1-*-1
00011EC1 19                       M 	dc.b	$19
00011EC2                            	sStop	
00011EC2 F5                       M 	dc.b	$f5
00011EC4 00                         		even
00011EC4                            Snd_Shield:
00011EC4                            Snd_Splash:
00011EC4                            Snd_Bumper:
00011EC4                            		include	"Sound/sfx/Bumper.asm"
00011EC4                            BumperHeader:
00011EC4                            	sHeaderInit	
00011EC4 =00011EC4                M spointzero	=	*
00011EC4 =00000000                M spatnum	=	0
00011EC4                            	sHeaderPrio	$60
00011EC4 60                       M 	dc.b	$60
00011EC5                            	sHeaderCh	$03
00011EC5 02                       M 	dc.b	$03-1
00011EC6                            	sHeaderSFX	$80, $05, BumperFM5, $00, $00
00011EC6 8005                     M 	dc.b	$80,$05
00011EC8 0000                     M 	dc.w	bumperfm5-spointzero
00011ECA 0000                     M 	dc.b	$00,$00
00011ECC                            	sHeaderSFX	$80, $04, BumperFM4, $00, $00
00011ECC 8004                     M 	dc.b	$80,$04
00011ECE 0000                     M 	dc.w	bumperfm4-spointzero
00011ED0 0000                     M 	dc.b	$00,$00
00011ED2                            	sHeaderSFX	$80, $02, BumperFM3, $00, $02
00011ED2 8002                     M 	dc.b	$80,$02
00011ED4 0000                     M 	dc.w	bumperfm3-spointzero
00011ED6 0002                     M 	dc.b	$00,$02
00011ED8                            
00011ED8                            BumperFM5:
00011ED8                            	sVoice		$0D
00011ED8 E80D                     M 	dc.b	$e8,$0d
00011EDA                            	ssJump		BumperJump1
00011EDA F6                       M 	dc.b	$f6
00011EDB 0000                     M 	dc.w	bumperjump1-*-1
00011EDD                            
00011EDD                            BumperFM4:
00011EDD                            	sVoice		$0D
00011EDD E80D                     M 	dc.b	$e8,$0d
00011EDF                            	saDetune	$07
00011EDF E207                     M 	dc.b	$e2,$07
00011EE1 8001                       	dc.b nRst, $01
00011EE3                            
00011EE3                            BumperJump1:
00011EE3 BA20                       	dc.b nA4, $20
00011EE5                            	sStop	
00011EE5 F5                       M 	dc.b	$f5
00011EE6                            
00011EE6                            BumperFM3:
00011EE6                            	sVoice		$0E
00011EE6 E80E                     M 	dc.b	$e8,$0e
00011EE8 9A03                       	dc.b nCs2, $03
00011EEA                            	sStop	
00011EEA F5                       M 	dc.b	$f5
00011EEC 00                         		even
00011EEC                            Snd_Switch:
00011EEC                            Snd_Signpost:
00011EEC                            Snd_Collapse:
00011EEC                            Snd_WallSmash:
00011EEC                            Snd_Rumble:
00011EEC                            Snd_Warp:
00011EEC                            Snd_BossHit:
00011EEC                            		include	"Sound/sfx/Boss Hit.asm"
00011EEC                            BossHit_Header:
00011EEC                            	sHeaderInit	
00011EEC =00011EEC                M spointzero	=	*
00011EEC =00000000                M spatnum	=	0
00011EEC                            	sHeaderPrio	$60
00011EEC 60                       M 	dc.b	$60
00011EED                            	sHeaderCh	$01
00011EED 00                       M 	dc.b	$01-1
00011EEE                            	sHeaderSFX	$80, $05, BossHit_FM4, $00, $00
00011EEE 8005                     M 	dc.b	$80,$05
00011EF0 0000                     M 	dc.w	bosshit_fm4-spointzero
00011EF2 0000                     M 	dc.b	$00,$00
00011EF4                            
00011EF4                            BossHit_FM4:
00011EF4                            	sVoice		$0F
00011EF4 E80F                     M 	dc.b	$e8,$0f
00011EF6                            	ssMod68k	$01, $01, $0C, $01
00011EF6 F001 010C 01             M 	dc.b	$f0,$01,$01,$0c,$01
00011EFB                            
00011EFB                            BossHit_Loop1:
00011EFB 810A                       	dc.b nC0, $0A
00011EFD                            	saVol		$10
00011EFD ED10                     M 	dc.b	$ed,$10
00011EFF                            	sLoop		$00, $04, BossHit_Loop1
00011EFF F700                     M 	dc.b	$f7,$00
00011F01 FFF9                     M 	dc.w	bosshit_loop1-*-1
00011F03 04                       M 	dc.b	$04
00011F04                            	sStop	
00011F04 F5                       M 	dc.b	$f5
00011F06 00                         		even
00011F06                            Snd_Bomb:
00011F06                            		include	"Sound/sfx/Bomb.asm"
00011F06                            Bomb_Header:
00011F06                            	sHeaderInit	
00011F06 =00011F06                M spointzero	=	*
00011F06 =00000000                M spatnum	=	0
00011F06                            	sHeaderPrio	$60
00011F06 60                       M 	dc.b	$60
00011F07                            	sHeaderCh	$01
00011F07 00                       M 	dc.b	$01-1
00011F08                            	sHeaderSFX	$80, $05, Bomb_FM5, $00, $00
00011F08 8005                     M 	dc.b	$80,$05
00011F0A 0000                     M 	dc.w	bomb_fm5-spointzero
00011F0C 0000                     M 	dc.b	$00,$00
00011F0E                            
00011F0E                            Bomb_FM5:
00011F0E                            	sVoice		$09
00011F0E E809                     M 	dc.b	$e8,$09
00011F10 8A22                       	dc.b nA0, $22
00011F12                            	sStop	
00011F12 F5                       M 	dc.b	$f5
00011F14 00                         		even
00011F14                            Snd_BreakItem:
00011F14                            		include	"Sound/sfx/Break Item.asm"
00011F14                            BreakItem_Header:
00011F14                            	sHeaderInit	
00011F14 =00011F14                M spointzero	=	*
00011F14 =00000000                M spatnum	=	0
00011F14                            	sHeaderPrio	$60
00011F14 60                       M 	dc.b	$60
00011F15                            	sHeaderCh	$01
00011F15 00                       M 	dc.b	$01-1
00011F16                            	sHeaderSFX	$80, $05, BreakItem_FM5, $00, $00
00011F16 8005                     M 	dc.b	$80,$05
00011F18 0000                     M 	dc.w	breakitem_fm5-spointzero
00011F1A 0000                     M 	dc.b	$00,$00
00011F1C                            
00011F1C                            BreakItem_FM5:
00011F1C                            	ssMod68k	$03, $01, $72, $0B
00011F1C F003 0172 0B             M 	dc.b	$f0,$03,$01,$72,$0b
00011F21                            	sVoice		$04
00011F21 E804                     M 	dc.b	$e8,$04
00011F23 BA16                       	dc.b nA4, $16
00011F25                            	sStop	
00011F25 F5                       M 	dc.b	$f5
00011F26                            		even
00011F26                            Snd_FloorBounce:
00011F26                            		include	"Sound/sfx/Floor Bounce.asm"
00011F26                            FloorBounce_Header:
00011F26                            	sHeaderInit	
00011F26 =00011F26                M spointzero	=	*
00011F26 =00000000                M spatnum	=	0
00011F26                            	sHeaderPrio	$60
00011F26 60                       M 	dc.b	$60
00011F27                            	sHeaderCh	$01
00011F27 00                       M 	dc.b	$01-1
00011F28                            	sHeaderSFX	$80, $05, FloorBounce_FM5, $00, $00
00011F28 8005                     M 	dc.b	$80,$05
00011F2A 0000                     M 	dc.w	floorbounce_fm5-spointzero
00011F2C 0000                     M 	dc.b	$00,$00
00011F2E                            
00011F2E                            FloorBounce_FM5:
00011F2E                            	sVoice		$18
00011F2E E818                     M 	dc.b	$e8,$18
00011F30 A00F                       	dc.b nG2, $0F
00011F32                            	saVol		$0F
00011F32 ED0F                     M 	dc.b	$ed,$0f
00011F34                            	sLoop		$00, $04, FloorBounce_FM5
00011F34 F700                     M 	dc.b	$f7,$00
00011F36 FFF7                     M 	dc.w	floorbounce_fm5-*-1
00011F38 04                       M 	dc.b	$04
00011F39                            	sStop	
00011F39 F5                       M 	dc.b	$f5
00011F3A                            		even
00011F3A                            Snd_Charge:
00011F3A                            		include	"Sound/sfx/Charge.asm"
00011F3A                            PeeloutCharge_Header:
00011F3A                            	sHeaderInit
00011F3A =00011F3A                M spointzero	=	*
00011F3A =00000000                M spatnum	=	0
00011F3A                            	sHeaderPrio	$60
00011F3A 60                       M 	dc.b	$60
00011F3B                            	sHeaderCh	$01
00011F3B 00                       M 	dc.b	$01-1
00011F3C                            
00011F3C                            	sHeaderSFX	$80, $05, PeeloutCharge_FM5, $00, $05
00011F3C 8005                     M 	dc.b	$80,$05
00011F3E 0000                     M 	dc.w	peeloutcharge_fm5-spointzero
00011F40 0005                     M 	dc.b	$00,$05
00011F42                            
00011F42                            ; FM5 Data
00011F42                            PeeloutCharge_FM5:
00011F42                            	sVoice	$0A
00011F42 E80A                     M 	dc.b	$e8,$0a
00011F44 8001                       	dc.b	nRst, $01
00011F46                            	ssMod68k	$01, $01, $09, $FF
00011F46 F001 0109 FF             M 	dc.b	$f0,$01,$01,$09,$ff
00011F4B CA22                       	dc.b	nCs6, $22
00011F4D                            	sModOn
00011F4D EB                       M 	dc.b	$eb
00011F4E                            	saVol	$02
00011F4E ED02                     M 	dc.b	$ed,$02
00011F50                            	sModOff
00011F50 EC                       M 	dc.b	$ec
00011F51                            
00011F51                            PeeloutCharge_Jump00:
00011F51 E7D1 02                    	dc.b	sHold, nAb6, $02
00011F54                            	ssJump	PeeloutCharge_Jump00
00011F54 F6                       M 	dc.b	$f6
00011F55 FFFB                     M 	dc.w	peeloutcharge_jump00-*-1
00011F58 00                         		even
00011F58                            Snd_ChargeStop:
00011F58                            		include	"Sound/sfx/Charge Stop.asm"
00011F58                            PeeloutStop_Header:
00011F58                            	sHeaderInit
00011F58 =00011F58                M spointzero	=	*
00011F58 =00000000                M spatnum	=	0
00011F58                            	sHeaderPrio	$60
00011F58 60                       M 	dc.b	$60
00011F59                            	sHeaderCh   $01
00011F59 00                       M 	dc.b	$01-1
00011F5A                            
00011F5A                            	sHeaderSFX $80, $05, PeeloutStop_FM5,	$00, $00
00011F5A 8005                     M 	dc.b	$80,$05
00011F5C 0000                     M 	dc.w	peeloutstop_fm5-spointzero
00011F5E 0000                     M 	dc.b	$00,$00
00011F60                            
00011F60                            ; FM5 Data
00011F60                            PeeloutStop_FM5:
00011F60                            	sStop
00011F60 F5                       M 	dc.b	$f5
00011F62 00                         		even
00011F62                            Snd_ChargeRelease:
00011F62                            		include	"Sound/sfx/Charge Release.asm"
00011F62                            Peelout_Release_Header:
00011F62                            	sHeaderInit
00011F62 =00011F62                M spointzero	=	*
00011F62 =00000000                M spatnum	=	0
00011F62                            	sHeaderPrio	$60
00011F62 60                       M 	dc.b	$60
00011F63                            	sHeaderCh	$02
00011F63 01                       M 	dc.b	$02-1
00011F64                            
00011F64                            	sHeaderSFX	$80, $04, Peelout_Release_FM4, $00, $00
00011F64 8004                     M 	dc.b	$80,$04
00011F66 0000                     M 	dc.w	peelout_release_fm4-spointzero
00011F68 0000                     M 	dc.b	$00,$00
00011F6A                            	sHeaderSFX	$80, $05, Peelout_Release_FM5, $00, $08
00011F6A 8005                     M 	dc.b	$80,$05
00011F6C 0000                     M 	dc.w	peelout_release_fm5-spointzero
00011F6E 0008                     M 	dc.b	$00,$08
00011F70                            
00011F70                            ; FM4 Data
00011F70                            Peelout_Release_FM4:
00011F70                            	sVoice		$0C
00011F70 E80C                     M 	dc.b	$e8,$0c
00011F72                            	ssMod68k	$01, $01, $C5, $1A
00011F72 F001 01C5 1A             M 	dc.b	$f0,$01,$01,$c5,$1a
00011F77 CD07                       	dc.b		nE6, $07
00011F79                            	saVol		$09
00011F79 ED09                     M 	dc.b	$ed,$09
00011F7B                            	sPan		spCenter, $00
00011F7B E0C0                     M 	dc.b	$e0,spcenter|$00
00011F7D                            	sVoice		$0A
00011F7D E80A                     M 	dc.b	$e8,$0a
00011F7F                            	ssMod68k	$03, $01, $09, $FF
00011F7F F003 0109 FF             M 	dc.b	$f0,$03,$01,$09,$ff
00011F84 D625                       	dc.b		nCs7, $25
00011F86                            	sModOff
00011F86 EC                       M 	dc.b	$ec
00011F87                            
00011F87                            Peelout_Release_Loop00:
00011F87 E7                         	dc.b		sHold
00011F88                            	saVol		$01
00011F88 ED01                     M 	dc.b	$ed,$01
00011F8A DC02                       	dc.b		nG7, $02
00011F8C                            	sLoop		$00, $2A, Peelout_Release_Loop00
00011F8C F700                     M 	dc.b	$f7,$00
00011F8E FFF8                     M 	dc.w	peelout_release_loop00-*-1
00011F90 2A                       M 	dc.b	$2a
00011F91                            	sStop
00011F91 F5                       M 	dc.b	$f5
00011F92                            
00011F92                            ; FM5 Data
00011F92                            Peelout_Release_FM5:
00011F92                            	sVoice		$0B
00011F92 E80B                     M 	dc.b	$e8,$0b
00011F94                            	ssMod68k	$01, $01, $20, $08
00011F94 F001 0120 08             M 	dc.b	$f0,$01,$01,$20,$08
00011F99 800A                       	dc.b		nRst, $0A
00011F9B                            
00011F9B                            Peelout_Release_Loop01:
00011F9B 880F                       	dc.b		nG0, $0F
00011F9D                            	sLoop		$00, $03, Peelout_Release_Loop01
00011F9D F700                     M 	dc.b	$f7,$00
00011F9F FFFB                     M 	dc.w	peelout_release_loop01-*-1
00011FA1 03                       M 	dc.b	$03
00011FA2                            
00011FA2                            Peelout_Release_Loop02:
00011FA2 880A                       	dc.b		nG0, $0A
00011FA4                            	saVol		$05
00011FA4 ED05                     M 	dc.b	$ed,$05
00011FA6                            	sLoop		$00, $06, Peelout_Release_Loop02
00011FA6 F700                     M 	dc.b	$f7,$00
00011FA8 FFF9                     M 	dc.w	peelout_release_loop02-*-1
00011FAA 06                       M 	dc.b	$06
00011FAB                            	sStop
00011FAB F5                       M 	dc.b	$f5
00011FAC                            		even
00011FAC                            Snd_DiamondBreak:
00011FAC                            		include	"Sound/sfx/Diamond Break.asm"
00011FAC                            DiamondBreak_Header:
00011FAC                            	sHeaderInit	
00011FAC =00011FAC                M spointzero	=	*
00011FAC =00000000                M spatnum	=	0
00011FAC                            	sHeaderPrio	$60
00011FAC 60                       M 	dc.b	$60
00011FAD                            	sHeaderCh	$01
00011FAD 00                       M 	dc.b	$01-1
00011FAE                            	sHeaderSFX	$80, $05, DiamondBreak_FM5, $00, $07
00011FAE 8005                     M 	dc.b	$80,$05
00011FB0 0000                     M 	dc.w	diamondbreak_fm5-spointzero
00011FB2 0007                     M 	dc.b	$00,$07
00011FB4                            
00011FB4                            DiamondBreak_FM5:
00011FB4                            	sVoice		$1E
00011FB4 E81E                     M 	dc.b	$e8,$1e
00011FB6 AE08                       	dc.b nA3, $08
00011FB8                            	sStop	
00011FB8 F5                       M 	dc.b	$f5
00011FBA 00                         		even
00011FBA                            
00011FBA                            ; -------------------------------------------------------------------------
00011FBA                            musaddr	include	"Sound/musicdata.asm"	; include all music
00011FBA                            
00011FBA                            
00011FBA                            ; ------------------------------------------------------------------------
00011FBA                            ; AMPS music data
00011FBA                            ; -------------------------------------------------------------------------
00011FBA                            
00011FBA                            Mus_WWZ:
00011FBA                            		include	"Sound/music/Wacky Workbench.asm"
00011FBA                            ; Level music was replaced with a silent music track, since I did not create the music, 
00011FBA                            ; nor do I currently have permission to share it.
00011FBA                            
00011FBA                            Mus_WWZ_Header:
00011FBA                            	sHeaderInit
00011FBA =00011FBA                M spointzero	=	*
00011FBA =00000000                M spatnum	=	0
00011FBA                            	sHeaderTempo	$02, $33
00011FBA 0133                     M 	dc.b	$02-1,$33
00011FBC                            	sHeaderCh	$05, $03
00011FBC 04                       M 	dc.b	$05-1
00011FBD 02                       M 	dc.b	$03-1
00011FBE                            	sHeaderDAC	Mus_WWZ_DAC2
00011FBE 0000                     M 	dc.w	mus_wwz_dac2-spointzero
00011FC0 0000                     M 	dc.w	$00
00011FC2                            	sHeaderDAC	Mus_WWZ_DAC
00011FC2 0000                     M 	dc.w	mus_wwz_dac-spointzero
00011FC4 0000                     M 	dc.w	$00
00011FC6                            	sHeaderFM	Mus_WWZ_FM1, $00, $0A
00011FC6 0000                     M 	dc.w	mus_wwz_fm1-spointzero
00011FC8 000A                     M 	dc.b	$00,$0a
00011FCA                            	sHeaderFM	Mus_WWZ_FM2, $00, $11
00011FCA 0000                     M 	dc.w	mus_wwz_fm2-spointzero
00011FCC 0011                     M 	dc.b	$00,$11
00011FCE                            	sHeaderFM	Mus_WWZ_FM3, $00, $10
00011FCE 0000                     M 	dc.w	mus_wwz_fm3-spointzero
00011FD0 0010                     M 	dc.b	$00,$10
00011FD2                            	sHeaderFM	Mus_WWZ_FM4, $00, $10
00011FD2 0000                     M 	dc.w	mus_wwz_fm4-spointzero
00011FD4 0010                     M 	dc.b	$00,$10
00011FD6                            	sHeaderFM	Mus_WWZ_FM5, $00, $0C
00011FD6 0000                     M 	dc.w	mus_wwz_fm5-spointzero
00011FD8 000C                     M 	dc.b	$00,$0c
00011FDA                            	sHeaderPSG	Mus_WWZ_PSG1, $00, $20>>3, $00, v00
00011FDA 0000                     M 	dc.w	mus_wwz_psg1-spointzero
00011FDC 0004 0000                M 	dc.b	$00,$20>>3,$00,v00
00011FE0                            	sHeaderPSG	Mus_WWZ_PSG2, $00, $40>>3, $00, v00
00011FE0 0000                     M 	dc.w	mus_wwz_psg2-spointzero
00011FE2 0008 0000                M 	dc.b	$00,$40>>3,$00,v00
00011FE6                            	sHeaderPSG	Mus_WWZ_PSG3, $00, $18>>3, $00, v00
00011FE6 0000                     M 	dc.w	mus_wwz_psg3-spointzero
00011FE8 0003 0000                M 	dc.b	$00,$18>>3,$00,v00
00011FEC                            
00011FEC                            Mus_WWZ_DAC:
00011FEC                            Mus_WWZ_DAC2:
00011FEC                            Mus_WWZ_FM1:
00011FEC                            Mus_WWZ_FM2:
00011FEC                            Mus_WWZ_FM3:
00011FEC                            Mus_WWZ_FM4:
00011FEC                            Mus_WWZ_FM5:
00011FEC                            Mus_WWZ_PSG1:
00011FEC                            Mus_WWZ_PSG2:
00011FEC                            Mus_WWZ_PSG3:
00011FEC                            	sStop
00011FEC F5                       M 	dc.b	$f5
00011FEE 00                         		even
00011FEE                            Mus_Boss:
00011FEE                            		include	"Sound/music/Boss.asm"
00011FEE                            Boss_Header:
00011FEE                            	sHeaderInit
00011FEE =00011FEE                M spointzero	=	*
00011FEE =00000000                M spatnum	=	0
00011FEE                            	sHeaderTempo	$01, $1D
00011FEE 001D                     M 	dc.b	$01-1,$1d
00011FF0                            	sHeaderCh	$05, $03
00011FF0 04                       M 	dc.b	$05-1
00011FF1 02                       M 	dc.b	$03-1
00011FF2                            
00011FF2                            	sHeaderDAC	Boss_DAC2
00011FF2 0000                     M 	dc.w	boss_dac2-spointzero
00011FF4 0000                     M 	dc.w	$00
00011FF6                            	sHeaderDAC	Boss_DAC
00011FF6 0000                     M 	dc.w	boss_dac-spointzero
00011FF8 0000                     M 	dc.w	$00
00011FFA                            	sHeaderFM	Boss_FM1,	$0C, $0A
00011FFA 0000                     M 	dc.w	boss_fm1-spointzero
00011FFC 0C0A                     M 	dc.b	$0c,$0a
00011FFE                            	sHeaderFM	Boss_FM2,	$0C, $06
00011FFE 0000                     M 	dc.w	boss_fm2-spointzero
00012000 0C06                     M 	dc.b	$0c,$06
00012002                            	sHeaderFM	Boss_FM3,	$0C, $08
00012002 0000                     M 	dc.w	boss_fm3-spointzero
00012004 0C08                     M 	dc.b	$0c,$08
00012006                            	sHeaderFM	Boss_FM4,	$00, $0F
00012006 0000                     M 	dc.w	boss_fm4-spointzero
00012008 000F                     M 	dc.b	$00,$0f
0001200A                            	sHeaderFM	Boss_FM5,	$00, $0F
0001200A 0000                     M 	dc.w	boss_fm5-spointzero
0001200C 000F                     M 	dc.b	$00,$0f
0001200E                            	sHeaderPSG	Boss_PSG1,	$E8-$0C, $04, $00, v0C
0001200E 0000                     M 	dc.w	boss_psg1-spointzero
00012010 DC04 000C                M 	dc.b	$e8-$0c,$04,$00,v0c
00012014                            	sHeaderPSG	Boss_PSG2,	$E8-$0C, $06, $00, v0C
00012014 0000                     M 	dc.w	boss_psg2-spointzero
00012016 DC06 000C                M 	dc.b	$e8-$0c,$06,$00,v0c
0001201A                            	sHeaderPSG	Boss_PSG3,	$FE-$0C, $03, $00, v04
0001201A 0000                     M 	dc.w	boss_psg3-spointzero
0001201C F203 0004                M 	dc.b	$fe-$0c,$03,$00,v04
00012020                            
00012020                            ; FM1 Data
00012020                            Boss_FM1:
00012020                            	sVoice        $56
00012020 E856                     M 	dc.b	$e8,$56
00012022                            
00012022                            Boss_Jump01:
00012022                            	sNoteTimeOut        $08
00012022 FD08                     M 	dc.b	$fd,$08
00012024                            	sCall            Boss_Call02
00012024 F8                       M 	dc.b	$f8
00012025 0000                     M 	dc.w	boss_call02-*-1
00012027                            	sNoteTimeOut        $0A
00012027 FD0A                     M 	dc.b	$fd,$0a
00012029                            
00012029                            Boss_Loop0B:
00012029 910C 9D                    	dc.b	nE1, $0C, nE2
0001202C                            	sLoop            $00, $04, Boss_Loop0B
0001202C F700                     M 	dc.b	$f7,$00
0001202E FFFA                     M 	dc.w	boss_loop0b-*-1
00012030 04                       M 	dc.b	$04
00012031                            	sNoteTimeOut        $08
00012031 FD08                     M 	dc.b	$fd,$08
00012033                            	sCall            Boss_Call02
00012033 F8                       M 	dc.b	$f8
00012034 0000                     M 	dc.w	boss_call02-*-1
00012036                            	sNoteTimeOut        $0A
00012036 FD0A                     M 	dc.b	$fd,$0a
00012038 910C 9D93 9F94 A095 A1     	dc.b	nE1, $0C, nE2, nFs1, nFs2, nG1, nG2, nAb1, nAb2
00012041                            
00012041                            Boss_Loop0C:
00012041                            	sCall            Boss_Call03
00012041 F8                       M 	dc.b	$f8
00012042 0000                     M 	dc.w	boss_call03-*-1
00012044 940C A006 A094 0CA0 06A0   	dc.b	nG1, $0C, nG2, $06, nG2, nG1, $0C, nG2, $06, nG2
0001204E                            	sCall            Boss_Call03
0001204E F8                       M 	dc.b	$f8
0001204F 0000                     M 	dc.w	boss_call03-*-1
00012051 910C 9D06 9D91 0C9D 069D   	dc.b	nE1, $0C, nE2, $06, nE2, nE1, $0C, nE2, $06, nE2
0001205B                            	sLoop            $00, $04, Boss_Loop0C
0001205B F700                     M 	dc.b	$f7,$00
0001205D FFE3                     M 	dc.w	boss_loop0c-*-1
0001205F 04                       M 	dc.b	$04
00012060                            	ssJump            Boss_Jump01
00012060 F6                       M 	dc.b	$f6
00012061 FFC0                     M 	dc.w	boss_jump01-*-1
00012063                            
00012063                            Boss_Call03:
00012063 960C A206 A296 0CA2 06A2+  	dc.b	nA1, $0C, nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nA1, $0C
0001206F A206 A296 0CA2 06A2 940C+  	dc.b	nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nG1, $0C, nG2, $06
0001207B A094 0CA0 06A0             	dc.b	nG2, nG1, $0C, nG2, $06, nG2
00012081                            	sRet
00012081 F9                       M 	dc.b	$f9
00012082                            
00012082                            Boss_Call02:
00012082 960C A2A2 96A2 A296 A2     	dc.b	nA1, $0C, nA2, nA2, nA1, nA2, nA2, nA1, nA2
0001208B                            	sRet
0001208B F9                       M 	dc.b	$f9
0001208C                            
0001208C                            ; PSG1 Data
0001208C                            Boss_PSG1:
0001208C                            ; PSG2 Data
0001208C                            Boss_PSG2:
0001208C                            Boss_DAC2:
0001208C                            	sStop
0001208C F5                       M 	dc.b	$f5
0001208D                            
0001208D                            ; FM2 Data
0001208D                            Boss_FM2:
0001208D                            	sVoice        $58
0001208D E858                     M 	dc.b	$e8,$58
0001208F                            
0001208F                            Boss_Loop09:
0001208F                            	sNoteTimeOut        $08
0001208F FD08                     M 	dc.b	$fd,$08
00012091 AE0C A9A9 AEA9 A9AE A9     	dc.b	nA3, $0C, nE3, nE3, nA3, nE3, nE3, nA3, nE3
0001209A                            	sNoteTimeOut        $17
0001209A FD17                     M 	dc.b	$fd,$17
0001209C B018 B0B0 B0               	dc.b	nB3, $18, nB3, nB3, nB3
000120A1                            	sLoop            $00, $02, Boss_Loop09
000120A1 F700                     M 	dc.b	$f7,$00
000120A3 FFEB                     M 	dc.w	boss_loop09-*-1
000120A5 02                       M 	dc.b	$02
000120A6                            	saTranspose      $F4
000120A6 E4F4                     M 	dc.b	$e4,$f4
000120A8                            	sVoice        $59
000120A8 E859                     M 	dc.b	$e8,$59
000120AA                            
000120AA                            Boss_Loop0A:
000120AA                            	sCall            Boss_Call01
000120AA F8                       M 	dc.b	$f8
000120AB 0000                     M 	dc.w	boss_call01-*-1
000120AD                            	sLoop            $00, $04, Boss_Loop0A
000120AD F700                     M 	dc.b	$f7,$00
000120AF FFFA                     M 	dc.w	boss_loop0a-*-1
000120B1 04                       M 	dc.b	$04
000120B2                            	saTranspose      $0C
000120B2 E40C                     M 	dc.b	$e4,$0c
000120B4                            	ssJump            Boss_FM2
000120B4 F6                       M 	dc.b	$f6
000120B5 FFD7                     M 	dc.w	boss_fm2-*-1
000120B7                            
000120B7                            Boss_Call01:
000120B7 AE06 80B0 80B1 18B3 B1B0+  	dc.b	nA3, $06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst
000120C3 B180 B080 AC18 A906 80AC+  	dc.b	nC4, nRst, nB3, nRst, nG3, $18, nE3, $06, nRst, nG3, $18, nA3
000120CF 0680 B080 B118 B3B1 B006+  	dc.b	$06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst, nC4
000120DB 80B3 80B4 80B5 0C80 24     	dc.b	nRst, nD4, nRst, nEb4, nRst, nE4, $0C, nRst, $24
000120E4                            	sRet
000120E4 F9                       M 	dc.b	$f9
000120E5                            
000120E5                            ; FM3 Data
000120E5                            Boss_FM3:
000120E5                            	sVoice        $58
000120E5 E858                     M 	dc.b	$e8,$58
000120E7                            
000120E7                            Boss_Loop06:
000120E7                            	sNoteTimeOut        $08
000120E7 FD08                     M 	dc.b	$fd,$08
000120E9 B10C AEAE B1AE AEB1 AE     	dc.b	nC4, $0C, nA3, nA3, nC4, nA3, nA3, nC4, nA3
000120F2                            	sNoteTimeOut        $17
000120F2 FD17                     M 	dc.b	$fd,$17
000120F4 AD18 ADAD AD               	dc.b	nAb3, $18, nAb3, nAb3, nAb3
000120F9                            	sLoop            $00, $02, Boss_Loop06
000120F9 F700                     M 	dc.b	$f7,$00
000120FB FFEB                     M 	dc.w	boss_loop06-*-1
000120FD 02                       M 	dc.b	$02
000120FE                            
000120FE                            Boss_Loop07:
000120FE 8030                       	dc.b	nRst, $30
00012100                            	sLoop            $00, $10, Boss_Loop07
00012100 F700                     M 	dc.b	$f7,$00
00012102 FFFB                     M 	dc.w	boss_loop07-*-1
00012104 10                       M 	dc.b	$10
00012105                            	ssDetune       $03
00012105 E103                     M 	dc.b	$e1,$03
00012107                            	saVol        $FC
00012107 EDFC                     M 	dc.b	$ed,$fc
00012109                            
00012109                            Boss_Loop08:
00012109                            	sCall            Boss_Call01
00012109 F8                       M 	dc.b	$f8
0001210A FFAC                     M 	dc.w	boss_call01-*-1
0001210C                            	sLoop            $00, $02, Boss_Loop08
0001210C F700                     M 	dc.b	$f7,$00
0001210E FFFA                     M 	dc.w	boss_loop08-*-1
00012110 02                       M 	dc.b	$02
00012111                            	ssDetune       $00
00012111 E100                     M 	dc.b	$e1,$00
00012113                            	saVol        $04
00012113 ED04                     M 	dc.b	$ed,$04
00012115                            	ssJump            Boss_FM3
00012115 F6                       M 	dc.b	$f6
00012116 FFCE                     M 	dc.w	boss_fm3-*-1
00012118                            
00012118                            ; FM4 Data
00012118                            Boss_FM4:
00012118                            	sPan             spLeft, $00
00012118 E080                     M 	dc.b	$e0,spleft|$00
0001211A                            	ssDetune       $02
0001211A E102                     M 	dc.b	$e1,$02
0001211C                            	ssMod68k          $0C, $01, $04, $04
0001211C F00C 0104 04             M 	dc.b	$f0,$0c,$01,$04,$04
00012121                            	ssJump            Boss_Jump00
00012121 F6                       M 	dc.b	$f6
00012122 0000                     M 	dc.w	boss_jump00-*-1
00012124                            
00012124                            ; FM5 Data
00012124                            Boss_FM5:
00012124                            	sPan             spRight, $00
00012124 E040                     M 	dc.b	$e0,spright|$00
00012126                            	ssMod68k          $0C, $01, $FC, $04
00012126 F00C 01FC 04             M 	dc.b	$f0,$0c,$01,$fc,$04
0001212B                            
0001212B                            Boss_Jump00:
0001212B                            	sModOff
0001212B EC                       M 	dc.b	$ec
0001212C                            	sVoice        $57
0001212C E857                     M 	dc.b	$e8,$57
0001212E 8030 8024 BF06 C1C2 0CC2+  	dc.b	nRst, $30, nRst, $24, nD5, $06, nE5, nF5, $0C, nF5, nE5, nE5
0001213A BFBF C180 8030 8024 BF06+  	dc.b	nD5, nD5, nE5, nRst, nRst, $30, nRst, $24, nD5, $06, nE5, nF5
00012146 0CC1 C0C1 C518 C1          	dc.b	$0C, nE5, nEb5, nE5, nAb5, $18, nE5
0001214D                            
0001214D                            Boss_Loop05:
0001214D 8030 80                    	dc.b	nRst, $30, nRst
00012150                            	sLoop            $00, $04, Boss_Loop05
00012150 F700                     M 	dc.b	$f7,$00
00012152 FFFA                     M 	dc.w	boss_loop05-*-1
00012154 04                       M 	dc.b	$04
00012155                            	sModOn
00012155 EB                       M 	dc.b	$eb
00012156                            	saVol        $02
00012156 ED02                     M 	dc.b	$ed,$02
00012158                            	sCall            Boss_Call00
00012158 F8                       M 	dc.b	$f8
00012159 0000                     M 	dc.w	boss_call00-*-1
0001215B AC                         	dc.b	nG3
0001215C                            	sCall            Boss_Call00
0001215C F8                       M 	dc.b	$f8
0001215D 0000                     M 	dc.w	boss_call00-*-1
0001215F ADBD E718 BF0C BDBC 30B8+  	dc.b	nAb3, nC5, sHold, $18, nD5, $0C, nC5, nB4, $30, nG4, nC5, sHold
0001216B 18BF 0CBD BC30 B9          	dc.b	$18, nD5, $0C, nC5, nB4, $30, nAb4
00012172                            	saVol        $F5
00012172 EDF5                     M 	dc.b	$ed,$f5
00012174                            	sVoice        $58
00012174 E858                     M 	dc.b	$e8,$58
00012176 BD06 80BF 80C1 18C2 C1BF+  	dc.b	nC5, $06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst
00012182 C180 BF80 BC18 B806 80BC+  	dc.b	nE5, nRst, nD5, nRst, nB4, $18, nG4, $06, nRst, nB4, $18, nC5
0001218E 0680 BF80 C118 C2C1 BF06+  	dc.b	$06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst, nE5
0001219A 80C2 80C3 80C5 0C80 24     	dc.b	nRst, nF5, nRst, nFs5, nRst, nAb5, $0C, nRst, $24
000121A3                            	saVol        $09
000121A3 ED09                     M 	dc.b	$ed,$09
000121A5                            	ssJump            Boss_Jump00
000121A5 F6                       M 	dc.b	$f6
000121A6 FF84                     M 	dc.w	boss_jump00-*-1
000121A8                            
000121A8                            Boss_Call00:
000121A8 B130 E718 B30C B1B0 30     	dc.b	nC4, $30, sHold, $18, nD4, $0C, nC4, nB3, $30
000121B1                            	sRet
000121B1 F9                       M 	dc.b	$f9
000121B2                            
000121B2                            ; PSG3 Data
000121B2                            Boss_PSG3:
000121B2                            	sNoisePSG         $E7
000121B2 F3E7                     M 	dc.b	$f3,$e7
000121B4                            	sNoteTimeOut        $05
000121B4 FD05                     M 	dc.b	$fd,$05
000121B6                            
000121B6                            Boss_Loop0D:
000121B6 C624 2418 8030 80          	dc.b	nA5, $24, $24, $18, nRst, $30, nRst
000121BD                            	sLoop            $00, $02, Boss_Loop0D
000121BD F700                     M 	dc.b	$f7,$00
000121BF FFF6                     M 	dc.w	boss_loop0d-*-1
000121C1 02                       M 	dc.b	$02
000121C2                            
000121C2                            Boss_Loop0E:
000121C2 C618                       	dc.b	nA5, $18
000121C4                            	sLoop            $00, $40, Boss_Loop0E
000121C4 F700                     M 	dc.b	$f7,$00
000121C6 FFFB                     M 	dc.w	boss_loop0e-*-1
000121C8 40                       M 	dc.b	$40
000121C9                            	ssJump            Boss_Loop0D
000121C9 F6                       M 	dc.b	$f6
000121CA FFEB                     M 	dc.w	boss_loop0d-*-1
000121CC                            
000121CC                            ; DAC Data
000121CC                            Boss_DAC:
000121CC 830C 8383 8383 8383 8387+  	dc.b	dSnare, $0C, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dTomMid, $0C, dTomL
000121D8 8789 8789 8789             	dc.b	dTomMid, dTomL, dTomMid, dTomL, dTomMid, dTomL
000121DE                            	sLoop            $00, $02, Boss_DAC
000121DE F700                     M 	dc.b	$f7,$00
000121E0 FFEB                     M 	dc.w	boss_dac-*-1
000121E2 02                       M 	dc.b	$02
000121E3 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
000121E8                            
000121E8                            Boss_Loop00:
000121E8 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
000121ED                            	sLoop            $00, $06, Boss_Loop00
000121ED F700                     M 	dc.b	$f7,$00
000121EF FFF8                     M 	dc.w	boss_loop00-*-1
000121F1 06                       M 	dc.b	$06
000121F2 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
000121FE 8306 83                    	dc.b	dSnare, $06, dSnare
00012201                            
00012201                            Boss_Loop01:
00012201 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012206                            	sLoop            $00, $05, Boss_Loop01
00012206 F700                     M 	dc.b	$f7,$00
00012208 FFF8                     M 	dc.w	boss_loop01-*-1
0001220A 05                       M 	dc.b	$05
0001220B 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00012217 8302 8704 8302 8704 890C+  	dc.b	dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C, dSnare, $06
00012223 83                         	dc.b	dSnare
00012224                            	sLoop            $01, $03, Boss_Loop00
00012224 F701                     M 	dc.b	$f7,$01
00012226 FFC1                     M 	dc.w	boss_loop00-*-1
00012228 03                       M 	dc.b	$03
00012229                            
00012229                            Boss_Loop02:
00012229 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
0001222E                            	sLoop            $00, $06, Boss_Loop02
0001222E F700                     M 	dc.b	$f7,$00
00012230 FFF8                     M 	dc.w	boss_loop02-*-1
00012232 06                       M 	dc.b	$06
00012233 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
0001223F 8306 83                    	dc.b	dSnare, $06, dSnare
00012242                            
00012242                            Boss_Loop03:
00012242 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012247                            	sLoop            $00, $03, Boss_Loop03
00012247 F700                     M 	dc.b	$f7,$00
00012249 FFF8                     M 	dc.w	boss_loop03-*-1
0001224B 03                       M 	dc.b	$03
0001224C                            
0001224C                            Boss_Loop04:
0001224C 890C 8302 8704 8302 8704   	dc.b	dTomL, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04
00012256                            	sLoop            $00, $04, Boss_Loop04
00012256 F700                     M 	dc.b	$f7,$00
00012258 FFF3                     M 	dc.w	boss_loop04-*-1
0001225A 04                       M 	dc.b	$04
0001225B                            	ssJump            Boss_DAC
0001225B F6                       M 	dc.b	$f6
0001225C FF6F                     M 	dc.w	boss_dac-*-1
0001225E                            		even
0001225E                            
0001225E                            ; -------------------------------------------------------------------------
0001225E                            musend
0001225E                            ; ===========================================================================
0001225E                            ; ---------------------------------------------------------------------------
0001225E                            ; Include samples and filters
0001225E                            ; ---------------------------------------------------------------------------
0001225E                            
0001225E                            		align	$8000		; must be aligned to bank...
0001225E                          M 	cnop	0,$8000
00018000                            fLog:		incbin "Sound/amps/filters/Logarithmic.dat"	; logarithmic filter (no filter)
00020000                            ;fLinear:	incbin "Sound/amps/filters/Linear.dat"	; linear filter (no filter)
00020000                            
00020000                            dacaddr		dcb.b	Z80E_Read*(MaxPitch/$100),$00
00020180                            SWF_Stop:	dcb.b	$8000-(2*Z80E_Read*(MaxPitch/$100)),$80
00027E80                            SWFR_Stop:	dcb.b	Z80E_Read*(MaxPitch/$100),$00
00028000                            
00028000                            	include	"Sound/dacdata.asm"
00028000                            
00028000                            
00028000                            ; ------------------------------------------------------------------------
00028000                            ; AMPS sample data
00028000                            ; -------------------------------------------------------------------------
00028000                            
00028000                            	incSWF	Kick,		"Sound/dac/incswf/Kick.swf"
00028000                          M swf_kick	incbin	"Sound/dac/incswf/Kick.swf"
00028E4A                          M swfr_kick	dcb.b	z80e_read*(maxpitch/$100),$00
00028FCA                            	incSWF	Snare,		"Sound/dac/incswf/Snare.swf"
00028FCA                          M swf_snare	incbin	"Sound/dac/incswf/Snare.swf"
0002B874                          M swfr_snare	dcb.b	z80e_read*(maxpitch/$100),$00
0002B9F4                            	incSWF	Tom,		"Sound/dac/incswf/Space Tom.swf"
0002B9F4                          M swf_tom	incbin	"Sound/dac/incswf/Space Tom.swf"
0002E288                          M swfr_tom	dcb.b	z80e_read*(maxpitch/$100),$00
0002E408                            	incSWF	Title,		"Sound/dac/incswf/Title.swf"
0002E408                          M swf_title	incbin	"Sound/dac/incswf/Title.swf"
00084EC7                          M swfr_title	dcb.b	z80e_read*(maxpitch/$100),$00
00085047                            	incSWF	Sega,		"Sound/dac/incswf/Sega.swf"
00085047                          M swf_sega	incbin	"Sound/dac/incswf/Sega.swf"
0008AC9D                          M swfr_sega	dcb.b	z80e_read*(maxpitch/$100),$00
0008AE1D                            	incSWF	Punch,		"Sound/dac/incswf/Punch.swf"
0008AE1D                          M swf_punch	incbin	"Sound/dac/incswf/Punch.swf"
0008D145                          M swfr_punch	dcb.b	z80e_read*(maxpitch/$100),$00
0008D2C5                            	incSWF	EndingSong,	"Sound/dac/incswf/EndingSong.swf"
0008D2C5                          M swf_endingsong	incbin	"Sound/dac/incswf/EndingSong.swf"
0009A6D8                          M swfr_endingsong	dcb.b	z80e_read*(maxpitch/$100),$00
0009A858                            	incSWF	BinBowie,	"Sound/dac/incswf/BinBowie.swf"
0009A858                          M swf_binbowie	incbin	"Sound/dac/incswf/BinBowie.swf"
000AF3FE                          M swfr_binbowie	dcb.b	z80e_read*(maxpitch/$100),$00
000AF57E                            	incSWF	Wacky_Base_Loud,"Sound/dac/incswf/Wacky_Base_Loud.swf"
000AF57E                          M swf_wacky_base_loud	incbin	"Sound/dac/incswf/Wacky_Base_Loud.swf"
000BB808                          M swfr_wacky_base_loud	dcb.b	z80e_read*(maxpitch/$100),$00
000BB988                            
000BB988                            ; -------------------------------------------------------------------------
000BB988                            	opt ae+				; enable automatic evens
000BB988                            	list				; continue source listing
000BB988                            ; ===========================================================================
000BB988                            DualPCM:
000BB988                            		z80prog	0
000BB988                          M 	pusho
000BB988                          M 	opt	ae-
000BB988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000BD4BF =00000000                M z80prg	=	0
000BD4BF                          M 	mexit
000BD4BF                            
000BD4BF                            ; =========================================================================================================================================================
000BD4BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            ; Error handler
000BD4BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            		include	"Config/Error/error.asm"
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Vladikcomper's debugger
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Error handler control flags
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Screen appearence flags
000BD4BF =00000001                  _eh_address_error	equ	$01	; use for address and bus errors only (tells error handler to display additional "Address" field)
000BD4BF =00000002                  _eh_show_sr_usp		equ	$02	; displays SR and USP registers content on error screen
000BD4BF                            
000BD4BF                            ; Advanced execution flags
000BD4BF                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
000BD4BF =00000020                  _eh_return		equ	$20
000BD4BF =00000040                  _eh_enter_console	equ	$40
000BD4BF =00000080                  _eh_align_offset	equ	$80
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Errors vector table
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Default screen configuration
000BD4BF =00000000                  _eh_default		equ	0	;_eh_show_sr_usp
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            exBus:
000BD4BF                            	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
000BD4BF                          M 	__fstring_generateargumentscode	"BUS ERROR"
000BD4BF =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4BF =00000000                M 	__stack:set	0
000BD4BF =00000000                M 	__sp:	set 0
000BD4BF                          M 	while	(__pos)
000BD4BF                          M 	rept	__stack
000BD4C0 004E B900 0000 00        M 	jsr	errorhandler
000BD4C6                          M 	__fstring_generatedecodedstring	"BUS ERROR"
000BD4C6 =00000001                M 	__lpos:	set 1
000BD4C6 =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4C6                          M 	while	(__pos)
000BD4C6                          M 	__substr:	substr __lpos,,"BUS ERROR"
000BD4C6 4255 5320 4552 524F 52   M 	dc.b	"BUS ERROR"
000BD4CF 00                       M 	dc.b	0
000BD4D0 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4D2 00                       M 	even
000BD4D2                            
000BD4D2                            exAddr:
000BD4D2                            	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
000BD4D2                          M 	__fstring_generateargumentscode	"ADDRESS ERROR"
000BD4D2 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D2 =00000000                M 	__stack:set	0
000BD4D2 =00000000                M 	__sp:	set 0
000BD4D2                          M 	while	(__pos)
000BD4D2                          M 	rept	__stack
000BD4D2 4EB9 0000 0000           M 	jsr	errorhandler
000BD4D8                          M 	__fstring_generatedecodedstring	"ADDRESS ERROR"
000BD4D8 =00000001                M 	__lpos:	set 1
000BD4D8 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D8                          M 	while	(__pos)
000BD4D8                          M 	__substr:	substr __lpos,,"ADDRESS ERROR"
000BD4D8 4144 4452 4553 5320 4552+M 	dc.b	"ADDRESS ERROR"
000BD4E5 00                       M 	dc.b	0
000BD4E6 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4E8 00                       M 	even
000BD4E8                            
000BD4E8                            exIll:
000BD4E8                            	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
000BD4E8                          M 	__fstring_generateargumentscode	"ILLEGAL INSTRUCTION"
000BD4E8 =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4E8 =00000000                M 	__stack:set	0
000BD4E8 =00000000                M 	__sp:	set 0
000BD4E8                          M 	while	(__pos)
000BD4E8                          M 	rept	__stack
000BD4E8 4EB9 0000 0000           M 	jsr	errorhandler
000BD4EE                          M 	__fstring_generatedecodedstring	"ILLEGAL INSTRUCTION"
000BD4EE =00000001                M 	__lpos:	set 1
000BD4EE =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4EE                          M 	while	(__pos)
000BD4EE                          M 	__substr:	substr __lpos,,"ILLEGAL INSTRUCTION"
000BD4EE 494C 4C45 4741 4C20 494E+M 	dc.b	"ILLEGAL INSTRUCTION"
000BD501 00                       M 	dc.b	0
000BD502 00                       M 	dc.b	_eh_default+0
000BD504 00                       M 	even
000BD504                            
000BD504                            exDiv:
000BD504                            	__ErrorMessage "ZERO DIVIDE", _eh_default
000BD504                          M 	__fstring_generateargumentscode	"ZERO DIVIDE"
000BD504 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD504 =00000000                M 	__stack:set	0
000BD504 =00000000                M 	__sp:	set 0
000BD504                          M 	while	(__pos)
000BD504                          M 	rept	__stack
000BD504 4EB9 0000 0000           M 	jsr	errorhandler
000BD50A                          M 	__fstring_generatedecodedstring	"ZERO DIVIDE"
000BD50A =00000001                M 	__lpos:	set 1
000BD50A =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD50A                          M 	while	(__pos)
000BD50A                          M 	__substr:	substr __lpos,,"ZERO DIVIDE"
000BD50A 5A45 524F 2044 4956 4944+M 	dc.b	"ZERO DIVIDE"
000BD515 00                       M 	dc.b	0
000BD516 00                       M 	dc.b	_eh_default+0
000BD518 00                       M 	even
000BD518                            
000BD518                            exChk:
000BD518                            	__ErrorMessage "CHK INSTRUCTION", _eh_default
000BD518                          M 	__fstring_generateargumentscode	"CHK INSTRUCTION"
000BD518 =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD518 =00000000                M 	__stack:set	0
000BD518 =00000000                M 	__sp:	set 0
000BD518                          M 	while	(__pos)
000BD518                          M 	rept	__stack
000BD518 4EB9 0000 0000           M 	jsr	errorhandler
000BD51E                          M 	__fstring_generatedecodedstring	"CHK INSTRUCTION"
000BD51E =00000001                M 	__lpos:	set 1
000BD51E =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD51E                          M 	while	(__pos)
000BD51E                          M 	__substr:	substr __lpos,,"CHK INSTRUCTION"
000BD51E 4348 4B20 494E 5354 5255+M 	dc.b	"CHK INSTRUCTION"
000BD52D 00                       M 	dc.b	0
000BD52E 00                       M 	dc.b	_eh_default+0
000BD530 00                       M 	even
000BD530                            
000BD530                            Trapv:
000BD530                            	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
000BD530                          M 	__fstring_generateargumentscode	"TRAPV INSTRUCTION"
000BD530 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD530 =00000000                M 	__stack:set	0
000BD530 =00000000                M 	__sp:	set 0
000BD530                          M 	while	(__pos)
000BD530                          M 	rept	__stack
000BD530 4EB9 0000 0000           M 	jsr	errorhandler
000BD536                          M 	__fstring_generatedecodedstring	"TRAPV INSTRUCTION"
000BD536 =00000001                M 	__lpos:	set 1
000BD536 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD536                          M 	while	(__pos)
000BD536                          M 	__substr:	substr __lpos,,"TRAPV INSTRUCTION"
000BD536 5452 4150 5620 494E 5354+M 	dc.b	"TRAPV INSTRUCTION"
000BD547 00                       M 	dc.b	0
000BD548 00                       M 	dc.b	_eh_default+0
000BD54A 00                       M 	even
000BD54A                            
000BD54A                            exPriv:
000BD54A                            	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
000BD54A                          M 	__fstring_generateargumentscode	"PRIVILEGE VIOLATION"
000BD54A =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD54A =00000000                M 	__stack:set	0
000BD54A =00000000                M 	__sp:	set 0
000BD54A                          M 	while	(__pos)
000BD54A                          M 	rept	__stack
000BD54A 4EB9 0000 0000           M 	jsr	errorhandler
000BD550                          M 	__fstring_generatedecodedstring	"PRIVILEGE VIOLATION"
000BD550 =00000001                M 	__lpos:	set 1
000BD550 =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD550                          M 	while	(__pos)
000BD550                          M 	__substr:	substr __lpos,,"PRIVILEGE VIOLATION"
000BD550 5052 4956 494C 4547 4520+M 	dc.b	"PRIVILEGE VIOLATION"
000BD563 00                       M 	dc.b	0
000BD564 00                       M 	dc.b	_eh_default+0
000BD566 00                       M 	even
000BD566                            
000BD566                            exTrace:
000BD566                            	__ErrorMessage "TRACE", _eh_default
000BD566                          M 	__fstring_generateargumentscode	"TRACE"
000BD566 =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD566 =00000000                M 	__stack:set	0
000BD566 =00000000                M 	__sp:	set 0
000BD566                          M 	while	(__pos)
000BD566                          M 	rept	__stack
000BD566 4EB9 0000 0000           M 	jsr	errorhandler
000BD56C                          M 	__fstring_generatedecodedstring	"TRACE"
000BD56C =00000001                M 	__lpos:	set 1
000BD56C =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD56C                          M 	while	(__pos)
000BD56C                          M 	__substr:	substr __lpos,,"TRACE"
000BD56C 5452 4143 45             M 	dc.b	"TRACE"
000BD571 00                       M 	dc.b	0
000BD572 00                       M 	dc.b	_eh_default+0
000BD574 00                       M 	even
000BD574                            
000BD574                            exLineA:
000BD574                            	__ErrorMessage "LINE A EMULATOR", _eh_default
000BD574                          M 	__fstring_generateargumentscode	"LINE A EMULATOR"
000BD574 =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD574 =00000000                M 	__stack:set	0
000BD574 =00000000                M 	__sp:	set 0
000BD574                          M 	while	(__pos)
000BD574                          M 	rept	__stack
000BD574 4EB9 0000 0000           M 	jsr	errorhandler
000BD57A                          M 	__fstring_generatedecodedstring	"LINE A EMULATOR"
000BD57A =00000001                M 	__lpos:	set 1
000BD57A =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD57A                          M 	while	(__pos)
000BD57A                          M 	__substr:	substr __lpos,,"LINE A EMULATOR"
000BD57A 4C49 4E45 2041 2045 4D55+M 	dc.b	"LINE A EMULATOR"
000BD589 00                       M 	dc.b	0
000BD58A 00                       M 	dc.b	_eh_default+0
000BD58C 00                       M 	even
000BD58C                            
000BD58C                            exLineF:
000BD58C                            	__ErrorMessage "LINE F EMULATOR", _eh_default
000BD58C                          M 	__fstring_generateargumentscode	"LINE F EMULATOR"
000BD58C =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD58C =00000000                M 	__stack:set	0
000BD58C =00000000                M 	__sp:	set 0
000BD58C                          M 	while	(__pos)
000BD58C                          M 	rept	__stack
000BD58C 4EB9 0000 0000           M 	jsr	errorhandler
000BD592                          M 	__fstring_generatedecodedstring	"LINE F EMULATOR"
000BD592 =00000001                M 	__lpos:	set 1
000BD592 =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD592                          M 	while	(__pos)
000BD592                          M 	__substr:	substr __lpos,,"LINE F EMULATOR"
000BD592 4C49 4E45 2046 2045 4D55+M 	dc.b	"LINE F EMULATOR"
000BD5A1 00                       M 	dc.b	0
000BD5A2 00                       M 	dc.b	_eh_default+0
000BD5A4 00                       M 	even
000BD5A4                            
000BD5A4                            exMisc:
000BD5A4                            	__ErrorMessage "MISC EXCEPTION", _eh_default
000BD5A4                          M 	__fstring_generateargumentscode	"MISC EXCEPTION"
000BD5A4 =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5A4 =00000000                M 	__stack:set	0
000BD5A4 =00000000                M 	__sp:	set 0
000BD5A4                          M 	while	(__pos)
000BD5A4                          M 	rept	__stack
000BD5A4 4EB9 0000 0000           M 	jsr	errorhandler
000BD5AA                          M 	__fstring_generatedecodedstring	"MISC EXCEPTION"
000BD5AA =00000001                M 	__lpos:	set 1
000BD5AA =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5AA                          M 	while	(__pos)
000BD5AA                          M 	__substr:	substr __lpos,,"MISC EXCEPTION"
000BD5AA 4D49 5343 2045 5843 4550+M 	dc.b	"MISC EXCEPTION"
000BD5B8 00                       M 	dc.b	0
000BD5B9 00                       M 	dc.b	_eh_default+0
000BD5BA                          M 	even
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Import error handler global functions
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            ErrorHandler.__global__error_initconsole		equ	ErrorHandler+$146
000BD5BA                            ErrorHandler.__global__errorhandler_setupvdp		equ	ErrorHandler+$234
000BD5BA                            ErrorHandler.__global__console_loadpalette		equ	ErrorHandler+$A1C
000BD5BA                            ErrorHandler.__global__console_setposasxy_stack		equ	ErrorHandler+$A58
000BD5BA                            ErrorHandler.__global__console_setposasxy		equ	ErrorHandler+$A5E
000BD5BA                            ErrorHandler.__global__console_getposasxy		equ	ErrorHandler+$A8A
000BD5BA                            ErrorHandler.__global__console_startnewline		equ	ErrorHandler+$AAC
000BD5BA                            ErrorHandler.__global__console_setbasepattern		equ	ErrorHandler+$AD4
000BD5BA                            ErrorHandler.__global__console_setwidth			equ	ErrorHandler+$AE8
000BD5BA                            ErrorHandler.__global__console_writeline_withpattern	equ	ErrorHandler+$AFE
000BD5BA                            ErrorHandler.__global__console_writeline		equ	ErrorHandler+$B00
000BD5BA                            ErrorHandler.__global__console_write			equ	ErrorHandler+$B04
000BD5BA                            ErrorHandler.__global__console_writeline_formatted	equ	ErrorHandler+$BB0
000BD5BA                            ErrorHandler.__global__console_write_formatted		equ	ErrorHandler+$BB4
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Error handler external functions (compiled only when used)
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            
000BD5BA                            ErrorHandler.__extern__console_only:
000BD5BA 46FC 2700 4FEF FFF2 48E7+  	dc.l	$46FC2700, $4FEFFFF2, $48E7FFFE, $47EF003C
000BD5CA 4EBA 0000                  	jsr		ErrorHandler.__global__errorhandler_setupvdp(pc)
000BD5CE 4EBA 0000                  	jsr		ErrorHandler.__global__error_initconsole(pc)
000BD5D2 4CDF 7FFF 487A 0008 2F2F+  	dc.l	$4CDF7FFF, $487A0008, $2F2F0012, $4E7560FE
000BD5E2                            
000BD5E2                            
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            ; Include error handler binary module
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            
000BD5E2                            ErrorHandler:
000BD5E2                            	incbin	"Config/Error/ErrorHandler.bin"
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; WARNING!
000BEFF6                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
000BEFF6                            ;	Symbol data should be appended here after ROM is compiled
000BEFF6                            ;	by ConvSym utility, otherwise debugger modules won't be able
000BEFF6                            ;	to resolve symbol names.
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; =========================================================================================================================================================
