00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling module
00000000                            ; 2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            	include	"Macros.asm"
00000000                            
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00C00000                  VDP_Data			equ $C00000
00000000 =00C00004                  VDP_Ctrl			equ $C00004
00000000                            
00000000                            ; Generate VRAM write command
00000000                            vram		macro
00000000                            	if narg=1
00000000                            		move.l	#($40000000+((\1&$3FFF)<<16)+((\1&$C000)>>14)),($C00004).l
00000000                            	else
00000000                            		move.l	#($40000000+((\1&$3FFF)<<16)+((\1&$C000)>>14)),\2
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; Generate dc.l constant with VRAM write command
00000000                            dcvram		macro
00000000                            		dc.l	($40000000+((\1&$3FFF)<<16)+((\1&$C000)>>14))
00000000                            	endm
00000000                            
00000000                            ; Generate CRAM write command
00000000                            cram	macro	offset,operand
00000000                            	if narg=1
00000000                            		move.l	#($C0000000+(\1<<16)),VDP_Ctrl
00000000                            	else
00000000                            		move.l	#($C0000000+(\1<<16)),\operand
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; Special macro do define externally visible symbols
00000000                            __global macro	*
00000000                            __global__\*:
00000000                            \*:
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000400                  VRAM_Font			equ (('!'-1)*$20)
00000000 =00002400                  VRAM_Font2			equ (($100+'!'-1)*$20)
00000000 =00008000                  VRAM_PlaneA 			equ $8000
00000000 =00008000                  VRAM_PlaneB		 	equ VRAM_PlaneA
00000000                            
00000000 =00000000                  _white				equ 0
00000000 =00002000                  _yellow 			equ 1<<13
00000000 =00004000                  _blue				equ 2<<13
00000000 =00006000                  _blue2				equ 3<<13
00000000 =00000000                  checkall			equ 0
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Main error handler
00000000                            ; ---------------------------------------------------------------
00000000                            ; GLOBAL REGISTERS:
00000000                            ;		d6	.b	Error handler flags bitfield
00000000                            ;		a3		Pointer to additional parameters
00000000                            ;		a4		Stack pointer (after exception frame)
00000000                            ;
00000000                            ; NOTE:	It should be called via JSR/BSR exclusively with error
00000000                            ;		information following the JSR/BSR opcode.
00000000                            ;
00000000                            ; ERROR DATA FORMAT:
00000000                            ;		dc.b	"<Error formatted message>", 0
00000000                            ;		dc.b	<Error Handler flags>
00000000                            ;		even
00000000                            ;		jmp		<ConsoleProgram> (optional)
00000000                            ;
00000000                            ;	Flags bitfield uses the following format:
00000000                            ;		bit #0:	If set, loads extended stack frame (used for
00000000                            ;				Address and Bus errors only)
00000000                            ;		bit #1: If set, displays SR and USP registers
00000000                            ;		bit #2:	<UNUSED>
00000000                            ;		bit #3:	<UNUSED>
00000000                            ;		bit #4:	If set, enables instruction disassembly for some parts
00000000                            ;		bit #5:	If set, displays full screen, but then calls
00000000                            ;				console program (via "jmp <ConsoleProgram>")
00000000                            ;		bit #6:	If set, displays error header only, then calls
00000000                            ;				console program (via "jmp <ConsoleProgram>")
00000000                            ;		bit #7:	If set, skips a byte after this byte, so
00000000                            ;				jmp <ConsoleProgram> is word-aligned.
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ErrorHandler:
00000000 46FC 2700                  		move	#$2700,sr				; disable interrupts for good
00000004 4FEF 0000                  		lea	-Console_RAM.size(sp),sp		; STACK => allocate memory for console
00000008 48E7 FFFE                  		movem.l d0-a6,-(sp) 				; STACK => dump registers ($3C bytes)
0000000C                            
0000000C 4EBA 0000                  		jsr	ErrorHandler_SetupVDP(pc)
00000010 49EF 0000                  		lea 	$3C+Console_RAM.size(sp),a4		; a4 = arguments, stack frame
00000014                            
00000014 4E68                       		move.l	usp,a0
00000016 2F08                       		move.l	a0,-(sp)				; save USP if needed to display later (as it's overwritten by the console subsystem)
00000018                            
00000018                            		; Initialize console subsystem
00000018 47EF 0040                  		lea	$3C+4(sp),a3				; a3 = Console RAM
0000001C 4EBA 0000                  		jsr	Error_InitConsole(pc)
00000020                            
00000020                            ; ----------------
00000020                            ; Screen header
00000020                            ; ----------------
00000020                            
00000020 41FA 0000                  		lea	Str_SetErrorScreen(pc),a0
00000024 4EBA 0000                  		jsr	Console_Write(pc)
00000028                            
00000028                            	; Print error description
00000028 225C                       		movea.l	(a4)+,a1				; get error text
0000002A 45D4                       		lea	(a4),a2					; a2 = load arguments buffer (if present)
0000002C 4EBA 0000                  		jsr 	Console_WriteLine_Formatted(pc)
00000030 4EBA 0000                  		jsr	Console_StartNewLine(pc)
00000034                            
00000034 49D2                       		lea	(a2),a4					; a4 = stack frame (after arguments buffer was processed by Console_Write)
00000036                            
00000036                            	; Load screen configuration bitfield
00000036 1C19                       		move.b	(a1)+,d6				; d6 = configuration bitfield
00000038 6A00                       		bpl.s	.align_ok				; if "_eh_align_offset" is not set, branch
0000003A 5249                       		addq.w	#1,a1					; skip a byte to avoid address error on reading the next word
0000003C                            
0000003C                            .align_ok
0000003C 47D1                       		lea	(a1),a3					; a3 may be used to fetch console program address later
0000003E                            
0000003E                            	; Print error address (for Address error and Bus Error only)
0000003E 0806 0000                  		btst	#0,d6					; does error has extended stack frame (Address Error and Bus Error only)?
00000042 6700                       		beq.s	.skip					; if not, branch
00000044                            
00000044 43FA 0000                  		lea 	Str_Address(pc),a1			; a1 = formatted string
00000048 45EC 0002                  		lea	2(a4),a2				; a2 = arguments buffer
0000004C 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
00000050 504C                       		addq.w	#8,a4					; skip extension part of the stack frame
00000052                            ; ---------------------------------------------------------------
00000052                            
00000052                            .skip
00000052                            		; print instruction
00000052 0806 0004                  		btst	#4,d6				; AF::	; check if instruction disassembly was requested
00000056 6700                       		beq.s	.noins				; AF::	; if not, branch
00000058                            
00000058 43FA 0000                  		lea 	Str_Instruction(pc),a1			; a1 = formatted string
0000005C 45EC 0002                  		lea	2(a4),a2				; a2 = arguments buffer
00000060 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
00000064                            ; ---------------------------------------------------------------
00000064                            
00000064                            .noins
00000064                            		; Print error location
00000064 43FA 0000                  		lea 	Str_Location(pc),a1			; a1 = formatted string
00000068 45EC 0002                  		lea	2(a4),a2				; a2 = arguments buffer
0000006C 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
00000070                            
00000070                            		; Print module name error occured in
00000070 43FA 0000                  		lea 	Str_Module(pc),a1			; a1 = formatted string
00000074 45EC 0002                  		lea	2(a4),a2				; a2 = arguments buffer
00000078 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
0000007C                            
0000007C                            		; Print caller
0000007C 45EC 0006                  		lea	6(a4),a2				; a2 = call stack (after exception stack frame)
00000080 4EBA 0000                  		jsr	Error_GuessCaller(pc)			; d1 = caller
00000084 43FA 0000                  		lea 	Str_Caller(pc),a1			; a1 = formatted string
00000088 2F01                       		move.l	d1,-(sp)
0000008A 45D7                       		lea	(sp),a2					; a2 = arguments buffer
0000008C 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
00000090 4EBA 0000                  		jsr	Console_StartNewLine(pc)
00000094 584F                       		addq.w	#4,sp					; free argument
00000096                            
00000096 0806 0006                  		btst	#6,d6					; is execute console program bit set?
0000009A 6600 0000                  		bne.w	Error_EnterConsoleProgram		; if yes, branch to error trap
0000009E                            
0000009E                            ; ----------------
0000009E                            ; Registers
0000009E                            ; ----------------
0000009E                            
0000009E 45EF 0004                  		lea	4(sp),a2				; use register buffer as arguments
000000A2                            
000000A2                            		; Print data registers
000000A2 4EBA 0000                  		jsr	Console_GetPosAsXY(pc)			; d0/d1 = XY-pos
000000A6 3F01                       		move.w	d1,-(sp)				; remember line
000000A8 7003                       		moveq	#3,d0					; left margin for data registers
000000AA 4EBA 0000                  		jsr	Console_SetPosAsXY(pc)
000000AE 303C 6430                  		move.w	#'d0',d0				; d0 = 'd0', what a twist !!!
000000B2 7A07                       		moveq	#8-1,d5					; number of registers - 1
000000B4 4EBA 0000                  		jsr	Error_DrawRegisters(pc)
000000B8                            
000000B8                            		; Print address registers
000000B8 321F                       		move.w	(sp)+,d1				; restore line
000000BA 7011                       		moveq	#$11,d0					; left margin for address registers
000000BC 4EBA 0000                  		jsr	Console_SetPosAsXY(pc)
000000C0 303C 6130                  		move.w	#'a0',d0
000000C4 7A06                       		moveq	#7-1,d5					; number of registers - 1
000000C6 4EBA 0000                  		jsr	Error_DrawRegisters(pc)
000000CA                            
000000CA                            		; Special case : stack register
000000CA 303C 7370                  		move.w	#'sp',d0
000000CE 7A00                       		moveq	#0,d5
000000D0 2F0C                       		move.l	a4,-(sp)
000000D2 45D7                       		lea	(sp),a2
000000D4 4EBA 0000                  		jsr	Error_DrawRegisters(pc)
000000D8 584F                       		addq.w	#4,sp
000000DA                            
000000DA                            		; Display USP and SR (if requested)
000000DA 0806 0001                  		btst	#1,d6
000000DE 6700                       		beq.s	.skip2
000000E0                            
000000E0                            		; Draw 'USP'
000000E0 43FA 0000                  		lea	Str_USP(pc),a1
000000E4 45D7                       		lea	(sp),a2					; a2 = USP saved in stack (how convy!)
000000E6 4EBA 0000                  		jsr	Console_Write_Formatted(pc)
000000EA                            
000000EA                            		; Draw 'SR'
000000EA 43FA 0000                  		lea	Str_SR(pc),a1
000000EE 45D4                       		lea	(a4),a2
000000F0 4EBA 0000                  		jsr	Console_WriteLine_Formatted(pc)
000000F4                            
000000F4                            .skip2
000000F4 584F                       		addq.w	#4,sp					; free USP copy from the stack (we don't need it anymore)
000000F6                            
000000F6 4EBA 0000                  		jsr	Console_GetPosAsXY(pc)			; d0/d1 = XY-pos
000000FA 5241                       		addq.w	#1,d1					; skip a line
000000FC 7001                       		moveq	#1,d0					; left margin for data registers
000000FE 4EBA 0000                  		jsr	Console_SetPosAsXY(pc)
00000102                            
00000102                            
00000102                            ; --------------------
00000102                            ; Interrupt handlers
00000102                            ; --------------------
00000102                            
00000102                            		; Print vertical and horizontal interrupt handlers, if available
00000102 2038 0078                  		move.l	$78.w,d0				; d0 = VInt vector address
00000106 41FA 0000                  		lea	Str_VInt(pc),a0
0000010A 4EBA 0000                  		jsr	Error_DrawInterruptHandler(pc)
0000010E                            
0000010E 2038 0070                  		move.l	$70.w,d0				; d0 = HInt vector address
00000112 41FA 0000                  		lea	Str_HInt(pc),a0
00000116 4EBA 0000                  		jsr	Error_DrawInterruptHandler(pc)
0000011A 4EBA 0000                  		jsr	Console_StartNewLine(pc)		; newline
0000011E                            
0000011E                            ; -----------------
0000011E                            ; Stack contents
0000011E                            ; -----------------
0000011E                            
0000011E 344C                       		movea.w	a4,a2
00000120 3278 0002                  		movea.w 2.w,a1					; a1 = stack top
00000124 5349                       		subq.w	#1,a1					; hotfix to convert stack pointer $0000 to $FFFF, decrement by 1 shouldn't make any difference otherwise
00000126                            
00000126 4EBA 0000                  		jsr	Console_GetPosAsXY(pc)			; d0/d1 = XY-pos
0000012A 7A19                       		moveq	#28-3,d5
0000012C 9A41                       		sub.w	d1,d5
0000012E 6B00                       		bmi.s	.stack_done
00000130 6100                       		bsr.s	Error_DrawStackRow_First
00000132                            
00000132                            .stack_loop
00000132 4EBA 0000                  		jsr	Error_DrawStackRow(pc)
00000136 51CD FFFA                  		dbf	d5, .stack_loop
0000013A                            
0000013A                            .stack_done
0000013A 0806 0005                  		btst	#5,d6					; is execute console program (at the end) bit set?
0000013E 6600                       		bne.s	Error_RunConsoleProgram
00000140                            ; ---------------------------------------------------------------
00000140                            
00000140                            Error_IdleLoop:
00000140 60FE                       		bra.s	*
00000142                            ; ===============================================================
00000142                            ; ---------------------------------------------------------------
00000142                            ; Routine to enter console mode after writting error header
00000142                            ; ---------------------------------------------------------------
00000142                            
00000142                            Error_EnterConsoleProgram:
00000142 7200                       		moveq	#0,d1
00000144 4EBA 0000                  		jsr	Console_SetBasePattern(pc)
00000148                            
00000148                            Error_RunConsoleProgram:
00000148 2ECB                       		move.l	a3,(sp)+				; replace USP in stack with return address
0000014A 4CDF 7FFF                  		movem.l	(sp)+,d0-a6				; restore registers
0000014E 487A FFF0                  		pea	Error_IdleLoop(pc)			; set return address
00000152 2F2F FFC4                  		move.l	-$3C(sp),-(sp)				; retrieve "a3" saved earlier
00000156 4E75                       		rts						; jump to a3
00000158                            ; ---------------------------------------------------------------
00000158                            
00000158                            Error_InitConsole:	__global
00000158                          M __global__error_initconsole:
00000158                          M error_initconsole:
00000158 43FA 0000                  		lea	ErrorHandler_ConsoleConfig(pc),a1
0000015C 45FA 0000                  		lea	Art1bpp_Font(pc),a2
00000160 4EFA 0000                  		jmp	Console_Init(pc)			; d5 = On-screen position
00000164                            ; ===============================================================
00000164                            ; ---------------------------------------------------------------
00000164                            ; Subroutine to draw contents of stack row
00000164                            ; ---------------------------------------------------------------
00000164                            ; INPUT:
00000164                            ;		a0		String buffero
00000164                            ;		a1		Top of stack pointer
00000164                            ;		a2		Arguments (stack contents)
00000164                            ; ---------------------------------------------------------------
00000164                            
00000164                            Error_DrawStackRow_First:
00000164 4FEF FFD0                  		lea	-$30(sp),sp
00000168 41D7                       		lea	(sp),a0					; a0 = string buffer
0000016A 7EFF                       		moveq	#-1,d7					; size of the buffer for formatter functions (we assume buffer will never overflow)
0000016C                            
0000016C 20FC 2853 5029             		move.l	#'(SP)',(a0)+
00000172 30FC 3A20                  		move.w	#': ',(a0)+
00000176 6000                       		bra.s	Error_DrawStackRow_Continue
00000178                            ; ---------------------------------------------------------------
00000178                            
00000178                            Error_DrawStackRow:
00000178 4FEF FFD0                  		lea	-$30(sp),sp
0000017C 41D7                       		lea	(sp),a0					; a0 = string buffer
0000017E 7EFF                       		moveq	#-1,d7					; size of the buffer for formatter functions (we assume buffer will never overflow)
00000180                            
00000180 30FC 202B                  		move.w	#' +',(a0)+
00000184 320A                       		move.w	a2,d1
00000186 924C                       		sub.w	a4,d1					; d1 = stack displacement
00000188 4EBA 0000                  		jsr 	FormatHex_Byte(pc)
0000018C 30FC 3A20                  		move.w	#': ',(a0)+
00000190                            
00000190                            ; ---------------------------------------------------------------
00000190                            Error_DrawStackRow_Continue:
00000190 7005                       		moveq	#5,d0					; number of words to display
00000192                            
00000192                            .loop
00000192 7200                       		moveq	#$FFFFFF00|_pal2,d1			; use light blue
00000194 B4C9                       		cmp.w	a1,a2					; is current word out of stack?
00000196 6D00                       		blt.s	.0					; if not, branch
00000198 7200                       		moveq	#$FFFFFF00|_pal3,d1			; use dark blue
0000019A                            
0000019A                            .0
0000019A 10C1                       		move.b	d1,(a0)+				; setup color
0000019C 321A                       		move.w	(a2)+,d1
0000019E 4EBA 0000                  		jsr	FormatHex_Word(pc)
000001A2 10FC 0020                  		move.b	#' ',(a0)+
000001A6 51C8 FFEA                  		dbf 	d0,.loop
000001AA                            
000001AA 4218                       		clr.b	(a0)+					; finalize string
000001AC                            
000001AC                            		; Draw string on screen
000001AC 41D7                       		lea	(sp),a0
000001AE 7200                       		moveq	#0,d1
000001B0 4EBA 0000                  		jsr	Console_WriteLine_WithPattern(pc)
000001B4 4FEF 0030                  		lea	$30(sp),sp
000001B8 4E75                       		rts
000001BA                            ; ===============================================================
000001BA                            ; ---------------------------------------------------------------
000001BA                            ; Subroutine to draw series of registers
000001BA                            ; ---------------------------------------------------------------
000001BA                            ; INPUT:
000001BA                            ;		d0	.w	Name of the first register ('d0' or 'a0')
000001BA                            ;		d5	.w	Number of registers
000001BA                            ;		a2		Registers buffer
000001BA                            ; ---------------------------------------------------------------
000001BA                            
000001BA                            Error_DrawRegisters:
000001BA 4FEF FFF0                  		lea	-$10(sp),sp				; allocate string buffaro
000001BE 7EFF                       		moveq	#-1,d7					; size of the buffer for formatter functions (we assume buffer will never overflow)
000001C0                            
000001C0                            .regloop
000001C0 41D7                       		lea	(sp),a0					; use allocated stack space as string buffer
000001C2 30C0                       		move.w	d0,(a0)+				; put register name
000001C4 30FC 3A20                  		move.w	#': ',(a0)+				; put ": "
000001C8 10FC 0000                  		move.b	#_pal2,(a0)+				; put palette flag
000001CC 221A                       		move.l	(a2)+,d1
000001CE 4EBA 0000                  		jsr	FormatHex_LongWord(pc)			; put register contents
000001D2 4218                       		clr.b	(a0)+					; finalize string
000001D4                            
000001D4 41D7                       		lea	(sp),a0					; use allocated stack space as string buffer
000001D6 7200                       		moveq	#0,d1					; default pattern
000001D8 4EBA 0000                  		jsr	Console_WriteLine_WithPattern(pc)
000001DC 5240                       		addq.w	#1,d0					; next register name
000001DE 51CD FFE0                  		dbf	d5,.regloop
000001E2                            
000001E2 4FEF 0010                  		lea	$10(sp), sp
000001E6 4E75                       		rts
000001E8                            ; ===============================================================
000001E8                            ; ---------------------------------------------------------------
000001E8                            ; Subroutine to draw series of registers
000001E8                            ; ---------------------------------------------------------------
000001E8                            ; INPUT:
000001E8                            ;		d0	.l	Interrupt handler address
000001E8                            ;		a0		Handler name string
000001E8                            ; ---------------------------------------------------------------
000001E8                            
000001E8                            Error_DrawInterruptHandler:
000001E8 2200                       		move.l	d0,d1
000001EA 4841                       		swap	d1
000001EC 0C01 00E0                  		cmp.b	#$E0,d1				; AF::	; does handler address point to RAM (block $E0 to $FF)?
000001F0 6500                       		blo.s	.ret				; AF::	; if not, branch
000001F2                            
000001F2 514F                       		subq.w	#8,sp
000001F4 2E88                       		move.l	a0,(sp)					; Argument #0 : String pointer
000001F6 2440                       		movea.l	d0,a2					; a2 = handler routine
000001F8                            
000001F8 0806 0004                  		btst	#4,d6				; AF::	; check if instruction disassembly was requested
000001FC 6700                       		beq.s	.noins				; AF::	; if not, branch
000001FE                            ; ---------------------------------------------------------------
000001FE                            
000001FE 43FA 0000                  		lea	Str_IntHandler_Asm(pc),a1	; AF::	; disassemble instruction
00000202 2F4A 0004                  		move.l	a2,4(sp)			; AF::	; Argument #1 : address
00000206 6000                       		bra.s	.0				; AF::	; continue
00000208                            ; ---------------------------------------------------------------
00000208                            
00000208                            .noins
00000208 43FA 0000                  		lea	Str_IntHandler_Unknown(pc),a1
0000020C                            
0000020C 0C5A 4EF9                  		cmp.w	#$4EF9,(a2)+				; does routine include jmp (xxx).l opcode?
00000210 6600                       		bne.s	.0					; if not, process "Str_IntHandler_Unknown"
00000212 43FA 0000                  		lea	Str_IntHandler(pc),a1			; otherwise, process "Str_IntHandler"
00000216 2F52 0004                  		move.l	(a2),4(sp)				; Argument #1 : Jump offset
0000021A                            
0000021A                            .0
0000021A 45D7                       		lea	(sp),a2
0000021C 4EBA 0000                  		jsr	Console_Write_Formatted(pc)
00000220 504F                       		addq.w	#8,sp
00000222                            
00000222                            .ret
00000222 4E75                       		rts
00000224                            ; ---------------------------------------------------------------
00000224                            
00000224                            Str_IntHandler_Asm:
00000224 0000 0000                  	dc.b	_str, _asm|long, _newl, 0
00000228                            
00000228                            Str_IntHandler:
00000228 0000 0000 0000 00          	dc.b	_str, _pal0, _sym|long|split|forced, _pal2, _disp|weak, _newl, 0
0000022F                            
0000022F                            Str_IntHandler_Unknown:
0000022F 0000 3C75 6E64 6566 696E+  	dc.b	_str, _pal0, '<undefined>', _newl, 0
0000023E                            	even
0000023E                            ; ===============================================================
0000023E                            ; ---------------------------------------------------------------
0000023E                            ; Subroutine to guess caller by inspecting stack
0000023E                            ; ---------------------------------------------------------------
0000023E                            ; INPUT:
0000023E                            ;		a2				Bottom of stack (after stack frame)
0000023E                            ;
0000023E                            ; OUTPUT:
0000023E                            ;		d1		.l		Caller offset
0000023E                            ;
0000023E                            ; USES:
0000023E                            ;		a1-a2
0000023E                            ; ---------------------------------------------------------------
0000023E                            
0000023E                            Error_GuessCaller:
0000023E 3278 0002                  		movea.w	2.w,a1					; a1 = stack top boundary
00000242 5949                       		subq.w	#4,a1					; subtract a longword to set offset you should pass through
00000244 B2CA                       		cmpa.w	a2,a1
00000246 6500                       		blo.s	.nocaller
00000248                            
00000248                            .try_offset
00000248 0C52 0040                  		cmp.w	#$40,(a2)				; does this seem like an offset?
0000024C 6500                       		blo.s	.caller_found				; if yes, branch
0000024E 544A                       		addq.w	#2,a2					; try some next offsets
00000250 B2CA                       		cmpa.w	a2,a1
00000252 64F4                       		bhs.s	.try_offset
00000254                            
00000254                            .nocaller
00000254 7200                       		moveq	#0,d1
00000256 4E75                       		rts
00000258                            ; ---------------------------------------------------------------
00000258                            
00000258                            .caller_found
00000258 2212                       		move.l	(a2),d1
0000025A 4E75                       		rts
0000025C                            ; ===============================================================
0000025C                            ; ---------------------------------------------------------------
0000025C                            ; Subroutine to setup/reset VDP in order to display properly
0000025C                            ; ---------------------------------------------------------------
0000025C                            
0000025C                            ErrorHandler_SetupVDP:	__global
0000025C                          M __global__errorhandler_setupvdp:
0000025C                          M errorhandler_setupvdp:
0000025C 4BF9 00C0 0004             		lea 	VDP_Ctrl,a5 				; a5 = VDP_Ctrl
00000262 4DED FFFC                  		lea 	-4(a5),a6				; a6 = VDP_Data
00000266                            
00000266                            	; Make sure there is no pending writes to VDP
00000266 4A55                       		tst.w	(a5)
00000268                            
00000268                            	; Make sure there are no DMA's occuring, otherwise wait
00000268                            .wait_dma
00000268 44D5                       		move.w	(a5),ccr				; is DMA occuring?
0000026A 69FC                       		bvs.s	.wait_dma				; wait until it's finished
0000026C                            
0000026C                            	; Setup VDP registers for Error Handler screen
0000026C 41FA 0000                  		lea 	.VDPConfig(pc),a0
00000270                            
00000270                            .setup_regs
00000270 3018                       		move.w	(a0)+,d0
00000272 6A00                       		bpl.s	.done
00000274 3A80                       		move.w	d0,(a5)
00000276 60F8                       		bra.s	.setup_regs
00000278                            
00000278                            .done
00000278                            	; Remove all sprites, reset horizontal and vertical scrolling
00000278 7000                       		moveq	#0,d0
0000027A                            		vram	$0000,(a5)				; reset sprites and horizontal scrolling (HSRAM)
0000027A 2ABC 4000 0000           M 	move.l	#($40000000+(($0000&$3fff)<<16)+(($0000&$c000)>>14)),(a5)
00000280 2C80                       		move.l	d0,(a6)					; ''
00000282 2ABC 4000 0010             		move.l	#$40000010,(a5) 			; reset vertical scrolling
00000288 2C80                       		move.l	d0,(a6)					; ''
0000028A                            
0000028A                            	; Fill screen with black
0000028A                            		cram	$00,(a5)
0000028A 2ABC C000 0000           M 	move.l	#($c0000000+($00<<16)),(a5)
00000290 3C80                       		move.w	d0,(a6)
00000292 4E75                       		rts
00000294                            
00000294                            ; ---------------------------------------------------------------
00000294                            ; Error screen's VDP configuration
00000294                            ; ---------------------------------------------------------------
00000294                            
00000294                            .VDPConfig:
00000294 8004                       	dc.w $8004						; $00, disable HInts
00000296 8134                       	dc.w $8134						; $01, disable DISP
00000298 8220                       	dc.w $8200+VRAM_PlaneA/$400				; $02, set Plane A nametable offset in VRAM
0000029A 8404                       	dc.w $8400+VRAM_PlaneB/$2000 				; $04, set Plane B nametable offset in VRAM
0000029C 8500                       	dc.w $8500						; $05, set Sprites offset to $0000
0000029E 8700                       	dc.w $8700						; $07, set backdrop color
000002A0 8B00                       	dc.w $8B00						; $0B, set VScroll=full, HScroll=full
000002A2 8C81                       	dc.w $8C81						; $0C, use 320 pixels horizontal resolution
000002A4 8D00                       	dc.w $8D00						; $0D, set HScroll table offset to $0000
000002A6 8F02                       	dc.w $8F02						; $0F, set auto-increment to $02
000002A8 9011                       	dc.w $9011						; $10, use 512x512 plane resolution
000002AA 9100                       	dc.w $9100						; $11, reset Window X-position
000002AC 9200                       	dc.w $9200						; $12, reset Window Y-position
000002AE 0000                       	dc.w 0							; WARNING! Make sure the next word is positive!
000002B0                            ; ===============================================================
000002B0                            ; ---------------------------------------------------------------
000002B0                            ; Console loading programme for Error Handler
000002B0                            ; ---------------------------------------------------------------
000002B0                            
000002B0                            ErrorHandler_ConsoleConfig:
000002B0                            ; ---------------------------------------------------------------
000002B0                            ; Font decompression programme
000002B0                            ; ---------------------------------------------------------------
000002B0                            ; NOTICE: It's possible to generate several "samples" of font
000002B0                            ;	with different color indecies at different VRAM locations.
000002B0                            ;	However, this is not used for this Error Handler
000002B0                            ; ---------------------------------------------------------------
000002B0                            
000002B0                            	dcvram	VRAM_Font					; font offset in VRAM
000002B0 4400 0000                M 	dc.l	($40000000+((vram_font&$3fff)<<16)+((vram_font&$c000)>>14))
000002B4 0000 0001 0010 0011        	dc.w $0000, $0001, $0010, $0011				; decompression table for 1bpp nibbles
000002BC 0100 0101 0110 0111        	dc.w $0100, $0101, $0110, $0111				; ''
000002C4 1000 1001 1010 1011        	dc.w $1000, $1001, $1010, $1011				; ''
000002CC 1100 1101 1110 1111        	dc.w $1100, $1101, $1110, $1111				; ''
000002D4                            
000002D4                            	dcvram	VRAM_Font2					; font offset in VRAM
000002D4 6400 0000                M 	dc.l	($40000000+((vram_font2&$3fff)<<16)+((vram_font2&$c000)>>14))
000002D8 0000 0002 0020 0022        	dc.w $0000, $0002, $0020, $0022				; decompression table for 2bpp nibbles
000002E0 0200 0202 0220 0222        	dc.w $0200, $0202, $0220, $0222				; ''
000002E8 2000 2002 2020 2022        	dc.w $2000, $2002, $2020, $2022				; ''
000002F0 2200 2202 2220 2222        	dc.w $2200, $2202, $2220, $2222				; ''
000002F8 FFFF                       	dc.w -1							; end marker
000002FA                            
000002FA                            ; ---------------------------------------------------------------
000002FA                            ; Console RAM initial config
000002FA                            ; ---------------------------------------------------------------
000002FA                            
000002FA                            	dcvram	VRAM_PlaneA					; screen start address / plane nametable pointer
000002FA 4000 0002                M 	dc.l	($40000000+((vram_planea&$3fff)<<16)+((vram_planea&$c000)>>14))
000002FE 0028                       	dc.w 40							; number of characters per line
00000300 0028                       	dc.w 40							; number of charasters on the first line (meant to be the same as the above)
00000302 0000                       	dc.w 0							; base font pattern (tile id for ASCII $00 + palette flags)
00000304 0080                       	dc.w $80						; size of screen row (in bytes)
00000306 00FF                       	dc.w $2000/$20-1					; size of screen (in tiles - 1)
00000308                            
00000308                            ; ---------------------------------------------------------------
00000308                            ; CRAM data
00000308                            ; ---------------------------------------------------------------
00000308                            ; FORMAT:
00000308                            ;	dc.w	Color1, ..., ColorN, -X*2
00000308                            ;		X = Number of longs words to fill until line ends
00000308                            ;
00000308                            ; NOTICE: Transparent color at the beginning of a palette line is
00000308                            ;	auto-filled with $000 (black), hence Color1 is index #1, etc
00000308                            ;
00000308                            ; WARNING: Caution is required when calculating -X*2 as it's used
00000308                            ;	for a jump offset directly in Console_Init code.
00000308                            ;
00000308                            ; WARNING: Make sure size of colors you pass (+automatic
00000308                            ;	transparency color) and fill size sums to $20 bytes strictly!
00000308                            ;	-- You can only fill with 4 bytes precision!
00000308                            ;	-- Use dummy colors if neccessary.
00000308                            ; ---------------------------------------------------------------
00000308                            
00000308 0EEE 0EEE 0123 FFF4        	dc.w $0EEE, $0EEE, $0123, -6*2				; line 0: white text
00000310 00CE 04C2 0123 FFF4        	dc.w $00CE, $04C2, $0123, -6*2				; line 1: yellow & green text
00000318 0EEA 0ECA 0123 FFF4        	dc.w $0EEA, $0ECA, $0123, -6*2				; line 2: lighter blue & normal blue text
00000320 0E86 066E 0123 FFF4        	dc.w $0E86, $066E, $0123, -6*2				; line 3: darker blue & red text
00000328                            ; ---------------------------------------------------------------
00000328                            ; Error Handler interface data
00000328                            ; ---------------------------------------------------------------
00000328                            
00000328                            Str_SetErrorScreen:
00000328 0000 0001 0026 00          	dc.b	_pal1, _newl, _setx, 1, _setw, 38, 0
0000032F                            
0000032F                            Str_Address:
0000032F 0041 6464 7265 7373 3A20+  	dc.b	_pal1, 'Address: ', _pal0, _sym|long|split, _pal2, _disp, 0
0000033E                            
0000033E                            Str_Location:
0000033E 004C 6F63 6174 696F 6E3A+  	dc.b	_pal1, 'Location: ', _pal2, _hex|long, 0
0000034C                            
0000034C                            Str_Instruction:
0000034C 003E 2000 00               	dc.b	_pal0, '> ', _asm|long, 0
00000351                            
00000351                            Str_Module:
00000351 004D 6F64 756C 653A 2000+  	dc.b	_pal1, 'Module: ', _pal0, _sym|long|split|forced, _pal2, _disp|weak, 0
0000035F                            
0000035F                            Str_Caller:
0000035F 0043 616C 6C65 723A 2000+   	dc.b	_pal1, 'Caller: ', _pal0, _sym|long|split, _pal2, _disp, 0
0000036D                            
0000036D                            Str_USP:
0000036D 0010 0075 7370 3A20 0000+  	dc.b	_setx, $10, _pal0, 'usp: ', _pal2, _hex|long, 0
00000378                            
00000378                            Str_SR:
00000378 0003 0073 723A 2000 0000   	dc.b	_setx, $03, _pal0, 'sr: ', _pal2, _hex|word, 0
00000382                            
00000382                            Str_VInt:
00000382 0056 496E 743A 2000        	dc.b	_pal1, 'VInt: ', 0
0000038A                            
0000038A                            Str_HInt:
0000038A 0048 496E 743A 2000        	dc.b	_pal1, 'HInt: ', 0
00000392                            	even
00000392                            
00000392                            ; ---------------------------------------------------------------
00000392                            ; Error Handler 1bpp font graphics
00000392                            ; ---------------------------------------------------------------
00000392                            
00000392                            Art1bpp_Font:
00000392 0000                       	dc.w Art1bpp_Font_End-Art1bpp_Font-1			; font size - 1
00000394                            
00000394 0000 0000 0000 0000 183C+  	dc.l $00000000, $00000000, $183C3C18, $18001800, $6C6C6C00, $00000000, $6C6CFE6C, $FE6C6C00
000003B4 187E C07C 06FC 1800 00C6+  	dc.l $187EC07C, $06FC1800, $00C60C18, $3060C600, $386C3876, $CCCC7600, $18183000, $00000000
000003D4 1830 6060 6030 1800 6030+  	dc.l $18306060, $60301800, $60301818, $18306000, $00EE7CFE, $7CEE0000, $0018187E, $18180000
000003F4 0000 0000 1818 3000 0000+  	dc.l $00000000, $18183000, $000000FE, $00000000, $00000000, $00383800, $060C1830, $60C08000
00000414 7CC6 CEDE F6E6 7C00 1878+  	dc.l $7CC6CEDE, $F6E67C00, $18781818, $18187E00, $7CC60C18, $3066FE00, $7CC6063C, $06C67C00
00000434 0C1C 3C6C FE0C 0C00 FEC0+  	dc.l $0C1C3C6C, $FE0C0C00, $FEC0FC06, $06C67C00, $7CC6C0FC, $C6C67C00, $FEC6060C, $18181800
00000454 7CC6 C67C C6C6 7C00 7CC6+  	dc.l $7CC6C67C, $C6C67C00, $7CC6C67E, $06C67C00, $001C1C00, $001C1C00, $00181800, $00181830
00000474 0C18 3060 3018 0C00 0000+  	dc.l $0C183060, $30180C00, $0000FE00, $00FE0000, $6030180C, $18306000, $7CC6060C, $18001800
00000494 7CC6 C6DE DCC0 7E00 386C+  	dc.l $7CC6C6DE, $DCC07E00, $386CC6C6, $FEC6C600, $FC66667C, $6666FC00, $3C66C0C0, $C0663C00
000004B4 F86C 6666 666C F800 FEC2+  	dc.l $F86C6666, $666CF800, $FEC2C0F8, $C0C2FE00, $FE62607C, $6060F000, $7CC6C0C0, $DEC67C00
000004D4 C6C6 C6FE C6C6 C600 3C18+  	dc.l $C6C6C6FE, $C6C6C600, $3C181818, $18183C00, $3C181818, $D8D87000, $C6CCD8F0, $D8CCC600
000004F4 F060 6060 6062 FE00 C6EE+  	dc.l $F0606060, $6062FE00, $C6EEFED6, $D6C6C600, $C6E6E6F6, $DECEC600, $7CC6C6C6, $C6C67C00
00000514 FC66 667C 6060 F000 7CC6+  	dc.l $FC66667C, $6060F000, $7CC6C6C6, $C6D67C06, $FCC6C6FC, $D8CCC600, $7CC6C07C, $06C67C00
00000534 7E5A 1818 1818 3C00 C6C6+  	dc.l $7E5A1818, $18183C00, $C6C6C6C6, $C6C67C00, $C6C6C6C6, $6C381000, $C6C6D6D6, $FEEEC600
00000554 C66C 3838 386C C600 6666+  	dc.l $C66C3838, $386CC600, $6666663C, $18183C00, $FE860C18, $3062FE00, $7C606060, $60607C00
00000574 C060 3018 0C06 0200 7C0C+  	dc.l $C0603018, $0C060200, $7C0C0C0C, $0C0C7C00, $10386CC6, $00000000, $00000000, $000000FF
00000594 3030 1800 0000 0000 0000+  	dc.l $30301800, $00000000, $0000780C, $7CCC7E00, $E0607C66, $6666FC00, $00007CC6, $C0C67C00
000005B4 1C0C 7CCC CCCC 7E00 0000+  	dc.l $1C0C7CCC, $CCCC7E00, $00007CC6, $FEC07C00, $1C3630FC, $30307800, $000076CE, $C67E067C
000005D4 E060 7C66 6666 E600 1800+  	dc.l $E0607C66, $6666E600, $18003818, $18183C00, $0C001C0C, $0C0CCC78, $E060666C, $786CE600
000005F4 1818 1818 1818 1C00 0000+  	dc.l $18181818, $18181C00, $00006CFE, $D6D6C600, $0000DC66, $66666600, $00007CC6, $C6C67C00
00000614 0000 DC66 667C 60F0 0000+  	dc.l $0000DC66, $667C60F0, $000076CC, $CC7C0C1E, $0000DC66, $6060F000, $00007CC0, $7C067C00
00000634 3030 FC30 3036 1C00 0000+  	dc.l $3030FC30, $30361C00, $0000CCCC, $CCCC7600, $0000C6C6, $6C381000, $0000C6C6, $D6FE6C00
00000654 0000 C66C 386C C600 0000+  	dc.l $0000C66C, $386CC600, $0000C6C6, $CE76067C, $0000FC98, $3064FC00, $0E181870, $18180E00
00000674 1818 1800 1818 1800 7018+  	dc.l $18181800, $18181800, $7018180E, $18187000, $76DC0000, $00000000
0000068C                            Art1bpp_Font_End:
0000068C                            
0000068C                            ; ---------------------------------------------------------------
0000068C                            ; Core modules
0000068C                            ; ---------------------------------------------------------------
0000068C                            
0000068C                            	include	'Symbols.asm'
0000068C =0000DEB2                  _ValidHeader = $DEB2
0000068C                            
0000068C                            ; ===============================================================
0000068C                            ; ---------------------------------------------------------------
0000068C                            ; Subroutine to find nearest symbol for given offset
0000068C                            ; ---------------------------------------------------------------
0000068C                            ; INPUT:
0000068C                            ;		d1	.l		Offset
0000068C                            ;
0000068C                            ; OUTPUT:
0000068C                            ;		d0	.w		Status (0 = ok, -1 = error)
0000068C                            ;		d1	.l		Offset displacement
0000068C                            ;		a1			Pointer to compressed symbol text
0000068C                            ;
0000068C                            ; USES:
0000068C                            ;		a1-a3 / d0-d3
0000068C                            ; ---------------------------------------------------------------
0000068C                            
0000068C                            GetSymbolByOffset:
0000068C 43FA 0000                  		lea	SymbolData(pc), a1
00000690 0C59 DEB2                  		cmp.w	#_ValidHeader,(a1)+			; verify header
00000694 6600                       		bne.s	.return_error
00000696                            
00000696 70FE                       		moveq	#-2,d0
00000698 D059                       		add.w	(a1)+,d0				; d0 = (lastBlock+1)*4
0000069A 74FC                       		moveq	#-4,d2					; d2 will be 4-byte boundary mask
0000069C 7600                       		moveq	#0,d3					; d3 will be gain value
0000069E                            
0000069E 4841                       		swap	d1					; d1 = block
000006A0 0241 00FF                  		and.w	#$FF,d1					; fix block id: xx00...xxFF --> 0000..00FF
000006A4 D241                       		add.w	d1,d1					; d1 = block*2
000006A6 D241                       		add.w	d1,d1					; d1 = block*4
000006A8 B240                       		cmp.w	d0,d1					; is the offset's block within [0..lastBlock+1]?
000006AA 6200                       		bhi.s	.return_error				; if not, branch
000006AC 6700                       		beq.s	.load_prev_block			; if strictly lastBlock+1, fetch the previous one ...
000006AE                            
000006AE                            .load_block
000006AE 2031 1000                  		move.l	(a1,d1.w),d0 				; d0 = relative offset
000006B2 6700                       		beq.s	.load_prev_block			; if block is empty, branch
000006B4 47F1 0800                  		lea 	(a1,d0.l),a3				; a3 = Block structure
000006B8 4841                       		swap	d1					; d1 = offset
000006BA                            
000006BA 7000                       		moveq	#0,d0
000006BC 301B                       		move.w	(a3)+,d0				; d0 = symbols heap relative offset
000006BE B253                       		cmp.w	(a3),d1					; compare the requested offset with the lowest in the block
000006C0 6500                       		blo.s	.load_prev_block_2			; if even lower, find nearest offset in the previous block
000006C2                            
000006C2                            		; WARNING: The following instruction assumes blocks will not be reloaded anymore
000006C2 43F3 08FE                  		lea	-2(a3,d0.l),a1				; a1 = symbols heap
000006C6                            								; d0 = (high - low)
000006C6 45E9 FFFC                  		lea 	-4(a1),a2 				; a2 = high
000006CA                            								; a3 = low
000006CA                            .search_loop
000006CA E248                       		lsr.w	#1,d0				; 8	; d0 = (high - low) / 2
000006CC C042                       		and.w	d2,d0				; 4	; find nearest 4-byte struct for the displacement
000006CE                            
000006CE B273 0000                  		cmp.w	(a3,d0.w),d1			; 14	; compare the requested offset with the guessed entry
000006D2 6500                       		blo.s	.search_lower_half		; 8/10
000006D4 6200                       		bhi.s	.search_higher_half		; 8/10
000006D6                            
000006D6 D6C0                       		adda.w	d0,a3
000006D8 6000                       		bra.s	.load_symbol
000006DA                            ; -----------------------------------------------------------
000006DA                            
000006DA                            .search_higher_half
000006DA 47F3 0004                  		lea 	4(a3,d0.w),a3			; 12	; limit "low" to "middle"+1 of previously observed area
000006DE 200A                       		move.l	a2,d0				; 4
000006E0 908B                       		sub.l	a3,d0				; 8	; d0 = (high - low)
000006E2 6AE6                       		bpl.s	.search_loop			; 8/10	; if (low >= high), branch
000006E4                            
000006E4 594B                       		subq.w	#4,a3
000006E6 6000                       		bra.s	.load_symbol
000006E8                            ; -----------------------------------------------------------
000006E8                            
000006E8                            .search_lower_half
000006E8 45F3 00FC                  		lea 	-4(a3,d0.w),a2			; 12	; limit "high" to "middle"-1 of previously observed area
000006EC 200A                       		move.l	a2,d0				; 4	;
000006EE 908B                       		sub.l	a3,d0				; 8	; d0 = (high - low)
000006F0 6AD8                       		bpl.s	.search_loop			; 8/10	; if (low >= high), branch
000006F2                            
000006F2 47D2                       		lea	(a2),a3
000006F4                            
000006F4                            .load_symbol
000006F4 925B                       		sub.w	(a3)+,d1				; d1 = displacement
000006F6 7400                       		moveq	#0,d2
000006F8 341B                       		move.w	(a3)+,d2				; d2 = symbol pointer, relative to the heap
000006FA D3C2                       		adda.l	d2,a1
000006FC                            
000006FC 4841                       		swap	d1					; ''
000006FE                            	; NOTICE: You should be able to access SymbolData+4(pc,d1.w) now ...
000006FE 4241                       		clr.w	d1					; ''
00000700 4841                       		swap	d1					; andi.l #$FFFF, d1
00000702 D283                       		add.l	d3,d1
00000704 7000                       		moveq	#0,d0					; return success
00000706 4E75                       		rts
00000708                            ; ---------------------------------------------------------------
00000708                            
00000708                            .return_error
00000708 70FF                       		moveq	#-1, d0					; return -1
0000070A 4E75                       		rts
0000070C                            ; ---------------------------------------------------------------
0000070C                            
0000070C                            .load_prev_block
0000070C 4841                       		swap	d1
0000070E                            
0000070E                            .load_prev_block_2
0000070E 7000                       		moveq	#0,d0
00000710 3001                       		move.w	d1,d0
00000712 D680                       		add.l	d0,d3					; increase offset gain by the offset within the previous block
00000714 5283                       		addq.l	#1,d3					; also increase offset gain by 1 to compensate for ...
00000716 323C FFFF                  		move.w	#$FFFF,d1				; ... setting offset to $FFFF instead of $10000
0000071A 4841                       		swap	d1
0000071C 5941                       		subq.w	#4,d1					; decrease block number
0000071E 6A8E                       		bpl.s	.load_block				; if block is positive, branch
00000720 70FF                       		moveq	#-1,d0					; return -1
00000722 4E75                       		rts
00000724                            ; ===============================================================
00000724                            ; ---------------------------------------------------------------
00000724                            ; Subroutine to decode compressed symbol name to string buffer
00000724                            ; ---------------------------------------------------------------
00000724                            ; INPUT:
00000724                            ;		a0			String buffer pointer
00000724                            ;		a1			Pointer to the compressed symbol data
00000724                            ;		a6			VPD Data Port
00000724                            ;		d5	.w		Base pattern
00000724                            ;
00000724                            ; OUTPUT:
00000724                            ;		(a0)++	ASCII characters upon conversion
00000724                            ;
00000724                            ; USES:
00000724                            ;		a2-a3, d1-d4
00000724                            ; ---------------------------------------------------------------
00000724                            
00000724                            DecodeSymbol:
00000724 47FA 0000                  		lea	SymbolData(pc),a3
00000728 0C5B DEB2                  		cmp.w	#_ValidHeader,(a3)+			; verify the header
0000072C 6600                       		bne.s	.return_cc
0000072E D6D3                       		add.w	(a3),a3					; a3 = Huffman code table
00000730 7800                       		moveq	#0,d4					; d4 will handle byte feeding from bitstream
00000732                            ; ---------------------------------------------------------------
00000732                            
00000732                            .decode_new_node
00000732 7200                       		moveq	#0,d1					; d1 will hold code
00000734 7400                       		moveq	#0,d2					; d2 will hold code length (in bits)
00000736 45D3                       		lea	(a3),a2					; a2 will hold current position in the decode table
00000738                            ; ---------------------------------------------------------------
00000738                            
00000738                            .code_extend
00000738 51CC 0000                  		dbf 	d4,.stream_ok				; if bits remain in byte, branch
0000073C 1619                       		move.b	(a1)+,d3
0000073E 7807                       		moveq	#7,d4
00000740                            
00000740                            .stream_ok
00000740 D603                       		add.b	d3,d3					; get a bit from the bitstream ...
00000742 D341                       		addx.w	d1,d1					; ... add it to current code
00000744 5242                       		addq.w	#1,d2					; count this bit
00000746                            
00000746                            .code_check_loop
00000746 B252                       		cmp.w	(a2),d1 				; does this node has the same code?
00000748 6200                       		bhi.s	.code_check_next			; if not, check next
0000074A 65EC                       		blo.s	.code_extend				; if no nodes are found, branch
0000074C B42A 0002                  		cmp.b	2(a2),d2				; is this code of the same length?
00000750 6700                       		beq.s	.code_found 				; if not, branch
00000752 65E4                       		blo.s	.code_extend				; if length is lower, append code
00000754                            
00000754                            .code_check_next
00000754 584A                       		addq.w	#4,a2
00000756 B252                       		cmp.w	(a2),d1 				; does this node has the same code?
00000758 62FA                       		bhi.s	.code_check_next			; if not, check next
0000075A 65DC                       		blo.s	.code_extend				; if no nodes are found, branch
0000075C B42A 0002                  		cmp.b	2(a2),d2				; is this code of the same length?
00000760 65D6                       		blo.s	.code_extend				; if length is lower, append code
00000762 66F0                       		bne.s	.code_check_next
00000764                            
00000764                            .code_found
00000764 10EA 0003                  		move.b	3(a2),(a0)+				; get decoded character
00000768 6700                       		beq.s	.decode_done				; if it's null character, branch
0000076A                            
0000076A 51CF FFC6                  		dbf	d7,.decode_new_node
0000076E 4E94                       		jsr	(a4)
00000770 64C0                       		bcc.s	.decode_new_node
00000772 4E75                       		rts
00000774                            ; ---------------------------------------------------------------
00000774                            
00000774                            .decode_done
00000774 5348                       		subq.w	#1,a0					; put the last character back
00000776 4E75                       		rts
00000778                            ; ---------------------------------------------------------------
00000778                            
00000778                            .return_cc							; return with Carry clear (cc)
00000778 7000                       		moveq	#0,d0
0000077A 4E75                       		rts
0000077C                            	include	'Formatter - Hex.asm'
0000077C                            ; ===============================================================
0000077C                            ; ---------------------------------------------------------------
0000077C                            ; Error handling and debugging modules
0000077C                            ; 2016-2017, Vladikcomper
0000077C                            ; ---------------------------------------------------------------
0000077C                            ; String formatters : Hexidecimal number
0000077C                            ; ---------------------------------------------------------------
0000077C                            ; INPUT:
0000077C                            ;		d1		Value
0000077C                            ;
0000077C                            ; OUTPUT:
0000077C                            ;		(a0)++	ASCII characters upon conversion
0000077C                            ;
0000077C                            ; WARNING!
0000077C                            ;	1) Formatters can only use registers a3 / d0-d4
0000077C                            ;	2) Formatters should decrement d7 after each symbol write,
0000077C                            ;		return Carry flag from the last decrement;
0000077C                            ;		stop if carry is set (means buffer is full)
0000077C                            ; ---------------------------------------------------------------
0000077C                            
0000077C                            FormatHex_Handlers:
0000077C 4EFA 0000                  		jmp		FormatHex_Word(pc)		; $00		; handler for word
00000780 4EFA 0000                  		jmp		FormatHex_LongWord(pc)		; $04		; handler for longword
00000784                            	;	jmp		FormatHex_Byte(pc)		; $08		; handler for byte
00000784                            
00000784                            FormatHex_Byte:
00000784 760F                       		moveq	#$F,d3
00000786 3401                       		move.w	d1,d2
00000788 E84A                       		lsr.w	#4,d2
0000078A C443                       		and.w	d3,d2
0000078C 10FB 2000                  		move.b	HexDigitToChar(pc,d2.w),(a0)+
00000790                            
00000790 51CF 0000                  		dbf	d7,.buffer_ok
00000794 4E94                       		jsr	(a4)
00000796 6500                       		bcs.s	FormatHex_Return
00000798                            .buffer_ok
00000798                            
00000798 C243                       		and.w	d3,d1
0000079A 10FB 1000                  		move.b	HexDigitToChar(pc,d1.w),(a0)+
0000079E 51CF 0000                  		dbf	d7,FormatHex_Return
000007A2 4ED4                       		jmp	(a4)					; call buffer flush function and return buffer status
000007A4                            
000007A4                            ; ---------------------------------------------------------------
000007A4                            FormatHex_LongWord:
000007A4 4841                       		swap	d1
000007A6 6100                       		bsr.s	FormatHex_Word
000007A8 6500                       		bcs.s	FormatHex_Return			; if buffer terminated, branch
000007AA                            
000007AA                            FormatHex_Word_Swap:
000007AA 4841                       		swap	d1
000007AC                            ; ---------------------------------------------------------------
000007AC                            
000007AC                            FormatHex_Word:
000007AC 7404                       		moveq	#4,d2
000007AE 760F                       		moveq	#$F,d3
000007B0                            
000007B0                            	rept 4-1
000007B0                            		rol.w	d2,d1
000007B0                            		move.b	d1,d4
000007B0                            		and.w	d3,d4					; get digit
000007B0                            		move.b	HexDigitToChar(pc,d4.w),(a0)+
000007B0                            		dbf	d7,*+6
000007B0                            		jsr	(a4)					; call buffer flush function
000007B0                            		bcs.s	FormatHex_Return			; if buffer terminated, branch
000007B0                            	endr
000007B0 E579                     M 	rol.w	d2,d1
000007B2 1801                     M 	move.b	d1,d4
000007B4 C843                     M 	and.w	d3,d4
000007B6 10FB 4000                M 	move.b	hexdigittochar(pc,d4.w),(a0)+
000007BA 51CF 0004                M 	dbf	d7,*+6
000007BE 4E94                     M 	jsr	(a4)
000007C0 6500                     M 	bcs.s	formathex_return
000007C2 E579                     M 	rol.w	d2,d1
000007C4 1801                     M 	move.b	d1,d4
000007C6 C843                     M 	and.w	d3,d4
000007C8 10FB 4000                M 	move.b	hexdigittochar(pc,d4.w),(a0)+
000007CC 51CF 0004                M 	dbf	d7,*+6
000007D0 4E94                     M 	jsr	(a4)
000007D2 6500                     M 	bcs.s	formathex_return
000007D4 E579                     M 	rol.w	d2,d1
000007D6 1801                     M 	move.b	d1,d4
000007D8 C843                     M 	and.w	d3,d4
000007DA 10FB 4000                M 	move.b	hexdigittochar(pc,d4.w),(a0)+
000007DE 51CF 0004                M 	dbf	d7,*+6
000007E2 4E94                     M 	jsr	(a4)
000007E4 6500                     M 	bcs.s	formathex_return
000007E6                            
000007E6 E579                       		rol.w	d2,d1
000007E8 1801                       		move.b	d1,d4
000007EA C843                       		and.w	d3,d4					; get digit
000007EC 10FB 4000                  		move.b	HexDigitToChar(pc,d4.w),(a0)+
000007F0 51CF 0000                  		dbf	d7, FormatHex_Return
000007F4 4ED4                       		jmp	(a4)					; call buffer flush function and return buffer status
000007F6                            
000007F6                            FormatHex_Return:
000007F6 4E75                       		rts						; return buffer status
000007F8                            
000007F8                            ; ---------------------------------------------------------------
000007F8                            HexDigitToChar:
000007F8 3031 3233 3435 3637 3839+  	dc.b	'0123456789ABCDEF'
00000808                            	include	'Formatter - Bin.asm'
00000808                            
00000808                            ; ===============================================================
00000808                            ; ---------------------------------------------------------------
00000808                            ; Error handling and debugging modules
00000808                            ; 2016-2017, Vladikcomper
00000808                            ; ---------------------------------------------------------------
00000808                            ; String formatters : Binary number
00000808                            ; ---------------------------------------------------------------
00000808                            ; INPUT:
00000808                            ;		d1		Value
00000808                            ;
00000808                            ; OUTPUT:
00000808                            ;		(a0)++	ASCII characters upon conversion
00000808                            ;
00000808                            ; WARNING!
00000808                            ;	1) Formatters can only use registers a3 / d0-d4
00000808                            ;	2) Formatters should decrement d7 after each symbol write,
00000808                            ;		return Carry flag from the last decrement;
00000808                            ;		stop if carry is set (means buffer is full)
00000808                            ; ---------------------------------------------------------------
00000808                            
00000808                            FormatBin_Handlers:
00000808 4EFA 0000                  		jmp 	FormatBin_Word(pc)	 		; $00	Word display handler
0000080C 4EFA 0000                  		jmp 	FormatBin_LongWord(pc) 			; $04	Longword display handler
00000810                            ;		jmp	FormatBin_Byte(pc)			; $08	Byte display handler
00000810                            ; ---------------------------------------------------------------
00000810                            
00000810                            FormatBin_Byte:
00000810 7407                       		moveq	#8-1,d2
00000812                            
00000812                            .loop
00000812 7018                       		moveq	#'0'/2,d0
00000814 D201                       		add.b	d1,d1
00000816 D100                       		addx.b	d0,d0
00000818 10C0                       		move.b	d0,(a0)+
0000081A                            
0000081A 51CF 0000                  		dbf	d7,.buffer_ok
0000081E 4E94                       		jsr	(a4)
00000820 6500                       		bcs.s	.quit
00000822                            .buffer_ok
00000822                            
00000822 51CA FFEE                  		dbf	d2,.loop
00000826                            
00000826                            .quit
00000826 4E75                       		rts
00000828                            ; ---------------------------------------------------------------
00000828                            
00000828                            FormatBin_LongWord:
00000828 4841                       		swap	d1
0000082A 6100                       		bsr.s	FormatBin_Word
0000082C 6500                       		bcs.s	FormatBin_Return
0000082E 4841                       		swap	d1
00000830                            
00000830                            FormatBin_Word:
00000830 740F                       		moveq	#16-1,d2
00000832                            
00000832                            .loop
00000832 7018                       		moveq	#'0'/2,d0
00000834 D241                       		add.w	d1,d1
00000836 D100                       		addx.b	d0,d0
00000838 10C0                       		move.b	d0,(a0)+
0000083A                            
0000083A 51CF 0000                  		dbf	d7,.buffer_ok
0000083E 4E94                       		jsr	(a4)
00000840 6500                       		bcs.s	FormatBin_Return
00000842                            .buffer_ok
00000842                            
00000842 51CA FFEE                  		dbf	d2,.loop
00000846                            
00000846                            FormatBin_Return:
00000846 4E75                       		rts
00000848                            	include	'Formatter - Dec.asm'
00000848                            ; ===============================================================
00000848                            ; ---------------------------------------------------------------
00000848                            ; Error handling and debugging modules
00000848                            ; 2016-2017, Vladikcomper
00000848                            ; ---------------------------------------------------------------
00000848                            ; String formatters : Decimal number
00000848                            ; ---------------------------------------------------------------
00000848                            ; INPUT:
00000848                            ;		d1		Value
00000848                            ;
00000848                            ; OUTPUT:
00000848                            ;		(a0)++	ASCII characters upon conversion
00000848                            ;
00000848                            ; WARNING!
00000848                            ;	1) Formatters can only use registers a3 / d0-d4
00000848                            ;	2) Formatters should decrement d7 after each symbol write,
00000848                            ;		return Carry flag from the last decrement;
00000848                            ;		stop if carry is set (means buffer is full)
00000848                            ; ---------------------------------------------------------------
00000848                            
00000848                            FormatDec_Handlers:
00000848 4EFA 0000                  		jmp 	FormatDec_Word(pc)	 		; $00	Word display handler
0000084C 4EFA 0000                  		jmp 	FormatDec_LongWord(pc) 			; $04	Longword display handler
00000850                            
00000850 47FA 0000                  		lea 	DecimalBase_Byte(pc),a3			; $08	Byte display handler
00000854 0241 00FF                  		andi.w	#$FF,d1					; ...
00000858 6000                       		bra.s 	FormatDec			 	; ...
0000085A                            ; ---------------------------------------------------------------
0000085A                            
0000085A                            FormatDec_Word:
0000085A 47FA 0000                  		lea 	DecimalBase_Word(pc),a3
0000085E                            
0000085E                            FormatDec:
0000085E 4200                       		clr.b	d0					; d0 will be trim zeros switcher
00000860 7609                       		moveq	#9,d3					; d3 will be DBcc iterator base
00000862 381B                       		move.w	(a3)+,d4				; d4 = decimal base
00000864                            
00000864                            FormatDec_Cont:
00000864                            .ProcessDigit
00000864 3403                       		move.w	d3,d2
00000866                            
00000866                            .FindDigit
00000866 9244                       		sub.w	d4,d1
00000868 55CA FFFC                  		dbcs	d2,.FindDigit
0000086C                            
0000086C D244                       		add.w	d4,d1					; restore digit
0000086E 9443                       		sub.w	d3,d2
00000870 4442                       		neg.w	d2					; d2 = digit
00000872 8002                       		or.b	d2,d0					; have we met non-zero digit yet?
00000874 6700                       		beq.s	.NextDigit				; if not, branch
00000876 0602 0030                  		add.b	#'0',d2
0000087A 10C2                       		move.b	d2,(a0)+
0000087C                            
0000087C 51CF 0000                  		dbf	d7,.NextDigit
00000880 4E94                       		jsr	(a4)
00000882 6500                       		bcs.s	FormatDec_Return
00000884                            
00000884                            .NextDigit
00000884 381B                       		move.w	(a3)+,d4
00000886 6ADC                       		bpl.s	.ProcessDigit
00000888                            
00000888                            	; The last digit is done manually
00000888 0601 0030                  		add.b	#'0',d1
0000088C 10C1                       		move.b	d1,(a0)+
0000088E 51CF 0000                  		dbf	d7,FormatDec_Return
00000892 4ED4                       		jmp	(a4)
00000894                            
00000894                            FormatDec_Return:
00000894 4E75                       		rts
00000896                            ; ---------------------------------------------------------------
00000896                            
00000896                            FormatDec_LongWord:
00000896 47FA 0000                  		lea 	DecimalBase_Long(pc),a3
0000089A 4200                       		clr.b	d0					; d0 will be trim zeros switcher
0000089C 7609                       		moveq	#9,d3					; d3 will be DBcc iterator base
0000089E 281B                       		move.l	(a3)+,d4				; d4 = decimal base
000008A0                            
000008A0                            .ProcessDigit
000008A0 3403                       		move.w	d3,d2
000008A2                            
000008A2                            .FindDigit
000008A2 9284                       		sub.l	d4,d1
000008A4 55CA FFFC                  		dbcs	d2,.FindDigit
000008A8                            
000008A8 D284                       		add.l	d4,d1					; restore digit
000008AA 9443                       		sub.w	d3,d2
000008AC 4442                       		neg.w	d2					; d2 = digit
000008AE 8002                       		or.b	d2,d0					; have we met non-zero digit yet?
000008B0 6700                       		beq.s	.NextDigit				; if not, branch
000008B2 0602 0030                  		add.b	#'0',d2
000008B6 10C2                       		move.b	d2,(a0)+
000008B8                            
000008B8 51CF 0000                  		dbf	d7,.NextDigit
000008BC 4E94                       		jsr	(a4)
000008BE 65D4                       		bcs.s	FormatDec_Return
000008C0                            
000008C0                            .NextDigit
000008C0 281B                       		move.l	(a3)+,d4				; load next decimal base
000008C2 6ADC                       		bpl.s	.ProcessDigit				; if base is positive, branch
000008C4                            								; otherwise, base is word-sized ...
000008C4 609E                       		bra.s	FormatDec_Cont				; continue drawing with word-sized version
000008C6                            								; note that lower word of D4 already contains next decimal base ...
000008C6                            ; ---------------------------------------------------------------
000008C6                            
000008C6                            DecimalBase_Long:
000008C6 3B9A CA00                  	dc.l	1000000000
000008CA 05F5 E100                  	dc.l	100000000
000008CE 0098 9680                  	dc.l	10000000
000008D2 000F 4240                  	dc.l	1000000
000008D6 0001 86A0                  	dc.l	100000
000008DA 0000 2710                  	dc.l	10000
000008DE FFFF                       	dc.w	-1						; marks switching between 'long' and 'word' modes
000008E0 03E8                       	dc.w	1000
000008E2 0064                       	dc.w	100
000008E4 000A                       	dc.w	10
000008E6 FFFF                       	dc.w	-1						; marks end of digit searching
000008E8                            
000008E8                            ; ---------------------------------------------------------------
000008E8                            DecimalBase_Word:
000008E8 2710                       	dc.w	10000
000008EA 03E8                       	dc.w	1000
000008EC                            
000008EC                            DecimalBase_Byte:
000008EC 0064                       	dc.w	100
000008EE 000A                       	dc.w	10
000008F0 FFFF                       	dc.w	-1						; marks end of digit searching
000008F2                            	include	'Formatter - Sym.asm'
000008F2                            ; ===============================================================
000008F2                            ; ---------------------------------------------------------------
000008F2                            ; Error handling and debugging modules
000008F2                            ; 2016-2017, Vladikcomper
000008F2                            ; ---------------------------------------------------------------
000008F2                            ; String formatters : Symbols
000008F2                            ; ---------------------------------------------------------------
000008F2                            ; INPUT:
000008F2                            ;		d1		Value
000008F2                            ;
000008F2                            ; OUTPUT:
000008F2                            ;		(a0)++	ASCII characters upon conversion
000008F2                            ;
000008F2                            ; WARNING!
000008F2                            ;	1) Formatters can only use registers a3 / d0-d4
000008F2                            ;	2) Formatters should decrement d7 after each symbol write,
000008F2                            ;		return Carry flag from the last decrement;
000008F2                            ;		stop if carry is set (means buffer is full)
000008F2                            ; ---------------------------------------------------------------
000008F2                            
000008F2                            FormatSym_Handlers:
000008F2 48C1                       		ext.l	d1				; $00	; handler for word
000008F4 6000                       		bra.s	FormatSym			; $02
000008F6                            
000008F6 4EFA 0000                  		jmp	FormatSym(pc)			; $04	; handler for longword
000008FA                            
000008FA 4881                       		ext.w	d1				; $08	; handler for byte
000008FC 48C1                       		ext.l	d1
000008FE                            ; ---------------------------------------------------------------
000008FE                            
000008FE                            FormatSym:
000008FE 0803 0003                  		btst	#3,d3					; is "display just label part so far" bit set?
00000902 6600                       		bne.s	.0					; if yes, branch
00000904 487A 0000                  		pea	FormatString_CodeHandlers+$40(pc)	; otherwise, display displacement after this routine is finished
00000908                            
00000908                            .0
00000908 48E7 5060                  		movem.l	d1/d3/a1-a2,-(sp)
0000090C 4EBA FD7E                  		jsr	GetSymbolByOffset(pc)			; IN:	d1 = offset
00000910 6600                       		bne.s	FormatSym_UnknownSymbol			; OUT:	d0/Z = error status, d1 = displacement, a1 = symbol pointer
00000912 2E81                       		move.l	d1,(sp)					; replace offset stored in stack as D1 with displacement
00000914 4EBA FE0E                  		jsr	DecodeSymbol(pc)			; IN:	a1 = symbol pointer
00000918 4CDF 060A                  		movem.l	(sp)+,d1/d3/a1-a2			; NOTICE: This doesn't affect CCR, so this routine still returns Carry
0000091C                            
0000091C                            FormatSym_Return:
0000091C 4E75                       		rts
0000091E                            ; ---------------------------------------------------------------
0000091E                            
0000091E                            FormatSym_UnknownSymbol:
0000091E 4CDF 060A                  		movem.l	(sp)+,d1/d3/a1-a2
00000922 0803 0002                  	  	btst	#2,d3					; is "draw <unknown> on error" bit set?
00000926 6700                       		beq.s	FormatSym_ReturnNC			; if not, branch
00000928 47FA 0000                  		lea	FormatSym_Str_Unknown(pc),a3
0000092C 4EFA 0000                  		jmp	FormatString_CodeHandlers+$A8(pc)	; jump to code D0 (string) handler, but skip instruction that sets A3
00000930                            ; ---------------------------------------------------------------
00000930                            
00000930                            FormatSym_ReturnNC:
00000930 70FF                       		moveq	#-1,d0					; reset Carry, keep D0 an error code
00000932 4E75                       		rts
00000934                            ; ---------------------------------------------------------------
00000934                            
00000934                            FormatSym_Str_Unknown:
00000934 3C75 6E6B 6E6F 776E 3E00   		dc.b	'<unknown>',0
0000093E                            
0000093E                            ; ===============================================================
0000093E                            ; ---------------------------------------------------------------
0000093E                            ; INPUT:
0000093E                            ;		d1	.l	Displacement
0000093E                            ; ---------------------------------------------------------------
0000093E                            
0000093E                            FormatSym_Displacement:
0000093E 10FC 002B                  		move.b	#'+',(a0)+
00000942 51CF 0000                  		dbf	d7,.buffer_ok
00000946 4E94                       		jsr	(a4)
00000948 65D2                       		bcs.s	FormatSym_Return
0000094A                            
0000094A                            .buffer_ok
0000094A 4841                       		swap	d1
0000094C 4A41                       		tst.w	d1
0000094E 6700 FE5A                  		beq	FormatHex_Word_Swap
00000952 4EBA FE58                  		jsr	FormatHex_Word(pc)
00000956 4EFA FE52                  		jmp	FormatHex_Word_Swap(pc)
0000095A                            
0000095A                            ; ---------------------------------------------------------------
0000095A                            ; INPUT:
0000095A                            ;		d1	.l	Offset
0000095A                            ;		d3	.b	Control byte
0000095A                            ; ---------------------------------------------------------------
0000095A                            
0000095A                            FormatSym_Offset:
0000095A 0803 0003                  		btst	#3,d3					; is "don't draw offset" flag set?
0000095E 66BC                       		bne.s	FormatSym_Return			; WARNING: Should return NC
00000960 4EFA FE42                  		jmp	FormatHex_LongWord(pc)
00000964                            
00000964                            	include	'Formatter - Asm.asm'
00000964                            ; ===============================================================
00000964                            ; ---------------------------------------------------------------
00000964                            ; Error handling and debugging modules
00000964                            ; 2020, AURORA FIELDS
00000964                            ; ---------------------------------------------------------------
00000964                            ; String formatters : Symbols
00000964                            ; ---------------------------------------------------------------
00000964                            ; INPUT:
00000964                            ;		d1		Value
00000964                            ;
00000964                            ; OUTPUT:
00000964                            ;		(a0)++	ASCII characters upon conversion
00000964                            ;
00000964                            ; WARNING!
00000964                            ;	1) Formatters can only use registers a3 / d0-d4
00000964                            ;	2) Formatters should decrement d7 after each symbol write,
00000964                            ;		return Carry flag from the last decrement;
00000964                            ;		stop if carry is set (means buffer is full)
00000964                            ; ---------------------------------------------------------------
00000964                            
00000964                            d68k_Store			reg d5/d6/a0-a2/a4/a6		; stored registers for decoder
00000964 =0000001C                  d68k_StoreSz =			4*7				; size of decoder stored registers
00000964                            ; ---------------------------------------------------------------
00000964                            
00000964                            FormatAsm_Handlers:
00000964 48C1                       		ext.l	d1				; $00	; handler for word
00000966 6000                       		bra.s	FormatAsm			; $02
00000968                            
00000968 4EFA 0000                  		jmp	FormatAsm(pc)			; $04	; handler for longword
0000096C                            
0000096C 4881                       		ext.w	d1				; $08	; handler for byte
0000096E 48C1                       		ext.l	d1
00000970                            ; ---------------------------------------------------------------
00000970                            
00000970                            FormatAsm:
00000970 48F9 5760 0000 0000        		movem.l	d68k_Store,d68k_StoreRegs		; push variables into temporary storage
00000978 2241                       		move.l	d1,a1					; copy instruction address to a1
0000097A 41F9 0000 0000             		lea	d68k_String,a0				; load destination address to a0
00000980 4EBA 0000                  		jsr	Decode68k(pc)				; decode instruction
00000984                            
00000984 2808                       		move.l	a0,d4					; copy end pointer to d4
00000986 4CF9 5760 0000 0000        		movem.l	d68k_StoreRegs,d68k_Store		; pop variables from temporary storage
0000098E                            ; ---------------------------------------------------------------
0000098E                            
0000098E                            	; flush
0000098E 0444 0000                  		sub.w	#(d68k_String+2)&$FFFF,d4		; subtract the start position from end
00000992 47F9 0000 0000             		lea	d68k_String,a3				; load string data to a3
00000998                            ; ---------------------------------------------------------------
00000998                            
00000998                            .copy
00000998 4A47                       		tst.w	d7					; SPECIAL CASE
0000099A 6600                       		bne.s	.not0					; branch if not special case
0000099C 0C13 0000                  		cmp.b	#_setpat,(a3)				; check if the last byte of buffer is _setpat command
000009A0 6600                       		bne.s	.not0					; branch if not
000009A2                            
000009A2 5244                       		addq.w	#1,d4					; add 1 to counter
000009A4 6000                       		bra.s	.flush					; flush NOW
000009A6                            ; ---------------------------------------------------------------
000009A6                            
000009A6                            .not0
000009A6 10DB                       		move.b	(a3)+,(a0)+				; copy a byte into buffer
000009A8 51CF 0000                  		dbf	d7,.loop				; check if buffer is full, but if not, branch
000009AC                            
000009AC                            .flush
000009AC 4E94                       		jsr	(a4)					; run flush function
000009AE 6500                       		bcs.s	.end					; do something if something
000009B0                            
000009B0                            .loop
000009B0 51CC FFE6                  		dbf	d4,.copy				; run the next copy operation
000009B4                            
000009B4                            .end
000009B4 4E75                       		rts
000009B6                            ; ---------------------------------------------------------------
000009B6                            	include	'Format String.asm'
000009B6                            
000009B6                            ; ===============================================================
000009B6                            ; ---------------------------------------------------------------
000009B6                            ; Error handling and debugging modules
000009B6                            ; 2016-2017, Vladikcomper
000009B6                            ; ---------------------------------------------------------------
000009B6                            ; String formatter module
000009B6                            ; ---------------------------------------------------------------
000009B6                            ; INPUT:
000009B6                            ;		a0		Pointer to a string buffer
000009B6                            ;		a1		Pointer to format sequence
000009B6                            ;		a2		Pointer to arguments list
000009B6                            ;		a4		Buffer flush function
000009B6                            ;		d7	.w	Number of characters before buffer flush
000009B6                            ;
000009B6                            ; USES:
000009B6                            ;		a0-a2
000009B6                            ; ---------------------------------------------------------------
000009B6                            
000009B6                            FormatString_reglist		reg d0-d4/a3
000009B6 =00000007                  FormatString_regnum		equ 7
000009B6                            
000009B6 =00000080                  _hex				equ $80
000009B6 =00000090                  _dec				equ $90
000009B6 =000000A0                  _bin				equ $A0
000009B6 =000000B0                  _sym				equ $B0
000009B6 =000000C0                  _disp				equ $C0
000009B6 =000000DF                  _str				equ $DF
000009B6 =000000D0                  _asm				equ $D0
000009B6                            
000009B6 =00000000                  byte				equ 0
000009B6 =00000001                  word				equ 1
000009B6 =00000003                  long				equ 3
000009B6                            
000009B6                            ; for number formatters ...
000009B6 =00000008                  signed				equ 8
000009B6                            
000009B6                            ; for symbol formatters ...
000009B6 =00000008                  split				equ 8
000009B6 =00000004                  forced				equ 4				; display <unknown> if symbol was not found
000009B6                            
000009B6                            ; for symbol displacement or offset formatters ...
000009B6 =00000008                  weak				equ 8				; don't draw offset after <unknown> symbol
000009B6                            ; ---------------------------------------------------------------
000009B6                            
000009B6                            FormatString:
000009B6 48E7 F810                  		movem.l	FormatString_reglist,-(sp)
000009BA                            
000009BA                            	; NOTICE: This loop shouldn't use registers D0/D1, as control codes B0..BF, C0..CF
000009BA                            	;	that are executed consequently use it to pass parameters inbetween.
000009BA                            .copy_loop
000009BA 10D9                       		move.b	(a1)+,(a0)+
000009BC 5FCF FFFC                  		dble	d7,.copy_loop				; if character's code is below $80 and not $00, copy string ...
000009C0 6E00                       		bgt.s	.flush
000009C2 6700                       		beq.s	.quit					; if char $00 was fetched, quit
000009C4                            
000009C4                            .flag
000009C4                            	; Process special character
000009C4 1620                       		move.b	-(a0),d3				; d3 = special character that was pushed out of the string
000009C6 7470                       		moveq	#$70,d2					; d2 = $00, $10, $20, $30, $40, $60, $70
000009C8 C403                       		and.b	d3,d2					; d2 = code offset based on character's code, aligned on $10-byte boundary
000009CA 4EBB 2000                  		jsr	FormatString_CodeHandlers(pc,d2.w)	; jump to an appropriate special character handler
000009CE 64EA                       		bcc.s	.copy_loop				; if string buffer is good, branch
000009D0                            
000009D0                            .quit_no_flush
000009D0 4CDF 081F                  		movem.l	(sp)+,FormatString_reglist
000009D4 4E75                       		rts
000009D6                            
000009D6                            .flush
000009D6 4E94                       		jsr	(a4)					; flush buffer
000009D8 64E0                       		bcc.s	.copy_loop				; if flashing was ok, branch
000009DA 60F4                       		bra.s	.quit_no_flush
000009DC                            
000009DC                            .quit
000009DC 5348                       		subq.w	#1,a0					; because D7 wasn't decremented?
000009DE 4E94                       		jsr	(a4)					; call flush buffer function
000009E0 4CDF 081F                  		movem.l	(sp)+,FormatString_reglist
000009E4                            
000009E4                            .return
000009E4 4E75                       		rts
000009E6                            ; --------------------------------------------------------------
000009E6                            
000009E6                            FormatString_CodeHandlers:
000009E6                            	; codes 80..8F : Display hex number
000009E6 47FA FD94                  		lea	FormatHex_Handlers(pc),a3		; $00
000009EA B702                       		eor.b	d3,d2					; $04	; d2 = lower 4 bits of char code, encodes argument size (valid values are: 0, 1, 3, see below)
000009EC D402                       		add.b	d2,d2					; $06	; multiply 4-bit code by 2 as instructions in the code handlers below are word-sized
000009EE 4EFB 2000                  		jmp	.ArgumentFetchFlow(pc,d2.w)		; $08	; jump to an appropriate insturction (note that even invalid codes won't crash)
000009F2 4E71                       		nop						; $0C
000009F4 4E71                       		nop						; $0E
000009F6                            ; --------------------------------------------------------------
000009F6                            
000009F6                            	; codes 90..9F : Display decimal number
000009F6 47FA FE50                  		lea	FormatDec_Handlers(pc),a3		; $00
000009FA B702                       		eor.b	d3,d2					; $04	; d2 = lower 4 bits of char code, encodes argument size (valid values are: 0, 1, 3, see below)
000009FC D402                       		add.b	d2,d2					; $06	; multiply 4-bit code by 2 as instructions in the code handlers below are word-sized
000009FE 4EFB 2000                  		jmp	.ArgumentFetchFlow(pc,d2.w)		; $08	; jump to an appropriate insturction (note that even invalid codes won't crash)
00000A02 4E71                       		nop						; $0C
00000A04 4E71                       		nop						; $0E
00000A06                            ; --------------------------------------------------------------
00000A06                            
00000A06                            	; codes A0..AF : Display binary number
00000A06 47FA FE00                  		lea	FormatBin_Handlers(pc),a3		; $00
00000A0A B702                       		eor.b	d3,d2					; $04	; d2 = lower 4 bits of char code, encodes argument size (valid values are: 0, 1, 3, see below)
00000A0C D402                       		add.b	d2,d2					; $06	; multiply 4-bit code by 2 as instructions in the code handlers below are word-sized
00000A0E 4EFB 2000                  		jmp	.ArgumentFetchFlow(pc,d2.w)		; $08	; jump to an appropriate instruction (note that even invalid codes won't crash)
00000A12                            
00000A12 5348                       .d0		subq.w	#1,a0					; $0C	; overwrite null-terminator (part of "String" section, see below)
00000A14 4E75                       		rts						; $0E
00000A16                            ; --------------------------------------------------------------
00000A16                            
00000A16                            	; codes B0..BF : Display symbol
00000A16 47FA FEDA                  		lea	FormatSym_Handlers(pc),a3		; $00
00000A1A                            
00000A1A                            .HandleAsm
00000A1A 1403                       		move.b	d3,d2					; $04
00000A1C 0242 0003                  		and.w	#3,d2					; $06	; d2 = 0, 1, 3 ... (ignore handlers for signed values)
00000A20 D442                       		add.w	d2,d2					; $0A	; multiply 4-bit code by 2 as instructions in the code handlers below are word-sized
00000A22 4EFB 2000                  		jmp	.ArgumentFetchFlow(pc,d2.w)		; $0C	; jump to an appropriate instruction (note that even invalid codes won't crash)
00000A26                            ; --------------------------------------------------------------
00000A26                            
00000A26                            	; codes C0..CF : Display symbol's displacement (to be used after codes B0..BF, if extra formatting is due)
00000A26 4A40                       		tst.w	d0					; $00	; check "GetSymbolByOffset" (see "FormatSym" code)
00000A28 6B00                       		bmi.s	.c0					; $02	; if return code is -1 (error), assume d1 is OFFSET, display it directly
00000A2A 4A81                       		tst.l	d1					; $04	; assume d1 is DISPLACEMENT, test it
00000A2C 6700                       		beq.s	.return2				; $06	; if displacement is zero, branch
00000A2E 4EFA FF0E                  		jmp	FormatSym_Displacement(pc)		; $08
00000A32                            
00000A32 4EFA FF26                  .c0		jmp	FormatSym_Offset(pc)			; $0C
00000A36                            ; --------------------------------------------------------------
00000A36                            
00000A36                            	; codes D0..DF : String + decode assembly
00000A36 0803 0003                  		btst	#3,d3					; $00	; check if this is string drawing function
00000A3A 6600 0000                  		bne.w	.DrawString				; $04	; branch if yes
00000A3E                            
00000A3E 47FA FF24                  		lea	FormatAsm_Handlers(pc),a3		; $08
00000A42 60D6                       		bra.s	.HandleAsm				; $0C
00000A44                            
00000A44                            .return2
00000A44 4E75                       		rts						; $0E	; return C
00000A46                            ; --------------------------------------------------------------
00000A46                            
00000A46                            	; codes E0..EF : Drawing command (ignore)
00000A46 5248                       		addq.w	#1,a0					; $00	; restore control character back
00000A48 6000                       		bra.s	.AfterRestoreCharacter			; $02
00000A4A                            
00000A4A                            	; NOTICE: Code handlers continue below and overlap with the following code ...
00000A4A                            ; --------------------------------------------------------------
00000A4A                            ; WARNING!
00000A4A                            ;	The code in the following blocks are critical and shouldn't
00000A4A                            ;	be altered anymore. Each instruction MUST take 2 bytes,
00000A4A                            ;	so even the invalid codes won't crash, but only break
00000A4A                            ;	the flow ...
00000A4A                            ; --------------------------------------------------------------
00000A4A                            
00000A4A                            .ArgumentFetchFlow
00000A4A 504B                       		addq.w	#8,a3			; $00 :$04	; code 0 : Display byte
00000A4C 321A                       		move.w	(a2)+,d1		; $02 :$06	; code 1 : Display word
00000A4E 4ED3                       		jmp	(a3)			; $04 :$08	; code 2 : ## invalid : displays garbage word
00000A50                            ; --------------------------------------------------------------
00000A50                            
00000A50 584B                       		addq.w	#4,a3			; $06 :$0A	; code 3 : Display longword
00000A52 221A                       		move.l	(a2)+,d1		; $08 :$0C	; code 4 : ## invalid ##: displays word, but loads longword
00000A54 4ED3                       		jmp	(a3)			; $0A :$0E	; code 5 : ## invalid ##: displays garbage word
00000A56                            ; --------------------------------------------------------------
00000A56                            
00000A56                            	; codes F0..FF : Drawing command, one-byte argument (ignore)
00000A56 5248                       		addq.w	#1,a0			; $0C :$00	; code 6 : ## invalid ##: restores control character and puts another one
00000A58 6000                       		bra.s	.AfterRestoreCharacter2	; $0E :$02	; code 7 : ## invalid ##: does nothing
00000A5A                            ; --------------------------------------------------------------
00000A5A                            
00000A5A 504B                       		addq.w	#8,a3			; $10		; code 8 : Display signed byte
00000A5C 321A                       		move.w	(a2)+,d1		; $12		; code 9 : Display signed word
00000A5E 6000                       		bra.s	.CheckValueSign		; $14		; code A : ## invalid ##: displays garbage signed word
00000A60                            ; --------------------------------------------------------------
00000A60                            
00000A60 584B                       		addq.w	#4,a3			; $16		; code B : Display signed longword
00000A62 221A                       		move.l	(a2)+,d1		; $18		; code C : ## invalid ##: displays signed word, but loads longword
00000A64                            ; --------------------------------------------------------------
00000A64                            
00000A64                            .CheckValueSign
00000A64 6A00                       		bpl.s	.positive		; $1A		; code D : ## invalid ##: displays garbage signed word
00000A66 4481                       		neg.l	d1			; $1C		; code E : ## invalid ##: displays gargage pseudo-negative word
00000A68 10FC 002D                  		move.b	#'-',(a0)+		; $1E		; code F : ## invalid ##: displays gargage pseudo-non-negative word
00000A6C 5347                       		subq.w	#1,d7					; are there characters left in the buffer?
00000A6E 65D4                       		bcs.s	.return2				; if not, stop output
00000A70 4ED3                       		jmp	(a3)					; draw the actual value using an appropriate handler
00000A72                            
00000A72                            .positive
00000A72 10FC 002B                  		move.b	#'+',(a0)+
00000A76 5347                       		subq.w	#1,d7					; are there characters left in the buffer?
00000A78 65CA                       		bcs.s	.return2				; if not, stop output
00000A7A 4ED3                       		jmp	(a3)					; draw the actual value using an appropriate handler
00000A7C                            ; --------------------------------------------------------------
00000A7C                            
00000A7C                            .AfterRestoreCharacter2
00000A7C 51CF 0000                  		dbf	d7,.AfterRestoreCharacter3
00000A80 4E94                       		jsr	(a4)
00000A82 65C0                       		bcs.s	.return2
00000A84                            
00000A84                            .AfterRestoreCharacter3:
00000A84 10D9                       		move.b	(a1)+,(a0)+
00000A86                            
00000A86                            .AfterRestoreCharacter:
00000A86 51CF FFBC                  		dbf	d7,.return2
00000A8A 4ED4                       		jmp	(a4)
00000A8C                            ; --------------------------------------------------------------
00000A8C                            
00000A8C                            .DrawString
00000A8C 265A                       		movea.l	(a2)+,a3				; $00	; a3 = string ptr
00000A8E                            
00000A8E                            .d1
00000A8E 10DB                       		move.b	(a3)+,(a0)+				; $02	; copy char
00000A90 57CF FFFC                  		dbeq	d7,.d1					; $04	; loop until either buffer ends or zero-terminator is met
00000A94 6700 FF7C                  		beq.w	.d0					; $08	; if met zero-terminator, branch
00000A98                            
00000A98 4E94                       		jsr	(a4)					; $0C	; flush buffer
00000A9A 64F2                       		bcc.s	.d1					; $0E	; if buffer is ok, branch
00000A9C 4E75                       		rts						; $10
00000A9E                            ; --------------------------------------------------------------
00000A9E                            	include	'Console.asm'
00000A9E                            
00000A9E                            ; ==============================================================
00000A9E                            ; --------------------------------------------------------------
00000A9E                            ; Error handling and debugging modules
00000A9E                            ; 2016-2017, Vladikcomper
00000A9E                            ; --------------------------------------------------------------
00000A9E                            ; Console Module
00000A9E                            ; --------------------------------------------------------------
00000A9E                            
00000A9E                            ; --------------------------------------------------------------
00000A9E                            ; RAM structure
00000A9E                            ; --------------------------------------------------------------
00000A9E                            
00000A9E                            				rsreset
00000A9E =00000000                  Console_RAM			equ __rs
00000A9E =00000000                  Console.ScreenPosReq		rs.l 1				;	screen position request for VDP
00000A9E =00000004                  Console.CharsPerLine		rs.w 1				; d2	number of characters per line
00000A9E =00000006                  Console.CharsRemaining		rs.w 1				; d3	remaining number of characters
00000A9E =00000008                  Console.BasePattern		rs.w 1				; d4	base pattern
00000A9E =0000000A                  Console.ScreenRowSz		rs.w 1				; d6	row size within screen position
00000A9E =0000000C                  Console.Validator		rs.b 1				;	should contain $5D to ensure this is valid console memory area
00000A9E                            				rs.b 1				;	<<FREE>>
00000A9E =0000000E                  Console_RAM.size		equ __rs-Console_RAM
00000A9E                            
00000A9E                            ; Drawing flags supported in strings
00000A9E =000000E0                  _newl				equ $E0
00000A9E =000000E6                  _cr				equ $E6
00000A9E =000000E8                  _pal0				equ $E8
00000A9E =000000EA                  _pal1				equ $EA
00000A9E =000000EC                  _pal2				equ $EC
00000A9E =000000EE                  _pal3				equ $EE
00000A9E                            
00000A9E =000000F0                  _setw				equ $F0
00000A9E =000000F4                  _setoff				equ $F4
00000A9E =000000F8                  _setpat				equ $F8
00000A9E =000000FA                  _setx				equ $FA
00000A9E                            
00000A9E =0000005D                  _ConsoleEnable			equ $5D
00000A9E                            ; ==============================================================
00000A9E                            ; --------------------------------------------------------------
00000A9E                            ; Initialize console module
00000A9E                            ; --------------------------------------------------------------
00000A9E                            ; INPUT:
00000A9E                            ;		a1		Console config
00000A9E                            ;		a2		Console font graphics (1bpp)
00000A9E                            ;		a3		Console RAM pointer
00000A9E                            ;
00000A9E                            ; OUTPUT:
00000A9E                            ;		d5	.l	Current on-screen position
00000A9E                            ;
00000A9E                            ; USES:
00000A9E                            ;		d0-d4, a5-a6
00000A9E                            ; --------------------------------------------------------------
00000A9E                            
00000A9E                            Console_Init:
00000A9E 4BF9 00C0 0004             		lea	VDP_Ctrl,a5
00000AA4 4DED FFFC                  		lea	-4(a5),a6
00000AA8                            
00000AA8                            	; Load console font
00000AA8                            .font_prg_loop
00000AA8 4A51                       		tst.w	(a1)
00000AAA 6B00                       		bmi.s	.font_done
00000AAC 2A99                       		move.l	(a1)+,(a5)				; VDP => Setup font offset in VRAM
00000AAE 41D2                       		lea	(a2),a0					; load font offset
00000AB0 3818                       		move.w	(a0)+,d4				; load font size - 1
00000AB2 4EBA 0000                  		jsr	Decomp1bpp(pc)				; decompress font (input: a0-a1/a6, uses: a0/d0-d4)
00000AB6 43E9 0020                  		lea	$20(a1),a1
00000ABA 60EC                       		bra.s	.font_prg_loop
00000ABC                            
00000ABC                            .font_done
00000ABC 5449                       		addq.w	#2,a1					; skip end marker
00000ABE                            
00000ABE                            		; Init Console RAM
00000ABE 4E63                       		move.l	a3,usp					; remember Console RAM pointer in USP to restore it in later calls
00000AC0 2A19                       		move.l	(a1)+,d5				; d4 = start VRAM pos
00000AC2 26C5                       		move.l	d5,(a3)+				; Console RAM => copy screen position (long)
00000AC4 26D9                       		move.l	(a1)+,(a3)+				; Console RAM => copy number of characters per line (word) + characters remaining for the current line (word)
00000AC6 26D9                       		move.l	(a1)+,(a3)+				; Console RAM => copy base pattern (word) + screen row size (word)
00000AC8 36FC 5D00                  		move.w	#_ConsoleEnable<<8,(a3)+		; Console RAM => set validator and clear the last byte (UNUSED)
00000ACC                            
00000ACC                            		; WARNING! Don't touch d5 from now on
00000ACC                            
00000ACC                            		; Clear screen
00000ACC 47FA 0000                  		lea	Console_FillTile(pc), a3
00000AD0 2A85                       		move.l	d5,(a5)					; VDP => Setup VRAM for screen namespace
00000AD2 7000                       		moveq	#0,d0					; d0 = fill pattern
00000AD4 3219                       		move.w	(a1)+,d1				; d1 = size of screen in tiles - 1
00000AD6 4E93                       		jsr	(a3)					; fill screen
00000AD8                            		vram	$0000,(a5)				; VDP => Setup VRAM at tile 0
00000AD8 2ABC 4000 0000           M 	move.l	#($40000000+(($0000&$3fff)<<16)+(($0000&$c000)>>14)),(a5)
00000ADE 7200                       		moveq	#0,d1					; d1 = number of tiles to fill - 1
00000AE0 4E93                       		jsr	(a3)					; clear first tile
00000AE2                            
00000AE2                            Console_LoadPalette: __global
00000AE2                          M __global__console_loadpalette:
00000AE2                          M console_loadpalette:
00000AE2                            		; Load palette
00000AE2                            		cram	$00,(a5)				; VDP => Setup CRAM write at offset $00
00000AE2 2ABC C000 0000           M 	move.l	#($c0000000+($00<<16)),(a5)
00000AE8 7000                       		moveq	#0,d0					; d0 = black color
00000AEA 7603                       		moveq	#4-1,d3					; d3 = number of palette lines - 1
00000AEC                            
00000AEC                            .fill_palette_line
00000AEC 3C80                       		move.w	d0,(a6)					; transparent color is always black
00000AEE 3419                       		move.w	(a1)+,d2				; get CRAM data entry
00000AF0 3C82                       .0		move.w	d2,(a6)					; write to CRAM
00000AF2 3419                       		move.w	(a1)+,d2				; get next CRAM data entry
00000AF4 6AFA                       		bpl.s	.0					; if color, branch
00000AF6                            
00000AF6 7200                       		moveq	#0,d1
00000AF8 4EB3 2010                  		jsr	$10(a3,d2.w)				; fill the rest of cram by a clever jump (WARNING! Precision required!)
00000AFC 51CB FFEE                  		dbf	d3,.fill_palette_line
00000B00                            
00000B00                            	; Finalize
00000B00 3ABC 8174                  		move.w	#$8174,(a5)				; VDP => Enable display
00000B04 2A85                       		move.l	d5,(a5)					; VDP => Enable console for writing
00000B06 4E75                       		rts
00000B08                            ; --------------------------------------------------------------
00000B08                            
00000B08                            Console_FillTile:
00000B08                            	rept 8
00000B08                            		move.l	d0,(a6)
00000B08                            	endr
00000B08 2C80                     M 	move.l	d0,(a6)
00000B0A 2C80                     M 	move.l	d0,(a6)
00000B0C 2C80                     M 	move.l	d0,(a6)
00000B0E 2C80                     M 	move.l	d0,(a6)
00000B10 2C80                     M 	move.l	d0,(a6)
00000B12 2C80                     M 	move.l	d0,(a6)
00000B14 2C80                     M 	move.l	d0,(a6)
00000B16 2C80                     M 	move.l	d0,(a6)
00000B18 51C9 FFEE                  		dbf	d1,Console_FillTile
00000B1C 4E75                       		rts
00000B1E                            ; ==============================================================
00000B1E                            ; --------------------------------------------------------------
00000B1E                            ; Setup console cursor position based on XY coordinates
00000B1E                            ; --------------------------------------------------------------
00000B1E                            ; INPUT:
00000B1E                            ;		d0	.w	X-position
00000B1E                            ;		d1	.w	Y-position
00000B1E                            ; --------------------------------------------------------------
00000B1E                            
00000B1E                            Console_SetPosAsXY_Stack: __global
00000B1E                          M __global__console_setposasxy_stack:
00000B1E                          M console_setposasxy_stack:
00000B1E 4CAF 0003 0004             		movem.w	4(sp),d0-d1
00000B24                            
00000B24                            Console_SetPosAsXY: __global
00000B24                          M __global__console_setposasxy:
00000B24                          M console_setposasxy:
00000B24 48E7 6010                  		movem.l	d1-d2/a3,-(sp)
00000B28 4E6B                       		move.l	usp,a3
00000B2A 0C2B 005D 000C             		cmp.b	#_ConsoleEnable,Console.Validator(a3)
00000B30 6600                       		bne.s	.quit
00000B32                            
00000B32 3413                       		move.w	(a3),d2
00000B34 0242 E000                  		and.w	#$E000,d2				; clear out displacement, leave base offset only
00000B38 C2EB 000A                  		mulu.w	Console.ScreenRowSz(a3),d1
00000B3C D441                       		add.w	d1,d2
00000B3E D440                       		add.w	d0,d2
00000B40 D440                       		add.w	d0,d2
00000B42 3682                       		move.w	d2,(a3)
00000B44 23D3 00C0 0004             		move.l	(a3),VDP_Ctrl
00000B4A                            
00000B4A                            .quit
00000B4A 4CDF 0806                  		movem.l	(sp)+,d1-d2/a3
00000B4E 4E75                       		rts
00000B50                            ; ==============================================================
00000B50                            ; --------------------------------------------------------------
00000B50                            ; Get current line position in XY-coordinates
00000B50                            ; --------------------------------------------------------------
00000B50                            ; OUTPUT:
00000B50                            ;		d0	.w	X-position
00000B50                            ;		d1	.w	Y-position
00000B50                            ; --------------------------------------------------------------
00000B50                            
00000B50                            Console_GetPosAsXY: __global
00000B50                          M __global__console_getposasxy:
00000B50                          M console_getposasxy:
00000B50 2F0B                       		move.l	a3,-(sp)
00000B52 4E6B                       		move.l	usp,a3
00000B54 0C2B 005D 000C             		cmp.b	#_ConsoleEnable,Console.Validator(a3)
00000B5A 6600                       		bne.s	.quit
00000B5C 7200                       		moveq	#0,d1
00000B5E 3213                       		move.w	(a3),d1
00000B60 0241 1FFF                  		and.w	#$1FFF,d1				; clear out base offset, leave displacement only
00000B64 82EB 000A                  		divu.w	Console.ScreenRowSz(a3),d1		; d1 = row
00000B68 2001                       		move.l	d1,d0
00000B6A 4840                       		swap	d0
00000B6C E248                       		lsr.w	d0
00000B6E                            
00000B6E                            .quit
00000B6E 265F                       		move.l	(sp)+,a3
00000B70 4E75                       		rts
00000B72                            ; ==============================================================
00000B72                            ; --------------------------------------------------------------
00000B72                            ; Subroutine to transfer console to a new line
00000B72                            ; --------------------------------------------------------------
00000B72                            
00000B72                            Console_StartNewLine: __global
00000B72                          M __global__console_startnewline:
00000B72                          M console_startnewline:
00000B72 2F0B                       		move.l	a3,-(sp)
00000B74 4E6B                       		move.l	usp,a3
00000B76 0C2B 005D 000C             		cmp.b	#_ConsoleEnable,Console.Validator(a3)
00000B7C 6600                       		bne.s	.quit
00000B7E                            
00000B7E 3F00                       		move.w	d0,-(sp)
00000B80 3013                       		move.w	(a3),d0
00000B82 D06B 000A                  		add.w	Console.ScreenRowSz(a3),d0
00000B86                            
00000B86                            		; TODO: Check if offset is out of plane boundaries
00000B86 0240 7FFF                  		and.w	#$7FFF,d0				; make sure line stays within plane
00000B8A 3680                       		move.w	d0,(a3)					; save new position
00000B8C 23DB 00C0 0004             		move.l	(a3)+,VDP_Ctrl
00000B92 36DB                       		move.w	(a3)+,(a3)+				; reset characters on line counter (copy "CharsPerLine" to "CharsRemaining")
00000B94 301F                       		move.w	(sp)+,d0
00000B96                            
00000B96                            .quit
00000B96 265F                       		move.l	(sp)+,a3
00000B98 4E75                       		rts
00000B9A                            
00000B9A                            
00000B9A                            ; ==============================================================
00000B9A                            ; --------------------------------------------------------------
00000B9A                            ; Subroutine to set console's base pattern
00000B9A                            ; --------------------------------------------------------------
00000B9A                            ; INPUT:
00000B9A                            ;		d1	.w	Base pattern
00000B9A                            ; --------------------------------------------------------------
00000B9A                            
00000B9A                            Console_SetBasePattern: __global
00000B9A                          M __global__console_setbasepattern:
00000B9A                          M console_setbasepattern:
00000B9A 2F0B                       		move.l	a3,-(sp)
00000B9C 4E6B                       		move.l	usp,a3
00000B9E 0C2B 005D 000C             		cmp.b	#_ConsoleEnable, Console.Validator(a3)
00000BA4 6600                       		bne.s	.quit
00000BA6 3741 0008                  		move.w	d1,Console.BasePattern(a3)
00000BAA                            
00000BAA                            .quit
00000BAA 265F                       		move.l	(sp)+,a3
00000BAC 4E75                       		rts
00000BAE                            
00000BAE                            ; ==============================================================
00000BAE                            ; --------------------------------------------------------------
00000BAE                            ; Subroutine to set console's base pattern
00000BAE                            ; --------------------------------------------------------------
00000BAE                            ; INPUT:
00000BAE                            ;		d1	.w	Base pattern
00000BAE                            ; --------------------------------------------------------------
00000BAE                            
00000BAE                            Console_SetWidth: __global
00000BAE                          M __global__console_setwidth:
00000BAE                          M console_setwidth:
00000BAE 2F0B                       		move.l	a3,-(sp)
00000BB0 4E6B                       		move.l	usp,a3
00000BB2 0C2B 005D 000C             		cmp.b	#_ConsoleEnable, Console.Validator(a3)
00000BB8 6600                       		bne.s	.quit
00000BBA 584B                       		addq.w	#4,a3
00000BBC 36C1                       		move.w	d1,(a3)+
00000BBE 36C1                       		move.w	d1,(a3)+
00000BC0                            
00000BC0                            .quit
00000BC0 265F                       		move.l	(sp)+,a3
00000BC2 4E75                       		rts
00000BC4                            ; ==============================================================
00000BC4                            ; --------------------------------------------------------------
00000BC4                            ; Subroutine to draw string on screen
00000BC4                            ; --------------------------------------------------------------
00000BC4                            ; INPUT:
00000BC4                            ;		a0		Pointer to null-terminated string
00000BC4                            ;		d1	.w	Base pattern (*_WriteLine_WithPattern only)
00000BC4                            ;
00000BC4                            ; OUTPUT:
00000BC4                            ;		a0		Pointer to the end of string
00000BC4                            ;
00000BC4                            ; MODIFIES:
00000BC4                            ;		a0
00000BC4                            ; --------------------------------------------------------------
00000BC4                            
00000BC4                            Console_WriteLine_WithPattern: __global
00000BC4                          M __global__console_writeline_withpattern:
00000BC4                          M console_writeline_withpattern:
00000BC4 61D4                       		bsr.s	Console_SetBasePattern
00000BC6                            
00000BC6                            ; --------------------------------------------------------------
00000BC6                            Console_WriteLine: __global
00000BC6                          M __global__console_writeline:
00000BC6                          M console_writeline:
00000BC6 487A FFAA                  		pea	Console_StartNewLine(pc)
00000BCA                            
00000BCA                            ; --------------------------------------------------------------
00000BCA                            Console_Write: __global
00000BCA                          M __global__console_write:
00000BCA                          M console_write:
00000BCA 48E7 7E12                  		movem.l	d1-d6/a3/a6,-(sp)
00000BCE 4E6B                       		move.l	usp,a3
00000BD0 0C2B 005D 000C             		cmp.b	#_ConsoleEnable,Console.Validator(a3)
00000BD6 6600                       		bne.s	.quit
00000BD8                            
00000BD8                            	; Load console variables
00000BD8 2A1B                       		move.l	(a3)+,d5				; d5 = VDP screen position request
00000BDA 4C93 005C                  		movem.w	(a3),d2-d4/d6				; d2 = number of characters per line
00000BDE 4846                       		swap	d6					; d3 = number of characters remaining until next line
00000BE0                            								; d4 = base pattern
00000BE0                            								; d6 = screen position increment value
00000BE0 4DF9 00C0 0000             		lea	VDP_Data,a6				; a6 = VDP_Data
00000BE6                            
00000BE6                            	; First iteration in .loop, unrolled
00000BE6 7200                       		moveq	#0,d1
00000BE8 1218                       		move.b	(a0)+,d1				; load first char
00000BEA 6E00                       		bgt.s	.loop					; if not a null-terminator or flag, branch
00000BEC 6B00                       		bmi.s	.flag					; if char is a flague, branch
00000BEE                            
00000BEE                            .done
00000BEE 4893 001C                  		movem.w	d2-d4,(a3)				; save d2-d4 (ignore d6 as it won't get changes anyways ...)
00000BF2 2705                       		move.l	d5,-(a3)				; save screen position
00000BF4                            
00000BF4                            .quit
00000BF4 4CDF 487E                  		movem.l	(sp)+,d1-d6/a3/a6
00000BF8 4E75                       		rts
00000BFA                            ; --------------------------------------------------------------
00000BFA                            
00000BFA                            .loop
00000BFA 51CB 0000                  		dbf	d3,.writechar
00000BFE D642                       		add.w	d2,d3					; restore number of characters per line
00000C00 DA86                       		add.l	d6,d5
00000C02 0885 001D                  		bclr	#29,d5
00000C06 2D45 0004                  		move.l	d5,4(a6)				; setup screen position
00000C0A                            
00000C0A                            .writechar
00000C0A D244                       		add.w	d4,d1  					; add base pattern
00000C0C 3C81                       		move.w	d1,(a6)					; draw
00000C0E                            
00000C0E                            .nextchar
00000C0E 7200                       		moveq	#0,d1
00000C10 1218                       		move.b	(a0)+,d1				; load next char
00000C12 6EE6                       		bgt.s	.loop					; if not a null-terminator or flag, branch
00000C14 67D8                       		beq.s	.done					; if null-terminator, branch
00000C16                            
00000C16                            	; Process drawing flag
00000C16                            .flag
00000C16 0241 001E                  		and.w	#$1E,d1					; d2 = $00, $02, $04, $06, $08, $0A, $0C, $0E, $10, $12, $14, $16, $18, $1A, $1C, $1E
00000C1A 4EFB 1000                  		jmp	.CommandHandlers(pc,d1.w)
00000C1E                            ; --------------------------------------------------------------
00000C1E                            
00000C1E                            .CommandHandlers
00000C1E                            	; For flags E0-EF (no arguments)
00000C1E DA86                       		add.l	d6,d5					; $00	; codes E0-E1 : start a new line
00000C20 721D                       		moveq	#29,d1	 				; $02	; codes E2-E3 : <<UNUSED>>
00000C22 0385                       		bclr	d1,d5					; $04	; codes E4-E5 : <<UNUSED>>
00000C24 6000                       		bra.s	.reset_line				; $06	; codes E6-E7 : reset position to the beginning of line
00000C26                            
00000C26 6000                       		bra.s	.set_palette_line_0			; $08	; codes E8-E9 : set palette line #0
00000C28 6000                       		bra.s	.set_palette_line_1			; $0A	; codes EA-EB : set palette line #1
00000C2A 6000                       		bra.s	.set_palette_line_2			; $0C	; codes EC-ED : set palette line #2
00000C2C 6000                       		bra.s	.set_palette_line_3			; $0E	; codes EE-EF : set palette line #3
00000C2E                            
00000C2E                            	; For flags F0-FF (one-byte arguments)
00000C2E 1418                       		move.b	(a0)+,d2				; $10	; codes F0-F1 : set characters per line, reset line
00000C30 6000                       		bra.s	.reset_line				; $12	; codes F2-F3 : <<UNUSED>>
00000C32                            
00000C32 1818                       		move.b	(a0)+,d4				; $14	; codes F4-F5 : set low byte of base pattern (raw)
00000C34 60D8                       		bra.s	.nextchar				; $16	; codes F6-F7 : <<UNUSED>>
00000C36                            
00000C36 6000                       		bra.s	.set_base_pattern_high_byte		; $18	; codes F8-F9 : set high byte of base pattern (raw)
00000C38                            ; --------------------------------------------------------------
00000C38                            
00000C38 1218                       		move.b	(a0)+,d1				; $1A	; codes FA-FB : set x-position
00000C3A D241                       		add.w	d1,d1					; $1C	; codes FC-FD : <<UNUSED>>
00000C3C 7680                       		moveq	#-$80,d3				; $1E	; codes FE-FF : <<UNUSED>>
00000C3E                            
00000C3E 4843                       		swap	d3					;
00000C40 CA83                       		and.l	d3,d5					;
00000C42 4841                       		swap	d1					;
00000C44 8A81                       		or.l	d1,d5					;
00000C46                            	;	bra.s	.reset_line				; restore d3 anyways, as it's corrupted
00000C46                            
00000C46                            .reset_line
00000C46 3602                       		move.w	d2,d3
00000C48 2D45 0004                  		move.l	d5,4(a6)
00000C4C 60C0                       		bra.s	.nextchar
00000C4E                            ; --------------------------------------------------------------
00000C4E                            
00000C4E                            .set_palette_line_0
00000C4E 0244 07FF                  		and.w	#$7FF,d4
00000C52 60BA                       		bra.s	.nextchar
00000C54                            ; --------------------------------------------------------------
00000C54                            
00000C54                            .set_palette_line_1
00000C54 0244 07FF                  		and.w	#$7FF,d4
00000C58 0044 2000                  		or.w	#$2000,d4
00000C5C 60B0                       		bra.s	.nextchar
00000C5E                            ; --------------------------------------------------------------
00000C5E                            
00000C5E                            .set_palette_line_2
00000C5E 0244 07FF                  		and.w	#$7FF,d4
00000C62 0044 4000                  		or.w	#$4000,d4
00000C66 60A6                       		bra.s	.nextchar
00000C68                            ; --------------------------------------------------------------
00000C68                            
00000C68                            .set_palette_line_3
00000C68 0044 6000                  		or.w	#$6000,d4
00000C6C 60A0                       		bra.s	.nextchar
00000C6E                            ; --------------------------------------------------------------
00000C6E                            
00000C6E                            .set_base_pattern_high_byte
00000C6E 3F04                       		move.w	d4,-(sp)
00000C70 1E98                       		move.b	(a0)+,(sp)
00000C72 381F                       		move.w	(sp)+,d4
00000C74 6098                       		bra.s	.nextchar
00000C76                            ; ==============================================================
00000C76                            ; --------------------------------------------------------------
00000C76                            ; Subroutine to provide writting of formatted strings
00000C76                            ; --------------------------------------------------------------
00000C76                            ; INPUT:
00000C76                            ;		a1		Pointer to source formatted string
00000C76                            ;		a2		Arguments buffer pointer
00000C76                            ;		a5		VDP Control port
00000C76                            ;		a6		VDP Data port
00000C76                            ;
00000C76                            ; USES:
00000C76                            ;		a0-a2, d7
00000C76                            ; --------------------------------------------------------------
00000C76                            
00000C76                            Console_WriteLine_Formatted: __global
00000C76                          M __global__console_writeline_formatted:
00000C76                          M console_writeline_formatted:
00000C76 487A FEFA                  		pea	Console_StartNewLine(pc)
00000C7A                            
00000C7A                            ; --------------------------------------------------------------
00000C7A                            Console_Write_Formatted: __global
00000C7A                          M __global__console_write_formatted:
00000C7A                          M console_write_formatted:
00000C7A                            
00000C7A =00000010                  .buffer_size = $10
00000C7A 2F0C                       		move.l	a4,-(sp)
00000C7C                            
00000C7C 49FA 0000                  		lea	.FlushBuffer(pc),a4			; flushing function
00000C80 4FEF FFF0                  		lea	-.buffer_size(sp),sp			; allocate string buffer
00000C84 41D7                       		lea	(sp),a0					; a0 = string buffer
00000C86                            
00000C86                            
00000C86 7E0E                       		moveq	#.buffer_size-2,d7			; d7 = number of characters before flush -1
00000C88 4EBA FD2C                  		jsr	FormatString(pc)
00000C8C 4FEF 0010                  		lea	.buffer_size(sp),sp			; free string buffer
00000C90                            
00000C90 285F                       		move.l	(sp)+,a4
00000C92 4E75                       		rts
00000C94                            ; ==============================================================
00000C94                            ; --------------------------------------------------------------
00000C94                            ; Flush buffer callback raised by FormatString
00000C94                            ; --------------------------------------------------------------
00000C94                            ; INPUT:
00000C94                            ;		a0		Buffer position
00000C94                            ;		d7	.w	Number of characters remaining in buffer - 1
00000C94                            ;
00000C94                            ; OUTPUT:
00000C94                            ;		a0		Buffer position after flushing
00000C94                            ;		d7	.w	Number of characters before next flush - 1
00000C94                            ;		Carry		0 = continue operation
00000C94                            ;				1 = terminate FormatString with error condition
00000C94                            ;
00000C94                            ; WARNING: This function shouldn't modify d0-d4 / a1-a3!
00000C94                            ; --------------------------------------------------------------
00000C94                            
00000C94                            .FlushBuffer
00000C94 4218                       		clr.b	(a0)+					; finalize buffer
00000C96                            
00000C96 4447                       		neg.w	d7
00000C98 0647 000F                  		add.w	#.buffer_size-1,d7
00000C9C 90C7                       		sub.w	d7,a0					; a0 = start of the buffer
00000C9E                            
00000C9E                            
00000C9E 2F08                       		move.l	a0,-(sp)
00000CA0 4EBA FF28                  		jsr	Console_Write(pc)			; call the real flush function
00000CA4 205F                       		move.l	(sp)+,a0
00000CA6 7E0E                       		moveq	#.buffer_size-2,d7			; d7 = number of characters before flush -1
00000CA8 4E75                       		rts						; WARNING! Must return Carry=0
00000CAA                            	include	'1bpp - Decompress.asm'
00000CAA                            ; ===============================================================
00000CAA                            ; ---------------------------------------------------------------
00000CAA                            ; Error handling and debugging modules
00000CAA                            ; 2016-2017, Vladikcomper
00000CAA                            ; ---------------------------------------------------------------
00000CAA                            ; Fast 1bpp decompressor
00000CAA                            ; ---------------------------------------------------------------
00000CAA                            ; INPUT:
00000CAA                            ;		a0		Source 1bpp art
00000CAA                            ;		a1		Decode table (generated or manual)
00000CAA                            ;		d4	.w	Size of art in bytes - 1
00000CAA                            ;		a6		VDP Data Port
00000CAA                            ;
00000CAA                            ; USES:
00000CAA                            ;		a0, d0-d2/d4
00000CAA                            ; ---------------------------------------------------------------
00000CAA                            
00000CAA                            Decomp1bpp:
00000CAA 741E                       		moveq	#$1E,d2
00000CAC                            
00000CAC                            .row
00000CAC 1018                       		move.b	(a0)+,d0				; d0 = %aaaa bbbb
00000CAE 1200                       		move.b	d0,d1
00000CB0 E609                       		lsr.b	#3,d1					; d1 = %000a aaab
00000CB2 C242                       		and.w	d2,d1					; d1 = %000a aaa0
00000CB4 3CB1 1000                  		move.w	(a1,d1),(a6)				; decompress first nibble
00000CB8                            
00000CB8 D000                       		add.b	d0,d0					; d0 = %aaab bbb0
00000CBA C042                       		and.w	d2,d0					; d0 = %000b bbb0
00000CBC 3CB1 0000                  		move.w	(a1,d0),(a6)				; decompress second nibble
00000CC0                            
00000CC0 51CC FFEA                  		dbf	d4,.row
00000CC4 4E75                       		rts
00000CC6                            	include	'Decode.asm'
00000CC6                            ; ==============================================================
00000CC6                            ; --------------------------------------------------------------
00000CC6                            ; 68k decoder macros
00000CC6                            ;
00000CC6                            ; register usage:
00000CC6                            ;   a1 = instruction address
00000CC6                            ;   a0 = text buffer address
00000CC6                            ;   a2 = script address
00000CC6                            ;   a3 = stack address
00000CC6                            ;   a4-a6 = various other uses
00000CC6                            ;
00000CC6                            ;   d0 = instruction word
00000CC6                            ;   d1 = command parameter
00000CC6                            ;   d2-d5 = various other uses
00000CC6                            ;   d6 = instruction size
00000CC6                            ; --------------------------------------------------------------
00000CC6                            ; equates
00000CC6                            
00000CC6 =000000E8                  dcwhite =			_pal0				; white that can be included in a string
00000CC6 =000000EA                  dcgreen =			_pal1				; green that can be included in a string
00000CC6 =000000EC                  dcblue =			_pal2				; blue that can be included in a string
00000CC6 =000000EE                  dcred =				_pal3				; red that can be included in a string
00000CC6                            
00000CC6                            		rsset 0
00000CC6 =00000000                  d68ke_Exec			rs.w 1				; execute routine
00000CC6 =00000002                  d68ke_Jump			rs.w 1				; jump command
00000CC6 =00000004                  d68ke_Finish			rs.w 1				; script finish command
00000CC6 =00000006                  d68ke_Print			rs.w 1				; print string command
00000CC6 =00000008                  d68ke_PrintNum			rs.w 1				; print number from stack command
00000CC6 =0000000A                  d68ke_ReadSrc			rs.w 1				; read words from the source and AND it
00000CC6 =0000000C                  d68ke_Read			rs.w 1				; read words and AND it
00000CC6 =0000000E                  d68ke_InsSz			rs.w 1				; print normal instruction size
00000CC6 =00000010                  d68ke_Reg			rs.w 1				; print a register
00000CC6 =00000012                  d68ke_DataReg			rs.w 1				; print a data register
00000CC6 =00000014                  d68ke_AddrReg			rs.w 1				; print an address register
00000CC6 =00000016                  d68ke_Mode			rs.w 1				; print an addressing mode
00000CC6 =00000018                  d68ke_Cmp			rs.w 1				; check and jump if true
00000CC6 =0000001A                  d68ke_SmallSz			rs.w 1				; print small instruction size
00000CC6 =0000001C                  d68ke_Push			rs.w 1				; push words into stack
00000CC6 =0000001E                  d68ke_Pop			rs.w 1				; move stack pointer
00000CC6 =00000020                  d68ke_Swap			rs.w 1				; swap top of stack with another entry
00000CC6 =00000022                  d68ke_Size			rs.w 1				; create instruction size
00000CC6 =00000024                  d68ke_Char			rs.w 1				; print character
00000CC6 =00000026                  d68ke_Mode2			rs.w 1				; print an alternate addressing mode
00000CC6                            
00000CC6                            		rsset 0
00000CC6 =00000000                  d68kn_Byte			rs.w 1				; byte number type
00000CC6 =00000002                  d68kn_Word			rs.w 1				; word number type
00000CC6 =00000004                  d68kn_Addr			rs.w 1				; addr number type
00000CC6 =00000006                  d68kn_Long			rs.w 1				; long number type
00000CC6                            ; --------------------------------------------------------------
00000CC6                            ; constants
00000CC6                            
00000CC6 =00FF0000                  d68k_StoreIns =			$FF0000				; stored next instruction address
00000CC6 =00FF0004                  d68k_StoreDst =			$FF0004				; stored source address
00000CC6 =00FF0008                  d68k_StoreSrc =			$FF0008				; stored source address
00000CC6 =00FF000C                  d68k_Stack =			$FF000C				; stack address
00000CC6 =00FF0028                  d68k_StoreRegs =		$FF0028
00000CC6 =00FF0044                  d68k_String =			$FF0028+d68k_StoreSz		; target address for string
00000CC6 =00000000                  d68k_ShowAddr =			0				; set to 1 to enable printing address to output buffer
00000CC6 =00000001                  d68k_CheckInvalid =		1				; set to 1 to enable checking for invalid addresses
00000CC6                            ; --------------------------------------------------------------
00000CC6                            ; macros
00000CC6                            
00000CC6                            ; create a routine reference
00000CC6                            d68k_Ref	macro addr
00000CC6                            	rept narg						; run for all args
00000CC6                            		dc.w \addr-*-2					; routine offset
00000CC6                            	shift							; shift to next entry
00000CC6                            	endr
00000CC6                                endm
00000CC6                            
00000CC6                            ; execute a 68k routine
00000CC6                            d68k_Exec	macro addr, extra
00000CC6                            	dc.b d68ke_Exec, 0
00000CC6                            	d68k_Ref	\addr
00000CC6                                endm
00000CC6                            
00000CC6                            ; jump to a script address
00000CC6                            d68k_Jump	macro addr
00000CC6                            	dc.b d68ke_Jump, 0
00000CC6                            	d68k_Ref	\addr
00000CC6                                endm
00000CC6                            
00000CC6                            ; finish decoding and exit
00000CC6                            d68k_Finish	macro
00000CC6                            	dc.b d68ke_Finish, 0
00000CC6                                endm
00000CC6                            
00000CC6                            ; print external string with an additional character
00000CC6                            d68k_Print	macro extra, addr
00000CC6                            	dc.b d68ke_Print, \extra
00000CC6                            	d68k_Ref	\addr
00000CC6                                endm
00000CC6                            
00000CC6                            ; write a single character
00000CC6                            d68k_Char	macro char
00000CC6                            	dc.b d68ke_Char, \char
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a number from stack of a specific type
00000CC6                            d68k_PrintNum	macro type
00000CC6                            	dc.b d68ke_PrintNum, \type
00000CC6                                endm
00000CC6                            
00000CC6                            ; pop certain number of bytes from stack
00000CC6                            d68k_Pop	macro offset
00000CC6                            	dc.b d68ke_Pop, \offset
00000CC6                                endm
00000CC6                            
00000CC6                            ; swap the topmost entry with entry at a specific offset
00000CC6                            d68k_Swap	macro offset
00000CC6                            	dc.b d68ke_Swap, \offset
00000CC6                                endm
00000CC6                            
00000CC6                            ; read number of times from the opcode to stack with specific AND values
00000CC6                            d68k_ReadSrc	macro and
00000CC6                            	dc.b d68ke_ReadSrc, narg-1
00000CC6                            
00000CC6                            	rept narg
00000CC6                            		dc.w \and
00000CC6                            	shift
00000CC6                            	endr
00000CC6                                endm
00000CC6                            
00000CC6                            ; read a number of words from the ROM into the stack with specific AND values
00000CC6                            d68k_Read	macro and
00000CC6                            	dc.b d68ke_Read, narg-1
00000CC6                            
00000CC6                            	rept narg
00000CC6                            		dc.w \and
00000CC6                            	shift
00000CC6                            	endr
00000CC6                                endm
00000CC6                            
00000CC6                            ; push number of values to stack
00000CC6                            d68k_Push	macro val
00000CC6                            	dc.b d68ke_Push, narg-1
00000CC6                            
00000CC6                            	rept narg
00000CC6                            		dc.w \val
00000CC6                            	shift
00000CC6                            	endr
00000CC6                                endm
00000CC6                            
00000CC6                            ; print normal instruction size with a shift amount
00000CC6                            d68k_InsSz	macro shift
00000CC6                            	dc.b d68ke_InsSz, \shift
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a small instruction size based on a specific bit
00000CC6                            d68k_SmallSz	macro bit
00000CC6                            	dc.b d68ke_SmallSz, \bit
00000CC6                                endm
00000CC6                            
00000CC6                            ; force a specific instruction size for instruction
00000CC6                            d68k_Size	macro size
00000CC6                            	dc.b d68ke_Size, \size
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a specific register with a shift count (bit3 decides between data and address)
00000CC6                            d68k_Reg	macro shift
00000CC6                            	dc.b d68ke_Reg, \shift
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a data register with a shift count
00000CC6                            d68k_DataReg	macro shift
00000CC6                            	dc.b d68ke_DataReg, \shift
00000CC6                                endm
00000CC6                            
00000CC6                            ; print an address register with a shift count
00000CC6                            d68k_AddrReg	macro shift
00000CC6                            	dc.b d68ke_AddrReg, \shift
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a regular addressing mode based on a few stack values and an additional character
00000CC6                            d68k_Mode	macro char
00000CC6                            	dc.b d68ke_Mode, \char
00000CC6                                endm
00000CC6                            
00000CC6                            ; print a regular addressing mode based on a few stack values and an additional character but with different shift values
00000CC6                            d68k_Mode2	macro char
00000CC6                            	dc.b d68ke_Mode2, \char
00000CC6                                endm
00000CC6                            
00000CC6                            ; compare the top of stack with the check value, offset the stack a specific value and if compare matches, jump to address
00000CC6                            d68k_Cmp	macro offset, check, addr
00000CC6                            	dc.b d68ke_Cmp, \offset
00000CC6                            	dc.w \check
00000CC6                            	d68k_Ref	\addr
00000CC6                                endm
00000CC6                            ; ==============================================================
00000CC6                            ; --------------------------------------------------------------
00000CC6                            ; 68k decoder program
00000CC6                            ;
00000CC6                            ; input:
00000CC6                            ;   a0 = destination buffer address
00000CC6                            ;   a1 = source instruction address
00000CC6                            ;
00000CC6                            ; output:
00000CC6                            ;   a0 = next buffer address
00000CC6                            ;   a1 = next instruction address
00000CC6                            ;   buffer = text generated with color highlight, and end token
00000CC6                            ; --------------------------------------------------------------
00000CC6                            
00000CC6                            d68k_HighNibble:
00000CC6                            	d68k_Ref d68k_i0xxx, d68k_iMove, d68k_iMove, d68k_iMove
00000CC6                          M 	rept	narg
00000CC6 0000                     M 	dc.w	d68k_i0xxx-*-2
00000CC8                          M 	shift
00000CC8 0000                     M 	dc.w	d68k_imove-*-2
00000CCA                          M 	shift
00000CCA 0000                     M 	dc.w	d68k_imove-*-2
00000CCC                          M 	shift
00000CCC 0000                     M 	dc.w	d68k_imove-*-2
00000CCE                          M 	shift
00000CCE                            	d68k_Ref d68k_i4xxx, d68k_i5xxx, d68k_iBCC,  d68k_iMoveq
00000CCE                          M 	rept	narg
00000CCE 0000                     M 	dc.w	d68k_i4xxx-*-2
00000CD0                          M 	shift
00000CD0 0000                     M 	dc.w	d68k_i5xxx-*-2
00000CD2                          M 	shift
00000CD2 0000                     M 	dc.w	d68k_ibcc-*-2
00000CD4                          M 	shift
00000CD4 0000                     M 	dc.w	d68k_imoveq-*-2
00000CD6                          M 	shift
00000CD6                            	d68k_Ref d68k_i8xxx, d68k_iSub,  d68k_iData, d68k_iBxxx
00000CD6                          M 	rept	narg
00000CD6 0000                     M 	dc.w	d68k_i8xxx-*-2
00000CD8                          M 	shift
00000CD8 0000                     M 	dc.w	d68k_isub-*-2
00000CDA                          M 	shift
00000CDA 0000                     M 	dc.w	d68k_idata-*-2
00000CDC                          M 	shift
00000CDC 0000                     M 	dc.w	d68k_ibxxx-*-2
00000CDE                          M 	shift
00000CDE                            	d68k_Ref d68k_iCxxx, d68k_iAdd,  d68k_iExxx, d68k_iData
00000CDE                          M 	rept	narg
00000CDE 0000                     M 	dc.w	d68k_icxxx-*-2
00000CE0                          M 	shift
00000CE0 0000                     M 	dc.w	d68k_iadd-*-2
00000CE2                          M 	shift
00000CE2 0000                     M 	dc.w	d68k_iexxx-*-2
00000CE4                          M 	shift
00000CE4 0000                     M 	dc.w	d68k_idata-*-2
00000CE6                          M 	shift
00000CE6                            ; --------------------------------------------------------------
00000CE6                            
00000CE6                            Decode68k:	__global
00000CE6                          M __global__decode68k:
00000CE6                          M decode68k:
00000CE6 23C8 00FF 0004             		move.l	a0,d68k_StoreDst			; store the buffer address (data needs this)
00000CEC 47F9 00FF 000C             		lea	d68k_Stack,a3				; load stack address to a3
00000CF2 10FC 00F8                  		move.b	#_setpat,(a0)+				; PATTERN
00000CF6 10FC 0001                  		move.b	#(VRAM_Font2/$20)>>8,(a0)+		; $01xx
00000CFA                            
00000CFA                            ; --------------------------------------------------------------
00000CFA                            
00000CFA 323C F000                  		move.w	#$F000,d1				; prepare high nibble mask to d1
00000CFE                            
00000CFE 243C 00FF FFFF             		move.l	#$FFFFFF,d2				; prepare high nibble mask to d2
00000D04 2609                       		move.l	a1,d3					; load address to d3
00000D06                            
00000D06 0303                       		btst	d1,d3					; check if misaligned address
00000D08 6600                       		bne.s	.invalid				; branch if yes
00000D0A 0C83 00E0 0000             		cmp.l	#$E00000,d3				; check if this is in RAM
00000D10 6400                       		bhs.s	.valid					; branch if yes
00000D12                            
00000D12 2002                       		move.l	d2,d0					; load nibble mask to d0
00000D14 C0B8 01A0                  		and.l	$1A0.w,d0				; AND start of ROM address
00000D18 B680                       		cmp.l	d0,d3					; check if before start of ROM (should never happen?)
00000D1A 6500                       		blo.s	.invalid				; branch if yes
00000D1C                            
00000D1C 2002                       		move.l	d2,d0					; load nibble mask to d0
00000D1E C0B8 01A4                  		and.l	$1A4.w,d0				; AND end of ROM address
00000D22 B680                       		cmp.l	d0,d3					; check if after end of ROM
00000D24 6500                       		blo.s	.valid					; branch if not
00000D26                            ; --------------------------------------------------------------
00000D26                            
00000D26                            .invalid
00000D26 10FC 00EE                  		move.b	#dcred,(a0)+				; RED
00000D2A 26C9                       		move.l	a1,(a3)+				; copy ROM address to stack
00000D2C 4EBA 0000                  		jsr	d68k_PrintAddr(pc)			; print it
00000D30                            
00000D30 45FA 0000                  		lea	d68k_Invalid(pc),a2			; load invalid script to a2
00000D34 4EFA 0000                  		jmp	d68k_RunScript(pc)			; run this script
00000D38                            
00000D38                            .valid
00000D38                            ; --------------------------------------------------------------
00000D38                            
00000D38 23C9 00FF 0008             		move.l	a1,d68k_StoreSrc			; copy source address to RAM
00000D3E                            
00000D3E 3019                       		move.w	(a1)+,d0				; load the next byte from source
00000D40 C240                       		and.w	d0,d1					; get the highest nibble
00000D42 EB59                       		rol.w	#5,d1					; rotate 6 bits, so each nibble gets a long word
00000D44 45FB 1080                  		lea	d68k_HighNibble(pc,d1.w),a2		; load script data to a2
00000D48                            ; ==============================================================
00000D48                            ; --------------------------------------------------------------
00000D48                            ; Command to jump to another script address
00000D48                            ; --------------------------------------------------------------
00000D48                            
00000D48                            d68k_rJump:
00000D48 D4DA                       		add.w	(a2)+,a2				; add offset to script address
00000D4A                            ; ==============================================================
00000D4A                            ; --------------------------------------------------------------
00000D4A                            ; Run decoder script
00000D4A                            ; --------------------------------------------------------------
00000D4A                            
00000D4A                            d68k_RunScript:
00000D4A 7400                       		moveq	#0,d2
00000D4C 141A                       		move.b	(a2)+,d2				; load next instruction to d2
00000D4E 7200                       		moveq	#0,d1
00000D50 121A                       		move.b	(a2)+,d1				; load argument to d1
00000D52 4881                       		ext.w	d1					; extend to word
00000D54                            
00000D54 343B 2000                  		move.w	.ins(pc,d2.w),d2			; load target offset to d1
00000D58 4EFB 2000                  		jmp	.ins(pc,d2.w)				; execute it
00000D5C                            ; --------------------------------------------------------------
00000D5C                            
00000D5C 0000 FFEC 0000 0000        .ins	dc.w d68k_rExec-.ins, d68k_rJump-.ins, d68k_rFinish-.ins, d68k_rPrint-.ins
00000D64 0000 0000 0000 0000        	dc.w d68k_rPrintNum-.ins, d68k_rReadSrc-.ins, d68k_rRead-.ins, d68k_rInsSz-.ins
00000D6C 0000 0000 0000             	dc.w d68k_rPrintReg-.ins, d68k_rPrintDataReg-.ins, d68k_rPrintAddrReg-.ins
00000D72 0000 0000 0000 0000        	dc.w d68k_rMode-.ins, d68k_rCmp-.ins, d68k_rPrintSmallSize-.ins, d68k_rPush-.ins
00000D7A 0000 0000 0000 0000        	dc.w d68k_rPop-.ins, d68k_rSwap-.ins, d68k_rSize-.ins, d68k_rChar-.ins
00000D82 0000                       	dc.w d68k_rMode2-.ins
00000D84                            ; ==============================================================
00000D84                            ; --------------------------------------------------------------
00000D84                            ; Command to execute ASM code
00000D84                            ; --------------------------------------------------------------
00000D84                            
00000D84                            d68k_rExec:
00000D84 385A                       		move.w	(a2)+,a4				; load next address as the base address
00000D86 D9CA                       		add.l	a2,a4					; add script address to it
00000D88 4ED4                       		jmp	(a4)					; execute the code
00000D8A                            ; ==============================================================
00000D8A                            ; --------------------------------------------------------------
00000D8A                            ; Command to print a string
00000D8A                            ; --------------------------------------------------------------
00000D8A                            
00000D8A                            d68k_rPrint:
00000D8A 385A                       		move.w	(a2)+,a4				; load next address as the base address
00000D8C D9CA                       		add.l	a2,a4					; add script address to it
00000D8E                            
00000D8E                            d68k_rPrint3:
00000D8E 487A FFBA                  		pea	d68k_RunScript(pc)			; run the script later
00000D92                            ; --------------------------------------------------------------
00000D92                            
00000D92                            d68k_rPrint2:
00000D92 4A14                       		tst.b	(a4)					; check the next character
00000D94 6700                       		beq.s	.null					; if null, its the end marker
00000D96 10DC                       		move.b	(a4)+,(a0)+				; copy character into buffer
00000D98 60F8                       		bra.s	d68k_rPrint2
00000D9A                            ; --------------------------------------------------------------
00000D9A                            
00000D9A                            .null
00000D9A 4A01                       		tst.b	d1					; check if there is an extre parameter
00000D9C 6700                       		beq.s	.rts					; if was null, skip this
00000D9E 10C1                       		move.b	d1,(a0)+				; save into buffer
00000DA0                            
00000DA0                            .rts
00000DA0 4E75                       		rts
00000DA2                            ; ==============================================================
00000DA2                            ; --------------------------------------------------------------
00000DA2                            ; Command to print a character
00000DA2                            ; --------------------------------------------------------------
00000DA2                            
00000DA2                            d68k_rChar:
00000DA2 10C1                       		move.b	d1,(a0)+				; save into buffer
00000DA4 6000                       		bra.s	d68k_JumpScript1
00000DA6                            ; ==============================================================
00000DA6                            ; --------------------------------------------------------------
00000DA6                            ; Command to compare stack variable with value and
00000DA6                            ; jump if the same
00000DA6                            ; --------------------------------------------------------------
00000DA6                            
00000DA6                            d68k_rCmp:
00000DA6 342B FFFE                  		move.w	-2(a3),d2				; load value from stack
00000DAA D6C1                       		add.w	d1,a3					; offset stack with parameter
00000DAC                            
00000DAC B45A                       		cmp.w	(a2)+,d2				; check if value is the same
00000DAE 6700 FF98                  		beq.w	d68k_rJump				; if yes, execute a jump
00000DB2 544A                       		addq.w	#2,a2					; skip parameter
00000DB4 6000                       		bra.s	d68k_JumpScript1
00000DB6                            ; ==============================================================
00000DB6                            ; --------------------------------------------------------------
00000DB6                            ; Command to move stack pointer
00000DB6                            ; --------------------------------------------------------------
00000DB6                            
00000DB6                            d68k_rPop:
00000DB6 D6C1                       		add.w	d1,a3					; offset the stack pointer
00000DB8 6000                       		bra.s	d68k_JumpScript1
00000DBA                            ; ==============================================================
00000DBA                            ; --------------------------------------------------------------
00000DBA                            ; Command to read a value from source
00000DBA                            ; --------------------------------------------------------------
00000DBA                            
00000DBA                            d68k_rRead:
00000DBA 3619                       		move.w	(a1)+,d3				; read value from source
00000DBC 6000                       		bra.s	d68k_rRead2				; run common code
00000DBE                            
00000DBE                            d68k_rReadSrc:
00000DBE 3600                       		move.w	d0,d3					; read instruction to d3
00000DC0                            ; --------------------------------------------------------------
00000DC0                            
00000DC0                            d68k_rRead2:
00000DC0 341A                       		move.w	(a2)+,d2				; read AND value from script
00000DC2 C443                       		and.w	d3,d2					; AND with the read value
00000DC4 36C2                       		move.w	d2,(a3)+				; write to stack
00000DC6 51C9 FFF8                  		dbf	d1,d68k_rRead2				; loop for all writes
00000DCA                            ; ==============================================================
00000DCA                            ; --------------------------------------------------------------
00000DCA                            ; Go back to runnin the script
00000DCA                            ; --------------------------------------------------------------
00000DCA                            
00000DCA                            d68k_JumpScript1:
00000DCA 4EFA FF7E                  		jmp	d68k_RunScript(pc)			; run the script now
00000DCE                            ; ==============================================================
00000DCE                            ; --------------------------------------------------------------
00000DCE                            ; Command to push data to stack
00000DCE                            ; --------------------------------------------------------------
00000DCE                            
00000DCE                            d68k_rPush:
00000DCE 36DA                       		move.w	(a2)+,(a3)+				; push value from script
00000DD0 51C9 FFFC                  		dbf	d1,d68k_rPush				; loop for all pushes
00000DD4 60F4                       		bra.s	d68k_JumpScript1			; continue script execute
00000DD6                            ; ==============================================================
00000DD6                            ; --------------------------------------------------------------
00000DD6                            ; Command to swap stack entries
00000DD6                            ; --------------------------------------------------------------
00000DD6                            
00000DD6                            d68k_rSwap:
00000DD6 342B FFFE                  		move.w	-2(a3),d2				; copy stack entry to d2
00000DDA 3773 10FE FFFE             		move.w	-2(a3,d1.w),-2(a3)			; write earlier entry to stack top
00000DE0 3782 10FE                  		move.w	d2,-2(a3,d1.w)				; write the other entry to target
00000DE4 60E4                       		bra.s	d68k_JumpScript1			; continue script execute
00000DE6                            ; ==============================================================
00000DE6                            ; --------------------------------------------------------------
00000DE6                            ; Command to print a number from stack
00000DE6                            ; --------------------------------------------------------------
00000DE6                            
00000DE6                            d68k_rPrintNum:
00000DE6 487A FF62                  		pea	d68k_RunScript(pc)			; run the script later
00000DEA 323B 1000                  		move.w	.tbl(pc,d1.w),d1			; load target offset to d1
00000DEE 4EFB 1000                  		jmp	.tbl(pc,d1.w)				; execute it
00000DF2                            ; --------------------------------------------------------------
00000DF2                            
00000DF2 0000 0000                  .tbl		dc.w d68k_PrintByte-.tbl, d68k_PrintWord-.tbl
00000DF6 0000 0000                  		dc.w d68k_PrintAddr2-.tbl, d68k_PrintLong-.tbl
00000DFA                            ; ==============================================================
00000DFA                            ; --------------------------------------------------------------
00000DFA                            ; Command to print an address as characters
00000DFA                            ; --------------------------------------------------------------
00000DFA                            
00000DFA                            d68k_PrintAddr:
00000DFA 7605                       		moveq	#6-1,d3					; prepare loop count to d3
00000DFC 2223                       		move.l	-(a3),d1				; read data from stack
00000DFE E199                       		rol.l	#8,d1					; skip highest 8 bits
00000E00 6000                       		bra.s	d68k_PrintCom
00000E02                            ; ==============================================================
00000E02                            ; --------------------------------------------------------------
00000E02                            ; Command to print a longword as characters
00000E02                            ; --------------------------------------------------------------
00000E02                            
00000E02                            d68k_PrintLong:
00000E02 7607                       		moveq	#8-1,d3					; prepare loop count to d3
00000E04 2223                       		move.l	-(a3),d1				; read data from stack
00000E06 6000                       		bra.s	d68k_PrintCom
00000E08                            ; ==============================================================
00000E08                            ; --------------------------------------------------------------
00000E08                            ; Command to print a byte as characters
00000E08                            ; --------------------------------------------------------------
00000E08                            
00000E08                            d68k_PrintByte:
00000E08 7601                       		moveq	#2-1,d3					; prepare loop count to d3
00000E0A 3223                       		move.w	-(a3),d1				; read data from stack
00000E0C E099                       		ror.l	#8,d1					; shift into place
00000E0E 6000                       		bra.s	d68k_PrintCom
00000E10                            ; ==============================================================
00000E10                            ; --------------------------------------------------------------
00000E10                            ; Command to print a word as characters
00000E10                            ; --------------------------------------------------------------
00000E10                            
00000E10                            d68k_PrintWord:
00000E10 7603                       		moveq	#4-1,d3					; prepare loop count to d3
00000E12 3223                       		move.w	-(a3),d1				; read data from stack
00000E14 4841                       		swap	d1					; shift 16 bits
00000E16                            ; ==============================================================
00000E16                            ; --------------------------------------------------------------
00000E16                            ; Common routine to print a number as characters
00000E16                            ;
00000E16                            ; input:
00000E16                            ;   d1 = data to write, shifted in place
00000E16                            ;   d3 = character count
00000E16                            ; --------------------------------------------------------------
00000E16                            
00000E16                            d68k_PrintCom:
00000E16 10FC 00EE                  		move.b	#dcred,(a0)+				; RED
00000E1A 10FC 0024                  		move.b	#'$',(a0)+				; print $
00000E1E                            
00000E1E                            .char
00000E1E E999                       		rol.l	#4,d1					; get first 4 bits into view
00000E20 740F                       		moveq	#$F,d2					; get bitmask to d2
00000E22 C441                       		and.w	d1,d2					; get only single digt
00000E24                            
00000E24 10FB 2000                  		move.b	d68k_DigitTbl(pc,d2.w),(a0)+		; load digit into buffer
00000E28 51CB FFF4                  		dbf	d3,.char				; loop for every character
00000E2C 4E75                       		rts
00000E2E                            ; --------------------------------------------------------------
00000E2E                            
00000E2E 3031 3233 3435 3637 3839+  d68k_DigitTbl:	dc.b '0123456789ABCDEF'
00000E3E                            ; ==============================================================
00000E3E                            ; --------------------------------------------------------------
00000E3E                            ; Command to print an address register
00000E3E                            ;
00000E3E                            ; input:
00000E3E                            ;   d2 = register number
00000E3E                            ; --------------------------------------------------------------
00000E3E                            
00000E3E                            d68k_rPrintAddrReg:
00000E3E 6100                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000E40                            
00000E40                            d68k_PrintAddrReg2:
00000E40 487A FF08                  		pea	d68k_RunScript(pc)			; run the script later
00000E44                            
00000E44                            d68k_PrintAddrReg3:
00000E44 10FC 00EA                  		move.b	#dcgreen,(a0)+				; GREEN
00000E48 10FC 0061                  		move.b	#'a',(a0)+				; print a
00000E4C 0242 0007                  		and.w	#7,d2					; keep in range
00000E50 10FB 20DC                  		move.b	d68k_DigitTbl(pc,d2.w),(a0)+		; load number into buffer
00000E54 4E75                       		rts
00000E56                            ; ==============================================================
00000E56                            ; --------------------------------------------------------------
00000E56                            ; Command to print a data register
00000E56                            ;
00000E56                            ; input:
00000E56                            ;   d2 = register number
00000E56                            ; --------------------------------------------------------------
00000E56                            
00000E56                            d68k_rPrintDataReg:
00000E56 6100                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000E58                            
00000E58                            d68k_PrintDataReg2:
00000E58 487A FEF0                  		pea	d68k_RunScript(pc)			; run the script later
00000E5C                            
00000E5C                            d68k_PrintDataReg3:
00000E5C 10FC 00EA                  		move.b	#dcgreen,(a0)+				; GREEN
00000E60 10FC 0064                  		move.b	#'d',(a0)+				; print d
00000E64 0242 0007                  		and.w	#7,d2					; keep in range
00000E68 10FB 20C4                  		move.b	d68k_DigitTbl(pc,d2.w),(a0)+		; load number into buffer
00000E6C 4E75                       		rts
00000E6E                            ; ==============================================================
00000E6E                            ; --------------------------------------------------------------
00000E6E                            ; Command to print a register. If bit4 is set,
00000E6E                            ; its a address register. If clear, data
00000E6E                            ;
00000E6E                            ; input:
00000E6E                            ;   d2 = register number
00000E6E                            ; --------------------------------------------------------------
00000E6E                            
00000E6E                            d68k_rPrintReg:
00000E6E 6100                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000E70                            
00000E70                            d68k_PrintReg2:
00000E70 487A FED8                  		pea	d68k_RunScript(pc)			; run the script later
00000E74                            
00000E74                            d68k_PrintReg3:
00000E74 0882 0003                  		bclr	#3,d2					; check if address or data
00000E78 66CA                       		bne.s	d68k_PrintAddrReg3			; branch if address
00000E7A 60E0                       		bra.s	d68k_PrintDataReg3
00000E7C                            ; ==============================================================
00000E7C                            ; --------------------------------------------------------------
00000E7C                            ; Shift instruction into place according to d1
00000E7C                            ;
00000E7C                            ; input:
00000E7C                            ;   d1 = shift count
00000E7C                            ;
00000E7C                            ; output:
00000E7C                            ;   d2 = result
00000E7C                            ; --------------------------------------------------------------
00000E7C                            
00000E7C                            d68k_ShiftIns:
00000E7C 3400                       		move.w	d0,d2					; copy instruction into d2
00000E7E E26A                       		lsr.w	d1,d2					; shift according to param
00000E80 4E75                       		rts
00000E82                            ; ==============================================================
00000E82                            ; --------------------------------------------------------------
00000E82                            ; Command to load instruction size
00000E82                            ; --------------------------------------------------------------
00000E82                            
00000E82                            d68k_rSize:
00000E82 3C01                       		move.w	d1,d6					; save size to d6
00000E84                            ; ==============================================================
00000E84                            ; --------------------------------------------------------------
00000E84                            ; Go back to runnin the script
00000E84                            ; --------------------------------------------------------------
00000E84                            
00000E84                            d68k_JumpScript2:
00000E84 4EFA FEC4                  		jmp	d68k_RunScript(pc)			; run the script now
00000E88                            ; ==============================================================
00000E88                            ; --------------------------------------------------------------
00000E88                            ; Command to print instruction size
00000E88                            ; --------------------------------------------------------------
00000E88                            
00000E88                            d68k_rInsSz:
00000E88 61F2                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000E8A 0242 0003                  		and.w	#3,d2					; keep in range
00000E8E 1C3B 2000                  		move.b	d68k_InsSize(pc,d2.w),d6		; load instruction size to d6
00000E92                            
00000E92                            d68k_rInsSz2:
00000E92 6700 0000                  		beq.w	d68k_Data				; execute as data
00000E96 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
00000E9A 10FC 002E                  		move.b	#'.',(a0)+				; print .
00000E9E 10C6                       		move.b	d6,(a0)+				; copy it to buffer
00000EA0 60E2                       		bra.s	d68k_JumpScript2
00000EA2                            
00000EA2 6277 6C00                  d68k_InsSize:	dc.b 'bwl', 0
00000EA6                            ; --------------------------------------------------------------
00000EA6                            
00000EA6                            d68k_MoveSz:
00000EA6 720C                       		moveq	#12,d1					; shift 12 bits
00000EA8 61D2                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000EAA                            
00000EAA 0242 0003                  		and.w	#3,d2					; keep in range
00000EAE 1C3B 2000                  		move.b	.size(pc,d2.w),d6			; load instruction size to d6
00000EB2 60DE                       		bra.s	d68k_rInsSz2				; execute common code
00000EB4                            
00000EB4 0062 6C77                  .size		dc.b 0, 'blw'
00000EB8                            ; ==============================================================
00000EB8                            ; --------------------------------------------------------------
00000EB8                            ; Command to check and print instruction mode
00000EB8                            ; --------------------------------------------------------------
00000EB8                            
00000EB8                            d68k_rMode2:
00000EB8 7609                       		moveq	#9,d3					; register shift count 9
00000EBA 7806                       		moveq	#6,d4					; mode shift count 6
00000EBC 6000                       		bra.s	d68k_ModeCom
00000EBE                            
00000EBE                            d68k_rMode:
00000EBE 7600                       		moveq	#0,d3					; register shift count 0
00000EC0 7803                       		moveq	#3,d4					; mode shift count 3
00000EC2                            
00000EC2                            d68k_ModeCom:
00000EC2 4A01                       		tst.b	d1					; check character argument
00000EC4 6700                       		beq.s	.skip					; if was null, skip this
00000EC6 10C1                       		move.b	d1,(a0)+				; save into buffer
00000EC8                            ; --------------------------------------------------------------
00000EC8                            
00000EC8                            .skip
00000EC8 1203                       		move.b	d3,d1					; load the shift count to d1
00000ECA 61B0                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000ECC 7607                       		moveq	#7,d3					; get the register mask
00000ECE 3A03                       		move.w	d3,d5					; copy into d5
00000ED0 C642                       		and.w	d2,d3					; and with the read value
00000ED2                            
00000ED2 1204                       		move.b	d4,d1					; load the shift count to d1
00000ED4 61A6                       		bsr.s	d68k_ShiftIns				; shift instruction into place
00000ED6 C445                       		and.w	d5,d2					; keep mode in range
00000ED8                            
00000ED8 3802                       		move.w	d2,d4					; copy mode to d4
00000EDA B845                       		cmp.w	d5,d4					; check if mode 7
00000EDC 6600                       		bne.s	.not7					; if not, skip
00000EDE D843                       		add.w	d3,d4					; add register to mode check
00000EE0                            
00000EE0                            .not7
00000EE0 3223                       		move.w	-(a3),d1				; load mode check from stack
00000EE2 0901                       		btst	d4,d1					; check if the mode is actually valid
00000EE4 6700 0000                  		beq.w	d68k_Data				; execute as data
00000EE8                            ; --------------------------------------------------------------
00000EE8                            
00000EE8 C742                       		exg	d3,d2					; swap register and mode
00000EEA D643                       		add.w	d3,d3					; double mode
00000EEC 363B 3000                  		move.w	.tbl(pc,d3.w),d3			; load target offset to d1
00000EF0 4EFB 3000                  		jmp	.tbl(pc,d3.w)				; execute it
00000EF4                            ; --------------------------------------------------------------
00000EF4                            
00000EF4 FF64 0000                  .tbl		dc.w d68k_PrintDataReg2-.tbl,  d68k_rModeAreg-.tbl
00000EF8 0000 0000                  		dc.w d68k_rModeAind-.tbl,  d68k_rModeApind-.tbl
00000EFC 0000 0000                  		dc.w d68k_rModeAmind-.tbl, d68k_rModeAoind-.tbl
00000F00 0000 0000                  		dc.w d68k_rModeANXN-.tbl,  .reg-.tbl
00000F04                            ; --------------------------------------------------------------
00000F04                            
00000F04                            .reg
00000F04 D442                       		add.w	d2,d2					; double register
00000F06 343B 2000                  		move.w	.tbl2(pc,d2.w),d2			; load target offset to d1
00000F0A 4EFB 2000                  		jmp	.tbl2(pc,d2.w)				; execute it
00000F0E                            ; --------------------------------------------------------------
00000F0E                            
00000F0E 0000 0000                  .tbl2		dc.w d68k_rModeAddrW-.tbl2, d68k_rModeAddrL-.tbl2
00000F12 0000 0000                  		dc.w d68k_rModePind-.tbl2,  d68k_rModePCXN-.tbl2
00000F16 0000 0000                  		dc.w d68k_rModeImm-.tbl2,   d68k_rModeData2-.tbl2
00000F1A 0000 0000                  		dc.w d68k_rModeData2-.tbl2, d68k_rModeData2-.tbl2
00000F1E                            ; ==============================================================
00000F1E                            ; --------------------------------------------------------------
00000F1E                            ; print address register string
00000F1E                            ; --------------------------------------------------------------
00000F1E                            
00000F1E                            d68k_rModeAreg:
00000F1E 0C06 0062                  		cmp.b	#'b',d6					; check if instruction is a byte instruction
00000F22 6600 FF1C                  		bne.w	d68k_PrintAddrReg2			; if not, branch
00000F26                            
00000F26                            d68k_rModeData2:
00000F26 4EFA 0000                  		jmp	d68k_Data(pc)				; invalid instruction
00000F2A                            ; ==============================================================
00000F2A                            ; --------------------------------------------------------------
00000F2A                            ; print address register and pc-relative indirect string
00000F2A                            ; --------------------------------------------------------------
00000F2A                            
00000F2A                            d68k_rModeAmind:
00000F2A 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000F2E 10FC 002D                  		move.b	#'-',(a0)+				; print -
00000F32 6000                       		bra.s	d68k_rModeAind
00000F34                            ; --------------------------------------------------------------
00000F34                            
00000F34                            d68k_ModeAoind2:
00000F34 3400                       		move.w	d0,d2					; copy instruction to d2
00000F36                            
00000F36                            d68k_rModeAoind:
00000F36 3842                       		move.w	d2,a4					; copy register temporarily
00000F38 36D9                       		move.w	(a1)+,(a3)+				; read word from source
00000F3A 4EBA FED4                  		jsr	d68k_PrintWord(pc)			; print it
00000F3E 340C                       		move.w	a4,d2					; get it back
00000F40                            ; --------------------------------------------------------------
00000F40                            
00000F40                            d68k_rModeAind:
00000F40 487A FE08                  		pea	d68k_RunScript(pc)			; run the script later
00000F44                            
00000F44                            d68k_rModeAind2:
00000F44 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000F48 10FC 0028                  		move.b	#'(',(a0)+				; print (
00000F4C 4EBA FEF6                  		jsr	d68k_PrintAddrReg3(pc)			; write the address register into buffer
00000F50                            
00000F50 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000F54 10FC 0029                  		move.b	#')',(a0)+				; print )
00000F58 4E75                       		rts
00000F5A                            ; --------------------------------------------------------------
00000F5A                            
00000F5A                            d68k_ModeApind2:
00000F5A 3400                       		move.w	d0,d2					; copy instruction to d2
00000F5C 3223                       		move.w	-(a3),d1				; load shfit count to d1
00000F5E E27A                       		ror.w	d1,d2					; rotate according to count
00000F60                            
00000F60                            d68k_rModeApind:
00000F60 61E2                       		bsr.s	d68k_rModeAind2				; write indirect data into buffer
00000F62 10FC 002B                  		move.b	#'+',(a0)+				; print +
00000F66 6000                       		bra.s	d68k_JumpScript3
00000F68                            ; --------------------------------------------------------------
00000F68                            
00000F68                            d68k_rModePind:
00000F68 2849                       		move.l	a1,a4					; copy current address to a4
00000F6A D8D9                       		add.w	(a1)+,a4				; offset with the word
00000F6C 220C                       		move.l	a4,d1					; copy result to d1
00000F6E 4EBA 0000                  		jsr	d68k_ResolveAddr(pc)			; print it
00000F72                            
00000F72 4EBA 0000                  		jsr	d68k_PrintPC(pc)			; print WHITE + (pc
00000F76 10FC 0029                  		move.b	#')',(a0)+				; print )
00000F7A 6000                       		bra.s	d68k_JumpScript3
00000F7C                            ; ==============================================================
00000F7C                            ; --------------------------------------------------------------
00000F7C                            ; print address register indirect and
00000F7C                            ; pc-relative with register displacement
00000F7C                            ; --------------------------------------------------------------
00000F7C                            
00000F7C                            d68k_rModeANXN:
00000F7C 3842                       		move.w	d2,a4					; copy register temporarily
00000F7E 3A19                       		move.w	(a1)+,d5				; read extension word from source
00000F80 36C5                       		move.w	d5,(a3)+				; store it in stack
00000F82 4EBA FE84                  		jsr	d68k_PrintByte(pc)			; print byte displacement
00000F86                            
00000F86 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000F8A 10FC 0028                  		move.b	#'(',(a0)+				; print (
00000F8E 340C                       		move.w	a4,d2					; get regiser back
00000F90 4EBA FEB2                  		jsr	d68k_PrintAddrReg3(pc)			; print address register
00000F94                            ; --------------------------------------------------------------
00000F94                            
00000F94                            d68k_ModeCommXN:
00000F94 3205                       		move.w	d5,d1					; copy extension to d1
00000F96 0241 0700                  		and.w	#$700,d1				; check if any unused bits are set
00000F9A 668A                       		bne.s	d68k_rModeData2				; if yes, its data nao
00000F9C                            
00000F9C 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000FA0 10FC 002C                  		move.b	#',',(a0)+				; print ,
00000FA4                            
00000FA4 3405                       		move.w	d5,d2					; copy extension to d2
00000FA6 E95A                       		rol.w	#4,d2					; get the register bits to low bits
00000FA8 4EBA FECA                  		jsr	d68k_PrintReg3(pc)			; print the register
00000FAC                            
00000FAC 0805 000B                  		btst	#11,d5					; check if this is a longword
00000FB0 56C1                       		sne	d1					; if yes, results in 4
00000FB2 0241 0002                  		and.w	#2,d1					; if not, results in 0
00000FB6                            
00000FB6 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
00000FBA 10FB 1000                  		move.b	d68k_SizeXN(pc,d1.w),(a0)+		; read size into buffer
00000FBE 10FB 1000                  		move.b	d68k_SizeXN+1(pc,d1.w),(a0)+		;
00000FC2                            
00000FC2 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000FC6 10FC 0029                  		move.b	#')',(a0)+				; print )
00000FCA                            ; ==============================================================
00000FCA                            ; --------------------------------------------------------------
00000FCA                            ; Go back to running the script
00000FCA                            ; --------------------------------------------------------------
00000FCA                            
00000FCA                            d68k_JumpScript3:
00000FCA 4EFA FD7E                  		jmp	d68k_RunScript(pc)			; run the script now
00000FCE                            ; ==============================================================
00000FCE                            ; --------------------------------------------------------------
00000FCE                            ; Routine to print (pc to buffer
00000FCE                            ; --------------------------------------------------------------
00000FCE                            
00000FCE                            d68k_PrintPC:
00000FCE 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000FD2 10FC 0028                  		move.b	#'(',(a0)+				; (
00000FD6 10FC 00EA                  		move.b	#dcgreen,(a0)+				; GREEN
00000FDA 10FC 0070                  		move.b	#'p',(a0)+				; pc
00000FDE 10FC 0063                  		move.b	#'c',(a0)+				;
00000FE2 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00000FE6 4E75                       		rts
00000FE8                            ; --------------------------------------------------------------
00000FE8                            
00000FE8                            d68k_rModePCXN:
00000FE8 3219                       		move.w	(a1)+,d1				; read extension word from source
00000FEA 3A01                       		move.w	d1,d5					; copy extension to d4
00000FEC 4881                       		ext.w	d1					; extend byte offset to word
00000FEE 5541                       		subq.w	#2,d1					; account for the word read
00000FF0                            
00000FF0 48C1                       		ext.l	d1					; extend it to longword
00000FF2                            
00000FF2 D289                       		add.l	a1,d1					; add current address to d1
00000FF4 4EBA 0000                  		jsr	d68k_ResolveAddr(pc)			; print resulting address
00000FF8 61D4                       		bsr.s	d68k_PrintPC				; print WHITE + (pc)
00000FFA 6098                       		bra.s	d68k_ModeCommXN				; run the rest of the code the same
00000FFC                            
00000FFC 2E77 2E6C                  d68k_SizeXN:	dc.b '.w.l'
00001000                            ; ==============================================================
00001000                            ; --------------------------------------------------------------
00001000                            ; print direct address word and long
00001000                            ; --------------------------------------------------------------
00001000                            
00001000                            d68k_rPrintSmallSize:
00001000 487A FD48                  		pea	d68k_RunScript(pc)			; run the script later
00001004 0300                       		btst	d1,d0					; check if bit was set
00001006                            
00001006                            d68k_PrintSmallSize2:
00001006 56C6                       		sne	d6					; if yes, results in 4
00001008 0246 0002                  		and.w	#2,d6					; if not, results in 0
0000100C 10FB 60EE                  		move.b	d68k_SizeXN(pc,d6.w),(a0)+		; read size into buffer
00001010 10FB 60EB                  		move.b	d68k_SizeXN+1(pc,d6.w),(a0)+		;
00001014 4E75                       		rts
00001016                            ; ==============================================================
00001016                            ; --------------------------------------------------------------
00001016                            ; print direct address word and long
00001016                            ; --------------------------------------------------------------
00001016                            
00001016                            d68k_rModeAddrW:
00001016 3219                       		move.w	(a1)+,d1				; load address into d1
00001018 48C1                       		ext.l	d1					; extend to longword
0000101A 4EBA 0000                  		jsr	d68k_ResolveAddr(pc)			; print resulting address
0000101E                            
0000101E 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
00001022 10FA FFD8                  		move.b	d68k_SizeXN(pc),(a0)+			; write .w into buffer
00001026 10FA FFD5                  		move.b	d68k_SizeXN+1(pc),(a0)+			;
0000102A 609E                       		bra.s	d68k_JumpScript3
0000102C                            ; --------------------------------------------------------------
0000102C                            
0000102C                            d68k_rModeAddrL:
0000102C 2219                       		move.l	(a1)+,d1				; load address into d1
0000102E 4EBA 0000                  		jsr	d68k_ResolveAddr(pc)			; print resulting address
00001032                            
00001032 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
00001036 10FA FFC6                  		move.b	d68k_SizeXN+2(pc),(a0)+			; write .l into buffer
0000103A 10FA FFC3                  		move.b	d68k_SizeXN+3(pc),(a0)+			;
0000103E 608A                       		bra.s	d68k_JumpScript3
00001040                            ; ==============================================================
00001040                            ; --------------------------------------------------------------
00001040                            ; print direct address word and long
00001040                            ; --------------------------------------------------------------
00001040                            
00001040                            d68k_rModeImm:
00001040 487A FD08                  		pea	d68k_RunScript(pc)			; run the script later
00001044 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001048 10FC 0023                  		move.b	#'#',(a0)+				; print #
0000104C                            
0000104C 0C06 006C                  		cmp.b	#'l',d6					; check if this is a long instruction
00001050 6600                       		bne.s	.ckbyte					; if not, check for byte
00001052 26D9                       		move.l	(a1)+,(a3)+				; load the value from source
00001054 4EFA FDAC                  		jmp	d68k_PrintLong(pc)			; print it
00001058                            ; --------------------------------------------------------------
00001058                            
00001058                            .ckbyte
00001058 36D9                       		move.w	(a1)+,(a3)+				; load the value from source
0000105A 0C06 0062                  		cmp.b	#'b',d6					; check if this is a byte instruction
0000105E 6600 FDB0                  		bne.w	d68k_PrintWord				; if not, its a word
00001062 4EFA FDA4                  		jmp	d68k_PrintByte(pc)			; print it
00001066                            ; ==============================================================
00001066                            ; --------------------------------------------------------------
00001066                            ; Print instruction as a data entry
00001066                            ; --------------------------------------------------------------
00001066                            
00001066                            d68k_iData:	d68k_Exec	d68k_Data			; execute as assembly
00001066 0000                     M 	dc.b	d68ke_exec,0
00001068                          M 	d68k_ref	d68k_data
00001068                          M 	rept	narg
00001068 0000                     M 	dc.w	d68k_data-*-2
0000106A                          M 	shift
0000106A                            
0000106A                            d68k_Data:
0000106A 2079 00FF 0004             		move.l	d68k_StoreDst,a0			; load destination address to a0
00001070 2279 00FF 0008             		move.l	d68k_StoreSrc,a1			; restore original source address
00001076                            
00001076 45FA 0000                  		lea	.script2(pc),a2				; load secondary script to a2
0000107A 4EFA FCCE                  		jmp	d68k_RunScript(pc)			; run the script now
0000107E                            ; --------------------------------------------------------------
0000107E                            
0000107E EC64 632E 7700             .str		dc.b dcblue, 'dc.w', 0
00001084                            		even
00001084                            
00001084                            .script2	d68k_Print	' ', .str			; print the string out
00001084 0620                     M 	dc.b	d68ke_print,' '
00001086                          M 	d68k_ref	.str
00001086                          M 	rept	narg
00001086 FFF6                     M 	dc.w	.str-*-2
00001088                          M 	shift
00001088                            ; ==============================================================
00001088                            ; --------------------------------------------------------------
00001088                            ; Common type 7 instruction handler
00001088                            ; --------------------------------------------------------------
00001088                            
00001088                            d68k_CommonIns7:
00001088                            		d68k_Read	$FFFF				; read the instruction from source
00001088 0C00                     M 	dc.b	d68ke_read,narg-1
0000108A                          M 	rept	narg
0000108A FFFF                     M 	dc.w	$ffff
0000108C                          M 	shift
0000108C                            		d68k_PrintNum	d68kn_Word			; write the word value
0000108C 0802                     M 	dc.b	d68ke_printnum,d68kn_word
0000108E                            		d68k_Finish
0000108E 0400                     M 	dc.b	d68ke_finish,0
00001090                            ; ==============================================================
00001090                            ; --------------------------------------------------------------
00001090                            ; MOVEQ instruction handler
00001090                            ; --------------------------------------------------------------
00001090                            
00001090                            d68k_iMoveq:	d68k_ReadSrc	$100				; read the instruction from source
00001090 0A00                     M 	dc.b	d68ke_readsrc,narg-1
00001092                          M 	rept	narg
00001092 0100                     M 	dc.w	$100
00001094                          M 	shift
00001094                            		d68k_Cmp	-2, $100, d68k_iData		; check if this is invalid, and if so, present as data
00001094 18FE                     M 	dc.b	d68ke_cmp,-2
00001096 0100                     M 	dc.w	$100
00001098                          M 	d68k_ref	d68k_idata
00001098                          M 	rept	narg
00001098 FFCC                     M 	dc.w	d68k_idata-*-2
0000109A                          M 	shift
0000109A                            
0000109A                            		d68k_Print	'q', d68k_sMove			; print MOVEQ
0000109A 0671                     M 	dc.b	d68ke_print,'q'
0000109C                          M 	d68k_ref	d68k_smove
0000109C                          M 	rept	narg
0000109C 0000                     M 	dc.w	d68k_smove-*-2
0000109E                          M 	shift
0000109E                            		d68k_Print	0, d68k_sVal			; print #
0000109E 0600                     M 	dc.b	d68ke_print,0
000010A0                          M 	d68k_ref	d68k_sval
000010A0                          M 	rept	narg
000010A0 0000                     M 	dc.w	d68k_sval-*-2
000010A2                          M 	shift
000010A2                            		d68k_ReadSrc	$FF				; read the instruction from source
000010A2 0A00                     M 	dc.b	d68ke_readsrc,narg-1
000010A4                          M 	rept	narg
000010A4 00FF                     M 	dc.w	$ff
000010A6                          M 	shift
000010A6                            		d68k_PrintNum	d68kn_Byte			; write the byte value
000010A6 0800                     M 	dc.b	d68ke_printnum,d68kn_byte
000010A8                            		d68k_Jump	d68k_WriteReg1			; go to standard handler
000010A8 0200                     M 	dc.b	d68ke_jump,0
000010AA                          M 	d68k_ref	d68k_writereg1
000010AA                          M 	rept	narg
000010AA 0000                     M 	dc.w	d68k_writereg1-*-2
000010AC                          M 	shift
000010AC                            ; ==============================================================
000010AC                            ; --------------------------------------------------------------
000010AC                            ; MOVE instruction handler
000010AC                            ; --------------------------------------------------------------
000010AC                            
000010AC                            d68k_iMove:	d68k_Print	0, d68k_sMove			; print MOVE
000010AC 0600                     M 	dc.b	d68ke_print,0
000010AE                          M 	d68k_ref	d68k_smove
000010AE                          M 	rept	narg
000010AE 0000                     M 	dc.w	d68k_smove-*-2
000010B0                          M 	shift
000010B0                            		d68k_ReadSrc	$1C0				; read the instruction from source
000010B0 0A00                     M 	dc.b	d68ke_readsrc,narg-1
000010B2                          M 	rept	narg
000010B2 01C0                     M 	dc.w	$1c0
000010B4                          M 	shift
000010B4                            		d68k_Cmp	-2, $40, .printa		; check if this is a MOVEA, and if so, print a
000010B4 18FE                     M 	dc.b	d68ke_cmp,-2
000010B6 0040                     M 	dc.w	$40
000010B8                          M 	d68k_ref	.printa
000010B8                          M 	rept	narg
000010B8 0000                     M 	dc.w	.printa-*-2
000010BA                          M 	shift
000010BA                            
000010BA                            .cont
000010BA                            		d68k_Exec	d68k_MoveSz			; load size from assembly
000010BA 0000                     M 	dc.b	d68ke_exec,0
000010BC                          M 	d68k_ref	d68k_movesz
000010BC                          M 	rept	narg
000010BC FDE8                     M 	dc.w	d68k_movesz-*-2
000010BE                          M 	shift
000010BE                            		d68k_Push	$1FF, $FFF			; push check values into stack
000010BE 1C01                     M 	dc.b	d68ke_push,narg-1
000010C0                          M 	rept	narg
000010C0 01FF                     M 	dc.w	$1ff
000010C2                          M 	shift
000010C2 0FFF                     M 	dc.w	$fff
000010C4                          M 	shift
000010C4                            		d68k_Mode	' '				; print source addressing mode
000010C4 1620                     M 	dc.b	d68ke_mode,' '
000010C6                            		d68k_Print	0, d68k_sComma			; print ,
000010C6 0600                     M 	dc.b	d68ke_print,0
000010C8                          M 	d68k_ref	d68k_scomma
000010C8                          M 	rept	narg
000010C8 0000                     M 	dc.w	d68k_scomma-*-2
000010CA                          M 	shift
000010CA                            		d68k_Mode2	0				; print destination addressing mode
000010CA 2600                     M 	dc.b	d68ke_mode2,0
000010CC                            		d68k_Finish
000010CC 0400                     M 	dc.b	d68ke_finish,0
000010CE                            
000010CE                            .printa		d68k_Print	0, d68k_sA			; print A
000010CE 0600                     M 	dc.b	d68ke_print,0
000010D0                          M 	d68k_ref	d68k_sa
000010D0                          M 	rept	narg
000010D0 0000                     M 	dc.w	d68k_sa-*-2
000010D2                          M 	shift
000010D2                            		d68k_Jump	.cont				; run rest of the code
000010D2 0200                     M 	dc.b	d68ke_jump,0
000010D4                          M 	d68k_ref	.cont
000010D4                          M 	rept	narg
000010D4 FFE4                     M 	dc.w	.cont-*-2
000010D6                          M 	shift
000010D6                            ; ==============================================================
000010D6                            ; --------------------------------------------------------------
000010D6                            ; ADD and SUB instruction handlers
000010D6                            ; --------------------------------------------------------------
000010D6                            
000010D6                            d68k_iAdd:	d68k_Print	0, d68k_sAdd			; print ADD
000010D6 0600                     M 	dc.b	d68ke_print,0
000010D8                          M 	d68k_ref	d68k_sadd
000010D8                          M 	rept	narg
000010D8 0000                     M 	dc.w	d68k_sadd-*-2
000010DA                          M 	shift
000010DA                            		d68k_Jump	d68k_iAddSub			; add and sub share code
000010DA 0200                     M 	dc.b	d68ke_jump,0
000010DC                          M 	d68k_ref	d68k_iaddsub
000010DC                          M 	rept	narg
000010DC 0000                     M 	dc.w	d68k_iaddsub-*-2
000010DE                          M 	shift
000010DE                            
000010DE                            
000010DE                            d68k_iSub:	d68k_Print	0, d68k_sSub			; print SUB
000010DE 0600                     M 	dc.b	d68ke_print,0
000010E0                          M 	d68k_ref	d68k_ssub
000010E0                          M 	rept	narg
000010E0 0000                     M 	dc.w	d68k_ssub-*-2
000010E2                          M 	shift
000010E2                            ; --------------------------------------------------------------
000010E2                            
000010E2                            d68k_iAddSub:	d68k_ReadSrc	$130, $C0 			; read the instruction from source
000010E2 0A01                     M 	dc.b	d68ke_readsrc,narg-1
000010E4                          M 	rept	narg
000010E4 0130                     M 	dc.w	$130
000010E6                          M 	shift
000010E6 00C0                     M 	dc.w	$c0
000010E8                          M 	shift
000010E8                            		d68k_Cmp	-2, $C0, .adda			; check if this is a ADDA/SUBA, and brach if yes
000010E8 18FE                     M 	dc.b	d68ke_cmp,-2
000010EA 00C0                     M 	dc.w	$c0
000010EC                          M 	d68k_ref	.adda
000010EC                          M 	rept	narg
000010EC 0000                     M 	dc.w	.adda-*-2
000010EE                          M 	shift
000010EE                            		d68k_Cmp	-2, $100, .addx			; check if this is a ADDX/SUBX, and brach if yes
000010EE 18FE                     M 	dc.b	d68ke_cmp,-2
000010F0 0100                     M 	dc.w	$100
000010F2                          M 	d68k_ref	.addx
000010F2                          M 	rept	narg
000010F2 0000                     M 	dc.w	.addx-*-2
000010F4                          M 	shift
000010F4                            		d68k_Push	$FFF, $1FD			; push check values into stack
000010F4 1C01                     M 	dc.b	d68ke_push,narg-1
000010F6                          M 	rept	narg
000010F6 0FFF                     M 	dc.w	$fff
000010F8                          M 	shift
000010F8 01FD                     M 	dc.w	$1fd
000010FA                          M 	shift
000010FA                            		d68k_Jump	d68k_CommonIns1			; common instruction type 1
000010FA 0200                     M 	dc.b	d68ke_jump,0
000010FC                          M 	d68k_ref	d68k_commonins1
000010FC                          M 	rept	narg
000010FC 0000                     M 	dc.w	d68k_commonins1-*-2
000010FE                          M 	shift
000010FE                            ; --------------------------------------------------------------
000010FE                            
000010FE                            .adda		d68k_Print	0, d68k_sA			; print A
000010FE 0600                     M 	dc.b	d68ke_print,0
00001100                          M 	d68k_ref	d68k_sa
00001100                          M 	rept	narg
00001100 0000                     M 	dc.w	d68k_sa-*-2
00001102                          M 	shift
00001102                            		d68k_SmallSz	8				; print small instruction size
00001102 1A08                     M 	dc.b	d68ke_smallsz,8
00001104                            		d68k_Push	$FFF				; push check value into stack
00001104 1C00                     M 	dc.b	d68ke_push,narg-1
00001106                          M 	rept	narg
00001106 0FFF                     M 	dc.w	$fff
00001108                          M 	shift
00001108                            		d68k_Mode	' '				; print source addressing mode
00001108 1620                     M 	dc.b	d68ke_mode,' '
0000110A                            		d68k_Jump	d68k_CommonIns6			; go to standard handler
0000110A 0200                     M 	dc.b	d68ke_jump,0
0000110C                          M 	d68k_ref	d68k_commonins6
0000110C                          M 	rept	narg
0000110C 0000                     M 	dc.w	d68k_commonins6-*-2
0000110E                          M 	shift
0000110E                            ; --------------------------------------------------------------
0000110E                            
0000110E                            .addx		d68k_Print	0, d68k_sX			; print X
0000110E 0600                     M 	dc.b	d68ke_print,0
00001110                          M 	d68k_ref	d68k_sx
00001110                          M 	rept	narg
00001110 0000                     M 	dc.w	d68k_sx-*-2
00001112                          M 	shift
00001112                            		d68k_InsSz	6				; print instruction size
00001112 0E06                     M 	dc.b	d68ke_inssz,6
00001114                            ; ==============================================================
00001114                            ; --------------------------------------------------------------
00001114                            ; Write standard -(AN),-(AN) or DN,DN register pair
00001114                            ; --------------------------------------------------------------
00001114                            
00001114                            d68k_iSpecialReg:
00001114                            		d68k_Exec	d68k_SpecialReg			; load special register pair from assembly
00001114 0000                     M 	dc.b	d68ke_exec,0
00001116                          M 	d68k_ref	d68k_specialreg
00001116                          M 	rept	narg
00001116 0000                     M 	dc.w	d68k_specialreg-*-2
00001118                          M 	shift
00001118                            		d68k_Finish
00001118 0400                     M 	dc.b	d68ke_finish,0
0000111A                            ; --------------------------------------------------------------
0000111A                            
0000111A                            d68k_SpecialReg:
0000111A 3400                       		move.w	d0,d2					; copy instruction to d2
0000111C 3600                       		move.w	d0,d3					; copy instruction to d3
0000111E EF5B                       		rol.w	#16-9,d3				; rotate register into place
00001120                            
00001120 10FC 0020                  		move.b	#' ',(a0)+				; print a space
00001124 0800 0003                  		btst	#3,d0					; check if this is DN,DN
00001128 6600                       		bne.s	.anan					; if not, branch
0000112A                            ; --------------------------------------------------------------
0000112A                            
0000112A 4EBA FD30                  		jsr	d68k_PrintDataReg3(pc)			; print source register
0000112E 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001132 10FC 002C                  		move.b	#',',(a0)+				; print a ,
00001136                            
00001136 3403                       		move.w	d3,d2					; copy destination register to d2
00001138 4EBA FD22                  		jsr	d68k_PrintDataReg3(pc)			; print it
0000113C 6000                       		bra.s	.runs
0000113E                            ; --------------------------------------------------------------
0000113E                            
0000113E                            .anan
0000113E 6100                       		bsr.s	.printan				; write source register
00001140 3403                       		move.w	d3,d2					; copy destination register to d1
00001142 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001146 10FC 002C                  		move.b	#',',(a0)+				; print a ,
0000114A 6100                       		bsr.s	.printan				; write destination register
0000114C                            
0000114C                            .runs
0000114C 4EFA FBFC                  		jmp	d68k_RunScript(pc)			; run the script now
00001150                            ; --------------------------------------------------------------
00001150                            
00001150                            .printan
00001150 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001154 10FC 002D                  		move.b	#'-',(a0)+				; print a -
00001158 10FC 0028                  		move.b	#'(',(a0)+				; print a (
0000115C                            
0000115C 4EBA FCE6                  		jsr	d68k_PrintAddrReg3(pc)			; print address register
00001160 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001164 10FC 0029                  		move.b	#')',(a0)+				; print a )
00001168 4E75                       		rts
0000116A                            ; ==============================================================
0000116A                            ; --------------------------------------------------------------
0000116A                            ; CXXX instruction handler
0000116A                            ; --------------------------------------------------------------
0000116A                            
0000116A                            d68k_iCxxx:	d68k_ReadSrc	$F8, $38, $1F0, $1C0		; read the instruction from source
0000116A 0A03                     M 	dc.b	d68ke_readsrc,narg-1
0000116C                          M 	rept	narg
0000116C 00F8                     M 	dc.w	$f8
0000116E                          M 	shift
0000116E 0038                     M 	dc.w	$38
00001170                          M 	shift
00001170 01F0                     M 	dc.w	$1f0
00001172                          M 	shift
00001172 01C0                     M 	dc.w	$1c0
00001174                          M 	shift
00001174                            		d68k_Cmp	0, $0C0, d68k_iMulu		; check if DIVU, and if so, branch
00001174 1800                     M 	dc.b	d68ke_cmp,0
00001176 00C0                     M 	dc.w	$0c0
00001178                          M 	d68k_ref	d68k_imulu
00001178                          M 	rept	narg
00001178 0000                     M 	dc.w	d68k_imulu-*-2
0000117A                          M 	shift
0000117A                            		d68k_Cmp	-2, $1C0, d68k_iMuls		; check if DIVS, and if so, branch
0000117A 18FE                     M 	dc.b	d68ke_cmp,-2
0000117C 01C0                     M 	dc.w	$1c0
0000117E                          M 	d68k_ref	d68k_imuls
0000117E                          M 	rept	narg
0000117E 0000                     M 	dc.w	d68k_imuls-*-2
00001180                          M 	shift
00001180                            		d68k_Cmp	-2, $100, d68k_iAbcd		; check if ABCD, and if so, branch
00001180 18FE                     M 	dc.b	d68ke_cmp,-2
00001182 0100                     M 	dc.w	$100
00001184                          M 	d68k_ref	d68k_iabcd
00001184                          M 	rept	narg
00001184 0000                     M 	dc.w	d68k_iabcd-*-2
00001186                          M 	shift
00001186                            
00001186                            		d68k_Pop	4				; go check the last check value
00001186 1E04                     M 	dc.b	d68ke_pop,4
00001188                            		d68k_Cmp	0, $140, .chk			; check if EXG, and if so, branch
00001188 1800                     M 	dc.b	d68ke_cmp,0
0000118A 0140                     M 	dc.w	$140
0000118C                          M 	d68k_ref	.chk
0000118C                          M 	rept	narg
0000118C 0000                     M 	dc.w	.chk-*-2
0000118E                          M 	shift
0000118E                            		d68k_Cmp	0, $180, .chk			; check if EXG, and if so, branch
0000118E 1800                     M 	dc.b	d68ke_cmp,0
00001190 0180                     M 	dc.w	$180
00001192                          M 	d68k_ref	.chk
00001192                          M 	rept	narg
00001192 0000                     M 	dc.w	.chk-*-2
00001194                          M 	shift
00001194                            	;	d68k_Cmp	0, $1C0, .chk			; check if EXG, and if so, branch
00001194                            		d68k_Jump	d68k_iAnd			; go to AND code
00001194 0200                     M 	dc.b	d68ke_jump,0
00001196                          M 	d68k_ref	d68k_iand
00001196                          M 	rept	narg
00001196 0000                     M 	dc.w	d68k_iand-*-2
00001198                          M 	shift
00001198                            ; --------------------------------------------------------------
00001198                            
00001198                            .chk		d68k_Pop	-4				; go check the last check value
00001198 1EFC                     M 	dc.b	d68ke_pop,-4
0000119A                            		d68k_Cmp	0, $00, d68k_iExg		; check if AND, and if so, branch
0000119A 1800                     M 	dc.b	d68ke_cmp,0
0000119C 0000                     M 	dc.w	$00
0000119E                          M 	d68k_ref	d68k_iexg
0000119E                          M 	rept	narg
0000119E 0000                     M 	dc.w	d68k_iexg-*-2
000011A0                          M 	shift
000011A0                            		d68k_Cmp	0, $08, d68k_iExg		; check if AND, and if so, branch
000011A0 1800                     M 	dc.b	d68ke_cmp,0
000011A2 0008                     M 	dc.w	$08
000011A4                          M 	d68k_ref	d68k_iexg
000011A4                          M 	rept	narg
000011A4 0000                     M 	dc.w	d68k_iexg-*-2
000011A6                          M 	shift
000011A6                            
000011A6                            d68k_iAnd:	d68k_Print	0, d68k_sAnd			; print AND
000011A6 0600                     M 	dc.b	d68ke_print,0
000011A8                          M 	d68k_ref	d68k_sand
000011A8                          M 	rept	narg
000011A8 0000                     M 	dc.w	d68k_sand-*-2
000011AA                          M 	shift
000011AA                            		d68k_Push	$FFD, $1FD			; push check values into stack
000011AA 1C01                     M 	dc.b	d68ke_push,narg-1
000011AC                          M 	rept	narg
000011AC 0FFD                     M 	dc.w	$ffd
000011AE                          M 	shift
000011AE 01FD                     M 	dc.w	$1fd
000011B0                          M 	shift
000011B0                            		d68k_Jump	d68k_CommonIns1			; common instruction type 1
000011B0 0200                     M 	dc.b	d68ke_jump,0
000011B2                          M 	d68k_ref	d68k_commonins1
000011B2                          M 	rept	narg
000011B2 0000                     M 	dc.w	d68k_commonins1-*-2
000011B4                          M 	shift
000011B4                            ; ==============================================================
000011B4                            ; --------------------------------------------------------------
000011B4                            ; EXG instruction handler
000011B4                            ; --------------------------------------------------------------
000011B4                            
000011B4                            d68k_iExg:	d68k_Print	' ', d68k_sExg			; print EXG
000011B4 0620                     M 	dc.b	d68ke_print,' '
000011B6                          M 	d68k_ref	d68k_sexg
000011B6                          M 	rept	narg
000011B6 0000                     M 	dc.w	d68k_sexg-*-2
000011B8                          M 	shift
000011B8                            		d68k_Pop	-2				; go check the last check value
000011B8 1EFE                     M 	dc.b	d68ke_pop,-2
000011BA                            		d68k_Cmp	0, $48, .an1			; check if AN <-> AN, and if so, branch
000011BA 1800                     M 	dc.b	d68ke_cmp,0
000011BC 0048                     M 	dc.w	$48
000011BE                          M 	d68k_ref	.an1
000011BE                          M 	rept	narg
000011BE 0000                     M 	dc.w	.an1-*-2
000011C0                          M 	shift
000011C0                            		d68k_Cmp	0, $40, .dn1			; check if DN <-> DN, and if so, branch
000011C0 1800                     M 	dc.b	d68ke_cmp,0
000011C2 0040                     M 	dc.w	$40
000011C4                          M 	d68k_ref	.dn1
000011C4                          M 	rept	narg
000011C4 0000                     M 	dc.w	.dn1-*-2
000011C6                          M 	shift
000011C6                            		d68k_Cmp	0, $88, .dn1			; check if DN <-> AN, and if so, branch
000011C6 1800                     M 	dc.b	d68ke_cmp,0
000011C8 0088                     M 	dc.w	$88
000011CA                          M 	d68k_ref	.dn1
000011CA                          M 	rept	narg
000011CA 0000                     M 	dc.w	.dn1-*-2
000011CC                          M 	shift
000011CC                            		d68k_Jump	d68k_iData			; invalid mode
000011CC 0200                     M 	dc.b	d68ke_jump,0
000011CE                          M 	d68k_ref	d68k_idata
000011CE                          M 	rept	narg
000011CE FE96                     M 	dc.w	d68k_idata-*-2
000011D0                          M 	shift
000011D0                            ; --------------------------------------------------------------
000011D0                            
000011D0                            .an1		d68k_AddrReg	9				; print areg
000011D0 1409                     M 	dc.b	d68ke_addrreg,9
000011D2                            		d68k_Jump	.common1			; run common code
000011D2 0200                     M 	dc.b	d68ke_jump,0
000011D4                          M 	d68k_ref	.common1
000011D4                          M 	rept	narg
000011D4 0000                     M 	dc.w	.common1-*-2
000011D6                          M 	shift
000011D6                            
000011D6                            .dn1		d68k_DataReg	9				; print dreg
000011D6 1209                     M 	dc.b	d68ke_datareg,9
000011D8                            
000011D8                            .common1	d68k_Print	0, d68k_sComma			; print ,
000011D8 0600                     M 	dc.b	d68ke_print,0
000011DA                          M 	d68k_ref	d68k_scomma
000011DA                          M 	rept	narg
000011DA 0000                     M 	dc.w	d68k_scomma-*-2
000011DC                          M 	shift
000011DC                            		d68k_Cmp	0, $40, d68k_CommonIns9		; check if DN <-> DN, and if so, branch
000011DC 1800                     M 	dc.b	d68ke_cmp,0
000011DE 0040                     M 	dc.w	$40
000011E0                          M 	d68k_ref	d68k_commonins9
000011E0                          M 	rept	narg
000011E0 0000                     M 	dc.w	d68k_commonins9-*-2
000011E2                          M 	shift
000011E2                            ; ==============================================================
000011E2                            ; --------------------------------------------------------------
000011E2                            ; Common type 10 instruction handler
000011E2                            ; --------------------------------------------------------------
000011E2                            
000011E2                            d68k_CommonIns10:
000011E2                            		d68k_AddrReg	0				; print areg
000011E2 1400                     M 	dc.b	d68ke_addrreg,0
000011E4                            		d68k_Finish
000011E4 0400                     M 	dc.b	d68ke_finish,0
000011E6                            ; ==============================================================
000011E6                            ; --------------------------------------------------------------
000011E6                            ; XBCD instruction handlers
000011E6                            ; --------------------------------------------------------------
000011E6                            
000011E6                            d68k_iAbcd:	d68k_Print	0, d68k_sA			; print a
000011E6 0600                     M 	dc.b	d68ke_print,0
000011E8                          M 	d68k_ref	d68k_sa
000011E8                          M 	rept	narg
000011E8 0000                     M 	dc.w	d68k_sa-*-2
000011EA                          M 	shift
000011EA                            		d68k_Jump	d68k_iSAbcd			; go to common code
000011EA 0200                     M 	dc.b	d68ke_jump,0
000011EC                          M 	d68k_ref	d68k_isabcd
000011EC                          M 	rept	narg
000011EC 0000                     M 	dc.w	d68k_isabcd-*-2
000011EE                          M 	shift
000011EE                            
000011EE                            d68k_iSbcd:	d68k_Print	0, d68k_sS			; print s
000011EE 0600                     M 	dc.b	d68ke_print,0
000011F0                          M 	d68k_ref	d68k_ss
000011F0                          M 	rept	narg
000011F0 0000                     M 	dc.w	d68k_ss-*-2
000011F2                          M 	shift
000011F2                            
000011F2                            d68k_iSAbcd:	d68k_Print	0, d68k_sBcd
000011F2 0600                     M 	dc.b	d68ke_print,0
000011F4                          M 	d68k_ref	d68k_sbcd
000011F4                          M 	rept	narg
000011F4 0000                     M 	dc.w	d68k_sbcd-*-2
000011F6                          M 	shift
000011F6                            		d68k_Jump	d68k_iSpecialReg		; load special register pair from assembly
000011F6 0200                     M 	dc.b	d68ke_jump,0
000011F8                          M 	d68k_ref	d68k_ispecialreg
000011F8                          M 	rept	narg
000011F8 FF1A                     M 	dc.w	d68k_ispecialreg-*-2
000011FA                          M 	shift
000011FA                            ; ==============================================================
000011FA                            ; --------------------------------------------------------------
000011FA                            ; MULX and DIVX instruction handlers
000011FA                            ; --------------------------------------------------------------
000011FA                            
000011FA                            d68k_iDivu:	d68k_Print	'u', d68k_sDiv			; print DIVU
000011FA 0675                     M 	dc.b	d68ke_print,'u'
000011FC                          M 	d68k_ref	d68k_sdiv
000011FC                          M 	rept	narg
000011FC 0000                     M 	dc.w	d68k_sdiv-*-2
000011FE                          M 	shift
000011FE                            		d68k_Jump	d68k_iMulDiv			; go to common code
000011FE 0200                     M 	dc.b	d68ke_jump,0
00001200                          M 	d68k_ref	d68k_imuldiv
00001200                          M 	rept	narg
00001200 0000                     M 	dc.w	d68k_imuldiv-*-2
00001202                          M 	shift
00001202                            ; --------------------------------------------------------------
00001202                            
00001202                            d68k_iDivs:	d68k_Print	's', d68k_sDiv			; print DIVS
00001202 0673                     M 	dc.b	d68ke_print,'s'
00001204                          M 	d68k_ref	d68k_sdiv
00001204                          M 	rept	narg
00001204 0000                     M 	dc.w	d68k_sdiv-*-2
00001206                          M 	shift
00001206                            		d68k_Jump	d68k_iMulDiv			; go to common code
00001206 0200                     M 	dc.b	d68ke_jump,0
00001208                          M 	d68k_ref	d68k_imuldiv
00001208                          M 	rept	narg
00001208 0000                     M 	dc.w	d68k_imuldiv-*-2
0000120A                          M 	shift
0000120A                            ; --------------------------------------------------------------
0000120A                            
0000120A                            d68k_iMulu:	d68k_Print	'u', d68k_sMul			; print MULU
0000120A 0675                     M 	dc.b	d68ke_print,'u'
0000120C                          M 	d68k_ref	d68k_smul
0000120C                          M 	rept	narg
0000120C 0000                     M 	dc.w	d68k_smul-*-2
0000120E                          M 	shift
0000120E                            		d68k_Jump	d68k_iMulDiv			; go to common code
0000120E 0200                     M 	dc.b	d68ke_jump,0
00001210                          M 	d68k_ref	d68k_imuldiv
00001210                          M 	rept	narg
00001210 0000                     M 	dc.w	d68k_imuldiv-*-2
00001212                          M 	shift
00001212                            ; --------------------------------------------------------------
00001212                            
00001212                            d68k_iMuls:	d68k_Print	's', d68k_sMul			; print MULS
00001212 0673                     M 	dc.b	d68ke_print,'s'
00001214                          M 	d68k_ref	d68k_smul
00001214                          M 	rept	narg
00001214 0000                     M 	dc.w	d68k_smul-*-2
00001216                          M 	shift
00001216                            ; --------------------------------------------------------------
00001216                            
00001216                            d68k_iMulDiv:	d68k_Size	'w'				; set instruction size
00001216 2277                     M 	dc.b	d68ke_size,'w'
00001218                            		d68k_Push	$FFD				; push check value into stack
00001218 1C00                     M 	dc.b	d68ke_push,narg-1
0000121A                          M 	rept	narg
0000121A 0FFD                     M 	dc.w	$ffd
0000121C                          M 	shift
0000121C                            		d68k_Jump	d68k_WriteReg2			; go to standard handler
0000121C 0200                     M 	dc.b	d68ke_jump,0
0000121E                          M 	d68k_ref	d68k_writereg2
0000121E                          M 	rept	narg
0000121E 0000                     M 	dc.w	d68k_writereg2-*-2
00001220                          M 	shift
00001220                            ; ==============================================================
00001220                            ; --------------------------------------------------------------
00001220                            ; 8XXX instruction handler
00001220                            ; --------------------------------------------------------------
00001220                            
00001220                            d68k_i8xxx:	d68k_ReadSrc	$38, $1F0, $1C0			; read the instruction from source
00001220 0A02                     M 	dc.b	d68ke_readsrc,narg-1
00001222                          M 	rept	narg
00001222 0038                     M 	dc.w	$38
00001224                          M 	shift
00001224 01F0                     M 	dc.w	$1f0
00001226                          M 	shift
00001226 01C0                     M 	dc.w	$1c0
00001228                          M 	shift
00001228                            		d68k_Cmp	0, $0C0, d68k_iDivu		; check if DIVU, and if so, branch
00001228 1800                     M 	dc.b	d68ke_cmp,0
0000122A 00C0                     M 	dc.w	$0c0
0000122C                          M 	d68k_ref	d68k_idivu
0000122C                          M 	rept	narg
0000122C FFCC                     M 	dc.w	d68k_idivu-*-2
0000122E                          M 	shift
0000122E                            		d68k_Cmp	-2, $1C0, d68k_iDivs		; check if DIVS, and if so, branch
0000122E 18FE                     M 	dc.b	d68ke_cmp,-2
00001230 01C0                     M 	dc.w	$1c0
00001232                          M 	d68k_ref	d68k_idivs
00001232                          M 	rept	narg
00001232 FFCE                     M 	dc.w	d68k_idivs-*-2
00001234                          M 	shift
00001234                            		d68k_Cmp	-2, $100, d68k_iSbcd		; check if SBCD, and if so, branch
00001234 18FE                     M 	dc.b	d68ke_cmp,-2
00001236 0100                     M 	dc.w	$100
00001238                          M 	d68k_ref	d68k_isbcd
00001238                          M 	rept	narg
00001238 FFB4                     M 	dc.w	d68k_isbcd-*-2
0000123A                          M 	shift
0000123A                            
0000123A                            	; OR
0000123A                            		d68k_Print	0, d68k_sOr			; print OR
0000123A 0600                     M 	dc.b	d68ke_print,0
0000123C                          M 	d68k_ref	d68k_sor
0000123C                          M 	rept	narg
0000123C 0000                     M 	dc.w	d68k_sor-*-2
0000123E                          M 	shift
0000123E                            		d68k_Push	$FFD, $1FD			; push check values into stack
0000123E 1C01                     M 	dc.b	d68ke_push,narg-1
00001240                          M 	rept	narg
00001240 0FFD                     M 	dc.w	$ffd
00001242                          M 	shift
00001242 01FD                     M 	dc.w	$1fd
00001244                          M 	shift
00001244                            ; ==============================================================
00001244                            ; --------------------------------------------------------------
00001244                            ; Common type 1 instruction handler
00001244                            ; --------------------------------------------------------------
00001244                            
00001244                            d68k_CommonIns1:
00001244                            		d68k_InsSz	6				; print instruction size
00001244 0E06                     M 	dc.b	d68ke_inssz,6
00001246                            		d68k_Char	' '				; print space
00001246 2420                     M 	dc.b	d68ke_char,' '
00001248                            		d68k_ReadSrc	$100, $100 			; read the instruction from source
00001248 0A01                     M 	dc.b	d68ke_readsrc,narg-1
0000124A                          M 	rept	narg
0000124A 0100                     M 	dc.w	$100
0000124C                          M 	shift
0000124C 0100                     M 	dc.w	$100
0000124E                          M 	shift
0000124E                            
0000124E                            	; stack: EA, EA, INS, INS
0000124E                            		d68k_Swap	-6				; swap with the last entry
0000124E 20FA                     M 	dc.b	d68ke_swap,-6
00001250                            	; stack: INS, EA, INS, EA
00001250                            		d68k_Swap	-2				; swap with the first value
00001250 20FE                     M 	dc.b	d68ke_swap,-2
00001252                            	; stack: INS, EA, EA, INS
00001252                            		d68k_Cmp	-2, $000, .skip			; check if EA -> DN, and if so, branch
00001252 18FE                     M 	dc.b	d68ke_cmp,-2
00001254 0000                     M 	dc.w	$000
00001256                          M 	d68k_ref	.skip
00001256                          M 	rept	narg
00001256 0000                     M 	dc.w	.skip-*-2
00001258                          M 	shift
00001258                            
00001258                            		d68k_Swap	-2				; swap the first entry out (use second entry for mode check)
00001258 20FE                     M 	dc.b	d68ke_swap,-2
0000125A                            		d68k_DataReg	9				; print dreg
0000125A 1209                     M 	dc.b	d68ke_datareg,9
0000125C                            		d68k_Print	0, d68k_sComma			; print ,
0000125C 0600                     M 	dc.b	d68ke_print,0
0000125E                          M 	d68k_ref	d68k_scomma
0000125E                          M 	rept	narg
0000125E 0000                     M 	dc.w	d68k_scomma-*-2
00001260                          M 	shift
00001260                            
00001260                            .skip	; stack: INS, EA, EA
00001260                            		d68k_Mode	0				; print addressing mode
00001260 1600                     M 	dc.b	d68ke_mode,0
00001262                            		d68k_Pop	-2				; pop both EA entries out
00001262 1EFE                     M 	dc.b	d68ke_pop,-2
00001264                            		d68k_Cmp	-2, $100, d68k_Finish1		; check if DN -> EA, and if so, branch
00001264 18FE                     M 	dc.b	d68ke_cmp,-2
00001266 0100                     M 	dc.w	$100
00001268                          M 	d68k_ref	d68k_finish1
00001268                          M 	rept	narg
00001268 0000                     M 	dc.w	d68k_finish1-*-2
0000126A                          M 	shift
0000126A                            ; ==============================================================
0000126A                            ; --------------------------------------------------------------
0000126A                            ; Standard register write
0000126A                            ; --------------------------------------------------------------
0000126A                            
0000126A                            d68k_WriteReg1:
0000126A                            		d68k_Print	0, d68k_sComma			; print ,
0000126A 0600                     M 	dc.b	d68ke_print,0
0000126C                          M 	d68k_ref	d68k_scomma
0000126C                          M 	rept	narg
0000126C 0000                     M 	dc.w	d68k_scomma-*-2
0000126E                          M 	shift
0000126E                            		d68k_DataReg	9				; print dreg
0000126E 1209                     M 	dc.b	d68ke_datareg,9
00001270                            
00001270                            d68k_Finish1:
00001270                            		d68k_Finish
00001270 0400                     M 	dc.b	d68ke_finish,0
00001272                            
00001272                            d68k_WriteReg2:
00001272                            		d68k_Mode	' '				; print source addressing mode
00001272 1620                     M 	dc.b	d68ke_mode,' '
00001274                            		d68k_Jump	d68k_WriteReg1			; go to standard handler
00001274 0200                     M 	dc.b	d68ke_jump,0
00001276                          M 	d68k_ref	d68k_writereg1
00001276                          M 	rept	narg
00001276 FFF2                     M 	dc.w	d68k_writereg1-*-2
00001278                          M 	shift
00001278                            ; ==============================================================
00001278                            ; --------------------------------------------------------------
00001278                            ; BXXX instruction handler
00001278                            ; --------------------------------------------------------------
00001278                            
00001278                            d68k_iBxxx:	d68k_ReadSrc	$38, $100, $C0			; read the instruction from source
00001278 0A02                     M 	dc.b	d68ke_readsrc,narg-1
0000127A                          M 	rept	narg
0000127A 0038                     M 	dc.w	$38
0000127C                          M 	shift
0000127C 0100                     M 	dc.w	$100
0000127E                          M 	shift
0000127E 00C0                     M 	dc.w	$c0
00001280                          M 	shift
00001280                            		d68k_Cmp	-2, $C0, d68k_iCmpa		; check if this is CMPA, and branch if yes
00001280 18FE                     M 	dc.b	d68ke_cmp,-2
00001282 00C0                     M 	dc.w	$c0
00001284                          M 	d68k_ref	d68k_icmpa
00001284                          M 	rept	narg
00001284 0000                     M 	dc.w	d68k_icmpa-*-2
00001286                          M 	shift
00001286                            		d68k_Cmp	-2, $100, d68k_iEor		; check if this is EOR or CMPM, and branch if yes
00001286 18FE                     M 	dc.b	d68ke_cmp,-2
00001288 0100                     M 	dc.w	$100
0000128A                          M 	d68k_ref	d68k_ieor
0000128A                          M 	rept	narg
0000128A 0000                     M 	dc.w	d68k_ieor-*-2
0000128C                          M 	shift
0000128C                            
0000128C                            		d68k_Print	0, d68k_sCmp			; print CMP
0000128C 0600                     M 	dc.b	d68ke_print,0
0000128E                          M 	d68k_ref	d68k_scmp
0000128E                          M 	rept	narg
0000128E 0000                     M 	dc.w	d68k_scmp-*-2
00001290                          M 	shift
00001290                            		d68k_InsSz	6				; print instruction size
00001290 0E06                     M 	dc.b	d68ke_inssz,6
00001292                            		d68k_Push	$FFF				; push check value into stack
00001292 1C00                     M 	dc.b	d68ke_push,narg-1
00001294                          M 	rept	narg
00001294 0FFF                     M 	dc.w	$fff
00001296                          M 	shift
00001296                            		d68k_Jump	d68k_WriteReg2			; go to standard handler
00001296 0200                     M 	dc.b	d68ke_jump,0
00001298                          M 	d68k_ref	d68k_writereg2
00001298                          M 	rept	narg
00001298 FFD8                     M 	dc.w	d68k_writereg2-*-2
0000129A                          M 	shift
0000129A                            ; --------------------------------------------------------------
0000129A                            
0000129A                            d68k_iCmpa:	d68k_Print	'a', d68k_sCmp			; print CMPA
0000129A 0661                     M 	dc.b	d68ke_print,'a'
0000129C                          M 	d68k_ref	d68k_scmp
0000129C                          M 	rept	narg
0000129C 0000                     M 	dc.w	d68k_scmp-*-2
0000129E                          M 	shift
0000129E                            		d68k_SmallSz	8				; print small instruction size
0000129E 1A08                     M 	dc.b	d68ke_smallsz,8
000012A0                            		d68k_Push	$FFF				; push check value into stack
000012A0 1C00                     M 	dc.b	d68ke_push,narg-1
000012A2                          M 	rept	narg
000012A2 0FFF                     M 	dc.w	$fff
000012A4                          M 	shift
000012A4                            		d68k_Mode	' '				; print source addressing mode
000012A4 1620                     M 	dc.b	d68ke_mode,' '
000012A6                            ; ==============================================================
000012A6                            ; --------------------------------------------------------------
000012A6                            ; Common type 6 instruction handler
000012A6                            ; --------------------------------------------------------------
000012A6                            
000012A6                            d68k_CommonIns6:
000012A6                            		d68k_Print	0, d68k_sComma			; print ,
000012A6 0600                     M 	dc.b	d68ke_print,0
000012A8                          M 	d68k_ref	d68k_scomma
000012A8                          M 	rept	narg
000012A8 0000                     M 	dc.w	d68k_scomma-*-2
000012AA                          M 	shift
000012AA                            		d68k_AddrReg	9				; print areg
000012AA 1409                     M 	dc.b	d68ke_addrreg,9
000012AC                            		d68k_Finish
000012AC 0400                     M 	dc.b	d68ke_finish,0
000012AE                            ; ==============================================================
000012AE                            ; --------------------------------------------------------------
000012AE                            ; EOR instruction handler
000012AE                            ; --------------------------------------------------------------
000012AE                            
000012AE                            d68k_iEor:
000012AE                            		d68k_Cmp	-2, $08, d68k_iCmpm		; check if this is CMPM, and branch if yes
000012AE 18FE                     M 	dc.b	d68ke_cmp,-2
000012B0 0008                     M 	dc.w	$08
000012B2                          M 	d68k_ref	d68k_icmpm
000012B2                          M 	rept	narg
000012B2 0000                     M 	dc.w	d68k_icmpm-*-2
000012B4                          M 	shift
000012B4                            		d68k_Print	0, d68k_sEor			; print EOR
000012B4 0600                     M 	dc.b	d68ke_print,0
000012B6                          M 	d68k_ref	d68k_seor
000012B6                          M 	rept	narg
000012B6 0000                     M 	dc.w	d68k_seor-*-2
000012B8                          M 	shift
000012B8                            		d68k_InsSz	6				; print instruction size
000012B8 0E06                     M 	dc.b	d68ke_inssz,6
000012BA                            		d68k_Char	' '				; print a space
000012BA 2420                     M 	dc.b	d68ke_char,' '
000012BC                            		d68k_DataReg	9				; print dreg
000012BC 1209                     M 	dc.b	d68ke_datareg,9
000012BE                            		d68k_Push	$1FD				; push check value into stack
000012BE 1C00                     M 	dc.b	d68ke_push,narg-1
000012C0                          M 	rept	narg
000012C0 01FD                     M 	dc.w	$1fd
000012C2                          M 	shift
000012C2                            		d68k_Jump	d68k_CommonIns8			; go to standard handler
000012C2 0200                     M 	dc.b	d68ke_jump,0
000012C4                          M 	d68k_ref	d68k_commonins8
000012C4                          M 	rept	narg
000012C4 0000                     M 	dc.w	d68k_commonins8-*-2
000012C6                          M 	shift
000012C6                            ; ==============================================================
000012C6                            ; --------------------------------------------------------------
000012C6                            ; CMPM instruction handler
000012C6                            ; --------------------------------------------------------------
000012C6                            
000012C6                            d68k_iCmpm:	d68k_Print	'm', d68k_sCmp			; print CMPM
000012C6 066D                     M 	dc.b	d68ke_print,'m'
000012C8                          M 	d68k_ref	d68k_scmp
000012C8                          M 	rept	narg
000012C8 0000                     M 	dc.w	d68k_scmp-*-2
000012CA                          M 	shift
000012CA                            		d68k_InsSz	6				; print instruction size
000012CA 0E06                     M 	dc.b	d68ke_inssz,6
000012CC                            		d68k_Char	' '				; print a space
000012CC 2420                     M 	dc.b	d68ke_char,' '
000012CE                            
000012CE                            		d68k_Push	0				; push shift count to stack
000012CE 1C00                     M 	dc.b	d68ke_push,narg-1
000012D0                          M 	rept	narg
000012D0 0000                     M 	dc.w	0
000012D2                          M 	shift
000012D2                            		d68k_Exec	d68k_ModeApind2			; write source register
000012D2 0000                     M 	dc.b	d68ke_exec,0
000012D4                          M 	d68k_ref	d68k_modeapind2
000012D4                          M 	rept	narg
000012D4 FC84                     M 	dc.w	d68k_modeapind2-*-2
000012D6                          M 	shift
000012D6                            		d68k_Print	0, d68k_sComma			; print ,
000012D6 0600                     M 	dc.b	d68ke_print,0
000012D8                          M 	d68k_ref	d68k_scomma
000012D8                          M 	rept	narg
000012D8 0000                     M 	dc.w	d68k_scomma-*-2
000012DA                          M 	shift
000012DA                            		d68k_Push	9				; push shift count to stack
000012DA 1C00                     M 	dc.b	d68ke_push,narg-1
000012DC                          M 	rept	narg
000012DC 0009                     M 	dc.w	9
000012DE                          M 	shift
000012DE                            		d68k_Exec	d68k_ModeApind2			; write destination register
000012DE 0000                     M 	dc.b	d68ke_exec,0
000012E0                          M 	d68k_ref	d68k_modeapind2
000012E0                          M 	rept	narg
000012E0 FC78                     M 	dc.w	d68k_modeapind2-*-2
000012E2                          M 	shift
000012E2                            		d68k_Finish
000012E2 0400                     M 	dc.b	d68ke_finish,0
000012E4                            ; ==============================================================
000012E4                            ; --------------------------------------------------------------
000012E4                            ; 0XXX instruction handler
000012E4                            ; --------------------------------------------------------------
000012E4                            
000012E4                            d68k_i0xxx:	d68k_ReadSrc	$C0, $80, $38, $100		; read the instruction from source
000012E4 0A03                     M 	dc.b	d68ke_readsrc,narg-1
000012E6                          M 	rept	narg
000012E6 00C0                     M 	dc.w	$c0
000012E8                          M 	shift
000012E8 0080                     M 	dc.w	$80
000012EA                          M 	shift
000012EA 0038                     M 	dc.w	$38
000012EC                          M 	shift
000012EC 0100                     M 	dc.w	$100
000012EE                          M 	shift
000012EE                            		d68k_Cmp	-2, $000, d68k_i00xx		; check if this is a misc instruction, and brach if yes
000012EE 18FE                     M 	dc.b	d68ke_cmp,-2
000012F0 0000                     M 	dc.w	$000
000012F2                          M 	d68k_ref	d68k_i00xx
000012F2                          M 	rept	narg
000012F2 0000                     M 	dc.w	d68k_i00xx-*-2
000012F4                          M 	shift
000012F4                            		d68k_Cmp	-2, $08, d68k_iMovep		; check if this is MOVEP, and branch if yes
000012F4 18FE                     M 	dc.b	d68ke_cmp,-2
000012F6 0008                     M 	dc.w	$08
000012F8                          M 	d68k_ref	d68k_imovep
000012F8                          M 	rept	narg
000012F8 0000                     M 	dc.w	d68k_imovep-*-2
000012FA                          M 	shift
000012FA                            ; ==============================================================
000012FA                            ; --------------------------------------------------------------
000012FA                            ; BTST, BCHG, BCLR & BSET instruction handlers
000012FA                            ; --------------------------------------------------------------
000012FA                            
000012FA                            	; BXXX DN, EA
000012FA                            		d68k_Exec	d68k_PrintBXXX			; print BXXX instruction string
000012FA 0000                     M 	dc.b	d68ke_exec,0
000012FC                          M 	d68k_ref	d68k_printbxxx
000012FC                          M 	rept	narg
000012FC 0000                     M 	dc.w	d68k_printbxxx-*-2
000012FE                          M 	shift
000012FE                            		d68k_Pop	-2				; movep check out
000012FE 1EFE                     M 	dc.b	d68ke_pop,-2
00001300                            		d68k_Cmp	-2, $00, .btst			; check if this is BTST, and branch if yes
00001300 18FE                     M 	dc.b	d68ke_cmp,-2
00001302 0000                     M 	dc.w	$00
00001304                          M 	d68k_ref	.btst
00001304                          M 	rept	narg
00001304 0000                     M 	dc.w	.btst-*-2
00001306                          M 	shift
00001306                            		d68k_Push	$1FD				; push check value into stack
00001306 1C00                     M 	dc.b	d68ke_push,narg-1
00001308                          M 	rept	narg
00001308 01FD                     M 	dc.w	$1fd
0000130A                          M 	shift
0000130A                            		d68k_Jump	.common				; run common code
0000130A 0200                     M 	dc.b	d68ke_jump,0
0000130C                          M 	d68k_ref	.common
0000130C                          M 	rept	narg
0000130C 0000                     M 	dc.w	.common-*-2
0000130E                          M 	shift
0000130E                            
0000130E                            .btst		d68k_Push	$FFD				; push check value into stack
0000130E 1C00                     M 	dc.b	d68ke_push,narg-1
00001310                          M 	rept	narg
00001310 0FFD                     M 	dc.w	$ffd
00001312                          M 	shift
00001312                            
00001312                            .common		d68k_DataReg	9				; print dreg
00001312 1209                     M 	dc.b	d68ke_datareg,9
00001314                            ; ==============================================================
00001314                            ; --------------------------------------------------------------
00001314                            ; Common instruction type 5 handler
00001314                            ; --------------------------------------------------------------
00001314                            
00001314                            d68k_CommonIns5:
00001314                            		d68k_Size	'b'				; set instruction size
00001314 2262                     M 	dc.b	d68ke_size,'b'
00001316                            ; ==============================================================
00001316                            ; --------------------------------------------------------------
00001316                            ; Common instruction type 4 handler
00001316                            ; --------------------------------------------------------------
00001316                            
00001316                            d68k_CommonIns8:
00001316                            		d68k_Print	0, d68k_sComma			; print ,
00001316 0600                     M 	dc.b	d68ke_print,0
00001318                          M 	d68k_ref	d68k_scomma
00001318                          M 	rept	narg
00001318 0000                     M 	dc.w	d68k_scomma-*-2
0000131A                          M 	shift
0000131A                            		d68k_Mode	0				; print source addressing mode
0000131A 1600                     M 	dc.b	d68ke_mode,0
0000131C                            		d68k_Finish
0000131C 0400                     M 	dc.b	d68ke_finish,0
0000131E                            ; --------------------------------------------------------------
0000131E                            
0000131E                            	; BXXX #, EA
0000131E                            d68k_iBit:
0000131E                            		d68k_Exec	d68k_PrintBXXX			; print BXXX instruction string
0000131E 0000                     M 	dc.b	d68ke_exec,0
00001320                          M 	d68k_ref	d68k_printbxxx
00001320                          M 	rept	narg
00001320 0000                     M 	dc.w	d68k_printbxxx-*-2
00001322                          M 	shift
00001322                            		d68k_Pop	-2				; movep check out
00001322 1EFE                     M 	dc.b	d68ke_pop,-2
00001324                            		d68k_Cmp	-2, $00, .btst			; check if this is BTST, and branch if yes
00001324 18FE                     M 	dc.b	d68ke_cmp,-2
00001326 0000                     M 	dc.w	$00
00001328                          M 	d68k_ref	.btst
00001328                          M 	rept	narg
00001328 0000                     M 	dc.w	.btst-*-2
0000132A                          M 	shift
0000132A                            		d68k_Push	$1FD				; push check value into stack
0000132A 1C00                     M 	dc.b	d68ke_push,narg-1
0000132C                          M 	rept	narg
0000132C 01FD                     M 	dc.w	$1fd
0000132E                          M 	shift
0000132E                            		d68k_Jump	.common				; run common code
0000132E 0200                     M 	dc.b	d68ke_jump,0
00001330                          M 	d68k_ref	.common
00001330                          M 	rept	narg
00001330 0000                     M 	dc.w	.common-*-2
00001332                          M 	shift
00001332                            
00001332                            .btst		d68k_Push	$7FD				; push check value into stack
00001332 1C00                     M 	dc.b	d68ke_push,narg-1
00001334                          M 	rept	narg
00001334 07FD                     M 	dc.w	$7fd
00001336                          M 	shift
00001336                            
00001336                            .common		d68k_Char	'#'				; print #
00001336 2423                     M 	dc.b	d68ke_char,'#'
00001338                            		d68k_Read	$FFFF				; read the offset from source
00001338 0C00                     M 	dc.b	d68ke_read,narg-1
0000133A                          M 	rept	narg
0000133A FFFF                     M 	dc.w	$ffff
0000133C                          M 	shift
0000133C                            		d68k_PrintNum	d68kn_Word			; write the word value
0000133C 0802                     M 	dc.b	d68ke_printnum,d68kn_word
0000133E                            		d68k_Jump	d68k_CommonIns5			; go to standard handler
0000133E 0200                     M 	dc.b	d68ke_jump,0
00001340                          M 	d68k_ref	d68k_commonins5
00001340                          M 	rept	narg
00001340 FFD2                     M 	dc.w	d68k_commonins5-*-2
00001342                          M 	shift
00001342                            ; ==============================================================
00001342                            ; --------------------------------------------------------------
00001342                            ; Print BXXX instruction string
00001342                            ; --------------------------------------------------------------
00001342                            
00001342                            d68k_PrintBXXX:
00001342 3200                       		move.w	d0,d1					; copy the instruction to d1
00001344 0241 00C0                  		and.w	#$C0,d1					; keep in range
00001348 E849                       		lsr.w	#4,d1					; shift into place
0000134A                            
0000134A 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
0000134E 49FB 1000                  		lea	.ins(pc,d1.w),a4			; load table to a4
00001352 7203                       		moveq	#4-1,d1					; load repeat count to d1
00001354                            
00001354                            .load
00001354 10DC                       		move.b	(a4)+,(a0)+				; copy to buffer
00001356 51C9 FFFC                  		dbf	d1,.load				; print all characters
0000135A                            
0000135A 10FC 0020                  		move.b	#' ',(a0)+				; print a space
0000135E 4EFA F9EA                  		jmp	d68k_RunScript(pc)			; run the script now
00001362                            
00001362 6274 7374 6263 6867 6263+  .ins		dc.b 'btstbchgbclrbset'
00001372                            ; ==============================================================
00001372                            ; --------------------------------------------------------------
00001372                            ; MOVEP instruction handler
00001372                            ; --------------------------------------------------------------
00001372                            
00001372                            d68k_iMovep:	d68k_Print	'p', d68k_sMove			; print MOVEP
00001372 0670                     M 	dc.b	d68ke_print,'p'
00001374                          M 	d68k_ref	d68k_smove
00001374                          M 	rept	narg
00001374 0000                     M 	dc.w	d68k_smove-*-2
00001376                          M 	shift
00001376                            		d68k_SmallSz	6				; print small instruction size
00001376 1A06                     M 	dc.b	d68ke_smallsz,6
00001378                            		d68k_Char	' '				; print space
00001378 2420                     M 	dc.b	d68ke_char,' '
0000137A                            
0000137A                            		d68k_Cmp	0, $00, .skip1			; check if this is EA -> DN, and brach if yes
0000137A 1800                     M 	dc.b	d68ke_cmp,0
0000137C 0000                     M 	dc.w	$00
0000137E                          M 	d68k_ref	.skip1
0000137E                          M 	rept	narg
0000137E 0000                     M 	dc.w	.skip1-*-2
00001380                          M 	shift
00001380                            		d68k_DataReg	9				; print dreg
00001380 1209                     M 	dc.b	d68ke_datareg,9
00001382                            		d68k_Print	0, d68k_sComma			; print ,
00001382 0600                     M 	dc.b	d68ke_print,0
00001384                          M 	d68k_ref	d68k_scomma
00001384                          M 	rept	narg
00001384 0000                     M 	dc.w	d68k_scomma-*-2
00001386                          M 	shift
00001386                            
00001386                            .skip1		d68k_Exec	d68k_ModeAoind2			; write d16(AN) part
00001386 0000                     M 	dc.b	d68ke_exec,0
00001388                          M 	d68k_ref	d68k_modeaoind2
00001388                          M 	rept	narg
00001388 FBAA                     M 	dc.w	d68k_modeaoind2-*-2
0000138A                          M 	shift
0000138A                            		d68k_Cmp	-2, $80, d68k_Finish1		; check if this is DN -> EA, and brach if yes
0000138A 18FE                     M 	dc.b	d68ke_cmp,-2
0000138C 0080                     M 	dc.w	$80
0000138E                          M 	d68k_ref	d68k_finish1
0000138E                          M 	rept	narg
0000138E FEE0                     M 	dc.w	d68k_finish1-*-2
00001390                          M 	shift
00001390                            		d68k_Jump	d68k_WriteReg1			; go to standard handler
00001390 0200                     M 	dc.b	d68ke_jump,0
00001392                          M 	d68k_ref	d68k_writereg1
00001392                          M 	rept	narg
00001392 FED6                     M 	dc.w	d68k_writereg1-*-2
00001394                          M 	shift
00001394                            ; ==============================================================
00001394                            ; --------------------------------------------------------------
00001394                            ; 00XX instruction handler
00001394                            ; --------------------------------------------------------------
00001394                            
00001394                            d68k_i00xx:	d68k_ReadSrc	$C0, $63F, $E00	 		; read the instruction from source
00001394 0A02                     M 	dc.b	d68ke_readsrc,narg-1
00001396                          M 	rept	narg
00001396 00C0                     M 	dc.w	$c0
00001398                          M 	shift
00001398 063F                     M 	dc.w	$63f
0000139A                          M 	shift
0000139A 0E00                     M 	dc.w	$e00
0000139C                          M 	shift
0000139C                            		d68k_Cmp	0, $E00, d68k_iData		; check if this is invalid, and if so, present as data
0000139C 1800                     M 	dc.b	d68ke_cmp,0
0000139E 0E00                     M 	dc.w	$e00
000013A0                          M 	d68k_ref	d68k_idata
000013A0                          M 	rept	narg
000013A0 FCC4                     M 	dc.w	d68k_idata-*-2
000013A2                          M 	shift
000013A2                            		d68k_Cmp	-2, $800, d68k_iBit		; check if this is BXXX, and brach if yes
000013A2 18FE                     M 	dc.b	d68ke_cmp,-2
000013A4 0800                     M 	dc.w	$800
000013A6                          M 	d68k_ref	d68k_ibit
000013A6                          M 	rept	narg
000013A6 FF76                     M 	dc.w	d68k_ibit-*-2
000013A8                          M 	shift
000013A8                            
000013A8                            	; XXXI
000013A8                            		d68k_Exec	.print				; print instruction
000013A8 0000                     M 	dc.b	d68ke_exec,0
000013AA                          M 	d68k_ref	.print
000013AA                          M 	rept	narg
000013AA 0000                     M 	dc.w	.print-*-2
000013AC                          M 	shift
000013AC                            		d68k_InsSz	6				; print instruction size
000013AC 0E06                     M 	dc.b	d68ke_inssz,6
000013AE                            		d68k_Char	' '				; print a space
000013AE 2420                     M 	dc.b	d68ke_char,' '
000013B0                            		d68k_Exec	d68k_rModeImm			; print data
000013B0 0000                     M 	dc.b	d68ke_exec,0
000013B2                          M 	d68k_ref	d68k_rmodeimm
000013B2                          M 	rept	narg
000013B2 FC8C                     M 	dc.w	d68k_rmodeimm-*-2
000013B4                          M 	shift
000013B4                            
000013B4                            		d68k_Print	0, d68k_sComma			; print ,
000013B4 0600                     M 	dc.b	d68ke_print,0
000013B6                          M 	d68k_ref	d68k_scomma
000013B6                          M 	rept	narg
000013B6 0000                     M 	dc.w	d68k_scomma-*-2
000013B8                          M 	shift
000013B8                            		d68k_Cmp	0, $03C, .srccr			; check if this to SR/CCR, and brach if yes
000013B8 1800                     M 	dc.b	d68ke_cmp,0
000013BA 003C                     M 	dc.w	$03c
000013BC                          M 	d68k_ref	.srccr
000013BC                          M 	rept	narg
000013BC 0000                     M 	dc.w	.srccr-*-2
000013BE                          M 	shift
000013BE                            		d68k_Cmp	0, $23C, .srccr			; check if this is SR/CCR, and brach if yes
000013BE 1800                     M 	dc.b	d68ke_cmp,0
000013C0 023C                     M 	dc.w	$23c
000013C2                          M 	d68k_ref	.srccr
000013C2                          M 	rept	narg
000013C2 0000                     M 	dc.w	.srccr-*-2
000013C4                          M 	shift
000013C4                            ; --------------------------------------------------------------
000013C4                            
000013C4                            	; XXXI #,EA
000013C4                            		d68k_Push	$1FD				; push check value into stack
000013C4 1C00                     M 	dc.b	d68ke_push,narg-1
000013C6                          M 	rept	narg
000013C6 01FD                     M 	dc.w	$1fd
000013C8                          M 	shift
000013C8                            		d68k_Mode	0				; print source addressing mode
000013C8 1600                     M 	dc.b	d68ke_mode,0
000013CA                            		d68k_Finish
000013CA 0400                     M 	dc.b	d68ke_finish,0
000013CC                            ; --------------------------------------------------------------
000013CC                            
000013CC                            .print
000013CC 3213                       		move.w	(a3),d1					; read instruction from stack
000013CE E049                       		lsr.w	#8,d1					; shift down
000013D0 323B 1000                  		move.w	.tbl(pc,d1.w),d1			; load table entry to d1
000013D4 49FB 1000                  		lea	.tbl(pc,d1.w),a4			; load string address to a4
000013D8                            
000013D8 7269                       		moveq	#'i',d1					; write i at the end
000013DA 4EFA F9B2                  		jmp	d68k_rPrint3(pc)			; print it out
000013DE                            ; --------------------------------------------------------------
000013DE                            
000013DE 0000 0000 0000             .tbl		dc.w d68k_sOr-.tbl,  d68k_sAnd-.tbl, d68k_sSub-.tbl
000013E4 0000 0000 0000 0000        		dc.w d68k_sAdd-.tbl, 0, d68k_sEor-.tbl, d68k_sCmp-.tbl
000013EC                            ; --------------------------------------------------------------
000013EC                            
000013EC                            
000013EC                            .srccr	; XXXI #,SR/CCR
000013EC                            		d68k_Pop	-2				; pop ADDQ/SUBQ test word
000013EC 1EFE                     M 	dc.b	d68ke_pop,-2
000013EE                            		d68k_Cmp	0, $40, .sr			; check for SR, and branch if so
000013EE 1800                     M 	dc.b	d68ke_cmp,0
000013F0 0040                     M 	dc.w	$40
000013F2                          M 	d68k_ref	.sr
000013F2                          M 	rept	narg
000013F2 0000                     M 	dc.w	.sr-*-2
000013F4                          M 	shift
000013F4                            		d68k_Cmp	-2, $00, .ccr			; check for CCR, and branch if so
000013F4 18FE                     M 	dc.b	d68ke_cmp,-2
000013F6 0000                     M 	dc.w	$00
000013F8                          M 	d68k_ref	.ccr
000013F8                          M 	rept	narg
000013F8 0000                     M 	dc.w	.ccr-*-2
000013FA                          M 	shift
000013FA                            		d68k_Jump	d68k_iData			; invalid mode
000013FA 0200                     M 	dc.b	d68ke_jump,0
000013FC                          M 	d68k_ref	d68k_idata
000013FC                          M 	rept	narg
000013FC FC68                     M 	dc.w	d68k_idata-*-2
000013FE                          M 	shift
000013FE                            ; --------------------------------------------------------------
000013FE                            
000013FE                            .ccr		d68k_Print	'r', d68k_sCC			; print CCR
000013FE 0672                     M 	dc.b	d68ke_print,'r'
00001400                          M 	d68k_ref	d68k_scc
00001400                          M 	rept	narg
00001400 0000                     M 	dc.w	d68k_scc-*-2
00001402                          M 	shift
00001402                            		d68k_Finish
00001402 0400                     M 	dc.b	d68ke_finish,0
00001404                            
00001404                            .sr		d68k_Print	'r', d68k_sS2			; print SR
00001404 0672                     M 	dc.b	d68ke_print,'r'
00001406                          M 	d68k_ref	d68k_ss2
00001406                          M 	rept	narg
00001406 0000                     M 	dc.w	d68k_ss2-*-2
00001408                          M 	shift
00001408                            		d68k_Finish
00001408 0400                     M 	dc.b	d68ke_finish,0
0000140A                            ; ==============================================================
0000140A                            ; --------------------------------------------------------------
0000140A                            ; 5XXX instruction handler
0000140A                            ; --------------------------------------------------------------
0000140A                            
0000140A                            d68k_i5xxx:	d68k_ReadSrc	$38, $100, $C0 			; read the instruction from source
0000140A 0A02                     M 	dc.b	d68ke_readsrc,narg-1
0000140C                          M 	rept	narg
0000140C 0038                     M 	dc.w	$38
0000140E                          M 	shift
0000140E 0100                     M 	dc.w	$100
00001410                          M 	shift
00001410 00C0                     M 	dc.w	$c0
00001412                          M 	shift
00001412                            		d68k_Cmp	-2, $C0, .scc			; check if this is a DBc or Scc, and brach if yes
00001412 18FE                     M 	dc.b	d68ke_cmp,-2
00001414 00C0                     M 	dc.w	$c0
00001416                          M 	d68k_ref	.scc
00001416                          M 	rept	narg
00001416 0000                     M 	dc.w	.scc-*-2
00001418                          M 	shift
00001418                            ; ==============================================================
00001418                            ; --------------------------------------------------------------
00001418                            ; ADDQ and SUBQ instruction handlers
00001418                            ; --------------------------------------------------------------
00001418                            
00001418                            	; ADDQ and SUBQ
00001418                            		d68k_Cmp	-2, $100, .subq			; check if this is a SUBQ, and brach if yes
00001418 18FE                     M 	dc.b	d68ke_cmp,-2
0000141A 0100                     M 	dc.w	$100
0000141C                          M 	d68k_ref	.subq
0000141C                          M 	rept	narg
0000141C 0000                     M 	dc.w	.subq-*-2
0000141E                          M 	shift
0000141E                            		d68k_Print	'q', d68k_sAdd			; print addq
0000141E 0671                     M 	dc.b	d68ke_print,'q'
00001420                          M 	d68k_ref	d68k_sadd
00001420                          M 	rept	narg
00001420 0000                     M 	dc.w	d68k_sadd-*-2
00001422                          M 	shift
00001422                            		d68k_Jump	.common				; common code
00001422 0200                     M 	dc.b	d68ke_jump,0
00001424                          M 	d68k_ref	.common
00001424                          M 	rept	narg
00001424 0000                     M 	dc.w	.common-*-2
00001426                          M 	shift
00001426                            
00001426                            .subq		d68k_Print	'q', d68k_sSub			; print subq
00001426 0671                     M 	dc.b	d68ke_print,'q'
00001428                          M 	d68k_ref	d68k_ssub
00001428                          M 	rept	narg
00001428 0000                     M 	dc.w	d68k_ssub-*-2
0000142A                          M 	shift
0000142A                            ; --------------------------------------------------------------
0000142A                            
0000142A                            .common		d68k_InsSz	6				; print instruction size
0000142A 0E06                     M 	dc.b	d68ke_inssz,6
0000142C                            		d68k_Char	' '				; print space
0000142C 2420                     M 	dc.b	d68ke_char,' '
0000142E                            		d68k_Exec	d68k_PrintTinyValue		; print the value
0000142E 0000                     M 	dc.b	d68ke_exec,0
00001430                          M 	d68k_ref	d68k_printtinyvalue
00001430                          M 	rept	narg
00001430 0000                     M 	dc.w	d68k_printtinyvalue-*-2
00001432                          M 	shift
00001432                            		d68k_Push	$1FF				; push check value into stack
00001432 1C00                     M 	dc.b	d68ke_push,narg-1
00001434                          M 	rept	narg
00001434 01FF                     M 	dc.w	$1ff
00001436                          M 	shift
00001436                            		d68k_Jump	d68k_CommonIns8			; go to standard handler
00001436 0200                     M 	dc.b	d68ke_jump,0
00001438                          M 	d68k_ref	d68k_commonins8
00001438                          M 	rept	narg
00001438 FEDC                     M 	dc.w	d68k_commonins8-*-2
0000143A                          M 	shift
0000143A                            ; ==============================================================
0000143A                            ; --------------------------------------------------------------
0000143A                            ; SCC instruction handler
0000143A                            ; --------------------------------------------------------------
0000143A                            
0000143A                            .scc		d68k_Pop	-2				; pop ADDQ/SUBQ test word
0000143A 1EFE                     M 	dc.b	d68ke_pop,-2
0000143C                            		d68k_Cmp	-2, $08, .dbcc			; check if this is a DBCC, and brach if yes
0000143C 18FE                     M 	dc.b	d68ke_cmp,-2
0000143E 0008                     M 	dc.w	$08
00001440                          M 	d68k_ref	.dbcc
00001440                          M 	rept	narg
00001440 0000                     M 	dc.w	.dbcc-*-2
00001442                          M 	shift
00001442                            
00001442                            	; Scc
00001442                            		d68k_Print	0, d68k_sS			; print s
00001442 0600                     M 	dc.b	d68ke_print,0
00001444                          M 	d68k_ref	d68k_ss
00001444                          M 	rept	narg
00001444 0000                     M 	dc.w	d68k_ss-*-2
00001446                          M 	shift
00001446                            		d68k_Push	.scctbl-d68k_PrintCC		; push table offset to stack
00001446 1C00                     M 	dc.b	d68ke_push,narg-1
00001448                          M 	rept	narg
00001448 0000                     M 	dc.w	.scctbl-d68k_printcc
0000144A                          M 	shift
0000144A                            		d68k_Exec	d68k_PrintCC2			; print condition code
0000144A 0000                     M 	dc.b	d68ke_exec,0
0000144C                          M 	d68k_ref	d68k_printcc2
0000144C                          M 	rept	narg
0000144C 0000                     M 	dc.w	d68k_printcc2-*-2
0000144E                          M 	shift
0000144E                            
0000144E                            		d68k_Size	'b'				; set instruction size
0000144E 2262                     M 	dc.b	d68ke_size,'b'
00001450                            		d68k_Jump	d68k_CommonIns3			; run common instruction code
00001450 0200                     M 	dc.b	d68ke_jump,0
00001452                          M 	d68k_ref	d68k_commonins3
00001452                          M 	rept	narg
00001452 0000                     M 	dc.w	d68k_commonins3-*-2
00001454                          M 	shift
00001454                            ; ==============================================================
00001454                            ; --------------------------------------------------------------
00001454                            ; DBCC instruction handler
00001454                            ; --------------------------------------------------------------
00001454                            
00001454                            .dbcc	; DBcc
00001454                            		d68k_Print	0, d68k_sDB			; print db
00001454 0600                     M 	dc.b	d68ke_print,0
00001456                          M 	d68k_ref	d68k_sdb
00001456                          M 	rept	narg
00001456 0000                     M 	dc.w	d68k_sdb-*-2
00001458                          M 	shift
00001458                            		d68k_Push	.scctbl-d68k_PrintCC		; push table offset to stack
00001458 1C00                     M 	dc.b	d68ke_push,narg-1
0000145A                          M 	rept	narg
0000145A 0000                     M 	dc.w	.scctbl-d68k_printcc
0000145C                          M 	shift
0000145C                            		d68k_Exec	d68k_PrintCC2			; print condition code
0000145C 0000                     M 	dc.b	d68ke_exec,0
0000145E                          M 	d68k_ref	d68k_printcc2
0000145E                          M 	rept	narg
0000145E 0000                     M 	dc.w	d68k_printcc2-*-2
00001460                          M 	shift
00001460                            		d68k_Char	' '				; print space
00001460 2420                     M 	dc.b	d68ke_char,' '
00001462                            		d68k_DataReg	0				; print dreg
00001462 1200                     M 	dc.b	d68ke_datareg,0
00001464                            
00001464                            		d68k_Print	0, d68k_sComma			; print ,
00001464 0600                     M 	dc.b	d68ke_print,0
00001466                          M 	d68k_ref	d68k_scomma
00001466                          M 	rept	narg
00001466 0000                     M 	dc.w	d68k_scomma-*-2
00001468                          M 	shift
00001468                            		d68k_Read	$FFFF	 			; read the offset from source
00001468 0C00                     M 	dc.b	d68ke_read,narg-1
0000146A                          M 	rept	narg
0000146A FFFF                     M 	dc.w	$ffff
0000146C                          M 	shift
0000146C                            		d68k_Push	-2				; push address offset to stack
0000146C 1C00                     M 	dc.b	d68ke_push,narg-1
0000146E                          M 	rept	narg
0000146E FFFE                     M 	dc.w	-2
00001470                          M 	shift
00001470                            		d68k_Jump	d68k_iDoAddr			; run common instruction code
00001470 0200                     M 	dc.b	d68ke_jump,0
00001472                          M 	d68k_ref	d68k_idoaddr
00001472                          M 	rept	narg
00001472 0000                     M 	dc.w	d68k_idoaddr-*-2
00001474                          M 	shift
00001474                            
00001474 7400 6600                  .scctbl		dc.b 't', 0, 'f', 0
00001478                            ; ==============================================================
00001478                            ; --------------------------------------------------------------
00001478                            ; BCC instruction handler
00001478                            ; --------------------------------------------------------------
00001478                            
00001478                            d68k_iBCC:	d68k_Push	.bcctbl-d68k_PrintCC		; push table offset to stack
00001478 1C00                     M 	dc.b	d68ke_push,narg-1
0000147A                          M 	rept	narg
0000147A 0000                     M 	dc.w	.bcctbl-d68k_printcc
0000147C                          M 	shift
0000147C                            		d68k_Print	0, d68k_sB			; print b
0000147C 0600                     M 	dc.b	d68ke_print,0
0000147E                          M 	d68k_ref	d68k_sb
0000147E                          M 	rept	narg
0000147E 0000                     M 	dc.w	d68k_sb-*-2
00001480                          M 	shift
00001480                            		d68k_Exec	d68k_PrintCC			; print condition code
00001480 0000                     M 	dc.b	d68ke_exec,0
00001482                          M 	d68k_ref	d68k_printcc
00001482                          M 	rept	narg
00001482 0000                     M 	dc.w	d68k_printcc-*-2
00001484                          M 	shift
00001484                            
00001484                            		d68k_ReadSrc	$FF	 			; read the instruction from source
00001484 0A00                     M 	dc.b	d68ke_readsrc,narg-1
00001486                          M 	rept	narg
00001486 00FF                     M 	dc.w	$ff
00001488                          M 	shift
00001488                            		d68k_Cmp	0, $00, .word			; check if word, and if so, branch
00001488 1800                     M 	dc.b	d68ke_cmp,0
0000148A 0000                     M 	dc.w	$00
0000148C                          M 	d68k_ref	.word
0000148C                          M 	rept	narg
0000148C 0000                     M 	dc.w	.word-*-2
0000148E                          M 	shift
0000148E                            		d68k_Print	' ', d68k_sDotS			; print .s
0000148E 0620                     M 	dc.b	d68ke_print,' '
00001490                          M 	d68k_ref	d68k_sdots
00001490                          M 	rept	narg
00001490 0000                     M 	dc.w	d68k_sdots-*-2
00001492                          M 	shift
00001492                            		d68k_Push	0				; push address offset to stack
00001492 1C00                     M 	dc.b	d68ke_push,narg-1
00001494                          M 	rept	narg
00001494 0000                     M 	dc.w	0
00001496                          M 	shift
00001496                            		d68k_Jump	.common				; common code
00001496 0200                     M 	dc.b	d68ke_jump,0
00001498                          M 	d68k_ref	.common
00001498                          M 	rept	narg
00001498 0000                     M 	dc.w	.common-*-2
0000149A                          M 	shift
0000149A                            ; --------------------------------------------------------------
0000149A                            
0000149A 7261 7372                  .bcctbl		dc.b 'rasr'
0000149E                            
0000149E                            .word		d68k_Read	$FFFF	 			; read the offset from source
0000149E 0C00                     M 	dc.b	d68ke_read,narg-1
000014A0                          M 	rept	narg
000014A0 FFFF                     M 	dc.w	$ffff
000014A2                          M 	shift
000014A2                            		d68k_Print	' ', d68k_sDotW			; print .w
000014A2 0620                     M 	dc.b	d68ke_print,' '
000014A4                          M 	d68k_ref	d68k_sdotw
000014A4                          M 	rept	narg
000014A4 0000                     M 	dc.w	d68k_sdotw-*-2
000014A6                          M 	shift
000014A6                            		d68k_Push	-2				; push address offset to stack
000014A6 1C00                     M 	dc.b	d68ke_push,narg-1
000014A8                          M 	rept	narg
000014A8 FFFE                     M 	dc.w	-2
000014AA                          M 	shift
000014AA                            
000014AA                            .common		d68k_Swap	-2				; swap arguments
000014AA 20FE                     M 	dc.b	d68ke_swap,-2
000014AC                            ; ==============================================================
000014AC                            ; --------------------------------------------------------------
000014AC                            ; BCC and DBCC address calculation and printout
000014AC                            ; --------------------------------------------------------------
000014AC                            
000014AC                            d68k_iDoAddr:
000014AC                            		d68k_Exec	d68k_CalcAddr			; calculate address
000014AC 0000                     M 	dc.b	d68ke_exec,0
000014AE                          M 	d68k_ref	d68k_calcaddr
000014AE                          M 	rept	narg
000014AE 0000                     M 	dc.w	d68k_calcaddr-*-2
000014B0                          M 	shift
000014B0                            		d68k_PrintNum	d68kn_Addr			; write the address value
000014B0 0804                     M 	dc.b	d68ke_printnum,d68kn_addr
000014B2                            		d68k_Finish
000014B2 0400                     M 	dc.b	d68ke_finish,0
000014B4                            ; ==============================================================
000014B4                            ; --------------------------------------------------------------
000014B4                            ; Calculate address from source and stack
000014B4                            ; --------------------------------------------------------------
000014B4                            
000014B4                            d68k_CalcAddr:
000014B4 3223                       		move.w	-(a3),d1				; load address
000014B6 3423                       		move.w	-(a3),d2				; load offset
000014B8 6600                       		bne.s	.word					; branch if it was not 0
000014BA 4881                       		ext.w	d1					; extend address to word
000014BC                            
000014BC D242                       .word		add.w	d2,d1					; add offset
000014BE 48C1                       		ext.l	d1					; extend to long
000014C0 D289                       		add.l	a1,d1					; add source address
000014C2 26C1                       		move.l	d1,(a3)+				; store in stack
000014C4 4EFA F884                  		jmp	d68k_RunScript(pc)			; run the script now
000014C8                            ; ==============================================================
000014C8                            ; --------------------------------------------------------------
000014C8                            ; Condition code print handler
000014C8                            ; --------------------------------------------------------------
000014C8                            
000014C8                            d68k_PrintCC:
000014C8 487A F880                  		pea	d68k_RunScript(pc)			; run the script later
000014CC                            
000014CC                            d68k_PrintCC3:
000014CC 3223                       		move.w	-(a3),d1				; load table offset to d1
000014CE 49FB 10F8                  		lea	d68k_PrintCC(pc,d1.w),a4		; load table to a4
000014D2                            
000014D2 3200                       		move.w	d0,d1					; copy instruction to d1
000014D4 0241 0F00                  		and.w	#$0F00,d1				; keep in range
000014D8 EE49                       		lsr.w	#7,d1					; shift down
000014DA                            
000014DA 0C41 0004                  		cmp.w	#4,d1					; check if this is the two first entries
000014DE 6D00                       		blt.s	.a2					; read from a2
000014E0                            
000014E0 10FB 1000                  		move.b	.cctbl-3(pc,d1.w),(a0)+			; load first letter to buffer
000014E4 10FB 1000                  		move.b	.cctbl-4(pc,d1.w),(a0)+			; load second letter to buffer
000014E8 4E75                       		rts
000014EA                            ; --------------------------------------------------------------
000014EA                            
000014EA                            .a2
000014EA 10F4 1000                  		move.b	(a4,d1.w),(a0)+				; load first alternate letter to buffer
000014EE 10F4 1001                  		move.b	1(a4,d1.w),(a0)+			; load second alternate letter to buffer
000014F2 4E75                       		rts
000014F4                            ; --------------------------------------------------------------
000014F4                            
000014F4 6869 6C73 6363 6373 6E65+  .cctbl		dc.b 'hilscccsneeqvcvsplmigeltgtle'
00001510                            ; --------------------------------------------------------------
00001510                            
00001510                            d68k_PrintCC2:
00001510 61BA                       		bsr.s	d68k_PrintCC3				; print the CC
00001512 4A28 FFFF                  		tst.b	-1(a0)					; check if last was blank
00001516 57C1                       		seq	d1					; set d1 if yes
00001518                            
00001518 0241 0002                  		and.w	#2,d1					; keep in range
0000151C 90C1                       		sub.w	d1,a0					; advance the pointer
0000151E 4EFA F82A                  		jmp	d68k_RunScript(pc)			; run the script now
00001522                            ; ==============================================================
00001522                            ; --------------------------------------------------------------
00001522                            ; EXXX instruction handler
00001522                            ; --------------------------------------------------------------
00001522                            
00001522                            d68k_iExxx:	d68k_ReadSrc	$20, $C0			; read the instruction from source
00001522 0A01                     M 	dc.b	d68ke_readsrc,narg-1
00001524                          M 	rept	narg
00001524 0020                     M 	dc.w	$20
00001526                          M 	shift
00001526 00C0                     M 	dc.w	$c0
00001528                          M 	shift
00001528                            		d68k_Cmp	-2, $C0, .ea			; check if EA, and if so, branch
00001528 18FE                     M 	dc.b	d68ke_cmp,-2
0000152A 00C0                     M 	dc.w	$c0
0000152C                          M 	d68k_ref	.ea
0000152C                          M 	rept	narg
0000152C 0000                     M 	dc.w	.ea-*-2
0000152E                          M 	shift
0000152E                            
0000152E                            	; shift # or DN
0000152E                            		d68k_Push	3				; push shift count to stack
0000152E 1C00                     M 	dc.b	d68ke_push,narg-1
00001530                          M 	rept	narg
00001530 0003                     M 	dc.w	3
00001532                          M 	shift
00001532                            		d68k_Exec	d68k_PrintShift			; print shift instruction
00001532 0000                     M 	dc.b	d68ke_exec,0
00001534                          M 	d68k_ref	d68k_printshift
00001534                          M 	rept	narg
00001534 0000                     M 	dc.w	d68k_printshift-*-2
00001536                          M 	shift
00001536                            		d68k_InsSz	6				; print instruction size
00001536 0E06                     M 	dc.b	d68ke_inssz,6
00001538                            		d68k_Char	' '				; print space
00001538 2420                     M 	dc.b	d68ke_char,' '
0000153A                            		d68k_Cmp	-2, $00, .imm			; check if #, and if so, branch
0000153A 18FE                     M 	dc.b	d68ke_cmp,-2
0000153C 0000                     M 	dc.w	$00
0000153E                          M 	d68k_ref	.imm
0000153E                          M 	rept	narg
0000153E 0000                     M 	dc.w	.imm-*-2
00001540                          M 	shift
00001540                            
00001540                            	; shift DN
00001540                            		d68k_DataReg	9				; print dreg
00001540 1209                     M 	dc.b	d68ke_datareg,9
00001542                            		d68k_Jump	.common				; common code
00001542 0200                     M 	dc.b	d68ke_jump,0
00001544                          M 	d68k_ref	.common
00001544                          M 	rept	narg
00001544 0000                     M 	dc.w	.common-*-2
00001546                          M 	shift
00001546                            
00001546                            .imm	; shift #
00001546                            		d68k_Exec	d68k_PrintTinyValue		; print the value
00001546 0000                     M 	dc.b	d68ke_exec,0
00001548                          M 	d68k_ref	d68k_printtinyvalue
00001548                          M 	rept	narg
00001548 0000                     M 	dc.w	d68k_printtinyvalue-*-2
0000154A                          M 	shift
0000154A                            
0000154A                            .common		d68k_Print	0, d68k_sComma			; print ,
0000154A 0600                     M 	dc.b	d68ke_print,0
0000154C                          M 	d68k_ref	d68k_scomma
0000154C                          M 	rept	narg
0000154C 0000                     M 	dc.w	d68k_scomma-*-2
0000154E                          M 	shift
0000154E                            		d68k_Jump	d68k_CommonIns9			; common instruction type 9
0000154E 0200                     M 	dc.b	d68ke_jump,0
00001550                          M 	d68k_ref	d68k_commonins9
00001550                          M 	rept	narg
00001550 0000                     M 	dc.w	d68k_commonins9-*-2
00001552                          M 	shift
00001552                            
00001552                            .ea	; shift EA
00001552                            		d68k_Push	9				; push shift count to stack
00001552 1C00                     M 	dc.b	d68ke_push,narg-1
00001554                          M 	rept	narg
00001554 0009                     M 	dc.w	9
00001556                          M 	shift
00001556                            		d68k_Exec	d68k_PrintShift			; print shift instruction
00001556 0000                     M 	dc.b	d68ke_exec,0
00001558                          M 	d68k_ref	d68k_printshift
00001558                          M 	rept	narg
00001558 0000                     M 	dc.w	d68k_printshift-*-2
0000155A                          M 	shift
0000155A                            		d68k_Size	'w'				; set instruction size
0000155A 2277                     M 	dc.b	d68ke_size,'w'
0000155C                            		d68k_Push	$1FC				; push check value into stack
0000155C 1C00                     M 	dc.b	d68ke_push,narg-1
0000155E                          M 	rept	narg
0000155E 01FC                     M 	dc.w	$1fc
00001560                          M 	shift
00001560                            		d68k_Jump	d68k_CommonIns4			; run common instruction code
00001560 0200                     M 	dc.b	d68ke_jump,0
00001562                          M 	d68k_ref	d68k_commonins4
00001562                          M 	rept	narg
00001562 0000                     M 	dc.w	d68k_commonins4-*-2
00001564                          M 	shift
00001564                            ; ==============================================================
00001564                            ; --------------------------------------------------------------
00001564                            ; Print tiny value from instruction to stack
00001564                            ; --------------------------------------------------------------
00001564                            
00001564                            d68k_PrintTinyValue:
00001564 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
00001568 10FC 0023                  		move.b	#'#',(a0)+				; print a #
0000156C 10FC 00EE                  		move.b	#dcred,(a0)+				; RED
00001570                            
00001570 3200                       		move.w	d0,d1					; copy instruction to d1
00001572 EF59                       		rol.w	#16-9,d1				; rotate register into place
00001574 0241 0007                  		and.w	#7,d1					; keep in range
00001578 6600                       		bne.s	.not0					; branch if not
0000157A 7208                       		moveq	#8,d1					; set to 8 instead
0000157C                            
0000157C                            .not0
0000157C 0601 0030                  		add.b	#'0',d1					; turn into digit
00001580 10C1                       		move.b	d1,(a0)+				; print it!
00001582                            ; ==============================================================
00001582                            ; --------------------------------------------------------------
00001582                            ; Go back to running the script
00001582                            ; --------------------------------------------------------------
00001582                            
00001582                            d68k_JumpScript4:
00001582 4EFA F7C6                  		jmp	d68k_RunScript(pc)			; run the script now
00001586                            ; ==============================================================
00001586                            ; --------------------------------------------------------------
00001586                            ; Shift instruction print handler
00001586                            ; --------------------------------------------------------------
00001586                            
00001586                            d68k_PrintShift:
00001586 3223                       		move.w	-(a3),d1				; load shift count to d1
00001588 4EBA F8F2                  		jsr	d68k_ShiftIns(pc)			; shift into place
0000158C                            
0000158C 7600                       		moveq	#0,d3
0000158E 0242 0003                  		and.w	#3,d2					; keep in range
00001592 163B 2000                  		move.b	.inssz(pc,d2.w),d3			; load the correct size
00001596                            
00001596 143B 2000                  		move.b	.insoffs(pc,d2.w),d2			; load the correct offset
0000159A 49FB 2000                  		lea	.insdata(pc,d2.w),a4			; load the array to a4
0000159E 10FC 00EC                  		move.b	#dcblue,(a0)+				; BLUE
000015A2                            
000015A2                            .copyloop
000015A2 10DC                       		move.b	(a4)+,(a0)+				; COPY letter
000015A4 51CB FFFC                  		dbf	d3,.copyloop				; loop for all entries
000015A8                            
000015A8 0800 0008                  		btst	#8,d0					; check which direction to use
000015AC 57C3                       		seq	d3					; if yes, results in 0
000015AE 4883                       		ext.w	d3					; if not, results in $FFFF
000015B0                            
000015B0 10FB 3000                  		move.b	.direction+1(pc,d3.w),(a0)+		; print direction character
000015B4 60CC                       		bra.s	d68k_JumpScript4
000015B6                            ; --------------------------------------------------------------
000015B6                            
000015B6 0101 0201                  .inssz		dc.b 2-1, 2-1, 3-1, 2-1
000015BA 0200 0404                  .insoffs	dc.b 2, 0, 4, 4
000015BE 72                         .direction	dc.b 'r'
000015BF 6C73 6173 726F 78          .insdata	dc.b 'lsasrox'
000015C6                            		even
000015C6                            ; ==============================================================
000015C6                            ; --------------------------------------------------------------
000015C6                            ; 4XXX instruction handler
000015C6                            ; --------------------------------------------------------------
000015C6                            
000015C6                            d68k_i4xxx:	; doing it this way saves like a massive total of 8 bytes! oh my god! =/
000015C6                            		d68k_ReadSrc	$80, $40, $100			; read the instruction from source
000015C6 0A02                     M 	dc.b	d68ke_readsrc,narg-1
000015C8                          M 	rept	narg
000015C8 0080                     M 	dc.w	$80
000015CA                          M 	shift
000015CA 0040                     M 	dc.w	$40
000015CC                          M 	shift
000015CC 0100                     M 	dc.w	$100
000015CE                          M 	shift
000015CE                            		d68k_Cmp	-2, $100, d68k_iLeaChk		; check if LEA or CHK, and if so, branch
000015CE 18FE                     M 	dc.b	d68ke_cmp,-2
000015D0 0100                     M 	dc.w	$100
000015D2                          M 	d68k_ref	d68k_ileachk
000015D2                          M 	rept	narg
000015D2 0000                     M 	dc.w	d68k_ileachk-*-2
000015D4                          M 	shift
000015D4                            		d68k_Exec	.grab				; print shift instruction
000015D4 0000                     M 	dc.b	d68ke_exec,0
000015D6                          M 	d68k_ref	.grab
000015D6                          M 	rept	narg
000015D6 0000                     M 	dc.w	.grab-*-2
000015D8                          M 	shift
000015D8                            ; --------------------------------------------------------------
000015D8                            
000015D8                            .grab
000015D8 3200                       		move.w	d0,d1					; copy instruction to d1
000015DA 0241 0E00                  		and.w	#$0E00,d1				; get 3 upper bits of second nibble
000015DE EE49                       		lsr.w	#7,d1					; shift into place
000015E0                            
000015E0 3400                       		move.w	d0,d2					; copy instruction to d2
000015E2 0242 00C0                  		and.w	#$C0,d2					; check for a specific value
000015E6 0C42 00C0                  		cmp.w	#$C0,d2					;
000015EA 6600                       		bne.s	.nope					; branch if not
000015EC 5441                       		addq.w	#2,d1					; go to next entry
000015EE                            
000015EE                            .nope
000015EE 323B 1000                  		move.w	.tbl(pc,d1.w),d1			; load offset to d1
000015F2 45FB 1000                  		lea	.tbl(pc,d1.w),a2			; get entry as script
000015F6 608A                       		bra.s	d68k_JumpScript4
000015F8                            ; --------------------------------------------------------------
000015F8                            
000015F8 0000 0000 0000 0000        .tbl		dc.w d68k_iNegx-.tbl, d68k_iMovefSRCCR-.tbl, d68k_iClr-.tbl,  d68k_iMovefSRCCR-.tbl
00001600 0000 0000 0000 0000        		dc.w d68k_iNeg-.tbl,  d68k_iMovetSRCCR-.tbl, d68k_iNot-.tbl,  d68k_iMovetSRCCR-.tbl
00001608 0000 0000 0000 0000        		dc.w d68k_iNbcd-.tbl, d68k_iNbcd-.tbl,       d68k_iTst-.tbl,  d68k_iTas-.tbl
00001610 0000 0000 0000 0000        		dc.w d68k_iMovem-.tbl,d68k_iMovem-.tbl,      d68k_i4E4X-.tbl, d68k_iJmpJsr-.tbl
00001618                            ; ==============================================================
00001618                            ; --------------------------------------------------------------
00001618                            ; MOVE from/to SR and CCR instruction handlers
00001618                            ; --------------------------------------------------------------
00001618                            
00001618                            d68k_iMovefSRCCR:
00001618                            		d68k_Print	' ', d68k_sMove			; print MOVE
00001618 0620                     M 	dc.b	d68ke_print,' '
0000161A                          M 	d68k_ref	d68k_smove
0000161A                          M 	rept	narg
0000161A 0000                     M 	dc.w	d68k_smove-*-2
0000161C                          M 	shift
0000161C                            		d68k_ReadSrc	$200				; read the instruction from source
0000161C 0A00                     M 	dc.b	d68ke_readsrc,narg-1
0000161E                          M 	rept	narg
0000161E 0200                     M 	dc.w	$200
00001620                          M 	shift
00001620                            		d68k_Cmp	-2, $000, .sr			; check for SR, and branch if so
00001620 18FE                     M 	dc.b	d68ke_cmp,-2
00001622 0000                     M 	dc.w	$000
00001624                          M 	d68k_ref	.sr
00001624                          M 	rept	narg
00001624 0000                     M 	dc.w	.sr-*-2
00001626                          M 	shift
00001626                            ; --------------------------------------------------------------
00001626                            
00001626                            		d68k_Print	'r', d68k_sCC			; print CCR
00001626 0672                     M 	dc.b	d68ke_print,'r'
00001628                          M 	d68k_ref	d68k_scc
00001628                          M 	rept	narg
00001628 0000                     M 	dc.w	d68k_scc-*-2
0000162A                          M 	shift
0000162A                            		d68k_Size	'b'				; set instruction size
0000162A 2262                     M 	dc.b	d68ke_size,'b'
0000162C                            		d68k_Jump	.common				; common code
0000162C 0200                     M 	dc.b	d68ke_jump,0
0000162E                          M 	d68k_ref	.common
0000162E                          M 	rept	narg
0000162E 0000                     M 	dc.w	.common-*-2
00001630                          M 	shift
00001630                            
00001630                            .sr		d68k_Print	'r', d68k_sS2			; print S
00001630 0672                     M 	dc.b	d68ke_print,'r'
00001632                          M 	d68k_ref	d68k_ss2
00001632                          M 	rept	narg
00001632 0000                     M 	dc.w	d68k_ss2-*-2
00001634                          M 	shift
00001634                            		d68k_Size	'w'				; set instruction size
00001634 2277                     M 	dc.b	d68ke_size,'w'
00001636                            ; --------------------------------------------------------------
00001636                            
00001636                            .common		d68k_Push	$3FD				; push check value into stack
00001636 1C00                     M 	dc.b	d68ke_push,narg-1
00001638                          M 	rept	narg
00001638 03FD                     M 	dc.w	$3fd
0000163A                          M 	shift
0000163A                            		d68k_Jump	d68k_CommonIns8			; print addressing mode
0000163A 0200                     M 	dc.b	d68ke_jump,0
0000163C                          M 	d68k_ref	d68k_commonins8
0000163C                          M 	rept	narg
0000163C FCD8                     M 	dc.w	d68k_commonins8-*-2
0000163E                          M 	shift
0000163E                            ; --------------------------------------------------------------
0000163E                            
0000163E                            d68k_iMovetSRCCR:
0000163E                            		d68k_Print	' ', d68k_sMove			; print MOVE
0000163E 0620                     M 	dc.b	d68ke_print,' '
00001640                          M 	d68k_ref	d68k_smove
00001640                          M 	rept	narg
00001640 0000                     M 	dc.w	d68k_smove-*-2
00001642                          M 	shift
00001642                            		d68k_ReadSrc	$200				; read the instruction from source
00001642 0A00                     M 	dc.b	d68ke_readsrc,narg-1
00001644                          M 	rept	narg
00001644 0200                     M 	dc.w	$200
00001646                          M 	shift
00001646                            
00001646                            		d68k_Size	'w'				; set instruction size
00001646 2277                     M 	dc.b	d68ke_size,'w'
00001648                            		d68k_Cmp	0, $200, .sz			; check for SR, and branch if so
00001648 1800                     M 	dc.b	d68ke_cmp,0
0000164A 0200                     M 	dc.w	$200
0000164C                          M 	d68k_ref	.sz
0000164C                          M 	rept	narg
0000164C 0000                     M 	dc.w	.sz-*-2
0000164E                          M 	shift
0000164E                            		d68k_Size	'b'				; set instruction size
0000164E 2262                     M 	dc.b	d68ke_size,'b'
00001650                            ; --------------------------------------------------------------
00001650                            
00001650                            .sz		d68k_Push	$FFD				; push check value into stack
00001650 1C00                     M 	dc.b	d68ke_push,narg-1
00001652                          M 	rept	narg
00001652 0FFD                     M 	dc.w	$ffd
00001654                          M 	shift
00001654                            		d68k_Mode	0				; print addressing mode
00001654 1600                     M 	dc.b	d68ke_mode,0
00001656                            		d68k_Print	0, d68k_sComma			; print ,
00001656 0600                     M 	dc.b	d68ke_print,0
00001658                          M 	d68k_ref	d68k_scomma
00001658                          M 	rept	narg
00001658 0000                     M 	dc.w	d68k_scomma-*-2
0000165A                          M 	shift
0000165A                            ; --------------------------------------------------------------
0000165A                            
0000165A                            		d68k_Cmp	-2, $200, .sr			; check for SR, and branch if so
0000165A 18FE                     M 	dc.b	d68ke_cmp,-2
0000165C 0200                     M 	dc.w	$200
0000165E                          M 	d68k_ref	.sr
0000165E                          M 	rept	narg
0000165E 0000                     M 	dc.w	.sr-*-2
00001660                          M 	shift
00001660                            		d68k_Print	'r', d68k_sCC			; print CCR
00001660 0672                     M 	dc.b	d68ke_print,'r'
00001662                          M 	d68k_ref	d68k_scc
00001662                          M 	rept	narg
00001662 0000                     M 	dc.w	d68k_scc-*-2
00001664                          M 	shift
00001664                            		d68k_Finish
00001664 0400                     M 	dc.b	d68ke_finish,0
00001666                            
00001666                            .sr		d68k_Print	'r', d68k_sS2			; print S
00001666 0672                     M 	dc.b	d68ke_print,'r'
00001668                          M 	d68k_ref	d68k_ss2
00001668                          M 	rept	narg
00001668 0000                     M 	dc.w	d68k_ss2-*-2
0000166A                          M 	shift
0000166A                            		d68k_Finish
0000166A 0400                     M 	dc.b	d68ke_finish,0
0000166C                            ; ==============================================================
0000166C                            ; --------------------------------------------------------------
0000166C                            ; 4XXX common type instruction handlers
0000166C                            ; --------------------------------------------------------------
0000166C                            
0000166C                            d68k_iNegx:	d68k_Print	'x', d68k_sNeg			; print negx
0000166C 0678                     M 	dc.b	d68ke_print,'x'
0000166E                          M 	d68k_ref	d68k_sneg
0000166E                          M 	rept	narg
0000166E 0000                     M 	dc.w	d68k_sneg-*-2
00001670                          M 	shift
00001670                            		d68k_Jump	d68k_CommonIns2			; common code
00001670 0200                     M 	dc.b	d68ke_jump,0
00001672                          M 	d68k_ref	d68k_commonins2
00001672                          M 	rept	narg
00001672 0000                     M 	dc.w	d68k_commonins2-*-2
00001674                          M 	shift
00001674                            ; --------------------------------------------------------------
00001674                            
00001674                            d68k_iNeg:	d68k_Print	0, d68k_sNeg			; print neg
00001674 0600                     M 	dc.b	d68ke_print,0
00001676                          M 	d68k_ref	d68k_sneg
00001676                          M 	rept	narg
00001676 0000                     M 	dc.w	d68k_sneg-*-2
00001678                          M 	shift
00001678                            		d68k_Jump	d68k_CommonIns2			; common code
00001678 0200                     M 	dc.b	d68ke_jump,0
0000167A                          M 	d68k_ref	d68k_commonins2
0000167A                          M 	rept	narg
0000167A 0000                     M 	dc.w	d68k_commonins2-*-2
0000167C                          M 	shift
0000167C                            ; --------------------------------------------------------------
0000167C                            
0000167C                            d68k_iClr:	d68k_Print	0, d68k_sClr			; print clr
0000167C 0600                     M 	dc.b	d68ke_print,0
0000167E                          M 	d68k_ref	d68k_sclr
0000167E                          M 	rept	narg
0000167E 0000                     M 	dc.w	d68k_sclr-*-2
00001680                          M 	shift
00001680                            		d68k_Jump	d68k_CommonIns2			; common code
00001680 0200                     M 	dc.b	d68ke_jump,0
00001682                          M 	d68k_ref	d68k_commonins2
00001682                          M 	rept	narg
00001682 0000                     M 	dc.w	d68k_commonins2-*-2
00001684                          M 	shift
00001684                            ; --------------------------------------------------------------
00001684                            
00001684                            d68k_iNot:	d68k_Print	0, d68k_sNot			; print not
00001684 0600                     M 	dc.b	d68ke_print,0
00001686                          M 	d68k_ref	d68k_snot
00001686                          M 	rept	narg
00001686 0000                     M 	dc.w	d68k_snot-*-2
00001688                          M 	shift
00001688                            		d68k_Jump	d68k_CommonIns2			; common code
00001688 0200                     M 	dc.b	d68ke_jump,0
0000168A                          M 	d68k_ref	d68k_commonins2
0000168A                          M 	rept	narg
0000168A 0000                     M 	dc.w	d68k_commonins2-*-2
0000168C                          M 	shift
0000168C                            ; --------------------------------------------------------------
0000168C                            
0000168C                            d68k_iTst:	d68k_Print	0, d68k_sTst			; print tst
0000168C 0600                     M 	dc.b	d68ke_print,0
0000168E                          M 	d68k_ref	d68k_stst
0000168E                          M 	rept	narg
0000168E 0000                     M 	dc.w	d68k_stst-*-2
00001690                          M 	shift
00001690                            ; ==============================================================
00001690                            ; --------------------------------------------------------------
00001690                            ; Common type 2 instruction handler
00001690                            ; --------------------------------------------------------------
00001690                            
00001690                            d68k_CommonIns2:
00001690                            		d68k_InsSz	6				; print instruction size
00001690 0E06                     M 	dc.b	d68ke_inssz,6
00001692                            ; ==============================================================
00001692                            ; --------------------------------------------------------------
00001692                            ; Common type 3 instruction handler
00001692                            ; --------------------------------------------------------------
00001692                            
00001692                            d68k_CommonIns3:
00001692                            		d68k_Push	$1FD				; push check value into stack
00001692 1C00                     M 	dc.b	d68ke_push,narg-1
00001694                          M 	rept	narg
00001694 01FD                     M 	dc.w	$1fd
00001696                          M 	shift
00001696                            ; ==============================================================
00001696                            ; --------------------------------------------------------------
00001696                            ; Common type 4 instruction handler
00001696                            ; --------------------------------------------------------------
00001696                            
00001696                            d68k_CommonIns4:
00001696                            		d68k_Mode	' '				; print source addressing mode
00001696 1620                     M 	dc.b	d68ke_mode,' '
00001698                            		d68k_Finish
00001698 0400                     M 	dc.b	d68ke_finish,0
0000169A                            ; ==============================================================
0000169A                            ; --------------------------------------------------------------
0000169A                            ; NBCD instruction handler
0000169A                            ; --------------------------------------------------------------
0000169A                            
0000169A                            d68k_iNbcd:	d68k_ReadSrc	$38, $80			; read the instruction from source
0000169A 0A01                     M 	dc.b	d68ke_readsrc,narg-1
0000169C                          M 	rept	narg
0000169C 0038                     M 	dc.w	$38
0000169E                          M 	shift
0000169E 0080                     M 	dc.w	$80
000016A0                          M 	shift
000016A0                            		d68k_Cmp	-4, $80, d68k_iExt		; check if it's EXT or MOVEM, and if so, branch
000016A0 18FC                     M 	dc.b	d68ke_cmp,-4
000016A2 0080                     M 	dc.w	$80
000016A4                          M 	d68k_ref	d68k_iext
000016A4                          M 	rept	narg
000016A4 0000                     M 	dc.w	d68k_iext-*-2
000016A6                          M 	shift
000016A6                            		d68k_Cmp	0, $40, d68k_iPea		; check if it's PEA or SWAP, and if so, branch
000016A6 1800                     M 	dc.b	d68ke_cmp,0
000016A8 0040                     M 	dc.w	$40
000016AA                          M 	d68k_ref	d68k_ipea
000016AA                          M 	rept	narg
000016AA 0000                     M 	dc.w	d68k_ipea-*-2
000016AC                          M 	shift
000016AC                            
000016AC                            		d68k_Print	0, d68k_sNbcd			; print NBCD
000016AC 0600                     M 	dc.b	d68ke_print,0
000016AE                          M 	d68k_ref	d68k_snbcd
000016AE                          M 	rept	narg
000016AE 0000                     M 	dc.w	d68k_snbcd-*-2
000016B0                          M 	shift
000016B0                            		d68k_Size	'w'				; set instruction size
000016B0 2277                     M 	dc.b	d68ke_size,'w'
000016B2                            		d68k_Jump	d68k_CommonIns3			; run common instruction code
000016B2 0200                     M 	dc.b	d68ke_jump,0
000016B4                          M 	d68k_ref	d68k_commonins3
000016B4                          M 	rept	narg
000016B4 FFDC                     M 	dc.w	d68k_commonins3-*-2
000016B6                          M 	shift
000016B6                            ; ==============================================================
000016B6                            ; --------------------------------------------------------------
000016B6                            ; PEA instruction handler
000016B6                            ; --------------------------------------------------------------
000016B6                            
000016B6                            d68k_iPea:	d68k_Pop	2				; check the middle value quickly
000016B6 1E02                     M 	dc.b	d68ke_pop,2
000016B8                            		d68k_Cmp	-4, $00, d68k_iSwap		; check if it's SWAP, and if so, branch
000016B8 18FC                     M 	dc.b	d68ke_cmp,-4
000016BA 0000                     M 	dc.w	$00
000016BC                          M 	d68k_ref	d68k_iswap
000016BC                          M 	rept	narg
000016BC 0000                     M 	dc.w	d68k_iswap-*-2
000016BE                          M 	shift
000016BE                            
000016BE                            		d68k_Print	0, d68k_sPea			; print PEA
000016BE 0600                     M 	dc.b	d68ke_print,0
000016C0                          M 	d68k_ref	d68k_spea
000016C0                          M 	rept	narg
000016C0 0000                     M 	dc.w	d68k_spea-*-2
000016C2                          M 	shift
000016C2                            		d68k_Size	'w'				; set instruction size
000016C2 2277                     M 	dc.b	d68ke_size,'w'
000016C4                            		d68k_Push	$7E5				; push check value into stack
000016C4 1C00                     M 	dc.b	d68ke_push,narg-1
000016C6                          M 	rept	narg
000016C6 07E5                     M 	dc.w	$7e5
000016C8                          M 	shift
000016C8                            		d68k_Jump	d68k_CommonIns4			; run common instruction code
000016C8 0200                     M 	dc.b	d68ke_jump,0
000016CA                          M 	d68k_ref	d68k_commonins4
000016CA                          M 	rept	narg
000016CA FFCA                     M 	dc.w	d68k_commonins4-*-2
000016CC                          M 	shift
000016CC                            ; ==============================================================
000016CC                            ; --------------------------------------------------------------
000016CC                            ; TAS instruction handler
000016CC                            ; --------------------------------------------------------------
000016CC                            
000016CC                            d68k_iTas:	d68k_ReadSrc	$3F				; read the instruction from source
000016CC 0A00                     M 	dc.b	d68ke_readsrc,narg-1
000016CE                          M 	rept	narg
000016CE 003F                     M 	dc.w	$3f
000016D0                          M 	shift
000016D0                            		d68k_Cmp	-2, $3C, d68k_iIllegal		; check for illegal instruction
000016D0 18FE                     M 	dc.b	d68ke_cmp,-2
000016D2 003C                     M 	dc.w	$3c
000016D4                          M 	d68k_ref	d68k_iillegal
000016D4                          M 	rept	narg
000016D4 0000                     M 	dc.w	d68k_iillegal-*-2
000016D6                          M 	shift
000016D6                            
000016D6                            		d68k_Print	0, d68k_sTas			; print TAS
000016D6 0600                     M 	dc.b	d68ke_print,0
000016D8                          M 	d68k_ref	d68k_stas
000016D8                          M 	rept	narg
000016D8 0000                     M 	dc.w	d68k_stas-*-2
000016DA                          M 	shift
000016DA                            		d68k_Size	'b'				; set instruction size
000016DA 2262                     M 	dc.b	d68ke_size,'b'
000016DC                            		d68k_Jump	d68k_CommonIns3			; run common instruction code
000016DC 0200                     M 	dc.b	d68ke_jump,0
000016DE                          M 	d68k_ref	d68k_commonins3
000016DE                          M 	rept	narg
000016DE FFB2                     M 	dc.w	d68k_commonins3-*-2
000016E0                          M 	shift
000016E0                            ; ==============================================================
000016E0                            ; --------------------------------------------------------------
000016E0                            ; SWAP instruction handler
000016E0                            ; --------------------------------------------------------------
000016E0                            
000016E0                            d68k_iSwap:	d68k_Print	' ', d68k_sSwap			; print SWAP
000016E0 0620                     M 	dc.b	d68ke_print,' '
000016E2                          M 	d68k_ref	d68k_sswap
000016E2                          M 	rept	narg
000016E2 0000                     M 	dc.w	d68k_sswap-*-2
000016E4                          M 	shift
000016E4                            ; ==============================================================
000016E4                            ; --------------------------------------------------------------
000016E4                            ; Common type 9 instruction handler
000016E4                            ; --------------------------------------------------------------
000016E4                            
000016E4                            d68k_CommonIns9:
000016E4                            		d68k_DataReg	0				; print dreg
000016E4 1200                     M 	dc.b	d68ke_datareg,0
000016E6                            		d68k_Finish
000016E6 0400                     M 	dc.b	d68ke_finish,0
000016E8                            ; ==============================================================
000016E8                            ; --------------------------------------------------------------
000016E8                            ; JMP and JSR instruction handlers
000016E8                            ; --------------------------------------------------------------
000016E8                            
000016E8                            d68k_iJmpJsr:	d68k_ReadSrc	$40, $80			; read the instruction from source
000016E8 0A01                     M 	dc.b	d68ke_readsrc,narg-1
000016EA                          M 	rept	narg
000016EA 0040                     M 	dc.w	$40
000016EC                          M 	shift
000016EC 0080                     M 	dc.w	$80
000016EE                          M 	shift
000016EE                            		d68k_Cmp	-2, $00, d68k_iData		; check for invalid instruction
000016EE 18FE                     M 	dc.b	d68ke_cmp,-2
000016F0 0000                     M 	dc.w	$00
000016F2                          M 	d68k_ref	d68k_idata
000016F2                          M 	rept	narg
000016F2 F972                     M 	dc.w	d68k_idata-*-2
000016F4                          M 	shift
000016F4                            
000016F4                            		d68k_Cmp	-2, $00, .jsr			; check for JSR, and if so, branch
000016F4 18FE                     M 	dc.b	d68ke_cmp,-2
000016F6 0000                     M 	dc.w	$00
000016F8                          M 	d68k_ref	.jsr
000016F8                          M 	rept	narg
000016F8 0000                     M 	dc.w	.jsr-*-2
000016FA                          M 	shift
000016FA                            		d68k_Print	0, d68k_sJmp			; print JMP
000016FA 0600                     M 	dc.b	d68ke_print,0
000016FC                          M 	d68k_ref	d68k_sjmp
000016FC                          M 	rept	narg
000016FC 0000                     M 	dc.w	d68k_sjmp-*-2
000016FE                          M 	shift
000016FE                            		d68k_Jump	.common				; run common instruction code
000016FE 0200                     M 	dc.b	d68ke_jump,0
00001700                          M 	d68k_ref	.common
00001700                          M 	rept	narg
00001700 0000                     M 	dc.w	.common-*-2
00001702                          M 	shift
00001702                            
00001702                            .jsr		d68k_Print	0, d68k_sJsr			; print JSR
00001702 0600                     M 	dc.b	d68ke_print,0
00001704                          M 	d68k_ref	d68k_sjsr
00001704                          M 	rept	narg
00001704 0000                     M 	dc.w	d68k_sjsr-*-2
00001706                          M 	shift
00001706                            
00001706                            .common		d68k_Size	'w'				; set instruction size
00001706 2277                     M 	dc.b	d68ke_size,'w'
00001708                            		d68k_Push	$7E4				; push check value into stack
00001708 1C00                     M 	dc.b	d68ke_push,narg-1
0000170A                          M 	rept	narg
0000170A 07E4                     M 	dc.w	$7e4
0000170C                          M 	shift
0000170C                            		d68k_Jump	d68k_CommonIns4			; run common instruction code
0000170C 0200                     M 	dc.b	d68ke_jump,0
0000170E                          M 	d68k_ref	d68k_commonins4
0000170E                          M 	rept	narg
0000170E FF86                     M 	dc.w	d68k_commonins4-*-2
00001710                          M 	shift
00001710                            ; ==============================================================
00001710                            ; --------------------------------------------------------------
00001710                            ; ILLEGAL instruction handler
00001710                            ; --------------------------------------------------------------
00001710                            
00001710                            d68k_iIllegal:	d68k_Print	0, d68k_sIllegal		; print ILLEGAL
00001710 0600                     M 	dc.b	d68ke_print,0
00001712                          M 	d68k_ref	d68k_sillegal
00001712                          M 	rept	narg
00001712 0000                     M 	dc.w	d68k_sillegal-*-2
00001714                          M 	shift
00001714                            		d68k_Finish
00001714 0400                     M 	dc.b	d68ke_finish,0
00001716                            ; ==============================================================
00001716                            ; --------------------------------------------------------------
00001716                            ; EXT instruction handler
00001716                            ; --------------------------------------------------------------
00001716                            
00001716                            d68k_iExt2:	d68k_Print	0, d68k_sExt			; print EXT
00001716 0600                     M 	dc.b	d68ke_print,0
00001718                          M 	d68k_ref	d68k_sext
00001718                          M 	rept	narg
00001718 0000                     M 	dc.w	d68k_sext-*-2
0000171A                          M 	shift
0000171A                            		d68k_SmallSz	6				; print small instruction size
0000171A 1A06                     M 	dc.b	d68ke_smallsz,6
0000171C                            		d68k_Char	' '				; print space
0000171C 2420                     M 	dc.b	d68ke_char,' '
0000171E                            		d68k_Jump	d68k_CommonIns9			; common instruction type 9
0000171E 0200                     M 	dc.b	d68ke_jump,0
00001720                          M 	d68k_ref	d68k_commonins9
00001720                          M 	rept	narg
00001720 FFC2                     M 	dc.w	d68k_commonins9-*-2
00001722                          M 	shift
00001722                            ; --------------------------------------------------------------
00001722                            
00001722                            d68k_iExt:	d68k_Pop	2				; check the middle value quickly
00001722 1E02                     M 	dc.b	d68ke_pop,2
00001724                            		d68k_Cmp	-4, $00, d68k_iExt2		; check if it's EXT, and if so, branch
00001724 18FC                     M 	dc.b	d68ke_cmp,-4
00001726 0000                     M 	dc.w	$00
00001728                          M 	d68k_ref	d68k_iext2
00001728                          M 	rept	narg
00001728 FFEC                     M 	dc.w	d68k_iext2-*-2
0000172A                          M 	shift
0000172A                            ; ==============================================================
0000172A                            ; --------------------------------------------------------------
0000172A                            ; MOVEM instruction handler
0000172A                            ; --------------------------------------------------------------
0000172A                            
0000172A                            d68k_iMovem:	d68k_ReadSrc	$400, $380			; read the instruction from source
0000172A 0A01                     M 	dc.b	d68ke_readsrc,narg-1
0000172C                          M 	rept	narg
0000172C 0400                     M 	dc.w	$400
0000172E                          M 	shift
0000172E 0380                     M 	dc.w	$380
00001730                          M 	shift
00001730                            		d68k_Cmp	-2, $80, .continue 		; check if valid, and if so, branch
00001730 18FE                     M 	dc.b	d68ke_cmp,-2
00001732 0080                     M 	dc.w	$80
00001734                          M 	d68k_ref	.continue
00001734                          M 	rept	narg
00001734 0000                     M 	dc.w	.continue-*-2
00001736                          M 	shift
00001736                            		d68k_Jump	d68k_iData			; treat as data
00001736 0200                     M 	dc.b	d68ke_jump,0
00001738                          M 	d68k_ref	d68k_idata
00001738                          M 	rept	narg
00001738 F92C                     M 	dc.w	d68k_idata-*-2
0000173A                          M 	shift
0000173A                            ; --------------------------------------------------------------
0000173A                            
0000173A                            .continue	d68k_Print	'm', d68k_sMove			; print MOVEM
0000173A 066D                     M 	dc.b	d68ke_print,'m'
0000173C                          M 	d68k_ref	d68k_smove
0000173C                          M 	rept	narg
0000173C 0000                     M 	dc.w	d68k_smove-*-2
0000173E                          M 	shift
0000173E                            		d68k_SmallSz	6				; print small instruction size
0000173E 1A06                     M 	dc.b	d68ke_smallsz,6
00001740                            		d68k_Char	' '				; print space
00001740 2420                     M 	dc.b	d68ke_char,' '
00001742                            		d68k_Read	$FFFF				; read the registers to stack
00001742 0C00                     M 	dc.b	d68ke_read,narg-1
00001744                          M 	rept	narg
00001744 FFFF                     M 	dc.w	$ffff
00001746                          M 	shift
00001746                            
00001746                            		d68k_Swap	-2				; swap with the last entry
00001746 20FE                     M 	dc.b	d68ke_swap,-2
00001748                            		d68k_Cmp	0, $000, .skip1			; check if ARG -> EA, and if so, branch
00001748 1800                     M 	dc.b	d68ke_cmp,0
0000174A 0000                     M 	dc.w	$000
0000174C                          M 	d68k_ref	.skip1
0000174C                          M 	rept	narg
0000174C 0000                     M 	dc.w	.skip1-*-2
0000174E                          M 	shift
0000174E                            		d68k_Push	$7EC				; push check value into stack
0000174E 1C00                     M 	dc.b	d68ke_push,narg-1
00001750                          M 	rept	narg
00001750 07EC                     M 	dc.w	$7ec
00001752                          M 	shift
00001752                            		d68k_Mode	0				; print source addressing mode
00001752 1600                     M 	dc.b	d68ke_mode,0
00001754                            		d68k_Print	0, d68k_sComma			; print ,
00001754 0600                     M 	dc.b	d68ke_print,0
00001756                          M 	d68k_ref	d68k_scomma
00001756                          M 	rept	narg
00001756 0000                     M 	dc.w	d68k_scomma-*-2
00001758                          M 	shift
00001758                            
00001758                            .skip1		d68k_Exec	.regs				; print registers
00001758 0000                     M 	dc.b	d68ke_exec,0
0000175A                          M 	d68k_ref	.regs
0000175A                          M 	rept	narg
0000175A 0000                     M 	dc.w	.regs-*-2
0000175C                          M 	shift
0000175C                            		d68k_Cmp	-2, $400, d68k_Finish1		; check if EA -> ARG, and if so, branch
0000175C 18FE                     M 	dc.b	d68ke_cmp,-2
0000175E 0400                     M 	dc.w	$400
00001760                          M 	d68k_ref	d68k_finish1
00001760                          M 	rept	narg
00001760 FB0E                     M 	dc.w	d68k_finish1-*-2
00001762                          M 	shift
00001762                            		d68k_Push	$1F4				; push check value into stack
00001762 1C00                     M 	dc.b	d68ke_push,narg-1
00001764                          M 	rept	narg
00001764 01F4                     M 	dc.w	$1f4
00001766                          M 	shift
00001766                            		d68k_Jump	d68k_CommonIns8			; go to standard handler
00001766 0200                     M 	dc.b	d68ke_jump,0
00001768                          M 	d68k_ref	d68k_commonins8
00001768                          M 	rept	narg
00001768 FBAC                     M 	dc.w	d68k_commonins8-*-2
0000176A                          M 	shift
0000176A                            ; ==============================================================
0000176A                            ; --------------------------------------------------------------
0000176A                            ; MOVEM registers handler
0000176A                            ; --------------------------------------------------------------
0000176A                            
0000176A                            .regs
0000176A 362B FFFC                  		move.w	-4(a3),d3				; copy register list to d3
0000176E 6600                       		bne.s	.notnull				; branch if 1 or more registers are used
00001770 10FC 00EE                  		move.b	#dcred,(a0)+				; WHITE
00001774 10FC 0030                  		move.b	#'0',(a0)+				; print a 0
00001778 6000                       		bra.s	.cont
0000177A                            ; --------------------------------------------------------------
0000177A                            
0000177A                            .notnull
0000177A 3200                       		move.w	d0,d1					; copy instruction to d1
0000177C 0241 0038                  		and.w	#$38,d1					; get the eamode to d1
00001780 0C41 0020                  		cmp.w	#8*4,d1					; check if -(AN)
00001784 6600                       		bne.s	.normal					; branch if not
00001786                            
00001786                            	; now here is some WTF for you. For this one specific mode, the bitfield is FUCKING BACKWARDS. You heard me right. Backwards. WTF Motorola!!!
00001786 3203                       		move.w	d3,d1					; copy register list to d1
00001788 7600                       		moveq	#0,d3					; clear register list
0000178A 780F                       		moveq	#16-1,d4				; set repeat count to d4
0000178C                            
0000178C                            .invert
0000178C E249                       		lsr.w	#1,d1					; shift the next bit to carry
0000178E D743                       		addx.w	d3,d3					; add carry and shift d3
00001790 51CC FFFA                  		dbf	d4,.invert				; repeat like 16 times wtf
00001794                            ; --------------------------------------------------------------
00001794                            
00001794                            .normal
00001794 3F07                       		move.w	d7,-(sp)				; push d7 to stack
00001796 7C00                       		moveq	#0,d6					; set current bit to 0
00001798 74FF                       		moveq	#-1,d2					; set starting bit to null
0000179A 7E00                       		moveq	#0,d7					; no registers are written
0000179C                            
0000179C                            .loop
0000179C E24B                       		lsr.w	#1,d3					; shift the next bit into carry
0000179E 6400                       		bcc.s	.notset					; if not set, branch
000017A0 4A02                       		tst.b	d2					; check if we have found a starting bit
000017A2 6A00                       		bpl.s	.next					; if yes, go to next iteration
000017A4 3406                       		move.w	d6,d2					; set as the new starting bit
000017A6                            ; --------------------------------------------------------------
000017A6                            
000017A6                            .next
000017A6 5246                       		addq.w	#1,d6					; go to next bit
000017A8 0C46 0011                  		cmp.w	#17,d6					; check if bit 17
000017AC 6FEE                       		ble.s	.loop					; if not, go to loop
000017AE                            
000017AE                            .cont
000017AE 3E1F                       		move.w	(sp)+,d7				; pop d7 from stack
000017B0 4EFA F598                  		jmp	d68k_RunScript(pc)			; run the script now
000017B4                            ; --------------------------------------------------------------
000017B4                            
000017B4                            .notset
000017B4 4A02                       		tst.b	d2					; check if we have found a starting bit
000017B6 6BEE                       		bmi.s	.next					; if not, go to next iteration
000017B8 3A06                       		move.w	d6,d5					; copy ending bit to d5
000017BA 5345                       		subq.w	#1,d5					; align it correctly
000017BC                            
000017BC                            	; print separator
000017BC 4AC7                       		tas	d7					; check if we have written a register already
000017BE 6A00                       		bpl.s	.nowrite				; branch if not
000017C0 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
000017C4 10FC 002F                  		move.b	#'/',(a0)+				; print a /
000017C8                            
000017C8                            	; print out an appropriate version of the bit string
000017C8                            .nowrite
000017C8 3842                       		move.w	d2,a4					; store a4 temporarily
000017CA 4EBA F6A8                  		jsr	d68k_PrintReg3(pc)			; print the starting register
000017CE B8C5                       		cmp.w	d5,a4					; check if the distance is 0 registers
000017D0 6700                       		beq.s	.reset					; branch if yes
000017D2                            
000017D2 10FC 00E8                  		move.b	#dcwhite,(a0)+				; WHITE
000017D6 10FC 002D                  		move.b	#'-',(a0)+				; print a -
000017DA 3405                       		move.w	d5,d2					; copy ending register to d2
000017DC 4EBA F696                  		jsr	d68k_PrintReg3(pc)			; print it
000017E0                            
000017E0                            .reset
000017E0 74FF                       		moveq	#-1,d2					; set no starting bit
000017E2 60C2                       		bra.s	.next					; go to next iteration
000017E4                            ; ==============================================================
000017E4                            ; --------------------------------------------------------------
000017E4                            ; LEA and CHK instruction handlers
000017E4                            ; --------------------------------------------------------------
000017E4                            
000017E4                            d68k_iLeaChk:	d68k_Size	'w'				; set instruction size
000017E4 2277                     M 	dc.b	d68ke_size,'w'
000017E6                            		d68k_Cmp	-2, $00, .chk			; check if CHK, and if so, branch
000017E6 18FE                     M 	dc.b	d68ke_cmp,-2
000017E8 0000                     M 	dc.w	$00
000017EA                          M 	d68k_ref	.chk
000017EA                          M 	rept	narg
000017EA 0000                     M 	dc.w	.chk-*-2
000017EC                          M 	shift
000017EC                            ; --------------------------------------------------------------
000017EC                            
000017EC                            	; LEA
000017EC                            		d68k_Cmp	-2, $00, d68k_iData		; check for invalid instruction
000017EC 18FE                     M 	dc.b	d68ke_cmp,-2
000017EE 0000                     M 	dc.w	$00
000017F0                          M 	d68k_ref	d68k_idata
000017F0                          M 	rept	narg
000017F0 F874                     M 	dc.w	d68k_idata-*-2
000017F2                          M 	shift
000017F2                            
000017F2                            		d68k_Print	' ', d68k_sLea			; print lea
000017F2 0620                     M 	dc.b	d68ke_print,' '
000017F4                          M 	d68k_ref	d68k_slea
000017F4                          M 	rept	narg
000017F4 0000                     M 	dc.w	d68k_slea-*-2
000017F6                          M 	shift
000017F6                            		d68k_Push	$7E4				; push check value into stack
000017F6 1C00                     M 	dc.b	d68ke_push,narg-1
000017F8                          M 	rept	narg
000017F8 07E4                     M 	dc.w	$7e4
000017FA                          M 	shift
000017FA                            		d68k_Mode	0				; print source addressing mode
000017FA 1600                     M 	dc.b	d68ke_mode,0
000017FC                            		d68k_Jump	d68k_CommonIns6			; go to standard handler
000017FC 0200                     M 	dc.b	d68ke_jump,0
000017FE                          M 	d68k_ref	d68k_commonins6
000017FE                          M 	rept	narg
000017FE FAA6                     M 	dc.w	d68k_commonins6-*-2
00001800                          M 	shift
00001800                            ; --------------------------------------------------------------
00001800                            
00001800                            .chk	; CHK
00001800                            		d68k_Print	' ', d68k_sChk			; print chk
00001800 0620                     M 	dc.b	d68ke_print,' '
00001802                          M 	d68k_ref	d68k_schk
00001802                          M 	rept	narg
00001802 0000                     M 	dc.w	d68k_schk-*-2
00001804                          M 	shift
00001804                            		d68k_Push	$FFD				; push check value into stack
00001804 1C00                     M 	dc.b	d68ke_push,narg-1
00001806                          M 	rept	narg
00001806 0FFD                     M 	dc.w	$ffd
00001808                          M 	shift
00001808                            		d68k_Mode	0				; print source addressing mode
00001808 1600                     M 	dc.b	d68ke_mode,0
0000180A                            		d68k_Jump	d68k_WriteReg1			; go to standard handler
0000180A 0200                     M 	dc.b	d68ke_jump,0
0000180C                          M 	d68k_ref	d68k_writereg1
0000180C                          M 	rept	narg
0000180C FA5C                     M 	dc.w	d68k_writereg1-*-2
0000180E                          M 	shift
0000180E                            ; ==============================================================
0000180E                            ; --------------------------------------------------------------
0000180E                            ; TRAP instruction handler
0000180E                            ; --------------------------------------------------------------
0000180E                            
0000180E                            d68k_iTrap:	; LEWD OWO
0000180E                            		d68k_Print	0, d68k_sTrap			; print TRAP
0000180E 0600                     M 	dc.b	d68ke_print,0
00001810                          M 	d68k_ref	d68k_strap
00001810                          M 	rept	narg
00001810 0000                     M 	dc.w	d68k_strap-*-2
00001812                          M 	shift
00001812                            		d68k_ReadSrc	$0F				; read the instruction from source
00001812 0A00                     M 	dc.b	d68ke_readsrc,narg-1
00001814                          M 	rept	narg
00001814 000F                     M 	dc.w	$0f
00001816                          M 	shift
00001816                            		d68k_PrintNum	d68kn_Byte			; write the byte value
00001816 0800                     M 	dc.b	d68ke_printnum,d68kn_byte
00001818                            		d68k_Finish
00001818 0400                     M 	dc.b	d68ke_finish,0
0000181A                            ; ==============================================================
0000181A                            ; --------------------------------------------------------------
0000181A                            ; LINK and UNLK instruction handler
0000181A                            ; --------------------------------------------------------------
0000181A                            
0000181A                            d68k_iLink:	d68k_Pop	-2				; pop temporary value
0000181A 1EFE                     M 	dc.b	d68ke_pop,-2
0000181C                            		d68k_Cmp	-2, $08, .unlk			; check if UNLK, and if so, branch
0000181C 18FE                     M 	dc.b	d68ke_cmp,-2
0000181E 0008                     M 	dc.w	$08
00001820                          M 	d68k_ref	.unlk
00001820                          M 	rept	narg
00001820 0000                     M 	dc.w	.unlk-*-2
00001822                          M 	shift
00001822                            
00001822                            		d68k_Print	' ', d68k_sLink			; print link
00001822 0620                     M 	dc.b	d68ke_print,' '
00001824                          M 	d68k_ref	d68k_slink
00001824                          M 	rept	narg
00001824 0000                     M 	dc.w	d68k_slink-*-2
00001826                          M 	shift
00001826                            		d68k_AddrReg	0				; print areg
00001826 1400                     M 	dc.b	d68ke_addrreg,0
00001828                            		d68k_Print	0, d68k_sComma			; print ,
00001828 0600                     M 	dc.b	d68ke_print,0
0000182A                          M 	d68k_ref	d68k_scomma
0000182A                          M 	rept	narg
0000182A 0000                     M 	dc.w	d68k_scomma-*-2
0000182C                          M 	shift
0000182C                            		d68k_Char	'#'				; print #
0000182C 2423                     M 	dc.b	d68ke_char,'#'
0000182E                            		d68k_Jump	d68k_CommonIns7
0000182E 0200                     M 	dc.b	d68ke_jump,0
00001830                          M 	d68k_ref	d68k_commonins7
00001830                          M 	rept	narg
00001830 F856                     M 	dc.w	d68k_commonins7-*-2
00001832                          M 	shift
00001832                            ; --------------------------------------------------------------
00001832                            
00001832                            .unlk		d68k_Print	' ', d68k_sUnlk			; print unlk
00001832 0620                     M 	dc.b	d68ke_print,' '
00001834                          M 	d68k_ref	d68k_sunlk
00001834                          M 	rept	narg
00001834 0000                     M 	dc.w	d68k_sunlk-*-2
00001836                          M 	shift
00001836                            		d68k_Jump	d68k_CommonIns10		; go to standard handler
00001836 0200                     M 	dc.b	d68ke_jump,0
00001838                          M 	d68k_ref	d68k_commonins10
00001838                          M 	rept	narg
00001838 F9A8                     M 	dc.w	d68k_commonins10-*-2
0000183A                          M 	shift
0000183A                            ; ==============================================================
0000183A                            ; --------------------------------------------------------------
0000183A                            ; MOVE USP instruction handler
0000183A                            ; --------------------------------------------------------------
0000183A                            
0000183A                            d68k_iMvUSP:	d68k_Print	' ', d68k_sMove			; print MOVE
0000183A 0620                     M 	dc.b	d68ke_print,' '
0000183C                          M 	d68k_ref	d68k_smove
0000183C                          M 	rept	narg
0000183C 0000                     M 	dc.w	d68k_smove-*-2
0000183E                          M 	shift
0000183E                            		d68k_Cmp	0, $08, .skip1			; check if USP -> AN, and if so, branch
0000183E 1800                     M 	dc.b	d68ke_cmp,0
00001840 0008                     M 	dc.w	$08
00001842                          M 	d68k_ref	.skip1
00001842                          M 	rept	narg
00001842 0000                     M 	dc.w	.skip1-*-2
00001844                          M 	shift
00001844                            		d68k_AddrReg	0				; print areg
00001844 1400                     M 	dc.b	d68ke_addrreg,0
00001846                            		d68k_Print	0, d68k_sComma			; print ,
00001846 0600                     M 	dc.b	d68ke_print,0
00001848                          M 	d68k_ref	d68k_scomma
00001848                          M 	rept	narg
00001848 0000                     M 	dc.w	d68k_scomma-*-2
0000184A                          M 	shift
0000184A                            
0000184A                            .skip1		d68k_Print	0, d68k_sUSP			; print USP
0000184A 0600                     M 	dc.b	d68ke_print,0
0000184C                          M 	d68k_ref	d68k_susp
0000184C                          M 	rept	narg
0000184C 0000                     M 	dc.w	d68k_susp-*-2
0000184E                          M 	shift
0000184E                            		d68k_Cmp	-2, $00, d68k_Finish1		; check if AN -> USP, and if so, branch
0000184E 18FE                     M 	dc.b	d68ke_cmp,-2
00001850 0000                     M 	dc.w	$00
00001852                          M 	d68k_ref	d68k_finish1
00001852                          M 	rept	narg
00001852 FA1C                     M 	dc.w	d68k_finish1-*-2
00001854                          M 	shift
00001854                            		d68k_Print	0, d68k_sComma			; print ,
00001854 0600                     M 	dc.b	d68ke_print,0
00001856                          M 	d68k_ref	d68k_scomma
00001856                          M 	rept	narg
00001856 0000                     M 	dc.w	d68k_scomma-*-2
00001858                          M 	shift
00001858                            		d68k_Jump	d68k_CommonIns10		; go to standard handler
00001858 0200                     M 	dc.b	d68ke_jump,0
0000185A                          M 	d68k_ref	d68k_commonins10
0000185A                          M 	rept	narg
0000185A F986                     M 	dc.w	d68k_commonins10-*-2
0000185C                          M 	shift
0000185C                            ; ==============================================================
0000185C                            ; --------------------------------------------------------------
0000185C                            ; 4E7X instruction handler
0000185C                            ; --------------------------------------------------------------
0000185C                            
0000185C                            d68k_i4E4X:	d68k_ReadSrc	$08, $30, $40			; read the instruction from source
0000185C 0A02                     M 	dc.b	d68ke_readsrc,narg-1
0000185E                          M 	rept	narg
0000185E 0008                     M 	dc.w	$08
00001860                          M 	shift
00001860 0030                     M 	dc.w	$30
00001862                          M 	shift
00001862 0040                     M 	dc.w	$40
00001864                          M 	shift
00001864                            		d68k_Cmp	-2, $00, d68k_iJmpJsr		; check if JMP or JSR, and if so, branch
00001864 18FE                     M 	dc.b	d68ke_cmp,-2
00001866 0000                     M 	dc.w	$00
00001868                          M 	d68k_ref	d68k_ijmpjsr
00001868                          M 	rept	narg
00001868 FE7E                     M 	dc.w	d68k_ijmpjsr-*-2
0000186A                          M 	shift
0000186A                            
0000186A                            		d68k_Cmp	0, $00, d68k_iTrap		; check if TRAP, and if so, branch
0000186A 1800                     M 	dc.b	d68ke_cmp,0
0000186C 0000                     M 	dc.w	$00
0000186E                          M 	d68k_ref	d68k_itrap
0000186E                          M 	rept	narg
0000186E FF9E                     M 	dc.w	d68k_itrap-*-2
00001870                          M 	shift
00001870                            		d68k_Cmp	0, $10, d68k_iLink		; check if LINK or UNLK, and if so, branch
00001870 1800                     M 	dc.b	d68ke_cmp,0
00001872 0010                     M 	dc.w	$10
00001874                          M 	d68k_ref	d68k_ilink
00001874                          M 	rept	narg
00001874 FFA4                     M 	dc.w	d68k_ilink-*-2
00001876                          M 	shift
00001876                            		d68k_Cmp	-2, $20, d68k_iMvUSP		; check if MOVE from/to USP, and if so, branch
00001876 18FE                     M 	dc.b	d68ke_cmp,-2
00001878 0020                     M 	dc.w	$20
0000187A                          M 	d68k_ref	d68k_imvusp
0000187A                          M 	rept	narg
0000187A FFBE                     M 	dc.w	d68k_imvusp-*-2
0000187C                          M 	shift
0000187C                            
0000187C                            		d68k_Cmp	-2, $08, d68k_iData		; check if invalid, and if so, branch
0000187C 18FE                     M 	dc.b	d68ke_cmp,-2
0000187E 0008                     M 	dc.w	$08
00001880                          M 	d68k_ref	d68k_idata
00001880                          M 	rept	narg
00001880 F7E4                     M 	dc.w	d68k_idata-*-2
00001882                          M 	shift
00001882                            		d68k_Exec	.i4E7X				; print 4E7X instructions
00001882 0000                     M 	dc.b	d68ke_exec,0
00001884                          M 	d68k_ref	.i4e7x
00001884                          M 	rept	narg
00001884 0000                     M 	dc.w	.i4e7x-*-2
00001886                          M 	shift
00001886                            ; --------------------------------------------------------------
00001886                            
00001886                            .i4E7X
00001886 7607                       		moveq	#7,d3					; load mask into d3
00001888 C640                       		and.w	d0,d3					; AND instruction with d3
0000188A 163B 3000                  		move.b	d68k_MiscInsTbl(pc,d3.w),d3		; load instruction offset to d3
0000188E 6B00 F7DA                  		bmi.w	d68k_Data				; if negative, this is an invalid instruction
00001892                            
00001892 49FB 3000                  		lea	d68k_iStop(pc,d3.w),a4			; load string to a4
00001896 7200                       		moveq	#0,d1					; no extra characters
00001898 4EBA F4F8                  		jsr	d68k_rPrint2(pc)			; copy the string over
0000189C                            ; --------------------------------------------------------------
0000189C                            
0000189C 4A03                       		tst.b	d3					; check instruction
0000189E 6600                       		bne.s	d68k_rFinish				; branch if not stop
000018A0 36D9                       		move.w	(a1)+,(a3)+				; load value into stack
000018A2 4EBA F56C                  		jsr	d68k_PrintWord(pc)			; print it
000018A6                            ; ==============================================================
000018A6                            ; --------------------------------------------------------------
000018A6                            ; Command to put end marker and finish execution
000018A6                            ; --------------------------------------------------------------
000018A6                            
000018A6                            d68k_rFinish:
000018A6 10FC 00F8                  		move.b	#_setpat,(a0)+				; PATTERN
000018AA 10FC 0000                  		move.b	#(VRAM_Font/$20)>>8,(a0)+		; $00xx
000018AE 4218                       		clr.b	(a0)+					; set end token
000018B0                            
000018B0 23C9 00FF 0000             		move.l	a1,d68k_StoreIns			; store the instruction address
000018B6 4E75                       		rts
000018B8                            ; --------------------------------------------------------------
000018B8                            
000018B8                            d68k_MiscInsTbl:
000018B8 0000 0000                  		dc.b d68k_iReset-d68k_iStop,   d68k_iNop-d68k_iStop, 0, d68k_iRte-d68k_iStop
000018BC FF00 0000                  		dc.b -1, d68k_iRts-d68k_iStop, d68k_iTrapv-d68k_iStop,  d68k_iRtr-d68k_iStop
000018C0                            
000018C0 EC73 746F 70E8 2023 00     d68k_iStop:	dc.b dcblue, 'stop', dcwhite, ' #', 0
000018C9 EC72 6573 6574 00          d68k_iReset:	dc.b dcblue, 'reset', 0
000018D0 EC74 7261 7076 00          d68k_iTrapv:	dc.b dcblue, 'trapv', 0
000018D7 EC6E 6F70 00               d68k_iNop:	dc.b dcblue, 'nop', 0
000018DC EC72 7472 00               d68k_iRtr:	dc.b dcblue, 'rtr', 0
000018E1 EC72 7465 00               d68k_iRte:	dc.b dcblue, 'rte', 0
000018E6 EC72 7473 00               d68k_iRts:	dc.b dcblue, 'rts', 0
000018EB                            ; ==============================================================
000018EB                            ; --------------------------------------------------------------
000018EB                            ; Various common things
000018EB                            ; --------------------------------------------------------------
000018EB                            
000018EB EC61                       d68k_sA:	dc.b dcblue, 'a'
000018ED 00                         d68k_sNull:	dc.b 0
000018EE EC78 00                    d68k_sX:	dc.b dcblue, 'x', 0
000018F1 EC64                       d68k_sDB:	dc.b dcblue, 'd'
000018F3 EC62 00                    d68k_sB:	dc.b dcblue, 'b', 0
000018F6 EC2E                       d68k_sDotS:	dc.b dcblue, '.'
000018F8 EC73 00                    d68k_sS:	dc.b dcblue, 's', 0
000018FB EC2E 7700                  d68k_sDotW:	dc.b dcblue, '.w', 0
000018FF                            
000018FF EC65                       d68k_sEor:	dc.b dcblue, 'e'
00001901 EC6F 7200                  d68k_sOr:	dc.b dcblue, 'or', 0
00001905 EC61 6E64 00               d68k_sAnd:	dc.b dcblue, 'and', 0
0000190A EC63 6D70 00               d68k_sCmp:	dc.b dcblue, 'cmp', 0
0000190F EC61 6464 00               d68k_sAdd:	dc.b dcblue, 'add', 0
00001914 EC73 7562 00               d68k_sSub:	dc.b dcblue, 'sub', 0
00001919 EC6D 756C 00               d68k_sMul:	dc.b dcblue, 'mul', 0
0000191E EC64 6976 00               d68k_sDiv:	dc.b dcblue, 'div', 0
00001923 EC6E                       d68k_sNbcd:	dc.b dcblue, 'n'
00001925 EC62 6364 00               d68k_sBcd:	dc.b dcblue, 'bcd', 0
0000192A EC65 7867 00               d68k_sExg:	dc.b dcblue, 'exg', 0
0000192F EC73 7761 7000             d68k_sSwap:	dc.b dcblue, 'swap', 0
00001935 EC6D 6F76 6500             d68k_sMove:	dc.b dcblue, 'move', 0
0000193B EC6C 6561 00               d68k_sLea:	dc.b dcblue, 'lea', 0
00001940 EC70 6561 00               d68k_sPea:	dc.b dcblue, 'pea', 0
00001945 EC63 686B 00               d68k_sChk:	dc.b dcblue, 'chk', 0
0000194A EC63 6C72 00               d68k_sClr:	dc.b dcblue, 'clr', 0
0000194F EC6E 6F74 00               d68k_sNot:	dc.b dcblue, 'not', 0
00001954 EC6E 6567 00               d68k_sNeg:	dc.b dcblue, 'neg', 0
00001959 EC74 7374 00               d68k_sTst:	dc.b dcblue, 'tst', 0
0000195E EC74 6173 00               d68k_sTas:	dc.b dcblue, 'tas', 0
00001963 EC6C 696E 6B00             d68k_sLink:	dc.b dcblue, 'link', 0
00001969 EC75 6E6C 6B00             d68k_sUnlk:	dc.b dcblue, 'unlk', 0
0000196F EC65 7874 00               d68k_sExt:	dc.b dcblue, 'ext', 0
00001974 EC6A 6D70 00               d68k_sJmp:	dc.b dcblue, 'jmp', 0
00001979 EC6A 7372 00               d68k_sJsr:	dc.b dcblue, 'jsr', 0
0000197E EC69 6C6C 6567 616C 00     d68k_sIllegal:	dc.b dcblue, 'illegal', 0
00001987                            
00001987 EC74 7261 70               d68k_sTrap:	dc.b dcblue, 'trap'
0000198C E820 2300                  d68k_sVal:	dc.b dcwhite, ' #', 0
00001990 EA75 7370 00               d68k_sUSP:	dc.b dcgreen, 'usp', 0
00001995 EA73 00                    d68k_sS2:	dc.b dcgreen, 's', 0
00001998 EA63 6300                  d68k_sCC:	dc.b dcgreen, 'cc', 0
0000199C E83A 203C 696E 7661 6C69+  d68k_sInvalid:	dc.b dcwhite, ': <invalid>', 0
000019A9 E82C 00                    d68k_sComma:	dc.b dcwhite, ',', 0
000019AC                            	even
000019AC                            ; ==============================================================
000019AC                            ; --------------------------------------------------------------
000019AC                            ; Invalid address handler
000019AC                            ; --------------------------------------------------------------
000019AC                            
000019AC                            d68k_Invalid:	d68k_Print	' ', d68k_sInvalid		; print INVALID
000019AC 0620                     M 	dc.b	d68ke_print,' '
000019AE                          M 	d68k_ref	d68k_sinvalid
000019AE                          M 	rept	narg
000019AE FFEC                     M 	dc.w	d68k_sinvalid-*-2
000019B0                          M 	shift
000019B0                            		d68k_Finish
000019B0 0400                     M 	dc.b	d68ke_finish,0
000019B2                            ; ==============================================================
000019B2                            ; --------------------------------------------------------------
000019B2                            ; Handler for writing your own addresses into the buffer.
000019B2                            ; This could be used to handle reading from a listing file
000019B2                            ; based on the provided address
000019B2                            ;
000019B2                            ; input:
000019B2                            ;   d1 = address to write
000019B2                            ;   a0 = text buffer address
000019B2                            ; --------------------------------------------------------------
000019B2                            
000019B2                            d68k_PrintAddr2:
000019B2 2223                       		move.l	-(a3),d1				; load address from stack. DO NOT CHANGE!
000019B4                            
000019B4                            d68k_ResolveAddr:
000019B4 10FC 00F8                  		move.b	#_setpat,(a0)+				; PATTERN
000019B8 10FC 0000                  		move.b	#(VRAM_Font/$20)>>8,(a0)+		; $00xx
000019BC                            
000019BC 48E7 016C                  		movem.l	d7/a1/a2/a4/a5,-(sp)			; push variables
000019C0 4DF9 00C0 0000             		lea	$C00000,a6				; load VDP data port to a6
000019C6 4BEE 0004                  		lea	4(a6),a5				; load VDP control port to a5
000019CA                            
000019CA 2F08                       		move.l	a0,-(sp)				; store buffer address temporarily
000019CC 2F01                       		move.l	d1,-(sp)				; Argument #1 : Target address
000019CE                            
000019CE 43FA 0000                  		lea	.defaultformat(pc),a1			; load formatter address to a1
000019D2 45D7                       		lea	(sp),a2					; load args to a2
000019D4 49FA 0000                  		lea	.FlushBuffer(pc),a4			; flushing function
000019D8                            
000019D8 7E7F                       		moveq	#$7F,d7					; d7 = number of characters before flush -1
000019DA 4EBA EFDA                  		jsr	FormatString(pc)			; print formatted string
000019DE 221F                       		move.l	(sp)+,d1				; pop target address
000019E0                            
000019E0 7E02                       		moveq	#2,d7					; prepare offset of 2 to d7
000019E2 DE9F                       		add.l	(sp)+,d7				; add the last address to d7
000019E4 BE88                       		cmp.l	a0,d7					; check if any text was written
000019E6 6700                       		beq.s	.writenum				; branch if not
000019E8                            
000019E8 4CDF 3680                  		movem.l	(sp)+,d7/a1/a2/a4/a5			; pop variables
000019EC 10FC 00F8                  		move.b	#_setpat,(a0)+				; PATTERN
000019F0 10FC 0001                  		move.b	#(VRAM_Font2/$20)>>8,(a0)+		; $01xx
000019F4 4E75                       		rts
000019F6                            ; --------------------------------------------------------------
000019F6                            
000019F6 E8BB                       .defaultformat	dc.b _pal0, _sym|long|split
000019F8 ECC8 0000                  		dc.b _pal2, _disp|weak, 0, 0
000019FC                            ; --------------------------------------------------------------
000019FC                            
000019FC                            .writenum
000019FC 4CDF 3680                  		movem.l	(sp)+,d7/a1/a2/a4/a5			; pop variables
00001A00 5548                       		subq.w	#2,a0					; undo the color commands
00001A02 10FC 00F8                  		move.b	#_setpat,(a0)+				; PATTERN
00001A06 10FC 0001                  		move.b	#(VRAM_Font2/$20)>>8,(a0)+		; $01xx
00001A0A                            
00001A0A 26C1                       		move.l	d1,(a3)+				; store number in stack
00001A0C 4EFA F3F4                  		jmp	d68k_PrintLong(pc)			; print as longword
00001A10                            ; ==============================================================
00001A10                            ; --------------------------------------------------------------
00001A10                            ; Flush buffer callback raised by d68k_ResolveAddr
00001A10                            ; --------------------------------------------------------------
00001A10                            ; INPUT:
00001A10                            ;		a0		Buffer position
00001A10                            ;		d7	.w	Number of characters remaining in buffer - 1
00001A10                            ;
00001A10                            ; OUTPUT:
00001A10                            ;		a0		Buffer position after flushing
00001A10                            ;		d7	.w	Number of characters before next flush - 1
00001A10                            ;		Carry		0 = continue operation
00001A10                            ;				1 = terminate FormatString with error condition
00001A10                            ;
00001A10                            ; WARNING: This function shouldn't modify d0-d4 / a1-a3!
00001A10                            ; --------------------------------------------------------------
00001A10                            
00001A10                            .FlushBuffer
00001A10 7E7F                       		moveq	#$7F,d7					; d7 = number of characters before flush -1
00001A12 4E75                       		rts						; WARNING! Must return Carry=0
00001A14                            ; ---------------------------------------------------------------
00001A14                            
00001A14                            SymbolData:
