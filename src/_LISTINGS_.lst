00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Includes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Configuration.asm"	; User configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  DEBUG_BUILD	equ	0				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000000                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Shared.asm"		; MegaDrive includes
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Shared Includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Definitions.asm"	; Definitions
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ROM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  ROM_START		EQU	$000000		; ROM start address
00000000 =00400000                  ROM_END			EQU	$3FFFFF+1	; ROM end address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Z80 addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A00000                  Z80_RAM			EQU	$A00000		; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		EQU	$A02000		; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		EQU	$A11100		; Z80 bus rEQUest
00000000 =00A11200                  Z80_RESET		EQU	$A11200		; Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sound addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A04000                  YM2612_A0		EQU	$A04000		; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		EQU	$A04001		; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		EQU	$A04002		; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		EQU	$A04003		; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		EQU	$C00011		; M68K PSG input
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; I/O addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A10001                  HW_VERSION		EQU	$A10001		; Hardware version
00000000 =00A10003                  PORT_A_DATA		EQU	$A10003		; Port A data
00000000 =00A10005                  PORT_B_DATA		EQU	$A10005		; Port B data
00000000 =00A10007                  PORT_C_DATA		EQU	$A10007		; Port C data
00000000 =00A10009                  PORT_A_CTRL		EQU	$A10009		; Port A control
00000000 =00A1000B                  PORT_B_CTRL		EQU	$A1000B		; Port B control
00000000 =00A1000D                  PORT_C_CTRL		EQU	$A1000D		; Port C control
00000000 =00A1000F                  PORT_A_TX		EQU	$A1000F		; Port A Tx data
00000000 =00A10011                  PORT_A_RX		EQU	$A10011		; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		EQU	$A10013		; Port A S control
00000000 =00A10015                  PORT_B_TX		EQU	$A10015		; Port B Tx data
00000000 =00A10017                  PORT_B_RX		EQU	$A10017		; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		EQU	$A10019		; Port B S control
00000000 =00A1001B                  PORT_C_TX		EQU	$A1001B		; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		EQU	$A1001D		; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		EQU	$A1001F		; Port C S control
00000000 =00A130F1                  SRAM_ACCESS		EQU	$A130F1		; SRAM access port
00000000 =00A14000                  TMSS_PORT		EQU	$A14000		; TMSS port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00C00000                  VDP_DATA		EQU	$C00000		; VDP data port
00000000 =00C00004                  VDP_CTRL		EQU	$C00004		; VDP control port
00000000 =00C00008                  VDP_HV			EQU	$C00008		; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		EQU	$C0001C		; VDP debug register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RAM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00FF0000                  RAM_START		EQU	$FF0000		; RAM start address
00000000 =01000000                  RAM_END			EQU	$FFFFFF+1	; RAM end address
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rsEven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            
00000000                            		moveq	#0,d0
00000000                            
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Z80.asm"		; Z80 opcodes macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÈGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_ERROR_/debugger.asm"		; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		include	"../amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000000                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"../amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            		include	"_INCLUDE_/Shared.asm"		; User includes
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User shared includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Constants.asm"	; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  oAddr		rs.l	1				; Pointer to object code
00000000 =00000004                  oNext		rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  oPrev		rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  oDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  oDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  oFlags		rs.b	1				; Object flags
00000000 =0000000D                  oRender		rs.b	1				; Render flags
00000000 =0000000E                  oVRAM		rs.w	1				; Sprite tile properties
00000000 =00000010                  oFrame		rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  oMap		rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  oXPos		rs.l	1				; X position
00000000 =00000017                  oDrawW	=	__rs-1					; Sprite width
00000000 =00000018                  oYPos		rs.l	1				; Y position
00000000 =0000001B                  oDrawH	=	__rs-1					; Sprite height
00000000 =0000001C                  oXVel		rs.w	1				; X velocity
00000000 =0000001E                  oYVel		rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  oAni		rs.b	1				; Animation ID
00000000 =00000021                  oPrevAni	rs.b	1				; Saved animation ID
00000000 =00000022                  oAniFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  oAniTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  oSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  oRoutine	rs.b	1				; Routine ID
00000000 =00000026                  oRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  oStatus		rs.b	1				; Status flags
00000000 =00000029                  oShield		rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  oDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  oSize		rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oDynSSTs
00000000 =0000002A                  oColType	rs.b	1				; Collision type
00000000 =0000002B                  oColStat	rs.b	1				; Collision status
00000000 =0000002B                  oHitCnt		equ	oColStat			; Boss hit count
00000000 =0000002C                  oColW		rs.b	1				; Collision width
00000000 =0000002D                  oColH		rs.b	1				; Collision height
00000000 =0000002E                  oNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  oTilt		rs.b	1				; Tilt value
00000000 =00000030                  oLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oSubXPos	rs.w	1				; Sub sprite X position
00000000 =00000002                  oSubYPos	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000 =00000005                  oSubFrame	rs.b	1				; Sub sprite mapping frame
00000000 =00000006                  oSubSize	rs.b	0				; Sub sprite SSTs size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  oSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  oSubCnt		rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  oSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            oSub\$ct\X	rs.w	1				; Sub sprite X position
00000000                            oSub\$ct\Y	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000                            oSub\$ct\Frame	rs.b	1				; Sub sprite mapping frame position
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M osub0x	rs.w	1
00000000 =00000032                M osub0y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000035                M osub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M osub1x	rs.w	1
00000000 =00000038                M osub1y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000003B                M osub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M osub2x	rs.w	1
00000000 =0000003E                M osub2y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000041                M osub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M osub3x	rs.w	1
00000000 =00000044                M osub3y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000047                M osub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M osub4x	rs.w	1
00000000 =0000004A                M osub4y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000004D                M osub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M osub5x	rs.w	1
00000000 =00000050                M osub5y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000053                M osub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M osub6x	rs.w	1
00000000 =00000056                M osub6y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000059                M osub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M osub7x	rs.w	1
00000000 =0000005C                M osub7y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000005F                M osub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset oDrawPrev-6			; this awkward thing will make dPrev == oDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	oSize
00000000                            curobj_size		=	curobj_size+oSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/RAM.asm"		; RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  rBuffer		rs.b	0				; General buffer
00000000 =00FF0000                  rChunks		rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  rBuffer_End	rs.b	0
00000000                            
00000000                            		rsset	$FF000000|(RAM_START+$8000)
00000000                            
00000000 =FFFF8000                  rKosPBuf	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  rDMAQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  rDMASlot	rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  rHScroll	rs.b	$380				; HScroll table
00000000 =FFFF947E                  rHScroll_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  rVScroll	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  rVScroll_End	rs.b	0				; ''
00000000 =FFFF947E                  rVScrollFG	EQU	rVScroll			; VScroll foreground value
00000000 =FFFF9480                  rVScrollBG	EQU	rVScroll+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  rSprites	rs.b	$280				; Sprite table
00000000 =FFFF974E                  rSprites_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;rDestWtrPal	equ	rSprites_End-$100		; Target water palette buffer
00000000                            ;rDestPal	equ	rSprites_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  rDestWtrPal	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  rDestPal	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  rWaterPal	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  rPalette	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  rKosPVars	rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  rKosPCnt	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  rKosPRegs	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  rKosPSR		rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  rKosPBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  rKosPList	rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  rKosPSrc	equ	rKosPList			; ''
00000000 =FFFF9974                  rKosPDest	equ	rKosPList+4			; ''
00000000 =FFFF9990                  rKosPList_End	rs.b	0				; ''
00000000 =FFFF9990                  rKosPMMods	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  rKosPMLastSz	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  rKosPMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  rKosPMSrc	equ	rKosPMList			; ''
00000000 =FFFF9998                  rKosPMDest	equ	rKosPMList+4			; ''
00000000 =FFFF9A54                  rKosPMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  rKosPVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  rObjects	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9A54                M robj_0	rs.b	osize
00000000 =00000060                M curobj_size	=	curobj_size+osize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9AB4                M robj_1	rs.b	osize
00000000 =000000C0                M curobj_size	=	curobj_size+osize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9B14                M robj_2	rs.b	osize
00000000 =00000120                M curobj_size	=	curobj_size+osize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9B74                M robj_3	rs.b	osize
00000000 =00000180                M curobj_size	=	curobj_size+osize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9BD4                M robj_4	rs.b	osize
00000000 =000001E0                M curobj_size	=	curobj_size+osize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9C34                M robj_5	rs.b	osize
00000000 =00000240                M curobj_size	=	curobj_size+osize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9C94                M robj_6	rs.b	osize
00000000 =000002A0                M curobj_size	=	curobj_size+osize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9CF4                M robj_7	rs.b	osize
00000000 =00000300                M curobj_size	=	curobj_size+osize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFF9D54                M robj_8	rs.b	osize
00000000 =00000360                M curobj_size	=	curobj_size+osize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_9	rs.b	osize
00000000 =000003C0                M curobj_size	=	curobj_size+osize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_a	rs.b	osize
00000000 =00000420                M curobj_size	=	curobj_size+osize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_b	rs.b	osize
00000000 =00000480                M curobj_size	=	curobj_size+osize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_c	rs.b	osize
00000000 =000004E0                M curobj_size	=	curobj_size+osize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_d	rs.b	osize
00000000 =00000540                M curobj_size	=	curobj_size+osize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_e	rs.b	osize
00000000 =000005A0                M curobj_size	=	curobj_size+osize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_f	rs.b	osize
00000000 =00000600                M curobj_size	=	curobj_size+osize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_10	rs.b	osize
00000000 =00000660                M curobj_size	=	curobj_size+osize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_11	rs.b	osize
00000000 =000006C0                M curobj_size	=	curobj_size+osize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_12	rs.b	osize
00000000 =00000720                M curobj_size	=	curobj_size+osize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_13	rs.b	osize
00000000 =00000780                M curobj_size	=	curobj_size+osize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_14	rs.b	osize
00000000 =000007E0                M curobj_size	=	curobj_size+osize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_15	rs.b	osize
00000000 =00000840                M curobj_size	=	curobj_size+osize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_16	rs.b	osize
00000000 =000008A0                M curobj_size	=	curobj_size+osize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_17	rs.b	osize
00000000 =00000900                M curobj_size	=	curobj_size+osize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_18	rs.b	osize
00000000 =00000960                M curobj_size	=	curobj_size+osize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_19	rs.b	osize
00000000 =000009C0                M curobj_size	=	curobj_size+osize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_1a	rs.b	osize
00000000 =00000A20                M curobj_size	=	curobj_size+osize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_1b	rs.b	osize
00000000 =00000A80                M curobj_size	=	curobj_size+osize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_1c	rs.b	osize
00000000 =00000AE0                M curobj_size	=	curobj_size+osize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_1d	rs.b	osize
00000000 =00000B40                M curobj_size	=	curobj_size+osize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_1e	rs.b	osize
00000000 =00000BA0                M curobj_size	=	curobj_size+osize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_1f	rs.b	osize
00000000 =00000C00                M curobj_size	=	curobj_size+osize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_20	rs.b	osize
00000000 =00000C60                M curobj_size	=	curobj_size+osize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_21	rs.b	osize
00000000 =00000CC0                M curobj_size	=	curobj_size+osize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_22	rs.b	osize
00000000 =00000D20                M curobj_size	=	curobj_size+osize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_23	rs.b	osize
00000000 =00000D80                M curobj_size	=	curobj_size+osize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_24	rs.b	osize
00000000 =00000DE0                M curobj_size	=	curobj_size+osize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_25	rs.b	osize
00000000 =00000E40                M curobj_size	=	curobj_size+osize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_26	rs.b	osize
00000000 =00000EA0                M curobj_size	=	curobj_size+osize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_27	rs.b	osize
00000000 =00000F00                M curobj_size	=	curobj_size+osize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_28	rs.b	osize
00000000 =00000F60                M curobj_size	=	curobj_size+osize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_29	rs.b	osize
00000000 =00000FC0                M curobj_size	=	curobj_size+osize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_2a	rs.b	osize
00000000 =00001020                M curobj_size	=	curobj_size+osize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_2b	rs.b	osize
00000000 =00001080                M curobj_size	=	curobj_size+osize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_2c	rs.b	osize
00000000 =000010E0                M curobj_size	=	curobj_size+osize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_2d	rs.b	osize
00000000 =00001140                M curobj_size	=	curobj_size+osize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_2e	rs.b	osize
00000000 =000011A0                M curobj_size	=	curobj_size+osize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_2f	rs.b	osize
00000000 =00001200                M curobj_size	=	curobj_size+osize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_30	rs.b	osize
00000000 =00001260                M curobj_size	=	curobj_size+osize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_31	rs.b	osize
00000000 =000012C0                M curobj_size	=	curobj_size+osize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_32	rs.b	osize
00000000 =00001320                M curobj_size	=	curobj_size+osize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_33	rs.b	osize
00000000 =00001380                M curobj_size	=	curobj_size+osize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_34	rs.b	osize
00000000 =000013E0                M curobj_size	=	curobj_size+osize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_35	rs.b	osize
00000000 =00001440                M curobj_size	=	curobj_size+osize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_36	rs.b	osize
00000000 =000014A0                M curobj_size	=	curobj_size+osize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_37	rs.b	osize
00000000 =00001500                M curobj_size	=	curobj_size+osize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_38	rs.b	osize
00000000 =00001560                M curobj_size	=	curobj_size+osize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_39	rs.b	osize
00000000 =000015C0                M curobj_size	=	curobj_size+osize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_3a	rs.b	osize
00000000 =00001620                M curobj_size	=	curobj_size+osize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_3b	rs.b	osize
00000000 =00001680                M curobj_size	=	curobj_size+osize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_3c	rs.b	osize
00000000 =000016E0                M curobj_size	=	curobj_size+osize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_3d	rs.b	osize
00000000 =00001740                M curobj_size	=	curobj_size+osize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_3e	rs.b	osize
00000000 =000017A0                M curobj_size	=	curobj_size+osize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_3f	rs.b	osize
00000000 =00001800                M curobj_size	=	curobj_size+osize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_40	rs.b	osize
00000000 =00001860                M curobj_size	=	curobj_size+osize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_41	rs.b	osize
00000000 =000018C0                M curobj_size	=	curobj_size+osize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_42	rs.b	osize
00000000 =00001920                M curobj_size	=	curobj_size+osize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_43	rs.b	osize
00000000 =00001980                M curobj_size	=	curobj_size+osize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_44	rs.b	osize
00000000 =000019E0                M curobj_size	=	curobj_size+osize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_45	rs.b	osize
00000000 =00001A40                M curobj_size	=	curobj_size+osize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_46	rs.b	osize
00000000 =00001AA0                M curobj_size	=	curobj_size+osize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_47	rs.b	osize
00000000 =00001B00                M curobj_size	=	curobj_size+osize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_48	rs.b	osize
00000000 =00001B60                M curobj_size	=	curobj_size+osize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_49	rs.b	osize
00000000 =00001BC0                M curobj_size	=	curobj_size+osize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_4a	rs.b	osize
00000000 =00001C20                M curobj_size	=	curobj_size+osize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_4b	rs.b	osize
00000000 =00001C80                M curobj_size	=	curobj_size+osize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_4c	rs.b	osize
00000000 =00001CE0                M curobj_size	=	curobj_size+osize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_4d	rs.b	osize
00000000 =00001D40                M curobj_size	=	curobj_size+osize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_4e	rs.b	osize
00000000 =00001DA0                M curobj_size	=	curobj_size+osize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_4f	rs.b	osize
00000000 =00001E00                M curobj_size	=	curobj_size+osize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_50	rs.b	osize
00000000 =00001E60                M curobj_size	=	curobj_size+osize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_51	rs.b	osize
00000000 =00001EC0                M curobj_size	=	curobj_size+osize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_52	rs.b	osize
00000000 =00001F20                M curobj_size	=	curobj_size+osize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_53	rs.b	osize
00000000 =00001F80                M curobj_size	=	curobj_size+osize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_54	rs.b	osize
00000000 =00001FE0                M curobj_size	=	curobj_size+osize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_55	rs.b	osize
00000000 =00002040                M curobj_size	=	curobj_size+osize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_56	rs.b	osize
00000000 =000020A0                M curobj_size	=	curobj_size+osize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_57	rs.b	osize
00000000 =00002100                M curobj_size	=	curobj_size+osize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_58	rs.b	osize
00000000 =00002160                M curobj_size	=	curobj_size+osize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_59	rs.b	osize
00000000 =000021C0                M curobj_size	=	curobj_size+osize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_5a	rs.b	osize
00000000 =00002220                M curobj_size	=	curobj_size+osize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_5b	rs.b	osize
00000000 =00002280                M curobj_size	=	curobj_size+osize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_5c	rs.b	osize
00000000 =000022E0                M curobj_size	=	curobj_size+osize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_5d	rs.b	osize
00000000 =00002340                M curobj_size	=	curobj_size+osize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_5e	rs.b	osize
00000000 =000023A0                M curobj_size	=	curobj_size+osize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_5f	rs.b	osize
00000000 =00002400                M curobj_size	=	curobj_size+osize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFBE54                  rObjects_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(rObjects_End-rObjects)/oSize
00000000                            
00000000 =FFFFBE54                  rTailAddr	rs.l	1				; pointer to tail object code
00000000 =FFFFBE58                  rTailNext	rs.w	1				; pointer to the first object in linked list
00000000 =FFFFBE5A                  rTailPrev	rs.w	1				; pointer to the last object in linked list
00000000 =FFFFBE5C                  rFreeHead	rs.w	1				; pointer to the first object that is not loaded
00000000                            
00000000 =FFFFBE5A                  rDispInput	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFBE9E                  rDispInput_End	rs.b	0				; 
00000000                            
00000000 =FFFFBE9E                  rRespawns	rs.b	$300				; Object respawn table
00000000 =FFFFC19E                  rRespawns_End	rs.b	0				; ''
00000000                            
00000000 =FFFFC19E                  rFGRowBuf	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  rFGColBuf	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  rBGRowBuf	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  rBGColBuf	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  rAMPS		rs.b	0			; AMPS variables
00000000                            		include	"../amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC740                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC740                  rP1Data		rs.b	0				; Controller 1 data
00000000 =FFFFC740                  rP1Hold		rs.b	1				; Controller 1 held button data
00000000 =FFFFC741                  rP1Press	rs.b	1				; Controller 1 pressed button data
00000000 =FFFFC742                  rP2Data		rs.b	0				; Controller 2 data
00000000 =FFFFC742                  rP2Hold		rs.b	1				; Controller 2 held button data
00000000 =FFFFC743                  rP2Press	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC744                  rHWVersion	rs.b	1				; Hardware version
00000000 =FFFFC745                  rVINTFlag	rs.b	0				; V-INT flag
00000000 =FFFFC745                  rVINTRout	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC746                  rPalFade	rs.b	0				; Palette fade properties
00000000 =FFFFC746                  rFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC747                  rFadeLen	rs.b	1				; Palette fade size
00000000                            
00000000 =FFFFC748                  rLagCount	rs.b	1				; Lag frame counter
00000000                            
00000000 =FFFFC749                  rHIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74A                  rVIntJmp	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74C                  rVIntAddr	rs.l	1				; V-INT address
00000000 =FFFFC750                  rHIntJmp	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC752                  rHIntAddr	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC756                  rFrameCnt	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75A                  rGameMode	rs.b	1				; Game mode ID
00000000 =FFFFC75B                  rSprCount	rs.b	1				; Sprite count
00000000 =FFFFC75C                  rPauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75D                  rHIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC75E                  rHIntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC75F                  rHIntCnt	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC760                  rRNGSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC764                  rVDPReg1	rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC766                  rWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC768                  rMoveCheat	rs.b	1
00000000 =FFFFC769                  rArtCheat	rs.b	1
00000000                            
00000000 =FFFFC76A                  rOscNums	rs.b	0				; Oscillation numbers
00000000 =FFFFC76A                  rOscCtrl	rs.w	1				; Oscillation control
00000000 =FFFFC76C                  rOscData	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AC                  rOscNums_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AC                  rLevel		rs.b	0				; Level ID
00000000 =FFFFC7AC                  rZone		rs.b	1				; Zone ID
00000000 =FFFFC7AD                  rAct		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7AE                  rChkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7AE                  rLastChkpoint	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B0                  rSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B2                  rSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B4                  rChkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B4                  rObjPosAddr	rs.l	1				; Object position data pointer
00000000 =FFFFC7B8                  rObjManInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B9                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7BA                  rObjLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7BE                  rObjLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C2                  rObjRespL	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C4                  rObjRespR	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C6                  rObjXCoarse	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7C8                  rObjYCoarse	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CA                  rObjManX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CC                  rObjManY	rs.w	1				; Object manager's camera Y position
00000000                            
00000000 =FFFFC7CE                  rPalCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7CF                  rPalCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D0                  rGameVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  rGameVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  rStackSpace	rs.b	$100				; Stack space
00000000 =00000000                  rStackBase	rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000 =FFFFC7D0                  rBlocks		rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD0                  rLayout		rs.b	$1000				; Level layout
00000000                            
00000000 =FFFFEFD0                  rScrlSecs	rs.b	$384				; Scroll sections
00000000 =FFFFF354                  rScrlSecs_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF354                  rColList	rs.b	$80				; Collision response list
00000000 =FFFFF3D4                  rColList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF3D4                  rRings		rs.w	1				; Ring count
00000000                            
00000000 =FFFFF3D6                  rRingManRout	rs.b	1				; Ring manager routine
00000000 =FFFFF3D7                  rRingFrame	rs.b	1				; Ring animation frame
00000000                            
00000000 =FFFFF3D8                  rRingAniTime	rs.b	1				; Ring animation timer
00000000 =FFFFF3D9                  rRLossAniT	rs.b	1
00000000 =FFFFF3DA                  rRLossAniA	rs.w	1
00000000 =FFFFF3DC                  rRLossAniF	rs.b	1
00000000                            
00000000 =FFFFF3DD                  rBossDefeat	rs.b	1
00000000                            
00000000 =FFFFF3DE                  rRingStat	rs.b	$400				; Ring status table
00000000 =FFFFF7DE                  rRingStat_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF7DE                  rRingCol	rs.b	0				; Ring collection table
00000000 =FFFFF7DE                  rRingColCnt	rs.w	1				; Ring collection count
00000000 =FFFFF7E0                  rRingColList	rs.b	$7E				; Ring collection list
00000000 =FFFFF85E                  rRingCol_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF85E                  rRingPosAddr	rs.l	1				; Ring position data pointer
00000000 =FFFFF862                  rRingLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFF866                  rRingLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFF86A                  rRingStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFF86C                  rPlayer1Addr	rs.w	1				; Player 1 object address
00000000 =FFFFF86E                  rShield1Addr	rs.w	1				; Player 1 shield address
00000000 =FFFFF870                  rInvinc1Addr	rs.w	1				; Player 1 invincibility address
00000000 =FFFFF872                  rAftImg1Addr	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFF874                  rPlayer2Addr	rs.w	1				; Player 2 object address
00000000 =FFFFF876                  rShield2Addr	rs.w	1				; Player 2 shield address
00000000 =FFFFF878                  rInvinc2Addr	rs.w	1				; Player 2 invincibility address
00000000 =FFFFF87A                  rAftImg2Addr	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFF87C                  rWater1Addr	rs.w	1				; Water surface 1 address
00000000 =FFFFF87E                  rWater2Addr	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFF880                  rCamera		rs.b	0				; Camera RAM
00000000                            
00000000 =FFFFF880                  rFGCam		rs.b	cSize2				; Foreground variables
00000000 =FFFFF89E                  rBGCam		rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFF8BC                  rDestMaxCam	rs.b	0				; Target maximum camera positions
00000000 =FFFFF8BC                  rDestMaxX	rs.w	1				; Target maximum camera X position
00000000 =FFFFF8BE                  rDestMaxY	rs.w	1				; Target maximum camera Y position
00000000 =FFFFF8C0                  rMaxCam		rs.b	0				; Maximum camera positions
00000000 =FFFFF8C0                  rMaxCamX	rs.w	1				; Maximum camera X position
00000000 =FFFFF8C2                  rMaxCamY	rs.w	1				; Maximum camera Y position
00000000 =FFFFF8C4                  rDestMinCam	rs.b	0				; Target minimum camera positions
00000000 =FFFFF8C4                  rDestMinX	rs.w	1				; Target minimum camera X position
00000000 =FFFFF8C6                  rDestMinY	rs.w	1				; Target minimum camera Y position
00000000 =FFFFF8C8                  rMinCam		rs.b	0				; Minimum camera positions
00000000 =FFFFF8C8                  rMinCamX	rs.w	1				; Minimum camera X position
00000000 =FFFFF8CA                  rMinCamY	rs.w	1				; Minimum camera Y position
00000000 =FFFFF8CC                  rCamYPosDist	rs.w	1				; Distance from the player's Y position and the camera's
00000000 =FFFFF8CE                  rCamLocked	rs.b	0				; Camera locked flags
00000000 =FFFFF8CE                  rCamLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFF8CF                  rCamLockY	rs.b	1				; Camera locked vertically flag
00000000 =FFFFF8D0                  rCamMaxChg	rs.b	1				; Camera max Y position changing flag
00000000                            
00000000 =FFFFF8D1                  rCamera_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFF8D1                  rDebugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFF8D2                  rCamXPosCenter	rs.w	1				; Camera X center
00000000                            
00000000 =FFFFF8D4                  rCtrl		rs.b	0				; Player control data
00000000 =FFFFF8D4                  rCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFF8D5                  rCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFF8D6                  rLevelMusic	rs.b	1				; Level music ID
00000000 =FFFFF8D7                  rBossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFF8D8                  r1stCol		rs.l	1				; Primary level collision data pointer
00000000 =FFFFF8DC                  r2ndCol		rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFF8E0                  rColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFF8E4                  rLayerPos	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFF8E6                  rAngleVals	rs.l	1				; Angle value array pointer
00000000 =FFFFF8EA                  rColArrayN	rs.l	1				; Normal height map array pointer
00000000 =FFFFF8EE                  rColArrayR	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFF8F2                  rNextLevel	rs.b	1				; Flag to go to the next level
00000000                            
00000000 =FFFFF8F3                  rUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFF8F4                  rWaterFlag	rs.b	1				; Water in level flag
00000000 =FFFFF8F5                  rWaterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFF8F6                  rWaterLvl	rs.w	1				; Water height
00000000 =FFFFF8F8                  rDestWtrLvl	rs.w	1				; Target water height
00000000                            
00000000 =FFFFF8FA                  rLvlFrames	rs.w	1				; Level frame counter
00000000 =FFFFF8FC                  rLvlReload	rs.b	1				; Level reload flag
00000000 =FFFFF8FD                  rTimeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFF8FE                  rDynEvRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFF8FF                  rFloorActive	rs.b	1				; Floor active flag
00000000 =FFFFF900                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFF902                  rAnimCnts	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFF880                  rCamXPos		equ	rFGCam+cXPos			; Camera X position
00000000 =FFFFF888                  rCamYPos		equ	rFGCam+cYPos			; Camera Y position
00000000 =FFFFF89E                  rCamBGXPos		equ	rBGCam+cXPos			; Background camera X position
00000000 =FFFFF8A6                  rCamBGYPos		equ	rBGCam+cYPos			; Background camera Y position
00000000 =FFFFF89C                  rFGRedraw	equ	rFGCam+cRedraw		; Foreground redraw flag
00000000 =FFFFF8BA                  rBGRedraw	equ	rBGCam+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74A                  vInterrupt	equ	rVIntJmp			; V-INT
00000000 =FFFFC750                  hInterrupt	equ	rHIntJmp			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User Defined Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	rTailNext.w,a0				; load first object slot into a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	oNext(a0),a0				; load the next object address to a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	#rDispInput+(\layer*dSize),oDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	rDispInput+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	#rDispInput+(\layer*dSize),rDispInput+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w				; else, copy over
00000000                            
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	layer,oDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	oDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,oDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	oDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,oDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            
00000000                            		move.w	oDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	oDrawNext(\obj),oDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	oDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	oDrawPrev(\obj),oDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            
00000000                            ;		cmp.w	oDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,oDrawNext(\fre)				; else, change to point to same address
00000000                            
00000000                            .no\@
00000000                            		clr.l	oDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- Character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C750                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74A                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	rStackBase.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4D69 6768 7479 2054 6865+M 	dc.b	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Function libraries
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            		include	"_LIB_/VDP.asm"			; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; Mighty The Armadillo in PRISM PARADISE
000001BC                            ; By Nat The Porcupine 2021
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Initialize the VDP
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; PARAMETERS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; RETURNS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            InitVDP:
000001BC 31FC 8134 C764             		move.w	#$8134,rVDPReg1.w		; Save VDP register 1 in RAM
000001C2 31FC 8AFF C75E             		move.w	#$8AFF,rHIntReg.w		; Save H-INT counter register in RAM
000001C8                            
000001C8 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; Clear the screen and other VDP data (64 tile width)
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; PARAMETERS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; RETURNS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ClearScreen:
000001CC 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000001D2                            		dmaFill	0,$C000,$3000			; Clear planes
000001D2 3CBC 8F01                M 	move.w	#$8f01,(a6)
000001D6 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
000001DC 3CBC 9780                M 	move.w	#$9780,(a6)
000001E0 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
000001E6 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
000001EC                          M 	waitdma	(a6)
000001EC                          M .wait_22:
000001EC 3216                     M 	move.w	(a6),d1
000001EE 0801 0001                M 	btst	#1,d1
000001F2 66F8                     M 	bne.s	.wait_22
000001F4 3CBC 8F02                M 	move.w	#$8f02,(a6)
000001F8                            
000001F8                            		clrRAM	rHScroll, rVScroll_End	; Clear scroll tables
000001F8                          M 	local	endaddr
000001F8                          M endaddr	equs	"rvscroll_end"
000001F8 7000                     M 	moveq	#0,d0
000001FA 43F8 90FE                M 	lea	(rhscroll).w,a1
000001FE 323C 00F3                M 	move.w	#(((rvscroll_end)-(rhscroll))-((rhscroll)&1))>>2-1,d1
00000202 22C0                     M .clear_23:	move.l	d0,(a1)+
00000204 51C9 FFFC                M 	dbf	d1,.clear_23
00000208                            		
00000208 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; Load a plane map
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; PARAMETERS:
0000020C                            ;	d0.l	- VDP command for writing the data to VRAM
0000020C                            ;	d1.w	- Width in tiles (minus 1)
0000020C                            ;	d2.w	- Height in tiles (minus 1)
0000020C                            ;	d3.w	- Base tile properties for each tile
0000020C                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
0000020C                            ;	a1.l	- Plane map address
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; RETURNS:
0000020C                            ;	Nothing
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            LoadPlaneMap:
0000020C                            LoadPlaneMap_H64:
0000020C 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
00000212 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000214                            
00000214                            LoadPlaneMap_H32:
00000214 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
0000021A 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
0000021C                            
0000021C                            LoadPlaneMap_H128:
0000021C 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
00000222                            
00000222                            LoadPlaneMap_Custom:
00000222                            .RowLoop:
00000222 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000228 3801                       		move.w	d1,d4				; Store width
0000022A                            
0000022A                            .TileLoop:
0000022A 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
0000022C DA43                       		add.w	d3,d5				; Add base tile properties
0000022E 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
00000234 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000238 D086                       		add.l	d6,d0				; Next row
0000023A 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
0000023E 4E75                       		rts
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; Load a plane map into RAM
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; PARAMETERS:
00000240                            ;	d1.w	- Width in tiles (minus 1)
00000240                            ;	d2.w	- Height in tiles (minus 1)
00000240                            ;	d3.w	- Base tile properties for each tile
00000240                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000240                            ;	a0.l	- Buffer to load into
00000240                            ;	a1.l	- Plane map address
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; RETURNS:
00000240                            ;	Nothing
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            LoadPlaneMap_RAM:
00000240                            .RowLoop:
00000240 2448                       		movea.l	a0,a2				; Copy buffer address
00000242 3801                       		move.w	d1,d4				; Store width
00000244                            
00000244                            .TileLoop:
00000244 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
00000246 DA43                       		add.w	d3,d5				; Add base tile properties
00000248 34C5                       		move.w	d5,(a2)+			; Save in RAM
0000024A 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
0000024E D0FC 0080                  		adda.w	#$80,a0				; Next row
00000252 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000256 4E75                       		rts
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; Fill the plane map with a value in a specific region
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; PARAMETERS:
00000258                            ;	d0.l	- VDP command for writing the data to VRAM
00000258                            ;	d1.w	- Width in tiles (minus 1)
00000258                            ;	d2.w	- Height in tiles (minus 1)
00000258                            ;	d3.w	- Value to fill plane map with
00000258                            ;	d6.l	- Delta value for drawing to the next row
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; RETURNS:
00000258                            ;	Nothing
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            FillPlaneMap:
00000258                            FillPlaneMap_H64:
00000258 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000025E 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000260                            
00000260                            FillPlaneMap_H32:
00000260 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000266 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000268                            
00000268                            FillPlaneMap_H128:
00000268 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000026E                            
0000026E                            FillPlaneMap_Custom:
0000026E                            .RowLoop:
0000026E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000274 3801                       		move.w	d1,d4				; Store width
00000276                            
00000276                            .TileLoop:
00000276 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
0000027C 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000280 D086                       		add.l	d6,d0				; Next row
00000282 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000286 4E75                       		rts
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000288                            ; to be cleared by issuing the commands (this checks for overflow)
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ; 	d1.l	- Source address
00000288                            ; 	d2.w	- Destination address
00000288                            ; 	d3.w	- Transfer length
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000288                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000288 =00000001                  Use128kbSafeDMA		= 1
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000288                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000288                            ; before calling and then restore interrupts after.
00000288 =00000000                  UseVIntSafeDMA		= 0
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000288                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000288                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000288 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Convenience macros, for increased maintainability of the code.
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Like vdpComm, but starting from an address contained in a register
00000288 =00000001                  vdpCommReg_defined = 1
00000288                            vdpCommReg	macro	reg, type, rwd, clr
00000288                            		local	cd
00000288                            cd		= \type&\rwd
00000288                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000288                            		if ((cd)&3)<>0
00000288                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000288                            		endif
00000288                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000288                            							; (word-swapped) places
00000288                            		swap	\reg				; Put all bits in proper places
00000288                            		if \clr<>0
00000288                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000288                            		endif
00000288                            		if ((cd)&$FC)=$20
00000288                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000288                            		elseif ((cd)&$FC)<>0
00000288                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000288                            		endif
00000288                            		endm
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            QueueDMATransfer:
00000288                            
00000288 3278 90FC                  		movea.w	rDMASlot.w,a1
0000028C B2FC 90FC                  		cmpa.w	#rDMASlot,a1
00000290 6700                       		beq.s	.Done				; Return if there's no more room in the queue
00000292                            
00000292 E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000294                            
00000294 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000296                            			; Compute position of last transferred word. This handles 2 cases:
00000296                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000296                            			; (2) (source+length)&$FFFF = 0
00000296 5340                       			subq.w  #1,d0
00000298 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
0000029A 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
0000029C                            
0000029C                            		; Store VDP commands for specifying DMA into the queue
0000029C 4841                       		swap	d1				; Want the high byte first
0000029E 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
000002A2 C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
000002A4 32C0                       		move.w	d0,(a1)+			; Store command
000002A6 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
000002A8 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
000002AC 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
000002B0                            
000002B0                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
000002B0                          M 	local	cd
000002B0 =00000021                M cd	=	vram&dma
000002B0 E58A                     M 	lsl.l	#2,d2
000002B2 5242                     M 	addq.w	#((cd)&3),d2
000002B4 E45A                     M 	ror.w	#2,d2
000002B6 4842                     M 	swap	d2
000002B8 0242 0003                M 	andi.w	#3,d2
000002BC 4AC2                     M 	tas.b	d2
000002BE 22C2                       		move.l	d2,(a1)+			; Store command
000002C0                            
000002C0 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
000002C2 31C9 90FC                  		move.w	a1,rDMASlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000002C6                            
000002C6                            .Done:
000002C6 4E75                       		rts
000002C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002C8                            .DoubleTransfer:
000002C8                            			; Hand-coded version to break the DMA transfer into two smaller transfers
000002C8                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
000002C8                            			; of space) than by the method of saving parameters and calling the normal
000002C8                            			; DMA function twice, as Sonic3_Complete does.
000002C8                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
000002C8 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
000002CA 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
000002CC                            
000002CC                            			; Store VDP commands for specifying DMA into the queue
000002CC 4841                       			swap	d1			; Want the high byte first
000002CE                            
000002CE                            			; Sadly, all registers we can spare are in use right now, so we can't use
000002CE                            			; no-cost RAM source safety.
000002CE 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
000002D2 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
000002D6 32C1                       			move.w	d1,(a1)+		; Store command
000002D8 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
000002DA 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
000002DE 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
000002E0 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
000002E4 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
000002E8                            
000002E8 3602                       			move.w	d2,d3			; Save for later
000002EA                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
000002EA                          M 	local	cd
000002EA =00000021                M cd	=	vram&dma
000002EA E58A                     M 	lsl.l	#2,d2
000002EC 5242                     M 	addq.w	#((cd)&3),d2
000002EE E45A                     M 	ror.w	#2,d2
000002F0 4842                     M 	swap	d2
000002F2 0242 0003                M 	andi.w	#3,d2
000002F6 4AC2                     M 	tas.b	d2
000002F8 22C2                       			move.l	d2,(a1)+		; Store command
000002FA                            
000002FA B2FC 90FC                  			cmpa.w	#rDMASlot,a1		; Did this command fill the queue?
000002FE 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
00000300                            
00000300                            			; Store VDP commands for specifying DMA into the queue
00000300                            			; The source address high byte was done above already in the comments marked
00000300                            			; with (**)
00000300 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
00000302 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000304 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000308 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
0000030C                            
0000030C                            			; d1 contains length up to the end of the 128kB boundary
0000030C D241                       			add.w	d1,d1			; Convert it into byte length...
0000030E D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
00000310                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
00000310                          M 	local	cd
00000310 =00000021                M cd	=	vram&dma
00000310 E589                     M 	lsl.l	#2,d1
00000312 5241                     M 	addq.w	#((cd)&3),d1
00000314 E459                     M 	ror.w	#2,d1
00000316 4841                     M 	swap	d1
00000318 0241 0003                M 	andi.w	#3,d1
0000031C 4AC1                     M 	tas.b	d1
0000031E 22C1                       			move.l	d1,(a1)+		; Store command
00000320                            
00000320 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
00000322 31C9 90FC                  			move.w	a1,rDMASlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000326                            
00000326 4E75                       			rts
00000328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000328                            .SkipSecondTransfer:
00000328 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
0000032A                            	
0000032A 4E75                       			rts
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; PARAMETERS:
0000032C                            ;	a6.l	- VDP control port
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; RETURNS:
0000032C                            ;	Nothing
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ProcessDMAQueue:
0000032C 43F8 9000                  		lea	rDMAQueue.w,a1
00000330 31C9 90FC                  		move.w	a1,rDMASlot.w
00000334                            
00000334                            		rept (rDMASlot-rDMAQueue)/(7*2)
00000334                            			move.w	(a1)+,d0
00000334                            			beq.w	.Done			; Branch if we reached a stop token
00000334                            			
00000334                            			move.w	d0,(a6)			; Issue a set of VDP commands...
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            		endr
00000334 3019                     M 	move.w	(a1)+,d0
00000336 6700 0000                M 	beq.w	.done
0000033A 3C80                     M 	move.w	d0,(a6)
0000033C 2C99                     M 	move.l	(a1)+,(a6)
0000033E 2C99                     M 	move.l	(a1)+,(a6)
00000340 3C99                     M 	move.w	(a1)+,(a6)
00000342 3C99                     M 	move.w	(a1)+,(a6)
00000344 3019                     M 	move.w	(a1)+,d0
00000346 6700 0000                M 	beq.w	.done
0000034A 3C80                     M 	move.w	d0,(a6)
0000034C 2C99                     M 	move.l	(a1)+,(a6)
0000034E 2C99                     M 	move.l	(a1)+,(a6)
00000350 3C99                     M 	move.w	(a1)+,(a6)
00000352 3C99                     M 	move.w	(a1)+,(a6)
00000354 3019                     M 	move.w	(a1)+,d0
00000356 6700 0000                M 	beq.w	.done
0000035A 3C80                     M 	move.w	d0,(a6)
0000035C 2C99                     M 	move.l	(a1)+,(a6)
0000035E 2C99                     M 	move.l	(a1)+,(a6)
00000360 3C99                     M 	move.w	(a1)+,(a6)
00000362 3C99                     M 	move.w	(a1)+,(a6)
00000364 3019                     M 	move.w	(a1)+,d0
00000366 6700 0000                M 	beq.w	.done
0000036A 3C80                     M 	move.w	d0,(a6)
0000036C 2C99                     M 	move.l	(a1)+,(a6)
0000036E 2C99                     M 	move.l	(a1)+,(a6)
00000370 3C99                     M 	move.w	(a1)+,(a6)
00000372 3C99                     M 	move.w	(a1)+,(a6)
00000374 3019                     M 	move.w	(a1)+,d0
00000376 6700 0000                M 	beq.w	.done
0000037A 3C80                     M 	move.w	d0,(a6)
0000037C 2C99                     M 	move.l	(a1)+,(a6)
0000037E 2C99                     M 	move.l	(a1)+,(a6)
00000380 3C99                     M 	move.w	(a1)+,(a6)
00000382 3C99                     M 	move.w	(a1)+,(a6)
00000384 3019                     M 	move.w	(a1)+,d0
00000386 6700 0000                M 	beq.w	.done
0000038A 3C80                     M 	move.w	d0,(a6)
0000038C 2C99                     M 	move.l	(a1)+,(a6)
0000038E 2C99                     M 	move.l	(a1)+,(a6)
00000390 3C99                     M 	move.w	(a1)+,(a6)
00000392 3C99                     M 	move.w	(a1)+,(a6)
00000394 3019                     M 	move.w	(a1)+,d0
00000396 6700 0000                M 	beq.w	.done
0000039A 3C80                     M 	move.w	d0,(a6)
0000039C 2C99                     M 	move.l	(a1)+,(a6)
0000039E 2C99                     M 	move.l	(a1)+,(a6)
000003A0 3C99                     M 	move.w	(a1)+,(a6)
000003A2 3C99                     M 	move.w	(a1)+,(a6)
000003A4 3019                     M 	move.w	(a1)+,d0
000003A6 6700 0000                M 	beq.w	.done
000003AA 3C80                     M 	move.w	d0,(a6)
000003AC 2C99                     M 	move.l	(a1)+,(a6)
000003AE 2C99                     M 	move.l	(a1)+,(a6)
000003B0 3C99                     M 	move.w	(a1)+,(a6)
000003B2 3C99                     M 	move.w	(a1)+,(a6)
000003B4 3019                     M 	move.w	(a1)+,d0
000003B6 6700 0000                M 	beq.w	.done
000003BA 3C80                     M 	move.w	d0,(a6)
000003BC 2C99                     M 	move.l	(a1)+,(a6)
000003BE 2C99                     M 	move.l	(a1)+,(a6)
000003C0 3C99                     M 	move.w	(a1)+,(a6)
000003C2 3C99                     M 	move.w	(a1)+,(a6)
000003C4 3019                     M 	move.w	(a1)+,d0
000003C6 6700 0000                M 	beq.w	.done
000003CA 3C80                     M 	move.w	d0,(a6)
000003CC 2C99                     M 	move.l	(a1)+,(a6)
000003CE 2C99                     M 	move.l	(a1)+,(a6)
000003D0 3C99                     M 	move.w	(a1)+,(a6)
000003D2 3C99                     M 	move.w	(a1)+,(a6)
000003D4 3019                     M 	move.w	(a1)+,d0
000003D6 6700 0000                M 	beq.w	.done
000003DA 3C80                     M 	move.w	d0,(a6)
000003DC 2C99                     M 	move.l	(a1)+,(a6)
000003DE 2C99                     M 	move.l	(a1)+,(a6)
000003E0 3C99                     M 	move.w	(a1)+,(a6)
000003E2 3C99                     M 	move.w	(a1)+,(a6)
000003E4 3019                     M 	move.w	(a1)+,d0
000003E6 6700 0000                M 	beq.w	.done
000003EA 3C80                     M 	move.w	d0,(a6)
000003EC 2C99                     M 	move.l	(a1)+,(a6)
000003EE 2C99                     M 	move.l	(a1)+,(a6)
000003F0 3C99                     M 	move.w	(a1)+,(a6)
000003F2 3C99                     M 	move.w	(a1)+,(a6)
000003F4 3019                     M 	move.w	(a1)+,d0
000003F6 6700 0000                M 	beq.w	.done
000003FA 3C80                     M 	move.w	d0,(a6)
000003FC 2C99                     M 	move.l	(a1)+,(a6)
000003FE 2C99                     M 	move.l	(a1)+,(a6)
00000400 3C99                     M 	move.w	(a1)+,(a6)
00000402 3C99                     M 	move.w	(a1)+,(a6)
00000404 3019                     M 	move.w	(a1)+,d0
00000406 6700 0000                M 	beq.w	.done
0000040A 3C80                     M 	move.w	d0,(a6)
0000040C 2C99                     M 	move.l	(a1)+,(a6)
0000040E 2C99                     M 	move.l	(a1)+,(a6)
00000410 3C99                     M 	move.w	(a1)+,(a6)
00000412 3C99                     M 	move.w	(a1)+,(a6)
00000414 3019                     M 	move.w	(a1)+,d0
00000416 6700 0000                M 	beq.w	.done
0000041A 3C80                     M 	move.w	d0,(a6)
0000041C 2C99                     M 	move.l	(a1)+,(a6)
0000041E 2C99                     M 	move.l	(a1)+,(a6)
00000420 3C99                     M 	move.w	(a1)+,(a6)
00000422 3C99                     M 	move.w	(a1)+,(a6)
00000424 3019                     M 	move.w	(a1)+,d0
00000426 6700 0000                M 	beq.w	.done
0000042A 3C80                     M 	move.w	d0,(a6)
0000042C 2C99                     M 	move.l	(a1)+,(a6)
0000042E 2C99                     M 	move.l	(a1)+,(a6)
00000430 3C99                     M 	move.w	(a1)+,(a6)
00000432 3C99                     M 	move.w	(a1)+,(a6)
00000434 3019                     M 	move.w	(a1)+,d0
00000436 6700 0000                M 	beq.w	.done
0000043A 3C80                     M 	move.w	d0,(a6)
0000043C 2C99                     M 	move.l	(a1)+,(a6)
0000043E 2C99                     M 	move.l	(a1)+,(a6)
00000440 3C99                     M 	move.w	(a1)+,(a6)
00000442 3C99                     M 	move.w	(a1)+,(a6)
00000444 3019                     M 	move.w	(a1)+,d0
00000446 6700 0000                M 	beq.w	.done
0000044A 3C80                     M 	move.w	d0,(a6)
0000044C 2C99                     M 	move.l	(a1)+,(a6)
0000044E 2C99                     M 	move.l	(a1)+,(a6)
00000450 3C99                     M 	move.w	(a1)+,(a6)
00000452 3C99                     M 	move.w	(a1)+,(a6)
00000454 7000                       		moveq	#0,d0
00000456                            
00000456                            .Done:
00000456 31C0 9000                  		move.w	d0,rDMAQueue.w
0000045A 4E75                       		rts
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; Initialize the DMA queue
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; PARAMETERS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; RETURNS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            InitDMAQueue:
0000045C 43F8 9000                  		lea	rDMAQueue.w,a1
00000460 32BC 0000                  		move.w	#0,(a1)
00000464 31C9 90FC                  		move.w	a1,rDMASlot.w
00000468 223C 9695 9493             		move.l	#$96959493,d1
0000046E =00000000                  c		= 0
0000046E                            		rept (rDMASlot-rDMAQueue)/(7*2)
0000046E                            			movep.l	d1,2+c(a1)
0000046E                            c			= c+14
0000046E                            		endr
0000046E 03C9 0002                M 	movep.l	d1,2+c(a1)
00000472 =0000000E                M c	=	c+14
00000472 03C9 0010                M 	movep.l	d1,2+c(a1)
00000476 =0000001C                M c	=	c+14
00000476 03C9 001E                M 	movep.l	d1,2+c(a1)
0000047A =0000002A                M c	=	c+14
0000047A 03C9 002C                M 	movep.l	d1,2+c(a1)
0000047E =00000038                M c	=	c+14
0000047E 03C9 003A                M 	movep.l	d1,2+c(a1)
00000482 =00000046                M c	=	c+14
00000482 03C9 0048                M 	movep.l	d1,2+c(a1)
00000486 =00000054                M c	=	c+14
00000486 03C9 0056                M 	movep.l	d1,2+c(a1)
0000048A =00000062                M c	=	c+14
0000048A 03C9 0064                M 	movep.l	d1,2+c(a1)
0000048E =00000070                M c	=	c+14
0000048E 03C9 0072                M 	movep.l	d1,2+c(a1)
00000492 =0000007E                M c	=	c+14
00000492 03C9 0080                M 	movep.l	d1,2+c(a1)
00000496 =0000008C                M c	=	c+14
00000496 03C9 008E                M 	movep.l	d1,2+c(a1)
0000049A =0000009A                M c	=	c+14
0000049A 03C9 009C                M 	movep.l	d1,2+c(a1)
0000049E =000000A8                M c	=	c+14
0000049E 03C9 00AA                M 	movep.l	d1,2+c(a1)
000004A2 =000000B6                M c	=	c+14
000004A2 03C9 00B8                M 	movep.l	d1,2+c(a1)
000004A6 =000000C4                M c	=	c+14
000004A6 03C9 00C6                M 	movep.l	d1,2+c(a1)
000004AA =000000D2                M c	=	c+14
000004AA 03C9 00D4                M 	movep.l	d1,2+c(a1)
000004AE =000000E0                M c	=	c+14
000004AE 03C9 00E2                M 	movep.l	d1,2+c(a1)
000004B2 =000000EE                M c	=	c+14
000004B2 03C9 00F0                M 	movep.l	d1,2+c(a1)
000004B6 =000000FC                M c	=	c+14
000004B6 4E75                       		rts
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; Load a palette into the main palette buffer
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; PARAMETERS:
000004B8                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004B8                            ;	a0.l	- Pointer to palette data
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            LoadPalette:
000004B8 43F8 98CE                  		lea	rPalette.w,a1			; Main palette buffer
000004BC 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; Load a palette into the target palette buffer
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; PARAMETERS:
000004BE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004BE                            ;	a0.l	- Pointer to palette data
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            LoadTargetPal:
000004BE 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000004C2 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; Load a palette into the main water palette buffer
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; PARAMETERS:
000004C4                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004C4                            ;	a0.l	- Pointer to palette data
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            LoadWaterPal:
000004C4 43F8 984E                  		lea	rWaterPal.w,a1		; Main water palette buffer
000004C8 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; Load a palette into the target water palette buffer
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; PARAMETERS:
000004CA                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CA                            ;	a0.l	- Pointer to palette data
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            LoadTargetWaterPal:
000004CA 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; Load a palette into a palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; PARAMETERS:
000004CE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CE                            ;	a0.l	- Pointer to palette data
000004CE                            ;	a1.l	- Pointer to destination buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            LoadPalToBuf:
000004CE 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
000004D0 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
000004D4 4E75                       		rts
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; Fade the palette to black
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; PARAMETERS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; RETURNS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            FadeToBlack:
000004D6 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000004DC                            
000004DC                            FadeToBlack_Custom:
000004DC 7807                       		moveq	#7,d4				; Set repeat times
000004DE                            		
000004DE                            .FadeLoop:
000004DE                            		rept	2
000004DE                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000004DE                            			bsr.w	VSync_Routine		; Do V-SYNC
000004DE                            		endr
000004DE 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004E4 6100 0000                M 	bsr.w	vsync_routine
000004E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004EE 6100 0000                M 	bsr.w	vsync_routine
000004F2 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
000004F4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000004F8 4E75                       		rts
000004FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004FA                            FadeToBlack_Once:
000004FA 7000                       		moveq	#0,d0
000004FC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000500 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000504 D0C0                       		adda.w	d0,a0				; ''
00000506 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000050A                            
0000050A                            .FadeLoop:
0000050A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000050C 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000510                            
00000510 7000                       		moveq	#0,d0
00000512 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000516 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000051A D0C0                       		adda.w	d0,a0				; ''
0000051C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000520                            
00000520                            .FadeLoopWater:
00000520 6100                       		bsr.s	.FadeColor			; Fade a color			
00000522 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000526 4E75                       		rts
00000528                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000528                            .FadeColor:
00000528 3A10                       		move.w	(a0),d5				; Load color
0000052A 6700                       		beq.s	.NoRed				; If the color is already black, branch
0000052C 3205                       		move.w	d5,d1				; Copy color
0000052E 1401                       		move.b	d1,d2				; Load green and red
00000530 1601                       		move.b	d1,d3				; Load only red
00000532                            
00000532 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000536 6700                       		beq.s	.NoBlue				; If blue is finished, branch
00000538 0445 0200                  		subi.w	#$200,d5			; Decrease blue
0000053C                            
0000053C                            .NoBlue:
0000053C 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000540 6700                       		beq.s	.NoGreen			; If green is finished, branch
00000542 0445 0020                  		subi.w	#$20,d5				; Decrease green
00000546                            
00000546                            .NoGreen:
00000546 0203 000E                  		andi.b	#$E,d3				; Get only red
0000054A 6700                       		beq.s	.NoRed				; If red is finished, branch
0000054C 5545                       		subq.w	#2,d5				; Decrease red
0000054E                            
0000054E                            .NoRed:
0000054E 30C5                       		move.w	d5,(a0)+			; Save the color
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette from black to the target palette
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeFromBlack:
00000552 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000558                            
00000558                            FadeFromBlack_Custom:
00000558 780E                       		moveq	#$E,d4				; Maximum color check
0000055A                            
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
00000570 5504                       		subq.b	#2,d4				; Decrement color check
00000572 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
00000574                            
00000574 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
0000057A 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000057E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000057E                            FadeFromBlack_Once:
0000057E 7000                       		moveq	#0,d0
00000580 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000584 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000588 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000058C D0C0                       		adda.w	d0,a0				; ''
0000058E D2C0                       		adda.w	d0,a1				; ''
00000590 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000594                            
00000594                            .FadeLoop:
00000594 6100                       		bsr.s	.FadeColor			; Fade a color			
00000596 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000059A                            
0000059A 7000                       		moveq	#0,d0
0000059C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000005A0 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000005A4 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000005A8 D0C0                       		adda.w	d0,a0				; ''
000005AA D2C0                       		adda.w	d0,a1				; ''
000005AC 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000005B0                            
000005B0                            .FadeLoopWater:
000005B0 6100                       		bsr.s	.FadeColor			; Fade a color			
000005B2 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005B6 4E75                       		rts
000005B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005B8                            .FadeColor:
000005B8 1A11                       		move.b	(a1),d5				; Load blue
000005BA 3219                       		move.w	(a1)+,d1			; Load green and red
000005BC 1401                       		move.b	d1,d2				; Load red
000005BE E809                       		lsr.b	#4,d1				; Get only green
000005C0 0202 000E                  		andi.b	#$E,d2				; Get only red
000005C4                            
000005C4 3610                       		move.w	(a0),d3				; Load current color
000005C6 B805                       		cmp.b	d5,d4				; Should the blue fade?
000005C8 6200                       		bhi.s	.NoBlue				; If not, branch
000005CA 0643 0200                  		addi.w	#$200,d3			; Increase blue
000005CE                            
000005CE                            .NoBlue:
000005CE B801                       		cmp.b	d1,d4				; Should the green fade?
000005D0 6200                       		bhi.s	.NoGreen			; If not, branch
000005D2 0643 0020                  		addi.w	#$20,d3				; Increase green
000005D6                            
000005D6                            .NoGreen:
000005D6 B802                       		cmp.b	d2,d4				; Should the red fade?
000005D8 6200                       		bhi.s	.NoRed				; If not, branch
000005DA 5443                       		addq.w	#2,d3				; Increase red
000005DC                            
000005DC                            .NoRed:
000005DC 30C3                       		move.w	d3,(a0)+			; Save the color
000005DE 4E75                       		rts
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; Fade the palette to white
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; PARAMETERS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; RETURNS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            FadeToWhite:
000005E0 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000005E6                            
000005E6                            FadeToWhite_Custom:
000005E6 7807                       		moveq	#7,d4				; Set repeat times
000005E8                            
000005E8                            .FadeLoop:
000005E8                            		rept	2
000005E8                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000005E8                            			bsr.w	VSync_Routine		; Do V-SYNC
000005E8                            		endr
000005E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005EE 6100 0000                M 	bsr.w	vsync_routine
000005F2 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005F8 6100 0000                M 	bsr.w	vsync_routine
000005FC 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
000005FE 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000602 4E75                       		rts
00000604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000604                            FadeToWhite_Once:
00000604 7000                       		moveq	#0,d0
00000606 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000060A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000060E D0C0                       		adda.w	d0,a0				; ''
00000610 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000614                            
00000614                            .FadeLoop:
00000614 6100                       		bsr.s	.FadeColor			; Fade a color			
00000616 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000061A                            
0000061A 7000                       		moveq	#0,d0
0000061C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000620 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000062A                            
0000062A                            .FadeLoopWater:
0000062A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000630 4E75                       		rts
00000632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000632                            .FadeColor:
00000632 3A10                       		move.w	(a0),d5				; Load color
00000634 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
00000638 6700                       		beq.s	.NoRed				; If so, branch
0000063A 3205                       		move.w	d5,d1				; Copy color
0000063C 1401                       		move.b	d1,d2				; Load green and red
0000063E 1601                       		move.b	d1,d3				; Load only red
00000640                            
00000640 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000644 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
00000648 6700                       		beq.s	.NoBlue				; If do, branch
0000064A 0645 0200                  		addi.w	#$200,d5			; Increase blue
0000064E                            
0000064E                            .NoBlue:
0000064E 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000652 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
00000656 6700                       		beq.s	.NoGreen			; If so, branch
00000658 0645 0020                  		addi.w	#$20,d5				; Increase green
0000065C                            
0000065C                            .NoGreen:
0000065C 0203 000E                  		andi.b	#$E,d3				; Get only red
00000660 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
00000664 6700                       		beq.s	.NoRed				; If so, branch
00000666 5445                       		addq.w	#2,d5				; Increase red
00000668                            
00000668                            .NoRed:
00000668 30C5                       		move.w	d5,(a0)+			; Save the color
0000066A 4E75                       		rts
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; Fade the palette from white to the target palette
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; PARAMETERS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; RETURNS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            FadeFromWhite:
0000066C 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000672                            
00000672                            FadeFromWhite_Custom:
00000672 7800                       		moveq	#0,d4				; Minimum color check
00000674                            		
00000674                            .FadeLoop:
00000674                            		rept	2
00000674                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000674                            			bsr.w	VSync_Routine		; Do V-SYNC
00000674                            		endr
00000674 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000067A 6100 0000                M 	bsr.w	vsync_routine
0000067E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000684 6100 0000                M 	bsr.w	vsync_routine
00000688 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
0000068A 5404                       		addq.b	#2,d4				; Decrement color check
0000068C 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
00000690 66E2                       		bne.s	.FadeLoop			; If not, branch
00000692                            
00000692 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
00000698 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000069C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000069C                            FadeFromWhite_Once:
0000069C 7000                       		moveq	#0,d0
0000069E 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
000006A2 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000006A6 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006AA D0C0                       		adda.w	d0,a0				; ''
000006AC D2C0                       		adda.w	d0,a1				; ''
000006AE 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006B2                            
000006B2                            .FadeLoop:
000006B2 6100                       		bsr.s	.FadeColor			; Fade a color			
000006B4 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000006B8                            
000006B8 7000                       		moveq	#0,d0
000006BA 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000006BE 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000006C2 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006C6 D0C0                       		adda.w	d0,a0				; ''
000006C8 D2C0                       		adda.w	d0,a1				; ''
000006CA 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006CE                            
000006CE                            .FadeLoopWater:
000006CE 6100                       		bsr.s	.FadeColor			; Fade a color			
000006D0 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006D4 4E75                       		rts
000006D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006D6                            .FadeColor:
000006D6 1A11                       		move.b	(a1),d5				; Load blue
000006D8 3219                       		move.w	(a1)+,d1			; Load green and red
000006DA 1401                       		move.b	d1,d2				; Load red
000006DC E809                       		lsr.b	#4,d1				; Get only green
000006DE 0202 000E                  		andi.b	#$E,d2				; Get only red
000006E2                            
000006E2 3610                       		move.w	(a0),d3				; Load current color
000006E4 B805                       		cmp.b	d5,d4				; Should the blue fade?
000006E6 6500                       		bcs.s	.NoBlue				; If not, branch
000006E8 0443 0200                  		subi.w	#$200,d3			; Decrease blue
000006EC                            
000006EC                            .NoBlue:
000006EC B801                       		cmp.b	d1,d4				; Should the green fade?
000006EE 6500                       		bcs.s	.NoGreen			; If not, branch
000006F0 0443 0020                  		subi.w	#$20,d3				; Decrease green
000006F4                            
000006F4                            .NoGreen:
000006F4 B802                       		cmp.b	d2,d4				; Should the red fade?
000006F6 6500                       		bcs.s	.NoRed				; If not, branch
000006F8 5543                       		subq.w	#2,d3				; Decrease red
000006FA                            
000006FA                            .NoRed:
000006FA 30C3                       		move.w	d3,(a0)+			; Save the color
000006FC 4E75                       		rts
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; Fade the palette from the current palette to the target palette
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; PARAMETERS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; RETURNS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            FadeToPalette:
000006FE 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000704                            
00000704                            FadeToPalette_Custom:
00000704 7000                       		moveq	#0,d0
00000706 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000070A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000070E D0C0                       		adda.w	d0,a0				; ''
00000710                            
00000710 7807                       		moveq	#7,d4				; Set repeat times
00000712                            
00000712                            .FadeLoop:
00000712                            		rept	2
00000712                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000712                            			bsr.w	VSync_Routine		; Do V-SYNC
00000712                            		endr
00000712 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000718 6100 0000                M 	bsr.w	vsync_routine
0000071C 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000722 6100 0000                M 	bsr.w	vsync_routine
00000726 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
00000728 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000072C 4E75                       		rts
0000072E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000072E                            FadeToPalette_Once:
0000072E 7000                       		moveq	#0,d0
00000730 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000734 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000738 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000073C D0C0                       		adda.w	d0,a0				; ''
0000073E D2C0                       		adda.w	d0,a1				; ''
00000740 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000744                            
00000744                            .FadeLoop:
00000744 6100                       		bsr.s	.FadeColor			; Fade a color			
00000746 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000074A                            
0000074A 7000                       		moveq	#0,d0
0000074C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000750 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
00000754 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000758 D0C0                       		adda.w	d0,a0				; ''
0000075A D2C0                       		adda.w	d0,a1				; ''
0000075C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000760                            
00000760                            .FadeLoopWater:
00000760 6100                       		bsr.s	.FadeColor			; Fade a color			
00000762 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000766 4E75                       		rts
00000768                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000768                            .FadeColor:
00000768 3610                       		move.w	(a0),d3				; Get color
0000076A B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
0000076C 6700                       		beq.s	.NoRed				; If so, branch
0000076E                            		
0000076E 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
00000772 1401                       		move.b	d1,d2				; Get red only
00000774 0202 000E                  		andi.b	#$E,d2				; ''
00000778 E809                       		lsr.b	#4,d1				; Get green only
0000077A                            
0000077A 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
0000077E BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
00000780 6700                       		beq.s	.NoBlue				; If not, branch
00000782 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000784 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000788 6000                       		bra.s	.NoBlue				; Continue
0000078A                            
0000078A                            .DecBlue:
0000078A 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000078E                            
0000078E                            .NoBlue:
0000078E 3A10                       		move.w	(a0),d5				; Get green
00000790 E80D                       		lsr.b	#4,d5				; ''
00000792 B205                       		cmp.b	d5,d1				; Does green need to fade?
00000794 6700                       		beq.s	.NoGreen			; If not, branch
00000796 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000798 0603 0020                  		addi.b	#$20,d3				; Increase green
0000079C 6000                       		bra.s	.NoGreen			; Continue
0000079E                            
0000079E                            .DecGreen:
0000079E 0403 0020                  		subi.b	#$20,d3				; Decrease green
000007A2                            
000007A2                            .NoGreen:
000007A2 3A10                       		move.w	(a0),d5				; Get red
000007A4 0205 000E                  		andi.b	#$E,d5				; ''
000007A8 B405                       		cmp.b	d5,d2				; Does red need to fade?
000007AA 6700                       		beq.s	.NoRed				; If not, branch
000007AC 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
000007AE 5403                       		addq.b	#2,d3				; Increase red
000007B0 6000                       		bra.s	.NoRed				; Continue
000007B2                            
000007B2                            .DecRed:
000007B2 5503                       		subq.b	#2,d3				; Decrease red
000007B4                            
000007B4                            .NoRed:
000007B4 30C3                       		move.w	d3,(a0)+			; Save new color
000007B6 4E75                       		rts
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            ; Initialize the sprite table
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            InitSpriteTable:
000007B8 7000                       		moveq	#0,d0
000007BA 41F8 94CE                  		lea	rSprites.w,a0			; Sprite table buffer
000007BE 7201                       		moveq	#1,d1				; Link value
000007C0 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
000007C2                            
000007C2                            .Loop:
000007C2 3080                       		move.w	d0,(a0)				; Move off screen
000007C4 1141 0003                  		move.b	d1,3(a0)			; Set link value
000007C8 5241                       		addq.w	#1,d1				; Increment link value
000007CA 5048                       		addq.w	#8,a0				; Next sprite
000007CC 51CF FFF4                  		dbf	d7,.Loop			; Loop
000007D0 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
000007D4 4E75                       		rts
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; Draw the sprites from mappings
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; PARAMETERS:
000007D6                            ;	d0.w	- X position
000007D6                            ;	d1.w	- Y position
000007D6                            ;	d4.w	- Number of sprites to draw
000007D6                            ;	d5.w	- Sprite tile properties
000007D6                            ;	d6.b	- Render flags
000007D6                            ;	d7.w	- Max number of sprites left to draw
000007D6                            ;	a1.l	- Mappings frame data
000007D6                            ;	a6.l	- Sprite table buffer
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; RETURNS:
000007D6                            ;	Nothing
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            DrawSprite:
000007D6 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000007D8 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
000007DA E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000007DC 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            ; Draw the sprites from mappings with no flip checks
000007E0                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            DrawSprite_Loop:
000007E0 1419                       		move.b	(a1)+,d2			; Get Y offset
000007E2 4882                       		ext.w	d2				; ''
000007E4 D441                       		add.w	d1,d2				; Add onto Y position
000007E6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007E8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000007EA 524E                       		addq.w	#1,a6				; Skip link data
000007EC 3419                       		move.w	(a1)+,d2			; Get tile properties
000007EE D445                       		add.w	d5,d2				; Add base tile properties
000007F0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F2 3419                       		move.w	(a1)+,d2			; Get X offset
000007F4 D440                       		add.w	d0,d2				; Add onto X position
000007F6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F8 5347                       		subq.w	#1,d7				; Decrement sprite count
000007FA 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
000007FE                            		
000007FE                            DrawSprite_End:
000007FE 4E75                       		rts
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            ; Draw the sprites from mappings, horizontally flipped
00000800                            ; (Parameters inherited from DrawSprite)
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            DrawSprite_FlipX:
00000800 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000802 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000804                            
00000804                            .Loop:
00000804 1419                       		move.b	(a1)+,d2			; Get Y offset
00000806 4882                       		ext.w	d2				; ''
00000808 D441                       		add.w	d1,d2				; Add onto Y position
0000080A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000080C 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000080E 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000810 524E                       		addq.w	#1,a6				; Skip link data
00000812 3419                       		move.w	(a1)+,d2			; Get tile properties
00000814 D445                       		add.w	d5,d2				; Add base tile properties
00000816 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
0000081A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000081C 3419                       		move.w	(a1)+,d2			; Get X offset
0000081E 4442                       		neg.w	d2				; Negate it
00000820 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
00000824 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000826 D440                       		add.w	d0,d2				; Add onto X position
00000828 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000082A 5347                       		subq.w	#1,d7				; Decrement sprite count
0000082C 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000830 4E75                       		rts
00000832                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000832                            DrawSprite_XFlipOff:
00000832 0808 0808                  		dc.b	8, 8, 8, 8
00000836 1010 1010                  		dc.b	$10, $10, $10, $10
0000083A 1818 1818                  		dc.b	$18, $18, $18, $18
0000083E 2020 2020                  		dc.b	$20, $20, $20, $20
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            ; Draw the sprites from mappings, horizontally and vertically flipped
00000842                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            DrawSprite_FlipXY:
00000842 1419                       		move.b	(a1)+,d2			; Get Y offset
00000844 4882                       		ext.w	d2				; ''
00000846 4442                       		neg.w	d2				; Negate it
00000848 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000084A 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000084E 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000850 D441                       		add.w	d1,d2				; Add onto Y position
00000852 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000854 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000856 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000858 524E                       		addq.w	#1,a6				; Skip link data
0000085A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000085C D445                       		add.w	d5,d2				; Add base tile properties
0000085E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 3419                       		move.w	(a1)+,d2			; Get X offset
00000866 4442                       		neg.w	d2				; Negate it
00000868 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
0000086C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000086E D440                       		add.w	d0,d2				; Add onto X position
00000870 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000872 5347                       		subq.w	#1,d7				; Decrement sprite count
00000874 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
00000878 4E75                       		rts
0000087A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087A                            DrawSprite_YFlipOff:
0000087A 0810 1820                  		dc.b	8, $10, $18, $20
0000087E 0810 1820                  		dc.b	8, $10, $18, $20
00000882 0810 1820                  		dc.b	8, $10, $18, $20
00000886 0810 1820                  		dc.b	8, $10, $18, $20
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            ; Draw the sprites from mappings, vertically flipped
0000088A                            ; (Parameters inherited from DrawSprite)
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            DrawSprite_FlipY:
0000088A 1419                       		move.b	(a1)+,d2			; Get Y offset
0000088C 4882                       		ext.w	d2				; ''
0000088E 4442                       		neg.w	d2				; Negate it
00000890 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000892 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000896 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000089A 9446                       		sub.w	d6,d2				; Subtract from the Y offset
0000089C D441                       		add.w	d1,d2				; Add onto Y position
0000089E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A0 544E                       		addq.w	#2,a6				; Skip link data
000008A2 3419                       		move.w	(a1)+,d2			; Get tile properties
000008A4 D445                       		add.w	d5,d2				; Add base tile properties
000008A6 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
000008AA 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008AC 3419                       		move.w	(a1)+,d2			; Get X offset
000008AE D440                       		add.w	d0,d2				; Add onto X position
000008B0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008B2 5347                       		subq.w	#1,d7				; Decrement sprite count
000008B4 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
000008B8 4E75                       		rts
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; Draw the sprites from mappings (with boundary checks)
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; PARAMETERS:
000008BA                            ;	d0.w	- X position
000008BA                            ;	d1.w	- Y position
000008BA                            ;	d4.w	- Number of sprites to draw
000008BA                            ;	d5.w	- Sprite tile properties
000008BA                            ;	d6.b	- Render flags
000008BA                            ;	d7.w	- Max number of sprites left to draw
000008BA                            ;	a1.l	- Mappings frame data
000008BA                            ;	a6.l	- Sprite table buffer
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; RETURNS:
000008BA                            ;	Nothing
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            DrawSprite_BoundChk:
000008BA E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000008BC 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
000008BE E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000008C0 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
000008C4                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            DrawSprBndChk_Loop:
000008C4 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C6 4882                       		ext.w	d2				; ''
000008C8 D441                       		add.w	d1,d2				; Add onto Y position
000008CA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000008CE 6300                       		bls.s	.Next_YOffScr			; If so, branch
000008D0 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
000008D4 6400                       		bhs.s	.Next_YOffScr			; If so, branch
000008D6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000008DA 524E                       		addq.w	#1,a6				; Skip link data
000008DC 3419                       		move.w	(a1)+,d2			; Get tile properties
000008DE D445                       		add.w	d5,d2				; Add base tile properties
000008E0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E2 3419                       		move.w	(a1)+,d2			; Get X offset
000008E4 D440                       		add.w	d0,d2				; Add onto X position
000008E6 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000008EA 6300                       		bls.s	.Next_XOffScr			; If so, branch
000008EC 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000008F0 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000008F2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008F4 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F6 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
000008FA 4E75                       		rts
000008FC                            
000008FC                            .Next_XOffScr:
000008FC 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000008FE 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000902 4E75                       		rts
00000904                            
00000904                            .Next_YOffScr:
00000904 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000906 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000090A 4E75                       		rts
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
0000090C                            ; (Parameters inherited from DrawSprite_BoundChk)
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            DrawSprite_BndChk_FlipX:
0000090C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000090E 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
00000910                            
00000910                            .Loop:
00000910 1419                       		move.b	(a1)+,d2			; Get Y offset
00000912 4882                       		ext.w	d2				; ''
00000914 D441                       		add.w	d1,d2				; Add onto Y position
00000916 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000091A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000091C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000920 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000922 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000924 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000926 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000928 524E                       		addq.w	#1,a6				; Skip link data
0000092A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000092C D445                       		add.w	d5,d2				; Add base tile properties
0000092E 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000932 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000934 3419                       		move.w	(a1)+,d2			; Get X offset
00000936 4442                       		neg.w	d2				; Negate it
00000938 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
0000093C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000093E D440                       		add.w	d0,d2				; Add onto X position
00000940 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000944 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000946 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000094A 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000094C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000094E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000950 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000954 4E75                       		rts
00000956                            
00000956                            .Next_XOffScr:
00000956 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000958 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
0000095C 4E75                       		rts
0000095E                            
0000095E                            .Next_YOffScr:
0000095E 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000960 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
00000964 4E75                       		rts
00000966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000966                            DrwSprBndChk_XFlips:
00000966 0808 0808                  		dc.b	8, 8, 8, 8
0000096A 1010 1010                  		dc.b	$10, $10, $10, $10
0000096E 1818 1818                  		dc.b	$18, $18, $18, $18
00000972 2020 2020                  		dc.b	$20, $20, $20, $20
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
00000976                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            DrawSprite_BndChk_FlipXY:
00000976 1419                       		move.b	(a1)+,d2			; Get Y offset
00000978 4882                       		ext.w	d2				; ''
0000097A 4442                       		neg.w	d2				; Negate it
0000097C 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000097E 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000982 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000984 D441                       		add.w	d1,d2				; Add onto Y position
00000986 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000098A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000098C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000990 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000992 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000994 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000996 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000998 524E                       		addq.w	#1,a6				; Skip link data
0000099A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000099C D445                       		add.w	d5,d2				; Add base tile properties
0000099E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000009A2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A4 3419                       		move.w	(a1)+,d2			; Get X offset
000009A6 4442                       		neg.w	d2				; Negate it
000009A8 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009AC 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009AE D440                       		add.w	d0,d2				; Add onto X position
000009B0 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009B4 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009B6 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009BA 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009BC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009BE 5347                       		subq.w	#1,d7				; Decrement sprite count
000009C0 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009C4 4E75                       		rts
000009C6                            
000009C6                            .Next_XOffScr:
000009C6 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009C8 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009CC 4E75                       		rts
000009CE                            
000009CE                            .Next_YOffScr:
000009CE 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009D0 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009D4 4E75                       		rts
000009D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009D6                            DrwSprBndChk_YFlips:
000009D6 0810 1820                  		dc.b	8, $10, $18, $20
000009DA 0810 1820                  		dc.b	8, $10, $18, $20
000009DE 0810 1820                  		dc.b	8, $10, $18, $20
000009E2 0810 1820                  		dc.b	8, $10, $18, $20
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
000009E6                            ; (Parameters inherited from DrawSprite_BoundChk)
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            DrawSprite_BndChk_FlipY:
000009E6 1419                       		move.b	(a1)+,d2			; Get Y offset
000009E8 4882                       		ext.w	d2				; ''
000009EA 4442                       		neg.w	d2				; Negate it
000009EC 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
000009EE 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
000009F2 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009F6 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000009F8 D441                       		add.w	d1,d2				; Add onto Y position
000009FA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000009FE 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A00 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A04 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A06 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A08 544E                       		addq.w	#2,a6				; Skip link data
00000A0A 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A0C D445                       		add.w	d5,d2				; Add base tile properties
00000A0E 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A12 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A14 3419                       		move.w	(a1)+,d2			; Get X offset
00000A16 D440                       		add.w	d0,d2				; Add onto X position
00000A18 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A1C 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A1E 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A22 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A24 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A26 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A28 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A2C 4E75                       		rts
00000A2E                            
00000A2E                            .Next_XOffScr:
00000A2E 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A30 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A34 4E75                       		rts
00000A36                            
00000A36                            .Next_YOffScr:
00000A36 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A38 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A3C 4E75                       		rts
00000A3E                            ; =========================================================================================================================================================
00000A3E                            		include	"_LIB_/Joypad.asm"		; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; Mighty The Armadillo in PRISM PARADISE
00000A3E                            ; By Nat The Porcupine 2021
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Read joypad input
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; PARAMETERS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; RETURNS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ReadJoypads:
00000A3E 41F8 C740                  	lea	rP1Data.w,a0			; 8	; load RAM space for joypad data
00000A42 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000A48 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000A4A 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000A4C                            
00000A4C                            	; Repeat the following twice to
00000A4C                            	; collect input from both pads
00000A4C                            	rept	2
00000A4C                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000A4C                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000A4C                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000A4C                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000A4C                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000A4C                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000A4C                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000A4C                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000A4C                            		or.b	d3,d2			; 4	; combine collected button bits
00000A4C                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000A4C                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000A4C                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000A4C                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000A4C                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000A4C                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000A4C                            	endr
00000A4C 3280                     M 	move.w	d0,(a1)
00000A4E 7430                     M 	moveq	#%00110000,d2
00000A50 763F                     M 	moveq	#%00111111,d3
00000A52 C451                     M 	and.w	(a1),d2
00000A54 3281                     M 	move.w	d1,(a1)
00000A56 D402                     M 	add.b	d2,d2
00000A58 D402                     M 	add.b	d2,d2
00000A5A C659                     M 	and.w	(a1)+,d3
00000A5C 8403                     M 	or.b	d3,d2
00000A5E 4602                     M 	not.b	d2
00000A60 1610                     M 	move.b	(a0),d3
00000A62 B503                     M 	eor.b	d2,d3
00000A64 10C2                     M 	move.b	d2,(a0)+
00000A66 C602                     M 	and.b	d2,d3
00000A68 10C3                     M 	move.b	d3,(a0)+
00000A6A 3280                     M 	move.w	d0,(a1)
00000A6C 7430                     M 	moveq	#%00110000,d2
00000A6E 763F                     M 	moveq	#%00111111,d3
00000A70 C451                     M 	and.w	(a1),d2
00000A72 3281                     M 	move.w	d1,(a1)
00000A74 D402                     M 	add.b	d2,d2
00000A76 D402                     M 	add.b	d2,d2
00000A78 C659                     M 	and.w	(a1)+,d3
00000A7A 8403                     M 	or.b	d3,d2
00000A7C 4602                     M 	not.b	d2
00000A7E 1610                     M 	move.b	(a0),d3
00000A80 B503                     M 	eor.b	d2,d3
00000A82 10C2                     M 	move.b	d2,(a0)+
00000A84 C602                     M 	and.b	d2,d3
00000A86 10C3                     M 	move.b	d3,(a0)+
00000A88                            
00000A88 4E75                       	rts					; 16	; return
00000A8A                            
00000A8A                            ; =========================================================================================================================================================
00000A8A                            		include	"_LIB_/Interrupt.asm"		; Interrupt functions
00000A8A                            ; =========================================================================================================================================================
00000A8A                            ; Mighty The Armadillo in PRISM PARADISE
00000A8A                            ; By Nat The Porcupine 2021
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; Interrupt functions
00000A8A                            ; =========================================================================================================================================================
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; Wait for the vertical interrupt to run and finish
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; PARAMETERS:
00000A8A                            ;	Nothing
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; RETURNS:
00000A8A                            ;	Nothing
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            VSync:
00000A8A 50F8 C745                  		st	rVINTFlag.w			; Set V-INT flag
00000A8E                            
00000A8E                            VSync_Routine:
00000A8E                            		intsOn					; Enable interrupts
00000A8E 027C F8FF                M 	andi	#$f8ff,sr
00000A92                            		lagOff					; Turn off the lag-o-meter
00000A92                            
00000A92                            .Wait:
00000A92 4A38 C745                  		tst.b	rVINTFlag.w			; Has the V-INT run yet?
00000A96 66FA                       		bne.s	.Wait				; If not, wait some more
00000A98 4E75                       		rts
00000A9A                            ; =========================================================================================================================================================
00000A9A                            		include	"_LIB_/Decompression.asm"	; Decompression functions
00000A9A                            ; =========================================================================================================================================================
00000A9A                            ; Mighty The Armadillo in PRISM PARADISE
00000A9A                            ; By Nat The Porcupine 2021
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; Decompression functions
00000A9A                            ; =========================================================================================================================================================
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; Kosinski decompression (General purpose)
00000A9A                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; PARAMETERS:
00000A9A                            ;	a0.l	- Source address
00000A9A                            ;	a1.l	- Destination address
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; RETURNS:
00000A9A                            ;	a1.l	- End of decompressed data address
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A =00000001                  _Kos_UseLUT			equ	1
00000A9A =00000003                  _Kos_LoopUnroll			equ	3
00000A9A =00000001                  _Kos_ExtremeUnrolling		equ	1
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            _Kos_RunBitStream macro
00000A9A                            		dbra	d2,.skip\@
00000A9A                            		moveq	#7,d2				; Set repeat count to 8.
00000A9A                            		move.b	d1,d0				; Use the remaining 8 bits.
00000A9A                            		not.w	d3				; Have all 16 bits been used up?
00000A9A                            		bne.s	.skip\@				; Branch if not.
00000A9A                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000A9A                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000A9A                            	if _Kos_UseLUT=1
00000A9A                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000A9A                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000A9A                            	endif
00000A9A                            .skip\@:
00000A9A                            		endm
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            _Kos_ReadBit macro
00000A9A                            	if _Kos_UseLUT=1
00000A9A                            		add.b	d0,d0				; Get a bit from the bitstream.
00000A9A                            	else
00000A9A                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000A9A                            	endif
00000A9A                            		endm
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            KosDec:
00000A9A 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000A9C 7000                       		moveq	#0,d0
00000A9E 7200                       		moveq	#0,d1
00000AA0 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000AA4 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000AA6 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000AA8 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000AAC 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000AB0 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000AB2 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000AB4 6000                       		bra.s	.FetchNewCode
00000AB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000AB6                            .FetchCodeLoop:
00000AB6                            		; Code 1 (Uncompressed byte).
00000AB6                            		_Kos_RunBitStream
00000AB6 51CA 0000                M 	dbra	d2,.skip_30
00000ABA 7407                     M 	moveq	#7,d2
00000ABC 1001                     M 	move.b	d1,d0
00000ABE 4643                     M 	not.w	d3
00000AC0 6600                     M 	bne.s	.skip_30
00000AC2 1018                     M 	move.b	(a0)+,d0
00000AC4 1218                     M 	move.b	(a0)+,d1
00000AC6 1034 0000                M 	move.b	(a4,d0.w),d0
00000ACA 1234 1000                M 	move.b	(a4,d1.w),d1
00000ACE                          M .skip_30:
00000ACE 12D8                       		move.b	(a0)+,(a1)+
00000AD0                             
00000AD0                            .FetchNewCode:
00000AD0                            		_Kos_ReadBit
00000AD0 D000                     M 	add.b	d0,d0
00000AD2 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000AD4                             
00000AD4                            		; Codes 00 and 01.
00000AD4 7AFF                       		moveq	#-1,d5
00000AD6 4BD1                       		lea	(a1),a5
00000AD8                            		_Kos_RunBitStream
00000AD8 51CA 0000                M 	dbra	d2,.skip_32
00000ADC 7407                     M 	moveq	#7,d2
00000ADE 1001                     M 	move.b	d1,d0
00000AE0 4643                     M 	not.w	d3
00000AE2 6600                     M 	bne.s	.skip_32
00000AE4 1018                     M 	move.b	(a0)+,d0
00000AE6 1218                     M 	move.b	(a0)+,d1
00000AE8 1034 0000                M 	move.b	(a4,d0.w),d0
00000AEC 1234 1000                M 	move.b	(a4,d1.w),d1
00000AF0                          M .skip_32:
00000AF0                            		_Kos_ReadBit
00000AF0 D000                     M 	add.b	d0,d0
00000AF2 6500 0000                  		bcs.w	.Code_01
00000AF6                             
00000AF6                            		; Code 00 (Dictionary ref. short).
00000AF6                            		_Kos_RunBitStream
00000AF6 51CA 0000                M 	dbra	d2,.skip_34
00000AFA 7407                     M 	moveq	#7,d2
00000AFC 1001                     M 	move.b	d1,d0
00000AFE 4643                     M 	not.w	d3
00000B00 6600                     M 	bne.s	.skip_34
00000B02 1018                     M 	move.b	(a0)+,d0
00000B04 1218                     M 	move.b	(a0)+,d1
00000B06 1034 0000                M 	move.b	(a4,d0.w),d0
00000B0A 1234 1000                M 	move.b	(a4,d1.w),d1
00000B0E                          M .skip_34:
00000B0E                            		_Kos_ReadBit
00000B0E D000                     M 	add.b	d0,d0
00000B10 6500                       		bcs.s	.Copy45
00000B12                            		_Kos_RunBitStream
00000B12 51CA 0000                M 	dbra	d2,.skip_36
00000B16 7407                     M 	moveq	#7,d2
00000B18 1001                     M 	move.b	d1,d0
00000B1A 4643                     M 	not.w	d3
00000B1C 6600                     M 	bne.s	.skip_36
00000B1E 1018                     M 	move.b	(a0)+,d0
00000B20 1218                     M 	move.b	(a0)+,d1
00000B22 1034 0000                M 	move.b	(a4,d0.w),d0
00000B26 1234 1000                M 	move.b	(a4,d1.w),d1
00000B2A                          M .skip_36:
00000B2A                            		_Kos_ReadBit
00000B2A D000                     M 	add.b	d0,d0
00000B2C 6500                       		bcs.s	.Copy3
00000B2E                            		_Kos_RunBitStream
00000B2E 51CA 0000                M 	dbra	d2,.skip_38
00000B32 7407                     M 	moveq	#7,d2
00000B34 1001                     M 	move.b	d1,d0
00000B36 4643                     M 	not.w	d3
00000B38 6600                     M 	bne.s	.skip_38
00000B3A 1018                     M 	move.b	(a0)+,d0
00000B3C 1218                     M 	move.b	(a0)+,d1
00000B3E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B42 1234 1000                M 	move.b	(a4,d1.w),d1
00000B46                          M .skip_38:
00000B46 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B48 DAC5                       		adda.w	d5,a5
00000B4A 12DD                       		move.b	(a5)+,(a1)+
00000B4C 12DD                       		move.b	(a5)+,(a1)+
00000B4E 6080                       		bra.s	.FetchNewCode
00000B50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B50                            .Copy3:
00000B50                            		_Kos_RunBitStream
00000B50 51CA 0000                M 	dbra	d2,.skip_39
00000B54 7407                     M 	moveq	#7,d2
00000B56 1001                     M 	move.b	d1,d0
00000B58 4643                     M 	not.w	d3
00000B5A 6600                     M 	bne.s	.skip_39
00000B5C 1018                     M 	move.b	(a0)+,d0
00000B5E 1218                     M 	move.b	(a0)+,d1
00000B60 1034 0000                M 	move.b	(a4,d0.w),d0
00000B64 1234 1000                M 	move.b	(a4,d1.w),d1
00000B68                          M .skip_39:
00000B68 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B6A DAC5                       		adda.w	d5,a5
00000B6C 12DD                       		move.b	(a5)+,(a1)+
00000B6E 12DD                       		move.b	(a5)+,(a1)+
00000B70 12DD                       		move.b	(a5)+,(a1)+
00000B72 6000 FF5C                  		bra.w	.FetchNewCode
00000B76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B76                            .Copy45:
00000B76                            		_Kos_RunBitStream
00000B76 51CA 0000                M 	dbra	d2,.skip_40
00000B7A 7407                     M 	moveq	#7,d2
00000B7C 1001                     M 	move.b	d1,d0
00000B7E 4643                     M 	not.w	d3
00000B80 6600                     M 	bne.s	.skip_40
00000B82 1018                     M 	move.b	(a0)+,d0
00000B84 1218                     M 	move.b	(a0)+,d1
00000B86 1034 0000                M 	move.b	(a4,d0.w),d0
00000B8A 1234 1000                M 	move.b	(a4,d1.w),d1
00000B8E                          M .skip_40:
00000B8E                            		_Kos_ReadBit
00000B8E D000                     M 	add.b	d0,d0
00000B90 6500                       		bcs.s	.Copy5
00000B92                            		_Kos_RunBitStream
00000B92 51CA 0000                M 	dbra	d2,.skip_42
00000B96 7407                     M 	moveq	#7,d2
00000B98 1001                     M 	move.b	d1,d0
00000B9A 4643                     M 	not.w	d3
00000B9C 6600                     M 	bne.s	.skip_42
00000B9E 1018                     M 	move.b	(a0)+,d0
00000BA0 1218                     M 	move.b	(a0)+,d1
00000BA2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BA6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BAA                          M .skip_42:
00000BAA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BAC DAC5                       		adda.w	d5,a5
00000BAE 12DD                       		move.b	(a5)+,(a1)+
00000BB0 12DD                       		move.b	(a5)+,(a1)+
00000BB2 12DD                       		move.b	(a5)+,(a1)+
00000BB4 12DD                       		move.b	(a5)+,(a1)+
00000BB6 6000 FF18                  		bra.w	.FetchNewCode
00000BBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBA                            .Copy5:
00000BBA                            		_Kos_RunBitStream
00000BBA 51CA 0000                M 	dbra	d2,.skip_43
00000BBE 7407                     M 	moveq	#7,d2
00000BC0 1001                     M 	move.b	d1,d0
00000BC2 4643                     M 	not.w	d3
00000BC4 6600                     M 	bne.s	.skip_43
00000BC6 1018                     M 	move.b	(a0)+,d0
00000BC8 1218                     M 	move.b	(a0)+,d1
00000BCA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BCE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD2                          M .skip_43:
00000BD2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD4 DAC5                       		adda.w	d5,a5
00000BD6 12DD                       		move.b	(a5)+,(a1)+
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 12DD                       		move.b	(a5)+,(a1)+
00000BE0 6000 FEEE                  		bra.w	.FetchNewCode
00000BE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE4                            .Code_01:
00000BE4 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000BE6                            		; Code 01 (Dictionary ref. long / special).
00000BE6                            		_Kos_RunBitStream
00000BE6 51CA 0000                M 	dbra	d2,.skip_44
00000BEA 7407                     M 	moveq	#7,d2
00000BEC 1001                     M 	move.b	d1,d0
00000BEE 4643                     M 	not.w	d3
00000BF0 6600                     M 	bne.s	.skip_44
00000BF2 1018                     M 	move.b	(a0)+,d0
00000BF4 1218                     M 	move.b	(a0)+,d1
00000BF6 1034 0000                M 	move.b	(a4,d0.w),d0
00000BFA 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFE                          M .skip_44:
00000BFE 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C00 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C02 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C04 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C06 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C08 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C0A 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C0C                             
00000C0C                            		; special mode (extended counter)
00000C0C 1818                       		move.b	(a0)+,d4			; Read cnt
00000C0E 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C10 5304                       		subq.b	#1,d4
00000C12 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C16                             
00000C16 DAC5                       		adda.w	d5,a5
00000C18 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C1A 3C04                       		move.w	d4,d6
00000C1C 4646                       		not.w	d6
00000C1E CC47                       		and.w	d7,d6
00000C20 DC46                       		add.w	d6,d6
00000C22 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C24 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C28                            .LargeCopy:
00000C28                            	rept (1<<_Kos_LoopUnroll)
00000C28                            		move.b	(a5)+,(a1)+
00000C28                            	endr
00000C28 12DD                     M 	move.b	(a5)+,(a1)+
00000C2A 12DD                     M 	move.b	(a5)+,(a1)+
00000C2C 12DD                     M 	move.b	(a5)+,(a1)+
00000C2E 12DD                     M 	move.b	(a5)+,(a1)+
00000C30 12DD                     M 	move.b	(a5)+,(a1)+
00000C32 12DD                     M 	move.b	(a5)+,(a1)+
00000C34 12DD                     M 	move.b	(a5)+,(a1)+
00000C36 12DD                     M 	move.b	(a5)+,(a1)+
00000C38 51CC FFEE                  		dbra	d4,.LargeCopy
00000C3C 6000 FE92                  		bra.w	.FetchNewCode
00000C40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C40                            .StreamCopy:
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C44 BF44                       		eor.w	d7,d4
00000C46 D844                       		add.w	d4,d4
00000C48 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000C4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C4C                            .MediumCopy:
00000C4C                            	rept 8
00000C4C                            		move.b	(a5)+,(a1)+
00000C4C                            	endr
00000C4C 12DD                     M 	move.b	(a5)+,(a1)+
00000C4E 12DD                     M 	move.b	(a5)+,(a1)+
00000C50 12DD                     M 	move.b	(a5)+,(a1)+
00000C52 12DD                     M 	move.b	(a5)+,(a1)+
00000C54 12DD                     M 	move.b	(a5)+,(a1)+
00000C56 12DD                     M 	move.b	(a5)+,(a1)+
00000C58 12DD                     M 	move.b	(a5)+,(a1)+
00000C5A 12DD                     M 	move.b	(a5)+,(a1)+
00000C5C 6000 FE72                  		bra.w	.FetchNewCode
00000C60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C60                            .Quit:
00000C60 4E75                       		rts
00000C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C62                            KosDec_ByteMap:
00000C62 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000C72 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000C82 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000C92 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000CA2 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000CB2 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000CC2 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000CD2 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000CE2 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000CF2 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D02 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D12 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D22 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D32 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000D42 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000D52 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; Enigma decompression (Mainly for plane mappings)
00000D62                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; PARAMETERS:
00000D62                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000D62                            ;	a0.l	- Source address
00000D62                            ;	a1.l	- Destination address
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; RETURNS:
00000D62                            ;	a1.l	- End of decompressed data address
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            EniDec:
00000D62                            		push.l d0-d7/a1-a5
00000D62 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000D66 3640                       		movea.w d0,a3				; Store base tile properties
00000D68 1018                       		move.b	(a0)+,d0
00000D6A 4880                       		ext.w	d0
00000D6C 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000D6E 1818                       		move.b	(a0)+,d4			; Store second byte
00000D70 E70C                       		lsl.b	#3,d4				; Multiply by 8
00000D72 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000D74 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000D76 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000D78 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000D7A 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000D7C E145                       		asl.w	#8,d5				; Shift up by a byte
00000D7E 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000D80 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000D82                            
00000D82                            EniDec_Loop:
00000D82 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000D84 3E06                       		move.w	d6,d7
00000D86 9E40                       		sub.w	d0,d7
00000D88 3205                       		move.w	d5,d1
00000D8A EE69                       		lsr.w	d7,d1
00000D8C 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000D90 3401                       		move.w	d1,d2
00000D92 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000D96 6400                       		bcc.s	.getnext			; If so, branch
00000D98 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000D9A E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000D9C                            
00000D9C                            .getnext:
00000D9C 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000DA0 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000DA4 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000DA6 D241                       		add.w	d1,d1
00000DA8 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000DAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DAC                            EniDec_Sub0:
00000DAC 32CA                       		move.w	a2,(a1)+			; Write to destination
00000DAE 524A                       		addq.w	#1,a2				; Increment
00000DB0 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000DB4 60CC                       		bra.s	EniDec_Loop
00000DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DB6                            EniDec_Sub4:
00000DB6 32CC                       		move.w	a4,(a1)+			; Write to destination
00000DB8 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000DBC 60C4                       		bra.s	EniDec_Loop
00000DBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DBE                            EniDec_Sub8:
00000DBE 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DC2                            
00000DC2                            .loop1:
00000DC2 32C1                       		move.w	d1,(a1)+
00000DC4 51CA FFFC                  		dbf	d2,.loop1
00000DC8 60B8                       		bra.s	EniDec_Loop
00000DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCA                            EniDec_SubA:
00000DCA 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DCE                            
00000DCE                            .loop2:
00000DCE 32C1                       		move.w	d1,(a1)+
00000DD0 5241                       		addq.w	#1,d1
00000DD2 51CA FFFA                  		dbf	d2,.loop2
00000DD6 60AA                       		bra.s	EniDec_Loop
00000DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DD8                            EniDec_SubC:
00000DD8 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DDC                            
00000DDC                            .loop3:
00000DDC 32C1                       		move.w	d1,(a1)+
00000DDE 5341                       		subq.w	#1,d1
00000DE0 51CA FFFA                  		dbf	d2,.loop3
00000DE4 609C                       		bra.s	EniDec_Loop
00000DE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DE6                            EniDec_SubE:
00000DE6 0C42 000F                  		cmpi.w	#$F,d2
00000DEA 6700                       		beq.s	EniDec_End
00000DEC                            
00000DEC                            .loop4:
00000DEC 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DF0 32C1                       		move.w	d1,(a1)+
00000DF2 51CA FFF8                  		dbf	d2,.loop4
00000DF6 608A                       		bra.s	EniDec_Loop
00000DF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DF8                            EniDec_JmpTable:
00000DF8 60B2                       		bra.s	EniDec_Sub0
00000DFA 60B0                       		bra.s	EniDec_Sub0
00000DFC 60B8                       		bra.s	EniDec_Sub4
00000DFE 60B6                       		bra.s	EniDec_Sub4
00000E00 60BC                       		bra.s	EniDec_Sub8
00000E02 60C6                       		bra.s	EniDec_SubA
00000E04 60D2                       		bra.s	EniDec_SubC
00000E06 60DE                       		bra.s	EniDec_SubE
00000E08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E08                            EniDec_End:
00000E08 5348                       		subq.w	#1,a0
00000E0A 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E0E 6600                       		bne.s	.norollback			; If not, branch
00000E10 5348                       		subq.w	#1,a0
00000E12                            
00000E12                            .norollback:
00000E12 3008                       		move.w	a0,d0
00000E14 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E16 6400                       		bcc.s	.evendest			; If not, branch
00000E18 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E1A                            
00000E1A                            .evendest:
00000E1A                            		pop.l	d0-d7/a1-a5
00000E1A 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E1E 4E75                       		rts
00000E20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E20                            EniDec_GetInlineCopyVal:
00000E20 360B                       		move.w	a3,d3				; Store base tile properties
00000E22 1204                       		move.b	d4,d1
00000E24 D201                       		add.b	d1,d1
00000E26 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E28 5346                       		subq.w	#1,d6				; Get next bit number
00000E2A 0D05                       		btst	d6,d5				; Is the bit set?
00000E2C 6700                       		beq.s	.nopriority			; If not, branch
00000E2E 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E32                            
00000E32                            .nopriority:
00000E32 D201                       		add.b	d1,d1
00000E34 6400                       		bcc.s	.nopal1				; If d4 < $40
00000E36 5346                       		subq.w	#1,d6				; Get next bit number
00000E38 0D05                       		btst	d6,d5				; Is the bit set?
00000E3A 6700                       		beq.s	.nopal1				; If not, branch
00000E3C 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000E40                            
00000E40                            .nopal1:
00000E40 D201                       		add.b	d1,d1
00000E42 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000E44 5346                       		subq.w	#1,d6				; Get next bit number
00000E46 0D05                       		btst	d6,d5				; Is the bit set?
00000E48 6700                       		beq.s	.nopal0				; If not, branch
00000E4A 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000E4E                            
00000E4E                            .nopal0:
00000E4E D201                       		add.b	d1,d1
00000E50 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000E52 5346                       		subq.w	#1,d6				; Get next bit number
00000E54 0D05                       		btst	d6,d5				; Is the bit set?
00000E56 6700                       		beq.s	.noyflip			; If not, branch
00000E58 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000E5C                            
00000E5C                            .noyflip:
00000E5C D201                       		add.b	d1,d1
00000E5E 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000E60 5346                       		subq.w	#1,d6				; Get next bit number
00000E62 0D05                       		btst	d6,d5				; Is the bit set?
00000E64 6700                       		beq.s	.noxflip			; If not, branch
00000E66 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000E6A                            
00000E6A                            .noxflip:
00000E6A 3205                       		move.w	d5,d1
00000E6C 3E06                       		move.w	d6,d7				; Get remaining bits
00000E6E 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000E70 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000E72 3C07                       		move.w	d7,d6
00000E74 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000E78 4447                       		neg.w	d7				; Calculate bit deficit
00000E7A EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000E7C 1A10                       		move.b	(a0),d5				; Get next byte
00000E7E EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000E80 DE47                       		add.w	d7,d7
00000E82 CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000E86 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000E88                            
00000E88                            .AddBits:
00000E88 300D                       		move.w	a5,d0
00000E8A D040                       		add.w	d0,d0
00000E8C C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000E90 D243                       		add.w	d3,d1				; Add base tile properties
00000E92 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000E94 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000E96 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000E98 4E75                       		rts
00000E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E9A                            .GotEnoughBits:
00000E9A 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000E9C EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000E9E 300D                       		move.w	a5,d0
00000EA0 D040                       		add.w	d0,d0
00000EA2 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EA6 D243                       		add.w	d3,d1				; Add base tile properties
00000EA8 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000EAA 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000EAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EAC                            .GotExactCount:
00000EAC 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000EAE 60D8                       		bra.s	.AddBits
00000EB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EB0                            EniDec_AndVals:
00000EB0 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000EB8 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000EC0 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000EC8 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000ED0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ED0                            EniDec_ChkGetNextByte:
00000ED0 9C40                       		sub.w	d0,d6
00000ED2 0C46 0009                  		cmpi.w	#9,d6
00000ED6 6400                       		bcc.s	.Done
00000ED8 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000EDA E145                       		asl.w	#8,d5				; Shift up by a byte
00000EDC 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000EDE                            
00000EDE                            .Done:
00000EDE 4E75                       		rts
00000EE0                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; Load a Kosinski Moduled Queue
00000EE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; PARAMETERS:
00000EE0                            ;	a3.l	- Queue pointer
00000EE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; RETURNS:
00000EE0                            ;	Nothing
00000EE0                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            LoadKosMQueue:
00000EE0 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000EE2 6B00                       		bmi.s	.End				; If it's negative, branch
00000EE4                            
00000EE4                            .Queue:
00000EE4 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000EE6 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000EE8 6100                       		bsr.s	QueueKosMData			; Queue
00000EEA 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000EEE                            
00000EEE                            .End:
00000EEE 4E75                       		rts
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; Adds a Kosinski Moduled archive to the module queue
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; PARAMETERS:
00000EF0                            ;	d2.w	- Destination in VRAM
00000EF0                            ;	a1.l	- Address of the archive
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; RETURNS:
00000EF0                            ;	Nothing
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            QueueKosMData:
00000EF0 45F8 9994                  		lea	rKosPMList.w,a2
00000EF4 4A92                       		tst.l	(a2)				; Is the first slot free?
00000EF6 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000EF8                            		
00000EF8                            .FindFreeSlot:
00000EF8 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000EFA 4A92                       		tst.l	(a2)
00000EFC 66FA                       		bne.s	.FindFreeSlot
00000EFE 24C9                       		move.l	a1,(a2)+			; Store source address
00000F00 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F02 4E75                       		rts
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; Initializes processing of the first module on the queue
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; PARAMETERS:
00000F04                            ;	Nothing
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; RETURNS:
00000F04                            ;	Nothing
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ProcessKosM_Init:
00000F04 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F06 0C43 A000                  		cmpi.w	#$A000,d3
00000F0A 6600                       		bne.s	.GotSize
00000F0C 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F10                            
00000F10                            .GotSize:
00000F10 E24B                       		lsr.w	#1,d3
00000F12 3003                       		move.w	d3,d0
00000F14 EB58                       		rol.w	#5,d0
00000F16 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F1A 11C0 9990                  		move.b	d0,rKosPMMods.w
00000F1E 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F24 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F26 5338 9990                  		subq.b	#1,rKosPMMods.w		; Otherwise decrement the number of modules
00000F2A 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F30                            
00000F30                            .GotLeftover:
00000F30 31C3 9992                  		move.w	d3,rKosPMLastSz.w
00000F34 31C2 9998                  		move.w	d2,rKosPMDest.w
00000F38 21C9 9994                  		move.l	a1,rKosPMSrc.w
00000F3C 5238 9990                  		addq.b	#1,rKosPMMods.w		; Store total number of modules
00000F40 4E75                       		rts
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; Processes the first module on the queue
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; PARAMETERS:
00000F42                            ;	Nothing
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; RETURNS:
00000F42                            ;	Nothing
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ProcessKosM:
00000F42 4A38 9990                  		tst.b	rKosPMMods.w
00000F46 6600                       		bne.s	.ModulesLeft
00000F48                            
00000F48                            .Done:
00000F48 4E75                       		rts
00000F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4A                            .ModulesLeft:
00000F4A 6B00                       		bmi.s	.DecompressionStarted
00000F4C 0C78 0004 994E             		cmpi.w	#(rKosPList_End-rKosPList)/8,rKosPCnt.w
00000F52 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000F54 2278 9994                  		movea.l	rKosPMList.w,a1
00000F58 45F8 8000                  		lea	rKosPBuf.w,a2
00000F5C 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000F60 0038 0080 9990             		ori.b	#$80,rKosPMMods.w		; And set bit to signify decompression in progress
00000F66 4E75                       		rts
00000F68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F68                            .DecompressionStarted:
00000F68 4A78 994E                  		tst.w	rKosPCnt.w
00000F6C 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000F6E                            
00000F6E                            		; Otherwise, DMA the decompressed data to VRAM
00000F6E 0238 007F 9990             		andi.b	#$7F,rKosPMMods.w
00000F74 263C 0000 0800             		move.l	#$1000/2,d3
00000F7A 5338 9990                  		subq.b	#1,rKosPMMods.w
00000F7E 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000F80 3638 9992                  		move.w	rKosPMLastSz.w,d3
00000F84                            
00000F84                            .Skip:
00000F84 3438 9998                  		move.w	rKosPMDest.w,d2
00000F88 3002                       		move.w	d2,d0
00000F8A D043                       		add.w	d3,d0
00000F8C D043                       		add.w	d3,d0
00000F8E 31C0 9998                  		move.w	d0,rKosPMDest.w		; Set new destination
00000F92 2038 9994                  		move.l	rKosPMList.w,d0
00000F96 2238 9970                  		move.l	rKosPList.w,d1
00000F9A 9081                       		sub.l	d1,d0
00000F9C 0280 0000 000F             		andi.l	#$F,d0
00000FA2 D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00000FA4 21C1 9994                  		move.l	d1,rKosPMList.w		; And set new source
00000FA8 223C FFFF 8000             		move.l	#rKosPBuf,d1
00000FAE 6100 F2D8                  		bsr.w	QueueDMATransfer
00000FB2 4A38 9990                  		tst.b	rKosPMMods.w
00000FB6 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00000FBA 41F8 9994                  		lea	rKosPMList.w,a0
00000FBE 43F8 999A                  		lea	(rKosPMList+6).w,a1
00000FC2                            	rept (rKosPMList_End-rKosPMList)/6-1
00000FC2                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
00000FC2                            		move.w	(a1)+,(a0)+
00000FC2                            	endr
00000FC2 20D9                     M 	move.l	(a1)+,(a0)+
00000FC4 30D9                     M 	move.w	(a1)+,(a0)+
00000FC6 20D9                     M 	move.l	(a1)+,(a0)+
00000FC8 30D9                     M 	move.w	(a1)+,(a0)+
00000FCA 20D9                     M 	move.l	(a1)+,(a0)+
00000FCC 30D9                     M 	move.w	(a1)+,(a0)+
00000FCE 20D9                     M 	move.l	(a1)+,(a0)+
00000FD0 30D9                     M 	move.w	(a1)+,(a0)+
00000FD2 20D9                     M 	move.l	(a1)+,(a0)+
00000FD4 30D9                     M 	move.w	(a1)+,(a0)+
00000FD6 20D9                     M 	move.l	(a1)+,(a0)+
00000FD8 30D9                     M 	move.w	(a1)+,(a0)+
00000FDA 20D9                     M 	move.l	(a1)+,(a0)+
00000FDC 30D9                     M 	move.w	(a1)+,(a0)+
00000FDE 20D9                     M 	move.l	(a1)+,(a0)+
00000FE0 30D9                     M 	move.w	(a1)+,(a0)+
00000FE2 20D9                     M 	move.l	(a1)+,(a0)+
00000FE4 30D9                     M 	move.w	(a1)+,(a0)+
00000FE6 20D9                     M 	move.l	(a1)+,(a0)+
00000FE8 30D9                     M 	move.w	(a1)+,(a0)+
00000FEA 20D9                     M 	move.l	(a1)+,(a0)+
00000FEC 30D9                     M 	move.w	(a1)+,(a0)+
00000FEE 20D9                     M 	move.l	(a1)+,(a0)+
00000FF0 30D9                     M 	move.w	(a1)+,(a0)+
00000FF2 20D9                     M 	move.l	(a1)+,(a0)+
00000FF4 30D9                     M 	move.w	(a1)+,(a0)+
00000FF6 20D9                     M 	move.l	(a1)+,(a0)+
00000FF8 30D9                     M 	move.w	(a1)+,(a0)+
00000FFA 20D9                     M 	move.l	(a1)+,(a0)+
00000FFC 30D9                     M 	move.w	(a1)+,(a0)+
00000FFE 20D9                     M 	move.l	(a1)+,(a0)+
00001000 30D9                     M 	move.w	(a1)+,(a0)+
00001002 20D9                     M 	move.l	(a1)+,(a0)+
00001004 30D9                     M 	move.w	(a1)+,(a0)+
00001006 20D9                     M 	move.l	(a1)+,(a0)+
00001008 30D9                     M 	move.w	(a1)+,(a0)+
0000100A 20D9                     M 	move.l	(a1)+,(a0)+
0000100C 30D9                     M 	move.w	(a1)+,(a0)+
0000100E 20D9                     M 	move.l	(a1)+,(a0)+
00001010 30D9                     M 	move.w	(a1)+,(a0)+
00001012 20D9                     M 	move.l	(a1)+,(a0)+
00001014 30D9                     M 	move.w	(a1)+,(a0)+
00001016 20D9                     M 	move.l	(a1)+,(a0)+
00001018 30D9                     M 	move.w	(a1)+,(a0)+
0000101A 20D9                     M 	move.l	(a1)+,(a0)+
0000101C 30D9                     M 	move.w	(a1)+,(a0)+
0000101E 20D9                     M 	move.l	(a1)+,(a0)+
00001020 30D9                     M 	move.w	(a1)+,(a0)+
00001022 20D9                     M 	move.l	(a1)+,(a0)+
00001024 30D9                     M 	move.w	(a1)+,(a0)+
00001026 20D9                     M 	move.l	(a1)+,(a0)+
00001028 30D9                     M 	move.w	(a1)+,(a0)+
0000102A 20D9                     M 	move.l	(a1)+,(a0)+
0000102C 30D9                     M 	move.w	(a1)+,(a0)+
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 4298                       		clr.l	(a0)+				; And mark the last slot as free
00001040 4258                       		clr.w	(a0)+
00001042 2038 9994                  		move.l	rKosPMList.w,d0
00001046 6700                       		beq.s	.Exit				; Return if the queue is now empty
00001048 2240                       		movea.l	d0,a1
0000104A 3438 9998                  		move.w	rKosPMDest.w,d2
0000104E 6000 FEB4                  		bra.w	ProcessKosM_Init
00001052                            
00001052                            .Exit:
00001052 4E75                       		rts
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; Adds Kosinski-compressed data to the decompression queue
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; PARAMETERS:
00001054                            ;	a1.l	- Compressed data address
00001054                            ;	a2.l	- Decompression destination in RAM
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; RETURNS:
00001054                            ;	Nothing
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            QueueKosData:
00001054 3038 994E                  		move.w	rKosPCnt.w,d0
00001058 E748                       		lsl.w	#3,d0
0000105A 47F8 9970                  		lea	rKosPList.w,a3
0000105E 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
00001062 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
00001066 5278 994E                  		addq.w	#1,rKosPCnt.w
0000106A 4E75                       		rts
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; PARAMETERS:
0000106C                            ;	Nothing
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; RETURNS:
0000106C                            ;	Nothing
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            SetKosBookmark:
0000106C 4A78 994E                  		tst.w	rKosPCnt.w
00001070 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
00001072 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
00001076 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
0000107C 6500                       		bcs.s	.Done
0000107E 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
00001084 6400                       		bcc.s	.Done
00001086 21EF 0042 996C             		move.l	$42(sp),rKosPBookmark.w
0000108C 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001094                            
00001094                            .Done:
00001094 4E75                       		rts
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; Processes the first entry in the Kosinski decompression queue
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; PARAMETERS:
00001096                            ;	Nothing
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; RETURNS:
00001096                            ;	Nothing
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ProcessKos:
00001096 4A78 994E                  		tst.w	rKosPCnt.w
0000109A 6700 0000                  		beq.w	ProcessKos_Done
0000109E 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
000010A2                            
000010A2                            ProcessKos_Main:
000010A2 0078 8000 994E             		ori.w	#$8000,rKosPCnt.w	; Set sign bit to signify decompression in progress
000010A8 2078 9970                  		movea.l	rKosPList.w,a0
000010AC 2278 9974                  		movea.l	rKosPDest.w,a1
000010B0                            		
000010B0                            		; What follows is identical to the normal Kosinski decompressor
000010B0 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
000010B2 7000                       		moveq	#0,d0
000010B4 7200                       		moveq	#0,d1
000010B6 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
000010BA 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
000010BC 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
000010BE 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
000010C2 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
000010C6 7407                       		moveq	#7,d2				; Set repeat count to 8.
000010C8 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
000010CA 6000                       		bra.s	.FetchNewCode
000010CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010CC                            .FetchCodeLoop:
000010CC                            		; Code 1 (Uncompressed byte).
000010CC                            		_Kos_RunBitStream
000010CC 51CA 0000                M 	dbra	d2,.skip_47
000010D0 7407                     M 	moveq	#7,d2
000010D2 1001                     M 	move.b	d1,d0
000010D4 4643                     M 	not.w	d3
000010D6 6600                     M 	bne.s	.skip_47
000010D8 1018                     M 	move.b	(a0)+,d0
000010DA 1218                     M 	move.b	(a0)+,d1
000010DC 1034 0000                M 	move.b	(a4,d0.w),d0
000010E0 1234 1000                M 	move.b	(a4,d1.w),d1
000010E4                          M .skip_47:
000010E4 12D8                       		move.b	(a0)+,(a1)+
000010E6                            
000010E6                            .FetchNewCode:
000010E6                            		_Kos_ReadBit
000010E6 D000                     M 	add.b	d0,d0
000010E8 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
000010EA                            
000010EA                            		; Codes 00 and 01.
000010EA 7AFF                       		moveq	#-1,d5
000010EC 4BD1                       		lea	(a1),a5
000010EE                            		_Kos_RunBitStream
000010EE 51CA 0000                M 	dbra	d2,.skip_49
000010F2 7407                     M 	moveq	#7,d2
000010F4 1001                     M 	move.b	d1,d0
000010F6 4643                     M 	not.w	d3
000010F8 6600                     M 	bne.s	.skip_49
000010FA 1018                     M 	move.b	(a0)+,d0
000010FC 1218                     M 	move.b	(a0)+,d1
000010FE 1034 0000                M 	move.b	(a4,d0.w),d0
00001102 1234 1000                M 	move.b	(a4,d1.w),d1
00001106                          M .skip_49:
00001106                            		_Kos_ReadBit
00001106 D000                     M 	add.b	d0,d0
00001108 6500 0000                  		bcs.w	.Code_01
0000110C                            
0000110C                            		; Code 00 (Dictionary ref. short).
0000110C                            		_Kos_RunBitStream
0000110C 51CA 0000                M 	dbra	d2,.skip_51
00001110 7407                     M 	moveq	#7,d2
00001112 1001                     M 	move.b	d1,d0
00001114 4643                     M 	not.w	d3
00001116 6600                     M 	bne.s	.skip_51
00001118 1018                     M 	move.b	(a0)+,d0
0000111A 1218                     M 	move.b	(a0)+,d1
0000111C 1034 0000                M 	move.b	(a4,d0.w),d0
00001120 1234 1000                M 	move.b	(a4,d1.w),d1
00001124                          M .skip_51:
00001124                            		_Kos_ReadBit
00001124 D000                     M 	add.b	d0,d0
00001126 6500                       		bcs.s	.Copy45
00001128                            		_Kos_RunBitStream
00001128 51CA 0000                M 	dbra	d2,.skip_53
0000112C 7407                     M 	moveq	#7,d2
0000112E 1001                     M 	move.b	d1,d0
00001130 4643                     M 	not.w	d3
00001132 6600                     M 	bne.s	.skip_53
00001134 1018                     M 	move.b	(a0)+,d0
00001136 1218                     M 	move.b	(a0)+,d1
00001138 1034 0000                M 	move.b	(a4,d0.w),d0
0000113C 1234 1000                M 	move.b	(a4,d1.w),d1
00001140                          M .skip_53:
00001140                            		_Kos_ReadBit
00001140 D000                     M 	add.b	d0,d0
00001142 6500                       		bcs.s	.Copy3
00001144                            		_Kos_RunBitStream
00001144 51CA 0000                M 	dbra	d2,.skip_55
00001148 7407                     M 	moveq	#7,d2
0000114A 1001                     M 	move.b	d1,d0
0000114C 4643                     M 	not.w	d3
0000114E 6600                     M 	bne.s	.skip_55
00001150 1018                     M 	move.b	(a0)+,d0
00001152 1218                     M 	move.b	(a0)+,d1
00001154 1034 0000                M 	move.b	(a4,d0.w),d0
00001158 1234 1000                M 	move.b	(a4,d1.w),d1
0000115C                          M .skip_55:
0000115C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000115E DAC5                       		adda.w	d5,a5
00001160 12DD                       		move.b	(a5)+,(a1)+
00001162 12DD                       		move.b	(a5)+,(a1)+
00001164 6080                       		bra.s	.FetchNewCode
00001166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001166                            .Copy3:
00001166                            		_Kos_RunBitStream
00001166 51CA 0000                M 	dbra	d2,.skip_56
0000116A 7407                     M 	moveq	#7,d2
0000116C 1001                     M 	move.b	d1,d0
0000116E 4643                     M 	not.w	d3
00001170 6600                     M 	bne.s	.skip_56
00001172 1018                     M 	move.b	(a0)+,d0
00001174 1218                     M 	move.b	(a0)+,d1
00001176 1034 0000                M 	move.b	(a4,d0.w),d0
0000117A 1234 1000                M 	move.b	(a4,d1.w),d1
0000117E                          M .skip_56:
0000117E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001180 DAC5                       		adda.w	d5,a5
00001182 12DD                       		move.b	(a5)+,(a1)+
00001184 12DD                       		move.b	(a5)+,(a1)+
00001186 12DD                       		move.b	(a5)+,(a1)+
00001188 6000 FF5C                  		bra.w	.FetchNewCode
0000118C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000118C                            .Copy45:
0000118C                            		_Kos_RunBitStream
0000118C 51CA 0000                M 	dbra	d2,.skip_57
00001190 7407                     M 	moveq	#7,d2
00001192 1001                     M 	move.b	d1,d0
00001194 4643                     M 	not.w	d3
00001196 6600                     M 	bne.s	.skip_57
00001198 1018                     M 	move.b	(a0)+,d0
0000119A 1218                     M 	move.b	(a0)+,d1
0000119C 1034 0000                M 	move.b	(a4,d0.w),d0
000011A0 1234 1000                M 	move.b	(a4,d1.w),d1
000011A4                          M .skip_57:
000011A4                            		_Kos_ReadBit
000011A4 D000                     M 	add.b	d0,d0
000011A6 6500                       		bcs.s	.Copy5
000011A8                            		_Kos_RunBitStream
000011A8 51CA 0000                M 	dbra	d2,.skip_59
000011AC 7407                     M 	moveq	#7,d2
000011AE 1001                     M 	move.b	d1,d0
000011B0 4643                     M 	not.w	d3
000011B2 6600                     M 	bne.s	.skip_59
000011B4 1018                     M 	move.b	(a0)+,d0
000011B6 1218                     M 	move.b	(a0)+,d1
000011B8 1034 0000                M 	move.b	(a4,d0.w),d0
000011BC 1234 1000                M 	move.b	(a4,d1.w),d1
000011C0                          M .skip_59:
000011C0 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011C2 DAC5                       		adda.w	d5,a5
000011C4 12DD                       		move.b	(a5)+,(a1)+
000011C6 12DD                       		move.b	(a5)+,(a1)+
000011C8 12DD                       		move.b	(a5)+,(a1)+
000011CA 12DD                       		move.b	(a5)+,(a1)+
000011CC 6000 FF18                  		bra.w	.FetchNewCode
000011D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D0                            .Copy5:
000011D0                            		_Kos_RunBitStream
000011D0 51CA 0000                M 	dbra	d2,.skip_60
000011D4 7407                     M 	moveq	#7,d2
000011D6 1001                     M 	move.b	d1,d0
000011D8 4643                     M 	not.w	d3
000011DA 6600                     M 	bne.s	.skip_60
000011DC 1018                     M 	move.b	(a0)+,d0
000011DE 1218                     M 	move.b	(a0)+,d1
000011E0 1034 0000                M 	move.b	(a4,d0.w),d0
000011E4 1234 1000                M 	move.b	(a4,d1.w),d1
000011E8                          M .skip_60:
000011E8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EA DAC5                       		adda.w	d5,a5
000011EC 12DD                       		move.b	(a5)+,(a1)+
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 12DD                       		move.b	(a5)+,(a1)+
000011F6 6000 FEEE                  		bra.w	.FetchNewCode
000011FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011FA                            .Code_01:
000011FA 7800                       		moveq	#0,d4				; d4 will contain copy count.
000011FC                            		; Code 01 (Dictionary ref. long / special).
000011FC                            		_Kos_RunBitStream
000011FC 51CA 0000                M 	dbra	d2,.skip_61
00001200 7407                     M 	moveq	#7,d2
00001202 1001                     M 	move.b	d1,d0
00001204 4643                     M 	not.w	d3
00001206 6600                     M 	bne.s	.skip_61
00001208 1018                     M 	move.b	(a0)+,d0
0000120A 1218                     M 	move.b	(a0)+,d1
0000120C 1034 0000                M 	move.b	(a4,d0.w),d0
00001210 1234 1000                M 	move.b	(a4,d1.w),d1
00001214                          M .skip_61:
00001214 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001216 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001218 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
0000121A EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
0000121C 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000121E C847                       		and.w	d7,d4				; d4 = %00000CCC.
00001220 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00001222                            
00001222                            		; special mode (extended counter)
00001222 1818                       		move.b	(a0)+,d4			; Read cnt
00001224 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001226 5304                       		subq.b	#1,d4
00001228 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
0000122C                            
0000122C DAC5                       		adda.w	d5,a5
0000122E 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00001230 3C04                       		move.w	d4,d6
00001232 4646                       		not.w	d6
00001234 CC47                       		and.w	d7,d6
00001236 DC46                       		add.w	d6,d6
00001238 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
0000123A 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
0000123E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123E                            .LargeCopy:
0000123E                            	rept (1<<_Kos_LoopUnroll)
0000123E                            		move.b	(a5)+,(a1)+
0000123E                            	endr
0000123E 12DD                     M 	move.b	(a5)+,(a1)+
00001240 12DD                     M 	move.b	(a5)+,(a1)+
00001242 12DD                     M 	move.b	(a5)+,(a1)+
00001244 12DD                     M 	move.b	(a5)+,(a1)+
00001246 12DD                     M 	move.b	(a5)+,(a1)+
00001248 12DD                     M 	move.b	(a5)+,(a1)+
0000124A 12DD                     M 	move.b	(a5)+,(a1)+
0000124C 12DD                     M 	move.b	(a5)+,(a1)+
0000124E 51CC FFEE                  		dbra	d4,.LargeCopy
00001252 6000 FE92                  		bra.w	.FetchNewCode
00001256                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001256                            .StreamCopy:
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000125A BF44                       		eor.w	d7,d4
0000125C D844                       		add.w	d4,d4
0000125E 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00001262                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001262                            .MediumCopy:
00001262                            	rept 8
00001262                            		move.b	(a5)+,(a1)+
00001262                            	endr
00001262 12DD                     M 	move.b	(a5)+,(a1)+
00001264 12DD                     M 	move.b	(a5)+,(a1)+
00001266 12DD                     M 	move.b	(a5)+,(a1)+
00001268 12DD                     M 	move.b	(a5)+,(a1)+
0000126A 12DD                     M 	move.b	(a5)+,(a1)+
0000126C 12DD                     M 	move.b	(a5)+,(a1)+
0000126E 12DD                     M 	move.b	(a5)+,(a1)+
00001270 12DD                     M 	move.b	(a5)+,(a1)+
00001272 6000 FE72                  		bra.w	.FetchNewCode
00001276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001276                            .Quit:	
00001276 21C8 9970                  		move.l	a0,rKosPList.w
0000127A 21C9 9974                  		move.l	a1,rKosPDest.w
0000127E 0278 7FFF 994E             		andi.w	#$7FFF,rKosPCnt.w		; Clear decompression in progress bit
00001284 5378 994E                  		subq.w	#1,rKosPCnt.w
00001288 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
0000128A 41F8 9970                  		lea	rKosPList.w,a0
0000128E 43F8 9978                  		lea	(rKosPList+8).w,a1		; Otherwise, shift all entries up
00001292                            	rept (rKosPList_End-rKosPList)/8-1
00001292                            		move.l	(a1)+,(a0)+
00001292                            		move.l	(a1)+,(a0)+
00001292                            	endr
00001292 20D9                     M 	move.l	(a1)+,(a0)+
00001294 20D9                     M 	move.l	(a1)+,(a0)+
00001296 20D9                     M 	move.l	(a1)+,(a0)+
00001298 20D9                     M 	move.l	(a1)+,(a0)+
0000129A 20D9                     M 	move.l	(a1)+,(a0)+
0000129C 20D9                     M 	move.l	(a1)+,(a0)+
0000129E                            
0000129E                            ProcessKos_Done:
0000129E 4E75                       		rts
000012A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012A0                            RestoreKosBookmark:
000012A0 4CB8 007F 9950             		movem.w	rKosPRegs.w,d0-d6
000012A6 4CF8 2300 995E             		movem.l	(rKosPRegs+2*7).w,a0-a1/a5
000012AC 2F38 996C                  		move.l	rKosPBookmark.w,-(sp)
000012B0 3F38 996A                  		move.w	rKosPSR.w,-(sp)
000012B4 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
000012B6 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
000012BA 4E73                       		rte
000012BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BC                            BackupKosRegs:
000012BC 40F8 996A                  		move	sr,rKosPSR.w
000012C0 48B8 007F 9950             		movem.w	d0-d6,rKosPRegs.w
000012C6 48F8 2300 995E             		movem.l	a0-a1/a5,(rKosPRegs+2*7).w
000012CC 4E75                       		rts
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; Load Kosinski compressed art into VRAM
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; PARAMETERS:
000012CE                            ;	a0.l	- Source address
000012CE                            ;	a1.l	- Destination address
000012CE                            ;	a2.w	- VRAM address
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; RETURNS:
000012CE                            ;	Nothing
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            LoadKosArt:
000012CE 2649                       		movea.l	a1,a3				; Save destination address
000012D0 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
000012D4                            
000012D4 93CB                       		suba.l	a3,a1				; Get size of decompressed art
000012D6 3609                       		move.w	a1,d3				; ''
000012D8 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
000012DA 220B                       		move.l	a3,d1				; Use destination address for DMA source
000012DC 340A                       		move.w	a2,d2				; Get destination VRAM address
000012DE 6000 EFA8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
000012E2                            ; =========================================================================================================================================================
000012E2                            		include	"_LIB_/Math.asm"		; Math functions
000012E2                            ; =========================================================================================================================================================
000012E2                            ; Mighty The Armadillo in PRISM PARADISE
000012E2                            ; By Nat The Porcupine 2021
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; Math functions
000012E2                            ; =========================================================================================================================================================
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; Get a pseudo random number
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; PARAMETERS:
000012E2                            ;	Nothing
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; RETURNS:
000012E2                            ;	d0.l	- Random number
000012E2                            ;	d1.l	- New seed
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            RandomNumber:
000012E2 2238 C760                  		move.l	rRNGSeed.w,d1			; Get seed
000012E6 6600                       		bne.s	.Generate			; If it's already initialized, branch
000012E8 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
000012EE                            
000012EE                            .Generate:
000012EE 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
000012F0 E581                       		asl.l	#2,d1				; ''
000012F2 D280                       		add.l	d0,d1				; ''
000012F4 E781                       		asl.l	#3,d1				; ''
000012F6 D280                       		add.l	d0,d1				; ''
000012F8 3001                       		move.w	d1,d0				; ''
000012FA 4841                       		swap	d1				; ''
000012FC D041                       		add.w	d1,d0				; ''
000012FE 3200                       		move.w	d0,d1				; ''
00001300 4841                       		swap	d1				; ''
00001302 21C1 C760                  		move.l	d1,rRNGSeed.w			; Set new seed
00001306 4E75                       		rts
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; Calculate the sine and cosine of an angle
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; PARAMETERS:
00001308                            ;	d0.b	- Angle
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; RETURNS:
00001308                            ;	d0.w	- Sine value
00001308                            ;	d1.w	- Cosine value	
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            CalcSine:
00001308 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
0000130C 5040                       		addq.w	#8,d0				; Turn into offset
0000130E D040                       		add.w	d0,d0				; ''
00001310 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001314 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001318 4E75                       		rts
0000131A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000131A                            SineTable:
0000131A 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000133A 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000135A 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
0000137A 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
0000139A 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000013BA 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000013DA 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000013FA 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
0000141A 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
0000143A FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
0000145A FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
0000147A FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
0000149A FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000014BA FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000014DA FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000014FA FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
0000151A 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000153A 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000155A 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
0000157A 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
0000159A 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000015BA 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000015DA 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000015FA 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
0000161A 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
0000163A FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
0000165A FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
0000167A FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
0000169A FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000016BA FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000016DA FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000016FA FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; Calculate the arctangent of y/x
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; PARAMETERS:
0000171A                            ;	d1.w	- X position
0000171A                            ;	d2.w	- Y position
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; RETURNS:
0000171A                            ;	d0.w	- The angle
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            CalcArcTan:
0000171A                            		push.l	d3-d4
0000171A 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000171E 7600                       		moveq	#0,d3
00001720 7800                       		moveq	#0,d4
00001722 3601                       		move.w	d1,d3
00001724 3802                       		move.w	d2,d4
00001726 8843                       		or.w	d3,d4
00001728 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
0000172A 3802                       		move.w	d2,d4
0000172C                            		
0000172C 4A43                       		tst.w	d3
0000172E 6A00                       		bpl.s	.NotNeg
00001730 4443                       		neg.w	d3
00001732                            
00001732                            .NotNeg:
00001732 4A44                       		tst.w	d4
00001734 6A00                       		bpl.s	.NotNeg2
00001736 4444                       		neg.w	d4
00001738                            
00001738                            .NotNeg2:
00001738 B843                       		cmp.w	d3,d4
0000173A 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
0000173C E18C                       		lsl.l	#8,d4
0000173E 88C3                       		divu.w	d3,d4
00001740 7000                       		moveq	#0,d0
00001742 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
00001746 6000                       		bra.s	.Skip
00001748                            
00001748                            .NotGreater:
00001748 E18B                       		lsl.l	#8,d3
0000174A 86C4                       		divu.w	d4,d3
0000174C 7040                       		moveq	#$40,d0
0000174E 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
00001752                            
00001752                            .Skip:
00001752 4A41                       		tst.w	d1
00001754 6A00                       		bpl.s	.Skip2
00001756 4440                       		neg.w	d0
00001758 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
0000175C                            
0000175C                            .Skip2:
0000175C 4A42                       		tst.w	d2
0000175E 6A00                       		bpl.s	.Skip3
00001760 4440                       		neg.w	d0
00001762 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
00001766                            
00001766                            .Skip3:
00001766                            		pop.l	d3-d4
00001766 4CDF 0018                M 	movem.l	(sp)+,d3-d4
0000176A 4E75                       		rts
0000176C                            
0000176C                            GetArcTan_Zero:
0000176C 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
00001770                            		pop.l	d3-d4
00001770 4CDF 0018                M 	movem.l	(sp)+,d3-d4
00001774 4E75                       		rts
00001776                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001776                            ArcTanTable:
00001776 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
0000177C 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
00001782 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
00001788 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
0000178E 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001794 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
0000179A 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
000017A0 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
000017A6 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
000017AC 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
000017B2 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
000017B8 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
000017BE 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
000017C4 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
000017CA 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
000017D0 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
000017D6 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
000017DC 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
000017E2 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
000017E8 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
000017EE 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
000017F4 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
000017FA 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
00001800 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001806 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
0000180C 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
00001812 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001818 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000181E 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001824 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
0000182A 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
00001830 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
00001836 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
0000183C 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
00001842 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
00001848 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
0000184E 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
00001854 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
0000185A 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
00001860 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
00001866 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
0000186C 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
00001872 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
00001878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001878                            ; Initialize oscillation
00001878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001878                            InitOscillation:
00001878 43F8 C76A                  		lea	rOscNums.w,a1
0000187C 45FA 0000                  		lea	OscInitData(pc),a2
00001880 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
00001882                            
00001882                            .LoadData:
00001882 32DA                       		move.w	(a2)+,(a1)+
00001884 51C9 FFFC                  		dbf	d1,.LoadData
00001888 4E75                       		rts
0000188A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000188A                            OscInitData:
0000188A 007D                       		dc.w	%0000000001111101
0000188C 0080 0000                  		dc.w	$0080, $0000
00001890 0080 0000                  		dc.w	$0080, $0000
00001894 0080 0000                  		dc.w	$0080, $0000
00001898 0080 0000                  		dc.w	$0080, $0000
0000189C 0080 0000                  		dc.w	$0080, $0000
000018A0 0080 0000                  		dc.w	$0080, $0000
000018A4 0080 0000                  		dc.w	$0080, $0000
000018A8 0080 0000                  		dc.w	$0080, $0000
000018AC 0080 0000                  		dc.w	$0080, $0000
000018B0 3848 00EE                  		dc.w	$3848, $00EE
000018B4 2080 00B4                  		dc.w	$2080, $00B4
000018B8 3080 010E                  		dc.w	$3080, $010E
000018BC 5080 01C2                  		dc.w	$5080, $01C2
000018C0 7080 0276                  		dc.w	$7080, $0276
000018C4 0080 0000                  		dc.w	$0080, $0000
000018C8 4000 00FE                  		dc.w	$4000, $00FE
000018CC                            OscInitData_End:
000018CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018CC                            ; Update oscillation
000018CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018CC                            UpdateOscillation:
000018CC 43F8 C76A                  		lea	rOscNums.w,a1
000018D0 45FA 0000                  		lea	OscUpdateData(pc),a2
000018D4 3619                       		move.w	(a1)+,d3
000018D6 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
000018D8                            
000018D8                            .OscLoop:
000018D8 341A                       		move.w	(a2)+,d2
000018DA 381A                       		move.w	(a2)+,d4
000018DC 0303                       		btst	d1,d3
000018DE 6600                       		bne.s	.Sub
000018E0 3029 0002                  		move.w	2(a1),d0
000018E4 D042                       		add.w	d2,d0
000018E6 3340 0002                  		move.w	d0,2(a1)
000018EA D151                       		add.w	d0,(a1)
000018EC B811                       		cmp.b	(a1),d4
000018EE 6200                       		bhi.s	.DoLoop
000018F0 03C3                       		bset	d1,d3
000018F2 6000                       		bra.s	.DoLoop
000018F4                            
000018F4                            .Sub:
000018F4 3029 0002                  		move.w	2(a1),d0
000018F8 9042                       		sub.w	d2,d0
000018FA 3340 0002                  		move.w	d0,2(a1)
000018FE D151                       		add.w	d0,(a1)
00001900 B811                       		cmp.b	(a1),d4
00001902 6300                       		bls.s	.DoLoop
00001904 0383                       		bclr	d1,d3
00001906                            
00001906                            .DoLoop:
00001906 5849                       		addq.w	#4,a1
00001908 51C9 FFCE                  		dbf	d1,.OscLoop
0000190C                            
0000190C 31C3 C76A                  		move.w	d3,rOscCtrl.w
00001910                            
00001910                            .End:
00001910 4E75                       		rts
00001912                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001912                            OscUpdateData:
00001912 0002 0010                  		dc.w	$02, $10
00001916 0002 0018                  		dc.w	$02, $18
0000191A 0002 0020                  		dc.w	$02, $20
0000191E 0002 0030                  		dc.w	$02, $30
00001922 0004 0020                  		dc.w	$04, $20
00001926 0008 0008                  		dc.w	$08, $08
0000192A 0008 0040                  		dc.w	$08, $40
0000192E 0004 0040                  		dc.w	$04, $40
00001932 0002 0038                  		dc.w	$02, $38
00001936 0002 0038                  		dc.w	$02, $38
0000193A 0002 0020                  		dc.w	$02, $20
0000193E 0003 0030                  		dc.w	$03, $30
00001942 0005 0050                  		dc.w	$05, $50
00001946 0007 0070                  		dc.w	$07, $70
0000194A 0002 0040                  		dc.w	$02, $40
0000194E 0002 0040                  		dc.w	$02, $40
00001952                            OscUpdateData_End:
00001952                            ; =========================================================================================================================================================
00001952                            		include	"_LIB_/Object.asm"		; Object functions
00001952                            ; =========================================================================================================================================================
00001952                            ; Mighty The Armadillo in PRISM PARADISE
00001952                            ; By Nat The Porcupine 2021
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; Object functions
00001952                            ; =========================================================================================================================================================
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; Initialize object lists
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; PARAMETERS:
00001952                            ;	Nothing
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; RETURNS:
00001952                            ;	Nothing
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            InitObjectList:
00001952                            		clrRAM	rRespawns			; Clear object respawn table
00001952                          M 	local	endaddr
00001952                          M endaddr	equs	"rrespawns_End"
00001952 7000                     M 	moveq	#0,d0
00001954 43F8 BE9E                M 	lea	(rrespawns).w,a1
00001958 323C 00BF                M 	move.w	#(((rrespawns_end)-(rrespawns))-((rrespawns)&1))>>2-1,d1
0000195C 22C0                     M .clear_65:	move.l	d0,(a1)+
0000195E 51C9 FFFC                M 	dbf	d1,.clear_65
00001962                            
00001962                            	; setup tail object
00001962 31FC BE54 BE58             		move.w	#rTailAddr,rTailNext.w		; set the first object as the tail object
00001968 31FC BE54 BE5A             		move.w	#rTailAddr,rTailPrev.w		; set the last object as the tail object
0000196E 21FC 0000 0000 BE54        		move.l	#.rts,rTailAddr.w		; set the next rts as the tail object pointer
00001976                            
00001976                            	; setup free object list
00001976 41F8 9A54                  		lea	rObjects.w,a0			; load the objects list into a0
0000197A 31C8 BE5C                  		move.w	a0,rFreeHead.w			; set the first object as the first free object
0000197E 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
00001980 7260                       		moveq	#oSize,d1			; load object size to d1
00001982                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001982                            
00001982                            .load
00001982 D0C1                       		add.w	d1,a0				; go to the next object now
00001984 3148 FFA6                  		move.w	a0,oPrev-oSize(a0)		; save new previous pointer
00001988 42A8 0008                  		clr.l	oDrawNext(a0)			; clear the display link values
0000198C 51C8 FFF4                  		dbf	d0,.load			; loop for every object
00001990                            
00001990 4268 0006                  		clr.w	oPrev(a0)			; set the last previous pointer to 0
00001994                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001994                            
00001994                            	; reset display table
00001994 43F8 BE56                  		lea	rDispInput-dNext.w,a1		; get display table address to a1
00001998 7207                       		moveq	#8-1,d1				; loop for all the layers
0000199A                            
0000199A                            .dsp
0000199A 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
0000199E 5849                       		addq.w	#dNext,a1			; advance to the actual address
000019A0 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
000019A4                            
000019A4 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
000019A8 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
000019AA 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
000019AE                            
000019AE                            .rts
000019AE 4E75                       		rts
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; Find the first free object space available
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; PARAMETERS:
000019B0                            ;	Nothing
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; RETURNS:
000019B0                            ;	a1.l	- Pointer to the SST space in the free object space
000019B0                            ;	a2.l	- Trashed
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            FindFreeObj:
000019B0 3038 BE5C                  		move.w	rFreeHead.w,d0			; get pointer to the next free object
000019B4 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
000019B6 3240                       		movea.w	d0,a1				; load to a1
000019B8 31E9 0006 BE5C             		move.w	oPrev(a1),rFreeHead.w		; copy the next free object pointer to list start
000019BE                            ; --------------------------------------------------------------
000019BE                            
000019BE                            	; clear object memory
000019BE 45E9 000A                  		lea	oDrawPrev(a1),a2		; load the first byte to clear to a2
000019C2 425A                       		clr.w	(a2)+				; clear a word of data
000019C4                            
000019C4                            	rept (oSize-oDrawPrev) / 4			; repeat for every object property
000019C4                            		clr.l	(a2)+				; clear a longword of data
000019C4                            	endr
000019C4 429A                     M 	clr.l	(a2)+
000019C6 429A                     M 	clr.l	(a2)+
000019C8 429A                     M 	clr.l	(a2)+
000019CA 429A                     M 	clr.l	(a2)+
000019CC 429A                     M 	clr.l	(a2)+
000019CE 429A                     M 	clr.l	(a2)+
000019D0 429A                     M 	clr.l	(a2)+
000019D2 429A                     M 	clr.l	(a2)+
000019D4 429A                     M 	clr.l	(a2)+
000019D6 429A                     M 	clr.l	(a2)+
000019D8 429A                     M 	clr.l	(a2)+
000019DA 429A                     M 	clr.l	(a2)+
000019DC 429A                     M 	clr.l	(a2)+
000019DE 429A                     M 	clr.l	(a2)+
000019E0 429A                     M 	clr.l	(a2)+
000019E2 429A                     M 	clr.l	(a2)+
000019E4 429A                     M 	clr.l	(a2)+
000019E6 429A                     M 	clr.l	(a2)+
000019E8 429A                     M 	clr.l	(a2)+
000019EA 429A                     M 	clr.l	(a2)+
000019EC 429A                     M 	clr.l	(a2)+
000019EE                            ; --------------------------------------------------------------
000019EE                            
000019EE 3478 BE5A                  		move.w	rTailPrev.w,a2			; load last object to a2
000019F2 31C9 BE5A                  		move.w	a1,rTailPrev.w			; save as the new last object
000019F6 336A 0004 0004             		move.w	oNext(a2),oNext(a1)		; copy the next pointer from old tail to new object
000019FC 3549 0004                  		move.w	a1,oNext(a2)			; save new object as next pointer for old tail
00001A00 334A 0006                  		move.w	a2,oPrev(a1)			; save old tail as prev pointer for new object
00001A04                            
00001A04                            .rts:
00001A04 4E75                       		rts
00001A06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A06                            ; Delete the current object
00001A06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A06                            ; PARAMETERS:
00001A06                            ;	Nothing
00001A06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A06                            ; RETURNS:
00001A06                            ;	a1.l	- Trashed
00001A06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A06                            DeleteObject:
00001A06                            	removeSprite	a0, a1, 1			; remove object display
00001A06 4A68 0008                M 	tst.w	odrawnext(a0)
00001A0A 6700                     M 	beq.s	.yes_66
00001A0C 3268 000A                M 	move.w	odrawprev(a0),a1
00001A10 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00001A16 3268 0008                M 	move.w	odrawnext(a0),a1
00001A1A 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00001A20                          M .no_66
00001A20 42A8 0008                M 	clr.l	odrawnext(a0)
00001A24                          M .yes_66
00001A24 3268 0006                  		move.w	oPrev(a0),a1			; copy previous pointer to a1
00001A28 3368 0004 0004             		move.w	oNext(a0),oNext(a1)		; copy next pointer to previous object
00001A2E 3268 0004                  		move.w	oNext(a0),a1			; get next object to a1
00001A32 3368 0006 0006             		move.w	oPrev(a0),oPrev(a1)		; copy previous pointer
00001A38                            
00001A38 3178 BE5C 0006             		move.w	rFreeHead.w,oPrev(a0)		; get the head of the free list to previous pointer of this object
00001A3E 31C8 BE5C                  		move.w	a0,rFreeHead.w			; save as the new head of free list
00001A42 4E75                       		rts
00001A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A44                            ; Delete an object
00001A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A44                            ; PARAMETERS:
00001A44                            ;	a1.l	- Pointer to object space to clear
00001A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A44                            ; RETURNS:
00001A44                            ;	a1.l	- Trashed
00001A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A44                            DeleteOtherObj:
00001A44                            		push.l	a0
00001A44 2F08                     M 	move.l	a0,-(sp)
00001A46 2049                       		move.l	a1,a0
00001A48 61BC                       		bsr.s	DeleteObject
00001A4A                            		pop.l	a0
00001A4A 205F                     M 	move.l	(sp)+,a0
00001A4C 4E75                       		rts
00001A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4E                            ; Render object sprites
00001A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4E                            ; PARAMETERS:
00001A4E                            ;	Nothing
00001A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4E                            ; RETURNS:
00001A4E                            ;	Nothing
00001A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4E                            RenderObjects:
00001A4E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001A50 7C00                       		moveq	#0,d6				; Render flags
00001A52                            
00001A52 47F8 F880                  		lea	rFGCam.w,a3			; Foreground camera variables
00001A56 4BF8 BE5E                  		lea	rDispInput+dNext.w,a5	; Sprite input table
00001A5A 4DF8 94CE                  		lea	rSprites.w,a6			; Sprite table buffer
00001A5E                            
00001A5E 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Are we in level mode?
00001A64 6600                       		bne.s	.PrioLvlLoop			; If not, branch
00001A66 4EB9 0000 0000             		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001A6C                            
00001A6C                            .PrioLvlLoop:
00001A6C 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001A6E 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001A70 4A68 0008                  		tst.w	oDrawNext(a0)			; Is the next pointer for a valid object?
00001A74 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001A78                            
00001A78                            .ObjectLoop:
00001A78                            	;	movea.w	(a4)+,a0			; Get object SST address
00001A78 4A90                       		tst.l	oAddr(a0)			; Is this object slot used?
00001A7A 6700 0000                  		beq.w	.NextObject			; If not, branch
00001A7E                            
00001A7E 0228 007F 000D             		andi.b	#$7F,oRender(a0)		; Clear on-screen flag
00001A84 1C28 000D                  		move.b	oRender(a0),d6			; Store render flags
00001A88 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001A8C 3228 0018                  		move.w	oYPos(a0),d1			; Get Y position
00001A90                            
00001A90 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001A94 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001A98 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001A9C 6700                       		beq.s	.Render				; If not, branch
00001A9E                            
00001A9E 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AA0 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AA4                            
00001AA4                            .Render:
00001AA4 7400                       		moveq	#0,d2
00001AA6 1428 0017                  		move.b	oDrawW(a0),d2			; Get sprite width
00001AAA 3600                       		move.w	d0,d3				; Get sprite X position
00001AAC D642                       		add.w	d2,d3				; Add width
00001AAE 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AB0 3600                       		move.w	d0,d3				; Get sprite X position
00001AB2 9642                       		sub.w	d2,d3				; Subtract width
00001AB4 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001AB8 6C00                       		bge.s	.NextObject			; If so, branch
00001ABA 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001ABE                            
00001ABE 7400                       		moveq	#0,d2
00001AC0 1428 001B                  		move.b	oDrawH(a0),d2			; Get sprite height
00001AC4 3601                       		move.w	d1,d3				; Get sprite Y position
00001AC6 D642                       		add.w	d2,d3				; Add height
00001AC8 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001ACA 3601                       		move.w	d1,d3				; Get sprite Y position
00001ACC 9642                       		sub.w	d2,d3				; Subtract height
00001ACE 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001AD2 6C00                       		bge.s	.NextObject			; If so, branch
00001AD4 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001AD8                            
00001AD8 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001ADE 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001AE0 6B00                       		bmi.s	.NextObject			; If not, branch
00001AE2                            
00001AE2 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001AE6 6700                       		beq.s	.NextObject			; If blank, branch
00001AE8 2244                       		movea.l	d4,a1				; Store it
00001AEA 7800                       		moveq	#0,d4
00001AEC 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001AF0 6600                       		bne.s	.Static				; If so, branch
00001AF2 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001AF6 D844                       		add.w	d4,d4				; Turn into offset
00001AF8 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001AFC 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001AFE 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B00 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B02                            
00001B02                            .Static:
00001B02 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B06 6100 ECCE                  		bsr.w	DrawSprite			; Draw the sprites
00001B0A                            
00001B0A                            .NextObject:	
00001B0A 3068 0008                  		move.w	oDrawNext(a0),a0		; Load next object to a0
00001B0E 4A68 0008                  		tst.w	oDrawNext(a0)			; Check the next pointer for valid object
00001B12 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B16                            
00001B16                            .NextPrioLvl:
00001B16 BAFC BE9E                  		cmpa.w	#rDispInput_End,a5		; Are we at the end of the input table?
00001B1A 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B1E                            
00001B1E 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B20 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B22 7000                       		moveq	#0,d0
00001B24                            
00001B24                            .FillRest:
00001B24 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B26 504E                       		addq.w	#8,a6				; Next sprite
00001B28 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B2C                            
00001B2C                            .SetDrawnSprites:
00001B2C 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B30 4446                       		neg.w	d6				; ''
00001B32 11C6 C75B                  		move.b	d6,rSprCount.w		; Store it
00001B36                            
00001B36 4E75                       		rts
00001B38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B38                            .MultiDraw:
00001B38 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B3C 6700                       		beq.s	.RenderMain			; If not, branch
00001B3E                            
00001B3E 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B40 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B44                            
00001B44                            .RenderMain:
00001B44 7400                       		moveq	#0,d2
00001B46 1428 0017                  		move.b	oDrawW(a0),d2			; Get main sprite width
00001B4A 3600                       		move.w	d0,d3				; Get main sprite X position
00001B4C D642                       		add.w	d2,d3				; Add width
00001B4E 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B50 3600                       		move.w	d0,d3				; Get main sprite X position
00001B52 9642                       		sub.w	d2,d3				; Subtract width
00001B54 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B58 6CB0                       		bge.s	.NextObject			; If so, branch
00001B5A 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B5E                            
00001B5E 1428 001B                  		move.b	oDrawH(a0),d2			; Get main sprite height
00001B62 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B64 D642                       		add.w	d2,d3				; Add height
00001B66 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B68 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B6A 9642                       		sub.w	d2,d3				; Subtract height
00001B6C 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B70 6C98                       		bge.s	.NextObject			; If so, branch
00001B72 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B76                            
00001B76 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001B7C 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B7E 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001B82                            
00001B82 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B86 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001B8A 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001B8E 2444                       		movea.l	d4,a2				; Store it
00001B90 7800                       		moveq	#0,d4
00001B92 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001B96 D844                       		add.w	d4,d4				; Turn into offset
00001B98 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001B9A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B9E 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BA0 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BA2 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BA4 3606                       		move.w	d6,d3				; Store render flags
00001BA6 6100 ED12                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BAA 3C03                       		move.w	d3,d6				; Restore render flags
00001BAC                            
00001BAC 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BAE 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BB2                            
00001BB2                            .RenderSubSprites:
00001BB2 3628 002E                  		move.w	oSubCnt(a0),d3			; Get sub sprite count
00001BB6 5343                       		subq.w	#1,d3				; Subtract 1
00001BB8 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001BBC 41E8 0030                  		lea	oSubStart(a0),a0		; Get sub sprite SSTs start
00001BC0                            
00001BC0                            .RenderSubSprs_Loop:
00001BC0 3018                       		move.w	(a0)+,d0			; Get X position
00001BC2 0640 0080                  		addi.w	#128,d0				; Move on screen
00001BC6 3218                       		move.w	(a0)+,d1			; Get Y position
00001BC8 0641 0080                  		addi.w	#128,d1				; Move on screen
00001BCC                            
00001BCC 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001BD0 6700                       		beq.s	.RenderSub			; If not, branch
00001BD2                            
00001BD2 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001BD4 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001BD8                            
00001BD8                            .RenderSub:
00001BD8 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001BDA D844                       		add.w	d4,d4				; Turn into offset
00001BDC 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BDE D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BE2 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BE4 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BE6 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001BE8                            		push.w	d6				; Store render flags
00001BE8 3F06                     M 	move.w	d6,-(sp)
00001BEA 6100 ECCE                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BEE                            		pop.w	d6				; Restore render flags
00001BEE 3C1F                     M 	move.w	(sp)+,d6
00001BF0                            
00001BF0                            .RenderSubSprs_ChkLoop:
00001BF0 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BF2 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001BF6 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BFA                            ; Animate an object's sprite
00001BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BFA                            ; PARAMETERS:
00001BFA                            ;	a0.l	- Object space pointer
00001BFA                            ;	a1.l	- Animation script pointer
00001BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BFA                            ; RETURNS:
00001BFA                            ;	Nothing
00001BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BFA                            AnimateObject:
00001BFA 7000                       		moveq	#0,d0
00001BFC 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00001C00 B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00001C04 6700                       		beq.s	.Run				; If not, branch
00001C06 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00001C0A 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C0E 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C12                            
00001C12                            .Run:
00001C12 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00001C16 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C18 D040                       		add.w	d0,d0				; Turn ID into offset
00001C1A D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C1E 1151 0023                  		move.b	(a1),oAniTimer(a0)		; Set new animation timer
00001C22                            
00001C22 7200                       		moveq	#0,d1
00001C24 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00001C28 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C2C 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C30 6400                       		bhs.s	.CmdReset			; If so, branch
00001C32                            
00001C32                            .Next:
00001C32 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00001C36 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00001C3A 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C3E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00001C44 8128 000D                  		or.b	d0,oRender(a0)			; Set flip bits
00001C48 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00001C4C                            
00001C4C                            .Wait:
00001C4C 4E75                       		rts
00001C4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C4E                            .CmdReset:
00001C4E 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C50 6600                       		bne.s	.CmdJump			; If not, branch
00001C52 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C56 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001C5A 60D6                       		bra.s	.Next				; Continue
00001C5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C5C                            .CmdJump:
00001C5C 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001C5E 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001C60 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001C64 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00001C68 9200                       		sub.b	d0,d1				; ''
00001C6A 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001C6E 60C2                       		bra.s	.Next				; Continue
00001C70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C70                            .CmdSetAnim:
00001C70 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001C72 6600                       		bne.s	.CmdNextRout			; If not, branch
00001C74 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00001C7A 4E75                       		rts
00001C7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C7C                            .CmdNextRout:
00001C7C 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001C7E 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001C80 5428 0025                  		addq.b	#2,oRoutine(a0)			; Next routine
00001C84 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C88 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next animation frame
00001C8C 4E75                       		rts
00001C8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8E                            .CmdReset2ndRout:
00001C8E 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001C90 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001C92 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C96                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001C96 4E75                       		rts
00001C98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C98                            .CmdNext2ndRout:
00001C98 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001C9A 6600                       		bne.s	.CmdEnd				; If not, branch
00001C9C                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001C9C 4E75                       		rts
00001C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C9E                            .CmdEnd:
00001C9E 4E75                       		rts
00001CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA0                            ; Load object DPLCs
00001CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA0                            ; PARAMETERS:
00001CA0                            ;	d4.w	- Target VRAM address
00001CA0                            ;	d6.l	- Pointer to uncompressed art
00001CA0                            ;	a2.l	- Pointer to DPLCs
00001CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA0                            ; RETURNS:
00001CA0                            ;	Nothing
00001CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA0                            LoadObjDPLCs:
00001CA0 7000                       		moveq	#0,d0
00001CA2 1028 0010                  		move.b	oFrame(a0),d0			; Get mapping frame
00001CA6 B010                       		cmp.b	oPrevDPLC(a0),d0		; Do we need to update the art?
00001CA8 6700                       		beq.s	.End				; If not, branch
00001CAA 1080                       		move.b	d0,oPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CAC D040                       		add.w	d0,d0				; Turn ID into offset
00001CAE D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CB2 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CB4 5345                       		subq.w	#1,d5				; Subtract 1
00001CB6 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001CB8                            
00001CB8                            .ReadEntries:
00001CB8 7200                       		moveq	#0,d1
00001CBA 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001CBC 3601                       		move.w	d1,d3				; Copy that
00001CBE E04B                       		lsr.w	#8,d3				; Get tile count
00001CC0 0243 00F0                  		andi.w	#$F0,d3				; ''
00001CC4 0643 0010                  		addi.w	#$10,d3				; ''
00001CC8 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001CCC EB89                       		lsl.l	#5,d1				; ''
00001CCE D286                       		add.l	d6,d1				; Get pointer in art data
00001CD0 3404                       		move.w	d4,d2				; Copy VRAM address
00001CD2 D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001CD4 D843                       		add.w	d3,d4				; ''
00001CD6 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the art
00001CDA 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001CDE                            
00001CDE                            .End:
00001CDE 4E75                       		rts
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            ; Move an object by it's velocity values
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            ; PARAMETERS:
00001CE0                            ;	a0.l	- Object space pointer
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            ; RETURNS:
00001CE0                            ;	Nothing
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            ObjectMove:
00001CE0 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001CE4 48C0                       		ext.l	d0				; ''
00001CE6 E188                       		lsl.l	#8,d0				; Shift
00001CE8 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001CEC 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001CF0 48C0                       		ext.l	d0				; ''
00001CF2 E188                       		lsl.l	#8,d0				; Shift
00001CF4 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001CF8 4E75                       		rts
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            ; Move an object by it's velocity values (with gravity)
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            ; PARAMETERS:
00001CFA                            ;	a0.l	- Object space pointer
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            ; RETURNS:
00001CFA                            ;	Nothing
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            ObjectMoveAndFall:
00001CFA 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001CFE 48C0                       		ext.l	d0				; ''
00001D00 E188                       		lsl.l	#8,d0				; Shift
00001D02 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D06 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D0A 0668 0038 001E             		addi.w	#$38,oYVel(a0)			; Apply gravity
00001D10 48C0                       		ext.l	d0				; ''
00001D12 E188                       		lsl.l	#8,d0				; Shift
00001D14 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D18 4E75                       		rts
00001D1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D1A                            ; Check if a specific object is nearby
00001D1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D1A                            ; PARAMETERS:
00001D1A                            ;	a0.l	- Current object space pointer
00001D1A                            ;	a1.l	- Range data pointer
00001D1A                            ;	a2.l	- Object to check's space pointer
00001D1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D1A                            ; RETURNS:
00001D1A                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D1A                            CheckObjInRange:
00001D1A 7000                       		moveq	#0,d0
00001D1C 322A 0014                  		move.w	oXPos(a2),d1			; Get other object's position
00001D20 342A 0018                  		move.w	oYPos(a2),d2			; ''
00001D24 3628 0014                  		move.w	oXPos(a0),d3			; Get current object's position
00001D28 3828 0018                  		move.w	oYPos(a0),d4			; ''
00001D2C D659                       		add.w	(a1)+,d3			; Get left boundary
00001D2E 3A03                       		move.w	d3,d5				; Copy
00001D30 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D32 D859                       		add.w	(a1)+,d4			; Get top boundary
00001D34 3C04                       		move.w	d4,d6				; Copy
00001D36 DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D38 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D3A 6500                       		blo.s	.End				; If not, branch
00001D3C B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D3E 6400                       		bhs.s	.End				; If not, branch
00001D40 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D42 6500                       		blo.s	.End				; If not, branch
00001D44 B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D46 6400                       		bhs.s	.End				; If not, branch
00001D48 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D4A                            
00001D4A                            .End:
00001D4A 4E75                       		rts
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; Object manager
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ObjectManager:
00001D4C 4A38 C7B8                  		tst.b	rObjManInit.w
00001D50 6600                       		bne.s	ObjectManagerMain
00001D52                            
00001D52                            ObjectManagerInit:
00001D52 50F8 C7B8                  		st	rObjManInit.w			; Set the init flag
00001D56                            
00001D56 2078 C7B4                  		movea.l	rObjPosAddr.w,a0		; Get object data pointer
00001D5A 21C8 C7BA                  		move.l	a0,rObjLoadR.w
00001D5E 21C8 C7BE                  		move.l	a0,rObjLoadL.w			; Store address of object layout
00001D62                            
00001D62 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001D66                            
00001D66 3C38 F880                  		move.w	rCamXPos.w,d6			; Camera's X position
00001D6A 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001D6E 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001D70 7C00                       		moveq	#0,d6				; Cap at left boundary
00001D72                            
00001D72                            .NoReset:
00001D72 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001D76                            
00001D76 2078 C7BA                  		movea.l	rObjLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001D7A                            
00001D7A                            .ChkObjsLeft:
00001D7A BC50                       		cmp.w	(a0),d6				; Compare object position
00001D7C 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001D7E 5C48                       		addq.w	#6,a0				; Next object
00001D80 524B                       		addq.w	#1,a3				; Next respawn table index
00001D82 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001D84                            
00001D84                            .ChkDone:
00001D84 21C8 C7BA                  		move.l	a0,rObjLoadR.w			; Store new addresses
00001D88 31CB C7C4                  		move.w	a3,rObjRespR.w			; ''
00001D8C                            
00001D8C 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001D90                            
00001D90 2078 C7BE                  		movea.l	rObjLoadL.w,a0
00001D94 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001D98 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001D9A                            
00001D9A                            .ChkObjsRight:
00001D9A BC50                       		cmp.w	(a0),d6				; Compate object position
00001D9C 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001D9E 5C48                       		addq.w	#6,a0				; Next object
00001DA0 524B                       		addq.w	#1,a3				; Next respawn table index
00001DA2 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DA4                            
00001DA4                            .ChkDone2:
00001DA4 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001DA8 31CB C7C2                  		move.w	a3,rObjRespL.w		; ''
00001DAC                            
00001DAC 31FC FFFF C7CA             		move.w	#-1,rObjManX.w		; Reset manager's camera X position
00001DB2 3038 F888                  		move.w	rCamYPos.w,d0			; Get camera's Y position
00001DB6 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001DBA 31C0 C7CC                  		move.w	d0,rObjManY.w		; Store it so unnecessary Y checks shouldn't be done
00001DBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DBE                            ObjectManagerMain:
00001DBE 3238 F888                  		move.w	rCamYPos.w,d1			; Get camera's Y position
00001DC2 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DC6 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DCA 31C1 C7C8                  		move.w	d1,rObjYCoarse.w		; Store this
00001DCE                            
00001DCE 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera's X position
00001DD2 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DD6 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DDA 31C1 C7C6                  		move.w	d1,rObjXCoarse.w		; Store this
00001DDE                            		
00001DDE 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001DE4                            
00001DE4 3638 F888                  		move.w	rCamYPos.w,d3			; Get camera's Y position
00001DE8 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001DEC 3803                       		move.w	d3,d4				; Copy
00001DEE 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001DF2 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001DF6 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001DF8 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001DFA                            
00001DFA                            .SetNoWrap:
00001DFA 3A3C 0FFF                  		move.w	#$FFF,d5
00001DFE 3C38 F880                  		move.w	rCamXPos.w,d6			; Get camera's X position
00001E02 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E06 BC78 C7CA                  		cmp.w	rObjManX.w,d6		; Check against last range
00001E0A 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E0E 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E10                            
00001E10 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E14                            
00001E14 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E18 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E1C                            
00001E1C 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E20 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E22                            
00001E22 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E26 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E28                            
00001E28                            .LoadLoop:
00001E28 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E2C 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E2E 5D88                       		subq.l	#6,a0				; Get actual object address
00001E30 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E32                            
00001E32 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E36 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E38 5D88                       		subq.l	#6,a0
00001E3A 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E3C                            
00001E3C                            .LoadFail:
00001E3C 5C88                       		addq.l	#6,a0				; Undo object loading
00001E3E 524B                       		addq.w	#1,a3
00001E40 6000                       		bra.s	.EndLoad
00001E42                            .EndLoadRst:
00001E42 4EB8 1A44                  		jsr	DeleteOtherObj.w
00001E46                            
00001E46                            .EndLoad:
00001E46 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001E4A 31CB C7C2                  		move.w	a3,rObjRespL.w
00001E4E                            
00001E4E 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E52 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E56                            
00001E56 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001E5A                            
00001E5A                            .ChkLoop:
00001E5A BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001E5E 6E00                       		bgt.s	.ChkDone			; If so, branch
00001E60 5D88                       		subq.l	#6,a0				; Get the object before this
00001E62 534B                       		subq.w	#1,a3				; And its respawn index
00001E64 60F4                       		bra.s	.ChkLoop			; Check next object
00001E66                            
00001E66                            .ChkDone:
00001E66 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001E6A 31CB C7C4                  		move.w	a3,rObjRespR.w
00001E6E 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001E70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E70                            Level_LoadObjs_Forward:
00001E70 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E74                            
00001E74 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E78 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E7C                            
00001E7C 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001E80                            
00001E80 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E84 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E86                            
00001E86                            .LoadLoop:
00001E86 BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001E88 6300                       		bls.s	.EndLoadRst			; If not, branch
00001E8A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E8E 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001E90 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001E92 60F2                       		bra.s	.LoadLoop
00001E94                            
00001E94                            .EndLoadRst:
00001E94 4EB8 1A44                  		jsr	DeleteOtherObj.w
00001E98                            
00001E98                            .EndLoad:
00001E98 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001E9C 31CB C7C4                  		move.w	a3,rObjRespR.w
00001EA0                            
00001EA0 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001EA4 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001EA8                            
00001EA8 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EAC 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EAE                            
00001EAE                            .ChkLoop:
00001EAE BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EB0 6300                       		bls.s	.ChkDone			; If so, branch
00001EB2 5C88                       		addq.l	#6,a0				; Get the object before this
00001EB4 524B                       		addq.w	#1,a3				; And its respawn index
00001EB6 60F6                       		bra.s	.ChkLoop			; Check next object
00001EB8                            
00001EB8                            .ChkDone:
00001EB8 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001EBC 31CB C7C2                  		move.w	a3,rObjRespL.w
00001EC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EC0                            Level_LoadObjs_SameXRange:
00001EC0 3C38 F888                  		move.w	rCamYPos.w,d6			; Get camera's X position
00001EC4 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001EC8 3606                       		move.w	d6,d3				; Copy
00001ECA BC78 C7CC                  		cmp.w	rObjManY.w,d6		; Check against last range
00001ECE 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001ED2 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001ED4                            
00001ED4 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001ED8 6B00 0000                  		bmi.w	.LoadEnd
00001EDC 6000                       		bra.s	.YCheck
00001EDE                            
00001EDE                            .MovingDown:
00001EDE 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001EE2                            
00001EE2                            .YCheck:
00001EE2 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001EE6 6700                       		beq.s	.LoadEnd			; If failed, branch
00001EE8                            		
00001EE8 3803                       		move.w	d3,d4				; Copy Y position
00001EEA 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001EEE 3A3C 0FFF                  		move.w	#$FFF,d5
00001EF2                            
00001EF2 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001EF6 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001EFA 2E38 C7BA                  		move.l	rObjLoadR.w,d7		; Get current objects on the right side of the screen
00001EFE 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F00 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F02 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F04                            
00001F04                            .LoadNext:
00001F04 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F06 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F08                            
00001F08 3210                       		move.w	(a0),d1				; Get object's Y position
00001F0A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F0C B243                       		cmp.w	d3,d1
00001F0E 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F10 B244                       		cmp.w	d4,d1
00001F12 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F14                            
00001F14 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F18 3368 FFFE 0014             		move.w	-2(a0),oXPos(a1)			; Set X position
00001F1E 3210                       		move.w	(a0),d1				; Get object's Y position
00001F20 3401                       		move.w	d1,d2				; Copy it
00001F22 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F24 3341 0018                  		move.w	d1,oYPos(a1)			; Set Y position
00001F28                            
00001F28 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F2A 0242 0003                  		andi.w	#3,d2				; ''
00001F2E 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F32 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001F36                            
00001F36 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F3A D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F3C D442                       		add.w	d2,d2
00001F3E 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001F42                            
00001F42 1368 0003 0024             		move.b	3(a0),oSubtype(a1)		; Set subtype
00001F48 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001F4C                            
00001F4C 4EB8 19B0                  		jsr	FindFreeObj.w			; Find a free object slot
00001F50 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F52                            
00001F52                            .LoadFail:
00001F52 5C88                       		addq.l	#6,a0				; Next object
00001F54 524B                       		addq.w	#1,a3				; ''
00001F56 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001F58 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001F5A                            
00001F5A                            .LoadEndRst:
00001F5A 4EB8 1A44                  		jsr	DeleteOtherObj.w
00001F5E                            
00001F5E                            .LoadEnd:
00001F5E 31C6 C7CC                  		move.w	d6,rObjManY.w		; Store manager's camera Y position
00001F62 4E75                       		rts
00001F64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F64                            ; Load an object from the object layout
00001F64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F64                            ; PARAMETERS:
00001F64                            ;	d3.w	- Upper boundary
00001F64                            ;	d4.w	- Lower boundary
00001F64                            ;	d5.w	- Y position limit
00001F64                            ;	a0.l	- Index of object layout
00001F64                            ;	a1.l	- Target object
00001F64                            ;	a3.l	- Respawn table address
00001F64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F64                            Level_LoadObject:
00001F64 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F66 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001F68 5C88                       		addq.l	#6,a0				; Next object
00001F6A 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F6C 4E75                       		rts
00001F6E                            
00001F6E                            .NotLoaded:
00001F6E 3E18                       		move.w	(a0)+,d7			; X position
00001F70 3218                       		move.w	(a0)+,d1			; Y position
00001F72 3401                       		move.w	d1,d2				; Copy
00001F74 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001F76 C245                       		and.w	d5,d1				; Keey Y in range
00001F78 B243                       		cmp.w	d3,d1
00001F7A 6500                       		bcs.s	.End				; Branch if in range
00001F7C B244                       		cmp.w	d4,d1
00001F7E 6300                       		bls.s	.Spawn				; Branch if in range
00001F80                            
00001F80                            .End:
00001F80 5448                       		addq.w	#2,a0				; Next objeect
00001F82 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F84 4E75                       		rts
00001F86                            
00001F86                            .LoadNoY:
00001F86 C245                       		and.w	d5,d1				; Keey Y in range
00001F88                            
00001F88                            .Spawn:
00001F88 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F8C 3347 0014                  		move.w	d7,oXPos(a1)			; Store X position
00001F90 3341 0018                  		move.w	d1,oYPos(a1)			; Store Y position
00001F94                            
00001F94 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F96 0242 0003                  		andi.w	#3,d2				; ''
00001F9A 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F9E 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001FA2                            
00001FA2 1418                       		move.b	(a0)+,d2			; Get ID
00001FA4 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FA6 D442                       		add.w	d2,d2
00001FA8 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001FAC                            
00001FAC 1358 0024                  		move.b	(a0)+,oSubtype(a1)		; Set subtype
00001FB0 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001FB4                            		
00001FB4 6000 F9FA                  		bra.w	FindFreeObj			; Find a free object slot
00001FB8                            		
00001FB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FB8                            ; Check if the object is in range on the camera. If it isn't, delete it
00001FB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FB8                            ; PARAMETERS:
00001FB8                            ;	a0.l	- Object space pointer
00001FB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FB8                            ; RETURNS:
00001FB8                            ;	Nothing
00001FB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FB8                            CheckObjActive:
00001FB8 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001FBC                            
00001FBC                            CheckObjActive2:
00001FBC 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00001FC0 9078 C7C6                  		sub.w	rObjXCoarse.w,d0		; Subtract the camera's coarse X position
00001FC4 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00001FC8 6200                       		bhi.s	.Delete				; If so, branch
00001FCA 4E75                       		rts
00001FCC                            
00001FCC                            .Delete:
00001FCC 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table entry address
00001FD0 6700                       		beq.s	.DoDelete			; If 0, branch
00001FD2 3440                       		movea.w	d0,a2
00001FD4 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00001FD8                            
00001FD8                            .DoDelete:
00001FD8 4EF8 1A06                  		jmp	DeleteObject.w			; Delete the object
00001FDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FDC                            ; Get orientation to player
00001FDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FDC                            ; PARAMETERS:
00001FDC                            ;	a0.l	- Object space pointer
00001FDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FDC                            ; RETURNS:
00001FDC                            ;	a1.l	- Player object
00001FDC                            ;	d0.w	- 0 if player is left from object, 2 if right
00001FDC                            ;	d1.w	- 0 if player is above object, 2 if below
00001FDC                            ;	d2.w	- Player's horizontal distance to object
00001FDC                            ;	d3.w	- Player's vertical distance to object
00001FDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FDC                            GetOrientToPlayer:
00001FDC 7000                       		moveq	#0,d0
00001FDE 7200                       		moveq	#0,d1
00001FE0                            
00001FE0 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get player object
00001FE4                            
00001FE4 3428 0014                  		move.w	oXPos(a0),d2			; Get horizonal distance
00001FE8 9469 0014                  		sub.w	oXPos(a1),d2			; ''
00001FEC 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00001FEE 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00001FF0                            
00001FF0                            .GetY:
00001FF0 3628 0018                  		move.w	oYPos(a0),d3			; Get vertical distance
00001FF4 9669 0018                  		sub.w	oYPos(a1),d3			; ''
00001FF8 6400                       		bhs.s	.End				; Branch if the player is above the object
00001FFA 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00001FFC                            
00001FFC                            .End:
00001FFC 4E75                       		rts
00001FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FFE                            ; Cap an object's speed
00001FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FFE                            ; PARAMETERS:
00001FFE                            ;	a0.l	- Object space pointer
00001FFE                            ;	d0.w	- Max X speed
00001FFE                            ;	d1.w	- Max Y speed
00001FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FFE                            ; RETURNS:
00001FFE                            ;	Nothing
00001FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FFE                            CapObjSpeed:
00001FFE 3428 001C                  		move.w	oXVel(a0),d2			; Get X velocity
00002002 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
00002004 4440                       		neg.w	d0				; Get absolute speed
00002006 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002008 6400                       		bhs.s	.ChkUp				; If not, branch
0000200A 3400                       		move.w	d0,d2				; Cap the speed
0000200C 6000                       		bra.s	.ChkUp				; Continue
0000200E                            
0000200E                            .ChkRight:
0000200E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002010 6300                       		bls.s	.ChkUp				; If not, branch
00002012 3400                       		move.w	d0,d2				; Cap the speed
00002014                            
00002014                            .ChkUp:
00002014 3628 001E                  		move.w	oYVel(a0),d3			; Get Y velocity
00002018 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
0000201A 4441                       		neg.w	d1				; Get absolute speed
0000201C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000201E 6400                       		bhs.s	.UpdateVel			; If not, branch
00002020 3601                       		move.w	d1,d3				; Cap the speed
00002022 6000                       		bra.s	.UpdateVel			; Continue
00002024                            
00002024                            .ChkDown:
00002024 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002026 6300                       		bls.s	.UpdateVel			; If not, branch
00002028 3601                       		move.w	d1,d3				; Cap the speed
0000202A                            
0000202A                            .UpdateVel:
0000202A 3142 001C                  		move.w	d2,oXVel(a0)			; Set X velocity
0000202E 3142 001E                  		move.w	d2,oYVel(a0)			; Set Y velocity
00002032 4E75                       		rts
00002034                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002034                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
00002034                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002034                            ; PARAMETERS:
00002034                            ;	a2.l	- Object data
00002034                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002034                            ; RETURNS:
00002034                            ;	Nothing
00002034                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002034                            ; LoadChildObject:
00002034 6100 F97A                  		bsr.w	FindFreeObj			; Find a free object slot
00002038 6600                       		bne.s	.End				; If there is non, branch
0000203A 301A                       		move.w	(a2)+,d0			; Get parent object SST
0000203C 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002040 301A                       		move.w	(a2)+,d0			; Get child object SST
00002042 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
00002046 229A                       		move.l	(a2)+,oAddr(a1)			; Set object pointer
00002048 135A 0024                  		move.b	(a2)+,oSubtype(a1)		; Set subtype
0000204C 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)			; Set X
00002052 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)			; Set Y
00002058                            
00002058                            .End:
00002058 4E75                       		rts
0000205A                            ; =========================================================================================================================================================
0000205A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000205A                            ; Entry point
0000205A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000205A                            GameInit:
0000205A                            		intsOff						; Disable interrupts
0000205A 007C 0700                M 	ori	#$700,sr
0000205E                            		
0000205E                            		clrRAM	RAM_START, RAM_END			; Clear RAM
0000205E                          M 	local	endaddr
0000205E                          M endaddr	equs	"ram_end"
0000205E 7000                     M 	moveq	#0,d0
00002060 43F9 00FF 0000           M 	lea	ram_start,a1
00002066 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
0000206A 22C0                     M .clear_72:	move.l	d0,(a1)+
0000206C 51C9 FFFC                M 	dbf	d1,.clear_72
00002070                            		
00002070 6100 E3EA                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
00002074 6100 E146                  		bsr.w	InitVDP					; Initialize the VDP
00002078 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
0000207E                            		
0000207E 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
00002084 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
00002088 11C0 C744                  		move.b	d0,rHWVersion.w				; Store in RAM
0000208C                            
0000208C 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
00002090 31C0 C74A                  		move.w	d0,rVIntJmp.w				; Set the "JMP" command for V-INT
00002094 31C0 C750                  		move.w	d0,rHIntJmp.w				; Set the "JMP" command for H-INT
00002098 21FC 0000 0000 C74C        		move.l	#VInt_Standard,rVIntAddr.w		; Set the V-INT pointer to the standard V-INT routine
000020A0 21FC 0000 0000 C752        		move.l	#HInt_Water,rHIntAddr.w			; Set the H-INT pointer to the standard V-INT routine
000020A8                            
000020A8 4278 9000                  		clr.w	rDMAQueue.w				; Set stop token at the beginning of the DMA queue
000020AC 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w			; Reset the DMA queue slot
000020B2                            
000020B2 11FC 0004 C75A             		move.b	#gLevel,rGameMode.w			; Set game mode to "title"
000020B8 4EF9 0000 0000             		jmp	Level					; Go to the title screen
000020BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020BE                            ; Go to the correct game mode
000020BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020BE                            GotoGameMode:
000020BE 7000                       		moveq	#0,d0
000020C0 1038 C75A                  		move.b	rGameMode.w,d0				; Get game mode ID
000020C4 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
000020C8 4ED0                       		jmp	(a0)					; Jump to it
000020CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020CA                            .GameModes:
000020CA 0000 0000                  		dc.l	TitleScreen				; Title screen
000020CE 0000 0000                  		dc.l	Level					; Level mode
000020D2 0000 0000                  		dc.l	Ending					; Ending
000020D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020D6                            ; Check for pausing
000020D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020D6                            CheckPause:
000020D6 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game already paused?
000020DA 6600                       		bne.s	.SetPause			; If so, branch
000020DC 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000020E2 6700                       		beq.s	.End				; If not, branch
000020E4                            
000020E4                            .SetPause:
000020E4 50F8 C75C                  		st	rPauseFlag.w			; Pause the game
000020E8                            		AMPS_MUSPAUSE				; Pause the music
000020E8 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
000020EE                            
000020EE                            .PauseLoop:
000020EE 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; General V-INT routine
000020F4 6100 E998                  		bsr.w	VSync_Routine			; V-SYNC
000020F8 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000020FE 67EE                       		beq.s	.PauseLoop			; If not, branch
00002100                            
00002100                            		AMPS_MUSUNPAUSE				; Unpause the music
00002100 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002106 4238 C75C                  		clr.b	rPauseFlag.w			; Unpause the game
0000210A                            
0000210A                            .End:
0000210A 4E75                       		rts
0000210C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000210C                            ; Interrupts
0000210C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000210C                            VInt_Standard:
0000210C                            		intsOff					; Turn interrupts off
0000210C 007C 0700                M 	ori	#$700,sr
00002110                            		push.l	d0-a6				; Save registers
00002110 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002114                            		
00002114 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000211A 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0000211E                            
0000211E                            .WaitForVBLANK:
0000211E 3016                       		move.w	(a6),d0				; Get VDP status
00002120 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
00002124 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
00002126                            
00002126 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
0000212C 6700                       		beq.s	.SetVScroll			; If not, branch
0000212E 303C 0700                  		move.w	#$700,d0			; Do a delay
00002132 51C8 FFFE                  		dbf	d0,*				; ''
00002136                            
00002136                            .SetVScroll:
00002136                            		dma68k	rVScroll,0,$50,VSRAM		; Load VScroll buffer into VSRAM
00002136 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
0000213C 2CBC 96CA 953F           M 	move.l	#$96009500|((((rvscroll)/2)&$ff00)<<8)|(((rvscroll)/2)&$ff),(a6)
00002142 3CBC 977F                M 	move.w	#$9700|(((rvscroll)>>17)&$7f),(a6)
00002146                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
00002146 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000214A                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
0000214A 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000214E 3C9F                     M 	move.w	(sp)+,(a6)
00002150                            
00002150 4A38 C745                  		tst.b	rVINTRout.w			; Is the game lagging?
00002154 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
00002158 4238 C748                  		clr.b	rLagCount.w			; Clear lag frame counter
0000215C                            
0000215C 7000                       		moveq	#0,d0
0000215E 1038 C745                  		move.b	rVINTRout.w,d0		; Get V-INT routine ID
00002162 4238 C745                  		clr.b	rVINTRout.w			; Clear V-INT routine ID
00002166 50F8 C749                  		st	rHIntFlag.w			; Allow the H-INT to run
0000216A 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
0000216E 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002172                            
00002172                            VInt_FinishUpdates:
00002172 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002178                            
00002178                            VInt_End:
00002178 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
0000217C 6100 F164                  		bsr.w	RandomNumber			; Generate a random number
00002180                            		
00002180                            		pop.l	d0-a6				; Restore registers
00002180 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002184                            		intsOn					; Turn interrupts on
00002184 027C F8FF                M 	andi	#$f8ff,sr
00002188                            		lagOn					; Turn on the lag-o-meter
00002188 4E73                       		rte
0000218A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000218A                            ; V-INT routines
0000218A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000218A                            VInt_Routines:
0000218A 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
0000218C 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
0000218E 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
00002190 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
00002192 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
00002194 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
00002196                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002196                            ; V-INT lag routine
00002196                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002196                            VInt_Lag:
00002196 584F                       		addq.w	#4,sp				; Don't return to caller
00002198                            
00002198                            VInt_Lag_Main:
00002198 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
0000219C 6600                       		bne.s	.WaterPal			; If so, branch
0000219E                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
0000219E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021A4 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021AA 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000021AE                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021AE 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021B2                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021B2 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021B6 3C9F                     M 	move.w	(sp)+,(a6)
000021B8 6000                       		bra.s	.Cont				; Continue
000021BA                            
000021BA                            .WaterPal:
000021BA                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021BA 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021C0 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000021C6 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000021CA                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021CA 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021CE                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021CE 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021D2 3C9F                     M 	move.w	(sp)+,(a6)
000021D4                            
000021D4                            .Cont:	
000021D4 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000021D8                            
000021D8 5238 C748                  		addq.b	#1,rLagCount.w		; Increment lag counter
000021DC 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
000021E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021E0                            ; V-INT general routine
000021E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021E0                            VInt_General:
000021E0 6100 0000                  		bsr.w	VInt_Update			; Do updates
000021E4 6000 EE86                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021E8                            ; V-INT level load routine
000021E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021E8                            VInt_LevelLoad:
000021E8 6100 E854                  		bsr.w	ReadJoypads			; Read joypads
000021EC                            
000021EC 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000021F0 6600                       		bne.s	.WaterPal			; If so, branch
000021F2                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000021F2 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021F8 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021FE 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002202                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002202 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002206                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002206 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000220A 3C9F                     M 	move.w	(sp)+,(a6)
0000220C 6000                       		bra.s	.Cont				; Continue
0000220E                            
0000220E                            .WaterPal:
0000220E                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000220E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002214 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
0000221A 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000221E                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000221E 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002222                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002222 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002226 3C9F                     M 	move.w	(sp)+,(a6)
00002228                            
00002228                            .Cont:
00002228 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
0000222C                            		
0000222C                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000222C 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002232 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002238 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000223C                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000223C 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
00002240                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
00002240 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
00002244 3C9F                     M 	move.w	(sp)+,(a6)
00002246                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002246 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
0000224C 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
00002252 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002256                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002256 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
0000225A                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
0000225A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000225E 3C9F                     M 	move.w	(sp)+,(a6)
00002260 6100 E0CA                  		bsr.w	ProcessDMAQueue			; Process DMA queue
00002264                            		
00002264 6000 EE06                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002268                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002268                            ; V-INT level routine
00002268                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002268                            VInt_Level:
00002268 43F8 F880                  		lea	rFGCam.w,a1			; Foreground level drawing variables
0000226C 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Foreground column plane buffer
00002270 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Foreground row plane buffer
00002274 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
0000227A 43F8 F89E                  		lea	rBGCam.w,a1			; Background level drawing variables
0000227E 47F8 C424                  		lea	rBGColBuf.w,a3		; Background column plane buffer
00002282 49F8 C322                  		lea	rBGRowBuf.w,a4		; Background row plane buffer
00002286 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
0000228C                            
0000228C 6100 E7B0                  		bsr.w	ReadJoypads			; Read joypads
00002290                            
00002290 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002294 6600                       		bne.s	.WaterPal			; If so, branch
00002296                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002296 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000229C 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000022A2 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000022A6                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022A6 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022AA                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022AA 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022AE 3C9F                     M 	move.w	(sp)+,(a6)
000022B0 6000                       		bra.s	.Cont				; Continue
000022B2                            
000022B2                            .WaterPal:
000022B2                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000022B2 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022B8 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000022BE 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000022C2                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022C2 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022C6                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022C6 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022CA 3C9F                     M 	move.w	(sp)+,(a6)
000022CC                            
000022CC                            .Cont:
000022CC 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000022D0                            
000022D0                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000022D0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022D6 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000022DC 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000022E0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022E0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022E4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022E4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022E8 3C9F                     M 	move.w	(sp)+,(a6)
000022EA                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000022EA 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000022F0 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
000022F6 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
000022FA                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000022FA 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000022FE                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000022FE 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002302 3C9F                     M 	move.w	(sp)+,(a6)
00002304 6100 E026                  		bsr.w	ProcessDMAQueue			; Process DMA queue
00002308                            		
00002308 0C38 005C C75F             		cmpi.b	#92,rHIntCnt.w		; Would V-INT be unable to do updates in the next frame?
0000230E 6400                       		bhs.s	.DoUpdates			; If not, branch
00002310 50F8 C75D                  		st	rHIntUpdates.W		; Set updates in H-INT flag
00002314 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
00002316 6100 ED54                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000231A 6000 FE5C                  		bra.w	VInt_End			; Continue
0000231E                            
0000231E                            .DoUpdates:
0000231E 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
00002324 6000 ED46                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002328                            ; V-INT title screen update routine
00002328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002328                            VInt_Title:
00002328 4E75                       		rts
0000232A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000232A                            ;		bsr.w	ReadJoypads			; Read joypads
0000232A                            ;
0000232A                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
0000232A                            ;		lea	rPalette.w,a0			; ''
0000232A                            ;		moveq	#$80>>2-1,d0			; ''
0000232A                            ;
0000232A                            ;.WritePal:
0000232A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000232A                            ;		dbf	d0,.WritePal			; ''
0000232A                            ;
0000232A                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
0000232A                            ;		lea	rSprites.w,a0			; ''
0000232A                            ;		move.w	#$280>>2-1,d0			; ''
0000232A                            ;
0000232A                            ;.WriteSprs:
0000232A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000232A                            ;		dbf	d0,.WriteSprs			; ''
0000232A                            ;
0000232A                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
0000232A                            ;		lea	rHScroll.w,a0			; ''
0000232A                            ;		move.w	#$380>>2-1,d0			; ''
0000232A                            ;
0000232A                            ;.WriteHScrl:
0000232A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000232A                            ;		dbf	d0,.WriteHScrl			; ''
0000232A                            ;		rts
0000232A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000232A                            ; Do standard updates in V-INT
0000232A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000232A                            VInt_Update:
0000232A                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
0000232A                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000232A 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002330 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002336 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000233A                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000233A 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000233E                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000233E 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
00002342 3C9F                     M 	move.w	(sp)+,(a6)
00002344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002344                            ; V-INT fade routine
00002344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002344                            VInt_Fade:
00002344 6100 E6F8                  		bsr.w	ReadJoypads			; Read joypads
00002348                            
00002348 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
0000234C 6600                       		bne.s	.WaterPal			; If so, branch
0000234E                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
0000234E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002354 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000235A 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
0000235E                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000235E 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002362                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002362 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002366 3C9F                     M 	move.w	(sp)+,(a6)
00002368 6000                       		bra.s	.Cont				; Continue
0000236A                            
0000236A                            .WaterPal:
0000236A                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000236A 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002370 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002376 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000237A                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000237A 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000237E                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000237E 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002382 3C9F                     M 	move.w	(sp)+,(a6)
00002384                            
00002384                            .Cont:
00002384 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002388                            
00002388                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002388 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
0000238E 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
00002394 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002398                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002398 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
0000239C                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
0000239C 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000023A0 3C9F                     M 	move.w	(sp)+,(a6)
000023A2 6000 DF88                  		bra.w	ProcessDMAQueue			; Process DMA queue
000023A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A6                            ; V-INT routine that only runs the SMPS driver
000023A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A6                            VInt_RunSMPS:
000023A6                            		push.l	d0-a6				; Save registers
000023A6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023AA                            		
000023AA                            .WaitForVBLANK:
000023AA 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
000023B0 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000023B4 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
000023B6                            
000023B6 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
000023BC 6700                       		beq.s	.UpdateSMPS			; If not, branch
000023BE 303C 0700                  		move.w	#$700,d0			; Do a delay
000023C2 51C8 FFFE                  		dbf	d0,*				; ''
000023C6                            
000023C6                            .UpdateSMPS:
000023C6 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
000023CC                            
000023CC 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
000023D0 6100 EF10                  		bsr.w	RandomNumber			; Generate a random number
000023D4                            		
000023D4                            		pop.l	d0-a6				; Restore registers
000023D4 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
000023D8 4E73                       		rte
000023DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DA                            ; Title screen
000023DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DA                            		include	"Title Screen/Main.asm"
000023DA                            ; =========================================================================================================================================================
000023DA                            ; Mighty The Armadillo in PRISM PARADISE
000023DA                            ; By Nat The Porcupine 2021
000023DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DA                            ; Title splash screen
000023DA                            ; =========================================================================================================================================================
000023DA                            
000023DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DA                            TitleScreen:
000023DA 60FE                       		bra.s	TitleScreen
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
000023DC                            ;		playSnd	#Mus_Stop, 1			; Stop sound
000023DC                            ;
000023DC                            ;		bsr.w	FadeToBlack			; Fade to black
000023DC                            ;
000023DC                            ;		intsOff					; Disable interrupts
000023DC                            ;		clrRAM	rKosPVars
000023DC                            ;		clrRAM	rChkpoint
000023DC                            ;		clrRAM	rGameVars
000023DC                            ;		clrRAM	rObjects
000023DC                            ;
000023DC                            ;		lea	VDP_CTRL,a5
000023DC                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
000023DC                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
000023DC                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
000023DC                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
000023DC                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
000023DC                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
000023DC                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
000023DC                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
000023DC                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
000023DC                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
000023DC                            ;
000023DC                            ;		bsr.w	ClearScreen			; Clear screen
000023DC                            ;
000023DC                            ;		lea	rDestPal.w,a0			; Fade target palette
000023DC                            ;		moveq	#$80>>2-1,d0			; Size
000023DC                            ;
000023DC                            ;.FillPal:
000023DC                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
000023DC                            ;		dbf	d0,.FillPal			; Loop
000023DC                            ;
000023DC                            ;		bsr.w	FadeFromBlack			; Fade from black
000023DC                            ;		
000023DC                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
000023DC                            ;
000023DC                            ;TitleScreen2:
000023DC                            ;		intsOff
000023DC                            ;
000023DC                            ;		clr.b	rArtCheat.w
000023DC                            ;		clrRAM	rGameVars
000023DC                            ;		clrRAM	rObjects
000023DC                            ;
000023DC                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
000023DC                            ;		bsr.w	FadeToWhite			; Fade to white
000023DC                            ;
000023DC                            ;		intsOff
000023DC                            ;		bsr.w	ClearScreen			; Clear screen
000023DC                            ;
000023DC                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
000023DC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023DC                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023DC                            ;		bsr.w	EniDec				; Decompress!
000023DC                            ;
000023DC                            ;		lea	rBuffer,a1			; Load mappings
000023DC                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
000023DC                            ;		moveq	#$27,d1				; $28x$1C tiles
000023DC                            ;		moveq	#$1B,d2				; ''
000023DC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023DC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023DC                            ;
000023DC                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
000023DC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023DC                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
000023DC                            ;		bsr.w	EniDec				; Decompress!
000023DC                            ;
000023DC                            ;		lea	rBuffer,a1			; Load mappings
000023DC                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
000023DC                            ;		moveq	#$E,d1				; $28x$1C tiles
000023DC                            ;		moveq	#$C,d2				; ''
000023DC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023DC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023DC                            ;
000023DC                            ;		lea	Pal_Title,a0			; Load palette to target buffer
000023DC                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
000023DC                            ;		bsr.w	LoadTargetPal			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
000023DC                            ;		move.w	#$20,d2				; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
000023DC                            ;		move.w	#$6E00,d2			; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
000023DC                            ;		move.w	#$4000,d2			; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
000023DC                            ;		move.w	#$8400,d2			; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
000023DC                            ;		move.w	#$8600,d2			; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;.WaitPLCs:
000023DC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023DC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023DC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023DC                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023DC                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023DC                            ;		bne.s	.WaitPLCs			; If so, branch
000023DC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023DC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023DC                            ;		
000023DC                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
000023DC                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
000023DC                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
000023DC                            ;
000023DC                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
000023DC                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
000023DC                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
000023DC                            ;
000023DC                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
000023DC                            ;		move.w	#224,(rObj_2+oX).w		; Set X
000023DC                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
000023DC                            ;
000023DC                            ;		jsr	RunObjects.w			; Run objects
000023DC                            ;		jsr	RenderObjects.w			; Render objects
000023DC                            ;
000023DC                            ;		clr.w	rPalCycTimer.w		; Reset palette cycle
000023DC                            ;
000023DC                            ;		bsr.w	FadeFromWhite			; Fade from white
000023DC                            ;
000023DC                            ;		lea	SampleList+$C0,a3		; Play title screen music
000023DC                            ;		jsr	PlayDAC1			; ''
000023DC                            ;
000023DC                            ;.Loop:
000023DC                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023DC                            ;		bsr.w	VSync_Routine			; ''
000023DC                            ;
000023DC                            ;		bsr.s	Title_Updates			; Do updates
000023DC                            ;		
000023DC                            ;		jsr	RunObjects.w			; Run objects
000023DC                            ;		jsr	RenderObjects.w			; Render objects
000023DC                            ;
000023DC                            ;		lea	FreeMove_Cheat(pc),a0
000023DC                            ;		lea	rMoveCheat.w,a1
000023DC                            ;		lea	rCheatEntry.w,a2
000023DC                            ;		bsr.w	Title_ChkCheats
000023DC                            ;		lea	Art_Cheat(pc),a0
000023DC                            ;		lea	rArtCheat.w,a1
000023DC                            ;		lea	rCheatEntry2.w,a2
000023DC                            ;		bsr.w	Title_ChkCheats
000023DC                            ;
000023DC                            ;		tst.b	rArtCheat.w
000023DC                            ;		bne.w	BinbowieArt
000023DC                            ;
000023DC                            ;		tst.b	rP1Press.w			; Has start been pressed
000023DC                            ;		bpl.s	.Loop				; If so, branch
000023DC                            ;
000023DC                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
000023DC                            ;
000023DC                            ;		lea	SampleList+$E0,a3		; Punch
000023DC                            ;		jsr	PlayDAC1			; ''
000023DC                            ;
000023DC                            ;.PunchLoop:
000023DC                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023DC                            ;		bsr.w	VSync_Routine			; ''
000023DC                            ;
000023DC                            ;		bsr.s	Title_Updates			; Do updates
000023DC                            ;
000023DC                            ;		jsr	RunObjects.w			; Run objects
000023DC                            ;		jsr	RenderObjects.w			; Render objects
000023DC                            ;		
000023DC                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
000023DC                            ;		bpl.s	.PunchLoop			; If not, loop
000023DC                            ;		
000023DC                            ;		st	rStartFall.w			; Set flag to start the level by falling
000023DC                            ;
000023DC                            ;		move.b	#gLevel,rGameMode.w		; Set game mode to "level"
000023DC                            ;		jmp	Level				; Go to level
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Palette cycle
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;Title_Updates:
000023DC                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
000023DC                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
000023DC                            ;		jsr	CalcSine.w			; Get sine
000023DC                            ;		asr.w	#5,d0				; ''
000023DC                            ;		move.w	d0,rVScrollFG.w		; Set logo's Y position
000023DC                            ;
000023DC                            ;		subq.b	#1,rPalCycTimer.w		; Decrement timer
000023DC                            ;		bpl.s	.End				; If it hasn't run out, branch
000023DC                            ;		move.b	#6,rPalCycTimer.w		; Reset timer
000023DC                            ;		
000023DC                            ;		moveq	#0,d0
000023DC                            ;		move.b	rPalCycIndex.w,d0		; Get index
000023DC                            ;		mulu.w	#$C,d0				; Turn into offset
000023DC                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
000023DC                            ;		lea	(rPalette+$14).w,a1		; Palette
000023DC                            ;		move.w	(a0)+,(a1)+			; Load palette
000023DC                            ;		move.w	(a0)+,(a1)+			; ''
000023DC                            ;		move.w	(a0)+,(a1)+			; ''
000023DC                            ;		move.w	(a0)+,(a1)+			; ''
000023DC                            ;		move.w	(a0)+,(a1)+			; ''
000023DC                            ;		move.w	(a0)+,(a1)+			; ''
000023DC                            ;		
000023DC                            ;		addq.b	#1,rPalCycIndex.w		; Increment index
000023DC                            ;		cmpi.b	#6,rPalCycIndex.w		; Has it reached the end?
000023DC                            ;		bcs.s	.End				; If not, branch
000023DC                            ;		clr.b	rPalCycIndex.w		; Reset index
000023DC                            
000023DC                            ;.End:
000023DC                            ;		rts
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;PalCyc_Title:
000023DC                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
000023DC                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
000023DC                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
000023DC                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
000023DC                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
000023DC                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Check for cheats
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;Title_ChkCheats:
000023DC                            ;		tst.b	(a1)
000023DC                            ;		bne.s	.End
000023DC                            ;		move.w	(a2),d0
000023DC                            ;		adda.w	d0,a0
000023DC                            ;		move.b	rP1Press.w,d0
000023DC                            ;		cmp.b	(a0),d0
000023DC                            ;		bne.s	.ResetCheat
000023DC                            ;		addq.w	#1,(a2)
000023DC                            ;		tst.b	d0
000023DC                            ;		bne.s	.End
000023DC                            ;		st	(a1)
000023DC                            ;		playSnd	#sRing, 2
000023DC                            ;		rts
000023DC                            ;
000023DC                            ;.ResetCheat:
000023DC                            ;		tst.b	d0
000023DC                            ;		beq.s	.End
000023DC                            ;		clr.w	(a2)
000023DC                            ;
000023DC                            ;.End:
000023DC                            ;		rts
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;FreeMove_Cheat:
000023DC                            ;		dc.b	1, 2, 4, 8, 0, $FF
000023DC                            ;		even
000023DC                            ;Art_Cheat:
000023DC                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
000023DC                            ;		even
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; BinBowie's art
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;BinbowieArt:
000023DC                            ;		bsr.w	FadeToWhite			; Fade to white
000023DC                            ;		
000023DC                            ;		lea	SampleList,a3
000023DC                            ;		jsr	PlayDAC1
000023DC                            ;
000023DC                            ;		intsOff
000023DC                            ;
000023DC                            ;		jsr	ClearScreen.w
000023DC                            ;
000023DC                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
000023DC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023DC                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023DC                            ;		bsr.w	EniDec				; Decompress!
000023DC                            ;
000023DC                            ;		lea	rBuffer,a1			; Load mappings
000023DC                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
000023DC                            ;		moveq	#$27,d1				; $28x$1C tiles
000023DC                            ;		moveq	#$1B,d2				; ''
000023DC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023DC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023DC                            ;
000023DC                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
000023DC                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
000023DC                            ;		bsr.w	LoadTargetPal			; ''
000023DC                            ;
000023DC                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
000023DC                            ;		move.w	#$20,d2				; ''
000023DC                            ;		bsr.w	QueueKosMData			; ''
000023DC                            ;
000023DC                            ;.WaitPLCs:
000023DC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023DC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023DC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023DC                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023DC                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023DC                            ;		bne.s	.WaitPLCs			; If so, branch
000023DC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023DC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023DC                            ;
000023DC                            ;		jsr	FadeFromWhite.w
000023DC                            ;
000023DC                            ;		lea	SampleList+$100,a3
000023DC                            ;		jsr	PlayDAC1
000023DC                            ;
000023DC                            ;.Loop:
000023DC                            ;		move.b	#vTitle,rVINTRout.w		; Level load V-INT routine
000023DC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023DC                            ;		move.b	rP1Press.w,d0
000023DC                            ;		andi.b	#%10010000,d0
000023DC                            ;		beq.s	.Loop
000023DC                            ;
000023DC                            ;		jmp	TitleScreen2
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Objects
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
000023DC                            ;		include	"Title Screen/Objects/Bird/Code.asm"
000023DC                            ;		include	"Title Screen/Objects/Glove/Code.asm"
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Art
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;ArtKosM_TitleBG:
000023DC                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
000023DC                            ;		even
000023DC                            ;ArtKosM_TitleLogo:
000023DC                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
000023DC                            ;		even
000023DC                            ;ArtKosM_BinBowieArt:
000023DC                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
000023DC                            ;		even
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Plane mappings
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;MapEni_TitleBG:
000023DC                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
000023DC                            ;		even
000023DC                            ;MapEni_TitleLogo:
000023DC                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
000023DC                            ;		even
000023DC                            ;MapEni_BinBowieArt:
000023DC                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
000023DC                            ;		even
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Palette
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;Pal_Title:
000023DC                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
000023DC                            ;Pal_Title_End:
000023DC                            ;		even
000023DC                            ;Pal_BinBowieArt:
000023DC                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
000023DC                            ;Pal_BinBowieArt_End:
000023DC                            ;		even
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; SEGA FMV
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
000023DC                            ; =========================================================================================================================================================
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Level
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            		include	"Level/Main.asm"
000023DC                            ; =========================================================================================================================================================
000023DC                            ; Mighty The Armadillo in PRISM PARADISE
000023DC                            ; By Nat The Porcupine 2021
000023DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023DC                            ; Level
000023DC                            ; =========================================================================================================================================================
000023DC                            Level:
000023DC                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
000023DC 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
000023E2                            
000023E2 4EB8 04D6                  		jsr	FadeToBlack			; Fade to black
000023E6                            
000023E6                            Level_NoFade:
000023E6                            		; --- Set up the VDP ---
000023E6                            
000023E6                            		intsOff					; Disable interrupts
000023E6 007C 0700                M 	ori	#$700,sr
000023EA                            		displayOff				; Disable display
000023EA 3038 C764                M 	move.w	rvdpreg1.w,d0
000023EE 0200 00BF                M 	andi.b	#%10111111,d0
000023F2 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000023F8                            
000023F8 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
000023FE 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
00002402 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
00002406 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
0000240A 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
0000240E 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
00002412 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
00002416 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
0000241A 31C0 C766                  		move.w	d0,rWindowY.w			; ''
0000241E 3A80                       		move.w	d0,(a5)				; ''
00002420 4278 9000                  		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002424 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0000242A                            
0000242A 4EB8 01CC                  		jsr	ClearScreen.w			; Clear the screen
0000242E                            
0000242E                            		; --- Clear some RAM ---
0000242E                            
0000242E                            		clrRAM	rKosPVars			; Clear Kosinski queue variables
0000242E                          M 	local	endaddr
0000242E                          M endaddr	equs	"rkospvars_End"
0000242E 7000                     M 	moveq	#0,d0
00002430 43F8 994E                M 	lea	(rkospvars).w,a1
00002434 323C 0040                M 	move.w	#(((rkospvars_end)-(rkospvars))-((rkospvars)&1))>>2-1,d1
00002438 22C0                     M .clear_130:	move.l	d0,(a1)+
0000243A 51C9 FFFC                M 	dbf	d1,.clear_130
0000243E 32C0                     M 	move.w	d0,(a1)+
00002440                            		clrRAM	rGameVars			; Clear variables
00002440                          M 	local	endaddr
00002440                          M endaddr	equs	"rgamevars_End"
00002440 7000                     M 	moveq	#0,d0
00002442 43F8 C7D0                M 	lea	(rgamevars).w,a1
00002446 323C 0DCB                M 	move.w	#(((rgamevars_end)-(rgamevars))-((rgamevars)&1))>>2-1,d1
0000244A 22C0                     M .clear_131:	move.l	d0,(a1)+
0000244C 51C9 FFFC                M 	dbf	d1,.clear_131
00002450                            		clrRAM	rOscNums			; Clear oscillation data
00002450                          M 	local	endaddr
00002450                          M endaddr	equs	"roscnums_End"
00002450 7000                     M 	moveq	#0,d0
00002452 43F8 C76A                M 	lea	(roscnums).w,a1
00002456 323C 000F                M 	move.w	#(((roscnums_end)-(roscnums))-((roscnums)&1))>>2-1,d1
0000245A 22C0                     M .clear_132:	move.l	d0,(a1)+
0000245C 51C9 FFFC                M 	dbf	d1,.clear_132
00002460 32C0                     M 	move.w	d0,(a1)+
00002462                            
00002462                            		; --- Do some final initializing and play the level music ---
00002462                            
00002462 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Set ring animation timer
00002468 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set floor timer
0000246E 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset palette cycle
00002472                            
00002472 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002476 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
0000247A E218                       		ror.b	#1,d0				; Turn into offset
0000247C EE48                       		lsr.w	#7,d0				; ''
0000247E 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
00002482 11C0 F8D6                  		move.b	d0,rLevelMusic.w		; Store it
00002486                            		playSnd	d0, 1				; Play it
00002486 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
0000248A                            
0000248A                            		intsOn					; Enable interrupts
0000248A 027C F8FF                M 	andi	#$f8ff,sr
0000248E                            
0000248E                            		; --- Load level data ---
0000248E                            
0000248E 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
00002494 4EB8 0EE0                  		jsr	LoadKosMQueue.w			; ''
00002498                            
00002498 4EB8 1952                  		jsr	InitObjectList.w
0000249C                            
0000249C 4EB8 19B0                  		jsr	FindFreeObj.w
000024A0 22BC 0000 0000             		move.l	#ObjMighty,oAddr(a1)		; Load Mighty object
000024A6 31C9 F86C                  		move.w	a1,rPlayer1Addr.w		; Store the address
000024AA                            
000024AA 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
000024AE 6700                       		beq.s	.NoSurface			; If not, branch
000024B0                            
000024B0                            							; Load water surfaces
000024B0 4EB8 19B0                  		jsr	FindFreeObj.w
000024B4 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024BA 337C 0060 0014             		move.w	#$60,oXPos(a1)
000024C0 31C9 F87C                  		move.w	a1,rWater1Addr.w		; Store the address
000024C4                            
000024C4 4EB8 19B0                  		jsr	FindFreeObj.w
000024C8 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024CE 337C 0120 0014             		move.w	#$120,oXPos(a1)
000024D4 31C9 F87E                  		move.w	a1,rWater2Addr.w		; Store the address
000024D8                            
000024D8                            .NoSurface:
000024D8 6100 0000                  		bsr.w	Level_LoadData			; Load level data
000024DC                            
000024DC                            .WaitPLCs:
000024DC 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000024E2 4EB8 1096                  		jsr	ProcessKos.w			; Process Kosinski queue
000024E6 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
000024EA 4EB8 0F42                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000024EE 4A38 9990                  		tst.b	rKosPMMods.w			; Are there still modules left?
000024F2 66E8                       		bne.s	.WaitPLCs			; If so, branch
000024F4                            
000024F4 4238 F8F4                  		clr.b	rWaterFlag.w			; Clear the water flag
000024F8                            
000024F8 41FA 0000                  		lea	Level_WaterLevels(pc),a0	; Water heights
000024FC 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002500 E218                       		ror.b	#1,d0				; Turn into offset
00002502 EC48                       		lsr.w	#6,d0				; ''
00002504 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
00002508 6B00                       		bmi.s	.NoWater			; If it's negative, branch
0000250A 31C0 F8F6                  		move.w	d0,rWaterLvl.w		; Set the water height
0000250E 31C0 F8F8                  		move.w	d0,rDestWtrLvl.w
00002512                            
00002512 50F8 F8F4                  		st	rWaterFlag.w			; Set the water flag
00002516 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
0000251E 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002522 33F8 C75E 00C0 0004        		move.w	rHIntReg.w,VDP_CTRL		; Set H-INT counter
0000252A                            
0000252A                            .NoWater:
0000252A 31FC 00A0 F8D2             		move.w	#320/2,rCamXPosCenter.w		; Set camera X center
00002530                            
00002530 4EB8 1878                  		jsr	InitOscillation.w		; Initialize oscillation
00002534                            
00002534 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
00002538 6100 0000                  		bsr.w	Level_InitHUD			; Initialize the HUD
0000253C 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
00002540                            
00002540 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002544                            
00002544                            		; --- Load the planes ---
00002544                            
00002544                            		intsOff					; Disable interrupts
00002544 007C 0700                M 	ori	#$700,sr
00002548 21FC 0000 23A6 C74C        		move.l	#VInt_RunSMPS,rVIntAddr.w	; Swap V-INT
00002550                            		intsOn					; Enable interrupts
00002550 027C F8FF                M 	andi	#$f8ff,sr
00002554 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
00002558                            		intsOff					; Disable interrupts
00002558 007C 0700                M 	ori	#$700,sr
0000255C 21FC 0000 210C C74C        		move.l	#VInt_Standard,rVIntAddr.w	; Swap V-INT
00002564                            		intsOn					; Enable interrupts
00002564 027C F8FF                M 	andi	#$f8ff,sr
00002568 11FC 0006 C745             		move.b	#vLvlLoad,rVINTRout.w		; Level load V-INT routine
0000256E 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
00002572                            
00002572                            		; --- Load the level objects and rings ---
00002572                            
00002572 51F8 C7B8                  		sf	rObjManInit.w			; Reset object manager routine
00002576 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
0000257A 4EB8 1D4C                  		jsr	ObjectManager.w			; Run the object manager
0000257E                            	runObjects
0000257E 3078 BE58                M 	movea.w	rtailnext.w,a0
00002582 2250                     M 	move.l	oaddr(a0),a1
00002584 4E91                     M 	jsr	(a1)
00002586 4EB8 1A4E                  		jsr	RenderObjects.w			; Render objects
0000258A                            
0000258A 4238 F8FC                  		clr.b	rLvlReload.w			; Clear the level reload flag
0000258E                            
0000258E                            		displayOn				; Enable display
0000258E 3038 C764                M 	move.w	rvdpreg1.w,d0
00002592 0000 0040                M 	ori.b	#%01000000,d0
00002596 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
0000259C 4EB8 0552                  		jsr	FadeFromBlack.w			; Fade from black
000025A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000025A0                            ; Main loop
000025A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000025A0                            .Loop:
000025A0 11FC 0004 C745             		move.b	#vLevel,rVINTRout.w		; Level V-INT routine
000025A6 4EB8 1096                  		jsr	ProcessKos.w			; Process Kosinski queue
000025AA 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
000025AE                            
000025AE 4EB8 20D6                  		jsr	CheckPause.w			; Check for pausing
000025B2 5278 F8FA                  		addq.w	#1,rLvlFrames.w			; Increment frame counter
000025B6                            
000025B6 4EB8 18CC                  		jsr	UpdateOscillation.w		; Update oscillation
000025BA                            
000025BA 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
000025BE 4EB8 1D4C                  		jsr	ObjectManager.w			; Run the object manager
000025C2                            
000025C2                            	runObjects
000025C2 3078 BE58                M 	movea.w	rtailnext.w,a0
000025C6 2250                     M 	move.l	oaddr(a0),a1
000025C8 4E91                     M 	jsr	(a1)
000025CA                            
000025CA 4A38 F8FC                  		tst.b	rLvlReload.w			; Does the level need to be reloaded?
000025CE 6600 FE0C                  		bne.w	Level				; If so, branch
000025D2                            
000025D2 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
000025D6 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
000025DA 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
000025DE                            
000025DE 4EB8 1A4E                  		jsr	RenderObjects.w			; Render objects
000025E2                            
000025E2 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000025E6 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025EA 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
000025EE 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
000025F2                            
000025F2 5338 F3D8                  		subq.b	#1,rRingAniTime.w		; Decrement ring animation timer
000025F6 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
000025F8 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Reset animation timer
000025FE 5238 F3D7                  		addq.b	#1,rRingFrame.w			; Next ring frame
00002602 0238 0007 F3D7             		andi.b	#7,rRingFrame.w			; Limit it
00002608                            
00002608 7000                       		moveq	#0,d0
0000260A 1038 F3D7                  		move.b	rRingFrame.w,d0			; Get ring frame
0000260E EF48                       		lsl.w	#7,d0				; Convert to offset
00002610 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002616 D280                       		add.l	d0,d1				; ''
00002618 343C D780                  		move.w	#$D780,d2			; VRAM address
0000261C 363C 0040                  		move.w	#$80/2,d3			; Size
00002620 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002624                            
00002624                            .NoRingAni:
00002624 4A38 F3D9                  		tst.b	rRLossAniT.w
00002628 6700                       		beq.s	.NoRingLossAni
0000262A 7000                       		moveq	#0,d0
0000262C 1038 F3D9                  		move.b	rRLossAniT.w,d0
00002630 D078 F3DA                  		add.w	rRLossAniA.w,d0
00002634 31C0 F3DA                  		move.w	d0,rRLossAniA.w
00002638 E158                       		rol.w	#8,d0
0000263A 0240 0007                  		andi.w	#7,d0
0000263E 11C0 F3DC                  		move.b	d0,rRLossAniF.w
00002642 5338 F3D9                  		subq.b	#1,rRLossAniT.w
00002646                            
00002646 7000                       		moveq	#0,d0
00002648 1038 F3DC                  		move.b	rRLossAniF.w,d0		; Get ring frame
0000264C EF48                       		lsl.w	#7,d0				; Convert to offset
0000264E 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002654 D280                       		add.l	d0,d1				; ''
00002656 343C D680                  		move.w	#$D680,d2			; VRAM address
0000265A 363C 0040                  		move.w	#$80/2,d3			; Size
0000265E 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002662                            
00002662                            .NoRingLossAni:
00002662 4EB8 0F42                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002666                            
00002666 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Is the game mode level?
0000266C 6700 FF32                  		beq.w	.Loop				; If so, branch
00002670 4EF8 20BE                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            ; Level functions
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            		include	"Level/Level Drawing.asm"
00002674                            ; =========================================================================================================================================================
00002674                            ; Mighty The Armadillo in PRISM PARADISE
00002674                            ; By Nat The Porcupine 2021
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002674                            ; =========================================================================================================================================================
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            ; Initialize the planes
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            ; PARAMETERS:
00002674                            ;	Nothing
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            ; RETURNS:
00002674                            ;	Nothing
00002674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002674                            Level_InitPlanes:
00002674 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002678 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
0000267C 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
00002680                            
00002680 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002688 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
0000268C                            		
0000268C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002690 E218                       		ror.b	#1,d0				; Turn into offset
00002692 E648                       		lsr.w	#3,d0				; ''
00002694 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
0000269A 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000026A0 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000026A4 4E90                       		jsr	(a0)				; Jump to it
000026A6                            
000026A6 31E9 0008 947E             		move.w	cYPos(a1),rVScrollFG.w		; Set the V-Scroll value for the foreground
000026AC                            
000026AC 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
000026B0 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
000026B4 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000026B8                            		
000026B8 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
000026C0 337C 0080 0016             		move.w	#$80,cLayout(a1)		; Set the offset for the level layout (background)
000026C6                            		
000026C6 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000026CA E218                       		ror.b	#1,d0				; Turn into offset
000026CC E648                       		lsr.w	#3,d0				; ''
000026CE 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
000026D4 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000026DA 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000026DE 4E90                       		jsr	(a0)				; Jump to it
000026E0                            
000026E0 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
000026E6 4E75                       		rts
000026E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026E8                            ; Update the planes
000026E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026E8                            Level_UpdatePlanes:
000026E8 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
000026EC 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
000026F0 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
000026F4                            		
000026F4 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000026F8 4E90                       		jsr	(a0)				; Jump to it
000026FA                            		
000026FA 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
000026FE 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
00002702 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
00002706                            
00002706 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
0000270A 4E90                       		jsr	(a0)				; Jump to it
0000270C                            
0000270C 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
00002710 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002714 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
0000271A 31EA 0008 947E             		move.w	cYPos(a2),rVScrollFG.w		; Set the V-Scroll value for the foreground
00002720 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002724 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
0000272A 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
00002730                            
00002730 4E75                       		rts
00002732                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002732                            ; General foreground initialization
00002732                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002732                            General_InitFG:
00002732 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002736                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002736                            ; General background initialization
00002736                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002736                            General_InitBG:
00002736 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
0000273A 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
0000273C E240                       		asr.w	#1,d0				; Divide by 2
0000273E 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002740 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002744 E240                       		asr.w	#1,d0				; Divide by 2
00002746 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000274A                            
0000274A 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
0000274E                            		
0000274E 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002752                            ; General foreground update
00002752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002752                            General_UpdateFG:
00002752 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002756                            		
00002756 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002758 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000275A 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
0000275E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000275E                            ; General background update
0000275E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000275E                            General_UpdateBG:
0000275E 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
00002762 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002764 E240                       		asr.w	#1,d0				; Divide by 2
00002766 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002768 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
0000276C E240                       		asr.w	#1,d0				; Divide by 2
0000276E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002772                            
00002772 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002776 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002778 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000277A 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
0000277E                            		
0000277E 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            ; Draw new tiles in the level
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            ; PARAMETERS:
00002782                            ;	a1.l	- Camera RAM
00002782                            ;	a2.l	- Plane buffer for columns
00002782                            ;	a3.l	- Plane buffer for rows
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            ; RETURNS:
00002782                            ;	Nothing
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            VInt_DrawLevel:
00002782 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002786 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
0000278A                            
0000278A 3013                       		move.w	(a3),d0				; Get high VDP command word
0000278C 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
00002790 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
00002792 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002796                            
00002796                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002796                            
00002796 3200                       		move.w	d0,d1				; Save high VDP command
00002798 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
0000279A 7C00                       		moveq	#0,d6
0000279C 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
000027A0 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027A2                            
000027A2 3C80                       		move.w	d0,(a6)				; Set VDP command
000027A4 3C84                       		move.w	d4,(a6)				; ''
000027A6 6000                       		bra.s	.DrawCol1_1_Start		; Start
000027A8                            
000027A8                            .DrawCol1_1_Loop:
000027A8 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027AA                            
000027AA                            .DrawCol1_1_Start:
000027AA 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
000027AE                            
000027AE 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000027B0 0642 007C                  		addi.w	#$7C,d2				; ''
000027B4 C042                       		and.w	d2,d0				; ''
000027B6                            
000027B6 3C80                       		move.w	d0,(a6)				; Set VDP command
000027B8 3C84                       		move.w	d4,(a6)				; ''
000027BA                            
000027BA                            .DrawCol1_2_Loop:
000027BA 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027BC 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
000027C0                            
000027C0                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
000027C0                            
000027C0 5441                       		addq.w	#2,d1				; Move over to the right
000027C2 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
000027C4 7C00                       		moveq	#0,d6
000027C6 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
000027CA 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027CC                            
000027CC 3C81                       		move.w	d1,(a6)				; Set VDP command
000027CE 3C84                       		move.w	d4,(a6)				; ''
000027D0 6000                       		bra.s	.DrawCol2_1_Start		; Start
000027D2                            
000027D2                            .DrawCol2_1_Loop:
000027D2 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027D4                            
000027D4                            .DrawCol2_1_Start:
000027D4 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
000027D8                            
000027D8 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000027DA 0642 007E                  		addi.w	#$7E,d2				; ''
000027DE C242                       		and.w	d2,d1				; ''
000027E0                            
000027E0 3C81                       		move.w	d1,(a6)				; Set VDP command
000027E2 3C84                       		move.w	d4,(a6)				; ''
000027E4                            
000027E4                            .DrawCol2_2_Loop:
000027E4 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027E6 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
000027EA                            
000027EA 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
000027EE 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
000027F0                            
000027F0                            VInt_DrawLvlRows:
000027F0 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
000027F4 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
000027F8                            
000027F8                            VInt_DrawLvlRows2:
000027F8 3014                       		move.w	(a4),d0				; Get high VDP command
000027FA 6700 0000                  		beq.w	.End				; If it's 0, branch
000027FE 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
00002800                            		
00002800                            		; --- DRAW THE FIRST HALF OF THE ROW ---
00002800                            
00002800 3200                       		move.w	d0,d1				; Save high VDP command
00002802 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002804 7C00                       		moveq	#0,d6
00002806 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
0000280A 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000280C                            
0000280C 3C80                       		move.w	d0,(a6)				; Set VDP command
0000280E 3C84                       		move.w	d4,(a6)				; ''
00002810 6000                       		bra.s	.DrawRow1_1_Start		; Start
00002812                            
00002812                            .DrawRow1_1_Loop:
00002812 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002814                            
00002814                            .DrawRow1_1_Start:
00002814 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002818                            
00002818 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
0000281A 0642 0F00                  		addi.w	#$F00,d2			; ''
0000281E C042                       		and.w	d2,d0				; ''
00002820                            
00002820 3C80                       		move.w	d0,(a6)				; Set VDP command
00002822 3C84                       		move.w	d4,(a6)				; ''
00002824                            
00002824                            .DrawRow1_2_Loop:
00002824 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002826 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
0000282A                            
0000282A                            		; --- DRAW THE SECOND HALF OF THE ROW ---
0000282A                            
0000282A 0641 0080                  		addi.w	#$80,d1				; Move over down
0000282E 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002830 7C00                       		moveq	#0,d6
00002832 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002836 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002838                            
00002838 3C81                       		move.w	d1,(a6)				; Set VDP command
0000283A 3C84                       		move.w	d4,(a6)				; ''
0000283C 6000                       		bra.s	.DrawRow2_1_Start		; Start
0000283E                            
0000283E                            .DrawRow2_1_Loop:
0000283E 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002840                            
00002840                            .DrawRow2_1_Start:
00002840 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002844                            
00002844 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002846 0642 0F80                  		addi.w	#$F80,d2			; ''
0000284A C242                       		and.w	d2,d1				; ''
0000284C                            
0000284C 3C81                       		move.w	d1,(a6)				; Set VDP command
0000284E 3C84                       		move.w	d4,(a6)				; ''
00002850                            
00002850                            .DrawRow2_2_Loop:
00002850 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002852 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002856                            
00002856                            .End:
00002856 4E75                       		rts
00002858                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002858                            ; Handle plane drawing
00002858                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002858                            ; PARAMETERS:
00002858                            ;	d4.w	- Number of blocks per column
00002858                            ;	d5.w	- Number of blocks per row
00002858                            ;	a1.l	- Camera variables
00002858                            ;	a2.l	- Layout pointer
00002858                            ;	a3.l	- Column plane buffer
00002858                            ;	a4.l	- Row plane buffer
00002858                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002858                            ; RETURNS:
00002858                            ;	Nothing
00002858                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002858                            Level_UpdatePlane:
00002858                            		push.l	d5/a4				; Push row plane buffer address
00002858 48E7 0408                M 	movem.l	d5/a4,-(sp)
0000285C 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
0000285E                            		pop.l	d5/a4				; Restore row plane buffer address
0000285E 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002862 3805                       		move.w	d5,d4				; Number of blocks per column
00002864                            		; Continue to update the plane vertically
00002864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002864                            ; Handle plane drawing (vertical redrawing only)
00002864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002864                            ; PARAMETERS:
00002864                            ;	d4.w	- Number of blocks per row
00002864                            ;	a1.l	- Camera variables
00002864                            ;	a4.l	- Row plane buffer
00002864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002864                            ; RETURNS:
00002864                            ;	Nothing
00002864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002864                            Level_UpdatePlaneY:
00002864 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002868 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
0000286C 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002870 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002874                            		
00002874 9240                       		sub.w	d0,d1				; Get distance travelled
00002876 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002878 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
0000287A                            		
0000287A                            .DrawUp:
0000287A 3011                       		move.w	cXPos(a1),d0			; Get X
0000287C 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002880 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002884                            
00002884                            .DrawDown:
00002884 3011                       		move.w	cXPos(a1),d0			; Get X
00002886 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
0000288A 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
0000288E 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002892                            
00002892                            .End:
00002892 4E75                       		rts
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; Handle plane drawing (horizontal redrawing only)
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; PARAMETERS:
00002894                            ;	d4.w	- Number of blocks per column
00002894                            ;	a1.l	- Camera variables
00002894                            ;	a3.l	- Column plane buffer
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            ; RETURNS:
00002894                            ;	Nothing
00002894                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002894                            Level_UpdatePlaneX:
00002894 3011                       		move.w	cXPos(a1),d0			; Get X
00002896 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
0000289A 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
0000289E 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
000028A2                            		
000028A2 9240                       		sub.w	d0,d1				; Get distance travelled
000028A4 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
000028A6 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
000028A8                            		
000028A8                            .DrawLeft:
000028A8 3011                       		move.w	cXPos(a1),d0			; Get X
000028AA 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
000028AE 6000 0000                  		bra.w	Level_GetCol			; Draw a column
000028B2                            		
000028B2                            .DrawRight:
000028B2 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
000028B6 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
000028BA 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
000028BE 6000 0000                  		bra.w	Level_GetCol			; Draw a column
000028C2                            
000028C2                            .End:
000028C2 4E75                       		rts
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; Macro to calculate the high VDP command word for the plane buffer
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; PARAMETERS:
000028C4                            ;	a1.l	- Camera variables
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; RETURNS:
000028C4                            ;	d2.w	- The high VDP command word
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            calcHiVDP	macro
000028C4                            		move.w	d0,d2				; Copy X
000028C4                            		move.w	d1,d3				; Copy Y
000028C4                            		lsl.w	#4,d3				; Multiply Y by $10
000028C4                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000028C4                            		lsr.w	#2,d2				; Divide X by 4
000028C4                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000028C4                            		add.w	d3,d2				; Add Y onto X
000028C4                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
000028C4                            		endm
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; Macro to get an address in chunk data relative to a position
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; PARAMETERS:
000028C4                            ;	d1.l	- $FFFFXXXX
000028C4                            ;	a2.l	- Layout data
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; RETURNS:
000028C4                            ;	a6.l	- Pointer in chunk data to the correct block
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            getChunk	macro
000028C4                            		move.b	(a2,d0.w),d1			; Get chunk ID
000028C4                            		andi.w	#$FF,d1				; ''
000028C4                            		lsl.w	#7,d1				; Turn into offset
000028C4                            		movea.l	d1,a6				; Store into a6
000028C4                            		endm
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; Get a block row and store it in a plane buffer
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; PARAMETERS:
000028C4                            ;	d0.w	- X position
000028C4                            ;	d1.w	- Y position
000028C4                            ;	d4.w	- Number of blocks to draw (minus 1)
000028C4                            ;	a1.l	- Camera variables
000028C4                            ;	a4.l	- Row plane buffer
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            ; RETURNS:
000028C4                            ;	Nothing
000028C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028C4                            Level_GetRow:
000028C4 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
000028C8 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
000028CC 47F8 C7D0                  		lea	rBlocks.w,a3			; Get block table address
000028D0 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
000028D4                            
000028D4                            		calcHiVDP				; Get high VDP command word
000028D4 3400                     M 	move.w	d0,d2
000028D6 3601                     M 	move.w	d1,d3
000028D8 E94B                     M 	lsl.w	#4,d3
000028DA 0243 0F00                M 	andi.w	#$f00,d3
000028DE E44A                     M 	lsr.w	#2,d2
000028E0 0242 007C                M 	andi.w	#$7c,d2
000028E4 D443                     M 	add.w	d3,d2
000028E6 8469 0012                M 	or.w	cvdp(a1),d2
000028EA 38C2                       		move.w	d2,(a4)+			; Store it
000028EC                            
000028EC 3400                       		move.w	d0,d2				; Get X
000028EE E44A                       		lsr.w	#2,d2				; Divide X by 4
000028F0 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000028F4 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
000028F8 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
000028FA 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
000028FE E44D                       		lsr.w	#2,d5				; Divide by 4
00002900 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
00002904                            		
00002904 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002906 3400                       		move.w	d0,d2				; ''
00002908 0242 000E                  		andi.w	#$E,d2				; ''
0000290C E848                       		lsr.w	#4,d0				; Get X within layout data
0000290E 0240 007F                  		andi.w	#$7F,d0				;''
00002912 3601                       		move.w	d1,d3				; Get Y within chunk data
00002914 0243 0070                  		andi.w	#$70,d3				; ''
00002918 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
0000291A                            
0000291A 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
0000291E D241                       		add.w	d1,d1				; ''
00002920 D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
00002922                            
00002922 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002924                            		getChunk				; Get chunk pointer at current location
00002924 1232 0000                M 	move.b	(a2,d0.w),d1
00002928 0241 00FF                M 	andi.w	#$ff,d1
0000292C EF49                     M 	lsl.w	#7,d1
0000292E 2C41                     M 	movea.l	d1,a6
00002930                            
00002930                            .DrawBlock_Loop:
00002930 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002934 3C05                       		move.w	d5,d6				; ''
00002936 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
0000293A E74D                       		lsl.w	#3,d5				; Get offset in block data
0000293C                            		
0000293C 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002940 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002944                            
00002944 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002948 6700                       		beq.s	.ChkYFlip			; If not, branch
0000294A 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002950 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002956 4847                       		swap	d7				; ''
00002958 4845                       		swap	d5				; ''
0000295A                            
0000295A                            .ChkYFlip:
0000295A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
0000295E 6700                       		beq.s	.DrawBlock			; If not, branch
00002960 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002966 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
0000296C CB47                       		exg.l	d7,d5				; ''
0000296E                            
0000296E                            .DrawBlock:
0000296E 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002970 2AC5                       		move.l	d5,(a5)+			; ''
00002972                            
00002972 5442                       		addq.w	#2,d2				; Go to the next block
00002974 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002978 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
0000297A 5240                       		addq.w	#1,d0				; Next chunk
0000297C                            		getChunk				; ''
0000297C 1232 0000                M 	move.b	(a2,d0.w),d1
00002980 0241 00FF                M 	andi.w	#$ff,d1
00002984 EF49                     M 	lsl.w	#7,d1
00002986 2C41                     M 	movea.l	d1,a6
00002988                            
00002988                            .DrawBlock_Cont:
00002988 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
0000298A 51CC FFA4                  		dbf	d4,.DrawBlock_Loop		; Loop
0000298E                            
0000298E 4E75                       		rts
00002990                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002990                            ; Get a block column and store it in a plane buffer
00002990                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002990                            ; PARAMETERS:
00002990                            ;	d0.w	- X position
00002990                            ;	d1.w	- Y position
00002990                            ;	d4.w	- Number of blocks to draw (minus 1)
00002990                            ;	a1.l	- Camera RAM
00002990                            ;	a3.l	- Column plane buffer
00002990                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002990                            ; RETURNS:
00002990                            ;	Nothing
00002990                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002990                            Level_GetCol:
00002990 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002994 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002998 49F8 C7D0                  		lea	rBlocks.w,a4			; Get block table address
0000299C 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
000029A0                            		
000029A0                            		calcHiVDP				; Get high VDP command word
000029A0 3400                     M 	move.w	d0,d2
000029A2 3601                     M 	move.w	d1,d3
000029A4 E94B                     M 	lsl.w	#4,d3
000029A6 0243 0F00                M 	andi.w	#$f00,d3
000029AA E44A                     M 	lsr.w	#2,d2
000029AC 0242 007C                M 	andi.w	#$7c,d2
000029B0 D443                     M 	add.w	d3,d2
000029B2 8469 0012                M 	or.w	cvdp(a1),d2
000029B6 36C2                       		move.w	d2,(a3)+			; Store it
000029B8                            
000029B8 3601                       		move.w	d1,d3				; Get Y
000029BA E94B                       		lsl.w	#4,d3				; Multiply by $10
000029BC 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000029C0 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
000029C4 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
000029C6 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
000029CA E04D                       		lsr.w	#8,d5				; Divide by $100
000029CC 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
000029D0                            
000029D0 E648                       		lsr.w	#3,d0				; Get X within chunk data
000029D2 3400                       		move.w	d0,d2				; ''
000029D4 0242 000E                  		andi.w	#$E,d2				; ''
000029D8 E848                       		lsr.w	#4,d0				; Get X within layout data
000029DA 0240 007F                  		andi.w	#$7F,d0				;''
000029DE 3601                       		move.w	d1,d3				; Get Y within chunk data
000029E0 0243 0070                  		andi.w	#$70,d3				; ''
000029E4 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
000029E6                            
000029E6 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029EA D241                       		add.w	d1,d1				; ''
000029EC D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
000029EE                            
000029EE 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
000029F0                            		getChunk				; Get chunk pointer at current location
000029F0 1232 0000                M 	move.b	(a2,d0.w),d1
000029F4 0241 00FF                M 	andi.w	#$ff,d1
000029F8 EF49                     M 	lsl.w	#7,d1
000029FA 2C41                     M 	movea.l	d1,a6
000029FC                            
000029FC                            .DrawBlock_Loop:
000029FC 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002A00 3C05                       		move.w	d5,d6				; ''
00002A02 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002A06 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002A08                            		
00002A08 3E05                       		move.w	d5,d7				; Get block tiles
00002A0A 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002A0E 3A07                       		move.w	d7,d5				; ''
00002A10 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002A14 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002A18 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002A1C                            
00002A1C 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002A20 6700                       		beq.s	.ChkYFlip			; If not, branch
00002A22 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002A28 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002A2E CB47                       		exg.l	d7,d5				; ''
00002A30                            
00002A30                            .ChkYFlip:
00002A30 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002A34 6700                       		beq.s	.DrawBlock			; If not, branch
00002A36 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A3C 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A42 4847                       		swap	d7				; ''
00002A44 4845                       		swap	d5				; ''
00002A46                            
00002A46                            .DrawBlock:
00002A46 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002A48 2AC5                       		move.l	d5,(a5)+			; ''
00002A4A                            
00002A4A 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002A4E 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002A52 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A54 0640 0100                  		addi.w	#$100,d0			; Next chunk
00002A58                            		getChunk				; ''
00002A58 1232 0000                M 	move.b	(a2,d0.w),d1
00002A5C 0241 00FF                M 	andi.w	#$ff,d1
00002A60 EF49                     M 	lsl.w	#7,d1
00002A62 2C41                     M 	movea.l	d1,a6
00002A64                            
00002A64                            .DrawBlock_Cont:
00002A64 D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002A66 51CC FF94                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A6A                            
00002A6A 4E75                       		rts
00002A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A6C                            ; Refresh a plane
00002A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A6C                            ; PARAMETERS:
00002A6C                            ;	a1.l	- Camera variables
00002A6C                            ;	a4.l	- Row plane buffer
00002A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A6C                            ; RETURNS:
00002A6C                            ;	Nothing
00002A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A6C                            Level_RefreshPlane:
00002A6C 3011                       		move.w	cXPos(a1),d0			; Get X position
00002A6E 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002A72 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002A76 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002A7A                            		
00002A7A 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002A7E 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002A82 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002A86 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002A8A                            		
00002A8A 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002A8C 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002A8E                            		
00002A8E                            		push.l	a4				; Save plane buffer address
00002A8E 2F0C                     M 	move.l	a4,-(sp)
00002A90                            		
00002A90                            .DrawRows:
00002A90                            		push.w	d0/d1/d4/d6			; Save registers
00002A90 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002A94 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002A98 6100 FE2A                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002A9C 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002AA0 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002AA6 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002AAA 6100 FD44                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002AAE                            		pop.w	d0/d1/d4/d6			; Restore registers
00002AAE 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002AB2                            		
00002AB2 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002AB6 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002ABA                            		
00002ABA                            		pop.l	a4				; Restore a3
00002ABA 285F                     M 	move.l	(sp)+,a4
00002ABC 4E75                       		rts
00002ABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ABE                            ; Check if the plane needs to be redrawn
00002ABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ABE                            ; PARAMETERS:
00002ABE                            ;	a1.l	- Camera RAM
00002ABE                            ;	a3.l	- Row plane buffer
00002ABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ABE                            ; RETURNS:
00002ABE                            ;	Nothing
00002ABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ABE                            Level_ChkRedrawPlane:
00002ABE 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002AC2                            		; Comment out the following line to disable blast processing :^)
00002AC2 6700                       		beq.s	.End				; If not, branch
00002AC4 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002AC8 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002ACA                            
00002ACA                            .End:
00002ACA 4E75                       		rts
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; Scroll sections macro
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            scrollInit	macro	label
00002ACC                            SCROLL_LABEL	equs	"\label"
00002ACC                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002ACC                            		endm
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            scrollEnd	macro
00002ACC                            \SCROLL_LABEL\_End:					; End label
00002ACC                            		endm
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            scrollSection	macro
00002ACC                            	if narg<3
00002ACC                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002ACC                            	else
00002ACC                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002ACC                            	endif
00002ACC                            		endm
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; Do section scrolling
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; PARAMERERS:
00002ACC                            ;	a1.l	- Background camera RAM
00002ACC                            ;	a3.l	- Scroll section data
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; RETURNS:
00002ACC                            ;	Nothing
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ScrollSections:
00002ACC 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing variables
00002AD0 49F8 EFD0                  		lea	rScrlSecs.w,a4		; Deformation offset buffer
00002AD4 4BF8 90FE                  		lea	rHScroll.w,a5			; Horizontal scroll buffer
00002AD8                            
00002AD8 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002ADA                            
00002ADA 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002ADC 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002AE0 48C4                       		ext.l	d4				; ''
00002AE2 E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002AE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AE4                            		; Update each section offset
00002AE4                            		push.w	d0/a4				; Save registers
00002AE4 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002AE8                            
00002AE8                            .ScrollSects:
00002AE8 361B                       		move.w	(a3)+,d3			; Get section speed
00002AEA 48C3                       		ext.l	d3				; ''
00002AEC                            
00002AEC 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002AEE 6A00                       		bpl.s	.NotAuto			; If not, branch
00002AF0 3C04                       		move.w	d4,d6				; Get camera speed
00002AF2 CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002AF4 E183                       		asl.l	#8,d3				; Shift section speed
00002AF6 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002AF8 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002AFA                            
00002AFA                            .NotAuto:
00002AFA C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002AFC                            
00002AFC                            .ApplySpeed:
00002AFC D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002AFE 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002B00 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002B04                            
00002B04                            		pop.w	d0/a4				; Restore registers
00002B04 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002B08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B08                            		; Set the scroll offsets on screen
00002B08 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002B0C 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002B10                            		
00002B10                            .FindStart:
00002B10 221C                       		move.l	(a4)+,d1			; Get section offset
00002B12 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002B14 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002B16 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002B1A 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B1C 4441                       		neg.w	d1				; Make it scroll the right direction
00002B1E 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B20 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B22 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002B24                            
00002B24                            .FoundStart:
00002B24 4446                       		neg.w	d6				; Get remaining size of the section
00002B26 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B28 4441                       		neg.w	d1				; Make it scroll the right direction
00002B2A 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B2C 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B2E 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002B30                            
00002B30                            .NextSection:
00002B30 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002B32 4441                       		neg.w	d1				; Make the section scroll the correct way
00002B34 2C1C                       		move.l	(a4)+,d6			; Get section size
00002B36                            		
00002B36                            .CheckScroll:
00002B36 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002B38 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002B3A 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002B3C                            
00002B3C                            .Scroll:
00002B3C 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002B3E 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002B42 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002B46 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002B48                            		
00002B48                            .EndSection:
00002B48 DA46                       		add.w	d6,d5				; Get remaining screen space
00002B4A                            		
00002B4A                            .LastSection:
00002B4A 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002B4C 6B00                       		bmi.s	.End				; If there are none, exit
00002B4E                            
00002B4E                            .FillScroll:
00002B4E 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002B50 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002B54                            
00002B54                            .End:
00002B54 4E75                       		rts
00002B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B56                            ; Static background scrolling (no parallax)
00002B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B56                            ; PARAMERERS:
00002B56                            ;	a1.l	- Background camera RAM
00002B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B56                            ; RETURNS:
00002B56                            ;	Nothing
00002B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B56                            ScrollStaticBG:
00002B56 45F8 F880                  		lea	rFGCam.w,a2		; Get foreground level drawing variables
00002B5A 4BF8 90FE                  		lea	rHScroll.w,a5		; Horizontal scroll buffer
00002B5E                            		
00002B5E 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002B60 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002B62 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002B64 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002B66                            
00002B66 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002B6A                            
00002B6A                            .Scroll:
00002B6A 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002B6C 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002B70 4E75                       		rts
00002B72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B72                            ; Generate fake layer art
00002B72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B72                            ; PARAMETERS:
00002B72                            ;	a0.l	- Layer art data pointer
00002B72                            ;	a1.l	- Layer tile ID mappings pointer
00002B72                            ;	d0.w	- Layer offset
00002B72                            ;	d1.l	- Buffer pointer
00002B72                            ;	d2.w	- VRAM destination address
00002B72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B72                            Level_UpdateLayer:
00002B72                            		; Prepare for transfer
00002B72 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002B74 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002B76                            		
00002B76                            		; Queue a DMA transfer for later
00002B76                            		push.l	d0/d3/a1			; Save registers
00002B76 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002B7A 5243                       		addq.w	#1,d3				; Get size of transfer
00002B7C E94B                       		lsl.w	#4,d3				; ''
00002B7E 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002B82                            		pop.l	d0/d3/a1			; Restore registers
00002B82 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002B86                            
00002B86                            		; Copy the tiles for the layer
00002B86 D040                       		add.w	d0,d0				; Double it
00002B88 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002B8C                            		
00002B8C                            .CopyTiles:
00002B8C 3219                       		move.w	(a1)+,d1			; Get tile offset
00002B8E 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002B92 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002B94 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B96 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B98 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B9A 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B9C 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B9E 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BA0 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BA2 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002BA6                            
00002BA6                            .End
00002BA6 4E75                       		rts
00002BA8                            ; =========================================================================================================================================================
00002BA8                            		include	"Level/Level Collision.asm"
00002BA8                            ; =========================================================================================================================================================
00002BA8                            ; Mighty The Armadillo in PRISM PARADISE
00002BA8                            ; By Nat The Porcupine 2021
00002BA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BA8                            ; Level collision functions
00002BA8                            ; =========================================================================================================================================================
00002BA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BA8                            ; Check if a player object has touched any level collision
00002BA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BA8                            PlayerChkCollision:
00002BA8 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002BAE 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002BB4 6700                       		beq.s	.NotPrimary			; If not, branch
00002BB6 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002BBC                            
00002BBC                            .NotPrimary:
00002BBC 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002BC0                            		
00002BC0 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002BC4 3428 001E                  		move.w	oYVel(a0),d2			; Get Y velocity
00002BC8 4EB8 171A                  		jsr	CalcArcTan.w			; Get the angle
00002BCC 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002BD0 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002BD4 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002BD8 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002BDC 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002BE0 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002BE4 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002BE8 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002BEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BEC                            PlayerHitFloorAndWalls:
00002BEC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002BF0 4A41                       		tst.w	d1				; Have we hit the wall?
00002BF2 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002BF4 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002BF8 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002BFC                            
00002BFC                            .NoLeftHit:
00002BFC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002C00 4A41                       		tst.w	d1				; Have we hit the wall?
00002C02 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002C04 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002C08 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C0C                            
00002C0C                            .NoRightHit:
00002C0C 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002C10 4A41                       		tst.w	d1				; Have we hit the floor?
00002C12 6A00                       		bpl.s	.End				; If not, branch
00002C14                            
00002C14 1428 001E                  		move.b	oYVel(a0),d2			; Get the integer part of the Y velocity
00002C18 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002C1A 4402                       		neg.b	d2				; Negate it since we are in the floor
00002C1C B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002C1E 6C00                       		bge.s	.TouchFloor			; If so, branch
00002C20 B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002C22 6D00                       		blt.s	.End				; If not, branch
00002C24                            
00002C24                            .TouchFloor:
00002C24 1143 0000                  		move.b	d3,oAngle(a0)			; Set the angle
00002C28 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the floor
00002C2C 1003                       		move.b	d3,d0				; Copy angle
00002C2E 0600 0020                  		addi.b	#$20,d0				; Shift it
00002C32 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002C36 6600                       		bne.s	.HitWall			; If so, branch
00002C38 1003                       		move.b	d3,d0				; Copy angle
00002C3A 0600 0010                  		addi.b	#$10,d0				; Shift it
00002C3E 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002C42 6700                       		beq.s	.HitFloor			; If not, branch
00002C44 E0E8 001E                  		asr	oYVel(a0)			; Divide the Y velocity by 2
00002C48 6000                       		bra.s	.HitSlope			; Continue
00002C4A                            
00002C4A                            .HitFloor:
00002C4A 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002C4E 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002C54 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002C58                            
00002C58                            .HitWall:
00002C58 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
00002C5C 0C68 0FC0 001E             		cmpi.w	#$FC0,oYVel(a0)			; Cap the Y velocity at $FC0
00002C62 6F00                       		ble.s	.HitSlope			; ''
00002C64 317C 0FC0 001E             		move.w	#$FC0,oYVel(a0)			; ''
00002C6A                            
00002C6A                            .HitSlope:
00002C6A 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002C6E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002C74 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002C76 6A00                       		bpl.s	.End				; If so, branch
00002C78 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002C7C                            
00002C7C                            .End:
00002C7C 4E75                       		rts
00002C7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C7E                            PlayerHitLWall:
00002C7E 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C82 4A41                       		tst.w	d1				; Have we hit the wall?
00002C84 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002C86 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C8A 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C8E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002C94                            
00002C94                            .ChkCeil:
00002C94 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002C98 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002C9A 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002C9C 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002C9E 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002CA2 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002CA4 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002CA8 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002CAC 6A00                       		bpl.s	.End				; If not, branch
00002CAE 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CB2                            
00002CB2                            .End:
00002CB2 4E75                       		rts
00002CB4                            
00002CB4                            .ChkRightWall:
00002CB4 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002CB8 4A41                       		tst.w	d1				; Have we hit the wall?
00002CBA 6A00                       		bpl.s	.End2				; If not, branch
00002CBC D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CC0 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CC4                            		
00002CC4                            .End2:
00002CC4 4E75                       		rts
00002CC6                            
00002CC6                            .ChkFloor:
00002CC6 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002CCA 6B00                       		bmi.s	.End3				; If so, branch
00002CCC 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002CD0 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002CD2 6A00                       		bpl.s	.End3				; If not, branch
00002CD4 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002CD8 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002CDC 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CE0 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002CE6 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002CEA                            		
00002CEA                            .End3:
00002CEA 4E75                       		rts
00002CEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CEC                            PlayerHitCeilAndWalls:
00002CEC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002CF0 4A41                       		tst.w	d1				; Have we hit the wall?
00002CF2 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002CF4 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002CF8 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CFC                            
00002CFC                            .NoLeftHit:
00002CFC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D00 4A41                       		tst.w	d1				; Have we hit the wall?
00002D02 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002D04 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D08 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D0C                            
00002D0C                            .NoRightHit:
00002D0C 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D10 4A41                       		tst.w	d1				; Have we hit the floor?
00002D12 6A00                       		bpl.s	.End				; If not, branch
00002D14 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of ceiling
00002D18 1003                       		move.b	d3,d0				; Get angle
00002D1A 0600 0020                  		addi.b	#$20,d0				; Shift it
00002D1E 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002D22 6600                       		bne.s	.HitWall			; If so, branch
00002D24 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D28 4E75                       		rts
00002D2A                            
00002D2A                            .HitWall:
00002D2A 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D2E 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D32 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D38 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D3A 6A00                       		bpl.s	.End				; If so, branch
00002D3C 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002D40                            
00002D40                            .End:
00002D40 4E75                       		rts
00002D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D42                            PlayerHitRWall:
00002D42 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D46 4A41                       		tst.w	d1				; Have we hit the wall?
00002D48 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D4A D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D4E 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D52 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D58                            
00002D58                            .ChkCeil:
00002D58 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D5C 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D5E 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D60 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of the ceiling
00002D64 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D68 6A00                       		bpl.s	.End				; If not, branch
00002D6A 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D6E                            
00002D6E                            .End:
00002D6E 4E75                       		rts
00002D70                            
00002D70                            .ChkFloor:
00002D70 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D74 6B00                       		bmi.s	.End2				; If so, branch
00002D76 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D7A 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D7C 6A00                       		bpl.s	.End2				; If not, branch
00002D7E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D82 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D86 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D8A 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002D90 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002D92                            		
00002D92                            .End2:
00002D92 4E75                       		rts
00002D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D94                            ; Reset a player object's status on the floor
00002D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D94                            PlayerResetOnFloor:
00002D94 4A28 0000                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00002D98 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002D9A 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002D9E                            		
00002D9E                            PlayerResetOnFloorPart2:
00002D9E 0828 0002 0028             		btst	#2,oStatus(a0)			; Was Sonic rolling?
00002DA4 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002DA6 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
00002DAC 1168 0000 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00002DB2 1168 0000 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00002DB8 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002DBC 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align with floor
00002DC0                            
00002DC0                            PlayerResetOnFloorPart3:
00002DC0 0228 00DD 0028             		andi.b	#$DD,oStatus(a0)		; Clear "pushing", and "jumping" flag
00002DC6 4228 0000                  		clr.b	oJumping(a0)			; Clear jumping flag
00002DCA 4228 0000                  		clr.b	oFlipAngle(a0)			; Reset flip angle
00002DCE 4228 0000                  		clr.b	oFlipTurned(a0)			; Reset flip inverted flag
00002DD2 4228 0000                  		clr.b	oFlipRemain(a0)			; Reset flips remaining
00002DD6 4E75                       		rts
00002DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DD8                            ; Calculate the room in front of a player object
00002DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DD8                            PlayerCalcRoomInFront:
00002DD8 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002DDE 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002DE4 6700                       		beq.s	.NotPrimary			; If not, branch
00002DE6 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002DEC                            
00002DEC                            .NotPrimary:
00002DEC 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002DF0                            		
00002DF0 2628 0014                  		move.l	oXPos(a0),d3			; Get X position
00002DF4 2428 0018                  		move.l	oYPos(a0),d2			; Get Y position
00002DF8 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002DFC 48C1                       		ext.l	d1				; ''
00002DFE E181                       		asl.l	#8,d1				; Shift it
00002E00 D681                       		add.l	d1,d3				; Add onto X position
00002E02 3228 001E                  		move.w	oYVel(a0),d1			; Get Y velocity
00002E06 48C1                       		ext.l	d1				; ''
00002E08 E181                       		asl.l	#8,d1				; Shift it
00002E0A D481                       		add.l	d1,d2				; Add onto Y position
00002E0C 4842                       		swap	d2				; Get actual Y
00002E0E 4843                       		swap	d3				; Get actual X
00002E10 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E14 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E18 1200                       		move.b	d0,d1				; Copy angle
00002E1A 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002E1E 6700                       		beq.s	.DownUp				; If not, branch
00002E20 5200                       		addq.b	#1,d0				; Shift the angle
00002E22                            
00002E22                            .DownUp:
00002E22 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002E26 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E2A 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002E2E 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E32 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002E36 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002E3A 6600                       		bne.s	.ChkWall			; If not, branch
00002E3C 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002E3E                            
00002E3E                            .ChkWall:
00002E3E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E42 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002E46 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002E4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E4A                            ; Calculate the room over a player object
00002E4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E4A                            PlayerCalcRoomOverHead:
00002E4A 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E50 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E56 6700                       		beq.s	.NotPrimary			; If not, branch
00002E58 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E5E                            
00002E5E                            .NotPrimary:
00002E5E 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E62 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E66 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E6A                            		
00002E6A 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002E6E 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E72 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E76 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002E7A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E7E 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002E82 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002E86 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002E8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E8A                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002E8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E8A                            PlayerChkFloor:
00002E8A 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E90 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E96 6700                       		beq.s	.NotPrimary			; If not, branch
00002E98 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E9E                            
00002E9E                            .NotPrimary:
00002E9E 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00002EA2                            		
00002EA2                            		; Get the angle on the bottom right sensor
00002EA2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002EA6 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002EAA 7000                       		moveq	#0,d0
00002EAC 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002EB0 4880                       		ext.w	d0				; ''
00002EB2 D440                       		add.w	d0,d2				; Add onto Y position
00002EB4 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002EB8 4880                       		ext.w	d0				; ''
00002EBA D640                       		add.w	d0,d3				; Add onto X position
00002EBC 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002EC0 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002EC4 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002EC6 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002ECA                            		push.w	d1				; Save the primary floor distance
00002ECA 3F01                     M 	move.w	d1,-(sp)
00002ECC                            
00002ECC                            		; Get the angle on the bottom left sensor
00002ECC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002ED0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002ED4 7000                       		moveq	#0,d0
00002ED6 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002EDA 4880                       		ext.w	d0				; ''
00002EDC D440                       		add.w	d0,d2				; Add onto Y position
00002EDE 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002EE2 4880                       		ext.w	d0				; ''
00002EE4 9640                       		sub.w	d0,d3				; Subtract from X position
00002EE6 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00002EEA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002EEE 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002EF0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002EF4                            		
00002EF4                            		; Update the object's angle
00002EF4                            		pop.w	d0				; Restore the primary floor distance
00002EF4 301F                     M 	move.w	(sp)+,d0
00002EF6 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002EF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EF8                            PlayerPickAngle:
00002EF8 1628 002F                  		move.b	oTilt(a0),d3			; Get secondary angle
00002EFC B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002EFE 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002F00 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F04 C141                       		exg.l	d0,d1				; Switch floor distance values
00002F06                            		
00002F06                            .ChkSetAngle:
00002F06 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002F0A 6700                       		beq.s	.End				; If not, branch
00002F0C 1602                       		move.b	d2,d3				; Set the new angle value
00002F0E                            		
00002F0E                            .End:
00002F0E 4E75                       		rts
00002F10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F10                            ; Get the distance between the floor and the player object
00002F10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F10                            PlayerChkFloorDist:
00002F10 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F14 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F18                            
00002F18                            PlayerChkFloorDist_Part2:
00002F18 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00002F1C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F20 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F24 4246                       		clr.w	d6				; No flip bits
00002F26 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F2A 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F2C                            PlayerGetPrimaryAngle:
00002F2C 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F30 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002F34 6700                       		beq.s	.End				; If not, branch
00002F36 1602                       		move.b	d2,d3				; Set the new angle value
00002F38                            		
00002F38                            .End:
00002F38 4E75                       		rts
00002F3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F3A                            sub_F846:
00002F3A 3628 0014                  		move.w	oXPos(a0),d3
00002F3E 3428 0018                  		move.w	oYPos(a0),d2
00002F42 5942                       		subq.w	#4,d2
00002F44 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F4A 0C28 000D 0000             		cmpi.b	#$D,oLRBSolid(a0)		; Are we on the primary path?
00002F50 6700                       		beq.s	.NotPrimary			; If not, branch
00002F52 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F58                            
00002F58                            .NotPrimary:
00002F58 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F5C 4214                       		clr.b	(a4)				; Clear it
00002F5E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F62 4246                       		clr.w	d6				; No flip bits
00002F64 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Solidity bits
00002F68 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F6C 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F70 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002F74 6700                       		beq.s	.End				; If not, branch
00002F76 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002F78                            
00002F78                            .End:
00002F78 4E75                       		rts
00002F7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F7A                            ; Check for the edge of a floor
00002F7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F7A                            PlayerChkFloorEdge:
00002F7A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F7E                            
00002F7E                            PlayerChkFloorEdge_Part2:
00002F7E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F82 7000                       		moveq	#0,d0
00002F84 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F88 4880                       		ext.w	d0				; ''
00002F8A D440                       		add.w	d0,d2				; Add onto Y position
00002F8C                            
00002F8C                            PlayerChkFloorEdge_Part3:
00002F8C 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F92 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002F98 6700                       		beq.s	.NotPrimary			; If not, branch
00002F9A 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002FA0                            
00002FA0                            .NotPrimary:
00002FA0 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FA4 4214                       		clr.b	(a4)				; Clear it
00002FA6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FAA 4246                       		clr.w	d6				; No flip bits
00002FAC 1A28 0000                  		move.b	oTopSolid(a0),d5		; Solidity bits
00002FB0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FB4 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FB8 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FBC 6700                       		beq.s	.End				; If not, branch
00002FBE 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002FC0                            
00002FC0                            .End:
00002FC0 4E75                       		rts
00002FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC2                            ; Get the distance between the floor and an object
00002FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC2                            ObjCheckFloorDist:
00002FC2 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FC6                            		
00002FC6                            ObjCheckFloorDist_Part2:
00002FC6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FCA                            
00002FCA                            ObjCheckFloorDist_Part3:
00002FCA 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002FCE 4880                       		ext.w	d0				; ''
00002FD0 D440                       		add.w	d0,d2				; Add onto Y position
00002FD2 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FD6 4214                       		clr.b	(a4)				; Clear it
00002FD8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FDC 4246                       		clr.w	d6				; No flip bits
00002FDE 7A0C                       		moveq	#$C,d5				; Solidity bits
00002FE0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FE4 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FE8 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FEC 6700                       		beq.s	.End				; If not, branch
00002FEE 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002FF0                            
00002FF0                            .End:
00002FF0 4E75                       		rts
00002FF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FF2                            ; Get the distance between a right ceiling and a player object
00002FF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FF2                            PlayerChkRightCeilDist:
00002FF2                            		; Get the angle on the bottom right (rotated) sensor
00002FF2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FF6 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FFA 7000                       		moveq	#0,d0
00002FFC 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
00003000 4880                       		ext.w	d0				; ''
00003002 9440                       		sub.w	d0,d2				; Subtract from Y position
00003004 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
00003008 4880                       		ext.w	d0				; ''
0000300A D640                       		add.w	d0,d3				; Add onto X position
0000300C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003010 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003014 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003016 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000301A                            		push.w	d1				; Save the primary floor distance
0000301A 3F01                     M 	move.w	d1,-(sp)
0000301C                            
0000301C                            		; Get the angle on the bottom left (rotated) sensor
0000301C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003020 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003024 7000                       		moveq	#0,d0
00003026 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
0000302A 4880                       		ext.w	d0				; ''
0000302C D440                       		add.w	d0,d2				; Add onto Y position
0000302E 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
00003032 4880                       		ext.w	d0				; ''
00003034 D640                       		add.w	d0,d3				; Add onto X position
00003036 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000303A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000303E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003040 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003044                            
00003044                            		; Update the object's angle
00003044                            		pop.w	d0				; Restore the primary floor distance
00003044 301F                     M 	move.w	(sp)+,d0
00003046 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000304A 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
0000304E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000304E                            ; Get the distance between a right wall and a player object
0000304E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000304E                            PlayerChkRightWallDist:
0000304E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003052 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003056                            
00003056                            PlayerChkRightWallDist_Part2:
00003056 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
0000305A 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000305E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003062 4246                       		clr.w	d6				; No flip bits
00003064 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003068 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000306C 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003070                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003070                            ; Get the distance between a right wall and an object
00003070                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003070                            ObjCheckRightWallDist:
00003070 D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003074 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003078 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000307C 4214                       		clr.b	(a4)				; Clear it
0000307E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003082 4246                       		clr.w	d6				; No flip bits
00003084 7A0D                       		moveq	#$D,d5				; Solidity bits
00003086 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000308A 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
0000308E 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003092 6700                       		beq.s	.End				; If not, branch
00003094 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
00003098                            
00003098                            .End:
00003098 4E75                       		rts
0000309A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000309A                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
0000309A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000309A                            PlayerChkCeiling:
0000309A                            		; Get the angle on the bottom right sensor
0000309A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000309E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030A2 7000                       		moveq	#0,d0
000030A4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000030A8 4880                       		ext.w	d0				; ''
000030AA 9440                       		sub.w	d0,d2				; Subtract from Y position
000030AC 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030B0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030B4 4880                       		ext.w	d0				; ''
000030B6 D640                       		add.w	d0,d3				; Add onto X position
000030B8 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000030BC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000030C0 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000030C4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030C8                            		push.w	d1				; Save the primary floor distance
000030C8 3F01                     M 	move.w	d1,-(sp)
000030CA                            
000030CA                            		; Get the angle on the bottom left sensor
000030CA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030CE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030D2 7000                       		moveq	#0,d0
000030D4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000030D8 4880                       		ext.w	d0				; ''
000030DA 9440                       		sub.w	d0,d2				; Subtract from Y position
000030DC 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030E0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030E4 4880                       		ext.w	d0				; ''
000030E6 9640                       		sub.w	d0,d3				; Subtract from X position
000030E8 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000030EC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000030F0 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000030F4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030F8                            		
000030F8                            		; Update the object's angle
000030F8                            		pop.w	d0				; Restore the primary floor distance
000030F8 301F                     M 	move.w	(sp)+,d0
000030FA 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
000030FE 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
00003102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003102                            ; Get the distance between a ceiling and a player object
00003102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003102                            PlayerChkCeilingDist:
00003102 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003106 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000310A                            
0000310A                            PlayerChkCeilingDist_Part2:
0000310A 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
0000310E 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003112 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003116 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000311A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000311E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003122 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003126 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000312A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000312A                            ; Get the distance between a ceiling and an object
0000312A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000312A                            ObjCheckCeilingDist:
0000312A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000312E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003132 7000                       		moveq	#0,d0
00003134 1028 002D                  		move.b	oColH(a0),d0		; Get collision height
00003138 4880                       		ext.w	d0				; ''
0000313A 9440                       		sub.w	d0,d2				; Subtract it from Y position
0000313C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003140 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003144 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003148 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000314C 7A0D                       		moveq	#$D,d5				; Solidity bits
0000314E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003152 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003156 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000315A 6700                       		beq.s	.End				; If not, branch
0000315C 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003160                            
00003160                            .End:
00003160 4E75                       		rts
00003162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003162                            ; Get the distance between a left ceiling and a player object
00003162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003162                            PlayerChkLeftCeilDist:
00003162                            		; Get the angle on the bottom right (rotated) sensor
00003162 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003166 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000316A 7000                       		moveq	#0,d0
0000316C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003170 4880                       		ext.w	d0				; ''
00003172 9440                       		sub.w	d0,d2				; Subtract from Y position
00003174 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003178 4880                       		ext.w	d0				; ''
0000317A 9640                       		sub.w	d0,d3				; Subtract from X position
0000317C 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003180 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003184 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003188 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000318C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003190                            		push.w	d1				; Save the primary floor distance
00003190 3F01                     M 	move.w	d1,-(sp)
00003192                            
00003192                            		; Get the angle on the bottom left (rotated) sensor
00003192 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003196 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000319A 7000                       		moveq	#0,d0
0000319C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000031A0 4880                       		ext.w	d0				; ''
000031A2 D440                       		add.w	d0,d2				; Add onto Y position
000031A4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000031A8 4880                       		ext.w	d0				; ''
000031AA 9640                       		sub.w	d0,d3				; Subtract from X position
000031AC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031B0 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000031B4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031B8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031BC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031C0                            
000031C0                            		; Update the object's angle
000031C0                            		pop.w	d0				; Restore the primary floor distance
000031C0 301F                     M 	move.w	(sp)+,d0
000031C2 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031C6 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
000031CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031CA                            ; Get the distance between a left wall and a player object
000031CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031CA                            PlayerChkLeftWallDist:
000031CA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031CE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031D2                            
000031D2                            PlayerChkLeftWallDist_Part2:
000031D2 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
000031D6 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031DA 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031DE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031E2 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031E6 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031EA 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031EE 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000031F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031F2                            ; Get the distance between a left wall and an object
000031F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031F2                            ObjCheckLeftWallDist:
000031F2 D668 0014                  		add.w	oXPos(a0),d3			; Add X position
000031F6 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031FA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031FE 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003202 4214                       		clr.b	(a4)				; Clear it
00003204 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003208 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000320C 7A0D                       		moveq	#$D,d5				; Solidity bits
0000320E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003212 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003216 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000321A 6700                       		beq.s	.End				; If not, branch
0000321C 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003220                            
00003220                            .End:
00003220 4E75                       		rts
00003222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003222                            ; Move a player object along on the ground
00003222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003222                            PlayerAnglePos:
00003222 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00003228 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
0000322E 6700                       		beq.s	.NotPrimary			; If not, branch
00003230 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00003236                            
00003236                            .NotPrimary:
00003236 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
0000323A 0828 0003 0028             		btst	#3,oStatus(a0)			; Are we standing on a player object?
00003240 6700                       		beq.s	.NotOnObj			; If not, branch
00003242 4268 002E                  		clr.w	oNextTilt(a0)			; Set the angles to 0
00003246 4E75                       		rts
00003248                            
00003248                            .NotOnObj:
00003248 317C 0303 002E             		move.w	#$0303,oNextTilt(a0)		; Set the angles to 3
0000324E                            		
0000324E                            		; Get which quadrant the object is in on the ground
0000324E                            		; This makes it so that angles:
0000324E                            		; 	$E0-$20 = Quadrant 0 (floor)
0000324E                            		;	$1F-$5F = Quadrant $40 (left wall)
0000324E                            		;	$60-$A0 = Quadrant $80 (ceiling)
0000324E                            		;	$A1-$DF = Quadrant $C0 (right wall)
0000324E 1028 0000                  		move.b	oAngle(a0),d0			; Get the angle
00003252 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003256 6700                       		beq.s	.DownUp				; If not, branch
00003258 5200                       		addq.b	#1,d0				; Shift the angle
0000325A                            
0000325A                            .DownUp:
0000325A 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000325E 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
00003262 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003266 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
0000326A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
0000326E 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
00003272 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003276 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
0000327A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000327A                            ; Move the object along the floor
0000327A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000327A                            PlayerMoveFloor:
0000327A                            		; Get the angle on the bottom right sensor
0000327A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000327E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003282 7000                       		moveq	#0,d0
00003284 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003288 4880                       		ext.w	d0				; ''
0000328A D440                       		add.w	d0,d2				; Add onto Y position
0000328C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003290 4880                       		ext.w	d0				; ''
00003292 D640                       		add.w	d0,d3				; Add onto X position
00003294 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003298 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000329C 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000329E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000032A2                            		push.w	d1				; Save the primary floor distance
000032A2 3F01                     M 	move.w	d1,-(sp)
000032A4                            
000032A4                            		; Get the angle on the bottom left sensor
000032A4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000032A8 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000032AC 7000                       		moveq	#0,d0
000032AE 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000032B2 4880                       		ext.w	d0				; ''
000032B4 D440                       		add.w	d0,d2				; Add onto Y position
000032B6 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000032BA 4880                       		ext.w	d0				; ''
000032BC 9640                       		sub.w	d0,d3				; Add onto X position
000032BE 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000032C2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000032C6 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000032C8 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000032CC                            		
000032CC                            		; Update the object's angle
000032CC                            		pop.w	d0				; Restore the primary floor distance
000032CC 301F                     M 	move.w	(sp)+,d0
000032CE 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
000032D2                            		
000032D2                            		; Check if the object has hit a wall or is about to fall
000032D2 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000032D4 6700                       		beq.s	.End				; If so, branch
000032D6 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000032D8 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000032DC 6D00                       		blt.s	.End				; If so, branch
000032DE D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
000032E2                            
000032E2                            .End:
000032E2 4E75                       		rts
000032E4                            
000032E4                            .ChkFall:
000032E4 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
000032E8 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000032EA 4400                       		neg.b	d0				; Force it to be positive
000032EC                            
000032EC                            .GetMinDist:
000032EC 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000032EE 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000032F2 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000032F4 103C 000E                  		move.b	#$E,d0				; ''
000032F8                            
000032F8                            .ChkDist:
000032F8 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000032FA 6E00                       		bgt.s	.SetAir				; If so, branch
000032FC D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
00003300 4E75                       		rts
00003302                            
00003302                            .SetAir:
00003302 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003308 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000330E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003314 4E75                       		rts
00003316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003316                            ; Set the objects's angle
00003316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003316                            PlayerSetAngle:
00003316 1428 002F                  		move.b	oTilt(a0),d2			; Get secondary angle
0000331A B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
0000331C 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000331E 1428 002E                  		move.b	oNextTilt(a0),d2		; Get primary angle
00003322 3200                       		move.w	d0,d1				; Get primary floor distance
00003324                            		
00003324                            .ChkSetAngle:
00003324 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
00003328 6600                       		bne.s	.LatchOnFlat			; If so, branch
0000332A 1002                       		move.b	d2,d0				; Get angle change
0000332C 9028 0000                  		sub.b	oAngle(a0),d0			; ''
00003330 6A00                       		bpl.s	.ChkDist			; ''
00003332 4400                       		neg.b	d0				; ''
00003334                            
00003334                            .ChkDist:
00003334 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
00003338 6400                       		bhs.s	.LatchOnFlat			; If so, branch
0000333A 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
0000333E 4E75                       		rts
00003340                            
00003340                            .LatchOnFlat:
00003340 1428 0000                  		move.b	oAngle(a0),d2			; Get old angle value
00003344 0602 0020                  		addi.b	#$20,d2				; Shift the angle
00003348 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
0000334C 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
00003350 4E75                       		rts
00003352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003352                            ; Move the object along the right wall
00003352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003352                            PlayerMoveRWall:
00003352                            		; Get the angle on the bottom right (rotated) sensor
00003352 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003356 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000335A 7000                       		moveq	#0,d0
0000335C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003360 4880                       		ext.w	d0				; ''
00003362 9440                       		sub.w	d0,d2				; Add onto Y position
00003364 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003368 4880                       		ext.w	d0				; ''
0000336A D640                       		add.w	d0,d3				; Add onto X position
0000336C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003370 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003374 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003376 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000337A                            		push.w	d1				; Save the primary floor distance
0000337A 3F01                     M 	move.w	d1,-(sp)
0000337C                            
0000337C                            		; Get the angle on the bottom left (rotated) sensor
0000337C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003380 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003384 7000                       		moveq	#0,d0
00003386 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000338A 4880                       		ext.w	d0				; ''
0000338C D440                       		add.w	d0,d2				; Add onto Y position
0000338E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003392 4880                       		ext.w	d0				; ''
00003394 D640                       		add.w	d0,d3				; Add onto X position
00003396 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000339A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000339E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000033A0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000033A4                            		
000033A4                            		; Update the object's angle
000033A4                            		pop.w	d0				; Restore the primary floor distance
000033A4 301F                     M 	move.w	(sp)+,d0
000033A6 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
000033AA                            
000033AA                            		; Check if the object has hit a wall or is about to fall
000033AA 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000033AC 6700                       		beq.s	.End				; If so, branch
000033AE 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000033B0 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000033B4 6D00                       		blt.s	.End				; If so, branch
000033B6 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033BA                            
000033BA                            .End:
000033BA 4E75                       		rts
000033BC                            
000033BC                            .ChkFall:
000033BC 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000033C0 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000033C2 4400                       		neg.b	d0				; Force it to be positive
000033C4                            
000033C4                            .GetMinDist:
000033C4 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000033C6 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000033CA 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000033CC 103C 000E                  		move.b	#$E,d0				; ''
000033D0                            
000033D0                            .ChkDist:
000033D0 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000033D2 6E00                       		bgt.s	.SetAir				; If so, branch
000033D4 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033D8 4E75                       		rts
000033DA                            
000033DA                            .SetAir:
000033DA 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000033E0 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000033E6 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000033EC 4E75                       		rts
000033EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EE                            ; Move the object along the ceiling
000033EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EE                            PlayerMoveCeiling:
000033EE                            		; Get the angle on the bottom right (rotated) sensor
000033EE 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000033F2 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000033F6 7000                       		moveq	#0,d0
000033F8 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000033FC 4880                       		ext.w	d0				; ''
000033FE 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003400 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003404 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003408 4880                       		ext.w	d0				; ''
0000340A D640                       		add.w	d0,d3				; Add onto X position
0000340C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003410 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003414 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003418 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000341C                            		push.w	d1				; Save the primary floor distance
0000341C 3F01                     M 	move.w	d1,-(sp)
0000341E                            
0000341E                            		; Get the angle on the bottom left (rotated) sensor
0000341E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003422 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003426 7000                       		moveq	#0,d0
00003428 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000342C 4880                       		ext.w	d0				; ''
0000342E 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003430 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003434 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003438 4880                       		ext.w	d0				; ''
0000343A 9640                       		sub.w	d0,d3				; Subtract from the X position
0000343C 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003440 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003444 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003448 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000344C                            		
0000344C                            		; Update the object's angle
0000344C                            		pop.w	d0				; Restore the primary floor distance
0000344C 301F                     M 	move.w	(sp)+,d0
0000344E 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
00003452                            		
00003452                            		; Check if the object has hit a wall or is about to fall
00003452 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003454 6700                       		beq.s	.End				; If so, branch
00003456 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003458 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000345C 6D00                       		blt.s	.End				; If so, branch
0000345E 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
00003462                            
00003462                            .End:
00003462 4E75                       		rts
00003464                            
00003464                            .ChkFall:
00003464 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003468 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000346A 4400                       		neg.b	d0				; Force it to be positive
0000346C                            
0000346C                            .GetMinDist:
0000346C 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
0000346E 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003472 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003474 103C 000E                  		move.b	#$E,d0				; ''
00003478                            
00003478                            .ChkDist:
00003478 B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000347A 6E00                       		bgt.s	.SetAir				; If so, branch
0000347C 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
00003480 4E75                       		rts
00003482                            
00003482                            .SetAir:
00003482 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003488 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000348E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003494 4E75                       		rts
00003496                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003496                            ; Move the object along the left wall
00003496                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003496                            PlayerMoveLWall:
00003496                            		; Get the angle on the bottom right (rotated) sensor
00003496 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000349A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000349E 7000                       		moveq	#0,d0
000034A0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034A4 4880                       		ext.w	d0				; ''
000034A6 9440                       		sub.w	d0,d2				; Subtract from the Y position
000034A8 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034AC 4880                       		ext.w	d0				; ''
000034AE 9640                       		sub.w	d0,d3				; Subtract from X position
000034B0 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034B4 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000034B8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034BC 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000034C0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034C4                            		push.w	d1				; Save the primary floor distance
000034C4 3F01                     M 	move.w	d1,-(sp)
000034C6                            
000034C6                            		; Get the angle on the bottom left (rotated) sensor
000034C6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034CA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034CE 7000                       		moveq	#0,d0
000034D0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034D4 4880                       		ext.w	d0				; ''
000034D6 D440                       		add.w	d0,d2				; Add onto Y position
000034D8 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034DC 4880                       		ext.w	d0				; ''
000034DE 9640                       		sub.w	d0,d3				; Subtract from X position
000034E0 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034E4 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000034E8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034EC 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000034F0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034F4                            		
000034F4                            		; Update the object's angle
000034F4                            		pop.w	d0				; Restore the primary floor distance
000034F4 301F                     M 	move.w	(sp)+,d0
000034F6 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
000034FA                            		
000034FA                            		; Check if the object has hit a wall or is about to fall
000034FA 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000034FC 6700                       		beq.s	.End				; If so, branch
000034FE 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003500 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003504 6D00                       		blt.s	.End				; If so, branch
00003506 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
0000350A                            
0000350A                            .End:
0000350A 4E75                       		rts
0000350C                            
0000350C                            .ChkFall:
0000350C 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
00003510 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003512 4400                       		neg.b	d0				; Force it to be positive
00003514                            
00003514                            .GetMinDist:
00003514 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003516 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000351A 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000351C 103C 000E                  		move.b	#$E,d0				; ''
00003520                            
00003520                            .ChkDist:
00003520 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003522 6E00                       		bgt.s	.SetAir				; If so, branch
00003524 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
00003528 4E75                       		rts
0000352A                            
0000352A                            .SetAir:
0000352A 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003530 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003536 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000353C 4E75                       		rts
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            ; Find the nearest floor from the object's position
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            ; PARAMETERS:
0000353E                            ;	d2.w	- Y position of the object's bottom sensor
0000353E                            ;	d3.w	- X position of the object's bottom sensor
0000353E                            ;	d5.w	- Bit to chect for solidity
0000353E                            ;	d6.w	- Flip bits (for walls and ceilings)
0000353E                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
0000353E                            ;	a4.w	- Pointer to where the angle value will be stored
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            ; RETURNS:
0000353E                            ;	d1.w	- The distance from the object to the floor
0000353E                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000353E                            ;	(a4).w	- The floor angle
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            Level_FindFloor:
0000353E 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003542 3011                       		move.w	(a1),d0				; Get block ID
00003544 3800                       		move.w	d0,d4				; Copy that
00003546 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000354A 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000354C 0B04                       		btst	d5,d4				; Is the block solid?
0000354E 6600                       		bne.s	.IsSolid			; If so, branch
00003550                            
00003550                            .IsBlank:
00003550 D44B                       		add.w	a3,d2				; Check below the sensor
00003552 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003556 944B                       		sub.w	a3,d2				; Restore Y position of sensor
00003558 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
0000355C 4E75                       		rts
0000355E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000355E                            .IsSolid:
0000355E 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003562 D040                       		add.w	d0,d0				; Turn ID into offset
00003564 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003568 0240 00FF                  		andi.w	#$FF,d0				; ''
0000356C 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000356E                            
0000356E 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003572 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003576 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003578                            
00003578 3203                       		move.w	d3,d1				; Get the object's X position
0000357A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000357E 6700                       		beq.s	.NoXFlip			; If not, branch
00003580 4641                       		not.w	d1				; Flip the X position
00003582 4414                       		neg.b	(a4)				; Flip the angle
00003584                            		
00003584                            .NoXFlip:
00003584 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003588 6700                       		beq.s	.NoYFlip			; If not, branch
0000358A 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000358E 4414                       		neg.b	(a4)				; ''
00003590 0414 0040                  		subi.b	#$40,(a4)			; ''
00003594                            
00003594                            .NoYFlip:
00003594 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003598 D240                       		add.w	d0,d1				; Add the collision block's offset
0000359A                            
0000359A 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
0000359E 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000035A2 4880                       		ext.w	d0				; ''
000035A4 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000035A6 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000035AA 6700                       		beq.s	.NoYFlip2			; If not, branch
000035AC 4440                       		neg.w	d0				; Flip the height
000035AE                            
000035AE                            .NoYFlip2:
000035AE 4A40                       		tst.w	d0				; Check the height
000035B0 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000035B2 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000035B4 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000035B8 6700                       		beq.s	.MaxFloor			; If so, branch
000035BA 3202                       		move.w	d2,d1				; Get the object's Y position
000035BC 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035C0 D041                       		add.w	d1,d0				; Add onto the height
000035C2 323C 000F                  		move.w	#$F,d1				; Get actual distance
000035C6 9240                       		sub.w	d0,d1				; ''
000035C8 4E75                       		rts
000035CA                            
000035CA                            .NegHeight:
000035CA 3202                       		move.w	d2,d1				; Get the object's Y position
000035CC 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035D0 D041                       		add.w	d1,d0				; Add onto the height
000035D2 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000035D6                            
000035D6                            .MaxFloor:
000035D6 944B                       		sub.w	a3,d2				; Check above the sensor
000035D8 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
000035DA D44B                       		add.w	a3,d2				; Restore Y position of sensor
000035DC 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000035E0 4E75                       		rts
000035E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035E2                            Level_FindFloor2:
000035E2 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000035E6 3011                       		move.w	(a1),d0				; Get block ID
000035E8 3800                       		move.w	d0,d4				; Copy that
000035EA 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000035EE 6700                       		beq.s	.IsBlank			; If it's blank, branch
000035F0 0B04                       		btst	d5,d4				; Is the block solid?
000035F2 6600                       		bne.s	.IsSolid			; If so, branch
000035F4                            
000035F4                            .IsBlank:
000035F4 323C 000F                  		move.w	#$F,d1				; Get max distance
000035F8 3002                       		move.w	d2,d0				; Get the object's Y position
000035FA 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
000035FE 9240                       		sub.w	d0,d1				; Get actual distance
00003600 4E75                       		rts
00003602                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003602                            .IsSolid:
00003602 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003606 D040                       		add.w	d0,d0				; Turn ID into offset
00003608 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000360C 0240 00FF                  		andi.w	#$FF,d0				; ''
00003610 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003612                            
00003612 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003616 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000361A E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000361C                            
0000361C 3203                       		move.w	d3,d1				; Get the object's X position
0000361E 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003622 6700                       		beq.s	.NoXFlip			; If not, branch
00003624 4641                       		not.w	d1				; Flip the X position
00003626 4414                       		neg.b	(a4)				; Flip the angle
00003628                            
00003628                            .NoXFlip:
00003628 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000362C 6700                       		beq.s	.NoYFlip			; If not, branch
0000362E 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003632 4414                       		neg.b	(a4)				; ''
00003634 0414 0040                  		subi.b	#$40,(a4)			; ''
00003638                            
00003638                            .NoYFlip:
00003638 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000363C D240                       		add.w	d0,d1				; Add the collision block's offset
0000363E                            
0000363E 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
00003642 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003646 4880                       		ext.w	d0				; ''
00003648 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000364A 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000364E 6700                       		beq.s	.NoYFlip2			; If not, branch
00003650 4440                       		neg.w	d0				; Flip the height
00003652                            
00003652                            .NoYFlip2:
00003652 4A40                       		tst.w	d0				; Check the height
00003654 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003656 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003658 3202                       		move.w	d2,d1				; Get the object's Y position
0000365A 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000365E D041                       		add.w	d1,d0				; Add onto the height
00003660 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003664 9240                       		sub.w	d0,d1				; ''
00003666 4E75                       		rts
00003668                            
00003668                            .NegHeight:
00003668 3202                       		move.w	d2,d1				; Get the object's Y position
0000366A 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000366E D041                       		add.w	d1,d0				; Add onto the height
00003670 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003674 4641                       		not.w	d1				; Flip the height
00003676 4E75                       		rts
00003678                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003678                            ; Find the nearest wall from the object's position
00003678                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003678                            ; PARAMETERS:
00003678                            ;	d2.w	- Y position of the object's bottom sensor
00003678                            ;	d3.w	- X position of the object's bottom sensor
00003678                            ;	d5.w	- Bit to chect for solidity
00003678                            ;	d6.w	- Flip bits (for walls and ceilings)
00003678                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003678                            ;	a4.w	- Pointer to where the angle value will be stored
00003678                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003678                            ; RETURNS:
00003678                            ;	d1.w	- The distance from the object to the floor
00003678                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003678                            ;	(a4).w	- The floor angle
00003678                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003678                            Level_FindWall:
00003678 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000367C 3011                       		move.w	(a1),d0				; Get block ID
0000367E 3800                       		move.w	d0,d4				; Copy that
00003680 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003684 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003686 0B04                       		btst	d5,d4				; Is the block solid?
00003688 6600                       		bne.s	.IsSolid			; If so, branch
0000368A                            
0000368A                            .IsBlank:
0000368A D64B                       		add.w	a3,d3				; Check right to the sensor
0000368C 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
00003690 964B                       		sub.w	a3,d3				; Restore X position of sensor
00003692 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003696 4E75                       		rts
00003698                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003698                            .IsSolid:
00003698 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
0000369C D040                       		add.w	d0,d0				; Turn ID into offset
0000369E 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000036A2 0240 00FF                  		andi.w	#$FF,d0				; ''
000036A6 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000036A8                            
000036A8 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000036AC 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000036B0 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000036B2                            
000036B2 3202                       		move.w	d2,d1				; Get the object's Y position
000036B4 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036B8 6700                       		beq.s	.NoYFlip			; If not, branch
000036BA 4641                       		not.w	d1				; Flip the Y position
000036BC 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000036C0 4414                       		neg.b	(a4)				; ''
000036C2 0414 0040                  		subi.b	#$40,(a4)			; ''
000036C6                            
000036C6                            .NoYFlip:
000036C6 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000036CA 6700                       		beq.s	.NoXFlip			; If not, branch
000036CC 4414                       		neg.b	(a4)				; Flip the angle
000036CE                            
000036CE                            .NoXFlip:
000036CE 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000036D2 D240                       		add.w	d0,d1				; Add the collision block's offset
000036D4                            
000036D4 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
000036D8 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000036DC 4880                       		ext.w	d0				; ''
000036DE BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000036E0 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
000036E4 6700                       		beq.s	.NoYFlip2			; If not, branch
000036E6 4440                       		neg.w	d0				; Flip the height
000036E8                            
000036E8                            .NoYFlip2:
000036E8 4A40                       		tst.w	d0				; Check the height
000036EA 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036EC 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036EE 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000036F2 6700                       		beq.s	.MaxFloor			; If so, branch
000036F4 3203                       		move.w	d3,d1				; Get the object's X position
000036F6 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000036FA D041                       		add.w	d1,d0				; Add onto the height
000036FC 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003700 9240                       		sub.w	d0,d1				; ''
00003702 4E75                       		rts
00003704                            
00003704                            .NegHeight:
00003704 3203                       		move.w	d3,d1				; Get the object's X position
00003706 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
0000370A D041                       		add.w	d1,d0				; Add onto the height
0000370C 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003710                            
00003710                            .MaxFloor:
00003710 964B                       		sub.w	a3,d3				; Check left to the sensor
00003712 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003714 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003716 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
0000371A 4E75                       		rts
0000371C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000371C                            Level_FindWall2:
0000371C 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003720 3011                       		move.w	(a1),d0				; Get block ID
00003722 3800                       		move.w	d0,d4				; Copy that
00003724 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003728 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000372A 0B04                       		btst	d5,d4				; Is the block solid?
0000372C 6600                       		bne.s	.IsSolid			; If so, branch
0000372E                            
0000372E                            .IsBlank:
0000372E 323C 000F                  		move.w	#$F,d1				; Get max distance
00003732 3003                       		move.w	d3,d0				; Get the object's X position
00003734 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003738 9240                       		sub.w	d0,d1				; Get actual distance
0000373A 4E75                       		rts
0000373C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000373C                            .IsSolid:
0000373C 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003740 D040                       		add.w	d0,d0				; Turn ID into offset
00003742 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003746 0240 00FF                  		andi.w	#$FF,d0				; ''
0000374A 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000374C                            
0000374C 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003750 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003754 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003756                            
00003756 3202                       		move.w	d2,d1				; Get the object's Y position
00003758 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000375C 6700                       		beq.s	.NoYFlip			; If not, branch
0000375E 4641                       		not.w	d1				; Flip the Y position
00003760 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003764 4414                       		neg.b	(a4)				; ''
00003766 0414 0040                  		subi.b	#$40,(a4)			; ''
0000376A                            
0000376A                            .NoYFlip:
0000376A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000376E 6700                       		beq.s	.NoXFlip			; If not, branch
00003770 4414                       		neg.b	(a4)				; Flip the angle
00003772                            
00003772                            .NoXFlip:
00003772 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003776 D240                       		add.w	d0,d1				; Add the collision block's offset
00003778                            
00003778 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
0000377C 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003780 4880                       		ext.w	d0				; ''
00003782 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003784 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003788 6700                       		beq.s	.NoYFlip2			; If not, branch
0000378A 4440                       		neg.w	d0				; Flip the height
0000378C                            
0000378C                            .NoYFlip2:
0000378C 4A40                       		tst.w	d0				; Check the height
0000378E 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003790 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003792 3203                       		move.w	d3,d1				; Get the object's X position
00003794 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003798 D041                       		add.w	d1,d0				; Add onto the height
0000379A 323C 000F                  		move.w	#$F,d1				; Get actual distance
0000379E 9240                       		sub.w	d0,d1				; ''
000037A0 4E75                       		rts
000037A2                            
000037A2                            .NegHeight:
000037A2 3203                       		move.w	d3,d1				; Get the object's X position
000037A4 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037A8 D041                       		add.w	d1,d0				; Add onto the height
000037AA 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000037AE 4641                       		not.w	d1				; Flip the height
000037B0 4E75                       		rts
000037B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B2                            ; Find the nearest block in the level from the player
000037B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B2                            ; PARAMETERS:
000037B2                            ;	d2.w	- Y position of the object's sensor
000037B2                            ;	d3.w	- X position of the object's sensor
000037B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B2                            ; RETURNS:
000037B2                            ;	(a1).w	- The block ID in the chunk where the object is standing
000037B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B2                            Level_FindBlock:
000037B2 3002                       		move.w	d2,d0				; Get the object's Y position
000037B4 D040                       		add.w	d0,d0				; Double it
000037B6 0240 0F00                  		andi.w	#$F00,d0			; Get chunk row offset
000037BA 3203                       		move.w	d3,d1				; Get the object's X position
000037BC E649                       		lsr.w	#3,d1				; Divide by 8
000037BE 3801                       		move.w	d1,d4				; Save for later
000037C0 E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
000037C2 0241 007F                  		andi.w	#$7F,d1				; Only 128 chunks per row
000037C6 D041                       		add.w	d1,d0				; Get offset in the level layout
000037C8 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
000037CA 4241                       		clr.w	d1				; ''
000037CC 43F8 DFD0                  		lea	rLayout.w,a1			; Get layout pointer
000037D0 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
000037D4 D241                       		add.w	d1,d1				; Turn into offset
000037D6 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
000037DA 3002                       		move.w	d2,d0				; Get the object's Y position
000037DC 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
000037E0 D240                       		add.w	d0,d1				; Add onto the offset
000037E2 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
000037E6 D244                       		add.w	d4,d1				; Add onto the offset
000037E8 2241                       		movea.l	d1,a1				; Get pointer in chunk table
000037EA 4E75                       		rts
000037EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037EC                            .ChunkOffsets:
000037EC =00000000                  c		= 0
000037EC                            		rept	256
000037EC                            			dc.w	c
000037EC                            c			= c+$80
000037EC                            		endr
000037EC 0000                     M 	dc.w	c
000037EE =00000080                M c	=	c+$80
000037EE 0080                     M 	dc.w	c
000037F0 =00000100                M c	=	c+$80
000037F0 0100                     M 	dc.w	c
000037F2 =00000180                M c	=	c+$80
000037F2 0180                     M 	dc.w	c
000037F4 =00000200                M c	=	c+$80
000037F4 0200                     M 	dc.w	c
000037F6 =00000280                M c	=	c+$80
000037F6 0280                     M 	dc.w	c
000037F8 =00000300                M c	=	c+$80
000037F8 0300                     M 	dc.w	c
000037FA =00000380                M c	=	c+$80
000037FA 0380                     M 	dc.w	c
000037FC =00000400                M c	=	c+$80
000037FC 0400                     M 	dc.w	c
000037FE =00000480                M c	=	c+$80
000037FE 0480                     M 	dc.w	c
00003800 =00000500                M c	=	c+$80
00003800 0500                     M 	dc.w	c
00003802 =00000580                M c	=	c+$80
00003802 0580                     M 	dc.w	c
00003804 =00000600                M c	=	c+$80
00003804 0600                     M 	dc.w	c
00003806 =00000680                M c	=	c+$80
00003806 0680                     M 	dc.w	c
00003808 =00000700                M c	=	c+$80
00003808 0700                     M 	dc.w	c
0000380A =00000780                M c	=	c+$80
0000380A 0780                     M 	dc.w	c
0000380C =00000800                M c	=	c+$80
0000380C 0800                     M 	dc.w	c
0000380E =00000880                M c	=	c+$80
0000380E 0880                     M 	dc.w	c
00003810 =00000900                M c	=	c+$80
00003810 0900                     M 	dc.w	c
00003812 =00000980                M c	=	c+$80
00003812 0980                     M 	dc.w	c
00003814 =00000A00                M c	=	c+$80
00003814 0A00                     M 	dc.w	c
00003816 =00000A80                M c	=	c+$80
00003816 0A80                     M 	dc.w	c
00003818 =00000B00                M c	=	c+$80
00003818 0B00                     M 	dc.w	c
0000381A =00000B80                M c	=	c+$80
0000381A 0B80                     M 	dc.w	c
0000381C =00000C00                M c	=	c+$80
0000381C 0C00                     M 	dc.w	c
0000381E =00000C80                M c	=	c+$80
0000381E 0C80                     M 	dc.w	c
00003820 =00000D00                M c	=	c+$80
00003820 0D00                     M 	dc.w	c
00003822 =00000D80                M c	=	c+$80
00003822 0D80                     M 	dc.w	c
00003824 =00000E00                M c	=	c+$80
00003824 0E00                     M 	dc.w	c
00003826 =00000E80                M c	=	c+$80
00003826 0E80                     M 	dc.w	c
00003828 =00000F00                M c	=	c+$80
00003828 0F00                     M 	dc.w	c
0000382A =00000F80                M c	=	c+$80
0000382A 0F80                     M 	dc.w	c
0000382C =00001000                M c	=	c+$80
0000382C 1000                     M 	dc.w	c
0000382E =00001080                M c	=	c+$80
0000382E 1080                     M 	dc.w	c
00003830 =00001100                M c	=	c+$80
00003830 1100                     M 	dc.w	c
00003832 =00001180                M c	=	c+$80
00003832 1180                     M 	dc.w	c
00003834 =00001200                M c	=	c+$80
00003834 1200                     M 	dc.w	c
00003836 =00001280                M c	=	c+$80
00003836 1280                     M 	dc.w	c
00003838 =00001300                M c	=	c+$80
00003838 1300                     M 	dc.w	c
0000383A =00001380                M c	=	c+$80
0000383A 1380                     M 	dc.w	c
0000383C =00001400                M c	=	c+$80
0000383C 1400                     M 	dc.w	c
0000383E =00001480                M c	=	c+$80
0000383E 1480                     M 	dc.w	c
00003840 =00001500                M c	=	c+$80
00003840 1500                     M 	dc.w	c
00003842 =00001580                M c	=	c+$80
00003842 1580                     M 	dc.w	c
00003844 =00001600                M c	=	c+$80
00003844 1600                     M 	dc.w	c
00003846 =00001680                M c	=	c+$80
00003846 1680                     M 	dc.w	c
00003848 =00001700                M c	=	c+$80
00003848 1700                     M 	dc.w	c
0000384A =00001780                M c	=	c+$80
0000384A 1780                     M 	dc.w	c
0000384C =00001800                M c	=	c+$80
0000384C 1800                     M 	dc.w	c
0000384E =00001880                M c	=	c+$80
0000384E 1880                     M 	dc.w	c
00003850 =00001900                M c	=	c+$80
00003850 1900                     M 	dc.w	c
00003852 =00001980                M c	=	c+$80
00003852 1980                     M 	dc.w	c
00003854 =00001A00                M c	=	c+$80
00003854 1A00                     M 	dc.w	c
00003856 =00001A80                M c	=	c+$80
00003856 1A80                     M 	dc.w	c
00003858 =00001B00                M c	=	c+$80
00003858 1B00                     M 	dc.w	c
0000385A =00001B80                M c	=	c+$80
0000385A 1B80                     M 	dc.w	c
0000385C =00001C00                M c	=	c+$80
0000385C 1C00                     M 	dc.w	c
0000385E =00001C80                M c	=	c+$80
0000385E 1C80                     M 	dc.w	c
00003860 =00001D00                M c	=	c+$80
00003860 1D00                     M 	dc.w	c
00003862 =00001D80                M c	=	c+$80
00003862 1D80                     M 	dc.w	c
00003864 =00001E00                M c	=	c+$80
00003864 1E00                     M 	dc.w	c
00003866 =00001E80                M c	=	c+$80
00003866 1E80                     M 	dc.w	c
00003868 =00001F00                M c	=	c+$80
00003868 1F00                     M 	dc.w	c
0000386A =00001F80                M c	=	c+$80
0000386A 1F80                     M 	dc.w	c
0000386C =00002000                M c	=	c+$80
0000386C 2000                     M 	dc.w	c
0000386E =00002080                M c	=	c+$80
0000386E 2080                     M 	dc.w	c
00003870 =00002100                M c	=	c+$80
00003870 2100                     M 	dc.w	c
00003872 =00002180                M c	=	c+$80
00003872 2180                     M 	dc.w	c
00003874 =00002200                M c	=	c+$80
00003874 2200                     M 	dc.w	c
00003876 =00002280                M c	=	c+$80
00003876 2280                     M 	dc.w	c
00003878 =00002300                M c	=	c+$80
00003878 2300                     M 	dc.w	c
0000387A =00002380                M c	=	c+$80
0000387A 2380                     M 	dc.w	c
0000387C =00002400                M c	=	c+$80
0000387C 2400                     M 	dc.w	c
0000387E =00002480                M c	=	c+$80
0000387E 2480                     M 	dc.w	c
00003880 =00002500                M c	=	c+$80
00003880 2500                     M 	dc.w	c
00003882 =00002580                M c	=	c+$80
00003882 2580                     M 	dc.w	c
00003884 =00002600                M c	=	c+$80
00003884 2600                     M 	dc.w	c
00003886 =00002680                M c	=	c+$80
00003886 2680                     M 	dc.w	c
00003888 =00002700                M c	=	c+$80
00003888 2700                     M 	dc.w	c
0000388A =00002780                M c	=	c+$80
0000388A 2780                     M 	dc.w	c
0000388C =00002800                M c	=	c+$80
0000388C 2800                     M 	dc.w	c
0000388E =00002880                M c	=	c+$80
0000388E 2880                     M 	dc.w	c
00003890 =00002900                M c	=	c+$80
00003890 2900                     M 	dc.w	c
00003892 =00002980                M c	=	c+$80
00003892 2980                     M 	dc.w	c
00003894 =00002A00                M c	=	c+$80
00003894 2A00                     M 	dc.w	c
00003896 =00002A80                M c	=	c+$80
00003896 2A80                     M 	dc.w	c
00003898 =00002B00                M c	=	c+$80
00003898 2B00                     M 	dc.w	c
0000389A =00002B80                M c	=	c+$80
0000389A 2B80                     M 	dc.w	c
0000389C =00002C00                M c	=	c+$80
0000389C 2C00                     M 	dc.w	c
0000389E =00002C80                M c	=	c+$80
0000389E 2C80                     M 	dc.w	c
000038A0 =00002D00                M c	=	c+$80
000038A0 2D00                     M 	dc.w	c
000038A2 =00002D80                M c	=	c+$80
000038A2 2D80                     M 	dc.w	c
000038A4 =00002E00                M c	=	c+$80
000038A4 2E00                     M 	dc.w	c
000038A6 =00002E80                M c	=	c+$80
000038A6 2E80                     M 	dc.w	c
000038A8 =00002F00                M c	=	c+$80
000038A8 2F00                     M 	dc.w	c
000038AA =00002F80                M c	=	c+$80
000038AA 2F80                     M 	dc.w	c
000038AC =00003000                M c	=	c+$80
000038AC 3000                     M 	dc.w	c
000038AE =00003080                M c	=	c+$80
000038AE 3080                     M 	dc.w	c
000038B0 =00003100                M c	=	c+$80
000038B0 3100                     M 	dc.w	c
000038B2 =00003180                M c	=	c+$80
000038B2 3180                     M 	dc.w	c
000038B4 =00003200                M c	=	c+$80
000038B4 3200                     M 	dc.w	c
000038B6 =00003280                M c	=	c+$80
000038B6 3280                     M 	dc.w	c
000038B8 =00003300                M c	=	c+$80
000038B8 3300                     M 	dc.w	c
000038BA =00003380                M c	=	c+$80
000038BA 3380                     M 	dc.w	c
000038BC =00003400                M c	=	c+$80
000038BC 3400                     M 	dc.w	c
000038BE =00003480                M c	=	c+$80
000038BE 3480                     M 	dc.w	c
000038C0 =00003500                M c	=	c+$80
000038C0 3500                     M 	dc.w	c
000038C2 =00003580                M c	=	c+$80
000038C2 3580                     M 	dc.w	c
000038C4 =00003600                M c	=	c+$80
000038C4 3600                     M 	dc.w	c
000038C6 =00003680                M c	=	c+$80
000038C6 3680                     M 	dc.w	c
000038C8 =00003700                M c	=	c+$80
000038C8 3700                     M 	dc.w	c
000038CA =00003780                M c	=	c+$80
000038CA 3780                     M 	dc.w	c
000038CC =00003800                M c	=	c+$80
000038CC 3800                     M 	dc.w	c
000038CE =00003880                M c	=	c+$80
000038CE 3880                     M 	dc.w	c
000038D0 =00003900                M c	=	c+$80
000038D0 3900                     M 	dc.w	c
000038D2 =00003980                M c	=	c+$80
000038D2 3980                     M 	dc.w	c
000038D4 =00003A00                M c	=	c+$80
000038D4 3A00                     M 	dc.w	c
000038D6 =00003A80                M c	=	c+$80
000038D6 3A80                     M 	dc.w	c
000038D8 =00003B00                M c	=	c+$80
000038D8 3B00                     M 	dc.w	c
000038DA =00003B80                M c	=	c+$80
000038DA 3B80                     M 	dc.w	c
000038DC =00003C00                M c	=	c+$80
000038DC 3C00                     M 	dc.w	c
000038DE =00003C80                M c	=	c+$80
000038DE 3C80                     M 	dc.w	c
000038E0 =00003D00                M c	=	c+$80
000038E0 3D00                     M 	dc.w	c
000038E2 =00003D80                M c	=	c+$80
000038E2 3D80                     M 	dc.w	c
000038E4 =00003E00                M c	=	c+$80
000038E4 3E00                     M 	dc.w	c
000038E6 =00003E80                M c	=	c+$80
000038E6 3E80                     M 	dc.w	c
000038E8 =00003F00                M c	=	c+$80
000038E8 3F00                     M 	dc.w	c
000038EA =00003F80                M c	=	c+$80
000038EA 3F80                     M 	dc.w	c
000038EC =00004000                M c	=	c+$80
000038EC 4000                     M 	dc.w	c
000038EE =00004080                M c	=	c+$80
000038EE 4080                     M 	dc.w	c
000038F0 =00004100                M c	=	c+$80
000038F0 4100                     M 	dc.w	c
000038F2 =00004180                M c	=	c+$80
000038F2 4180                     M 	dc.w	c
000038F4 =00004200                M c	=	c+$80
000038F4 4200                     M 	dc.w	c
000038F6 =00004280                M c	=	c+$80
000038F6 4280                     M 	dc.w	c
000038F8 =00004300                M c	=	c+$80
000038F8 4300                     M 	dc.w	c
000038FA =00004380                M c	=	c+$80
000038FA 4380                     M 	dc.w	c
000038FC =00004400                M c	=	c+$80
000038FC 4400                     M 	dc.w	c
000038FE =00004480                M c	=	c+$80
000038FE 4480                     M 	dc.w	c
00003900 =00004500                M c	=	c+$80
00003900 4500                     M 	dc.w	c
00003902 =00004580                M c	=	c+$80
00003902 4580                     M 	dc.w	c
00003904 =00004600                M c	=	c+$80
00003904 4600                     M 	dc.w	c
00003906 =00004680                M c	=	c+$80
00003906 4680                     M 	dc.w	c
00003908 =00004700                M c	=	c+$80
00003908 4700                     M 	dc.w	c
0000390A =00004780                M c	=	c+$80
0000390A 4780                     M 	dc.w	c
0000390C =00004800                M c	=	c+$80
0000390C 4800                     M 	dc.w	c
0000390E =00004880                M c	=	c+$80
0000390E 4880                     M 	dc.w	c
00003910 =00004900                M c	=	c+$80
00003910 4900                     M 	dc.w	c
00003912 =00004980                M c	=	c+$80
00003912 4980                     M 	dc.w	c
00003914 =00004A00                M c	=	c+$80
00003914 4A00                     M 	dc.w	c
00003916 =00004A80                M c	=	c+$80
00003916 4A80                     M 	dc.w	c
00003918 =00004B00                M c	=	c+$80
00003918 4B00                     M 	dc.w	c
0000391A =00004B80                M c	=	c+$80
0000391A 4B80                     M 	dc.w	c
0000391C =00004C00                M c	=	c+$80
0000391C 4C00                     M 	dc.w	c
0000391E =00004C80                M c	=	c+$80
0000391E 4C80                     M 	dc.w	c
00003920 =00004D00                M c	=	c+$80
00003920 4D00                     M 	dc.w	c
00003922 =00004D80                M c	=	c+$80
00003922 4D80                     M 	dc.w	c
00003924 =00004E00                M c	=	c+$80
00003924 4E00                     M 	dc.w	c
00003926 =00004E80                M c	=	c+$80
00003926 4E80                     M 	dc.w	c
00003928 =00004F00                M c	=	c+$80
00003928 4F00                     M 	dc.w	c
0000392A =00004F80                M c	=	c+$80
0000392A 4F80                     M 	dc.w	c
0000392C =00005000                M c	=	c+$80
0000392C 5000                     M 	dc.w	c
0000392E =00005080                M c	=	c+$80
0000392E 5080                     M 	dc.w	c
00003930 =00005100                M c	=	c+$80
00003930 5100                     M 	dc.w	c
00003932 =00005180                M c	=	c+$80
00003932 5180                     M 	dc.w	c
00003934 =00005200                M c	=	c+$80
00003934 5200                     M 	dc.w	c
00003936 =00005280                M c	=	c+$80
00003936 5280                     M 	dc.w	c
00003938 =00005300                M c	=	c+$80
00003938 5300                     M 	dc.w	c
0000393A =00005380                M c	=	c+$80
0000393A 5380                     M 	dc.w	c
0000393C =00005400                M c	=	c+$80
0000393C 5400                     M 	dc.w	c
0000393E =00005480                M c	=	c+$80
0000393E 5480                     M 	dc.w	c
00003940 =00005500                M c	=	c+$80
00003940 5500                     M 	dc.w	c
00003942 =00005580                M c	=	c+$80
00003942 5580                     M 	dc.w	c
00003944 =00005600                M c	=	c+$80
00003944 5600                     M 	dc.w	c
00003946 =00005680                M c	=	c+$80
00003946 5680                     M 	dc.w	c
00003948 =00005700                M c	=	c+$80
00003948 5700                     M 	dc.w	c
0000394A =00005780                M c	=	c+$80
0000394A 5780                     M 	dc.w	c
0000394C =00005800                M c	=	c+$80
0000394C 5800                     M 	dc.w	c
0000394E =00005880                M c	=	c+$80
0000394E 5880                     M 	dc.w	c
00003950 =00005900                M c	=	c+$80
00003950 5900                     M 	dc.w	c
00003952 =00005980                M c	=	c+$80
00003952 5980                     M 	dc.w	c
00003954 =00005A00                M c	=	c+$80
00003954 5A00                     M 	dc.w	c
00003956 =00005A80                M c	=	c+$80
00003956 5A80                     M 	dc.w	c
00003958 =00005B00                M c	=	c+$80
00003958 5B00                     M 	dc.w	c
0000395A =00005B80                M c	=	c+$80
0000395A 5B80                     M 	dc.w	c
0000395C =00005C00                M c	=	c+$80
0000395C 5C00                     M 	dc.w	c
0000395E =00005C80                M c	=	c+$80
0000395E 5C80                     M 	dc.w	c
00003960 =00005D00                M c	=	c+$80
00003960 5D00                     M 	dc.w	c
00003962 =00005D80                M c	=	c+$80
00003962 5D80                     M 	dc.w	c
00003964 =00005E00                M c	=	c+$80
00003964 5E00                     M 	dc.w	c
00003966 =00005E80                M c	=	c+$80
00003966 5E80                     M 	dc.w	c
00003968 =00005F00                M c	=	c+$80
00003968 5F00                     M 	dc.w	c
0000396A =00005F80                M c	=	c+$80
0000396A 5F80                     M 	dc.w	c
0000396C =00006000                M c	=	c+$80
0000396C 6000                     M 	dc.w	c
0000396E =00006080                M c	=	c+$80
0000396E 6080                     M 	dc.w	c
00003970 =00006100                M c	=	c+$80
00003970 6100                     M 	dc.w	c
00003972 =00006180                M c	=	c+$80
00003972 6180                     M 	dc.w	c
00003974 =00006200                M c	=	c+$80
00003974 6200                     M 	dc.w	c
00003976 =00006280                M c	=	c+$80
00003976 6280                     M 	dc.w	c
00003978 =00006300                M c	=	c+$80
00003978 6300                     M 	dc.w	c
0000397A =00006380                M c	=	c+$80
0000397A 6380                     M 	dc.w	c
0000397C =00006400                M c	=	c+$80
0000397C 6400                     M 	dc.w	c
0000397E =00006480                M c	=	c+$80
0000397E 6480                     M 	dc.w	c
00003980 =00006500                M c	=	c+$80
00003980 6500                     M 	dc.w	c
00003982 =00006580                M c	=	c+$80
00003982 6580                     M 	dc.w	c
00003984 =00006600                M c	=	c+$80
00003984 6600                     M 	dc.w	c
00003986 =00006680                M c	=	c+$80
00003986 6680                     M 	dc.w	c
00003988 =00006700                M c	=	c+$80
00003988 6700                     M 	dc.w	c
0000398A =00006780                M c	=	c+$80
0000398A 6780                     M 	dc.w	c
0000398C =00006800                M c	=	c+$80
0000398C 6800                     M 	dc.w	c
0000398E =00006880                M c	=	c+$80
0000398E 6880                     M 	dc.w	c
00003990 =00006900                M c	=	c+$80
00003990 6900                     M 	dc.w	c
00003992 =00006980                M c	=	c+$80
00003992 6980                     M 	dc.w	c
00003994 =00006A00                M c	=	c+$80
00003994 6A00                     M 	dc.w	c
00003996 =00006A80                M c	=	c+$80
00003996 6A80                     M 	dc.w	c
00003998 =00006B00                M c	=	c+$80
00003998 6B00                     M 	dc.w	c
0000399A =00006B80                M c	=	c+$80
0000399A 6B80                     M 	dc.w	c
0000399C =00006C00                M c	=	c+$80
0000399C 6C00                     M 	dc.w	c
0000399E =00006C80                M c	=	c+$80
0000399E 6C80                     M 	dc.w	c
000039A0 =00006D00                M c	=	c+$80
000039A0 6D00                     M 	dc.w	c
000039A2 =00006D80                M c	=	c+$80
000039A2 6D80                     M 	dc.w	c
000039A4 =00006E00                M c	=	c+$80
000039A4 6E00                     M 	dc.w	c
000039A6 =00006E80                M c	=	c+$80
000039A6 6E80                     M 	dc.w	c
000039A8 =00006F00                M c	=	c+$80
000039A8 6F00                     M 	dc.w	c
000039AA =00006F80                M c	=	c+$80
000039AA 6F80                     M 	dc.w	c
000039AC =00007000                M c	=	c+$80
000039AC 7000                     M 	dc.w	c
000039AE =00007080                M c	=	c+$80
000039AE 7080                     M 	dc.w	c
000039B0 =00007100                M c	=	c+$80
000039B0 7100                     M 	dc.w	c
000039B2 =00007180                M c	=	c+$80
000039B2 7180                     M 	dc.w	c
000039B4 =00007200                M c	=	c+$80
000039B4 7200                     M 	dc.w	c
000039B6 =00007280                M c	=	c+$80
000039B6 7280                     M 	dc.w	c
000039B8 =00007300                M c	=	c+$80
000039B8 7300                     M 	dc.w	c
000039BA =00007380                M c	=	c+$80
000039BA 7380                     M 	dc.w	c
000039BC =00007400                M c	=	c+$80
000039BC 7400                     M 	dc.w	c
000039BE =00007480                M c	=	c+$80
000039BE 7480                     M 	dc.w	c
000039C0 =00007500                M c	=	c+$80
000039C0 7500                     M 	dc.w	c
000039C2 =00007580                M c	=	c+$80
000039C2 7580                     M 	dc.w	c
000039C4 =00007600                M c	=	c+$80
000039C4 7600                     M 	dc.w	c
000039C6 =00007680                M c	=	c+$80
000039C6 7680                     M 	dc.w	c
000039C8 =00007700                M c	=	c+$80
000039C8 7700                     M 	dc.w	c
000039CA =00007780                M c	=	c+$80
000039CA 7780                     M 	dc.w	c
000039CC =00007800                M c	=	c+$80
000039CC 7800                     M 	dc.w	c
000039CE =00007880                M c	=	c+$80
000039CE 7880                     M 	dc.w	c
000039D0 =00007900                M c	=	c+$80
000039D0 7900                     M 	dc.w	c
000039D2 =00007980                M c	=	c+$80
000039D2 7980                     M 	dc.w	c
000039D4 =00007A00                M c	=	c+$80
000039D4 7A00                     M 	dc.w	c
000039D6 =00007A80                M c	=	c+$80
000039D6 7A80                     M 	dc.w	c
000039D8 =00007B00                M c	=	c+$80
000039D8 7B00                     M 	dc.w	c
000039DA =00007B80                M c	=	c+$80
000039DA 7B80                     M 	dc.w	c
000039DC =00007C00                M c	=	c+$80
000039DC 7C00                     M 	dc.w	c
000039DE =00007C80                M c	=	c+$80
000039DE 7C80                     M 	dc.w	c
000039E0 =00007D00                M c	=	c+$80
000039E0 7D00                     M 	dc.w	c
000039E2 =00007D80                M c	=	c+$80
000039E2 7D80                     M 	dc.w	c
000039E4 =00007E00                M c	=	c+$80
000039E4 7E00                     M 	dc.w	c
000039E6 =00007E80                M c	=	c+$80
000039E6 7E80                     M 	dc.w	c
000039E8 =00007F00                M c	=	c+$80
000039E8 7F00                     M 	dc.w	c
000039EA =00007F80                M c	=	c+$80
000039EA 7F80                     M 	dc.w	c
000039EC =00008000                M c	=	c+$80
000039EC                            ; =========================================================================================================================================================
000039EC                            		include	"Level/Level Functions.asm"
000039EC                            ; =========================================================================================================================================================
000039EC                            ; Mighty The Armadillo in PRISM PARADISE
000039EC                            ; By Nat The Porcupine 2021
000039EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039EC                            ; General level functions
000039EC                            ; =========================================================================================================================================================
000039EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039EC                            ; Load level data
000039EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039EC                            Level_LoadData:
000039EC                            		; --- Initialize the start position and camera ---
000039EC                            
000039EC 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
000039F2 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000039F6 E218                       		ror.b	#1,d0				; Turn into offset
000039F8 E848                       		lsr.w	#4,d0				; ''
000039FA 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
000039FE                            
000039FE 42B8 F8C4                  		clr.l	rDestMinCam.w		; Set target minimum camera values
00003A02 42B8 F8C8                  		clr.l	rMinCam.w			; Set minimum camera values
00003A06 21D3 F8BC                  		move.l	(a3),rDestMaxCam.w		; Set target maximum camera values
00003A0A 21DB F8C0                  		move.l	(a3)+,rMaxCam.w		; Set maximum camera values
00003A0E                            
00003A0E 31FC 0060 F8CC             		move.w	#(224/2)-16,rCamYPosDist.w	; Set camera Y distance
00003A14                            
00003A14 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Player object
00003A18 321B                       		move.w	(a3)+,d1			; Get starting X position
00003A1A 3141 0014                  		move.w	d1,oXPos(a0)			; Set the player's X position
00003A1E 3013                       		move.w	(a3),d0				; Get starting Y position
00003A20 3140 0018                  		move.w	d0,oYPos(a0)			; Set the player's Y position
00003A24                            
00003A24 4A38 C7B9                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003A28 6700                       		beq.s	.InitCam			; If not, branch
00003A2A 08E8 0002 000C             		bset	#2,oFlags(a0)
00003A30 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003A32 3141 0014                  		move.w	d1,oXPos(a0)			; ''
00003A36 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003A38 3140 0018                  		move.w	d0,oYPos(a0)			; ''
00003A3C                            
00003A3C                            .InitCam:
00003A3C 4A38 C7AE                  		tst.b	rLastChkpoint.w		; Has a checkpoint been hit?
00003A40 6700                       		beq.s	.SetCam				; If not, branch
00003A42 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003A46 3228 0014                  		move.w	oXPos(a0),d1			; Get X position
00003A4A 3028 0018                  		move.w	oYPos(a0),d0			; Get Y position
00003A4E                            
00003A4E                            .SetCam:
00003A4E 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003A52 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003A54 7200                       		moveq	#0,d1				; Cap it
00003A56                            
00003A56                            .ChkMaxX:
00003A56 3438 F8C0                  		move.w	rMaxCamX.w,d2		; Get max camera X position
00003A5A B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003A5C 6500                       		bcs.s	.SetCamX			; If not, branch
00003A5E 3202                       		move.w	d2,d1				; Cap it
00003A60                            
00003A60                            .SetCamX:	
00003A60 31C1 F880                  		move.w	d1,rCamXPos.w			; Set the camera's X position
00003A64                            
00003A64 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003A68 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003A6A 7000                       		moveq	#0,d0				; Cap it
00003A6C                            
00003A6C                            .ChkMaxY:
00003A6C 3438 F8C2                  		move.w	rMaxCamY.w,d2		; Get max camera Y position
00003A70 B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003A72 6D00                       		blt.s	.SetCamY			; If not, branch
00003A74 3002                       		move.w	d2,d0				; Cap it
00003A76                            
00003A76                            .SetCamY:	
00003A76 31C0 F888                  		move.w	d0,rCamYPos.w			; Set the camera's Y position
00003A7A                            
00003A7A                            		; --- Load level data ---
00003A7A                            
00003A7A 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003A80 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A84 E218                       		ror.b	#1,d0				; Turn into offset
00003A86 E448                       		lsr.w	#2,d0				; ''
00003A88 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A8C                            
00003A8C 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003A8E 43F9 00FF 0000             		lea	rChunks,a1			; Decompress into chunk table
00003A94 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003A98                            
00003A98 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003A9A 43F8 C7D0                  		lea	rBlocks.w,a1			; Decompress into block table
00003A9E 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003AA2                            
00003AA2 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003AA4 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003AA6 4EB8 0EF0                  		jsr	QueueKosMData.w			; Queue for decompression
00003AAA                            
00003AAA 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003AAC 3018                       		move.w	(a0)+,d0			; Size of palette data
00003AAE 4EB8 04BE                  		jsr	LoadTargetPal.w			; Load the palette
00003AB2                            
00003AB2 205B                       		movea.l	(a3)+,a0			; Get layout pointer
00003AB4 43F8 DFD0                  		lea	rLayout.w,a1			; Decompress into layout buffer
00003AB8 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003ABC                            
00003ABC 21DB C7B4                  		move.l	(a3)+,rObjPosAddr.w		; Set object position data pointer
00003AC0 21DB F85E                  		move.l	(a3)+,rRingPosAddr.w		; Set ring position data pointer
00003AC4 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003AC6 201B                       		move.l	(a3)+,d0			; Get collision data address
00003AC8 21C0 F8E0                  		move.l	d0,rColAddr.w			; Set collision address to primary
00003ACC 21C0 F8D8                  		move.l	d0,r1stCol.w			; Set primary collision data pointer
00003AD0 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003AD2 21C0 F8DC                  		move.l	d0,r2ndCol.w			; Set secondary collision data pointer
00003AD6 43F8 F8E6                  		lea	rAngleVals.w,a1		; Collision pointers
00003ADA 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003ADC 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003ADE 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003AE0                            
00003AE0 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003AE6 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003AEA E218                       		ror.b	#1,d0				; Turn into offset
00003AEC EA48                       		lsr.w	#5,d0				; ''
00003AEE 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003AF2 4EF8 0EE0                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003AF6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF6                            ; Update the water surface
00003AF6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF6                            Level_UpdateWaterSurface:
00003AF6 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003AFA 6700                       		beq.s	.End				; If not, branch
00003AFC 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera X position
00003B00 0838 0000 F8FB             		btst	#0,(rLvlFrames+1).w		; Are we on an odd frame?
00003B06 6700                       		beq.s	.SetXPos			; If not, branch
00003B08 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003B0C                            
00003B0C                            .SetXPos:
00003B0C 3001                       		move.w	d1,d0				; Copy X postion
00003B0E 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003B12 3078 F87C                  		movea.w	rWater1Addr.w,a0
00003B16 3140 0014                  		move.w	d0,oXPos(a0)			; Set it
00003B1A 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003B1E 3078 F87E                  		movea.w	rWater2Addr.w,a0
00003B22 3141 0014                  		move.w	d1,oXPos(a0)			; Set it
00003B26                            
00003B26                            .End:
00003B26 4E75                       		rts
00003B28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B28                            ; Handle water height
00003B28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B28                            Level_WaterHeight:
00003B28 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B2C 6700                       		beq.s	.End				; If not, branch
00003B2E 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003B32 4238 F8F5                  		clr.b	rWaterFullscr.w		; Clear water fullscreen flag
00003B36                            
00003B36 7201                       		moveq	#1,d1				; Water movement speed
00003B38 3038 F8F8                  		move.w	rDestWtrLvl.w,d0		; Get destination water level
00003B3C 9078 F8F6                  		sub.w	rWaterLvl.w,d0		; Is the current water level at that destination?
00003B40 6700                       		beq.s	.ChkOnScr			; If so, branch
00003B42 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003B44 4441                       		neg.w	d1				; Go up
00003B46                            
00003B46                            .MoveDown:
00003B46 D378 F8F6                  		add.w	d1,rWaterLvl.w		; Move water
00003B4A                            
00003B4A                            .ChkOnScr:
00003B4A 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00003B4E 9078 F888                  		sub.w	rCamYPos.w,d0			; Get camera's Y position
00003B52 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003B54 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003B56                            		
00003B56                            .Fullscreen:
00003B56 50F8 F8F5                  		st	rWaterFullscr.w		; Set water fullscreen flag
00003B5A 50F8 C75F                  		st	rHIntCnt.w			; Set H-INT counter to be offscreen
00003B5E 4E75                       		rts
00003B60                            
00003B60                            .ChkBottom:
00003B60 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003B64 6500                       		blo.s	.SetCounter			; If not, branch
00003B66 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003B68                            
00003B68                            .SetCounter:
00003B68 11C0 C75F                  		move.b	d0,rHIntCnt.w			; Set H-INT counter
00003B6C                            
00003B6C                            .End:
00003B6C 4E75                       		rts
00003B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B6E                            Level_MoveWater:
00003B6E 4E75                       		rts
00003B70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B70                            ; Do level palette cycling
00003B70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B70                            Level_PalCycle:
00003B70 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003B76 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B7A E218                       		ror.b	#1,d0				; Turn into offset
00003B7C EA48                       		lsr.w	#5,d0				; ''
00003B7E 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B82 4ED0                       		jmp	(a0)				; Jump to it
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            ; Do level art animation
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            Level_AnimateArt:
00003B84 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003B8A 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B8E E218                       		ror.b	#1,d0				; Turn into offset
00003B90 EA48                       		lsr.w	#5,d0				; ''
00003B92 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B96 4ED0                       		jmp	(a0)				; Jump to it
00003B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B98                            ; Do dynamic events
00003B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B98                            Level_DynEvents:
00003B98 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003B9E 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003BA2 E218                       		ror.b	#1,d0				; Turn into offset
00003BA4 EA48                       		lsr.w	#5,d0				; ''
00003BA6 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003BAA 4ED0                       		jmp	(a0)				; Jump to it
00003BAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BAC                            ; Handle the camera
00003BAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BAC                            Level_HandleCamera:
00003BAC 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Get player object
00003BB0                            		
00003BB0 4A38 F8CE                  		tst.b	rCamLockX.w			; Is the camera locked horizontally?
00003BB4 6600                       		bne.s	.ChkY				; If so, branch
00003BB6 43F8 F880                  		lea	rCamXPos.w,a1			; Get foreground level variables
00003BBA 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003BBC                            		
00003BBC                            .ChkY:
00003BBC 4A38 F8CF                  		tst.b	rCamLockY.w			; Is the camera locked vertically?
00003BC0 6600                       		bne.s	.ChkMaxY			; If not, branch
00003BC2 43F8 F888                  		lea	rCamYPos.w,a1			; Get foreground level variables
00003BC6 3638 F8CC                  		move.w	rCamYPosDist.w,d3		; Get camera Y distance
00003BCA 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003BCE                            
00003BCE                            .ChkMaxY:
00003BCE 7202                       		moveq	#2,d1				; Target camera scroll speed
00003BD0 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get distance between target and actual target max camera Y position
00003BD4 9078 F8C2                  		sub.w	rMaxCamY.w,d0		; ''
00003BD8 6700                       		beq.s	.End				; If it's 0, branch
00003BDA 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003BDC 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003BE0 B078 F8BE                  		cmp.w	rDestMaxY.w,d0		; Is it past the boundary?
00003BE4 6300                       		bls.s	.ScrollUp			; If not, branch
00003BE6 31C0 F8C2                  		move.w	d0,rMaxCamY.w		; Set max camera Y position
00003BEA 0278 FFFE F8C2             		andi.w	#$FFFE,rMaxCamY.w		; Keep it a multiple of 2
00003BF0                            
00003BF0                            .ScrollUp:
00003BF0 9378 F8C2                  		sub.w	d1,rMaxCamY.w		; Scroll up
00003BF4 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003BF8                            
00003BF8                            
00003BF8                            .End:
00003BF8 4E75                       		rts
00003BFA                            
00003BFA                            .MoveDown:
00003BFA 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003BFE 5040                       		addq.w	#8,d0				; ''
00003C00 B078 F8C2                  		cmp.w	rMaxCamY.w,d0		; Is it past the boundary?
00003C04 6500                       		bcs.s	.ScrollDown			; If not, branch
00003C06 0828 0001 0028             		btst	#1,oStatus(a0)		; Is the player in the air?
00003C0C 6700                       		beq.s	.ScrollDown			; If not, branch
00003C0E D241                       		add.w	d1,d1				; Scroll down faster
00003C10 D241                       		add.w	d1,d1				; ''
00003C12                            
00003C12                            .ScrollDown:
00003C12 D378 F8C2                  		add.w	d1,rMaxCamY.w		; Scroll down
00003C16 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C1A 4E75                       		rts
00003C1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1C                            Level_MoveCameraX:
00003C1C 3028 0014                  		move.w	oXPos(a0),d0			; Get the player's X position
00003C20 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003C22 9078 F8D2                  		sub.w	rCamXPosCenter.w,d0		; Subtract center
00003C26 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003C28 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003C2A 4E75                       		rts
00003C2C                            
00003C2C                            .MoveLeft:
00003C2C 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003C30 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003C32 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003C36                            
00003C36                            .ChkLeftBound:
00003C36 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C38 B078 F8C8                  		cmp.w	rMinCamX.w,d0		; Have we gone past the left boundary?
00003C3C 6E00                       		bgt.s	.SetCamX			; If not, branch
00003C3E 3038 F8C8                  		move.w	rMinCamX.w,d0		; Cap at the left boundary
00003C42 6000                       		bra.s	.SetCamX			; Continue
00003C44                            
00003C44                            .MoveRight:
00003C44 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003C48 6500                       		blo.s	.ChkRightBound			; If not, branch
00003C4A 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003C4E                            
00003C4E                            .ChkRightBound:
00003C4E D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C50 B078 F8C0                  		cmp.w	rMaxCamX.w,d0		; Has the camera gone beyond the right boundary?
00003C54 6D00                       		blt.s	.SetCamX			; If not, branch
00003C56 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Cap at the right boundary
00003C5A                            
00003C5A                            .SetCamX:
00003C5A 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003C5C 4E75                       		rts
00003C5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C5E                            Level_MoveCameraY:
00003C5E 7200                       		moveq	#0,d1
00003C60 3028 0018                  		move.w	oYPos(a0),d0			; Get the player's Y position
00003C64 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003C66                            
00003C66 0828 0002 0028             		btst	#2,oStatus(a0)			; Is the player rolling?
00003C6C 6700                       		beq.s	.NoRoll				; If not, branch
00003C6E 5B40                       		subq.w	#5,d0				; Move up some
00003C70                            
00003C70                            .NoRoll:
00003C70 0828 0001 0028             		btst	#1,oStatus(a0)			; Is the player in the air?
00003C76 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003C78                            
00003C78                            .ChkBoundCross_Air:
00003C78 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003C7C 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003C7E 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003C80 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003C84 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003C86                            
00003C86 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003C8A 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003C8C 6000                       		bra.s	.NoScroll			; Continue
00003C8E                            
00003C8E                            .ChkBoundCross_Ground:
00003C8E 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003C90 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003C92 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003C96 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003C98                            
00003C98                            .NoScroll:
00003C98 4E75                       		rts		
00003C9A                            
00003C9A                            .DecideScrollType:
00003C9A 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003C9E 6600                       		bne.s	.ScrollSlow			; If not, branch
00003CA0                            
00003CA0 3228 0000                  		move.w	oGVel(a0),d1			; Get the players' ground velocity
00003CA4 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003CA6 4441                       		neg.w	d1				; Force it to be positive
00003CA8                            
00003CA8                            .Positive:
00003CA8 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003CAC 6400                       		bhs.s	.ScrollFast			; If so, branch
00003CAE                            
00003CAE                            .ScrollMedium:
00003CAE 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003CB2 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003CB6 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CB8 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003CBC 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CBE 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CC0                            
00003CC0                            .ScrollSlow:
00003CC0 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003CC4 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003CC8 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CCA 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003CCE 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CD0 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CD2                            
00003CD2                            .ScrollFast:
00003CD2 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003CD6 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003CDA 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CDC 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003CE0 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CE2 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CE4                            
00003CE4                            .ScrollMaxYChange:
00003CE4 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003CE6 11C0 F8D0                  		move.b	d0,rCamMaxChg.w		; Clear the max Y boundary changing flag
00003CEA                            		
00003CEA                            .ScrollUpOrDown:
00003CEA 7200                       		moveq	#0,d1
00003CEC 3200                       		move.w	d0,d1				; Get position difference
00003CEE D251                       		add.w	(a1),d1				; Add old camera Y position
00003CF0 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003CF2 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003CF4 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003CF8                            
00003CF8                            .ScrollUpMax:
00003CF8 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003CFA 48C1                       		ext.l	d1
00003CFC E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003CFE D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D00 4841                       		swap	d1				; Get the actual Y position
00003D02                            
00003D02                            .ScrollUp:
00003D02 B278 F8CA                  		cmp.w	rMinCamY.w,d1		; Has the camera gone beyond the upper boundary?
00003D06 6E00                       		bgt.s	.DoScroll			; If not, branch
00003D08 3238 F8CA                  		move.w	rMinCamY.w,d1		; Cap at upper boundary
00003D0C 6000                       		bra.s	.DoScroll			; Continue
00003D0E                            
00003D0E                            .ScrollDownMax:
00003D0E 48C1                       		ext.l	d1
00003D10 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003D12 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D14 4841                       		swap	d1				; Get the actual Y position
00003D16                            
00003D16                            .ScrollDown:
00003D16 B278 F8C2                  		cmp.w	rMaxCamY.w,d1		; Has the camera gone beyond the lower boundary?
00003D1A 6D00                       		blt.s	.DoScroll			; If not, branch
00003D1C 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Cap at lower boundary
00003D20                            
00003D20                            .DoScroll:
00003D20 4841                       		swap	d1				; Put Y coordinate in the higher word
00003D22 2281                       		move.l	d1,(a1)				; Set Y position
00003D24 4E75                       		rts
00003D26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D26                            ; Level ring manager
00003D26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D26                            Level_RingsManager:
00003D26 7000                       		moveq	#0,d0
00003D28 1038 F3D6                  		move.b	rRingManRout.w,d0		; Get routine
00003D2C 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003D30 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003D34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D34                            .Routines:
00003D34 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003D36 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003D38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D38                            ; Ring manager initialization
00003D38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D38                            Level_RingsManagerInit:
00003D38 5438 F3D6                  		addq.b	#2,rRingManRout.w		; The next time the manager is run, only go to the main routine
00003D3C                            		
00003D3C 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003D40                            
00003D40                            		; Set up the addresses to use in the current location of the level
00003D40                            
00003D40                            		; Start at the left side of the screen
00003D40                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003D40                            
00003D40 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get current ring data address for the left side of the screen
00003D44 45F8 F3DE                  		lea	rRingStat.w,a2		; Ring status table
00003D48 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D4C 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D4E 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003D50 7801                       		moveq	#1,d4				; Cap left side to 1
00003D52 6000                       		bra.s	.CheckLeftSide			; Start checking
00003D54                            
00003D54                            .NextLeftRing:
00003D54 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D56 544A                       		addq.w	#2,a2				; Next ring in status table
00003D58                            
00003D58                            .CheckLeftSide:
00003D58 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003D5A 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003D5C 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003D60 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003D64                            
00003D64                            		; Now the right side of the screen
00003D64                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003D64                            
00003D64 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003D68 6000                       		bra.s	.CheckRightSide			; Start checking
00003D6A                            
00003D6A                            .NextRightRing:
00003D6A 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D6C                            
00003D6C                            .CheckRightSide:
00003D6C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003D6E 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003D70 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003D74 4E75                       		rts
00003D76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D76                            ; Ring manager main routine
00003D76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D76                            Level_RingsManagerMain:
00003D76 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003D7A                            
00003D7A 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get the current starting address for the ring data
00003D7E 3478 F86A                  		movea.w	rRingStatPtr.w,a2		; Get the current starting address for the status table
00003D82                            		
00003D82                            		; Get the new starting addresses for ring data
00003D82                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003D82                            		; and then going back to get the very first ring that's on screen
00003D82                            
00003D82 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D86 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D88 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003D8A 7801                       		moveq	#1,d4				; Cap left side to 1
00003D8C 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003D8E                            
00003D8E                            .NextNewLeftRing:
00003D8E 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D90 544A                       		addq.w	#2,a2				; Next ring in status table
00003D92                            
00003D92                            .CheckNewLeftSide:
00003D92 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003D94 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003D96 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003D98                            
00003D98                            .NextNewLeftRing2:
00003D98 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003D9A 554A                       		subq.w	#2,a2				; Previous ring in status table
00003D9C                            
00003D9C                            .CheckNewLeftSide2:
00003D9C B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003DA0 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003DA2 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003DA6 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003DAA                            
00003DAA                            		; Now get the new ending addresses for ring data
00003DAA                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003DAA                            		; and then going back to get the very first ring that's on screen on the left side
00003DAA                            
00003DAA 2278 F866                  		movea.l	rRingLoadR.w,a1		; Get the current ending address for the ring data
00003DAE                            
00003DAE 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003DB2 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003DB4                            
00003DB4                            .NextNewRightRing:
00003DB4 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DB6                            
00003DB6                            .CheckNewRightSide:
00003DB6 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003DB8 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003DBA 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003DBC                            
00003DBC                            .NextNewRightRing2:
00003DBC 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003DBE                            
00003DBE                            .CheckNewRightSide2:
00003DBE B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003DC2 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003DC4 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003DC8 4E75                       		rts
00003DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DCA                            ; Handle ring collection
00003DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DCA                            Level_RingsManagerDoCollect:
00003DCA 45F8 F7DE                  		lea	rRingCol.w,a2			; Ring collection table
00003DCE 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003DD0 5341                       		subq.w	#1,d1				; Sutbract 1
00003DD2 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003DD4                            
00003DD4                            .Loop:
00003DD4 301A                       		move.w	(a2)+,d0			; Get ring status address
00003DD6 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003DD8 3240                       		movea.w	d0,a1				; Save in a1
00003DDA 5311                       		subq.b	#1,(a1)				; Decrement timer
00003DDC 6600                       		bne.s	.Next				; If nonzero, branch
00003DDE 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003DE2 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003DE6                            							; Is it the last frame?
00003DE6 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003DEC 6600                       		bne.s	.Next				; If not, branch
00003DEE 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003DF2 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003DF6 5378 F7DE                  		subq.w	#1,rRingColCnt.w		; Decrement collection table count
00003DFA                            
00003DFA                            .Next:
00003DFA 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003DFE                            
00003DFE                            .End:
00003DFE 4E75                       		rts
00003E00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E00                            ; Set up the tables and load ring data
00003E00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E00                            Level_RingsManagerSetup:
00003E00                            		; Clear tables
00003E00                            		clrRAM	rRingStat
00003E00                          M 	local	endaddr
00003E00                          M endaddr	equs	"rringstat_End"
00003E00 7000                     M 	moveq	#0,d0
00003E02 43F8 F3DE                M 	lea	(rringstat).w,a1
00003E06 323C 00FF                M 	move.w	#(((rringstat_end)-(rringstat))-((rringstat)&1))>>2-1,d1
00003E0A 22C0                     M .clear_174:	move.l	d0,(a1)+
00003E0C 51C9 FFFC                M 	dbf	d1,.clear_174
00003E10                            		clrRAM	rRingCol
00003E10                          M 	local	endaddr
00003E10                          M endaddr	equs	"rringcol_End"
00003E10 7000                     M 	moveq	#0,d0
00003E12 43F8 F7DE                M 	lea	(rringcol).w,a1
00003E16 323C 001F                M 	move.w	#(((rringcol_end)-(rringcol))-((rringcol)&1))>>2-1,d1
00003E1A 22C0                     M .clear_175:	move.l	d0,(a1)+
00003E1C 51C9 FFFC                M 	dbf	d1,.clear_175
00003E20                            
00003E20 2278 F85E                  		movea.l	rRingPosAddr.w,a1		; Get ring data pointer
00003E24 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store address
00003E28 5849                       		addq.w	#4,a1				; Increment address by 4
00003E2A 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003E2C 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003E30                            
00003E30                            .GetRingCount:
00003E30 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003E32 6B00                       		bmi.s	.Exit				; If so, branch
00003E34 5245                       		addq.w	#1,d5				; Increment ring counter
00003E36 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003E3A                            
00003E3A                            .Exit:
00003E3A 4E75                       		rts
00003E3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E3C                            ; Do ring collision for the player
00003E3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E3C                            PlayerRingCollision:
00003E3C 0C28 0069 0000             		cmpi.b	#105,oInvulTime(a0)		; Is the player able to collect rings while hurt?
00003E42 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003E46 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get starting address of ring data
00003E4A 2478 F866                  		movea.l	rRingLoadR.w,a2		; Get starting address of status table
00003E4E B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003E50 6700 0000                  		beq.w	.End				; If not, branch
00003E54 3878 F86A                  		movea.w	rRingStatPtr.w,a4
00003E58 3428 0014                  		move.w	oXPos(a0),d2			; Player's X position
00003E5C 3628 0018                  		move.w	oYPos(a0),d3			; Player's Y position
00003E60 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003E62 7A00                       		moveq	#0,d5
00003E64 1A28 002D                  		move.b	oColH(a0),d5			; Player's collision height
00003E68 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003E6A 9645                       		sub.w	d5,d3				; Subtract from Y
00003E6C 323C 0006                  		move.w	#6,d1
00003E70 3C3C 000C                  		move.w	#$C,d6
00003E74 383C 0010                  		move.w	#$10,d4				; Width
00003E78 DA45                       		add.w	d5,d5				; Double the height
00003E7A                            
00003E7A                            .NextRing:
00003E7A 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003E7C 6600                       		bne.s	.GetNext			; If so, get the next ring
00003E7E 3011                       		move.w	(a1),d0				; Get ring's X position
00003E80 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003E82 9042                       		sub.w	d2,d0				; Check collision
00003E84 6400                       		bcc.s	.ChkCol
00003E86 D046                       		add.w	d6,d0
00003E88 6500                       		bcs.s	.ChkCol2
00003E8A 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003E8E                            
00003E8E                            .ChkCol:
00003E8E B044                       		cmp.w	d4,d0				; Check collision
00003E90 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003E94                            
00003E94                            .ChkCol2:
00003E94 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003E98 9041                       		sub.w	d1,d0
00003E9A 9043                       		sub.w	d3,d0
00003E9C 6400                       		bcc.s	.ChkCol3
00003E9E D046                       		add.w	d6,d0
00003EA0 6500                       		bcs.s	.Collect
00003EA2 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003EA6                            
00003EA6                            .ChkCol3:
00003EA6 B045                       		cmp.w	d5,d0
00003EA8 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003EAC                            
00003EAC                            .Collect:
00003EAC                            							; Consume the ring
00003EAC 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003EB0 6100                       		bsr.s	CollectRing			; Collect it
00003EB2 47F8 F7E0                  		lea	rRingColList.w,a3		; Get collection list
00003EB6                            
00003EB6                            .Consume:
00003EB6 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003EB8 66FC                       		bne.s	.Consume			; If not, get the next one
00003EBA 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003EBC 5278 F7DE                  		addq.w	#1,rRingColCnt.w		; Add to the number of rings consumed
00003EC0                            
00003EC0                            .GetNext:
00003EC0 5849                       		addq.w	#4,a1				; Next ring in ring data
00003EC2 544C                       		addq.w	#2,a4				; Next ring in status table
00003EC4 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003EC6 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003ECA                            
00003ECA                            .End:
00003ECA 4E75                       		rts
00003ECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ECC                            ; Collect a ring
00003ECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ECC                            CollectRing:
00003ECC 5278 F3D4                  		addq.w	#1,rRings.w			; Incremment ring count
00003ED0 50F8 F8F3                  		st	rUpdateRings.w			; Update ring counter in HUD
00003ED4                            		playSnd	#sRing, 2			; Play ring sound
00003ED4 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003EDA 4E75                       		rts
00003EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EDC                            ; Render the HUD
00003EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EDC                            Level_RenderHUDAndRings:
00003EDC 7C00                       		moveq	#0,d6				; Clear render flags
00003EDE 7802                       		moveq	#1*2,d4				; Standard frame
00003EE0 4A78 F3D4                  		tst.w	rRings.w			; Do we have 0 rings?
00003EE4 6600                       		bne.s	.Not0Rings			; If not, branch
00003EE6 0838 0003 F8FB             		btst	#3,(rLvlFrames+1).w		; Can the timer blink?
00003EEC 6600                       		bne.s	.Not0Rings			; If not, branch
00003EEE 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003EF0                            
00003EF0                            .Not0Rings:
00003EF0 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003EF4                            		
00003EF4 303C 0090                  		move.w	#16+128,d0			; X position
00003EF8 323C 0088                  		move.w	#8+128,d1			; Y position
00003EFC 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003F00 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003F04 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003F06 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003F08 4EB8 07D6                  		jsr	DrawSprite.w			; Draw the HUD frame
00003F0C                            
00003F0C                            .RenderRings:
00003F0C 2078 F862                  		movea.l	rRingLoadL.w,a0			; Get starting address of ring data
00003F10 2438 F866                  		move.l	rRingLoadR.w,d2			; Get ending address of ring data
00003F14 9488                       		sub.l	a0,d2				; Get length of the data to read
00003F16 6700                       		beq.s	.End				; If zero length, branch
00003F18 3878 F86A                  		movea.w	rRingStatPtr.w,a4		; Get starting address of status table
00003F1C 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00003F20 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00003F24                            		
00003F24                            .Loop:
00003F24 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00003F26 6B00                       		bmi.s	.Next				; If so, branch
00003F28 3228 0002                  		move.w	2(a0),d1			; Get Y position
00003F2C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00003F30 5041                       		addq.w	#8,d1				; Add 8
00003F32 B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00003F34 6400                       		bhs.s	.Next				; If so, branch
00003F36 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00003F3A 3010                       		move.w	(a0),d0				; Get X position
00003F3C 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00003F3E 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00003F42 7C00                       		moveq	#0,d6
00003F44 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00003F48                            
00003F48                            .Draw:
00003F48 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00003F4A 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00003F4E D25A                       		add.w	(a2)+,d1			; Add Y offset
00003F50 3CC1                       		move.w	d1,(a6)+			; Save Y position
00003F52 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00003F54 1C86                       		move.b	d6,(a6)				; Save it
00003F56 544E                       		addq.w	#2,a6				; Skip link value
00003F58 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00003F5A D05A                       		add.w	(a2)+,d0			; Add X offset
00003F5C 3CC0                       		move.w	d0,(a6)+			; Save X position
00003F5E 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00003F60                            
00003F60                            .Next:
00003F60 5848                       		addq.w	#4,a0				; Next ring in ring data
00003F62 5942                       		subq.w	#4,d2				; Decrement the ring count
00003F64 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00003F66                            
00003F66                            .End:
00003F66 4E75                       		rts
00003F68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F68                            ; Custom mappings format.
00003F68                            ; Differences include...
00003F68                            ;	No offset table (each sprite assumed to be 8 bytes)
00003F68                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00003F68                            ;	Sign-extended Y-pos value
00003F68                            ;	Sign-extended sprite size value
00003F68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F68                            CMap_Ring:
00003F68                            		; Main ring frame
00003F68 FFF8                       		dc.w	$FFF8
00003F6A 0005                       		dc.w	$0005
00003F6C 26BC                       		dc.w	$0000+$26BC
00003F6E FFF8                       		dc.w	$FFF8
00003F70                            
00003F70                            CMap_Ring_Sparkle:
00003F70                            		; Ring sparkle frame 1
00003F70 FFF8                       		dc.w	$FFF8
00003F72 0005                       		dc.w	$0005
00003F74 26B8                       		dc.w	$0000+$26B8
00003F76 FFF8                       		dc.w	$FFF8
00003F78                            		; Ring sparkle frame 2
00003F78 FFF8                       		dc.w	$FFF8
00003F7A 0005                       		dc.w	$0005
00003F7C 3EB8                       		dc.w	($0000+$26B8)|$1800
00003F7E FFF8                       		dc.w	$FFF8
00003F80                            		; Ring sparkle frame 3
00003F80 FFF8                       		dc.w	$FFF8
00003F82 0005                       		dc.w	$0005
00003F84 2EB8                       		dc.w	($0000+$26B8)|$800
00003F86 FFF8                       		dc.w	$FFF8
00003F88                            		; Ring sparkle frame 4
00003F88 FFF8                       		dc.w	$FFF8
00003F8A 0005                       		dc.w	$0005
00003F8C 36B8                       		dc.w	($0000+$26B8)|$1000
00003F8E FFF8                       		dc.w	$FFF8
00003F90                            CMap_Ring_Sparkle_Last:
00003F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F90                            ; HUD mappings
00003F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F90                            Map_HUD:	include	"Level/Objects/HUD/Mappings.asm"
00003F90                            ; --------------------------------------------------------------------------------
00003F90                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00003F90                            ; --------------------------------------------------------------------------------
00003F90                            
00003F90                            SME_dLu6r:	
00003F90 0000 0000                  		dc.w SME_dLu6r4-SME_dLu6r, SME_dLu6r18-SME_dLu6r	
00003F94 0003                       SME_dLu6r4:	dc.b 0, 3	
00003F96 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00003F9C 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
00003FA2 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003FA8 0003                       SME_dLu6r18:	dc.b 0, 3	
00003FAA 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
00003FB0 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00003FB6 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003FBC                            		even
00003FBC                            		even
00003FBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FBC                            ; Update the HUD
00003FBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FBC                            ; PARAMETERS:
00003FBC                            ;	a5.l	- VDP data port
00003FBC                            ;	a6.l	- VDP control port
00003FBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FBC                            ; RETURNS:
00003FBC                            ;	Nothing
00003FBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FBC                            Level_UpdateHUD:
00003FBC 4A38 F8F3                  		tst.b	rUpdateRings.w		; Does the ring counter need to be updated?
00003FC0 6700                       		beq.s	.End				; If not, branch
00003FC2 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
00003FC4 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00003FC8                            
00003FC8                            .DontZero:
00003FC8 4238 F8F3                  		clr.b	rUpdateRings.w		; Clear update value
00003FCC                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00003FCC 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
00003FD2 7200                       		moveq	#0,d1
00003FD4 3238 F3D4                  		move.w	rRings.w,d1			; Ring count
00003FD8 6000                       		bra.s	.UpdateRings			; Update the rings counter
00003FDA                            
00003FDA                            .End
00003FDA 4E75                       		rts
00003FDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FDC                            .UpdateRings:
00003FDC 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00003FDE 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
00003FE4 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00003FE6 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers
00003FEA                            		
00003FEA                            .LoadDigit_Loop:
00003FEA 7400                       		moveq	#0,d2				; Reset the digit
00003FEC 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
00003FEE                            		
00003FEE                            .GetDigit:
00003FEE 9283                       		sub.l	d3,d1				; Subtract
00003FF0 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
00003FF2 5242                       		addq.w	#1,d2				; Increment digit
00003FF4 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00003FF6                            
00003FF6                            .InitDrawDigit:
00003FF6 D283                       		add.l	d3,d1				; Add back
00003FF8 4A42                       		tst.w	d2				; Is the digit 0?
00003FFA 6700                       		beq.s	.DrawDigit			; If so, branch
00003FFC 50C4                       		st	d4				; Set the "draw digit" flag
00003FFE                            
00003FFE                            .DrawDigit:
00003FFE 4A04                       		tst.b	d4				; Should we draw the digit?
00004000 6700                       		beq.s	.NextDigit			; If not, branch
00004002 ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00004004 2C80                       		move.l	d0,(a6)				; Set the VDP command
00004006 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
0000400A                            		rept	16
0000400A                            			move.l	(a3)+,(a5)		; Load the digit art
0000400A                            		endr
0000400A 2A9B                     M 	move.l	(a3)+,(a5)
0000400C 2A9B                     M 	move.l	(a3)+,(a5)
0000400E 2A9B                     M 	move.l	(a3)+,(a5)
00004010 2A9B                     M 	move.l	(a3)+,(a5)
00004012 2A9B                     M 	move.l	(a3)+,(a5)
00004014 2A9B                     M 	move.l	(a3)+,(a5)
00004016 2A9B                     M 	move.l	(a3)+,(a5)
00004018 2A9B                     M 	move.l	(a3)+,(a5)
0000401A 2A9B                     M 	move.l	(a3)+,(a5)
0000401C 2A9B                     M 	move.l	(a3)+,(a5)
0000401E 2A9B                     M 	move.l	(a3)+,(a5)
00004020 2A9B                     M 	move.l	(a3)+,(a5)
00004022 2A9B                     M 	move.l	(a3)+,(a5)
00004024 2A9B                     M 	move.l	(a3)+,(a5)
00004026 2A9B                     M 	move.l	(a3)+,(a5)
00004028 2A9B                     M 	move.l	(a3)+,(a5)
0000402A                            		
0000402A                            .NextDigit:
0000402A 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
00004030 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
00004034 4E75                       		rts
00004036                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004036 0000 0064                  HUDMod_100:	dc.l	100
0000403A 0000 000A                  HUDMod_10:	dc.l	10
0000403E 0000 0001                  HUDMod_1:	dc.l	1
00004042                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004042                            ; Initialize the HUD
00004042                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004042                            Level_InitHUD:
00004042 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
00004048 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
0000404C                            		
0000404C                            Level_HUDResetRings:
0000404C                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
0000404C 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
00004052 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
00004056 343C 0002                  		move.w	#3-1,d2				; Length
0000405A                            
0000405A 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers art
0000405E                            
0000405E                            .LoadTiles:
0000405E 101A                       		move.b	(a2)+,d0			; Get digit
00004060 4880                       		ext.w	d0
00004062 ED48                       		lsl.w	#6,d0				; Turn into offset
00004064 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004068                            
00004068                            		rept	8*2
00004068                            			move.l	(a3)+,(a5)		; Load art
00004068                            		endr
00004068 2A9B                     M 	move.l	(a3)+,(a5)
0000406A 2A9B                     M 	move.l	(a3)+,(a5)
0000406C 2A9B                     M 	move.l	(a3)+,(a5)
0000406E 2A9B                     M 	move.l	(a3)+,(a5)
00004070 2A9B                     M 	move.l	(a3)+,(a5)
00004072 2A9B                     M 	move.l	(a3)+,(a5)
00004074 2A9B                     M 	move.l	(a3)+,(a5)
00004076 2A9B                     M 	move.l	(a3)+,(a5)
00004078 2A9B                     M 	move.l	(a3)+,(a5)
0000407A 2A9B                     M 	move.l	(a3)+,(a5)
0000407C 2A9B                     M 	move.l	(a3)+,(a5)
0000407E 2A9B                     M 	move.l	(a3)+,(a5)
00004080 2A9B                     M 	move.l	(a3)+,(a5)
00004082 2A9B                     M 	move.l	(a3)+,(a5)
00004084 2A9B                     M 	move.l	(a3)+,(a5)
00004086 2A9B                     M 	move.l	(a3)+,(a5)
00004088                            
00004088 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
0000408C                            
0000408C 4E75                       		rts
0000408E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000408E                            HUD_RingsBase:
0000408E 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
00004092 00                         		even
00004092                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004092                            ; HUD art
00004092                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004092                            ArtUnc_HUDNumbers:
00004092                            		incbin	"Level/Objects/HUD/Art - HUD Numbers.unc.bin"
00004312 0000 0000 0000 0000 0000+  		dcb.l	16, 0
00004352                            		even
00004352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004352                            ; Animate the level art
00004352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004352                            ; LEVEL ANIMATION SCRIPTS
00004352                            ;
00004352                            ; The AniArt_DoAnimate subroutine uses these scripts to reload certain tiles,
00004352                            ; thus animating them. All the relevant art must be uncompressed, because
00004352                            ; otherwise the subroutine would spend so much time waiting for the art to be
00004352                            ; decompressed that the VBLANK window would close before all the animating was done.
00004352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004352                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
00004352                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
00004352                            ;		ArtUnc_Flowers1		Source address
00004352                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
00004352                            ;		6			Number of frames
00004352                            ;		2			Number of tiles to load into VRAM for each frame
00004352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004352                            ;	dc.b   0,$7F			Start of the script proper
00004352                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
00004352                            ;		$7F			Frame duration. Only here if global duration is -1
00004352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004352                            AniArt_DoAnimate:
00004352 47F8 F902                  		lea	rAnimCnts.w,a3		; Level art animation counters
00004356 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004358 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
0000435A 4E75                       		rts
0000435C                            
0000435C                            .ListNotEmpty:
0000435C                            .Loop:
0000435C 5313                       		subq.b	#1,(a3)				; Tick down frame duration
0000435E 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
00004360                            
00004360                            .NextFrame:
00004360 7000                       		moveq	#0,d0
00004362 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004366 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
0000436A 6500                       		blo.s	.NotLastFrame			; If not, branch
0000436C 7000                       		moveq	#0,d0				; If so, reset to first frame
0000436E 1740 0001                  		move.b	d0,1(a3)			; ''
00004372                            
00004372                            .NotLastFrame:
00004372 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004376 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004378 6A00                       		bpl.s	.GlobalDuration
0000437A D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
0000437C 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
00004380                            
00004380                            .GlobalDuration:
00004380 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004384 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004386 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
0000438A 2212                       		move.l	(a2),d1				; Get ROM source address
0000438C 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
00004392 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
00004394 7600                       		moveq	#0,d3
00004396 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
0000439A E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
0000439C 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
000043A0                            
000043A0                            .NextScript:
000043A0 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
000043A4 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
000043A6 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
000043A8 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
000043AA                            
000043AA                            .GlobalDuration2:
000043AA 5200                       		addq.b	#1,d0
000043AC 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
000043B0 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
000043B4 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
000043B6 51CE FFA4                  		dbf	d6,.Loop			; Loop
000043BA 4E75                       		rts
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            ; Set an object as solid and check for collision
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For oStatus):
000043BC                            ;	XXPXSXAX
000043BC                            ;	X	- Unused
000043BC                            ;	P	- Pushing flag
000043BC                            ;	S	- Standing on flag
000043BC                            ;	A	- In air flag (for the player)
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
000043BC                            ;	XXXTXBXS
000043BC                            ;	X	- Unused
000043BC                            ;	T	- Touch top flag
000043BC                            ;	B	- Touch bottom flag
000043BC                            ;	S	- Touch side flag
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            ; PARAMETERS:
000043BC                            ;	d1.w	- Object width
000043BC                            ;	d2.w	- Object height / 2 (when jumping)
000043BC                            ;	d3.w	- Object height / 2 (when walking)
000043BC                            ;	d4.w	- Object x-axis position
000043BC                            ;	a0.l	- Object space pointer
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            ; RETURNS:
000043BC                            ;	See object collision return values above
000043BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043BC                            SolidObject:
000043BC 7C00                       		moveq	#0,d6				; Clear collision flag register
000043BE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000043C2 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000043C8 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
000043CC 3401                       		move.w	d1,d2				; Copy object width
000043CE D442                       		add.w	d2,d2				; Double it
000043D0 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000043D6 6600                       		bne.s	.NotOnTop			; If so, branch
000043D8 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000043DC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000043E0 D041                       		add.w	d1,d0				; Add width
000043E2 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000043E4 B042                       		cmp.w	d2,d0				; Compare with the width
000043E6 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000043E8                            
000043E8                            .NotOnTop:
000043E8 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
000043EE 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000043F4 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000043FA 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000043FE 7800                       		moveq	#0,d4				; Set collision status to 0
00004400 4E75                       		rts
00004402                            
00004402                            .IsOnTop:
00004402 3404                       		move.w	d4,d2				; Copy X position to d2
00004404 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004408 7800                       		moveq	#0,d4				; Set collision status to 0
0000440A 4E75                       		rts
0000440C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440C                            ; Set an object as solid and check for collision (even if off screen)
0000440C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440C                            ; PARAMETERS:
0000440C                            ;	d1.w	- Object width
0000440C                            ;	d2.w	- Object height / 2 (when jumping)
0000440C                            ;	d3.w	- Object height / 2 (when walking)
0000440C                            ;	d4.w	- Object x-axis position
0000440C                            ;	a0.l	- Object space pointer
0000440C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440C                            ; RETURNS:
0000440C                            ;	See object collision return values above
0000440C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440C                            SolidObject_Always:
0000440C 7C00                       		moveq	#0,d6				; Clear collision flag register
0000440E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
00004412 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004418 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
0000441C 3401                       		move.w	d1,d2				; Copy object width
0000441E D442                       		add.w	d2,d2				; Double it
00004420 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004426 6600                       		bne.s	.NotOnTop			; If so, branch
00004428 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000442C 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004430 D041                       		add.w	d1,d0				; Add width
00004432 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004434 B042                       		cmp.w	d2,d0				; Compare with the width
00004436 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004438                            
00004438                            .NotOnTop:
00004438 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000443E 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004444 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
0000444A 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000444E 7800                       		moveq	#0,d4				; Set collision status to 0
00004450 4E75                       		rts
00004452                            
00004452                            .IsOnTop:
00004452 3404                       		move.w	d4,d2				; Copy X position to d2
00004454 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004458 7800                       		moveq	#0,d4				; Set collision status to 0
0000445A 4E75                       		rts
0000445C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000445C                            ; Set an object as a solid slope and check for collision
0000445C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000445C                            ; PARAMETERS:
0000445C                            ;	d1.w	- Object width
0000445C                            ;	d2.w	- Object height / 2 (when jumping)
0000445C                            ;	d3.w	- Object height / 2 (when walking)
0000445C                            ;	d4.w	- Object x-axis position
0000445C                            ;	a0.l	- Object space pointer
0000445C                            ;	a2.l	- Slope height data pointer
0000445C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000445C                            ; RETURNS:
0000445C                            ;	See object collision return values above
0000445C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000445C                            SlopedSolid:
0000445C 7C00                       		moveq	#0,d6				; Clear collision flag register
0000445E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
00004462 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004468 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
0000446C 3401                       		move.w	d1,d2				; Copy object width
0000446E D442                       		add.w	d2,d2				; Double it
00004470 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004476 6600                       		bne.s	.NotOnTop			; If so, branch
00004478 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000447C 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004480 D041                       		add.w	d1,d0				; Add width
00004482 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004484 B042                       		cmp.w	d2,d0				; Compare with the width
00004486 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004488                            
00004488                            .NotOnTop:
00004488 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000448E 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004494 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
0000449A 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000449E 7800                       		moveq	#0,d4				; Set collision status to 0
000044A0 4E75                       		rts
000044A2                            
000044A2                            .IsOnTop:
000044A2 3404                       		move.w	d4,d2				; Copy X position to d2
000044A4 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
000044A8 7800                       		moveq	#0,d4				; Set collision status to 0
000044AA 4E75                       		rts
000044AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044AC                            SlopedSolid_ChkCollision:
000044AC 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000044B0 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract current object's X position
000044B4 D041                       		add.w	d1,d0				; Add width to it
000044B6 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000044BA 3601                       		move.w	d1,d3				; Copy width to d3
000044BC D643                       		add.w	d3,d3				; Double it
000044BE B043                       		cmp.w	d3,d0				; Compare to the X position
000044C0 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000044C4 3A00                       		move.w	d0,d5				; Copy the X position to d5
000044C6 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X-flipped?
000044CC 6700                       		beq.s	.NoFlip				; If not, branch
000044CE 4645                       		not.w	d5				; Logical notation on d5
000044D0 DA43                       		add.w	d3,d5				; Add width
000044D2                            
000044D2                            .NoFlip:
000044D2 E24D                       		lsr.w	#1,d5				; Divide by 2
000044D4 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
000044D8 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
000044DA 4883                       		ext.w	d3				; Sign extend to word
000044DC 3A28 0018                  		move.w	oYPos(a0),d5			; Get the current object's Y position
000044E0 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
000044E2 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
000044E6 4883                       		ext.w	d3				; Sign extend to word
000044E8 D443                       		add.w	d3,d2				; Add collision height to the object height
000044EA 3629 0018                  		move.w	oYPos(a1),d3			; Get the player's Y position
000044EE 9645                       		sub.w	d5,d3				; Subtract d5
000044F0 5843                       		addq.w	#4,d3				; Add 4
000044F2 D642                       		add.w	d2,d3				; Add height and collision height
000044F4 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000044F8 3802                       		move.w	d2,d4				; Copy height and collision height
000044FA D844                       		add.w	d4,d4				; Double it
000044FC B644                       		cmp.w	d4,d3				; Compare to Y position
000044FE 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004502 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
00004506                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004506                            SolidObject_ChkColOnScr:
00004506 4A28 000D                  		tst.b	oRender(a0)			; Is the object on screen?
0000450A 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
0000450E                            
0000450E                            SolidObject_ChkCollision:
0000450E 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004512 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004516 D041                       		add.w	d1,d0				; Add width
00004518 3601                       		move.w	d1,d3				; Copy width
0000451A D643                       		add.w	d3,d3				; Double it
0000451C B043                       		cmp.w	d3,d0				; Compare with the X position
0000451E 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004522                            		
00004522 1829 0000                  		move.b	oInitColH(a1),d4		; Get the player's default collision height
00004526 4884                       		ext.w	d4				; Sign extend to word
00004528 D842                       		add.w	d2,d4				; Add height
0000452A 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
0000452E 4883                       		ext.w	d3				; Sign extend to word
00004530 D443                       		add.w	d3,d2				; Add to height
00004532 3629 0018                  		move.w	oYPos(a1),d3			; Get player's Y position
00004536 9668 0018                  		sub.w	oYPos(a0),d3			; Subtract the current object's Y position
0000453A 5843                       		addq.w	#4,d3				; Add 4
0000453C D642                       		add.w	d2,d3				; Add height
0000453E 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
00004542 D842                       		add.w	d2,d4				; Add height
00004544 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004546 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
0000454A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000454A                            SolidObject_ChkBounds:
0000454A 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000454E 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
00004552 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004558 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
0000455C 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004560 6600 0000                  		bne.w	SolidObject_End			; If so, branch
00004564                            
00004564 3A00                       		move.w	d0,d5				; Copy X offset
00004566 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004568 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
0000456A D241                       		add.w	d1,d1				; Double collision width
0000456C 9041                       		sub.w	d1,d0				; Subtract from X offset
0000456E 3A00                       		move.w	d0,d5				; Copy X offset
00004570 4445                       		neg.w	d5				; Negate offset
00004572                            
00004572                            .IsLeft:
00004572 3203                       		move.w	d3,d1				; Copy Y offset
00004574 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004576 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004578 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
0000457A 9644                       		sub.w	d4,d3				; Subtract height from the collision height
0000457C 3203                       		move.w	d3,d1				; Copy Y offset
0000457E 4441                       		neg.w	d1				; Negate offset
00004580                            
00004580                            .IsAbove:
00004580 BA41                       		cmp.w	d1,d5
00004582 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004586 0C41 0004                  		cmpi.w	#4,d1
0000458A 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
0000458E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458E                            SolidObject_Sides:
0000458E 4A40                       		tst.w	d0
00004590 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
00004592 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
00004594 4A69 001C                  		tst.w	oXVel(a1)			; Is the player moving left?
00004598 6B00                       		bmi.s	.AlignPlayer			; If so, branch
0000459A 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
0000459C                            
0000459C                            .ChkRight:
0000459C 4A69 001C                  		tst.w	oXVel(a1)
000045A0 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
000045A2                            
000045A2                            .ClearGroundVel:
000045A2 4269 0000                  		clr.w	oGVel(a1)			; Stop the player from moving
000045A6 4269 001C                  		clr.w	oXVel(a1)			; Clear the player's X velocity
000045AA                            
000045AA                            .AlignPlayer:
000045AA 9169 0014                  		sub.w	d0,oXPos(a1)			; Align player to the side of the object
000045AE 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000045B4 6600                       		bne.s	.InAir				; If so, branch
000045B6 08E8 0005 0028             		bset	#cPushBit,oStatus(a0)		; Set the pushing bit
000045BC 08E9 0005 0028             		bset	#cPushBit,oStatus(a1)		; Set the player's pushing bit
000045C2 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045C6 7801                       		moveq	#1,d4				; Set collision status to 1
000045C8 4E75                       		rts
000045CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045CA                            .InAir:
000045CA 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
000045CC 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045D0 7801                       		moveq	#1,d4				; Set collision status to 1
000045D2 4E75                       		rts
000045D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045D4                            SolidObject_TestClearPush:
000045D4 0828 0005 0028             		btst	#cPushBit,oStatus(a0)		; Is the player pushing this object?
000045DA 6700                       		beq.s	SolidObject_End			; If not, branch
000045DC 0C29 0002 0020             		cmpi.b	#2,oAni(a1)			; Is the player jumping/rolling?
000045E2 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045E4 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)			; Is the player in using the drowning animation
000045EA 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045EC 0C29 001A 0020             		cmpi.b	#$1A,oAni(a1)			; Is the player in using the hurt animation
000045F2 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045F4 337C 0001 0020             		move.w	#1,oAni(a1)			; Make the player use the walking animation
000045FA                            
000045FA                            SolidObject_ClearPush:
000045FA 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear the pushing bit
00004600 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; Clear the player's pushing bit
00004606                            
00004606                            SolidObject_End:
00004606 7800                       		moveq	#0,d4				; Set collision status to 0
00004608 4E75                       		rts
0000460A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000460A                            SolidObject_UpDown:
0000460A 4A43                       		tst.w	d3				; Is the player below the middle of the object?
0000460C 6B00                       		bmi.s	SolidObject_Below		; If so, branch
0000460E 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
00004612 6500                       		bcs.s	SolidObject_Above		; If so, branch
00004614 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
00004616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004616                            SolidObject_Below:
00004616 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving vertically?
0000461A 6700                       		beq.s	.CheckCrush			; If so, branch
0000461C 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
0000461E 4A43                       		tst.w	d3				; Is the player above the middle of the object?
00004620 6A00                       		bpl.s	.SetY				; If so, branch
00004622 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004626                            
00004626                            .SetY:
00004626 9769 0018                  		sub.w	d3,oYPos(a1)			; Push the player below the object
0000462A 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
0000462E 78FE                       		moveq	#-2,d4				; Set the collision status to -2
00004630 4E75                       		rts
00004632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004632                            .CheckCrush:
00004632 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004638 66EC                       		bne.s	.SetY				; If so, branch
0000463A 3800                       		move.w	d0,d4				; Get x offset
0000463C 6A00                       		bpl.s	.NoNeg				; If it's positive branch
0000463E 4444                       		neg.w	d4				; Negate it (absolute value)
00004640                            
00004640                            .NoNeg:
00004640 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004644 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004648                            		
00004648                            		push.l	a0				; Store the current object's address
00004648 2F08                     M 	move.l	a0,-(sp)
0000464A 2049                       		movea.l	a1,a0				; Replace with the player's address
0000464C 4EB9 0000 0000             		jsr	ObjMighty_GetKilled		; Kill the player
00004652                            		pop.l	a0				; Restore the current object's address
00004652 205F                     M 	move.l	(sp)+,a0
00004654 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004658 78FE                       		moveq	#-2,d4				; Set collision status to -2
0000465A 4E75                       		rts
0000465C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000465C                            SolidObject_Above:
0000465C 5943                       		subq.w	#4,d3				; Get the sub Y offset
0000465E                            		
0000465E                            		; This next bit ensures the player does not collide with the top when next to the walls
0000465E                            		; recalculates object width.
0000465E                            
0000465E 7200                       		moveq	#0,d1
00004660 1228 002C                  		move.b	oColW(a0),d1			; Get the current object's width
00004664 3401                       		move.w	d1,d2				; Copy it
00004666 D442                       		add.w	d2,d2				; Double it
00004668                            		
00004668 D269 0014                  		add.w	oXPos(a1),d1			; Add the player's X position
0000466C 9268 0014                  		sub.w	oXPos(a0),d1			; Subtract the current object's X position
00004670 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
00004672                            		
00004672 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
00004674 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004676                            		
00004676 5369 0018                  		subq.w	#1,oYPos(a1)			; Subtract 1 from the player's Y position
0000467A 9769 0018                  		sub.w	d3,oYPos(a1)			; Move the player above the object
0000467E 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004682 6B00                       		bmi.s	.NoCollision			; If so, branch
00004684 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004688 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
0000468C 78FF                       		moveq	#-1,d4				; Set collision status to -1
0000468E 4E75                       		rts
00004690                            
00004690                            .NoCollision:
00004690 7800                       		moveq	#0,d4				; Set collision status to 0
00004692 4E75                       		rts
00004694                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004694                            ; Set an object as a platform and check for collision
00004694                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004694                            ; PARAMETERS:
00004694                            ;	d1.w	- Object's width
00004694                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
00004694                            ;	d3.w	- Object's height
00004694                            ;	d4.w	- Object x-axis position
00004694                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004694                            ; RETURNS:
00004694                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004694                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004694                            PlatformObject:
00004694 7C00                       		moveq	#0,d6				; Clear collision flag register
00004696 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
0000469A 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
000046A0 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
000046A4 3401                       		move.w	d1,d2				; Copy the object's width
000046A6 D442                       		add.w	d2,d2				; Double it
000046A8 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000046AE 6600                       		bne.s	.NotOnTop			; If so, branch
000046B0 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046B4 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046B8 D041                       		add.w	d1,d0				; Add width
000046BA 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000046BC B042                       		cmp.w	d2,d0				; Compare with the width
000046BE 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000046C0                            
000046C0                            .NotOnTop:
000046C0 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000046C6 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000046CC 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000046D2 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000046D6 7800                       		moveq	#0,d4				; Set the collision status to 0
000046D8 4E75                       		rts
000046DA                            
000046DA                            .OnTop:
000046DA 3404                       		move.w	d4,d2				; Copy X position
000046DC 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
000046E0 7800                       		moveq	#0,d4				; Set the collision status to 0
000046E2 4E75                       		rts
000046E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046E4                            Platform_ChkBridgeCol:
000046E4 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000046E8 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000046EC 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046F0 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046F4 D041                       		add.w	d1,d0				; Add width
000046F6 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000046FA B042                       		cmp.w	d2,d0				; Compare with width
000046FC 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004700 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
00004702                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004702                            Platform_ChkCollision:
00004702 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004706 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000470A 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
0000470E 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
00004712 D041                       		add.w	d1,d0				; Add width
00004714 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004718 D241                       		add.w	d1,d1				; Double width
0000471A B041                       		cmp.w	d1,d0				; Compare with width
0000471C 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004720                            
00004720                            Platform_ChkCol_Cont:
00004720 3028 0018                  		move.w	oYPos(a0),d0			; Get the object's Y position
00004724 9043                       		sub.w	d3,d0				; Subtract the height from it
00004726                            
00004726                            PlatformObject_ChkYRange:
00004726 3429 0018                  		move.w	oYPos(a1),d2			; Get the player's Y position
0000472A 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
0000472E 4881                       		ext.w	d1				; Sign extend it
00004730 D242                       		add.w	d2,d1				; Add the Y position to the collision height
00004732 5841                       		addq.w	#4,d1				; Add 4
00004734 9041                       		sub.w	d1,d0				; Subract the result from the Y position
00004736 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
0000473A 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
0000473E 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
00004742 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004746 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
0000474A 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000474E 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004752 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)		; Is the player dead?
00004758 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
0000475C D440                       		add.w	d0,d2				; Add the previous result to the Y position
0000475E 5642                       		addq.w	#3,d2				; Add 3
00004760 3342 0018                  		move.w	d2,oYPos(a1)			; Add to the player's Y position
00004764                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004764                            ; Set the player on top of the object
00004764                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004764                            ; PARAMETERS:
00004764                            ;	a0.l	- Object space pointer
00004764                            ;	a1.l	- Player object space pointer
00004764                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004764                            ; RETURNS:
00004764                            ;	Nothing
00004764                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004764                            RideObject_SetRide:
00004764 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000476A 6700                       		beq.s	.IsStanding			; If not, branch
0000476C 3669 0000                  		movea.w	oInteract(a1),a3		; Get the object the player is standing on
00004770 08AB 0003 0028             		bclr	#cStandBit,oStatus(a3)		; Clear its standing on object bit
00004776 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000477A                            
0000477A                            .IsStanding:
0000477A 3348 0000                  		move.w	a0,oInteract(a1)		; Set it as the object the player is standing on
0000477E 4229 0000                  		clr.b	oAngle(a1)			; Clear the player's angle
00004782 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004786 3369 001C 0000             		move.w	oXVel(a1),oGVel(a1)		; Set the player's X velocity as its ground velocity
0000478C 08E9 0003 0028             		bset	#cStandBit,oStatus(a1)		; Set the player's standing on object bit
00004792 08E8 0003 0028             		bset	#cStandBit,oStatus(a0)		; Set the player standing on this object bir
00004798 08A9 0001 0028             		bclr	#1,oStatus(a1)			; Clear the player's in midair bit
0000479E 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
000047A0 2F08                       		move.l	a0,-(sp)			; Store the current object's address
000047A2 2049                       		movea.l	a1,a0				; Replace it with the player's address
000047A4 6100 E5EE                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
000047A8 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
000047AA                            
000047AA                            PlatformObject_End:
000047AA 4E75                       		rts
000047AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047AC                            ; Set an object as a solid slope and check for collision
000047AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047AC                            ; PARAMETERS:
000047AC                            ;	d1.w	- Object width
000047AC                            ;	d3.w	- Object height
000047AC                            ;	d4.w	- Object x-axis position
000047AC                            ;	a0.l	- Object space pointer
000047AC                            ;	a2.l	- Slope height data pointer
000047AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047AC                            ; RETURNS:
000047AC                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000047AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047AC                            SlopedPlatform:
000047AC 7C00                       		moveq	#0,d6				; Clear collision flag register
000047AE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
000047B2 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
000047B8 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
000047BC 3401                       		move.w	d1,d2				; Copy the object's width
000047BE D442                       		add.w	d2,d2				; Double it
000047C0 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000047C6 6600                       		bne.s	.NotOnTop			; If so, branch
000047C8 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000047CC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000047D0 D041                       		add.w	d1,d0				; Add width
000047D2 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000047D4 B042                       		cmp.w	d2,d0				; Compare with the width
000047D6 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000047D8                            
000047D8                            .NotOnTop:
000047D8 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000047DE 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000047E4 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000047EA 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000047EE 7800                       		moveq	#0,d4				; Set the collision status to 0
000047F0 4E75                       		rts
000047F2                            
000047F2                            .OnTop:
000047F2 3404                       		move.w	d4,d2				; Copy X position
000047F4 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
000047F8 7800                       		moveq	#0,d4				; Set the collision status to 0
000047FA 4E75                       		rts
000047FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047FC                            SlopedPlarform_ChkCol:
000047FC 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004800 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
00004804 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004808 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
0000480C D041                       		add.w	d1,d0				; Add width
0000480E 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004812 D241                       		add.w	d1,d1				; Double width
00004814 B041                       		cmp.w	d1,d0				; Compare with width
00004816 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
0000481A 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
00004820 6700                       		beq.s	.NoXFlip			; If not, skip
00004822 4640                       		not.w	d0				; Logical notation
00004824 D041                       		add.w	d1,d0				; Add width
00004826                            
00004826                            .NoXFlip:
00004826 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004828 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
0000482C 4883                       		ext.w	d3				; Sign extend to word
0000482E 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
00004832 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
00004834 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004838                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004838                            ; Move the player along a platform/solid object
00004838                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004838                            ; PARAMETERS:
00004838                            ;	d2.w	- X position of the platform
00004838                            ;	d3.w	- Height of the platform
00004838                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004838                            ; RETURNS:
00004838                            ;	Nothing
00004838                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004838                            PlayerMoveOnPtfm:
00004838 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
0000483C 9043                       		sub.w	d3,d0				; Subtract height
0000483E 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
00004842 6B00                       		bmi.s	.End				; If so, branch
00004844 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
0000484A 6400                       		bcc.s	.End				; If so, branch
0000484C 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004850 6600                       		bne.s	.End				; If so, branch
00004852 7200                       		moveq	#0,d1
00004854 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004858 9041                       		sub.w	d1,d0				; Subtract from the Y position
0000485A 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000485E 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004862 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004866                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004866                            		;beq.s	.End				; If not branch
00004866                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004866                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004866                            
00004866                            .End:
00004866 4E75                       		rts
00004868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004868                            ; Move the player along a sloped platform/solid object
00004868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004868                            ; PARAMETERS:
00004868                            ;	d3.w	- Height of the platform
00004868                            ;	d4.w	- X position of the platform
00004868                            ;	a2.l	- Slope height data pointer
00004868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004868                            ; RETURNS:
00004868                            ;	Nothing
00004868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004868                            PlayerMoveOnSlope:
00004868 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000486E 6700                       		beq.s	.End				; If not, branch
00004870 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004874 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004878 D041                       		add.w	d1,d0				; Add width
0000487A E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
0000487C 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
00004882 6700                       		beq.s	.NoXFlip			; If not, branch
00004884 4640                       		not.w	d0				; Logical notation on d0
00004886 D041                       		add.w	d1,d0				; Add width
00004888                            
00004888                            .NoXFlip:
00004888 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
0000488C 4881                       		ext.w	d1				; Sign extend to word
0000488E 3028 0018                  		move.w	oYPos(a0),d0			; Get current object's Y position
00004892 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004894 7200                       		moveq	#0,d1
00004896 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
0000489A 9041                       		sub.w	d1,d0				; Subtract from the Y position
0000489C 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
000048A0 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
000048A4 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
000048A8                            
000048A8                            .End:
000048A8 4E75                       		rts
000048AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048AA                            ; Do object collision for the player object
000048AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048AA                            PlayerDoObjCollision:
000048AA 4EB8 3E3C                  		jsr	PlayerRingCollision		; Do ring collision
000048AE                            		
000048AE 3428 0014                  		move.w	oXPos(a0),d2			; Get X position
000048B2 3628 0018                  		move.w	oYPos(a0),d3			; Get Y position
000048B6 5142                       		subq.w	#8,d2				; Get left sensor X
000048B8 7A00                       		moveq	#0,d5
000048BA 1A28 002D                  		move.b	oColH(a0),d5			; Get collision height
000048BE 5705                       		subq.b	#3,d5				; Subtract 3
000048C0 9645                       		sub.w	d5,d3				; Get left sensor Y
000048C2 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
000048C6 DA45                       		add.w	d5,d5				; Get right sensor delta Y
000048C8                            
000048C8 49F8 F354                  		lea	rColList.w,a4			; Get collision response list
000048CC 3C1C                       		move.w	(a4)+,d6			; Get count
000048CE 6700                       		beq.s	.End				; If there are no objects to test, branch
000048D0                            
000048D0                            .ObjLoop:
000048D0 325C                       		movea.w	(a4)+,a1			; Get object
000048D2 1029 002A                  		move.b	oColType(a1),d0			; Does touching it do anything?
000048D6 6600                       		bne.s	.ChkPosition			; If so, branch
000048D8                            
000048D8                            .NextObj:
000048D8 5546                       		subq.w	#2,d6				; Decrement count
000048DA 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
000048DC 7000                       		moveq	#0,d0				; Reset d0
000048DE                            
000048DE                            .End:
000048DE 4278 F354                  		clr.w	rColList.w			; Clear the collision response list count
000048E2 4E75                       		rts
000048E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E4                            .ChkPosition:
000048E4 7200                       		moveq	#0,d1
000048E6 1229 002C                  		move.b	oColW(a1),d1			; Get object width
000048EA 3029 0014                  		move.w	oXPos(a1),d0			; Get object X position
000048EE 9041                       		sub.w	d1,d0				; Get left side of object
000048F0 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
000048F2 6400                       		bcc.s	.ChkRightSide			; If so, branch
000048F4 D241                       		add.w	d1,d1				; Get right side delta X
000048F6 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
000048F8 6500                       		bcs.s	.ChkHeight			; If not, branch
000048FA 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
000048FC                            
000048FC                            .ChkRightSide:
000048FC B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
000048FE 62D8                       		bhi.s	.NextObj			; If not, branch
00004900                            
00004900                            .ChkHeight:
00004900 7200                       		moveq	#0,d1
00004902 1229 002D                  		move.b	oColH(a1),d1			; Get object height
00004906 3029 0018                  		move.w	oYPos(a1),d0			; Get object Y position
0000490A 9041                       		sub.w	d1,d0				; Get top of object
0000490C 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
0000490E 6400                       		bcc.s	.ChkBottom			; If so, branch
00004910 D241                       		add.w	d1,d1				; Get bottom delta Y
00004912 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004914 6500                       		bcs.s	.ChkType			; If not, branch
00004916 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004918                            
00004918                            .ChkBottom:
00004918 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
0000491A 62BC                       		bhi.s	.NextObj			; If not, branch
0000491C                            
0000491C                            .ChkType:
0000491C 7000                       		moveq	#0,d0
0000491E 1029 002A                  		move.b	oColType(a1),d0			; Get collision type
00004922 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004926                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004926                            .CollisionTypes:
00004926 6000                       		bra.s	.Enemy				; Enemy
00004928 6000                       		bra.s	.Indestructable			; Indestructable
0000492A 6000                       		bra.s	.Monitor			; Monitor
0000492C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000492C                            .Enemy:
0000492C 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
00004932 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004936                            
00004936                            .ChkBoss:
00004936 4A29 002B                  		tst.b	oHitCnt(a1)			; Do we have a hit count?
0000493A 6700                       		beq.s	.Kill				; If not, branch
0000493C 4468 001C                  		neg.w	oXVel(a0)			; Bounce backwards
00004940 4468 001E                  		neg.w	oYVel(a0)			; ''
00004944 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004948 5329 002B                  		subq.b	#1,oHitCnt(a1)			; Decrement hit count
0000494C 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
0000494E 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
00004954                            
00004954                            .BossEnd:
00004954 4E75                       		rts
00004956                            
00004956                            .Kill:
00004956 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
0000495C 22BC 0000 0000             		move.l	#ObjExplosion,oAddr(a1)		; Change into an explosion
00004962 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004966 4229 0025                  		clr.b	oRoutine(a1)			; Reset the routine ID
0000496A 4A68 001E                  		tst.w	oYVel(a0)			; Are we going up?
0000496E 6B00                       		bmi.s	.MoveDown			; If so, branch
00004970 3028 0018                  		move.w	oYPos(a0),d0			; Are we below the object?
00004974 B069 0018                  		cmp.w	oYPos(a1),d0			; ''
00004978 6400                       		bhs.s	.MoveUp				; If so, branch
0000497A 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
0000497E 4E75                       		rts
00004980                            
00004980                            .MoveDown:
00004980 0668 0100 001E             		addi.w	#$100,oYVel(a0)			; Move down
00004986 4E75                       		rts
00004988                            
00004988                            .MoveUp:
00004988 0468 0100 001E             		subi.w	#$100,oYVel(a0)			; Move up
0000498E 4E75                       		rts
00004990                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004990                            .Indestructable:
00004990 6000                       		bra.s	.ChkHurt			; Get hurt
00004992                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004992                            .Monitor:
00004992 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00004996 6A00                       		bpl.s	.ChkDestroy			; If it's falling or staying still, branch
00004998 3028 0018                  		move.w	oYPos(a0),d0			; Get player's Y position
0000499C 0440 0010                  		subi.w	#$10,d0				; Subtract 16
000049A0 B069 0018                  		cmp.w	oYPos(a1),d0			; Is the plyaer hitting the bottom of the object?
000049A4 6500                       		blo.s	.MonitorEnd			; If not, branch
000049A6 337C FE80 001E             		move.w	#-$180,oYVel(a1)		; Bounce the monitor up
000049AC 4A29 0000                  		tst.b	oMonFall(a1)			; Is it already falling?
000049B0 6600                       		bne.s	.MonitorEnd			; If so, branch
000049B2 50E9 0000                  		st	oMonFall(a1)			; Set the fall flag
000049B6 4E75                       		rts
000049B8                            
000049B8                            .ChkDestroy:
000049B8 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
000049BE 6600                       		bne.s	.MonitorEnd			; If not, branch
000049C0 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
000049C4 22BC 0000 0000             		move.l	#ObjMonitorBreakOpen,oAddr(a1)	; Set to destroyed routine
000049CA                            		
000049CA                            .MonitorEnd:
000049CA 4E75                       		rts
000049CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049CC                            .ChkHurt:
000049CC 4A68 0000                  		tst.w	oInvulTime(a0)			; Are we invulnerable?
000049D0 6600                       		bne.s	.NoHurt				; If so, branch
000049D2 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
000049D4 4EF9 0000 0000             		jmp	ObjMighty_GetHurt		; Get hurts
000049DA                            
000049DA                            .NoHurt:
000049DA 4E75                       		rts
000049DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DC                            ; Add a new entry to the collision response list
000049DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DC                            AddToColResponse:
000049DC 43F8 F354                  		lea	rColList.w,a1			; Get collision response list
000049E0 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
000049E4 6400                       		bhs.s	.End				; If so, branch
000049E6 5451                       		addq.w	#2,(a1)				; Add a new entry
000049E8 D2D1                       		adda.w	(a1),a1				; Get entry pointer
000049EA 3288                       		move.w	a0,(a1)				; Store entry
000049EC                            
000049EC                            .End:
000049EC 4E75                       		rts
000049EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EE                            ; Save some info in a level (mainly for checkpoints)
000049EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EE                            ; PARAMETERS:
000049EE                            ;	a0.l	- Object space pointer
000049EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EE                            ; RETURNS:
000049EE                            ;	Nothing
000049EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EE                            Level_SaveInfo:
000049EE 31E8 0014 C7B0             		move.w	oXPos(a0),rSavedXPos.w		; Save X position
000049F4 31E8 0018 C7B2             		move.w	oYPos(a0),rSavedYPos.w		; Save Y position
000049FA 4E75                       		rts
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            ; Load some info in a level (mainly for checkpoints)
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            ; PARAMETERS:
000049FC                            ;	a0.l	- Object space pointer
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            ; RETURNS:
000049FC                            ;	Nothing
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            Level_LoadSavedInfo:
000049FC 3178 C7B0 0014             		move.w	rSavedXPos.w,oXPos(a0)		; Load X position
00004A02 3178 C7B2 0018             		move.w	rSavedYPos.w,oYPos(a0)		; Load Y position
00004A08 4E75                       		rts
00004A0A                            ; =========================================================================================================================================================
00004A0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0A                            ; Music IDs
00004A0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0A                            Level_MusicIDs:
00004A0A 0B0B                       		dc.b	mWWZ, mWWZ
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            ; Level water heights (-1 for no water)
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            Level_WaterLevels:
00004A0C                            		;dc.w	$490, -1			; Wacky Workbench
00004A0C FFFF FFFF                  		dc.w	-1, -1
00004A10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A10                            ; Level data pointers
00004A10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A10                            ; FORMAT:
00004A10                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004A10                            ;	dc.l	LAYOUT, OBJECTS, RINGS, COLLISION
00004A10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A10                            Level_DataPointers:
00004A10 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A20 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A30 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A40 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A50                            ; Size and start position data
00004A50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A50                            Level_SizeStartPos:
00004A50 3000 0580                  		dc.w	$3000, $580
00004A54                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A58 3000 0580                  		dc.w	$3000, $580
00004A5C                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A60                            ; Dynamic events routines
00004A60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A60                            Level_DynEvenRouts:
00004A60 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004A64 0000 0000                  		dc.l	DynEv_WWZ
00004A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A68                            ; Wacky Workbench dynamic events routine
00004A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A68                            DynEv_WWZ:
00004A68 7000                       		moveq	#0,d0
00004A6A 1038 F8FE                  		move.b	rDynEvRout.w,d0
00004A6E 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004A72 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A76                            .Index:
00004A76 0000                       		dc.w	.WaitBoss-.Index
00004A78 0000                       		dc.w	.Done-.Index
00004A7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7A                            .WaitBoss:
00004A7A 0C78 2EE0 F880             		cmpi.w	#$2EE0,rCamXPos.w
00004A80 6D00                       		blt.s	.Done
00004A82 31FC 0340 F8CA             		move.w	#$340,rMinCamY.w
00004A88 31FC 0340 F8BE             		move.w	#$340,rDestMaxY.w
00004A8E 31FC 2EE0 F8C8             		move.w	#$2EE0,rMinCamX.w
00004A94 31FC 2EE0 F8C0             		move.w	#$2EE0,rMaxCamX.w
00004A9A 5438 F8FE                  		addq.b	#2,rDynEvRout.w
00004A9E                            
00004A9E                            .Done:
00004A9E 4E75                       		rts
00004AA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA0                            ; Palette cycle routines
00004AA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA0                            Level_PalCycRouts:
00004AA0 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004AA4 0000 0000                  		dc.l	PalCycle_WWZ
00004AA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA8                            ; Wacky Workbench palette cycle routine
00004AA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA8                            PalCycle_WWZ:
00004AA8 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
00004AAC 6600                       		bne.s	.Flash				; If so, branch
00004AAE                            
00004AAE 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004AB2 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004AB4 50F8 F8FF                  		st	rFloorActive.w		; Set the floor active flag
00004AB8 31FC 00B4 F900             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004ABE                            
00004ABE                            .ResetPal:
00004ABE 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset the palette cycle
00004AC2 31FC 0C28 9930             		move.w	#$C28,(rPalette+$62).w		; Set the floor color to be deactivated
00004AC8 31FC 0E48 98B0             		move.w	#$E48,(rWaterPal+$62).w	; ''
00004ACE 4E75                       		rts
00004AD0                            
00004AD0                            .Flash:
00004AD0 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004AD4 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004AD6 4238 F8FF                  		clr.b	rFloorActive.w		; Clear the floor active flag
00004ADA 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004AE0                            
00004AE0                            .UpdatePal:
00004AE0 5338 C7CE                  		subq.b	#1,rPalCycTimer.w		; Decrement the palette cycle timer
00004AE4 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004AE6 11FC 0001 C7CE             		move.b	#1,rPalCycTimer.w		; Reset the palette cycle timer
00004AEC                            
00004AEC 7000                       		moveq	#0,d0
00004AEE 1038 C7CF                  		move.b	rPalCycIndex.w,d0		; Get the palette cycle index
00004AF2 D040                       		add.w	d0,d0				; Turn into offset
00004AF4                            							; Set the floor color
00004AF4 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(rPalette+$62).w
00004AFA 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(rWaterPal+$62).w
00004B00                            
00004B00 5238 C7CF                  		addq.b	#1,rPalCycIndex.w		; Increment the palette cycle index
00004B04 0C38 0005 C7CF             		cmpi.b	#5,rPalCycIndex.w		; Has it reached the end of the cycle?
00004B0A 6500                       		bcs.s	.End				; If not, branch
00004B0C 4238 C7CF                  		clr.b	rPalCycIndex.w		; Reset the palette cycle index
00004B10                            
00004B10                            .End:
00004B10 4E75                       		rts
00004B12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B12                            PalCyc_WWZFloor:
00004B12 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004B1C                            PalCyc_WWZFloorUW:
00004B1C 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004B26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B26                            ; Animated art routines
00004B26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B26                            Level_AniArtRouts:
00004B26 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004B2A 0000 0000                  		dc.l	AniArt_WWZ
00004B2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B2E                            ; Wacky Workbench animated art routine
00004B2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B2E                            AniArt_WWZ:
00004B2E 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004B32 6000 F81E                  		bra.w	AniArt_DoAnimate		; Handle animations
00004B36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B36                            .AniData:
00004B36 0002                       		dc.w	2
00004B38                            
00004B38                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004B38 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004B3C 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004B3E 0408                     M 	dc.b	4,8
00004B40 0008 1018                  		dc.b	0, 8, $10, $18
00004B44                            
00004B44                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004B44 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004B48 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004B4A 0E04                     M 	dc.b	$e,4
00004B4C 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004B5A                            
00004B5A                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004B5A 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004B5E 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004B60 0804                     M 	dc.b	8,4
00004B62 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004B6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6A                            ; Level drawing initialization and update routines
00004B6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6A                            ; PARAMETERS:
00004B6A                            ;	a1.l	- Camera RAM
00004B6A                            ;	a3.l	- Row plane buffer
00004B6A                            ;	a4.l	- Column plane buffer
00004B6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6A                            ; RETURNS:
00004B6A                            ;	Nothing
00004B6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6A                            Level_RenderRouts:
00004B6A 0000 2732                  		dc.l	General_InitFG			; Wacky Workbench
00004B6E 0000 0000                  		dc.l	WWZ_InitBG
00004B72 0000 2752                  		dc.l	General_UpdateFG
00004B76 0000 0000                  		dc.l	WWZ_UpdateBG
00004B7A 0000 2732                  		dc.l	General_InitFG
00004B7E 0000 0000                  		dc.l	WWZ_InitBG
00004B82 0000 2752                  		dc.l	General_UpdateFG
00004B86 0000 0000                  		dc.l	WWZ_UpdateBG
00004B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8A                            ; Wacky Workbench background initialization
00004B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8A                            WWZ_InitBG:
00004B8A 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004B8E 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004B92 E440                       		asr.w	#2,d0				; Divide by $20
00004B94 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004B98                            
00004B98 6100 DED2                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004B9C                            
00004B9C 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004BA0 6000 DF2A                  		bra.w	ScrollSections			; Scroll the planes
00004BA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BA4                            ; Wacky Workbench background update
00004BA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BA4                            WWZ_UpdateBG:
00004BA4 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004BA8 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004BAC E440                       		asr.w	#2,d0				; Divide by $20
00004BAE 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004BB2                            
00004BB2 6100 DF0A                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004BB6 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004BB8 6100 DCAA                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004BBC                            
00004BBC 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004BC0 6000 DF0A                  		bra.w	ScrollSections			; Scroll the planes
00004BC4                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004BC4                            		scrollInit WWZ_Scroll
00004BC4                          M scroll_label	equs	"wwz_scroll"
00004BC4 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004BC6                            
00004BC6                            		; CEILING LIGHTS
00004BC6                            		scrollSection	 48, $80
00004BC6 0080 0000 0030           M 	dc.w	$80,0,48
00004BCC                            		scrollSection	 32, $60
00004BCC 0060 0000 0020           M 	dc.w	$60,0,32
00004BD2                            		scrollSection	 32, $50
00004BD2 0050 0000 0020           M 	dc.w	$50,0,32
00004BD8                            		scrollSection	 24, $40
00004BD8 0040 0000 0018           M 	dc.w	$40,0,24
00004BDE                            		scrollSection	 24, $38
00004BDE 0038 0000 0018           M 	dc.w	$38,0,24
00004BE4                            		scrollSection	 16, $30
00004BE4 0030 0000 0010           M 	dc.w	$30,0,16
00004BEA                            		scrollSection	 16, $2C
00004BEA 002C 0000 0010           M 	dc.w	$2c,0,16
00004BF0                            		scrollSection	 16, $28
00004BF0 0028 0000 0010           M 	dc.w	$28,0,16
00004BF6                            		scrollSection	 16, $24
00004BF6 0024 0000 0010           M 	dc.w	$24,0,16
00004BFC                            		scrollSection	 16, $20
00004BFC 0020 0000 0010           M 	dc.w	$20,0,16
00004C02                            
00004C02                            		; BACK WALL
00004C02                            		scrollSection	160, $40
00004C02 0040 0000 00A0           M 	dc.w	$40,0,160
00004C08                            
00004C08                            		; FRONT WALL
00004C08                            		scrollSection	368, $80
00004C08 0080 0000 0170           M 	dc.w	$80,0,368
00004C0E                            
00004C0E                            		scrollEnd
00004C0E                          M wwz_scroll_end:
00004C0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C0E                            ; Wacky Workbench level data
00004C0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C0E                            WWZ_Layout:
00004C0E                            		incbin	"Level/Level Data/Wacky Workbench/Layout.bin"
00004DEC                            		even
00004DEC                            WWZ_Chunks:
00004DEC                            		incbin	"Level/Level Data/Wacky Workbench/Chunks.bin"
0000583C                            		even
0000583C                            WWZ_Blocks:
0000583C                            		incbin	"Level/Level Data/Wacky Workbench/Blocks.bin"
00005F02                            		even
00005F02                            WWZ_Tiles:
00005F02                            		incbin	"Level/Level Data/Wacky Workbench/Tiles.kosm.bin"
00007630                            		even
00007630 FFFF 0000 0000             		dc.w	$FFFF, 0, 0
00007636                            WWZ_Objects:
00007636                            		incbin	"Level/Level Data/Wacky Workbench/Objects.bin"
000077F2                            		even
000077F2                            WWZ_Rings:
000077F2                            		incbin	"Level/Level Data/Wacky Workbench/Rings.bin"
00007AC2                            		even
00007AC2                            WWZ_Pal:
00007AC2 007F                       		dc.w	$100>>1-1
00007AC4                            		incbin	"Level/Level Data/Wacky Workbench/Palette.pal.bin"
00007B44                            		incbin	"Level/Level Data/Wacky Workbench/Palette (Water).pal.bin"
00007BC4                            		even
00007BC4                            WWZ_Collision:
00007BC4 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
00007BD4                            .ColData:
00007BD4                            		incbin	"Level/Level Data/Wacky Workbench/Collision.bin"
000081D4                            		even
000081D4                            .Angles:
000081D4                            		incbin	"Level/Level Data/Wacky Workbench/Angle Values.bin"
000082D4                            		even
000082D4                            .Heights:
000082D4                            		incbin	"Level/Level Data/Wacky Workbench/Height Values.bin"
000092D4                            		even
000092D4                            .HeightsR:
000092D4                            		incbin	"Level/Level Data/Wacky Workbench/Height Values (Rotated).bin"
0000A2D4                            		even
0000A2D4                            ArtUnc_Electricity:
0000A2D4                            		incbin	"Level/Level Data/Wacky Workbench/Electricity.bin"
0000A6D4                            		even
0000A6D4                            ArtUnc_ElectricOrbs:
0000A6D4                            		incbin	"Level/Level Data/Wacky Workbench/Electric Orbs.bin"
0000A8D4                            		even
0000A8D4                            ArtUnc_Sirens:
0000A8D4                            		incbin	"Level/Level Data/Wacky Workbench/Sirens.bin"
0000AAD4                            		even
0000AAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAD4                            ; Main level PLCs
0000AAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAD4                            PLC_LevelMain:
0000AAD4 000A                       		dc.w	$A
0000AAD6 0000 0000                  		dc.l	ArtKosM_Chkpoint
0000AADA AFC0                       		dc.w	$AFC0
0000AADC 0000 0000                  		dc.l	ArtKosM_Monitor
0000AAE0 B100                       		dc.w	$B100
0000AAE2 0000 0000                  		dc.l	ArtKosM_SpringH
0000AAE6 B740                       		dc.w	$B740
0000AAE8 0000 0000                  		dc.l	ArtKosM_SpringV
0000AAEC B940                       		dc.w	$B940
0000AAEE 0000 0000                  		dc.l	ArtKosM_SpringD
0000AAF2 BB20                       		dc.w	$BB20
0000AAF4 0000 0000                  		dc.l	ArtKosM_HUD
0000AAF8 D000                       		dc.w	$D000
0000AAFA 0000 0000                  		dc.l	ArtKosM_WaterSurface
0000AAFE D200                       		dc.w	$D200
0000AB00 0000 0000                  		dc.l	ArtKosM_SpikesN
0000AB04 D500                       		dc.w	$D500
0000AB06 0000 0000                  		dc.l	ArtKosM_SpikesS
0000AB0A D580                       		dc.w	$D580
0000AB0C 0000 0000                  		dc.l	ArtKosM_RingSparkle
0000AB10 D700                       		dc.w	$D700
0000AB12 0000 0000                  		dc.l	ArtKosM_Explosion
0000AB16 D800                       		dc.w	$D800
0000AB18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB18                            ; Level PLCs
0000AB18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB18                            Level_PLCs:
0000AB18 0000 0000                  		dc.l	PLC_WWZ
0000AB1C 0000 0000                  		dc.l	PLC_WWZ
0000AB20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB20                            ; Wacky Workbench PLCs
0000AB20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB20                            PLC_WWZ:
0000AB20 0000                       		dc.w	0
0000AB22 0000 0000                  		dc.l	ArtKosM_Bumper
0000AB26 6B60                       		dc.w	$6B60
0000AB28                            	;	dc.l	ArtKosM_Orbinaut
0000AB28                            	;	dc.w	$71A0
0000AB28                            	;	dc.l	ArtKosM_Diamond
0000AB28                            	;	dc.w	$7580
0000AB28                            	;	dc.l	ArtKosM_CNZBarrel
0000AB28                            	;	dc.w	$7A00
0000AB28                            	;	dc.l	ArtKosM_Slicer
0000AB28                            	;	dc.w	$8000
0000AB28                            	;	dc.l	ArtKosM_ShlCrker
0000AB28                            	;	dc.w	$8400
0000AB28                            	;	dc.l	ArtKosM_Asteron
0000AB28                            	;	dc.w	$8880
0000AB28                            	;	dc.l	ArtKosM_Harpoon
0000AB28                            	;	dc.w	$8A60
0000AB28                            	;	dc.l	ArtKosM_WFZBoss
0000AB28                            	;	dc.w	$9000
0000AB28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB28                            ; Art
0000AB28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB28                            ArtKosM_HUD:
0000AB28                            		incbin	"Level/Objects/HUD/Art - HUD Base.kosm.bin"
0000AB9E                            		even
0000AB9E                            ArtKosM_RingSparkle:
0000AB9E                            		incbin	"Level/Objects/Ring/Art - Sparkle.kosm.bin"
0000ABEA 00                         		even
0000ABEA                            ArtUnc_Ring:
0000ABEA                            		incbin	"Level/Objects/Ring/Art - Ring.unc.bin"
0000AFEA                            		even
0000AFEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFEA                            ; Object index
0000AFEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFEA                            Level_ObjIndex:
0000AFEA 0000 0000                  		dc.l	ObjMonitor
0000AFEE 0000 0000                  		dc.l	ObjSpike
0000AFF2 0000 0000                  		dc.l	ObjSpring
0000AFF6 0000 0000                  		dc.l	ObjCheckpoint
0000AFFA 0000 0000                  		dc.l	ObjNull			;ObjSlicer
0000AFFE 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
0000B002 0000 0000                  		dc.l	ObjNull			;ObjAsteron
0000B006 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
0000B00A 0000 0000                  		dc.l	ObjWallSpring
0000B00E 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
0000B012 0000 0000                  		dc.l	ObjBallMode
0000B016 0000 0000                  		dc.l	ObjBumper
0000B01A 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
0000B01E 0000 0000                  		dc.l	ObjNull			;ObjDiamond
0000B022 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
0000B026                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B026                            ; Objects
0000B026                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B026                            ObjNull:
0000B026 4EF8 1A06                  		jmp	DeleteObject
0000B02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B02A                            		include	"Level/Objects/Mighty/Code.asm"		; Mighty object
0000B02A                            ; =========================================================================================================================================================
0000B02A                            ; Mighty The Armadillo in PRISM PARADISE
0000B02A                            ; By Nat The Porcupine 2021
0000B02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B02A                            ; Sonic object
0000B02A                            ; =========================================================================================================================================================
0000B02A =00000600                  TOP_SPD		EQU	$600				; Top speed
0000B02A =0000000C                  ACC_SPD		EQU	$C				; Acceleration
0000B02A =00000080                  DEC_SPD		EQU	$80				; Deceleration
0000B02A =00000680                  JUMP_HEIGHT	EQU	$680				; Jump height
0000B02A =00000400                  MIN_JMP_HEIGHT	EQU	$400				; Minimum jump height
0000B02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B02A                            		rsset	oLvlSSTs
0000B02A =00000030                  oInitColH	rs.b	1				; Initial collision height
0000B02A =00000031                  oInitColW	rs.b	1				; Initial collision width
0000B02A =00000032                  oTopSolid	rs.b	1				; Top solid bit
0000B02A =00000033                  oLRBSolid	rs.b	1				; LRB solid bit
0000B02A =00000034                  oTopSpd		rs.w	1				; Top speed
0000B02A =00000036                  oAcc		rs.w	1				; Acceleration
0000B02A =00000038                  oDec		rs.w	1				; Deceleration
0000B02A =0000003A                  oFlipDir	rs.w	0				; Flip direction
0000B02A =0000003A                  oGVel		rs.w	1				; Ground velocity
0000B02A =0000003C                  oInteract	rs.w	1				; Interacted object space pointer
0000B02A =0000003E                  oAirTimer	rs.b	1				; Air timer
0000B02A =0000003F                  oMoveLock	rs.b	1				; Move lock timer
0000B02A =00000040                  oJumping	rs.b	1				; Jumping flag
0000B02A =00000041                  oAngle		rs.b	1				; Angle
0000B02A =00000042                  oInvulTime	rs.b	1				; Invulnerability timer
0000B02A =00000043                  oDeathTimer	rs.b	1				; Death timer
0000B02A =00000044                  oScrlDelay	rs.b	1				; Look up and down scroll delay counter
0000B02A =00000045                  oDashFlag	rs.b	1				; Dash flags
0000B02A =00000046                  oDashTimer	rs.b	1				; Dash timer
0000B02A =00000047                  oFlipAngle	rs.b	1				; Flip angle about the X axis
0000B02A =00000048                  oFlipTurned	rs.b	1				; Inverted flip flag
0000B02A =00000049                  oFlipRemain	rs.b	1				; Remaining flips to do
0000B02A =0000004A                  oFlipSpeed	rs.b	1				; Flip speed
0000B02A =0000004B                  oBallMode	rs.b	1				; Ball mode flag
0000B02A =0000004C                  oHangAniTime	rs.b	1				; Hang animation timer
0000B02A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B02A                            ObjMighty:
0000B02A 7000                       		moveq	#0,d0
0000B02C 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0000B030 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0000B034                            	nextObject
0000B034 3068 0004                M 	movea.w	onext(a0),a0
0000B038 2250                     M 	move.l	oaddr(a0),a1
0000B03A 4ED1                     M 	jmp	(a1)
0000B03C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03C                            .Index:
0000B03C 6000 0000                  		bra.w	ObjMighty_Init			; Initialization(00)
0000B040 6000 0000                  		bra.w	ObjMighty_Main			; Main		(04)
0000B044 6000 0000                  		bra.w	ObjMighty_Hurt			; Hurt		(08)
0000B048 6000 0000                  		bra.w	ObjMighty_Dead			; Dead		(0C)
0000B04C 6000 0000                  		bra.w	ObjMighty_Gone			; Gone		(10)
0000B050                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B050                            ; Initialization routine
0000B050                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B050                            ObjMighty_Init:
0000B050 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0000B054                            
0000B054 117C 0009 002C             		move.b	#9,oColW(a0)			; Collision width
0000B05A 117C 0013 002D             		move.b	#$13,oColH(a0)			; Collision height
0000B060 1168 002C 0031             		move.b	oColW(a0),oInitColW(a0)		; Set initial collision width
0000B066 1168 002D 0030             		move.b	oColH(a0),oInitColH(a0)		; Set initial collision height
0000B06C 217C 0000 0000 0010        		move.l	#Map_ObjMighty,oMap(a0)		; Mappings
0000B074 317C 0780 000E             		move.w	#$780,oVRAM(a0)			; Sprite tile properties
0000B07A                            	displaySprite	2,a0,a1,0			; Priority
0000B07A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000B080 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000B084 3149 000A                M 	move.w	a1,odrawprev(a0)
0000B088 3348 0008                M 	move.w	a0,odrawnext(a1)
0000B08C 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000B090                          M .no_199
0000B090 117C 0018 0017             		move.b	#$18,oDrawW(a0)			; Sprite width
0000B096 117C 0018 001B             		move.b	#$18,oDrawH(a0)			; Sprite height
0000B09C 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0000B0A2                            
0000B0A2 117C 000C 0032             		move.b	#$C,oTopSolid(a0)		; Top solid bit
0000B0A8 117C 000D 0033             		move.b	#$D,oLRBSolid(a0)		; LRB solid bit
0000B0AE 117C 001E 003E             		move.b	#$1E,oAirTimer(a0)		; Set air timer
0000B0B4 50D0                       		st	oPrevDPLC(a0)			; Reset saved DPLC frame
0000B0B6 4228 0049                  		clr.b	oFlipRemain(a0)			; No flips remaining
0000B0BA 117C 0004 004A             		move.b	#4,oFlipSpeed(a0)		; Flip speed
0000B0C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C0                            ; Main routine
0000B0C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0C0                            ObjMighty_Main:
0000B0C0 4A38 C768                  		tst.b	rMoveCheat.w
0000B0C4 6700                       		beq.s	.NoPlacementEnter
0000B0C6 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000B0CC 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000B0CE 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000B0D4 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000B0DA 4E75                       		rts
0000B0DC                            
0000B0DC                            .NoPlacementEnter:
0000B0DC 0828 0002 000C             		btst	#2,oFlags(a0)			; Are the controls locked?
0000B0E2 6600                       		bne.s	.Update				; If so, branch
0000B0E4 31F8 C740 F8D4             		move.w	rP1Data.w,rCtrl.w		; Set the player's control data
0000B0EA                            
0000B0EA                            .Update:
0000B0EA                            	;	btst	#1,oStatus(a0)
0000B0EA                            	;	bne.s	.NotOnGround
0000B0EA                            
0000B0EA                            ;.NotOnGround:
0000B0EA 6100 0000                  		bsr.w	ObjMighty_Water			; Handle Sonic in water
0000B0EE 6100 0000                  		bsr.w	ObjMighty_GetPhysics		; Update Sonic's physics
0000B0F2 6100 0000                  		bsr.w	ObjMighty_DoModes		; Do modes
0000B0F6 6100 0000                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000B0FA 4EB8 48AA                  		jsr	PlayerDoObjCollision		; Do object collision
0000B0FE                            
0000B0FE 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000B102 6100 0000                  		bsr.w	ObjMighty_Display		; Display sprite
0000B106 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000B10A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B10A                            ; Handle the extended camera
0000B10A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B10A                            ObjMighty_ExtendedCam:
0000B10A 3238 F8D2                  		move.w	rCamXPosCenter.w,d1		; Get camera X center
0000B10E 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B112 6A00                       		bpl.s	.PosGVel			; Get absolute value
0000B114 4440                       		neg.w	d0				; ''
0000B116                            
0000B116                            .PosGVel:
0000B116 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
0000B11A 6500                       		bcs.s	.ResetXShift			; If not, branch
0000B11C 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000B120 6A00                       		bpl.s	.MoveRight			; If so, branch
0000B122 5441                       		addq.w	#2,d1				; Move right
0000B124 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
0000B128 6500                       		bcs.s	.SetShift			; ''
0000B12A 323C 00E0                  		move.w	#$E0,d1				; ''
0000B12E 6000                       		bra.s	.SetShift			; Continue
0000B130                            
0000B130                            .MoveRight:
0000B130 5541                       		subq.w	#2,d1				; Move left
0000B132 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
0000B136 6400                       		bcc.s	.SetShift			; ''
0000B138 323C 0060                  		move.w	#$60,d1				; ''
0000B13C 6000                       		bra.s	.SetShift			; Continue
0000B13E                            
0000B13E                            .ResetXShift:
0000B13E 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
0000B142 6700                       		beq.s	.SetShift			; If so, branch
0000B144 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
0000B146 5441                       		addq.w	#2,d1				; Move back right
0000B148 6000                       		bra.s	.SetShift			; Continue
0000B14A                            
0000B14A                            .ReduceShift:
0000B14A 5541                       		subq.w	#2,d1				; Move back left
0000B14C                            
0000B14C                            .SetShift:
0000B14C 31C1 F8D2                  		move.w	d1,rCamXPosCenter.w		; Set camera X center
0000B150 4E75                       		rts
0000B152                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B152                            ; Update Sonic's physics
0000B152                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B152                            ObjMighty_GetPhysics:
0000B152 7000                       		moveq	#0,d0
0000B154 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000B15A 6700                       		beq.s	.GetOffset			; If not, branch
0000B15C 7008                       		moveq	#8,d0				; Set the underwater bit
0000B15E                            
0000B15E                            .GetOffset:
0000B15E 43FB 0000                  		lea	ObjMighty_Physics(pc,d0.w),a1	; Get pointer to correct physics values
0000B162 2159 0034                  		move.l	(a1)+,oTopSpd(a0)		; Set top speed and acceleration
0000B166 3151 0038                  		move.w	(a1),oDec(a0)			; Set deceleration
0000B16A 4E75                       		rts
0000B16C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B16C                            ; Physics values
0000B16C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B16C                            ; FORMAT:
0000B16C                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
0000B16C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B16C                            ObjMighty_Physics:
0000B16C 0600 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
0000B174 0300 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
0000B17C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B17C                            ; Handle Sonic in the water
0000B17C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B17C                            ObjMighty_Water:
0000B17C 4A38 F8F4                  	tst.b	rWaterFlag.w			; Is there water in the level?
0000B180 6600                       	bne.s	.HandleWater			; If so, branch
0000B182                            
0000B182                            .End:
0000B182 4E75                       	rts
0000B184                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B184                            .HandleWater:
0000B184 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
0000B188 B068 0018                  		cmp.w	oYPos(a0),d0			; Is Lover in the water?
0000B18C 6C00                       		bge.s	.NotInWater			; If not, branch
0000B18E                            
0000B18E 08E8 0006 0028             		bset	#6,oStatus(a0)			; Set the "in water" flag
0000B194 66EC                       		bne.s	.End				; If Lover is already in the water, branch
0000B196                            
0000B196 E0E8 001C                  		asr.w	oXVel(a0)			; Make Lover move slower
0000B19A E0E8 001E                  		asr.w	oYVel(a0)
0000B19E E0E8 001E                  		asr.w	oYVel(a0)
0000B1A2 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
0000B1A4                            
0000B1A4                            		playSnd	#sSplash, 2			; Play splash sound
0000B1A4 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B1AA 4E75                       		rts
0000B1AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1AC                            .NotInWater:
0000B1AC 08A8 0006 0028             		bclr	#6,oStatus(a0)			; Clear "in water" flag
0000B1B2 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
0000B1B4                            
0000B1B4 0C28 0010 0025             		cmpi.b	#$10,oRoutine(a0)			; Is Lover falling back from getting hurt?
0000B1BA 6700                       		beq.s	.ChkSplash			; If so, branch
0000B1BC E1E8 001E                  		asl	oYVel(a0)			; Make Lover move faster vertically
0000B1C0                            
0000B1C0                            .ChkSplash:
0000B1C0 4A68 001E                  		tst.w	oYVel(a0)			; Does a splash need to be created?
0000B1C4 67BC                       		beq.s	.End				; If not, branch
0000B1C6                            
0000B1C6 0C68 F000 001E             		cmpi.w	#-$1000,oYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
0000B1CC 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
0000B1CE 317C F000 001E             		move.w	#-$1000,oYVel(a0)		; Cap the speed
0000B1D4                            
0000B1D4                            .PlaySplashSnd:
0000B1D4                            		playSnd	#sSplash, 2			; Play splash sound
0000B1D4 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B1DA 4E75                       		rts
0000B1DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1DC                            ; Do Sonic's modes
0000B1DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1DC                            ObjMighty_DoModes:
0000B1DC 0828 0000 000C             		btst	#0,oFlags(a0)			; Is running Sonic's mode disabled?
0000B1E2 6600                       		bne.s	.NoMode				; If so, branch
0000B1E4                            
0000B1E4 7000                       		moveq	#0,d0
0000B1E6 1028 0028                  		move.b	oStatus(a0),d0			; Get status
0000B1EA 0240 0006                  		andi.w	#6,d0				; Only get mode bits
0000B1EE D040                       		add.w	d0,d0
0000B1F0 4EBB 0000                  		jsr	ObjMighty_Modes(pc,d0.w)	; Jump to the right routine
0000B1F4                            
0000B1F4 6100 FF14                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000B1F8 6100 0000                  		bsr.w	ObjMighty_ChkBounce		; Check for bouncy floor collision
0000B1FC 6100 0000                  		bsr.w	ObjMighty_ChkHang		; Check for hanging
0000B200 6000 0000                  		bra.w	ObjMighty_ChkElectric		; Check for electricity
0000B204                            
0000B204                            .NoMode:
0000B204 4E75                       		rts
0000B206                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B206                            ; Sonic's modes
0000B206                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B206                            ObjMighty_Modes:
0000B206 6000 0000                  		bra.w	ObjMighty_MdGround		; Ground
0000B20A 6000 0000                  		bra.w	ObjMighty_MdAir			; Air
0000B20E 6000 0000                  		bra.w	ObjMighty_MdRoll		; Roll
0000B212 6000 0000                  		bra.w	ObjMighty_MdJump		; Jumping
0000B216                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B216                            ; Ground mode
0000B216                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B216                            ObjMighty_MdGround:
0000B216 6100 0000                  		bsr.w	ObjMighty_Peelout		; Handle the peelout
0000B21A 6100 0000                  		bsr.w	ObjMighty_Spindash		; Handle the spindash
0000B21E 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B222 6100 0000                  		bsr.w	ObjMighty_ChkRoll		; Check for rolling
0000B226 6100 0000                  		bsr.w	ObjMighty_MoveGround		; Do movement on the ground
0000B22A 4EB8 1CE0                  		jsr	ObjectMove.w			; Allow movement
0000B22E 4EB8 3222                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B232                            
0000B232 6100 0000                  		bsr.w	ObjMighty_SlopePush		; Affect Sonic's speed on a slope
0000B236 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B23A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B23A                            ; Misc. updates
0000B23A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B23A                            ObjMighty_MiscUpdates:
0000B23A 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer finished?
0000B23E 6700                       		beq.s	.NoMoveLock			; If so, branch
0000B240 5328 003F                  		subq.b	#1,oMoveLock(a0)		; Decrement the timer
0000B244                            
0000B244                            .NoMoveLock:
0000B244 4EB8 2F3A                  		jsr	sub_F846
0000B248 4A41                       		tst.w	d1
0000B24A 6B00 0000                  		bmi.w	ObjMighty_GetKilled
0000B24E 4EB8 31CA                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
0000B252 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B254 6A00                       		bpl.s	.ChkRight			; If not, branch
0000B256 9368 0014                  		sub.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B25A                            
0000B25A                            .ChkRight:
0000B25A 4EB8 304E                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
0000B25E 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B260 6A00                       		bpl.s	.End				; If not, branch
0000B262 D368 0014                  		add.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B266                            
0000B266                            .End:
0000B266 4E75                       		rts
0000B268                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B268                            ; Air and jump modes
0000B268                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B268                            ObjMighty_MdJump:
0000B268                            ObjMighty_MdAir:
0000B268 4268 003C                  		clr.w	oInteract(a0)			; Sonic cannot be interacting with objects while in midair
0000B26C 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; ''
0000B272                            
0000B272 0828 0003 000C             		btst	#3,oFlags(a0)			; Is Sonic hanging?
0000B278 6700                       		beq.s	.DoModes			; If not, branch
0000B27A 6100 0000                  		bsr.w	ObjMighty_Hang			; Hang
0000B27E 6000                       		bra.s	.DoCol				; Continue
0000B280                            
0000B280                            .DoModes:
0000B280 6100 0000                  		bsr.w	ObjMighty_JumpHeight		; Handle jump height
0000B284 6100 0000                  		bsr.w	ObjMighty_MoveAir		; Do movement
0000B288 4EB8 1CFA                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000B28C 0C68 1000 001E             		cmpi.w	#$1000,oYVel(a0)		; Is Sonic moving down too fasr?
0000B292 6F00                       		ble.s	.NoCap				; If not, branch
0000B294 317C 1000 001E             		move.w	#$1000,oYVel(a0)		; Cap the downward speed
0000B29A                            
0000B29A                            .NoCap:
0000B29A 6100 0000                  		bsr.w	ObjMighty_JumpAngle		; Reset Sonic's angle in mid air
0000B29E                            
0000B29E                            .DoCol:
0000B29E 0828 0006 0028             		btst	#6,oStatus(a0)
0000B2A4 6700                       		beq.s	.NoWater
0000B2A6 0468 0028 001E             		subi.w	#$28,oYVel(a0)
0000B2AC                            
0000B2AC                            .NoWater:
0000B2AC 4EB8 2BA8                  		jsr	PlayerChkCollision		; Check for level collision
0000B2B0 6088                       		bra.s	ObjMighty_MiscUpdates
0000B2B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2B2                            ; Roll mode
0000B2B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2B2                            ObjMighty_MdRoll:
0000B2B2 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B2B6 6600                       		bne.s	.NoJump				; If so, branch
0000B2B8 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B2BC                            
0000B2BC                            .NoJump:
0000B2BC 6100 0000                  		bsr.w	ObjMighty_RollSlopePush		; Push Sonic on a slope while rolling
0000B2C0 6100 0000                  		bsr.w	ObjMighty_MoveRoll		; Do movement
0000B2C4 4EB8 1CE0                  		jsr	ObjectMove.w			; Allow movement
0000B2C8 4EB8 3222                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B2CC                            
0000B2CC 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B2D0 6000 FF68                  		bra.w	ObjMighty_MiscUpdates		; Do misc. updates
0000B2D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2D4                            ; Do movement on the ground
0000B2D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2D4                            ObjMighty_MoveGround:
0000B2D4 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B2D8 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B2DC 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B2E0                            
0000B2E0 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B2E4 6600 0000                  		bne.w	.ResetScr			; If so, branch
0000B2E8                            
0000B2E8 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left held?
0000B2EE 6700                       		beq.s	.NotLeft			; If so, branch
0000B2F0 6100 0000                  		bsr.w	ObjMighty_MoveLeft		; Move left
0000B2F4                            
0000B2F4                            .NotLeft:
0000B2F4 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right held?
0000B2FA 6700                       		beq.s	.NotRight			; If so, branch
0000B2FC 6100 0000                  		bsr.w	ObjMighty_MoveRight		; Move right
0000B300                            
0000B300                            .NotRight:
0000B300 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B304 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B308 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000B30C 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
0000B310 4A68 003A                  		tst.w	oGVel(a0)			; Has Sonic already been halted?
0000B314 6600 0000                  		bne.w	.ResetScr			; If not, branch
0000B318                            
0000B318 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B31E 117C 0005 0020             		move.b	#5,oAni(a0)			; Set to ducking animation
0000B324                            
0000B324 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is Sonic standing on an object?
0000B32A 6700 0000                  		beq.w	.ChkBalance			; If not, branch
0000B32E 3268 003C                  		movea.w	oInteract(a0),a1		; Get interacted object
0000B332 4A29 0028                  		tst.b	oStatus(a1)			; Is Sonic standing on it?
0000B336 6B00                       		bmi.s	.ChkLookUp			; If not, branch
0000B338 7200                       		moveq	#0,d1
0000B33A 1229 002C                  		move.b	oColW(a1),d1			; Get width of object
0000B33E 3401                       		move.w	d1,d2				; Copy it
0000B340 D442                       		add.w	d2,d2				; Double the copy
0000B342 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
0000B344 D268 0014                  		add.w	oXPos(a0),d1			; Add Sonic's X position
0000B348 9269 0014                  		sub.w	oXPos(a1),d1			; Subtract the object's X position
0000B34C 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
0000B350 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
0000B352 B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
0000B354 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
0000B356 6000                       		bra.s	.ChkLookUp			; Continue
0000B358                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B358                            .ChkBalance:
0000B358 4EB8 2F10                  		jsr	PlayerChkFloorDist		; Get floor distance
0000B35C 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
0000B360 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000B362 0C28 0003 002E             		cmpi.b	#3,oNextTilt(a0)		; Is Sonic balancing on the right side?
0000B368 6600                       		bne.s	.ChkLeftBalance			; If not, branch
0000B36A                            
0000B36A                            .BalanceOnObjRight:
0000B36A 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B370 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000B372                            
0000B372                            .ChkLeftBalance:
0000B372 0C28 0003 002F             		cmpi.b	#3,oTilt(a0)			; Is Sonic balancing on the left side?
0000B378 6600                       		bne.s	.ChkLookUp			; If not, branch
0000B37A                            
0000B37A                            .BalanceOnObjLeft:
0000B37A 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B380                            
0000B380                            .SetBalanceAnim:
0000B380 117C 0006 0020             		move.b	#6,oAni(a0)			; Set balancing animation
0000B386 6000                       		bra.s	.ResetScr			; Continue
0000B388                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B388                            .ChkLookUp:
0000B388 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is the up button being held?
0000B38E 6700                       		beq.s	.ChkDown			; If not, branch
0000B390 117C 0007 0020             		move.b	#7,oAni(a0)			; Set to looking up animation
0000B396                            
0000B396 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B39A 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B3A0 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B3A2 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B3A8 0C78 00C8 F8CC             		cmpi.w	#200,rCamYPosDist.w		; Has the camera finished scrolling?
0000B3AE 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3B0 5478 F8CC                  		addq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3B4 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B3B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3B6                            .ChkDown:
0000B3B6 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is the down button being held?
0000B3BC 6700                       		beq.s	.ResetScr			; If not, branch
0000B3BE 117C 0008 0020             		move.b	#8,oAni(a0)			; Set to ducking animation
0000B3C4                            
0000B3C4 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B3C8 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B3CE 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B3D0 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B3D6 0C78 0008 F8CC             		cmpi.w	#8,rCamYPosDist.w		; Has the camera finished scrolling?
0000B3DC 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3DE 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3E2 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B3E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3E4                            .ResetScr:
0000B3E4 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000B3E8                            
0000B3E8                            .ResetScrPart2:
0000B3E8 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B3EE 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3F0 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B3F2 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B3F6                            
0000B3F6                            .ScrollUp:
0000B3F6 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B3FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3FA                            .UpdateSpdOnGround:
0000B3FA 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000B3FE 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000B402 6600                       		bne.s	.ApplySpeed			; If so, branch
0000B404                            
0000B404 3028 003A                  		move.w	oGVel(a0),d0			; Get current ground velocity
0000B408 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
0000B40A 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
0000B40C                            
0000B40C                            .SettleRight:
0000B40C 9045                       		sub.w	d5,d0				; Slow down
0000B40E 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
0000B410 7000                       		moveq	#0,d0				; Stop the movement
0000B412 6000                       		bra.s	.SetSpeed			; Continue
0000B414                            
0000B414                            .SettleLeft:
0000B414 D045                       		add.w	d5,d0				; Slow down
0000B416 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
0000B418 7000                       		moveq	#0,d0				; Stop the movement
0000B41A                            
0000B41A                            .SetSpeed:
0000B41A 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B41E                            
0000B41E                            .ApplySpeed:
0000B41E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B422 4EB8 1308                  		jsr	CalcSine.w			; Get the sine and cosine
0000B426 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B42A C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B42E E081                       		asr.l	#8,d1				; Shift the values over
0000B430 E080                       		asr.l	#8,d0				; ''
0000B432 3141 001C                  		move.w	d1,oXVel(a0)			; Set the X velocity
0000B436 3140 001E                  		move.w	d0,oYVel(a0)			; Set the Y velocity
0000B43A                            
0000B43A                            ObjMighty_CheckWalls:
0000B43A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B43E 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
0000B442 6700                       		beq.s	.Skip				; If not, branch
0000B444 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B448 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
0000B44C 6B00                       		bmi.s	.End				; If so, branch
0000B44E                            
0000B44E                            .Skip:
0000B44E 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
0000B450 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000B454 6700                       		beq.s	.End				; Branch if not moving
0000B456 6B00                       		bmi.s	.CheckPush			; Branch if going left
0000B458 4441                       		neg.w	d1				; Negate the modifier
0000B45A                            
0000B45A                            .CheckPush:
0000B45A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B45E D001                       		add.b	d1,d0				; Add modifier
0000B460                            		push.w	d0				; Save it
0000B460 3F00                     M 	move.w	d0,-(sp)
0000B462 4EB8 2DD8                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
0000B466                            		pop.w	d0				; Restore angle
0000B466 301F                     M 	move.w	(sp)+,d0
0000B468 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
0000B46A 6A00                       		bpl.s	.End				; If not, branch
0000B46C E141                       		asl.w	#8,d1				; Shift distance inside the collision
0000B46E 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000B472 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
0000B476 6700                       		beq.s	.PushCeiling			; If so, branch
0000B478 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
0000B47C 6700                       		beq.s	.PushRightWall			; If so, branch
0000B47E 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000B482 6700                       		beq.s	.PushFloor			; If so, branch
0000B484 D368 001C                  		add.w	d1,oXVel(a0)			; Push out to the right
0000B488 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B48C 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing right?
0000B492 6600                       		bne.s	.End				; If not, branch
0000B494 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B49A 4E75                       		rts
0000B49C                            
0000B49C                            .PushFloor:
0000B49C 9368 001E                  		sub.w	d1,oYVel(a0)			; Push out upwards
0000B4A0 4E75                       		rts
0000B4A2                            
0000B4A2                            .PushRightWall:
0000B4A2 9368 001C                  		sub.w	d1,oXVel(a0)			; Push out to the left
0000B4A6 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B4AA 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B4B0 6700                       		beq.s	.End				; If not, branch
0000B4B2 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B4B8 4E75                       		rts
0000B4BA                            
0000B4BA                            .PushCeiling:
0000B4BA D368 001E                  		add.w	d1,oYVel(a0)			; Push out downwards
0000B4BE                            
0000B4BE                            .End:
0000B4BE 4E75                       		rts
0000B4C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4C0                            ; Move left on the ground
0000B4C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4C0                            ObjMighty_MoveLeft:
0000B4C0 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B4C4 6700                       		beq.s	.SetFlip			; If not moving yet, branch
0000B4C6 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
0000B4C8                            
0000B4C8                            .SetFlip:
0000B4C8 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B4CE 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000B4D0 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B4D6 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B4DC                            
0000B4DC                            .MoveLeft:
0000B4DC 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B4DE 3206                       		move.w	d6,d1				; Get top speed
0000B4E0 4441                       		neg.w	d1				; Negate it
0000B4E2 B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
0000B4E4 6E00                       		bgt.s	.SetSpeed			; If not, branch
0000B4E6 D045                       		add.w	d5,d0				; Add acceleration back
0000B4E8 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
0000B4EA 6F00                       		ble.s	.SetSpeed			; If not, branch
0000B4EC 3001                       		move.w	d1,d0				; Cap at the top speed
0000B4EE                            
0000B4EE                            .SetSpeed:
0000B4EE 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B4F2 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B4F6                            
0000B4F6                            .End:
0000B4F6 4E75                       		rts
0000B4F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4F8                            .Skid:
0000B4F8 9044                       		sub.w	d4,d0				; Subtract deceleration
0000B4FA 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B4FC                            
0000B4FC                            .Compare:
0000B4FC B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B4FE 6C00                       		bge.s	.SetSkidSpeed			; If not branch
0000B500 7080                       		moveq	#-$80,d0			; Set speed to -$80
0000B502                            
0000B502                            .SetSkidSpeed:
0000B502 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B506 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B50A 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B50E 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B512 66E2                       		bne.s	.End				; If so, branch
0000B514 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
0000B518 6DDC                       		blt.s	.End				; If not, branch
0000B51A 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B520 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B526                            		playSnd	#sSkid, 2			; Play skid sound
0000B526 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B52C 4E75                       		rts
0000B52E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B52E                            ; Move right on the ground
0000B52E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B52E                            ObjMighty_MoveRight:
0000B52E 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B532 6B00                       		bmi.s	.Skid				; If it's negative, skid
0000B534 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B53A 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
0000B53C 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B542 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B548                            
0000B548                            .MoveRight:
0000B548 D045                       		add.w	d5,d0				; Add acceleration
0000B54A B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B54C 6D00                       		blt.s	.SetSpeed			; If not, branch
0000B54E 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B550 B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
0000B552 6C00                       		bge.s	.SetSpeed			; If not, branch
0000B554 3006                       		move.w	d6,d0				; Cap at top speed
0000B556                            
0000B556                            .SetSpeed:
0000B556 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B55A 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B55E                            
0000B55E                            .End:
0000B55E 4E75                       		rts
0000B560                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B560                            .Skid:
0000B560 D044                       		add.w	d4,d0				; Add deceleration
0000B562 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B564                            
0000B564                            .Compare:
0000B564 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B566 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
0000B568 303C 0080                  		move.w	#$80,d0				; Set speed to $80
0000B56C                            
0000B56C                            .SetSkidSpeed:
0000B56C 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B570 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B574 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B578 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B57C 66E0                       		bne.s	.End				; If so, branch
0000B57E 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000B582 6EDA                       		bgt.s	.End				; If not, branch
0000B584 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B58A 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B590                            		playSnd	#sSkid, 2			; Play skid sound
0000B590 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B596 4E75                       		rts
0000B598                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B598                            ; Do movement while rolling
0000B598                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B598                            ObjMighty_MoveRoll:
0000B598 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B59C E346                       		asl.w	#1,d6				; ''
0000B59E 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B5A2 E245                       		asr.w	#1,d5				; ''
0000B5A4 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B5A8 E444                       		asr.w	#2,d4				; ''
0000B5AA                            
0000B5AA 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B5AE 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000B5B2                            
0000B5B2 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B5B8 6700                       		beq.s	.ChkRight			; If not, branch
0000B5BA 6100 0000                  		bsr.w	ObjMighty_RollLeft		; Handle left movement
0000B5BE                            
0000B5BE                            .ChkRight:
0000B5BE 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B5C4 6700                       		beq.s	.Decelerate			; If not, branch
0000B5C6 6100 0000                  		bsr.w	ObjMighty_RollRight		; Handle right movement
0000B5CA                            
0000B5CA                            .Decelerate:
0000B5CA 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B5CE 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
0000B5D0 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000B5D2                            
0000B5D2 9045                       		sub.w	d5,d0				; Decelerate
0000B5D4 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B5D6 7000                       		moveq	#0,d0				; Cap at 0
0000B5D8                            
0000B5D8                            .SetGVel:
0000B5D8 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B5DC 6000                       		bra.s	.ChkStop			; Continue
0000B5DE                            
0000B5DE                            .DecLeft:
0000B5DE D045                       		add.w	d5,d0				; Decelerate
0000B5E0 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000B5E2 7000                       		moveq	#0,d0				; Cap at 0
0000B5E4                            
0000B5E4                            .SetGVel2:
0000B5E4 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B5E8                            
0000B5E8                            .ChkStop:
0000B5E8 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic still moving?
0000B5EC 6600                       		bne.s	.UpdateSpd			; If so, branch
0000B5EE                            
0000B5EE 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B5F2 6600                       		bne.s	.KeepRoll			; If so, branch
0000B5F4 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Stop rolling
0000B5FA 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B600 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B606 117C 0005 0020             		move.b	#5,oAni(a0)			; Use standing animation
0000B60C 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B610 6000                       		bra.s	.UpdateSpd			; Continue
0000B612                            
0000B612                            .KeepRoll:
0000B612 317C 0400 003A             		move.w	#$400,oGVel(a0)			; Speed up again
0000B618 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing right?
0000B61E 6700                       		beq.s	.UpdateSpd			; If so, branch
0000B620 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B624                            
0000B624                            .UpdateSpd:
0000B624 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B628 4EB8 1308                  		jsr	CalcSine.w			; Get sine and cosine
0000B62C C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B630 E080                       		asr.l	#8,d0				; Shift over
0000B632 3140 001E                  		move.w	d0,oYVel(a0)			; Set Y velocity
0000B636 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B63A E081                       		asr.l	#8,d1				; Shift over
0000B63C                            
0000B63C 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
0000B640 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000B642 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000B646                            
0000B646                            .ChkLeftSpd:
0000B646 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
0000B64A 6C00                       		bge.s	.SetXVel			; If not, branch
0000B64C 323C F000                  		move.w	#-$1000,d1			; Cap the speed
0000B650                            
0000B650                            .SetXVel:
0000B650 3141 001C                  		move.w	d1,oXVel(a0)			; Set X velocity
0000B654 6000 FDE4                  		bra.w	ObjMighty_CheckWalls		; Check wall collision
0000B658                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B658                            ; Handle left movement for rolling
0000B658                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B658                            ObjMighty_RollLeft:
0000B658 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B65C 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
0000B65E 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
0000B660                            
0000B660                            .SetLeft:
0000B660 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B666 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B66C 4E75                       		rts
0000B66E                            
0000B66E                            .Dec:
0000B66E 9044                       		sub.w	d4,d0				; Decelerate
0000B670 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B672 303C FF80                  		move.w	#-$80,d0			; Set new speed
0000B676                            
0000B676                            .SetGVel:
0000B676 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B67A 4E75                       		rts
0000B67C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B67C                            ; Handle left movement for rolling
0000B67C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B67C                            ObjMighty_RollRight:
0000B67C 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B680 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
0000B682 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B688 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B68E 4E75                       		rts
0000B690                            
0000B690                            .Dec:
0000B690 D044                       		add.w	d4,d0				; Decelerate
0000B692 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B694 303C 0080                  		move.w	#$80,d0				; Set new speed
0000B698                            
0000B698                            .SetGVel:
0000B698 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B69C 4E75                       		rts
0000B69E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B69E                            ; Do movement in the air
0000B69E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B69E                            ObjMighty_MoveAir:
0000B69E 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B6A2 3A28 0036                  		move.w	oAcc(a0),d5			; Get accleration
0000B6A6 DA45                       		add.w	d5,d5				; Double it
0000B6A8 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B6AC                            
0000B6AC 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B6B2 6700                       		beq.s	.NotLeft			; If not, branch
0000B6B4 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B6BA 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B6BC 3206                       		move.w	d6,d1				; Get top speed
0000B6BE 4441                       		neg.w	d1				; Negate it
0000B6C0 B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000B6C2 6E00                       		bgt.s	.NotLeft			; If not, branch
0000B6C4 D045                       		add.w	d5,d0				; Add acceleration back
0000B6C6 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000B6C8 6F00                       		ble.s	.NotLeft			; If not, branch
0000B6CA 3001                       		move.w	d1,d0				; Cap at top speed
0000B6CC                            
0000B6CC                            .NotLeft:
0000B6CC 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B6D2 6700                       		beq.s	.NotRight			; If not, branch
0000B6D4 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B6DA D045                       		add.w	d5,d0				; Add acceleration
0000B6DC B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B6DE 6D00                       		blt.s	.NotRight			; If not, branch
0000B6E0 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B6E2 B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000B6E4 6C00                       		bge.s	.NotRight			; If not, branch
0000B6E6 3006                       		move.w	d6,d0				; Cap at top speed
0000B6E8                            
0000B6E8                            .NotRight:
0000B6E8 3140 001C                  		move.w	d0,oXVel(a0)			; Set X velocity
0000B6EC                            
0000B6EC                            .ResetScr
0000B6EC 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B6F2 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000B6F4 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B6F6 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B6FA                            
0000B6FA                            .ScrollUp:
0000B6FA 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B6FE                            
0000B6FE                            .DecelerateAtPeak:
0000B6FE 0C68 FC00 001E             		cmpi.w	#-$400,oYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000B704 6500                       		bcs.s	.End				; If not, branch
0000B706 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B70A 3200                       		move.w	d0,d1				; Save it
0000B70C EA41                       		asr.w	#5,d1				; Turn it into the acceleration
0000B70E 6700                       		beq.s	.End				; If it's 0, branch
0000B710 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000B712                            
0000B712                            .DecRight:
0000B712 9041                       		sub.w	d1,d0				; Subtract accleration
0000B714 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000B716 7000                       		moveq	#0,d0				; Cap at 0
0000B718 6000                       		bra.s	.DecSetSpeed			; Continue
0000B71A                            
0000B71A                            .DecLeft:
0000B71A 9041                       		sub.w	d1,d0				; Subtract acceleration
0000B71C 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
0000B71E 7000                       		moveq	#0,d0				; Cap at 0
0000B720                            
0000B720                            .DecSetSpeed:
0000B720 3140 001C                  		move.w	d0,oXVel(a0)			; Set thhe X velocity
0000B724                            
0000B724                            .End:
0000B724 4E75                       		rts
0000B726                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B726                            ; Handle level boundaries
0000B726                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B726                            ObjMighty_LvlBound:
0000B726 4A68 001E                  		tst.w	oYVel(a0)
0000B72A 6A00                       		bpl.s	.XBound
0000B72C 3228 0018                  		move.w	oYPos(a0),d1
0000B730 0641 0010                  		addi.w	#$10,d1
0000B734 3038 F8CA                  		move.w	rMinCamY.w,d0		; Get upper boundary position
0000B738 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
0000B73A 6F00                       		ble.s	.XBound				; If so, branch
0000B73C 3140 0018                  		move.w	d0,oYPos(a0)
0000B740 4268 001E                  		clr.w	oYVel(a0)
0000B744 4268 003A                  		clr.w	oGVel(a0)
0000B748                            
0000B748                            .XBound:
0000B748 2228 0014                  		move.l	oXPos(a0),d1			; Get X position
0000B74C 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B750 48C0                       		ext.l	d0
0000B752 E180                       		asl.l	#8,d0				; Shift it
0000B754 D280                       		add.l	d0,d1				; Add to X position
0000B756 4841                       		swap	d1				; Get actual X position
0000B758 3038 F8C8                  		move.w	rMinCamX.w,d0		; Get left boundary position
0000B75C 0640 0010                  		addi.w	#$10,d0				; ''
0000B760 B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
0000B762 6E00                       		bgt.s	.TouchedSide			; If so, branch
0000B764 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Get max camera X position
0000B768 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000B76C B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
0000B76E 6F00                       		ble.s	.TouchedSide			; If so, branch
0000B770                            
0000B770                            .ChkBottom:
0000B770 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
0000B774 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
0000B778 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000B77C 6D00                       		blt.s	.TouchedBottom			; If so, branch
0000B77E 4E75                       		rts
0000B780                            
0000B780                            .TouchedBottom:
0000B780 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get target max camera Y position
0000B784 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Get current max camera Y position
0000B788 B240                       		cmp.w	d0,d1				; Are they the same?
0000B78A 6D00                       		blt.s	.NoKill				; If not, branch
0000B78C 6000 0000                  		bra.w	ObjMighty_GetKilled		; Get Sonic killed
0000B790                            
0000B790                            .NoKill:
0000B790 4E75                       		rts
0000B792                            
0000B792                            .TouchedSide:
0000B792 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
0000B796 3140 0014                  		move.w	d0,oXPos(a0)			; Move Sonic out of the boundary
0000B79A 4228 0016                  		clr.b	oXPos+2(a0)			; Clear the subpixel of the X position
0000B79E 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B7A2 60CC                       		bra.s	.ChkBottom			; Continue
0000B7A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7A4                            ; Handle peelout
0000B7A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7A4                            ObjMighty_Peelout:
0000B7A4 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the peelout?
0000B7A8 6700                       		beq.s	.ChkUp				; If not, branch
0000B7AA 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000B7AC 4E75                       		rts
0000B7AE                            
0000B7AE                            .ChkUp:
0000B7AE 0C28 0007 0020             		cmpi.b	#7,oAni(a0)			; Is Sonic looking up?
0000B7B4 6600 0000                  		bne.w	.End				; If not, branch
0000B7B8 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B7BC 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B7C0 6700 0000                  		beq.w	.End				; If not, branch
0000B7C4                            
0000B7C4 4228 0020                  		clr.b	oAni(a0)			; Set to peelout charge animation
0000B7C8 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B7CC 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B7D2 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B7D8 6700                       		beq.s	.SetAni				; If so, branch
0000B7DA 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B7DE                            
0000B7DE                            .SetAni:
0000B7DE                            		playSnd	#sCharge, 2			; Play charge sound
0000B7DE 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B7E4                            
0000B7E4 588F                       		addq.l	#4,sp				; Don't return to caller
0000B7E6 50E8 0045                  		st	oDashFlag(a0)			; Set the peelout flag
0000B7EA 4EF8 3222                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B7EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7EE                            .ChkLaunch:
0000B7EE 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is up being held?
0000B7F4 6600 0000                  		bne.w	.Charge				; If so, branch
0000B7F8 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B7FC                            
0000B7FC 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged up enough?
0000B802 6600                       		bne.s	.StopSound			; If not, branch
0000B804                            
0000B804 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000B808 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B80E 0828 0006 0028             		btst	#6,oStatus(a0)
0000B814 6700                       		beq.s	.NoWater
0000B816 E2E8 003A                  		lsr.w	oGVel(a0)
0000B81A                            
0000B81A                            .NoWater:
0000B81A 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B820 6700                       		beq.s	.FinishDash			; If not, branch
0000B822 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B826                            
0000B826                            .FinishDash:
0000B826                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B826 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B82C                            
0000B82C 6000                       		bra.s	.DoUpdates			; Continue
0000B82E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B82E                            .Charge:
0000B82E 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged enough?
0000B834 6700                       		beq.s	.DoUpdates			; If so, branch
0000B836 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B83A 0668 0066 003A             		addi.w	#$66,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B840 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B846 6700                       		beq.s	.DoUpdates			; If so, branch
0000B848 0468 00CC 003A             		subi.w	#$66*2,oGVel(a0)		; Go the other way
0000B84E 6000                       		bra.s	.DoUpdates			; Continue
0000B850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B850                            .StopSound:
0000B850 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B854                            
0000B854                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B854 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B85A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B85A                            .DoUpdates:
0000B85A 588F                       		addq.l	#4,sp				; Don't return to caller
0000B85C 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B862 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B864 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B866 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B86A                            
0000B86A                            .ScrollUp:
0000B86A 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B86E                            
0000B86E                            .FinishUpdates:
0000B86E 4EF8 3222                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B872                            
0000B872                            .End:
0000B872 4E75                       		rts
0000B874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B874                            ; Handle spindash
0000B874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B874                            ObjMighty_Spindash:
0000B874 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the spindash?
0000B878 6700                       		beq.s	.ChkDown			; If not, branch
0000B87A 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000B87C 4E75                       		rts
0000B87E                            
0000B87E                            .ChkDown:
0000B87E 0C28 0008 0020             		cmpi.b	#8,oAni(a0)			; Is Sonic ducking?
0000B884 6600 0000                  		bne.w	.End				; If not, branch
0000B888 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B88C 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B890 6700 0000                  		beq.w	.End				; If not, branch
0000B894                            
0000B894 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B898 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B89E 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B8A4 6700                       		beq.s	.SetAni				; If so, branch
0000B8A6 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B8AA                            
0000B8AA                            .SetAni:
0000B8AA 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B8B0 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B8B6 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B8BA 117C 0002 0020             		move.b	#2,oAni(a0)			; Set to spin animation
0000B8C0                            
0000B8C0                            		playSnd	#sCharge, 2			; Play charge sound
0000B8C0 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B8C6                            
0000B8C6 588F                       		addq.l	#4,sp				; Don't return to caller
0000B8C8 117C 0001 0045             		move.b	#1,oDashFlag(a0)		; Set the spindash flag
0000B8CE 4EF8 3222                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B8D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8D2                            .ChkLaunch:
0000B8D2 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000B8D8 6600 0000                  		bne.w	.Charge				; If so, branch
0000B8DC 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B8E0                            
0000B8E0 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged up enough?
0000B8E6 6600                       		bne.s	.StopSound			; If not, branch
0000B8E8                            
0000B8E8 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set the roll flag
0000B8EE 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B8F4 0828 0006 0028             		btst	#6,oStatus(a0)
0000B8FA 6700                       		beq.s	.NoWater
0000B8FC E2E8 003A                  		lsr.w	oGVel(a0)
0000B900                            
0000B900                            .NoWater:
0000B900 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B906 6700                       		beq.s	.FinishDash			; If not, branch
0000B908 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B90C                            
0000B90C                            .FinishDash:
0000B90C                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B90C 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B912                            
0000B912 6000                       		bra.s	.DoUpdates			; Continue
0000B914                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B914                            .Charge:
0000B914 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged enough?
0000B91A 6700                       		beq.s	.DoUpdates			; If so, branch
0000B91C 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B920 0668 0046 003A             		addi.w	#$46,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B926 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B92C 6700                       		beq.s	.DoUpdates			; If so, branch
0000B92E 0468 008C 003A             		subi.w	#$46*2,oGVel(a0)		; Go the other way
0000B934 6000                       		bra.s	.DoUpdates			; Continue
0000B936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B936                            .StopSound:
0000B936 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B93A 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B940 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B946 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B94A                            
0000B94A                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B94A 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B950                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B950                            .DoUpdates:
0000B950 588F                       		addq.l	#4,sp				; Don't return to caller
0000B952 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B958 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B95A 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B95C 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B960                            
0000B960                            .ScrollUp:
0000B960 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B964                            
0000B964                            .FinishUpdates:
0000B964 4EF8 3222                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B968                            
0000B968                            .End:
0000B968 4E75                       		rts
0000B96A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B96A                            ; Check for jumping
0000B96A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B96A                            ObjMighty_ChkJump:
0000B96A 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get pressed buttons
0000B96E 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B972 4A38 C768                  		tst.b	rMoveCheat.w
0000B976 6700                       		beq.s	.NoDebug
0000B978 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000B97C                            
0000B97C                            .NoDebug:
0000B97C 4A00                       		tst.b	d0
0000B97E 6700 0000                  		beq.w	.End				; If not, branch
0000B982                            
0000B982 7000                       		moveq	#0,d0
0000B984 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B988 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
0000B98C 4EB8 2E4A                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000B990 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
0000B994 6D00 0000                  		blt.w	.End				; If not, branch
0000B998                            
0000B998 343C 0680                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
0000B99C 0828 0006 0028             		btst	#6,oStatus(a0)
0000B9A2 6700                       		beq.s	.NoWater
0000B9A4 0442 0300                  		subi.w	#$300,d2
0000B9A8                            
0000B9A8                            .NoWater:
0000B9A8 7000                       		moveq	#0,d0
0000B9AA 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B9AE 0400 0040                  		subi.b	#$40,d0				; Shift it
0000B9B2 4EB8 1308                  		jsr	CalcSine.w			; Get the sine and cosine
0000B9B6 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
0000B9B8 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
0000B9BA E081                       		asr.l	#8,d1				; Shift the values over
0000B9BC E080                       		asr.l	#8,d0				; ''
0000B9BE D368 001C                  		add.w	d1,oXVel(a0)			; Add to X velocity
0000B9C2 D168 001E                  		add.w	d0,oYVel(a0)			; Add to Y velocity
0000B9C6 0028 0006 0028             		ori.b	#6,oStatus(a0)			; Set "in air" and roll flags
0000B9CC 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000B9D2 584F                       		addq.w	#4,sp				; Do not return to collaer
0000B9D4 50E8 0040                  		st	oJumping(a0)			; Set the jumping flag
0000B9D8                            		playSnd	#sLeap, 2			; Play jump sound
0000B9D8 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
0000B9DE 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B9E4 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B9EA 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B9EE 117C 0002 0020             		move.b	#2,oAni(a0)			; Set jumping animation
0000B9F4                            
0000B9F4                            .End:
0000B9F4 4E75                       		rts
0000B9F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9F6                            ; Handle variable jumping
0000B9F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9F6                            ObjMighty_JumpHeight:
0000B9F6 4A28 0040                  		tst.b	oJumping(a0)			; Is Sonic jumping?
0000B9FA 6700                       		beq.s	.UpVelCap			; If not, branch
0000B9FC                            
0000B9FC 323C FC00                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
0000BA00 B268 001E                  		cmp.w	oYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000BA04 6F00                       		ble.s	.End				; If not, branch
0000BA06 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BA0A 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000BA0E 4A38 C768                  		tst.b	rMoveCheat.w
0000BA12 6700                       		beq.s	.NoDebug
0000BA14 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000BA18                            
0000BA18                            .NoDebug:
0000BA18 4A00                       		tst.b	d0
0000BA1A 6600                       		bne.s	.End				; If not, branch
0000BA1C 3141 001E                  		move.w	d1,oYVel(a0)			; Set to minimum height
0000BA20                            
0000BA20                            .End:
0000BA20 4E75                       		rts
0000BA22                            
0000BA22                            .UpVelCap:
0000BA22 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000BA26 66F8                       		bne.s	.End				; If so, branch
0000BA28 0C68 F040 001E             		cmpi.w	#-$FC0,oYVel(a0)		; Cap Y velocity at -$FC0 when going up
0000BA2E 6CF0                       		bge.s	.End				; ''
0000BA30 317C F040 001E             		move.w	#-$FC0,oYVel(a0)		; ''
0000BA36 4E75                       		rts
0000BA38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA38                            ; Gradually reset Sonic's angle in mid air
0000BA38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA38                            ObjMighty_JumpAngle:
0000BA38 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BA3C 6700                       		beq.s	ObjMighty_JumpFlip		; If it's already reset, branch
0000BA3E 6A00                       		bpl.s	.Decrease			; If it's positive, branch
0000BA40                            
0000BA40                            .Increase:
0000BA40 5400                       		addq.b	#2,d0				; Increase angle
0000BA42 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
0000BA44 7000                       		moveq	#0,d0				; Reset the angle
0000BA46 6000                       		bra.s	.SetAngle
0000BA48                            
0000BA48                            .Decrease:
0000BA48 5500                       		subq.b	#2,d0				; Decrease angle
0000BA4A 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000BA4C 7000                       		moveq	#0,d0				; Reset the angle
0000BA4E                            
0000BA4E                            .SetAngle:
0000BA4E 1140 0041                  		move.b	d0,oAngle(a0)			; Set the new angle
0000BA52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA52                            ; Update Sonic's angle while he's tumbling in the air
0000BA52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA52                            ObjMighty_JumpFlip:
0000BA52 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000BA56 6700                       		beq.s	.End				; If it's 0, branch
0000BA58 4A68 003A                  		tst.w	oFlipDir(a0)			; Is Sonic flipping left?
0000BA5C 6B00                       		bmi.s	.FlipLeft			; IF so, branch
0000BA5E                            
0000BA5E                            .FlipRight:
0000BA5E 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA62 D001                       		add.b	d1,d0				; Add to angle
0000BA64 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA66 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BA6A 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BA6C 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BA70 7000                       		moveq	#0,d0				; Reset angle
0000BA72 6000                       		bra.s	.FlipSet			; Continue
0000BA74                            
0000BA74                            .FlipLeft:
0000BA74 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is the flipping inverted?
0000BA78 66E4                       		bne.s	.FlipRight			; If so, branch
0000BA7A 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA7E 9001                       		sub.b	d1,d0				; Subtract from angle
0000BA80 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA82 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BA86 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BA88 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BA8C 7000                       		moveq	#0,d0				; Reset angle
0000BA8E                            
0000BA8E                            .FlipSet:
0000BA8E 1140 0047                  		move.b	d0,oFlipAngle(a0)		; Update the angle
0000BA92                            
0000BA92                            .End:
0000BA92 4E75                       		rts
0000BA94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA94                            ; Check for rolling
0000BA94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA94                            ObjMighty_ChkRoll:
0000BA94 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000BA98 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000BA9A 4440                       		neg.w	d0				; ''
0000BA9C                            
0000BA9C                            .ChkSpd:
0000BA9C 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
0000BAA0 6500                       		bcs.s	.NoRoll				; If not, branch
0000BAA2 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BAA6 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000BAAA 6600                       		bne.s	.NoRoll				; If not, branch
0000BAAC 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000BAB2 6600                       		bne.s	ObjMighty_DoRoll			; If so, branch
0000BAB4                            
0000BAB4                            .NoRoll:
0000BAB4 4E75                       		rts
0000BAB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAB6                            ; Make Sonic roll
0000BAB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAB6                            ObjMighty_DoRoll:
0000BAB6 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BABC 6600                       		bne.s	.End				; If so, branch
0000BABE 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BAC4                            
0000BAC4 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BACA 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BAD0 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BAD4 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BADA                            
0000BADA 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving already?
0000BADE 6600                       		bne.s	.End				; IF not, branch
0000BAE0 317C 0200 003A             		move.w	#$200,oGVel(a0)			; Set speed
0000BAE6                            
0000BAE6                            .End:
0000BAE6 4E75                       		rts
0000BAE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAE8                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
0000BAE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAE8                            ObjMighty_SlopePush:
0000BAE8 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BAEC 0600 0060                  		addi.b	#$60,d0				; Shift it
0000BAF0 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
0000BAF4 6400                       		bcc.s	.End				; If not, branch
0000BAF6 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BAFA 4EB8 1308                  		jsr	CalcSine.w			; Get the sine of it
0000BAFE C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000BB02 E080                       		asr.l	#8,d0				; Shift it
0000BB04 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000BB08 6700                       		beq.s	.End				; If Sonic is not moving, branch
0000BB0A D168 003A                  		add.w	d0,oGVel(a0)			; Add to ground velocity
0000BB0E                            
0000BB0E                            .End:
0000BB0E 4E75                       		rts
0000BB10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB10                            ; Check if Sonic is to fall off a slope
0000BB10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB10                            ObjMighty_FallOffSlope:
0000BB10 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer, active?
0000BB14 6600                       		bne.s	.End				; If so, branch
0000BB16 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB1A 0600 0020                  		addi.b	#$20,d0				; Shift it
0000BB1E 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000BB22 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000BB24 3028 003A                  		move.w	oGVel(a0),d0			; Get speed
0000BB28 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
0000BB2A 4440                       		neg.w	d0				; Force it to be positive
0000BB2C                            
0000BB2C                            .ChkSpeed:
0000BB2C 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
0000BB30 6400                       		bcc.s	.End				; If so, branch
0000BB32 4268 003A                  		clr.w	oGVel(a0)			; Stop movement
0000BB36 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000BB3C 117C 001E 003F             		move.b	#$1E,oMoveLock(a0)		; Set move lock timer
0000BB42                            
0000BB42                            .End:
0000BB42 4E75                       		rts
0000BB44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB44                            ; Affect Sonic's speed on slopes while rolling
0000BB44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB44                            ObjMighty_RollSlopePush:
0000BB44 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB48 0600 0060                  		addi.b	#$60,d0				; ''
0000BB4C 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000BB50 6400                       		bcc.s	.End				; If not, branch
0000BB52                            
0000BB52 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB56 4EB8 1308                  		jsr	CalcSine.w			; Get sine
0000BB5A C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
0000BB5E E080                       		asr.l	#8,d0				; Shift over
0000BB60                            
0000BB60 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000BB64 6B00                       		bmi.s	.PushLeft			; If not, branch
0000BB66 4A40                       		tst.w	d0				; Is the push speed positive?
0000BB68 6A00                       		bpl.s	.Push				; If so, branch
0000BB6A E480                       		asr.l	#2,d0				; Shift over more
0000BB6C                            
0000BB6C                            .Push:
0000BB6C D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB70 4E75                       		rts
0000BB72                            
0000BB72                            .PushLeft:
0000BB72 4A40                       		tst.w	d0				; Is the push speed negative?
0000BB74 6B00                       		bmi.s	.Push2				; If so, branch
0000BB76 E480                       		asr.l	#2,d0				; Shift over more
0000BB78                            
0000BB78                            .Push2:
0000BB78 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB7C                            
0000BB7C                            .End:
0000BB7C 4E75                       		rts
0000BB7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB7E                            ; Check for bouncy floor collision
0000BB7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB7E                            ObjMighty_ChkBounce:
0000BB7E 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
0000BB82 6700 0000                  		beq.w	.End				; If so, branch
0000BB86                            
0000BB86 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic in the air?
0000BB8C 6700                       		beq.s	.ChkDown			; If not, branch
0000BB8E                            
0000BB8E 4A68 001E                  		tst.w	oYVel(a0)			; Is Sonic falling?
0000BB92 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
0000BB96 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
0000BB9A                            
0000BB9A                            .ChkDown:
0000BB9A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BB9E 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BBA2 4880                       		ext.w	d0				; ''
0000BBA4 D440                       		add.w	d0,d2				; ''
0000BBA6 5442                       		addq.w	#2,d2				; ''
0000BBA8 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BBAC 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BBB0 4880                       		ext.w	d0				; ''
0000BBB2 9640                       		sub.w	d0,d3				; ''
0000BBB4 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BBB8 3011                       		move.w	(a1),d0				; ''
0000BBBA 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BBBE 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BBC2 6700                       		beq.s	.Bounce				; If so, branch
0000BBC4                            
0000BBC4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BBC8 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BBCC 4880                       		ext.w	d0				; ''
0000BBCE D440                       		add.w	d0,d2				; ''
0000BBD0 5442                       		addq.w	#2,d2				; ''
0000BBD2 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BBD6 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BBDA 4880                       		ext.w	d0				; ''
0000BBDC D640                       		add.w	d0,d3				; ''
0000BBDE 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BBE2 3011                       		move.w	(a1),d0				; ''
0000BBE4 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BBE8 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BBEC 6600                       		bne.s	.End				; If not, branch
0000BBEE                            
0000BBEE                            .Bounce:
0000BBEE 317C EA00 001E             		move.w	#-$1600,oYVel(a0)		; Bounce Sonic up
0000BBF4 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BBFA 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BBFE 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BC02 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BC06                            
0000BC06                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BC06 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BC0C                            
0000BC0C 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BC12 6600                       		bne.s	.End				; If so, branch
0000BC14 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BC1A 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BC20 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BC26 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BC2A 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BC30                            
0000BC30                            .End:
0000BC30 4E75                       		rts
0000BC32                            
0000BC32                            .ChkBounceUp:
0000BC32 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BC36 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC3A 4880                       		ext.w	d0				; ''
0000BC3C 9440                       		sub.w	d0,d2				; ''
0000BC3E 5542                       		subq.w	#2,d2				; ''
0000BC40 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BC44 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC48 4880                       		ext.w	d0				; ''
0000BC4A 9640                       		sub.w	d0,d3				; ''
0000BC4C 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BC50 3011                       		move.w	(a1),d0				; ''
0000BC52 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC56 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC5A 6700                       		beq.s	.BounceUp			; If so, branch
0000BC5C                            
0000BC5C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BC60 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC64 4880                       		ext.w	d0				; ''
0000BC66 9440                       		sub.w	d0,d2				; ''
0000BC68 5542                       		subq.w	#2,d2				; ''
0000BC6A 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BC6E 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC72 4880                       		ext.w	d0				; ''
0000BC74 D640                       		add.w	d0,d3				; ''
0000BC76 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BC7A 3011                       		move.w	(a1),d0				; ''
0000BC7C 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC80 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC84 66AA                       		bne.s	.End				; If not, branch
0000BC86                            
0000BC86                            .BounceUp:
0000BC86 588F                       		addq.l	#4,sp				; Don't return to caller
0000BC88                            
0000BC88 317C 1600 001E             		move.w	#$1600,oYVel(a0)		; Bounce Sonic up
0000BC8E 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BC94 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BC98 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BC9C 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BCA0                            
0000BCA0                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BCA0 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BCA6                            
0000BCA6 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BCAC 6600                       		bne.s	.End2				; If so, branch
0000BCAE 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BCB4 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BCBA 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BCC0 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BCC4 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BCCA                            
0000BCCA                            .End2:
0000BCCA 4E75                       		rts
0000BCCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCCC                            ; Check for bars to hang on to
0000BCCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCCC                            ObjMighty_ChkHang:
0000BCCC 0828 0003 000C             		btst	#3,oFlags(a0)			; Are we already hanging?
0000BCD2 6600                       		bne.s	.End				; If so, branch
0000BCD4                            
0000BCD4 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BCD8 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BCDC 0442 0018                  		subi.w	#$18,d2				; ''
0000BCE0 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BCE4 3011                       		move.w	(a1),d0				; ''
0000BCE6 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BCEA 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BCEE 6600                       		bne.s	.End				; If not, branch
0000BCF0                            
0000BCF0 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
0000BCF6 42A8 001C                  		clr.l	oXVel(a0)			; Stop movement
0000BCFA 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BCFE 08E8 0003 000C             		bset	#3,oFlags(a0)			; Set hanging flag
0000BD04 117C 000A 0020             		move.b	#$A,oAni(a0)			; Set hanging animation
0000BD0A 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Animation timer
0000BD10 3028 0018                  		move.w	oYPos(a0),d0			; Align with bar
0000BD14 0440 0018                  		subi.w	#$18,d0				; ''
0000BD18 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
0000BD1C 0640 0018                  		addi.w	#$18,d0				; ''
0000BD20 3140 0018                  		move.w	d0,oYPos(a0)			; ''
0000BD24 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000BD28 08A8 0001 000D             		bclr	#1,oRender(a0)			; ''
0000BD2E                            
0000BD2E                            .End:
0000BD2E 4E75                       		rts
0000BD30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD30                            ; Hang onto the bars
0000BD30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD30                            ObjMighty_Hang:
0000BD30 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BD34 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BD38 0442 0018                  		subi.w	#$18,d2				; ''
0000BD3C 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BD40 3011                       		move.w	(a1),d0				; ''
0000BD42 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD46 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BD4A 6600                       		bne.s	.FallOff			; If not, branch
0000BD4C 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get control press bits
0000BD50 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
0000BD54 6700                       		beq.s	.MoveX				; If not, branch
0000BD56                            
0000BD56                            .FallOff:
0000BD56 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BD5C 0668 0010 0018             		addi.w	#$10,oYPos(a0)			; Fall off
0000BD62 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000BD68 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000BD6E 4E75                       		rts
0000BD70                            
0000BD70                            .MoveX:
0000BD70 7002                       		moveq	#2,d0				; X speed
0000BD72 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Are we going left?
0000BD78 6700                       		beq.s	.ChkRight			; If not, branch
0000BD7A 4440                       		neg.w	d0				; Go the other way
0000BD7C 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face to the left
0000BD82 08E8 0000 000D             		bset	#0,oRender(a0)			; ''
0000BD88 6000                       		bra.s	.DoMove				; Continue
0000BD8A                            
0000BD8A                            .ChkRight:
0000BD8A 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Are we going left?
0000BD90 6700                       		beq.s	.ResetScr			; If not, branch
0000BD92 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face to the right
0000BD98 08A8 0000 000D             		bclr	#0,oRender(a0)			; ''
0000BD9E                            
0000BD9E                            .DoMove:
0000BD9E D168 0014                  		add.w	d0,oXPos(a0)			; Move
0000BDA2 5328 004C                  		subq.b	#1,oHangAniTime(a0)		; Decrement animation timer
0000BDA6 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
0000BDA8 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Reset timer
0000BDAE 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Increment animation frame
0000BDB2 0C28 0004 0022             		cmpi.b	#4,oAniFrame(a0)		; Have we reached the last one?
0000BDB8 6500                       		bcs.s	.ResetScr			; If not, branch
0000BDBA 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation frame
0000BDBE                            
0000BDBE                            .ResetScr:
0000BDBE 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BDC2 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BDC8 6700                       		beq.s	.End				; If so, branch
0000BDCA 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BDCC 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BDD0                            
0000BDD0                            .ScrollUp:
0000BDD0 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BDD4                            
0000BDD4                            .End:
0000BDD4 4E75                       		rts
0000BDD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDD6                            ; Check for electricity
0000BDD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDD6                            ObjMighty_ChkElectric:
0000BDD6 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BDDA 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BDDE 4EB8 37B2                  		jsr	Level_FindBlock			; Get the block located there
0000BDE2 3011                       		move.w	(a1),d0				; ''
0000BDE4 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BDE8                            
0000BDE8 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
0000BDEC 7C02                       		moveq	#2,d6				; ''
0000BDEE                            
0000BDEE                            .ChkBlocks:
0000BDEE B059                       		cmp.w	(a1)+,d0			; have we touched this block?
0000BDF0 6700                       		beq.s	ObjMighty_GetHurt		; If so, branch
0000BDF2 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000BDF6 4E75                       		rts
0000BDF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDF8 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
0000BDFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDFE                            ; Get Sonic hurt
0000BDFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDFE                            ObjMighty_GetHurt:
0000BDFE                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BDFE 4A68 0008                M 	tst.w	odrawnext(a0)
0000BE02 6600                     M 	bne.s	.no_215
0000BE04 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BE0A 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BE0E 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BE12 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BE16 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BE1A                          M .no_215
0000BE1A 4A28 0042                  		tst.b	oInvulTime(a0)			; Are we invulnerable?
0000BE1E 6600 0000                  		bne.w	.End				; If so, branch
0000BE22 4A78 F3D4                  		tst.w	rRings.w			; Does Sonic have any rings?
0000BE26 6700 0000                  		beq.w	ObjMighty_GetKilled		; If not, branch
0000BE2A 4EB8 19B0                  		jsr	FindFreeObj.w
0000BE2E 6700                       		beq.s	.Hurt
0000BE30 22BC 0000 0000             		move.l	#ObjRingLoss,oAddr(a1)
0000BE36 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0000BE3C 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000BE42                            
0000BE42                            .Hurt:
0000BE42 117C 0008 0025             		move.b	#8,oRoutine(a0)			; Set to hurt routine
0000BE48 4EB8 2D9E                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BE4C 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BE50 08A8 0000 000C             		bclr	#0,oFlags(a0)			; Allow modes
0000BE56 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BE5C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BE62 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Set to hurt animation
0000BE68 117C 0078 0042             		move.b	#$78,oInvulTime(a0)		; Set invulnerable timer
0000BE6E                            
0000BE6E 317C FC00 001E             		move.w	#-$400,oYVel(a0)		; Make Sonic bounce away
0000BE74 317C FE00 001C             		move.w	#-$200,oXVel(a0)		; ''
0000BE7A 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BE80 6700                       		beq.s	.ChkReverse			; If not, branch
0000BE82 317C FE00 001E             		move.w	#-$200,oYVel(a0)		; Make Sonic bounce away slower
0000BE88 317C FF00 001C             		move.w	#-$100,oXVel(a0)
0000BE8E                            
0000BE8E                            .ChkReverse:
0000BE8E 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0000BE92 B06A 0014                  		cmp.w	oXPos(a2),d0			; Is Sonic left of the object that hurt him?
0000BE96 6500                       		bcs.s	.ChkSnd				; If so, branch
0000BE98 4468 001C                  		neg.w	oXVel(a0)			; Make Sonic bounce the other way if on the right side
0000BE9C                            
0000BE9C                            .ChkSnd:
0000BE9C 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000BEA0                            
0000BEA0                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BEA0                            	;	beq.s	.End				; If not, branch
0000BEA0                            		playSnd	#sHurt, 2			; Play hurt sound
0000BEA0 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
0000BEA6                            
0000BEA6                            .End:
0000BEA6 70FF                       		moveq	#-1,d0				; Set return status
0000BEA8 4E75                       		rts
0000BEAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BEAA                            ; Hurt routine
0000BEAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BEAA                            ObjMighty_Hurt:
0000BEAA 4A38 C768                  		tst.b	rMoveCheat.w
0000BEAE 6700                       		beq.s	.NoPlacementEnter
0000BEB0 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BEB6 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BEB8 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BEBE 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BEC4 4E75                       		rts
0000BEC6                            
0000BEC6                            .NoPlacementEnter:
0000BEC6 4EB8 1CE0                  		jsr	ObjectMove.w			; Allow movement
0000BECA 0668 0030 001E             		addi.w	#$30,oYVel(a0)			; Apply gravity
0000BED0 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BED6 6700                       		beq.s	.NotWater			; If not, branch
0000BED8 0468 0020 001E             		subi.w	#$20,oYVel(a0)			; Reduce gravity underwater
0000BEDE                            
0000BEDE                            .NotWater:
0000BEDE 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Force the hurt animation
0000BEE4 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000BEE6                            
0000BEE6 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BEEC 6700                       		beq.s	.Cont				; If so, branch
0000BEEE 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BEF0 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BEF4                            
0000BEF4                            .ScrollUp:
0000BEF4 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BEF8                            
0000BEF8                            .Cont:
0000BEF8 6100 F82C                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000BEFC 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BF00 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BF04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF04                            .ChkStop:
0000BF04 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BF08 0640 00E0                  		addi.w	#224,d0				; ''
0000BF0C B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BF10 6D00                       		blt.s	ObjMighty_GetKilled		; If so, branch
0000BF12                            
0000BF12 4EB8 2BA8                  		jsr	PlayerChkCollision		; Check for level collision
0000BF16 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic still in midair?
0000BF1C 6600                       		bne.s	.End				; If so, branch
0000BF1E                            
0000BF1E 7000                       		moveq	#0,d0
0000BF20 3140 001E                  		move.w	d0,oYVel(a0)			; Stop Sonic's movement
0000BF24 3140 001C                  		move.w	d0,oXVel(a0)			; ''
0000BF28 3140 003A                  		move.w	d0,oGVel(a0)			; ''
0000BF2C 1140 000C                  		move.b	d0,oFlags(a0)			; Allow Sonic to move
0000BF30 1140 0020                  		move.b	d0,oAni(a0)			; Reset animation
0000BF34 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set back to main routine
0000BF3A                            
0000BF3A                            .End:
0000BF3A 4E75                       		rts
0000BF3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF3C                            ; Get Sonic killed
0000BF3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF3C                            ObjMighty_GetKilled:
0000BF3C                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BF3C 4A68 0008                M 	tst.w	odrawnext(a0)
0000BF40 6600                     M 	bne.s	.no_217
0000BF42 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BF48 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BF4C 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BF50 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BF54 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BF58                          M .no_217
0000BF58 117C 000C 0025             		move.b	#$C,oRoutine(a0)			; Set to the death routine
0000BF5E 4EB8 2D9E                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BF62 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BF66 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BF6C 117C 0018 0020             		move.b	#$18,oAni(a0)			; Set to death animation
0000BF72                            
0000BF72 317C F900 001E             		move.w	#-$700,oYVel(a0)		; Make Sonic bounce up
0000BF78 4268 001C                  		clr.w	oXVel(a0)			; Lock Sonic horizontally
0000BF7C 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BF80 31FC FFFF F8CE             		move.w	#$FFFF,rCamLocked.w		; Lock the camera
0000BF86                            
0000BF86                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BF86                            	;	beq.s	.End				; If not, branch
0000BF86                            		playSnd	#sDeath,2			; Play death sound
0000BF86 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
0000BF8C                            
0000BF8C                            .End:
0000BF8C 70FF                       		moveq	#-1,d0				; Set return status
0000BF8E 4E75                       		rts
0000BF90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF90                            ; Death routine
0000BF90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF90                            ObjMighty_Dead:
0000BF90 4A38 C768                  		tst.b	rMoveCheat.w
0000BF94 6700                       		beq.s	.NoPlacementEnter
0000BF96 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BF9C 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BF9E 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BFA4 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BFAA 4E75                       		rts
0000BFAC                            
0000BFAC                            .NoPlacementEnter:
0000BFAC 117C 0018 0020             		move.b	#$18,oAni(a0)			; Force the death animation
0000BFB2 0068 8000 000E             		ori.w	#$8000,oVRAM(a0)		; Force high priority
0000BFB8 6100                       		bsr.s	ObjMighty_ChkBound		; Check for when Sonic goes off screen
0000BFBA 4EB8 1CFA                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000BFBE 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BFC2 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BFC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFC6                            ObjMighty_ChkBound:
0000BFC6 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BFCA 0640 0100                  		addi.w	#$100,d0			; ''
0000BFCE B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BFD2 6C00                       		bge.s	.End				; If not, branch
0000BFD4                            
0000BFD4 117C 0010 0025             		move.b	#$10,oRoutine(a0)			; Go to gone routine
0000BFDA 117C 003C 0043             		move.b	#60,oDeathTimer(a0)		; Set death timer to 1 second
0000BFE0                            
0000BFE0                            .End:
0000BFE0 4E75                       		rts
0000BFE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFE2                            ; Wait for level reload or game/time over
0000BFE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFE2                            ObjMighty_Gone:
0000BFE2 4A28 0043                  		tst.b	oDeathTimer(a0)
0000BFE6 6700                       		beq.s	.End
0000BFE8 5328 0043                  		subq.b	#1,oDeathTimer(a0)		; Decrement the death counter
0000BFEC 6600                       		bne.s	.End				; If it hasn't run out, branch
0000BFEE 50F8 F8FC                  		st	rLvlReload.w			; Reload the level
0000BFF2                            
0000BFF2                            .End:
0000BFF2 4E75                       		rts
0000BFF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFF4                            ; Display Sonic's sprite
0000BFF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFF4                            ObjMighty_Display:
0000BFF4 1028 0042                  		move.b	oInvulTime(a0),d0		; Get invulnerability timer
0000BFF8 6700                       		beq.s	.Display			; If it's 0, branch
0000BFFA 5328 0042                  		subq.b	#1,oInvulTime(a0)		; Decrement invulnerability timer
0000BFFE E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
0000C000 6500                       		bcs.s	.Display			; If so, branch
0000C002                            	removeSprite	a0,a1,1				; Remove sprite if displayed
0000C002 4A68 0008                M 	tst.w	odrawnext(a0)
0000C006 6700                     M 	beq.s	.yes_219
0000C008 3268 000A                M 	move.w	odrawprev(a0),a1
0000C00C 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
0000C012 3268 0008                M 	move.w	odrawnext(a0),a1
0000C016 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
0000C01C                          M .no_219
0000C01C 42A8 0008                M 	clr.l	odrawnext(a0)
0000C020                          M .yes_219
0000C020 4E75                       		rts
0000C022                            
0000C022                            .Display:
0000C022                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
0000C022 4A68 0008                M 	tst.w	odrawnext(a0)
0000C026 6600                     M 	bne.s	.no_220
0000C028 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C02E 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000C032 3149 000A                M 	move.w	a1,odrawprev(a0)
0000C036 3348 0008                M 	move.w	a0,odrawnext(a1)
0000C03A 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C03E                          M .no_220
0000C03E 4E75                       		rts
0000C040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C040                            ; Load Sonic's DPLCs
0000C040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C040                            ObjMighty_LoadDPLCs:
0000C040 45F9 0000 0000             		lea	DPLC_ObjMighty,a2		; DPLCs
0000C046 383C F000                  		move.w	#$F000,d4			; VRAM location
0000C04A 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
0000C050 4EF8 1CA0                  		jmp	LoadObjDPLCs.w			; Load DPLCs
0000C054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C054                            ; Animate Sonic's sprite
0000C054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C054                            ObjMighty_Animate:
0000C054 43F9 0000 0000             		lea	Ani_ObjMighty,a1			; Animation script
0000C05A 7000                       		moveq	#0,d0
0000C05C 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
0000C060 B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
0000C064 6700                       		beq.s	.Run				; If not, branch
0000C066 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
0000C06A 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C06E 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C072 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000C078                            
0000C078                            .Run:
0000C078 D040                       		add.w	d0,d0				; Turn ID into offset
0000C07A D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
0000C07E 1011                       		move.b	(a1),d0				; Get first byte
0000C080 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
0000C082 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C086 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
0000C08A 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C090 8328 000D                  		or.b	d1,oRender(a0)			; Set flip bits
0000C094 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C098 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C09A 1140 0023                  		move.b	d0,oAniTimer(a0)		; Set new animation timer
0000C09E                            
0000C09E                            .GetFrame:
0000C09E 7200                       		moveq	#0,d1
0000C0A0 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
0000C0A4 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
0000C0A8 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
0000C0AC 6400                       		bhs.s	.CmdReset			; If so, branch
0000C0AE                            
0000C0AE                            .Next:
0000C0AE 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
0000C0B2 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
0000C0B6                            
0000C0B6                            .Wait:
0000C0B6 4E75                       		rts
0000C0B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0B8                            .CmdReset:
0000C0B8 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
0000C0BA 6600                       		bne.s	.CmdJump			; If not, branch
0000C0BC 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C0C0 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
0000C0C4 60E8                       		bra.s	.Next				; Continue
0000C0C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0C6                            .CmdJump:
0000C0C6 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
0000C0C8 6600                       		bne.s	.CmdSetAnim			; If not, branch
0000C0CA 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
0000C0CE 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
0000C0D2 9200                       		sub.b	d0,d1				; ''
0000C0D4 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
0000C0D8 60D4                       		bra.s	.Next				; Continue
0000C0DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0DA                            .CmdSetAnim:
0000C0DA 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
0000C0DC 6600                       		bne.s	.CmdEnd				; If not, branch
0000C0DE 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
0000C0E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0E4                            .CmdEnd:
0000C0E4 4E75                       		rts
0000C0E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0E6                            .WalkRunAnim:
0000C0E6 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C0EA 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C0EC 5200                       		addq.b	#1,d0				; Is the animation walking/running?
0000C0EE 6600 0000                  		bne.w	.RollAnim			; If not, branch
0000C0F2                            
0000C0F2 7000                       		moveq	#0,d0
0000C0F4 1028 0047                  		move.b	oFlipAngle(a0),d0		; Is Sonic tumbling in the air?
0000C0F8 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
0000C0FC                            
0000C0FC 7200                       		moveq	#0,d1				; Intial flip bits
0000C0FE 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000C102 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
0000C104 6700                       		beq.s	.ChkStatus			; If it's zero, branch
0000C106 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
0000C108                            
0000C108                            .ChkStatus:
0000C108 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C10C 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
0000C110 6600                       		bne.s	.ChkFlip			; If so, branch
0000C112 4600                       		not.b	d0				; Reverse angle
0000C114                            
0000C114                            .ChkFlip:
0000C114 0600 0010                  		addi.b	#$10,d0				; Shift angle
0000C118 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
0000C11A 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
0000C11C                            
0000C11C                            .SetFlags:
0000C11C 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits
0000C122 B302                       		eor.b	d1,d2				; Flip
0000C124 8528 000D                  		or.b	d2,oRender(a0)			; Set in render flags
0000C128                            
0000C128 0828 0005 0028             		btst	#5,oStatus(a0)			; Is Sonic pushing?
0000C12E 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
0000C132                            
0000C132 E808                       		lsr.b	#4,d0				; Divide angle by $10
0000C134 0200 0006                  		andi.b	#6,d0				; Get angle section
0000C138                            
0000C138 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C13C 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
0000C13E 4442                       		neg.w	d2				; Force it to be positive
0000C140                            
0000C140                            .GetAnim:
0000C140 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
0000C146 4A00                       		tst.b	d0
0000C148 6600                       		bne.s	.ChkRun
0000C14A 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
0000C14E 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C150                            
0000C150                            .ChkRun:
0000C150 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
0000C156 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
0000C15A 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C15C 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
0000C162 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
0000C164 E209                       		lsr.b	#1,d1				; ''
0000C166 D001                       		add.b	d1,d0				; ''
0000C168                            
0000C168                            .SkipWalk:
0000C168 D000                       		add.b	d0,d0				; Double the offset
0000C16A 1600                       		move.b	d0,d3				; Copy the oofset
0000C16C 4442                       		neg.w	d2				; Get animation speed
0000C16E 0642 0800                  		addi.w	#$800,d2			; ''
0000C172 6A00                       		bpl.s	.SetTimer			; ''
0000C174 7400                       		moveq	#0,d2				; ''
0000C176                            
0000C176                            .SetTimer:
0000C176 E04A                       		lsr.w	#8,d2				; ''
0000C178 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C17C 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
0000C180 D728 0010                  		add.b	d3,oFrame(a0)			; Add angle offset
0000C184 4E75                       		rts
0000C186                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C186                            .TumbleAnim:
0000C186 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000C18A 7200                       		moveq	#0,d1
0000C18C 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C190 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
0000C194 6600                       		bne.s	.TumbleLeft			; If so, branch
0000C196                            
0000C196 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C19C 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C1A0 80FC 0016                  		divu.w	#$16,d0				; ''
0000C1A4 0600 0068                  		addi.b	#$68,d0				; ''
0000C1A8 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C1AC 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C1B0 4E75                       		rts
0000C1B2                            
0000C1B2                            .TumbleLeft:
0000C1B2 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C1B8 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is flipping inverted?
0000C1BC 6700                       		beq.s	.NotInverted			; If not, branch
0000C1BE 0028 0001 000D             		ori.b	#1,oRender(a0)			; Face left
0000C1C4 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C1C8 6000                       		bra.s	.SetLeftFrame			; Continue
0000C1CA                            
0000C1CA                            .NotInverted:
0000C1CA 0028 0003 000D             		ori.b	#3,oRender(a0)			; Face left and be upside down
0000C1D0 4400                       		neg.b	d0				; Get map frame
0000C1D2 0600 008F                  		addi.b	#$8F,d0				; ''
0000C1D6                            
0000C1D6                            .SetLeftFrame:
0000C1D6 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
0000C1DA 0600 0068                  		addi.b	#$68,d0				; ''
0000C1DE 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C1E2 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C1E6 4E75                       		rts
0000C1E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C1E8                            .RollAnim:
0000C1E8 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C1EA 6600                       		bne.s	.PushAnim			; If not, branch
0000C1EC                            
0000C1EC 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C1F0 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
0000C1F2 4442                       		neg.w	d2				; Force it to be negative
0000C1F4                            
0000C1F4                            .GetAnim2:
0000C1F4 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
0000C1FA 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
0000C1FE 6400                       		bcc.s	.PrepareTimer			; If so, branch
0000C200 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
0000C206                            
0000C206                            .PrepareTimer:
0000C206 4442                       		neg.w	d2				; Get animation speed
0000C208 0642 0400                  		addi.w	#$400,d2			; ''
0000C20C 6A00                       		bpl.s	.SetTimer2			; ''
0000C20E 7400                       		moveq	#0,d2				; ''
0000C210                            
0000C210                            .SetTimer2:
0000C210 E04A                       		lsr.w	#8,d2				; ''
0000C212 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C216                            
0000C216 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C21A 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
0000C21E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits in render flags
0000C224 8328 000D                  		or.b	d1,oRender(a0)			; Set new flip bits
0000C228                            
0000C228 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
0000C22C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C22C                            .PushAnim:
0000C22C 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C22E 6600                       		bne.s	.HangAnim			; If not, branch
0000C230                            
0000C230                            .DoPushAnim:
0000C230 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C234 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
0000C236 4442                       		neg.w	d2				; Force it to be negative
0000C238                            
0000C238                            .GetAnim3:
0000C238 0642 0800                  		addi.w	#$800,d2			; Get animation speed
0000C23C 6A00                       		bpl.s	.SetTimer3			; ''
0000C23E 7400                       		moveq	#0,d2				; ''
0000C240                            
0000C240                            .SetTimer3:
0000C240 EC4A                       		lsr.w	#6,d2				; ''
0000C242 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C246 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000C24C 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
0000C250                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C250                            .HangAnim:
0000C250 7200                       		moveq	#0,d1
0000C252 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation frame
0000C256 1171 1001 0010             		move.b	1(a1,d1.w),oFrame(a0)		; Set map frame
0000C25C 4228 0023                  		clr.b	oAniTimer(a0)			; Clear animation timer
0000C260 4E75                       		rts
0000C262                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C262                            ; Handle debug placement mode
0000C262                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C262                            DebugPlacement:
0000C262 7000                       		moveq	#0,d0
0000C264 1038 F8D1                  		move.b	rDebugMode.w,d0		; Get debug placement mode routine
0000C268 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000C26C D040                       		add.w	d0,d0				; Double it
0000C26E 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
0000C272                            	nextObject
0000C272 3068 0004                M 	movea.w	onext(a0),a0
0000C276 2250                     M 	move.l	oaddr(a0),a1
0000C278 4ED1                     M 	jmp	(a1)
0000C27A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C27A                            .Routines:
0000C27A 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
0000C27E 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
0000C282                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C282                            Debug_Init:
0000C282 5438 F8D1                  		addq.b	#2,rDebugMode.w		; Next routine
0000C286 4228 0010                  		clr.b	oFrame(a0)			; Reset mapping frame
0000C28A 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000C28E 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000C292 4278 F8CE                  		clr.w	rCamLocked.w			; Unlock the camera
0000C296 4228 004B                  		clr.b	oBallMode(a0)			; Reset ball mode
0000C29A 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000C29E 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set routine to main
0000C2A4                            
0000C2A4 3028 003C                  		move.w	oInteract(a0),d0		; Get object interacted with last
0000C2A8 6700                       		beq.s	.NoInteract			; If there is none, branch
0000C2AA 3240                       		movea.w	d0,a1
0000C2AC 08A9 0003 0028             		bclr	#3,oStatus(a1)			; Clear flags
0000C2B2 08A9 0005 0028             		bclr	#5,oStatus(a1)			; ''
0000C2B8 4268 003C                  		clr.w	oInteract(a0)			; No more interaction
0000C2BC                            
0000C2BC                            .NoInteract:
0000C2BC 4228 000C                  		clr.b	oFlags(a0)			; Reset flags
0000C2C0 4228 0028                  		clr.b	oStatus(a0)			; Reset status
0000C2C4 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C2CA 117C 0001 0010             		move.b	#1,oFrame(a0)			; Display the standing frame
0000C2D0 6100 FD6E                  		bsr.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000C2D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2D4                            Debug_Main:
0000C2D4 6100 EE34                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000C2D8 6100                       		bsr.s	Debug_Control			; Control
0000C2DA                            	displaySprite	2,a0,a2,1
0000C2DA 4A68 0008                M 	tst.w	odrawnext(a0)
0000C2DE 6600                     M 	bne.s	.no_222
0000C2E0 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C2E6 3478 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a2
0000C2EA 314A 000A                M 	move.w	a2,odrawprev(a0)
0000C2EE 3548 0008                M 	move.w	a0,odrawnext(a2)
0000C2F2 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C2F6                          M .no_222
0000C2F6 4E75                       		rts
0000C2F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2F8                            Debug_Control:
0000C2F8 7006                       		moveq	#6,d0				; Speed
0000C2FA 0838 0000 C740             		btst	#0,rP1Hold.w			; Is up being held?
0000C300 6700                       		beq.s	.NoUp				; If not, branch
0000C302 9168 0018                  		sub.w	d0,oYPos(a0)			; Move up
0000C306                            
0000C306                            .NoUp:
0000C306 0838 0001 C740             		btst	#1,rP1Hold.w			; Is down being held?
0000C30C 6700                       		beq.s	.NoDown				; If not, branch
0000C30E D168 0018                  		add.w	d0,oYPos(a0)			; Move down
0000C312                            
0000C312                            .NoDown:
0000C312 0838 0002 C740             		btst	#2,rP1Hold.w			; Is left being held?
0000C318 6700                       		beq.s	.NoLeft				; If not, branch
0000C31A 9168 0014                  		sub.w	d0,oXPos(a0)			; Move left
0000C31E                            
0000C31E                            .NoLeft:
0000C31E 0838 0003 C740             		btst	#3,rP1Hold.w			; Is right being held?
0000C324 6700                       		beq.s	.NoRight			; If not, branch
0000C326 D168 0014                  		add.w	d0,oXPos(a0)			; Move right
0000C32A                            
0000C32A                            .NoRight:
0000C32A 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000C330 6700                       		beq.s	.ChkWrap			; If not, branch
0000C332 7000                       		moveq	#0,d0
0000C334 11C0 F8D1                  		move.b	d0,rDebugMode.w		; Disable debug placement mode
0000C338 1140 0016                  		move.b	d0,oXPos+2(a0)			; Reset X subpixel
0000C33C 1140 001A                  		move.b	d0,oYPos+2(a0)			; Reset Y subpixel
0000C340 3140 001C                  		move.w	d0,oXVel(a0)			; Reset X velocity
0000C344 3140 001E                  		move.w	d0,oYVel(a0)			; Reset Y velocity
0000C348 3140 003A                  		move.w	d0,oGVel(a0)			; Reset ground velocity
0000C34C 0228 0001 0028             		andi.b	#1,oStatus(a0)			; Reset status
0000C352 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000C358 20BC 0000 B02A             		move.l	#ObjMighty,oAddr(a0)		; Use normal Sonic object
0000C35E 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000C364 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000C36A                            
0000C36A                            .ChkWrap:
0000C36A 4E75                       		rts
0000C36C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C36C                            ; Data
0000C36C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C36C                            ArtUnc_Sonic:
0000C36C                            		incbin	"Level/Objects/Mighty/Art.unc.bin"
00017E2C                            		even
00017E2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00017E2C                            Map_ObjMighty:
00017E2C                            		include	"Level/Objects/Mighty/Mappings.asm"
00017E2C                            ; --------------------------------------------------------------------------------
00017E2C                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00017E2C                            ; --------------------------------------------------------------------------------
00017E2C                            
00017E2C                            SME_lde97:	
00017E2C 0000 0000                  		dc.w SME_lde97_FC-SME_lde97, SME_lde97_FE-SME_lde97	
00017E30 0000 0000                  		dc.w SME_lde97_118-SME_lde97, SME_lde97_12C-SME_lde97	
00017E34 0000 0000                  		dc.w SME_lde97_140-SME_lde97, SME_lde97_154-SME_lde97	
00017E38 0000 0000                  		dc.w SME_lde97_168-SME_lde97, SME_lde97_182-SME_lde97	
00017E3C 0000 0000                  		dc.w SME_lde97_190-SME_lde97, SME_lde97_19E-SME_lde97	
00017E40 0000 0000                  		dc.w SME_lde97_1B8-SME_lde97, SME_lde97_1C6-SME_lde97	
00017E44 0000 0000                  		dc.w SME_lde97_1DA-SME_lde97, SME_lde97_1FA-SME_lde97	
00017E48 0000 0000                  		dc.w SME_lde97_220-SME_lde97, SME_lde97_23A-SME_lde97	
00017E4C 0000 0000                  		dc.w SME_lde97_25A-SME_lde97, SME_lde97_274-SME_lde97	
00017E50 0000 0000                  		dc.w SME_lde97_294-SME_lde97, SME_lde97_2AE-SME_lde97	
00017E54 0000 0000                  		dc.w SME_lde97_2BC-SME_lde97, SME_lde97_2CA-SME_lde97	
00017E58 0000 0000                  		dc.w SME_lde97_2E4-SME_lde97, SME_lde97_2F2-SME_lde97	
00017E5C 0000 0000                  		dc.w SME_lde97_306-SME_lde97, SME_lde97_32C-SME_lde97	
00017E60 0000 0000                  		dc.w SME_lde97_352-SME_lde97, SME_lde97_36C-SME_lde97	
00017E64 0000 0000                  		dc.w SME_lde97_38C-SME_lde97, SME_lde97_3A6-SME_lde97	
00017E68 0000 0000                  		dc.w SME_lde97_3C6-SME_lde97, SME_lde97_3D4-SME_lde97	
00017E6C 0000 0000                  		dc.w SME_lde97_3E2-SME_lde97, SME_lde97_3F0-SME_lde97	
00017E70 0000 0000                  		dc.w SME_lde97_3FE-SME_lde97, SME_lde97_418-SME_lde97	
00017E74 0000 0000                  		dc.w SME_lde97_42C-SME_lde97, SME_lde97_446-SME_lde97	
00017E78 0000 0000                  		dc.w SME_lde97_45A-SME_lde97, SME_lde97_468-SME_lde97	
00017E7C 0000 0000                  		dc.w SME_lde97_476-SME_lde97, SME_lde97_484-SME_lde97	
00017E80 0000 0000                  		dc.w SME_lde97_492-SME_lde97, SME_lde97_4AC-SME_lde97	
00017E84 0000 0000                  		dc.w SME_lde97_4BA-SME_lde97, SME_lde97_4D4-SME_lde97	
00017E88 0000 0000                  		dc.w SME_lde97_4E2-SME_lde97, SME_lde97_4EA-SME_lde97	
00017E8C 0000 0000                  		dc.w SME_lde97_4F2-SME_lde97, SME_lde97_4FA-SME_lde97	
00017E90 0000 0000                  		dc.w SME_lde97_502-SME_lde97, SME_lde97_50A-SME_lde97	
00017E94 0000 0000                  		dc.w SME_lde97_50C-SME_lde97, SME_lde97_50E-SME_lde97	
00017E98 0000 0000                  		dc.w SME_lde97_510-SME_lde97, SME_lde97_512-SME_lde97	
00017E9C 0000 0000                  		dc.w SME_lde97_520-SME_lde97, SME_lde97_53A-SME_lde97	
00017EA0 0000 0000                  		dc.w SME_lde97_554-SME_lde97, SME_lde97_568-SME_lde97	
00017EA4 0000 0000                  		dc.w SME_lde97_57C-SME_lde97, SME_lde97_590-SME_lde97	
00017EA8 0000 0000                  		dc.w SME_lde97_59E-SME_lde97, SME_lde97_5B2-SME_lde97	
00017EAC 0000 0000                  		dc.w SME_lde97_5C6-SME_lde97, SME_lde97_5DA-SME_lde97	
00017EB0 0000 0000                  		dc.w SME_lde97_5F4-SME_lde97, SME_lde97_60E-SME_lde97	
00017EB4 0000 0000                  		dc.w SME_lde97_610-SME_lde97, SME_lde97_612-SME_lde97	
00017EB8 0000 0000                  		dc.w SME_lde97_620-SME_lde97, SME_lde97_634-SME_lde97	
00017EBC 0000 0000                  		dc.w SME_lde97_642-SME_lde97, SME_lde97_656-SME_lde97	
00017EC0 0000 0000                  		dc.w SME_lde97_658-SME_lde97, SME_lde97_65A-SME_lde97	
00017EC4 0000 0000                  		dc.w SME_lde97_65C-SME_lde97, SME_lde97_67C-SME_lde97	
00017EC8 0000 0000                  		dc.w SME_lde97_69C-SME_lde97, SME_lde97_69E-SME_lde97	
00017ECC 0000 0000                  		dc.w SME_lde97_6A0-SME_lde97, SME_lde97_6A2-SME_lde97	
00017ED0 0000 0000                  		dc.w SME_lde97_6A4-SME_lde97, SME_lde97_6A6-SME_lde97	
00017ED4 0000 0000                  		dc.w SME_lde97_6BA-SME_lde97, SME_lde97_6CE-SME_lde97	
00017ED8 0000 0000                  		dc.w SME_lde97_6E2-SME_lde97, SME_lde97_6F6-SME_lde97	
00017EDC 0000 0000                  		dc.w SME_lde97_704-SME_lde97, SME_lde97_712-SME_lde97	
00017EE0 0000 0000                  		dc.w SME_lde97_720-SME_lde97, SME_lde97_72E-SME_lde97	
00017EE4 0000 0000                  		dc.w SME_lde97_73C-SME_lde97, SME_lde97_73E-SME_lde97	
00017EE8 0000 0000                  		dc.w SME_lde97_740-SME_lde97, SME_lde97_742-SME_lde97	
00017EEC 0000 0000                  		dc.w SME_lde97_744-SME_lde97, SME_lde97_746-SME_lde97	
00017EF0 0000 0000                  		dc.w SME_lde97_748-SME_lde97, SME_lde97_74A-SME_lde97	
00017EF4 0000 0000                  		dc.w SME_lde97_74C-SME_lde97, SME_lde97_74E-SME_lde97	
00017EF8 0000 0000                  		dc.w SME_lde97_750-SME_lde97, SME_lde97_752-SME_lde97	
00017EFC 0000 0000                  		dc.w SME_lde97_754-SME_lde97, SME_lde97_768-SME_lde97	
00017F00 0000 0000                  		dc.w SME_lde97_77C-SME_lde97, SME_lde97_78A-SME_lde97	
00017F04 0000 0000                  		dc.w SME_lde97_792-SME_lde97, SME_lde97_7A0-SME_lde97	
00017F08 0000 0000                  		dc.w SME_lde97_7B4-SME_lde97, SME_lde97_7C8-SME_lde97	
00017F0C 0000 0000                  		dc.w SME_lde97_7DC-SME_lde97, SME_lde97_7EA-SME_lde97	
00017F10 0000 0000                  		dc.w SME_lde97_7F8-SME_lde97, SME_lde97_80C-SME_lde97	
00017F14 0000 0000                  		dc.w SME_lde97_81A-SME_lde97, SME_lde97_828-SME_lde97	
00017F18 0000 0000                  		dc.w SME_lde97_836-SME_lde97, SME_lde97_844-SME_lde97	
00017F1C 0000 0000                  		dc.w SME_lde97_858-SME_lde97, SME_lde97_86C-SME_lde97	
00017F20 0000 0000                  		dc.w SME_lde97_880-SME_lde97, SME_lde97_89A-SME_lde97	
00017F24 0000 0000                  		dc.w SME_lde97_8B4-SME_lde97, SME_lde97_8CE-SME_lde97	
00017F28 0000                       SME_lde97_FC:	dc.b 0, 0	
00017F2A 0004                       SME_lde97_FE:	dc.b 0, 4	
00017F2C EC08 0000 FFF0             		dc.b $EC, 8, 0, 0, $FF, $F0	
00017F32 F40D 0003 FFF0             		dc.b $F4, $D, 0, 3, $FF, $F0	
00017F38 0408 000B FFF0             		dc.b 4, 8, 0, $B, $FF, $F0	
00017F3E 0C08 000E FFF8             		dc.b $C, 8, 0, $E, $FF, $F8	
00017F44 0003                       SME_lde97_118:	dc.b 0, 3	
00017F46 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F4C FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F52 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F58 0003                       SME_lde97_12C:	dc.b 0, 3	
00017F5A EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F60 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F66 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F6C 0003                       SME_lde97_140:	dc.b 0, 3	
00017F6E EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F74 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F7A 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F80 0003                       SME_lde97_154:	dc.b 0, 3	
00017F82 EC0A 0000 FFF0             		dc.b $EC, $A, 0, 0, $FF, $F0	
00017F88 0408 0009 FFF0             		dc.b 4, 8, 0, 9, $FF, $F0	
00017F8E 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F94 0004                       SME_lde97_168:	dc.b 0, 4	
00017F96 EB0D 0000 FFEC             		dc.b $EB, $D, 0, 0, $FF, $EC	
00017F9C FB09 0008 FFEC             		dc.b $FB, 9, 0, 8, $FF, $EC	
00017FA2 FB06 000E 0004             		dc.b $FB, 6, 0, $E, 0, 4	
00017FA8 0B04 0014 FFEC             		dc.b $B, 4, 0, $14, $FF, $EC	
00017FAE 0002                       SME_lde97_182:	dc.b 0, 2	
00017FB0 EC0D 0000 FFED             		dc.b $EC, $D, 0, 0, $FF, $ED	
00017FB6 FC0E 0008 FFF5             		dc.b $FC, $E, 0, 8, $FF, $F5	
00017FBC 0002                       SME_lde97_190:	dc.b 0, 2	
00017FBE ED09 0000 FFF3             		dc.b $ED, 9, 0, 0, $FF, $F3	
00017FC4 FD0A 0006 FFF3             		dc.b $FD, $A, 0, 6, $FF, $F3	
00017FCA 0004                       SME_lde97_19E:	dc.b 0, 4	
00017FCC EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00017FD2 FB09 0006 FFEC             		dc.b $FB, 9, 0, 6, $FF, $EC	
00017FD8 FB06 000C 0004             		dc.b $FB, 6, 0, $C, 0, 4	
00017FDE 0B04 0012 FFEC             		dc.b $B, 4, 0, $12, $FF, $EC	
00017FE4 0002                       SME_lde97_1B8:	dc.b 0, 2	
00017FE6 EC09 0000 FFF3             		dc.b $EC, 9, 0, 0, $FF, $F3	
00017FEC FC0E 0006 FFEB             		dc.b $FC, $E, 0, 6, $FF, $EB	
00017FF2 0003                       SME_lde97_1C6:	dc.b 0, 3	
00017FF4 ED0D 0000 FFEC             		dc.b $ED, $D, 0, 0, $FF, $EC	
00017FFA FD0C 0008 FFF4             		dc.b $FD, $C, 0, 8, $FF, $F4	
00018000 0509 000C FFF4             		dc.b 5, 9, 0, $C, $FF, $F4	
00018006 0005                       SME_lde97_1DA:	dc.b 0, 5	
00018008 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
0001800E EB06 0006 0003             		dc.b $EB, 6, 0, 6, 0, 3	
00018014 FB08 000C FFEB             		dc.b $FB, 8, 0, $C, $FF, $EB	
0001801A 0309 000F FFF3             		dc.b 3, 9, 0, $F, $FF, $F3	
00018020 1300 0015 FFFB             		dc.b $13, 0, 0, $15, $FF, $FB	
00018026 0006                       SME_lde97_1FA:	dc.b 0, 6	
00018028 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
0001802E EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
00018034 FC0C 0008 FFEC             		dc.b $FC, $C, 0, 8, $FF, $EC	
0001803A 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
00018040 FC05 0012 000C             		dc.b $FC, 5, 0, $12, 0, $C	
00018046 F400 0016 0014             		dc.b $F4, 0, 0, $16, 0, $14	
0001804C 0004                       SME_lde97_220:	dc.b 0, 4	
0001804E ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00018054 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
0001805A FD0D 0008 FFF5             		dc.b $FD, $D, 0, 8, $FF, $F5	
00018060 0D08 0010 FFFD             		dc.b $D, 8, 0, $10, $FF, $FD	
00018066 0005                       SME_lde97_23A:	dc.b 0, 5	
00018068 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
0001806E EB05 0006 0003             		dc.b $EB, 5, 0, 6, 0, 3	
00018074 FB0D 000A FFF3             		dc.b $FB, $D, 0, $A, $FF, $F3	
0001807A 0B08 0012 FFF3             		dc.b $B, 8, 0, $12, $FF, $F3	
00018080 1304 0015 FFFB             		dc.b $13, 4, 0, $15, $FF, $FB	
00018086 0004                       SME_lde97_25A:	dc.b 0, 4	
00018088 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
0001808E EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
00018094 FC0D 0008 FFF4             		dc.b $FC, $D, 0, 8, $FF, $F4	
0001809A 0C08 0010 FFFC             		dc.b $C, 8, 0, $10, $FF, $FC	
000180A0 0005                       SME_lde97_274:	dc.b 0, 5	
000180A2 ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
000180A8 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
000180AE FD00 0008 FFED             		dc.b $FD, 0, 0, 8, $FF, $ED	
000180B4 FD0D 0009 FFF5             		dc.b $FD, $D, 0, 9, $FF, $F5	
000180BA 0D08 0011 FFFD             		dc.b $D, 8, 0, $11, $FF, $FD	
000180C0 0004                       SME_lde97_294:	dc.b 0, 4	
000180C2 F407 0000 FFEB             		dc.b $F4, 7, 0, 0, $FF, $EB	
000180C8 EC09 0008 FFFB             		dc.b $EC, 9, 0, 8, $FF, $FB	
000180CE FC04 000E FFFB             		dc.b $FC, 4, 0, $E, $FF, $FB	
000180D4 0409 0010 FFFB             		dc.b 4, 9, 0, $10, $FF, $FB	
000180DA 0002                       SME_lde97_2AE:	dc.b 0, 2	
000180DC F407 0000 FFEC             		dc.b $F4, 7, 0, 0, $FF, $EC	
000180E2 EC0B 0008 FFFC             		dc.b $EC, $B, 0, 8, $FF, $FC	
000180E8 0002                       SME_lde97_2BC:	dc.b 0, 2	
000180EA F406 0000 FFED             		dc.b $F4, 6, 0, 0, $FF, $ED	
000180F0 F40A 0006 FFFD             		dc.b $F4, $A, 0, 6, $FF, $FD	
000180F6 0004                       SME_lde97_2CA:	dc.b 0, 4	
000180F8 F406 0000 FFEB             		dc.b $F4, 6, 0, 0, $FF, $EB	
000180FE EC09 0006 FFFB             		dc.b $EC, 9, 0, 6, $FF, $FB	
00018104 FC04 000C FFFB             		dc.b $FC, 4, 0, $C, $FF, $FB	
0001810A 0409 000E FFFB             		dc.b 4, 9, 0, $E, $FF, $FB	
00018110 0002                       SME_lde97_2E4:	dc.b 0, 2	
00018112 F406 0000 FFEC             		dc.b $F4, 6, 0, 0, $FF, $EC	
00018118 F40B 0006 FFFC             		dc.b $F4, $B, 0, 6, $FF, $FC	
0001811E 0003                       SME_lde97_2F2:	dc.b 0, 3	
00018120 F407 0000 FFED             		dc.b $F4, 7, 0, 0, $FF, $ED	
00018126 EC00 0008 FFFD             		dc.b $EC, 0, 0, 8, $FF, $FD	
0001812C F40A 0009 FFFD             		dc.b $F4, $A, 0, 9, $FF, $FD	
00018132 0006                       SME_lde97_306:	dc.b 0, 6	
00018134 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
0001813A ED04 0006 FFF3             		dc.b $ED, 4, 0, 6, $FF, $F3	
00018140 F504 0008 FFEB             		dc.b $F5, 4, 0, 8, $FF, $EB	
00018146 F50A 000A FFFB             		dc.b $F5, $A, 0, $A, $FF, $FB	
0001814C 0D00 0013 FFFB             		dc.b $D, 0, 0, $13, $FF, $FB	
00018152 FD00 0014 0013             		dc.b $FD, 0, 0, $14, 0, $13	
00018158 0006                       SME_lde97_32C:	dc.b 0, 6	
0001815A FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
00018160 E408 0006 FFF4             		dc.b $E4, 8, 0, 6, $FF, $F4	
00018166 EC04 0009 FFFC             		dc.b $EC, 4, 0, 9, $FF, $FC	
0001816C F404 000B FFEC             		dc.b $F4, 4, 0, $B, $FF, $EC	
00018172 F40A 000D FFFC             		dc.b $F4, $A, 0, $D, $FF, $FC	
00018178 0C00 0016 FFFC             		dc.b $C, 0, 0, $16, $FF, $FC	
0001817E 0004                       SME_lde97_352:	dc.b 0, 4	
00018180 FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00018186 F304 0006 FFED             		dc.b $F3, 4, 0, 6, $FF, $ED	
0001818C EB0A 0008 FFFD             		dc.b $EB, $A, 0, 8, $FF, $FD	
00018192 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00018198 0005                       SME_lde97_36C:	dc.b 0, 5	
0001819A FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
000181A0 ED08 0006 FFF3             		dc.b $ED, 8, 0, 6, $FF, $F3	
000181A6 F504 0009 FFEB             		dc.b $F5, 4, 0, 9, $FF, $EB	
000181AC F50D 000B FFFB             		dc.b $F5, $D, 0, $B, $FF, $FB	
000181B2 0508 0013 FFFB             		dc.b 5, 8, 0, $13, $FF, $FB	
000181B8 0004                       SME_lde97_38C:	dc.b 0, 4	
000181BA FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
000181C0 F404 0006 FFEC             		dc.b $F4, 4, 0, 6, $FF, $EC	
000181C6 EC0A 0008 FFFC             		dc.b $EC, $A, 0, 8, $FF, $FC	
000181CC 0404 0011 FFFC             		dc.b 4, 4, 0, $11, $FF, $FC	
000181D2 0005                       SME_lde97_3A6:	dc.b 0, 5	
000181D4 FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
000181DA EB0A 0006 FFFD             		dc.b $EB, $A, 0, 6, $FF, $FD	
000181E0 F304 000F FFED             		dc.b $F3, 4, 0, $F, $FF, $ED	
000181E6 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
000181EC 0B00 0013 FFFD             		dc.b $B, 0, 0, $13, $FF, $FD	
000181F2 0002                       SME_lde97_3C6:	dc.b 0, 2	
000181F4 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000181FA FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018200 0002                       SME_lde97_3D4:	dc.b 0, 2	
00018202 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018208 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
0001820E 0002                       SME_lde97_3E2:	dc.b 0, 2	
00018210 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018216 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
0001821C 0002                       SME_lde97_3F0:	dc.b 0, 2	
0001821E EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018224 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
0001822A 0004                       SME_lde97_3FE:	dc.b 0, 4	
0001822C EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018232 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018238 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
0001823E FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
00018244 0003                       SME_lde97_418:	dc.b 0, 3	
00018246 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
0001824C EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018252 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018258 0004                       SME_lde97_42C:	dc.b 0, 4	
0001825A EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018260 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018266 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
0001826C FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
00018272 0003                       SME_lde97_446:	dc.b 0, 3	
00018274 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
0001827A EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018280 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018286 0002                       SME_lde97_45A:	dc.b 0, 2	
00018288 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
0001828E F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00018294 0002                       SME_lde97_468:	dc.b 0, 2	
00018296 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
0001829C F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182A2 0002                       SME_lde97_476:	dc.b 0, 2	
000182A4 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
000182AA F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182B0 0002                       SME_lde97_484:	dc.b 0, 2	
000182B2 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
000182B8 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182BE 0004                       SME_lde97_492:	dc.b 0, 4	
000182C0 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
000182C6 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
000182CC EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182D2 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
000182D8 0002                       SME_lde97_4AC:	dc.b 0, 2	
000182DA F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
000182E0 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182E6 0004                       SME_lde97_4BA:	dc.b 0, 4	
000182E8 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
000182EE F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
000182F4 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182FA 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
00018300 0002                       SME_lde97_4D4:	dc.b 0, 2	
00018302 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
00018308 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
0001830E 0001                       SME_lde97_4E2:	dc.b 0, 1	
00018310 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018316 0001                       SME_lde97_4EA:	dc.b 0, 1	
00018318 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001831E 0001                       SME_lde97_4F2:	dc.b 0, 1	
00018320 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018326 0001                       SME_lde97_4FA:	dc.b 0, 1	
00018328 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001832E 0001                       SME_lde97_502:	dc.b 0, 1	
00018330 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018336 0000                       SME_lde97_50A:	dc.b 0, 0	
00018338 0000                       SME_lde97_50C:	dc.b 0, 0	
0001833A 0000                       SME_lde97_50E:	dc.b 0, 0	
0001833C 0000                       SME_lde97_510:	dc.b 0, 0	
0001833E 0002                       SME_lde97_512:	dc.b 0, 2	
00018340 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
00018346 FD0E 0006 FFF0             		dc.b $FD, $E, 0, 6, $FF, $F0	
0001834C 0004                       SME_lde97_520:	dc.b 0, 4	
0001834E ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
00018354 FD0D 0006 FFF0             		dc.b $FD, $D, 0, 6, $FF, $F0	
0001835A 0D04 000E 0000             		dc.b $D, 4, 0, $E, 0, 0	
00018360 0500 0010 FFE8             		dc.b 5, 0, 0, $10, $FF, $E8	
00018366 0004                       SME_lde97_53A:	dc.b 0, 4	
00018368 F404 0000 FFFC             		dc.b $F4, 4, 0, 0, $FF, $FC	
0001836E FC0D 0002 FFF4             		dc.b $FC, $D, 0, 2, $FF, $F4	
00018374 0C08 000A FFF4             		dc.b $C, 8, 0, $A, $FF, $F4	
0001837A 0400 000D FFEC             		dc.b 4, 0, 0, $D, $FF, $EC	
00018380 0003                       SME_lde97_554:	dc.b 0, 3	
00018382 EC08 0800 FFE8             		dc.b $EC, 8, 8, 0, $FF, $E8	
00018388 F402 0803 0000             		dc.b $F4, 2, 8, 3, 0, 0	
0001838E F40F 0806 FFE0             		dc.b $F4, $F, 8, 6, $FF, $E0	
00018394 0003                       SME_lde97_568:	dc.b 0, 3	
00018396 EC0E 0800 FFE8             		dc.b $EC, $E, 8, 0, $FF, $E8	
0001839C 040D 080C FFE0             		dc.b 4, $D, 8, $C, $FF, $E0	
000183A2 0C00 1814 0000             		dc.b $C, 0, $18, $14, 0, 0	
000183A8 0003                       SME_lde97_57C:	dc.b 0, 3	
000183AA F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
000183B0 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
000183B6 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
000183BC 0002                       SME_lde97_590:	dc.b 0, 2	
000183BE F40A 0000 FFE8             		dc.b $F4, $A, 0, 0, $FF, $E8	
000183C4 F40A 0800 0000             		dc.b $F4, $A, 8, 0, 0, 0	
000183CA 0003                       SME_lde97_59E:	dc.b 0, 3	
000183CC F40D 0000 FFE4             		dc.b $F4, $D, 0, 0, $FF, $E4	
000183D2 FC00 0008 0004             		dc.b $FC, 0, 0, 8, 0, 4	
000183D8 040C 0009 FFEC             		dc.b 4, $C, 0, 9, $FF, $EC	
000183DE 0003                       SME_lde97_5B2:	dc.b 0, 3	
000183E0 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
000183E6 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
000183EC 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
000183F2 0003                       SME_lde97_5C6:	dc.b 0, 3	
000183F4 E80B 0000 FFF0             		dc.b $E8, $B, 0, 0, $FF, $F0	
000183FA 0804 000C FFF8             		dc.b 8, 4, 0, $C, $FF, $F8	
00018400 1000 000E FFF8             		dc.b $10, 0, 0, $E, $FF, $F8	
00018406 0004                       SME_lde97_5DA:	dc.b 0, 4	
00018408 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
0001840E 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
00018414 F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
0001841A F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
00018420 0004                       SME_lde97_5F4:	dc.b 0, 4	
00018422 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
00018428 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
0001842E F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
00018434 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
0001843A 0000                       SME_lde97_60E:	dc.b 0, 0	
0001843C 0000                       SME_lde97_610:	dc.b 0, 0	
0001843E 0002                       SME_lde97_612:	dc.b 0, 2	
00018440 ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00018446 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
0001844C 0003                       SME_lde97_620:	dc.b 0, 3	
0001844E EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
00018454 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
0001845A 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
00018460 0002                       SME_lde97_634:	dc.b 0, 2	
00018462 ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00018468 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
0001846E 0003                       SME_lde97_642:	dc.b 0, 3	
00018470 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
00018476 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
0001847C 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
00018482 0000                       SME_lde97_656:	dc.b 0, 0	
00018484 0000                       SME_lde97_658:	dc.b 0, 0	
00018486 0000                       SME_lde97_65A:	dc.b 0, 0	
00018488 0005                       SME_lde97_65C:	dc.b 0, 5	
0001848A E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
00018490 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
00018496 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
0001849C 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
000184A2 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
000184A8 0005                       SME_lde97_67C:	dc.b 0, 5	
000184AA E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
000184B0 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
000184B6 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
000184BC 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
000184C2 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
000184C8 0000                       SME_lde97_69C:	dc.b 0, 0	
000184CA 0000                       SME_lde97_69E:	dc.b 0, 0	
000184CC 0000                       SME_lde97_6A0:	dc.b 0, 0	
000184CE 0000                       SME_lde97_6A2:	dc.b 0, 0	
000184D0 0000                       SME_lde97_6A4:	dc.b 0, 0	
000184D2 0003                       SME_lde97_6A6:	dc.b 0, 3	
000184D4 F40D 0800 FFE4             		dc.b $F4, $D, 8, 0, $FF, $E4	
000184DA FC05 0808 0004             		dc.b $FC, 5, 8, 8, 0, 4	
000184E0 0408 080C FFEC             		dc.b 4, 8, 8, $C, $FF, $EC	
000184E6 0003                       SME_lde97_6BA:	dc.b 0, 3	
000184E8 F40D 0800 FFFC             		dc.b $F4, $D, 8, 0, $FF, $FC	
000184EE FC00 0808 FFF4             		dc.b $FC, 0, 8, 8, $FF, $F4	
000184F4 040C 0809 FFF4             		dc.b 4, $C, 8, 9, $FF, $F4	
000184FA 0003                       SME_lde97_6CE:	dc.b 0, 3	
000184FC F00E 0000 FFEC             		dc.b $F0, $E, 0, 0, $FF, $EC	
00018502 F801 000C 000C             		dc.b $F8, 1, 0, $C, 0, $C	
00018508 080C 000E FFF4             		dc.b 8, $C, 0, $E, $FF, $F4	
0001850E 0003                       SME_lde97_6E2:	dc.b 0, 3	
00018510 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00018516 FB0E 0006 FFEC             		dc.b $FB, $E, 0, 6, $FF, $EC	
0001851C 0301 0012 000C             		dc.b 3, 1, 0, $12, 0, $C	
00018522 0002                       SME_lde97_6F6:	dc.b 0, 2	
00018524 F00F 0000 FFEC             		dc.b $F0, $F, 0, 0, $FF, $EC	
0001852A F802 0010 000C             		dc.b $F8, 2, 0, $10, 0, $C	
00018530 0002                       SME_lde97_704:	dc.b 0, 2	
00018532 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018538 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
0001853E 0002                       SME_lde97_712:	dc.b 0, 2	
00018540 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018546 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
0001854C 0002                       SME_lde97_720:	dc.b 0, 2	
0001854E F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018554 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
0001855A 0002                       SME_lde97_72E:	dc.b 0, 2	
0001855C F40F 0000 FFF5             		dc.b $F4, $F, 0, 0, $FF, $F5	
00018562 FC01 0010 FFED             		dc.b $FC, 1, 0, $10, $FF, $ED	
00018568 0000                       SME_lde97_73C:	dc.b 0, 0	
0001856A 0000                       SME_lde97_73E:	dc.b 0, 0	
0001856C 0000                       SME_lde97_740:	dc.b 0, 0	
0001856E 0000                       SME_lde97_742:	dc.b 0, 0	
00018570 0000                       SME_lde97_744:	dc.b 0, 0	
00018572 0000                       SME_lde97_746:	dc.b 0, 0	
00018574 0000                       SME_lde97_748:	dc.b 0, 0	
00018576 0000                       SME_lde97_74A:	dc.b 0, 0	
00018578 0000                       SME_lde97_74C:	dc.b 0, 0	
0001857A 0000                       SME_lde97_74E:	dc.b 0, 0	
0001857C 0000                       SME_lde97_750:	dc.b 0, 0	
0001857E 0000                       SME_lde97_752:	dc.b 0, 0	
00018580 0003                       SME_lde97_754:	dc.b 0, 3	
00018582 E409 0000 FFF0             		dc.b $E4, 9, 0, 0, $FF, $F0	
00018588 F40B 0006 FFF0             		dc.b $F4, $B, 0, 6, $FF, $F0	
0001858E F401 0012 0008             		dc.b $F4, 1, 0, $12, 0, 8	
00018594 0003                       SME_lde97_768:	dc.b 0, 3	
00018596 E50B 0000 FFF0             		dc.b $E5, $B, 0, 0, $FF, $F0	
0001859C F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
000185A2 0505 000E FFF8             		dc.b 5, 5, 0, $E, $FF, $F8	
000185A8 0002                       SME_lde97_77C:	dc.b 0, 2	
000185AA EC0B 0000 FFF1             		dc.b $EC, $B, 0, 0, $FF, $F1	
000185B0 FC01 000C 0009             		dc.b $FC, 1, 0, $C, 0, 9	
000185B6 0001                       SME_lde97_78A:	dc.b 0, 1	
000185B8 EE0F 0000 FFF0             		dc.b $EE, $F, 0, 0, $FF, $F0	
000185BE 0002                       SME_lde97_792:	dc.b 0, 2	
000185C0 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
000185C6 FA01 000C 0008             		dc.b $FA, 1, 0, $C, 0, 8	
000185CC 0003                       SME_lde97_7A0:	dc.b 0, 3	
000185CE F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000185D4 E401 000C 0000             		dc.b $E4, 1, 0, $C, 0, 0	
000185DA F401 000E 0008             		dc.b $F4, 1, 0, $E, 0, 8	
000185E0 0003                       SME_lde97_7B4:	dc.b 0, 3	
000185E2 E509 0000 FFF0             		dc.b $E5, 9, 0, 0, $FF, $F0	
000185E8 F50B 0006 FFF0             		dc.b $F5, $B, 0, 6, $FF, $F0	
000185EE ED03 0012 0008             		dc.b $ED, 3, 0, $12, 0, 8	
000185F4 0003                       SME_lde97_7C8:	dc.b 0, 3	
000185F6 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000185FC F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
00018602 E405 000E FFF8             		dc.b $E4, 5, 0, $E, $FF, $F8	
00018608 0002                       SME_lde97_7DC:	dc.b 0, 2	
0001860A ED0B 0000 FFF0             		dc.b $ED, $B, 0, 0, $FF, $F0	
00018610 F501 000C 0008             		dc.b $F5, 1, 0, $C, 0, 8	
00018616 0002                       SME_lde97_7EA:	dc.b 0, 2	
00018618 F10B 0000 FFF8             		dc.b $F1, $B, 0, 0, $FF, $F8	
0001861E F401 000C FFF0             		dc.b $F4, 1, 0, $C, $FF, $F0	
00018624 0003                       SME_lde97_7F8:	dc.b 0, 3	
00018626 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
0001862C F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
00018632 E405 000E FFF1             		dc.b $E4, 5, 0, $E, $FF, $F1	
00018638 0002                       SME_lde97_80C:	dc.b 0, 2	
0001863A F10F 0000 FFF0             		dc.b $F1, $F, 0, 0, $FF, $F0	
00018640 E105 0010 FFF0             		dc.b $E1, 5, 0, $10, $FF, $F0	
00018646 0002                       SME_lde97_81A:	dc.b 0, 2	
00018648 EC0E 0000 FFEC             		dc.b $EC, $E, 0, 0, $FF, $EC	
0001864E 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
00018654 0002                       SME_lde97_828:	dc.b 0, 2	
00018656 EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
0001865C 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
00018662 0002                       SME_lde97_836:	dc.b 0, 2	
00018664 EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
0001866A 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
00018670 0003                       SME_lde97_844:	dc.b 0, 3	
00018672 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00018678 0008 000C FFF0             		dc.b 0, 8, 0, $C, $FF, $F0	
0001867E 0809 000F FFF8             		dc.b 8, 9, 0, $F, $FF, $F8	
00018684 0003                       SME_lde97_858:	dc.b 0, 3	
00018686 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
0001868C 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
00018692 100C 0012 FFF0             		dc.b $10, $C, 0, $12, $FF, $F0	
00018698 0003                       SME_lde97_86C:	dc.b 0, 3	
0001869A E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
000186A0 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
000186A6 1004 0012 FFF0             		dc.b $10, 4, 0, $12, $FF, $F0	
000186AC 0004                       SME_lde97_880:	dc.b 0, 4	
000186AE EC0E 0800 FFF0             		dc.b $EC, $E, 8, 0, $FF, $F0	
000186B4 FC01 080C 0010             		dc.b $FC, 1, 8, $C, 0, $10	
000186BA 0408 080E FFF8             		dc.b 4, 8, 8, $E, $FF, $F8	
000186C0 0C04 0811 0000             		dc.b $C, 4, 8, $11, 0, 0	
000186C6 0004                       SME_lde97_89A:	dc.b 0, 4	
000186C8 EC0E 0000 FFF8             		dc.b $EC, $E, 0, 0, $FF, $F8	
000186CE FC01 000C FFF0             		dc.b $FC, 1, 0, $C, $FF, $F0	
000186D4 0408 000E FFF8             		dc.b 4, 8, 0, $E, $FF, $F8	
000186DA 0C04 0011 FFF8             		dc.b $C, 4, 0, $11, $FF, $F8	
000186E0 0004                       SME_lde97_8B4:	dc.b 0, 4	
000186E2 FC0E 1000 FFF8             		dc.b $FC, $E, $10, 0, $FF, $F8	
000186E8 F401 100C FFF0             		dc.b $F4, 1, $10, $C, $FF, $F0	
000186EE F408 100E FFF8             		dc.b $F4, 8, $10, $E, $FF, $F8	
000186F4 EC04 1011 FFF8             		dc.b $EC, 4, $10, $11, $FF, $F8	
000186FA 0004                       SME_lde97_8CE:	dc.b 0, 4	
000186FC FC0E 1800 FFF0             		dc.b $FC, $E, $18, 0, $FF, $F0	
00018702 F401 180C 0010             		dc.b $F4, 1, $18, $C, 0, $10	
00018708 F408 180E FFF8             		dc.b $F4, 8, $18, $E, $FF, $F8	
0001870E EC04 1811 0000             		dc.b $EC, 4, $18, $11, 0, 0	
00018714                            		even
00018714                            		even
00018714                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018714                            DPLC_ObjMighty:
00018714                            		include	"Level/Objects/Mighty/DPLCs.asm"
00018714                            ; --------------------------------------------------------------------------------
00018714                            ; Dynamic Pattern Loading Cues - output from SonMapEd - Sonic 3 & Knuckles format; --------------------------------------------------------------------------------
00018714                            
00018714                            SME_CfLJT:	
00018714 0000 0000                  		dc.w SME_CfLJT_FC-SME_CfLJT, SME_CfLJT_FE-SME_CfLJT	
00018718 0000 0000                  		dc.w SME_CfLJT_108-SME_CfLJT, SME_CfLJT_110-SME_CfLJT	
0001871C 0000 0000                  		dc.w SME_CfLJT_118-SME_CfLJT, SME_CfLJT_120-SME_CfLJT	
00018720 0000 0000                  		dc.w SME_CfLJT_128-SME_CfLJT, SME_CfLJT_132-SME_CfLJT	
00018724 0000 0000                  		dc.w SME_CfLJT_138-SME_CfLJT, SME_CfLJT_13E-SME_CfLJT	
00018728 0000 0000                  		dc.w SME_CfLJT_148-SME_CfLJT, SME_CfLJT_14E-SME_CfLJT	
0001872C 0000 0000                  		dc.w SME_CfLJT_156-SME_CfLJT, SME_CfLJT_162-SME_CfLJT	
00018730 0000 0000                  		dc.w SME_CfLJT_170-SME_CfLJT, SME_CfLJT_17A-SME_CfLJT	
00018734 0000 0000                  		dc.w SME_CfLJT_186-SME_CfLJT, SME_CfLJT_190-SME_CfLJT	
00018738 0000 0000                  		dc.w SME_CfLJT_19C-SME_CfLJT, SME_CfLJT_1A6-SME_CfLJT	
0001873C 0000 0000                  		dc.w SME_CfLJT_1AC-SME_CfLJT, SME_CfLJT_1B2-SME_CfLJT	
00018740 0000 0000                  		dc.w SME_CfLJT_1BC-SME_CfLJT, SME_CfLJT_1C2-SME_CfLJT	
00018744 0000 0000                  		dc.w SME_CfLJT_1CA-SME_CfLJT, SME_CfLJT_1D8-SME_CfLJT	
00018748 0000 0000                  		dc.w SME_CfLJT_1E6-SME_CfLJT, SME_CfLJT_1F0-SME_CfLJT	
0001874C 0000 0000                  		dc.w SME_CfLJT_1FC-SME_CfLJT, SME_CfLJT_206-SME_CfLJT	
00018750 0000 0000                  		dc.w SME_CfLJT_212-SME_CfLJT, SME_CfLJT_218-SME_CfLJT	
00018754 0000 0000                  		dc.w SME_CfLJT_21E-SME_CfLJT, SME_CfLJT_224-SME_CfLJT	
00018758 0000 0000                  		dc.w SME_CfLJT_22A-SME_CfLJT, SME_CfLJT_234-SME_CfLJT	
0001875C 0000 0000                  		dc.w SME_CfLJT_23C-SME_CfLJT, SME_CfLJT_246-SME_CfLJT	
00018760 0000 0000                  		dc.w SME_CfLJT_24E-SME_CfLJT, SME_CfLJT_254-SME_CfLJT	
00018764 0000 0000                  		dc.w SME_CfLJT_25A-SME_CfLJT, SME_CfLJT_260-SME_CfLJT	
00018768 0000 0000                  		dc.w SME_CfLJT_266-SME_CfLJT, SME_CfLJT_270-SME_CfLJT	
0001876C 0000 0000                  		dc.w SME_CfLJT_276-SME_CfLJT, SME_CfLJT_280-SME_CfLJT	
00018770 0000 0000                  		dc.w SME_CfLJT_286-SME_CfLJT, SME_CfLJT_28A-SME_CfLJT	
00018774 0000 0000                  		dc.w SME_CfLJT_28E-SME_CfLJT, SME_CfLJT_292-SME_CfLJT	
00018778 0000 0000                  		dc.w SME_CfLJT_296-SME_CfLJT, SME_CfLJT_29A-SME_CfLJT	
0001877C 0000 0000                  		dc.w SME_CfLJT_29C-SME_CfLJT, SME_CfLJT_29E-SME_CfLJT	
00018780 0000 0000                  		dc.w SME_CfLJT_2A0-SME_CfLJT, SME_CfLJT_2A2-SME_CfLJT	
00018784 0000 0000                  		dc.w SME_CfLJT_2A8-SME_CfLJT, SME_CfLJT_2B2-SME_CfLJT	
00018788 0000 0000                  		dc.w SME_CfLJT_2BC-SME_CfLJT, SME_CfLJT_2C4-SME_CfLJT	
0001878C 0000 0000                  		dc.w SME_CfLJT_2CC-SME_CfLJT, SME_CfLJT_2D4-SME_CfLJT	
00018790 0000 0000                  		dc.w SME_CfLJT_2D8-SME_CfLJT, SME_CfLJT_2E0-SME_CfLJT	
00018794 0000 0000                  		dc.w SME_CfLJT_2E8-SME_CfLJT, SME_CfLJT_2F0-SME_CfLJT	
00018798 0000 0000                  		dc.w SME_CfLJT_2FA-SME_CfLJT, SME_CfLJT_304-SME_CfLJT	
0001879C 0000 0000                  		dc.w SME_CfLJT_306-SME_CfLJT, SME_CfLJT_308-SME_CfLJT	
000187A0 0000 0000                  		dc.w SME_CfLJT_30E-SME_CfLJT, SME_CfLJT_316-SME_CfLJT	
000187A4 0000 0000                  		dc.w SME_CfLJT_31C-SME_CfLJT, SME_CfLJT_324-SME_CfLJT	
000187A8 0000 0000                  		dc.w SME_CfLJT_326-SME_CfLJT, SME_CfLJT_328-SME_CfLJT	
000187AC 0000 0000                  		dc.w SME_CfLJT_32A-SME_CfLJT, SME_CfLJT_336-SME_CfLJT	
000187B0 0000 0000                  		dc.w SME_CfLJT_342-SME_CfLJT, SME_CfLJT_344-SME_CfLJT	
000187B4 0000 0000                  		dc.w SME_CfLJT_346-SME_CfLJT, SME_CfLJT_348-SME_CfLJT	
000187B8 0000 0000                  		dc.w SME_CfLJT_34A-SME_CfLJT, SME_CfLJT_34C-SME_CfLJT	
000187BC 0000 0000                  		dc.w SME_CfLJT_354-SME_CfLJT, SME_CfLJT_35C-SME_CfLJT	
000187C0 0000 0000                  		dc.w SME_CfLJT_364-SME_CfLJT, SME_CfLJT_36C-SME_CfLJT	
000187C4 0000 0000                  		dc.w SME_CfLJT_372-SME_CfLJT, SME_CfLJT_378-SME_CfLJT	
000187C8 0000 0000                  		dc.w SME_CfLJT_37E-SME_CfLJT, SME_CfLJT_384-SME_CfLJT	
000187CC 0000 0000                  		dc.w SME_CfLJT_38A-SME_CfLJT, SME_CfLJT_38C-SME_CfLJT	
000187D0 0000 0000                  		dc.w SME_CfLJT_38E-SME_CfLJT, SME_CfLJT_390-SME_CfLJT	
000187D4 0000 0000                  		dc.w SME_CfLJT_392-SME_CfLJT, SME_CfLJT_394-SME_CfLJT	
000187D8 0000 0000                  		dc.w SME_CfLJT_396-SME_CfLJT, SME_CfLJT_398-SME_CfLJT	
000187DC 0000 0000                  		dc.w SME_CfLJT_39A-SME_CfLJT, SME_CfLJT_39C-SME_CfLJT	
000187E0 0000 0000                  		dc.w SME_CfLJT_39E-SME_CfLJT, SME_CfLJT_3A0-SME_CfLJT	
000187E4 0000 0000                  		dc.w SME_CfLJT_3A2-SME_CfLJT, SME_CfLJT_3AA-SME_CfLJT	
000187E8 0000 0000                  		dc.w SME_CfLJT_3B2-SME_CfLJT, SME_CfLJT_3B8-SME_CfLJT	
000187EC 0000 0000                  		dc.w SME_CfLJT_3BC-SME_CfLJT, SME_CfLJT_3C2-SME_CfLJT	
000187F0 0000 0000                  		dc.w SME_CfLJT_3CA-SME_CfLJT, SME_CfLJT_3D2-SME_CfLJT	
000187F4 0000 0000                  		dc.w SME_CfLJT_3DA-SME_CfLJT, SME_CfLJT_3E0-SME_CfLJT	
000187F8 0000 0000                  		dc.w SME_CfLJT_3E6-SME_CfLJT, SME_CfLJT_3EE-SME_CfLJT	
000187FC 0000 0000                  		dc.w SME_CfLJT_3F4-SME_CfLJT, SME_CfLJT_3FA-SME_CfLJT	
00018800 0000 0000                  		dc.w SME_CfLJT_400-SME_CfLJT, SME_CfLJT_406-SME_CfLJT	
00018804 0000 0000                  		dc.w SME_CfLJT_40E-SME_CfLJT, SME_CfLJT_416-SME_CfLJT	
00018808 0000 0000                  		dc.w SME_CfLJT_41E-SME_CfLJT, SME_CfLJT_428-SME_CfLJT	
0001880C 0000 0000                  		dc.w SME_CfLJT_432-SME_CfLJT, SME_CfLJT_43C-SME_CfLJT	
00018810 0000                       SME_CfLJT_FC:	dc.b 0, 0	
00018812 0004 2000 7003 200B 200E   SME_CfLJT_FE:	dc.b 0, 4, $20, 0, $70, 3, $20, $B, $20, $E	
0001881C 0003 5011 5017 201D        SME_CfLJT_108:	dc.b 0, 3, $50, $11, $50, $17, $20, $1D	
00018824 0003 5020 5017 201D        SME_CfLJT_110:	dc.b 0, 3, $50, $20, $50, $17, $20, $1D	
0001882C 0003 5020 5017 2026        SME_CfLJT_118:	dc.b 0, 3, $50, $20, $50, $17, $20, $26	
00018834 0003 8029 200B 200E        SME_CfLJT_120:	dc.b 0, 3, $80, $29, $20, $B, $20, $E	
0001883C 0004 7032 503A 5040 1046   SME_CfLJT_128:	dc.b 0, 4, $70, $32, $50, $3A, $50, $40, $10, $46	
00018846 0002 7032 B048             SME_CfLJT_132:	dc.b 0, 2, $70, $32, $B0, $48	
0001884C 0002 5054 805A             SME_CfLJT_138:	dc.b 0, 2, $50, $54, $80, $5A	
00018852 0004 5054 5063 5069 106F   SME_CfLJT_13E:	dc.b 0, 4, $50, $54, $50, $63, $50, $69, $10, $6F	
0001885C 0002 5054 B071             SME_CfLJT_148:	dc.b 0, 2, $50, $54, $B0, $71	
00018862 0003 7032 307D 5081        SME_CfLJT_14E:	dc.b 0, 3, $70, $32, $30, $7D, $50, $81	
0001886A 0005 5087 508D 2093 5096+  SME_CfLJT_156:	dc.b 0, 5, $50, $87, $50, $8D, $20, $93, $50, $96, 0, $9C	
00018876 0006 5087 109D 309F 50A3+  SME_CfLJT_162:	dc.b 0, 6, $50, $87, $10, $9D, $30, $9F, $50, $A3, $30, $A9, 0, $AD	
00018884 0004 50AE 10B4 70B6 20BE   SME_CfLJT_170:	dc.b 0, 4, $50, $AE, $10, $B4, $70, $B6, $20, $BE	
0001888E 0005 50C1 30C7 70CB 20D3+  SME_CfLJT_17A:	dc.b 0, 5, $50, $C1, $30, $C7, $70, $CB, $20, $D3, $10, $D6	
0001889A 0004 50C1 10D8 70DA 20E2   SME_CfLJT_186:	dc.b 0, 4, $50, $C1, $10, $D8, $70, $DA, $20, $E2	
000188A4 0005 5087 109D 0093 70E5+  SME_CfLJT_190:	dc.b 0, 5, $50, $87, $10, $9D, 0, $93, $70, $E5, $20, $ED	
000188B0 0004 70F0 50F8 10FE 5100   SME_CfLJT_19C:	dc.b 0, 4, $70, $F0, $50, $F8, $10, $FE, $51, 0	
000188BA 0002 70F0 B106             SME_CfLJT_1A6:	dc.b 0, 2, $70, $F0, $B1, 6	
000188C0 0002 5112 8118             SME_CfLJT_1AC:	dc.b 0, 2, $51, $12, $81, $18	
000188C6 0004 5112 5121 1127 5129   SME_CfLJT_1B2:	dc.b 0, 4, $51, $12, $51, $21, $11, $27, $51, $29	
000188D0 0002 5112 B12F             SME_CfLJT_1BC:	dc.b 0, 2, $51, $12, $B1, $2F	
000188D6 0003 70F0 0106 813B        SME_CfLJT_1C2:	dc.b 0, 3, $70, $F0, 1, 6, $81, $3B	
000188DE 0006 5144 114A 114C 814E+  SME_CfLJT_1CA:	dc.b 0, 6, $51, $44, $11, $4A, $11, $4C, $81, $4E, 1, $57, 1, $58	
000188EC 0006 5144 2159 115C 115E+  SME_CfLJT_1D8:	dc.b 0, 6, $51, $44, $21, $59, $11, $5C, $11, $5E, $81, $60, 1, $57	
000188FA 0004 5169 116F 8171 117A   SME_CfLJT_1E6:	dc.b 0, 4, $51, $69, $11, $6F, $81, $71, $11, $7A	
00018904 0005 517C 2182 1185 7187+  SME_CfLJT_1F0:	dc.b 0, 5, $51, $7C, $21, $82, $11, $85, $71, $87, $21, $8F	
00018910 0004 517C 1192 8194 119D   SME_CfLJT_1FC:	dc.b 0, 4, $51, $7C, $11, $92, $81, $94, $11, $9D	
0001891A 0005 5144 819F 115E 11A8+  SME_CfLJT_206:	dc.b 0, 5, $51, $44, $81, $9F, $11, $5E, $11, $A8, 1, $57	
00018926 0002 51AA B1B0             SME_CfLJT_212:	dc.b 0, 2, $51, $AA, $B1, $B0	
0001892C 0002 5054 B1BC             SME_CfLJT_218:	dc.b 0, 2, $50, $54, $B1, $BC	
00018932 0002 51AA B1C8             SME_CfLJT_21E:	dc.b 0, 2, $51, $AA, $B1, $C8	
00018938 0002 5054 B1D4             SME_CfLJT_224:	dc.b 0, 2, $50, $54, $B1, $D4	
0001893E 0004 51E0 11E6 B1E8 01F4   SME_CfLJT_22A:	dc.b 0, 4, $51, $E0, $11, $E6, $B1, $E8, 1, $F4	
00018948 0003 51F5 11FB B1FD        SME_CfLJT_234:	dc.b 0, 3, $51, $F5, $11, $FB, $B1, $FD	
00018950 0004 51E0 1209 B20B 01F4   SME_CfLJT_23C:	dc.b 0, 4, $51, $E0, $12, 9, $B2, $B, 1, $F4	
0001895A 0003 51F5 11FB B217        SME_CfLJT_246:	dc.b 0, 3, $51, $F5, $11, $FB, $B2, $17	
00018962 0002 5223 B229             SME_CfLJT_24E:	dc.b 0, 2, $52, $23, $B2, $29	
00018968 0002 5112 B235             SME_CfLJT_254:	dc.b 0, 2, $51, $12, $B2, $35	
0001896E 0002 5223 B241             SME_CfLJT_25A:	dc.b 0, 2, $52, $23, $B2, $41	
00018974 0002 5112 B24D             SME_CfLJT_260:	dc.b 0, 2, $51, $12, $B2, $4D	
0001897A 0004 5259 125F B261 026D   SME_CfLJT_266:	dc.b 0, 4, $52, $59, $12, $5F, $B2, $61, 2, $6D	
00018984 0002 726E B276             SME_CfLJT_270:	dc.b 0, 2, $72, $6E, $B2, $76	
0001898A 0004 5259 1282 B284 026D   SME_CfLJT_276:	dc.b 0, 4, $52, $59, $12, $82, $B2, $84, 2, $6D	
00018994 0002 726E B290             SME_CfLJT_280:	dc.b 0, 2, $72, $6E, $B2, $90	
0001899A 0001 F29C                  SME_CfLJT_286:	dc.b 0, 1, $F2, $9C	
0001899E 0001 F2AC                  SME_CfLJT_28A:	dc.b 0, 1, $F2, $AC	
000189A2 0001 F2BC                  SME_CfLJT_28E:	dc.b 0, 1, $F2, $BC	
000189A6 0001 F2CC                  SME_CfLJT_292:	dc.b 0, 1, $F2, $CC	
000189AA 0001 F2DC                  SME_CfLJT_296:	dc.b 0, 1, $F2, $DC	
000189AE 0000                       SME_CfLJT_29A:	dc.b 0, 0	
000189B0 0000                       SME_CfLJT_29C:	dc.b 0, 0	
000189B2 0000                       SME_CfLJT_29E:	dc.b 0, 0	
000189B4 0000                       SME_CfLJT_2A0:	dc.b 0, 0	
000189B6 0002 52EC B2F2             SME_CfLJT_2A2:	dc.b 0, 2, $52, $EC, $B2, $F2	
000189BC 0004 52FE 7304 130C 030E   SME_CfLJT_2A8:	dc.b 0, 4, $52, $FE, $73, 4, $13, $C, 3, $E	
000189C6 0004 130F 7311 2319 031C   SME_CfLJT_2B2:	dc.b 0, 4, $13, $F, $73, $11, $23, $19, 3, $1C	
000189D0 0003 231D 2320 F323        SME_CfLJT_2BC:	dc.b 0, 3, $23, $1D, $23, $20, $F3, $23	
000189D8 0003 B333 733F 0071        SME_CfLJT_2C4:	dc.b 0, 3, $B3, $33, $73, $3F, 0, $71	
000189E0 0003 7347 334F 2353        SME_CfLJT_2CC:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
000189E8 0001 8356                  SME_CfLJT_2D4:	dc.b 0, 1, $83, $56	
000189EC 0003 735F 0367 3368        SME_CfLJT_2D8:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
000189F4 0003 736C 3374 2378        SME_CfLJT_2E0:	dc.b 0, 3, $73, $6C, $33, $74, $23, $78	
000189FC 0003 B37B 1387 0389        SME_CfLJT_2E8:	dc.b 0, 3, $B3, $7B, $13, $87, 3, $89	
00018A04 0004 B38A 3396 039A 039B   SME_CfLJT_2F0:	dc.b 0, 4, $B3, $8A, $33, $96, 3, $9A, 3, $9B	
00018A0E 0004 B39C 33A8 03AC 03AD   SME_CfLJT_2FA:	dc.b 0, 4, $B3, $9C, $33, $A8, 3, $AC, 3, $AD	
00018A18 0000                       SME_CfLJT_304:	dc.b 0, 0	
00018A1A 0000                       SME_CfLJT_306:	dc.b 0, 0	
00018A1C 0002 83AE 73B7             SME_CfLJT_308:	dc.b 0, 2, $83, $AE, $73, $B7	
00018A22 0003 83BF 23C8 13CB        SME_CfLJT_30E:	dc.b 0, 3, $83, $BF, $23, $C8, $13, $CB	
00018A2A 0002 83CD 73D6             SME_CfLJT_316:	dc.b 0, 2, $83, $CD, $73, $D6	
00018A30 0003 83BF 23DE 13E1        SME_CfLJT_31C:	dc.b 0, 3, $83, $BF, $23, $DE, $13, $E1	
00018A38 0000                       SME_CfLJT_324:	dc.b 0, 0	
00018A3A 0000                       SME_CfLJT_326:	dc.b 0, 0	
00018A3C 0000                       SME_CfLJT_328:	dc.b 0, 0	
00018A3E 0005 73E3 13EB 53ED 33F3+  SME_CfLJT_32A:	dc.b 0, 5, $73, $E3, $13, $EB, $53, $ED, $33, $F3, 3, $F7	
00018A4A 0005 73F8 13EB 5400 33F3+  SME_CfLJT_336:	dc.b 0, 5, $73, $F8, $13, $EB, $54, 0, $33, $F3, 3, $F7	
00018A56 0000                       SME_CfLJT_342:	dc.b 0, 0	
00018A58 0000                       SME_CfLJT_344:	dc.b 0, 0	
00018A5A 0000                       SME_CfLJT_346:	dc.b 0, 0	
00018A5C 0000                       SME_CfLJT_348:	dc.b 0, 0	
00018A5E 0000                       SME_CfLJT_34A:	dc.b 0, 0	
00018A60 0003 7347 334F 2353        SME_CfLJT_34C:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018A68 0003 735F 0367 3368        SME_CfLJT_354:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018A70 0003 B406 1412 3414        SME_CfLJT_35C:	dc.b 0, 3, $B4, 6, $14, $12, $34, $14	
00018A78 0003 5418 B41E 106D        SME_CfLJT_364:	dc.b 0, 3, $54, $18, $B4, $1E, $10, $6D	
00018A80 0002 F42A 243A             SME_CfLJT_36C:	dc.b 0, 2, $F4, $2A, $24, $3A	
00018A86 0002 F43D 244D             SME_CfLJT_372:	dc.b 0, 2, $F4, $3D, $24, $4D	
00018A8C 0002 F450 2460             SME_CfLJT_378:	dc.b 0, 2, $F4, $50, $24, $60	
00018A92 0002 F463 2473             SME_CfLJT_37E:	dc.b 0, 2, $F4, $63, $24, $73	
00018A98 0002 F476 1486             SME_CfLJT_384:	dc.b 0, 2, $F4, $76, $14, $86	
00018A9E 0000                       SME_CfLJT_38A:	dc.b 0, 0	
00018AA0 0000                       SME_CfLJT_38C:	dc.b 0, 0	
00018AA2 0000                       SME_CfLJT_38E:	dc.b 0, 0	
00018AA4 0000                       SME_CfLJT_390:	dc.b 0, 0	
00018AA6 0000                       SME_CfLJT_392:	dc.b 0, 0	
00018AA8 0000                       SME_CfLJT_394:	dc.b 0, 0	
00018AAA 0000                       SME_CfLJT_396:	dc.b 0, 0	
00018AAC 0000                       SME_CfLJT_398:	dc.b 0, 0	
00018AAE 0000                       SME_CfLJT_39A:	dc.b 0, 0	
00018AB0 0000                       SME_CfLJT_39C:	dc.b 0, 0	
00018AB2 0000                       SME_CfLJT_39E:	dc.b 0, 0	
00018AB4 0000                       SME_CfLJT_3A0:	dc.b 0, 0	
00018AB6 0003 5488 B48E 149A        SME_CfLJT_3A2:	dc.b 0, 3, $54, $88, $B4, $8E, $14, $9A	
00018ABE 0003 B49C 14A8 34AA        SME_CfLJT_3AA:	dc.b 0, 3, $B4, $9C, $14, $A8, $34, $AA	
00018AC6 0002 B4AE 14BA             SME_CfLJT_3B2:	dc.b 0, 2, $B4, $AE, $14, $BA	
00018ACC 0001 F4BC                  SME_CfLJT_3B8:	dc.b 0, 1, $F4, $BC	
00018AD0 0002 B4CC 14D8             SME_CfLJT_3BC:	dc.b 0, 2, $B4, $CC, $14, $D8	
00018AD6 0003 B4DA 14E6 14E8        SME_CfLJT_3C2:	dc.b 0, 3, $B4, $DA, $14, $E6, $14, $E8	
00018ADE 0003 54EA B4F0 34FC        SME_CfLJT_3CA:	dc.b 0, 3, $54, $EA, $B4, $F0, $34, $FC	
00018AE6 0003 B500 150C 350E        SME_CfLJT_3D2:	dc.b 0, 3, $B5, 0, $15, $C, $35, $E	
00018AEE 0002 B512 151E             SME_CfLJT_3DA:	dc.b 0, 2, $B5, $12, $15, $1E	
00018AF4 0002 B520 152C             SME_CfLJT_3E0:	dc.b 0, 2, $B5, $20, $15, $2C	
00018AFA 0003 B52E 153A 353C        SME_CfLJT_3E6:	dc.b 0, 3, $B5, $2E, $15, $3A, $35, $3C	
00018B02 0002 F540 3550             SME_CfLJT_3EE:	dc.b 0, 2, $F5, $40, $35, $50	
00018B08 0002 B554 5560             SME_CfLJT_3F4:	dc.b 0, 2, $B5, $54, $55, $60	
00018B0E 0002 B566 2572             SME_CfLJT_3FA:	dc.b 0, 2, $B5, $66, $25, $72	
00018B14 0002 B575 2581             SME_CfLJT_400:	dc.b 0, 2, $B5, $75, $25, $81	
00018B1A 0003 B584 2590 5593        SME_CfLJT_406:	dc.b 0, 3, $B5, $84, $25, $90, $55, $93	
00018B22 0003 B599 55A5 35AB        SME_CfLJT_40E:	dc.b 0, 3, $B5, $99, $55, $A5, $35, $AB	
00018B2A 0003 B5AF 55BB 15C1        SME_CfLJT_416:	dc.b 0, 3, $B5, $AF, $55, $BB, $15, $C1	
00018B32 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_41E:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B3C 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_428:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B46 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_432:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B50 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_43C:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B5A                            		even
00018B5A                            		even
00018B5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018B5A                            Ani_ObjMighty:
00018B5A                            		include	"Level/Objects/Mighty/Animations.asm"
00018B5A                            ; ---------------------------------------------------------------------------
00018B5A                            ; Animation script - Sonic
00018B5A                            ; ---------------------------------------------------------------------------
00018B5A                            SonicAniData:
00018B5A 0000                       		dc.w SonicAni_Walk-SonicAniData
00018B5C 0000                       		dc.w SonicAni_Run-SonicAniData
00018B5E 0000                       		dc.w SonicAni_Roll-SonicAniData
00018B60 0000                       		dc.w SonicAni_Roll2-SonicAniData
00018B62 0000                       		dc.w SonicAni_Push-SonicAniData
00018B64 0000                       		dc.w SonicAni_Wait-SonicAniData
00018B66 0000                       		dc.w SonicAni_Balance-SonicAniData
00018B68 0000                       		dc.w SonicAni_LookUp-SonicAniData
00018B6A 0000                       		dc.w SonicAni_Duck-SonicAniData
00018B6C 0000                       		dc.w SonicAni_Sprint-SonicAniData
00018B6E 0000                       		dc.w SonicAni_Hang-SonicAniData
00018B70 0000                       		dc.w SonicAni_Seizure-SonicAniData
00018B72 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B74 0000                       		dc.w SonicAni_Skid-SonicAniData
00018B76 0000                       		dc.w SonicAni_Float1-SonicAniData
00018B78 0000                       		dc.w SonicAni_Float2-SonicAniData
00018B7A 0000                       		dc.w SonicAni_Spring-SonicAniData
00018B7C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B7E 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B80 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B82 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B84 0000                       		dc.w SonicAni_Bubble-SonicAniData
00018B86 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B88 0000                       		dc.w SonicAni_Drown-SonicAniData
00018B8A 0000                       		dc.w SonicAni_Death-SonicAniData
00018B8C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B8E 0000                       		dc.w SonicAni_Hurt-SonicAniData
00018B90 0000                       		dc.w SonicAni_Slide-SonicAniData
00018B92 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B94 0000                       		dc.w SonicAni_Float3-SonicAniData
00018B96 0000                       		dc.w SonicAni_Float4-SonicAniData
00018B98 0100 FD00                  SonicAni_Blank:		dc.b 1, 0, $FD, 0
00018B9C FF08 090A 0B06 07FF        SonicAni_Walk:		dc.b $FF, $08, $09, $0A, $0B, $06, $07, $FF
00018BA4 FF1E 1F20 21FF FFFF        SonicAni_Run:		dc.b $FF, $1E, $1F, $20, $21, $FF, $FF,	$FF
00018BAC FF58 595A 5BFF FFFF        SonicAni_Sprint:	dc.b $FF, $58, $59, $5A, $5B, $FF, $FF, $FF
00018BB4 FE2E 2F30 3132 FFFF        SonicAni_Roll:		dc.b $FE, $2E, $2F, $30, $31, $32, $FF,	$FF
00018BBC FE2E 2F32 3031 32FF        SonicAni_Roll2:		dc.b $FE, $2E, $2F, $32, $30, $31, $32,	$FF
00018BC4 FD45 4647 48FF FFFF        SonicAni_Push:		dc.b $FD, $45, $46, $47, $48, $FF, $FF,	$FF
00018BCC 1701 0101 0101 0101 0101+  SonicAni_Wait:		dc.b $17, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 3, 2, 2, 2, 3, 4, $FE, 2, 0
00018BE2 1F3A 3BFF                  SonicAni_Balance:	dc.b $1F, $3A, $3B, $FF
00018BE6 3F05 FF00                  SonicAni_LookUp:	dc.b $3F, 5, $FF, 0
00018BEA 3F39 FF00                  SonicAni_Duck:		dc.b $3F, $39, $FF, 0
00018BEE 0737 38FF                  SonicAni_Skid:		dc.b 7,	$37, $38, $FF
00018BF2 073C 3FFF                  SonicAni_Float1:	dc.b 7,	$3C, $3F, $FF
00018BF6 073C 3D53 3E54 FF00        SonicAni_Float2:	dc.b 7,	$3C, $3D, $53, $3E, $54, $FF, 0
00018BFE 2F40 FD00                  SonicAni_Spring:	dc.b $2F, $40, $FD, 0
00018C02 FC78 7978 77FF             SonicAni_Hang:		dc.b $FC, $78, $79, $78, $77, $FF
00018C08 0B56 560A 0BFD 0000        SonicAni_Bubble:	dc.b $B, $56, $56, $A, $B, $FD,	0, 0
00018C10 2F4C FF00                  SonicAni_Drown:		dc.b $2F, $4C, $FF, 0
00018C14 034D FF00                  SonicAni_Death:		dc.b 3,	$4D, $FF, 0
00018C18 0355 FF00                  SonicAni_Hurt:		dc.b 3,	$55, $FF, 0
00018C1C 0755 57FF                  SonicAni_Slide:		dc.b 7, $55, $57, $FF
00018C20 033C 3D53 3E54 FF00        SonicAni_Float3:	dc.b 3,	$3C, $3D, $53, $3E, $54, $FF, 0
00018C28 033C FD00                  SonicAni_Float4:	dc.b 3,	$3C, $FD, 0
00018C2C 027A 7B7C 7DFF             SonicAni_Seizure:	dc.b 2, $7A, $7B, $7C, $7D, $FF
00018C32                            		even
00018C32                            		even
00018C32                            ; =========================================================================================================================================================
00018C32                            		include	"Level/Objects/Ring/Code.asm"		; Ring loss object
00018C32                            ; =========================================================================================================================================================
00018C32                            ; Mighty The Armadillo in PRISM PARADISE
00018C32                            ; By Nat The Porcupine 2021
00018C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C32                            ; Water surface object
00018C32                            ; =========================================================================================================================================================
00018C32                            		rsset	oLvlSSTs
00018C32                            
00018C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C32                            ObjRingLoss:
00018C32 2248                       		movea.l	a0,a1
00018C34 7A00                       		moveq	#0,d5
00018C36 3A38 F3D4                  		move.w	rRings.w,d5
00018C3A 7020                       		moveq	#32,d0
00018C3C BA40                       		cmp.w	d0,d5
00018C3E 6500                       		bcs.s	.BelowMax
00018C40 3A00                       		move.w	d0,d5
00018C42                            
00018C42                            .BelowMax:
00018C42 5345                       		subq.w	#1,d5
00018C44 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00018C4A 6000                       		bra.s	.MakeRings
00018C4C                            
00018C4C                            .Loop:
00018C4C 4EB8 19B0                  		jsr	FindFreeObj.w
00018C50 6700                       		beq.s	.ResetCounter
00018C52                            
00018C52                            .MakeRings:
00018C52 22BC 0000 0000             		move.l	#ObjLostRing,oAddr(a1)
00018C58 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00018C5E 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00018C64 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,oMap(a1)	; Mappings
00018C6C 337C 26B4 000E             		move.w	#$26B4,oVRAM(a1)		; Tile properties
00018C72 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00018C78                            	displaySprite	3,a1,a2,0			; Priority
00018C78 337C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a1)
00018C7E 3478 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a2
00018C82 334A 000A                M 	move.w	a2,odrawprev(a1)
00018C86 3549 0008                M 	move.w	a1,odrawnext(a2)
00018C8A 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00018C8E                          M .no_223
00018C8E 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00018C94 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00018C9A 137C 0008 002C             		move.b	#8,oColW(a1)			; Collision width
00018CA0 137C 0008 002D             		move.b	#8,oColH(a1)			; Collision height
00018CA6 335B 001C                  		move.w	(a3)+,oXVel(a1)
00018CAA 335B 001E                  		move.w	(a3)+,oYVel(a1)
00018CAE 51CD FF9C                  		dbf	d5,.Loop
00018CB2 11FC 00FF F3D9             		move.b	#-1,rRLossAniT.w
00018CB8                            
00018CB8                            .ResetCounter:
00018CB8 4278 F3D4                  		clr.w	rRings.w
00018CBC 11FC 0001 F8F3             		move.b	#1,rUpdateRings.w
00018CC2                            		playSnd	#sRingLoss, 2
00018CC2 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00018CC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018CC8                            ObjLostRing:
00018CC8 4EB8 1CE0                  		jsr	ObjectMove.w
00018CCC 0668 0018 001E             		addi.w	#$18,oYVel(a0)
00018CD2 6B00                       		bmi.s	.ChkCol
00018CD4 1038 C759                  		move.b	(rFrameCnt+3).w,d0
00018CD8 D048                       		add.w	a0,d0
00018CDA 0200 0006                  		andi.b	#6,d0
00018CDE 6600                       		bne.s	.ChkCol
00018CE0 4EB8 2FC2                  		jsr	ObjCheckFloorDist
00018CE4 4A41                       		tst.w	d1
00018CE6 6A00                       		bpl.s	.ChkCol
00018CE8 D368 0018                  		add.w	d1,oYPos(a0)
00018CEC 3028 001E                  		move.w	oYVel(a0),d0
00018CF0 E440                       		asr.w	#2,d0
00018CF2 9168 001E                  		sub.w	d0,oYVel(a0)
00018CF6 4468 001E                  		neg.w	oYVel(a0)
00018CFA                            
00018CFA                            .ChkCol:
00018CFA 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00018CFE 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00018D02 4EB8 1D1A                  		jsr	CheckObjInRange.w		; Is the player in range?
00018D06 4A40                       		tst.w	d0				; ''
00018D08 6700                       		beq.s	.ChkDel				; If not, branch
00018D0A 0C2A 0069 0042             		cmpi.b	#105,oInvulTime(a2)
00018D10 6400                       		bhs.s	.ChkDel
00018D12 6000                       		bra.s	ObjLostRing_Collect
00018D14                            
00018D14                            .ChkDel:
00018D14 4A38 F3D9                  		tst.b	rRLossAniT.w
00018D18 6700 0000                  		beq.w	ObjLostRing_Delete
00018D1C 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
00018D20 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00018D24 B068 0018                  		cmp.w	oYPos(a0),d0			; Have we touched the bottom boundary?
00018D28 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00018D2A                            	nextObject
00018D2A 3068 0004                M 	movea.w	onext(a0),a0
00018D2E 2250                     M 	move.l	oaddr(a0),a1
00018D30 4ED1                     M 	jmp	(a1)
00018D32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D32                            .RangeData:
00018D32 FFF0 0020                  		dc.w	-$10, $20
00018D36 FFF0 0020                  		dc.w	-$10, $20
00018D3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D3A                            ObjLostRing_Collect:
00018D3A                            	removeSprite	a0,a1,0
00018D3A 3268 000A                M 	move.w	odrawprev(a0),a1
00018D3E 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00018D44 3268 0008                M 	move.w	odrawnext(a0),a1
00018D48 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00018D4E                          M .no_226
00018D4E 42A8 0008                M 	clr.l	odrawnext(a0)
00018D52                          M .yes_226
00018D52                            	displaySprite	1,a0,a1,0
00018D52 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018D58 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018D5C 3149 000A                M 	move.w	a1,odrawprev(a0)
00018D60 3348 0008                M 	move.w	a0,odrawnext(a1)
00018D64 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018D68                          M .no_227
00018D68 4EB8 3ECC                  		jsr	CollectRing
00018D6C 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00018D72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D72                            ObjLostRing_Sparkle:
00018D72 43F9 0000 0000             		lea	Ani_ObjRing,a1
00018D78 4EB8 1BFA                  		jsr	AnimateObject.w
00018D7C 4A28 0025                  		tst.b	oRoutine(a0)
00018D80 6600                       		bne.s	ObjLostRing_Delete
00018D82                            	nextObject
00018D82 3068 0004                M 	movea.w	onext(a0),a0
00018D86 2250                     M 	move.l	oaddr(a0),a1
00018D88 4ED1                     M 	jmp	(a1)
00018D8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D8A                            ObjLostRing_Delete:
00018D8A 4EB8 1A06                  		jsr	DeleteObject.w
00018D8E                            	nextObject
00018D8E 3068 0004                M 	movea.w	onext(a0),a0
00018D92 2250                     M 	move.l	oaddr(a0),a1
00018D94 4ED1                     M 	jmp	(a1)
00018D96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D96                            ; Ring Spawn Array
00018D96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D96                            ObjLostRing_Speeds:
00018D96 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00018DA6 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00018DB6 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00018DC6 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00018DD6 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00018DE6 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00018DF6 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00018E06 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00018E16                            		even
00018E16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E16                            ; Data
00018E16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E16                            Map_ObjLostRing:
00018E16                            		include	"Level/Objects/Ring/Mappings.asm"
00018E16                            ; --------------------------------------------------------------------------------
00018E16                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00018E16                            ; --------------------------------------------------------------------------------
00018E16                            
00018E16                            SME_k4ulR:	
00018E16 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00018E1A 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00018E1E 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00018E20 0001                       SME_k4ulrA:	dc.b 0, 1	
00018E22 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00018E28 0001                       SME_k4ulrC:	dc.b 0, 1	
00018E2A F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018E30 0001                       SME_k4ulr14:	dc.b 0, 1	
00018E32 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018E38 0001                       SME_k4ulr1C:	dc.b 0, 1	
00018E3A F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00018E40 0001                       SME_k4ulr24:	dc.b 0, 1	
00018E42 F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00018E48                            		even
00018E48                            		even
00018E48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E48                            Ani_ObjRing:
00018E48 0000                       		dc.w	.Ani0-Ani_ObjRing
00018E4A 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00018E50                            		even
00018E50                            ; =========================================================================================================================================================
00018E50                            		include	"Level/Objects/Explosion/Code.asm"	; Explosion object
00018E50                            ; =========================================================================================================================================================
00018E50                            ; Mighty The Armadillo in PRISM PARADISE
00018E50                            ; By Nat The Porcupine 2021
00018E50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E50                            ; Explosion object
00018E50                            ; =========================================================================================================================================================
00018E50 =00000003                  EXPLODE_ANI	EQU	3
00018E50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E50                            ObjBossExplode:
00018E50                            		playSnd	#sBomb, 2			; Play explosion sound
00018E50 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00018E56 6000                       		bra.s	ObjExplosion_Init		; Continue
00018E58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E58                            ObjExplosion:
00018E58                            		playSnd	#sBreakItem, 2			; Play explosion sound
00018E58 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00018E5E                            
00018E5E                            ObjExplosion_Init:
00018E5E 20BC 0000 0000             		move.l	#ObjExplosion_Main,oAddr(a0)	; Next routine
00018E64 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00018E6A 317C 86C0 000E             		move.w	#$86C0,oVRAM(a0)		; Tile properties
00018E70 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,oMap(a0)	; Mappings
00018E78                            	displaySprite	1,a0,a1,0			; Priority
00018E78 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018E7E 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018E82 3149 000A                M 	move.w	a1,odrawprev(a0)
00018E86 3348 0008                M 	move.w	a0,odrawnext(a1)
00018E8A 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018E8E                          M .no_232
00018E8E 117C 000C 0017             		move.b	#$C,oDrawW(a0)			; Sprite width
00018E94 117C 000C 001B             		move.b	#$C,oDrawH(a0)			; Sprite height
00018E9A 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Animation timer
00018EA0 4228 0010                  		clr.b	oFrame(a0)			; Mapping frame
00018EA4                            		
00018EA4                            ObjExplosion_Main:
00018EA4 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00018EA8 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00018EAA 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Reset animation timer
00018EB0 5228 0010                  		addq.b	#1,oFrame(a0)			; Next frame
00018EB4 0C28 0005 0010             		cmpi.b	#5,oFrame(a0)			; Has it reached the last frame?
00018EBA 6600                       		bne.s	.Display			; If not, branch
00018EBC 4EB8 1A06                  		jsr	DeleteObject.w
00018EC0                            		
00018EC0                            .Display:
00018EC0                            	nextObject
00018EC0 3068 0004                M 	movea.w	onext(a0),a0
00018EC4 2250                     M 	move.l	oaddr(a0),a1
00018EC6 4ED1                     M 	jmp	(a1)
00018EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EC8                            ; Data
00018EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EC8                            ArtKosM_Explosion:
00018EC8                            		incbin	"Level/Objects/Explosion/Art.kosm.bin"
0001935A                            		even
0001935A                            Map_ObjExplosion:
0001935A                            		include	"Level/Objects/Explosion/Mappings.asm"
0001935A                            ; --------------------------------------------------------------------------------
0001935A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001935A                            ; --------------------------------------------------------------------------------
0001935A                            
0001935A                            SME_PS_OI:	
0001935A 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
0001935E 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
00019362 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
00019364 0001                       SME_PS_OI_A:	dc.b 0, 1	
00019366 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
0001936C 0001                       SME_PS_OI_12:	dc.b 0, 1	
0001936E F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
00019374 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00019376 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
0001937C 0004                       SME_PS_OI_22:	dc.b 0, 4	
0001937E EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
00019384 EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
0001938A 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00019390 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00019396 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00019398 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
0001939E EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
000193A4 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
000193AA FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
000193B0                            		even
000193B0                            		even
000193B0                            ; =========================================================================================================================================================
000193B0                            		include	"Level/Objects/Water Surface/Code.asm"	; Water surface object
000193B0                            ; =========================================================================================================================================================
000193B0                            ; Mighty The Armadillo in PRISM PARADISE
000193B0                            ; By Nat The Porcupine 2021
000193B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000193B0                            ; Water surface object
000193B0                            ; =========================================================================================================================================================
000193B0                            		rsset	oLvlSSTs
000193B0 =00000030                  oSurfPause	rs.b	1			; Animation stop flag
000193B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000193B0                            ObjWaterSurface:
000193B0 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,oAddr(a0)	; Next routine
000193B6 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,oMap(a0)	; Mappings
000193BE 317C 8690 000E             		move.w	#$8690,oVRAM(a0)		; Tile properties
000193C4 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
000193CA                            	displaySprite	0,a0,a1,0			; Priority
000193CA 317C BE5A 0008           M 	move.w	#rdispinput+(0*dsize),odrawnext(a0)
000193D0 3278 BE64                M 	move.w	rdispinput+dprev+(0*dsize).w,a1
000193D4 3149 000A                M 	move.w	a1,odrawprev(a0)
000193D8 3348 0008                M 	move.w	a0,odrawnext(a1)
000193DC 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
000193E0                          M .no_234
000193E0 117C 0080 0017             		move.b	#$80,oDrawW(a0)			; Sprite width
000193E6 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
000193EC                            
000193EC                            ObjWaterSurface_Main:
000193EC 3238 F8F6                  		move.w	rWaterLvl.w,d1		; Get water height
000193F0 5D41                       		subq.w	#6,d1				; Shift it
000193F2 3141 0018                  		move.w	d1,oYPos(a0)			; Set Y position
000193F6                            
000193F6 4A28 0030                  		tst.b	oSurfPause(a0)			; Is the animation paused?
000193FA 6600                       		bne.s	.ChkUnpause			; If so, branch
000193FC 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
00019402 6700                       		beq.s	.Animate			; If not, branch
00019404 5628 0010                  		addq.b	#3,oFrame(a0)			; Use different frames
00019408 50E8 0030                  		st	oSurfPause(a0)			; Pause the animation
0001940C 6000                       		bra.s	.Animate			; Continue
0001940E                            
0001940E                            .ChkUnpause:
0001940E 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game paused?
00019412 6600                       		bne.s	.Animate			; If so, branch
00019414 4228 0030                  		clr.b	oSurfPause(a0)			; Resume animation
00019418 5728 0010                  		subq.b	#3,oFrame(a0)			; Use normal frames
0001941C                            
0001941C                            .Animate:
0001941C 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
00019420 7200                       		moveq	#0,d1
00019422 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation script frame
00019426 1171 1000 0010             		move.b	(a1,d1.w),oFrame(a0)		; Set mapping frame
0001942C 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next frame in animation script
00019430 0228 003F 0022             		andi.b	#$3F,oAniFrame(a0)		; Loop in necessary
00019436                            	nextObject
00019436 3068 0004                M 	movea.w	onext(a0),a0
0001943A 2250                     M 	move.l	oaddr(a0),a1
0001943C 4ED1                     M 	jmp	(a1)
0001943E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001943E                            .AniScript:
0001943E 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0001944E 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
0001945E 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
0001946E 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0001947E 00                         		even
0001947E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001947E                            ; Data
0001947E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001947E                            Map_ObjWaterSurface:
0001947E                            		include	"Level/Objects/Water Surface/Mappings.asm"
0001947E                            MapConv_obj1B:
0001947E 0000                       	dc.w	byte_11178-MapConv_obj1B
00019480 0000                       	dc.w	byte_11188-MapConv_obj1B
00019482 0000                       	dc.w	byte_11198-MapConv_obj1B
00019484 0000                       	dc.w	byte_111A8-MapConv_obj1B
00019486 0000                       	dc.w	byte_111C7-MapConv_obj1B
00019488 0000                       	dc.w	byte_111E6-MapConv_obj1B
0001948A                            
0001948A 0003                       byte_11178:	dc.w 3
0001948C FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00019492 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00019498 FD0D 0000 0020             	dc.w $FD0D, 0, $20
0001949E                            
0001949E 0003                       byte_11188:	dc.w 3
000194A0 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000194A6 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000194AC FD0D 0008 0020             	dc.w $FD0D, 8, $20
000194B2                            
000194B2 0003                       byte_11198:	dc.w 3
000194B4 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000194BA FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000194C0 FD0D 0800 0020             	dc.w $FD0D, $800, $20
000194C6                            
000194C6 0006                       byte_111A8:	dc.w 6
000194C8 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
000194CE FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
000194D4 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
000194DA FD0D 0000 0000             	dc.w $FD0D, 0, 0
000194E0 FD0D 0000 0020             	dc.w $FD0D, 0, $20
000194E6 FD0D 0000 0040             	dc.w $FD0D, 0, $40
000194EC                            
000194EC 0006                       byte_111C7:	dc.w 6
000194EE FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000194F4 FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
000194FA FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00019500 FD0D 0008 0000             	dc.w $FD0D, 8, 0
00019506 FD0D 0008 0020             	dc.w $FD0D, 8, $20
0001950C FD0D 0008 0040             	dc.w $FD0D, 8, $40
00019512                            
00019512 0006                       byte_111E6:	dc.w 6
00019514 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
0001951A FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
00019520 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00019526 FD0D 0800 0000             	dc.w $FD0D, $800, 0
0001952C FD0D 0800 0020             	dc.w $FD0D, $800, $20
00019532 FD0D 0800 0040             	dc.w $FD0D, $800, $40
00019538                            
00019538                            	even
00019538                            		even
00019538                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019538                            ArtKosM_WaterSurface:
00019538                            		incbin	"Level/Objects/Water Surface/Art.kosm.bin"
00019692                            		even
00019692                            ; =========================================================================================================================================================
00019692                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019692                            		include	"Level/Objects/Monitor/Code.asm"	; Monitor object
00019692                            ; =========================================================================================================================================================
00019692                            ; Mighty The Armadillo in PRISM PARADISE
00019692                            ; By Nat The Porcupine 2021
00019692                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019692                            ; Monitor object
00019692                            ; =========================================================================================================================================================
00019692                            		rsset	oLvlSSTs
00019692 =00000030                  oMonFall	rs.b	1				; Fall flag
00019692                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019692                            ObjMonitor:
00019692 20BC 0000 0000             		move.l	#ObjMonitorMain,oAddr(a0)
00019698 117C 000E 002D             		move.b	#$E,oColH(a0)
0001969E 117C 000E 002C             		move.b	#$E,oColW(a0)
000196A4 217C 0000 0000 0010        		move.l	#Map_ObjMonitor,oMap(a0)
000196AC 317C 0588 000E             		move.w	#$588,oVRAM(a0)
000196B2 117C 0004 000D             		move.b	#4,oRender(a0)
000196B8                            	displaySprite	3,a0,a1,0			; Priority
000196B8 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
000196BE 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
000196C2 3149 000A                M 	move.w	a1,odrawprev(a0)
000196C6 3348 0008                M 	move.w	a0,odrawnext(a1)
000196CA 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
000196CE                          M .no_236
000196CE 117C 000F 0017             		move.b	#$F,oDrawW(a0)
000196D4 117C 000F 001B             		move.b	#$F,oDrawH(a0)
000196DA 3028 0026                  		move.w	oRespawn(a0),d0
000196DE 6700                       		beq.s	ObjMonitorNotBroken
000196E0 3440                       		movea.w	d0,a2
000196E2 0812 0000                  		btst	#0,(a2)				; has monitor been broken?
000196E6 6700                       		beq.s	ObjMonitorNotBroken		; if not, branch
000196E8 117C 0007 0010             		move.b	#7,oFrame(a0)		; use broken monitor frame
000196EE 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
000196F4                            	nextObject
000196F4 3068 0004                M 	movea.w	onext(a0),a0
000196F8 2250                     M 	move.l	oaddr(a0),a1
000196FA 4ED1                     M 	jmp	(a1)
000196FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000196FC                            ObjMonitorNotBroken:
000196FC 117C 0006 002A             		move.b	#6,oColType(a0)
00019702 1168 0024 0020             		move.b	oSubtype(a0),oAni(a0)
00019708                            
00019708                            ObjMonitorMain:
00019708 6100                       		bsr.s	ObjMonitorFall
0001970A 323C 0019                  		move.w	#$19,d1
0001970E 343C 0010                  		move.w	#$10,d2
00019712 3602                       		move.w	d2,d3
00019714 3828 0014                  		move.w	oXPos(a0),d4
00019718 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
0001971C 6100                       		bsr.s	SolidObject_Monitor
0001971E                            
0001971E 3038 F8C2                  		move.w	rMaxCamY.w,d0
00019722 0640 00E0                  		addi.w	#$E0,d0
00019726 B068 0018                  		cmp.w	oYPos(a0),d0
0001972A 6D00                       		blt.s	ObjMonitorDelete
0001972C                            
0001972C 4EB8 49DC                  		jsr	AddToColResponse
00019730 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
00019734 4EB8 1BFA                  		jsr	AnimateObject.w
00019738 4EB8 1FB8                  		jsr	CheckObjActive.w
0001973C                            	nextObject
0001973C 3068 0004                M 	movea.w	onext(a0),a0
00019740 2250                     M 	move.l	oaddr(a0),a1
00019742 4ED1                     M 	jmp	(a1)
00019744                            
00019744                            ObjMonitorDelete:
00019744 4EB8 1A06                  		jsr	DeleteObject.w
00019748                            	nextObject
00019748 3068 0004                M 	movea.w	onext(a0),a0
0001974C 2250                     M 	move.l	oaddr(a0),a1
0001974E 4ED1                     M 	jmp	(a1)
00019750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019750                            ObjMonitorAnimate:
00019750 0C28 0007 0010             		cmpi.b	#7,oFrame(a0)
00019756 6500                       		bcs.s	.NotBroken
00019758 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
0001975E                            
0001975E                            .NotBroken:
0001975E 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
00019762 4EB8 1BFA                  		jsr	AnimateObject.w
00019766                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019766                            ObjMonitorCheckActive:
00019766 4EB8 1FB8                  		jsr	CheckObjActive.w
0001976A                            	nextObject
0001976A 3068 0004                M 	movea.w	onext(a0),a0
0001976E 2250                     M 	move.l	oaddr(a0),a1
00019770 4ED1                     M 	jmp	(a1)
00019772                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019772                            ObjMonitorFall:
00019772 1028 0030                  		move.b	oMonFall(a0),d0
00019776 6700                       		beq.s	.End
00019778 4EB8 1CFA                  		jsr	ObjectMoveAndFall.w
0001977C 4A68 001E                  		tst.w	oYVel(a0)
00019780 6B00                       		bmi.s	.End
00019782 4EB8 2FC2                  		jsr	ObjCheckFloorDist
00019786 4A41                       		tst.w	d1
00019788 6700                       		beq.s	.InGround
0001978A 6A00                       		bpl.s	.End
0001978C                            
0001978C                            .InGround:
0001978C D368 0018                  		add.w	d1,oYPos(a0)
00019790 4268 001E                  		clr.w	oYVel(a0)
00019794 4228 0030                  		clr.b	oMonFall(a0)
00019798                            
00019798                            .End:
00019798 4E75                       		rts
0001979A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001979A                            SolidObject_Monitor:
0001979A 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
000197A0 6600                       		bne.s	ObjMonitorChkOverEdge
000197A2 0C29 0002 0020             		cmpi.b	#2,oAni(a1)
000197A8 6700                       		beq.s	.End
000197AA 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)		; check if in drowning animation
000197B0 6600                       		bne.s	.SetSolid
000197B2                            
000197B2                            .End:
000197B2 4E75                       		rts
000197B4                            
000197B4                            .SetSolid:
000197B4 4EF8 450E                  		jmp	SolidObject_ChkCollision
000197B8                            
000197B8                            ObjMonitorChkOverEdge:
000197B8 3401                       		move.w	d1,d2
000197BA D442                       		add.w	d2,d2
000197BC 0829 0001 0028             		btst	#1,oStatus(a1)
000197C2 6600                       		bne.s	.NotOnMonitor
000197C4 3029 0014                  		move.w	oXPos(a1),d0
000197C8 9068 0014                  		sub.w	oXPos(a0),d0
000197CC D041                       		add.w	d1,d0
000197CE 6B00                       		bmi.s	.NotOnMonitor
000197D0 B042                       		cmp.w	d2,d0
000197D2 6500                       		blo.s	ObjMonitorCharStandOn
000197D4                            
000197D4                            .NotOnMonitor:
000197D4 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)
000197DA 08E9 0001 0028             		bset	#1,oStatus(a1)
000197E0 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)
000197E6 7800                       		moveq	#0,d4
000197E8 4E75                       		rts
000197EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197EA                            ObjMonitorCharStandOn:
000197EA 3404                       		move.w	d4,d2
000197EC 4EB8 4838                  		jsr	PlayerMoveOnPtfm
000197F0 7800                       		moveq	#0,d4
000197F2 4E75                       		rts
000197F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197F4                            ObjMonitorBreakOpen:
000197F4                            		playSnd	#sBreakItem, 2			; Play destroy sound
000197F4 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
000197FA                            		
000197FA 1028 0028                  		move.b	oStatus(a0),d0
000197FE 0200 0028                  		andi.b	#cStand|cPush,d0
00019802 6700                       		beq.s	ObjMonitorSpawnIcon
00019804 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019808 0229 00D7 0028             		andi.b	#$D7,oStatus(a1)
0001980E 0029 0002 0028             		ori.b	#2,oStatus(a1)
00019814                            
00019814                            ObjMonitorSpawnIcon:
00019814 4228 0028                  		clr.b	oStatus(a0)
00019818 117C 0000 002A             		move.b	#0,oColType(a0)
0001981E 4EB8 19B0                  		jsr	FindFreeObj.w
00019822 6700                       		beq.s	.SkipIconCreation
00019824 22BC 0000 0000             		move.l	#ObjMonitorContents,oAddr(a1)		; load monitor contents	object
0001982A 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00019830 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00019836 1368 0020 0020             		move.b	oAni(a0),oAni(a1)
0001983C 1368 000D 000D             		move.b	oRender(a0),oRender(a1)
00019842 1368 0028 0028             		move.b	oStatus(a0),oStatus(a1)
00019848                            
00019848                            .SkipIconCreation:
00019848 4EB8 19B0                  		jsr	FindFreeObj.w
0001984C 6700                       		beq.s	.SkipExplosionCreation
0001984E 22BC 0001 8E58             		move.l	#ObjExplosion,oAddr(a1)			; load explosion object
00019854 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0001985A 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00019860                            
00019860                            .SkipExplosionCreation:
00019860 3028 0026                  		move.w	oRespawn(a0),d0
00019864 6700                       		beq.s	.NotRemembered
00019866 3440                       		movea.w	d0,a2
00019868 08D2 0000                  		bset	#0,(a2)
0001986C                            
0001986C                            .NotRemembered:
0001986C 117C 0006 0020             		move.b	#6,oAni(a0)
00019872 20BC 0001 9750             		move.l	#ObjMonitorAnimate,oAddr(a0)
00019878                            	nextObject
00019878 3068 0004                M 	movea.w	onext(a0),a0
0001987C 2250                     M 	move.l	oaddr(a0),a1
0001987E 4ED1                     M 	jmp	(a1)
00019880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019880                            ; Contents of monitor object
00019880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019880                            ObjMonitorContents:
00019880 7000                       		moveq	#0,d0
00019882 1028 0025                  		move.b	oRoutine(a0),d0
00019886 4EBB 0000                  		jsr	ObjMonitorContents_Index(pc,d0.w)
0001988A                            	nextObject
0001988A 3068 0004                M 	movea.w	onext(a0),a0
0001988E 2250                     M 	move.l	oaddr(a0),a1
00019890 4ED1                     M 	jmp	(a1)
00019892                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019892                            ObjMonitorContents_Index:
00019892 6000                       		bra.s	ObjMonitorContents_Main
00019894 6000                       		bra.s	ObjMonitorContents_Move
00019896 6000 0000                  		bra.w	ObjMonitorContents_Delete
0001989A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001989A                            ObjMonitorContents_Main:
0001989A 5428 0025                  		addq.b	#2,oRoutine(a0)
0001989E 317C 8588 000E             		move.w	#$8588,oVRAM(a0)
000198A4 117C 0024 000D             		move.b	#$24,oRender(a0)
000198AA                            	displaySprite	3,a0,a1,0			; Priority
000198AA 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
000198B0 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
000198B4 3149 000A                M 	move.w	a1,odrawprev(a0)
000198B8 3348 0008                M 	move.w	a0,odrawnext(a1)
000198BC 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
000198C0                          M .no_244
000198C0 117C 0008 0017             		move.b	#8,oDrawW(a0)
000198C6 117C 0008 001B             		move.b	#8,oDrawH(a0)
000198CC 317C FD00 001E             		move.w	#-$300,oYVel(a0)
000198D2 7000                       		moveq	#0,d0
000198D4 1028 0020                  		move.b	oAni(a0),d0
000198D8 5200                       		addq.b	#1,d0
000198DA 227C 0000 0000             		movea.l	#Map_ObjMonitor,a1
000198E0 D000                       		add.b	d0,d0
000198E2 D2F1 0000                  		adda.w	(a1,d0.w),a1
000198E6 5449                       		addq.w	#2,a1
000198E8 2149 0010                  		move.l	a1,oMap(a0)
000198EC                            
000198EC 1028 0020                  		move.b	oAni(a0),d0
000198F0 5200                       		addq.b	#1,d0
000198F2 1140 0010                  		move.b	d0,oFrame(a0)
000198F6                            
000198F6                            ObjMonitorContents_Move:
000198F6 4A68 001E                  		tst.w	oYVel(a0)			; is object moving?
000198FA 6A00 0000                  		bpl.w	ObjMonitorContents_GetType	; if not, branch
000198FE 4EB8 1CE0                  		jsr	ObjectMove.w
00019902 0668 0018 001E             		addi.w	#$18,oYVel(a0)			; reduce object	speed
00019908 4E75                       		rts
0001990A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001990A                            ObjMonitorContents_GetType:
0001990A 5428 0025                  		addq.b	#2,oRoutine(a0)
0001990E 117C 001D 0023             		move.b	#29,oAniTimer(a0)
00019914 1028 0020                  		move.b	oAni(a0),d0
00019918                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019918 0C00 0001                  		cmpi.b	#1,d0
0001991C 6600                       		bne.s	.ChkRings
0001991E                            		push.l	a0
0001991E 2F08                     M 	move.l	a0,-(sp)
00019920 2448                       		movea.l	a0,a2
00019922 3078 F86C                  		movea.w	rPlayer1Addr.w,a0
00019926 4EB9 0000 BDFE             		jsr	ObjMighty_GetHurt
0001992C                            		pop.l	a0
0001992C 205F                     M 	move.l	(sp)+,a0
0001992E 4E75                       		rts
00019930                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019930                            .ChkRings:
00019930 0C00 0002                  		cmpi.b	#2,d0
00019934 6600                       		bne.s	.Display
00019936 0678 000A F3D4             		addi.w	#10,rRings.w 				; add 10 rings to the number of rings you have
0001993C 0038 0001 F8F3             		ori.b	#1,rUpdateRings.w 			; update the ring counter
00019942                            		playSnd	#sRing, 2				; Play ring sound
00019942 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00019948                            
00019948                            .Display:
00019948 4E75                       		rts
0001994A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001994A                            ObjMonitorContents_Delete:
0001994A 5328 0023                  		subq.b	#1,oAniTimer(a0)
0001994E 6A00                       		bpl.s	.NoDelete
00019950 4EF8 1A06                  		jmp	DeleteObject.w
00019954                            
00019954                            .NoDelete:
00019954 4E75                       		rts
00019956                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019956                            ; Data
00019956                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019956                            ArtKosM_Monitor:
00019956                            		incbin	"Level/Objects/Monitor/Art.kosm.bin"
00019C78 00                         		even
00019C78                            Map_ObjMonitor:
00019C78                            		include	"Level/Objects/Monitor/Mappings.asm"
00019C78                            ; --------------------------------------------------------------------------------
00019C78                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019C78                            ; --------------------------------------------------------------------------------
00019C78                            
00019C78                            SME_7TKK1:	
00019C78 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00019C7C 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00019C80 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
00019C84 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00019C88 0001                       SME_7TKK1_10:	dc.b 0, 1	
00019C8A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019C90 0002                       SME_7TKK1_18:	dc.b 0, 2	
00019C92 F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00019C98 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019C9E 0002                       SME_7TKK1_26:	dc.b 0, 2	
00019CA0 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00019CA6 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CAC 0002                       SME_7TKK1_34:	dc.b 0, 2	
00019CAE F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
00019CB4 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CBA 0002                       SME_7TKK1_42:	dc.b 0, 2	
00019CBC F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
00019CC2 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CC8 0002                       SME_7TKK1_50:	dc.b 0, 2	
00019CCA F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
00019CD0 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CD6 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00019CD8 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00019CDE EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CE4 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00019CE6 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
00019CEC                            		even
00019CEC                            Ani_ObjMonitor:
00019CEC                            		include	"Level/Objects/Monitor/Animations.asm"
00019CEC                            ; ---------------------------------------------------------------------------
00019CEC                            ; Animation script - monitors
00019CEC                            ; ---------------------------------------------------------------------------
00019CEC 0000                       		dc.w .Static-Ani_ObjMonitor
00019CEE 0000                       		dc.w .Eggman-Ani_ObjMonitor
00019CF0 0000                       		dc.w .Rings-Ani_ObjMonitor
00019CF2 0000                       		dc.w .Shoes-Ani_ObjMonitor
00019CF4 0000                       		dc.w .Shield-Ani_ObjMonitor
00019CF6 0000                       		dc.w .Stars-Ani_ObjMonitor
00019CF8 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00019CFA 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00019CFF 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00019D08 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00019D11 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
00019D1A 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00019D23 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
00019D2C 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00019D34 00                         		even
00019D34                            ; =========================================================================================================================================================
00019D34                            		include	"Level/Objects/Spikes/Code.asm"		; Spike object
00019D34                            ; ===========================================================================
00019D34                            ; Mighty The Armadillo in PRISM PARADISE
00019D34                            ; By Nat The Porcupine 2021
00019D34                            ; ---------------------------------------------------------------------------
00019D34                            ; Spike object
00019D34                            ; ===========================================================================
00019D34                            		rsset	oLvlSSTs
00019D34 =00000030                  oSpikeX		rs.w	1
00019D34 =00000032                  oSpikeY		rs.w	1
00019D34 =00000034                  oSpkMvOff	rs.w	1
00019D34 =00000036                  oSpkMvState	rs.w	1
00019D34 =00000038                  oSpkMvTime	rs.w	1
00019D34                            ; ===========================================================================
00019D34                            ObjSpike:
00019D34 7000                       		moveq	#0,d0
00019D36 1028 0025                  		move.b	oRoutine(a0),d0
00019D3A 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00019D3E                            	nextObject
00019D3E 3068 0004                M 	movea.w	onext(a0),a0
00019D42 2250                     M 	move.l	oaddr(a0),a1
00019D44 4ED1                     M 	jmp	(a1)
00019D46                            ; ===========================================================================
00019D46                            ObjSpike_Index:
00019D46 6000 0000                  		bra.w ObjSpike_Init
00019D4A 6000 0000                  		bra.w ObjSpike_Upright
00019D4E 6000 0000                  		bra.w ObjSpike_Sideways
00019D52 6000 0000                  		bra.w ObjSpike_UpsideDown
00019D56                            ; ===========================================================================
00019D56                            ;ObjSpike_InitData:
00019D56                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00019D56                            ;		dc.b $10,$10	; 2	- Sideways spikes
00019D56                            ; ===========================================================================
00019D56                            ObjSpike_Init:
00019D56 5828 0025                  		addq.b	#4,oRoutine(a0)
00019D5A 217C 0000 0000 0010        		move.l	#Map_ObjSpike,oMap(a0)
00019D62 317C 06A8 000E             		move.w	#$6A8,oVRAM(a0)
00019D68 0028 0004 000D             		ori.b	#4,oRender(a0)
00019D6E                            	displaySprite	4,a0,a1,0			; Priority
00019D6E 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
00019D74 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
00019D78 3149 000A                M 	move.w	a1,odrawprev(a0)
00019D7C 3348 0008                M 	move.w	a0,odrawnext(a1)
00019D80 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00019D84                          M .no_249
00019D84 1028 0024                  		move.b	oSubtype(a0),d0
00019D88 0228 000F 0024             		andi.b	#$F,oSubtype(a0)
00019D8E 0240 00F0                  		andi.w	#$F0,d0
00019D92 7210                       		moveq	#$10,d1
00019D94 1141 0017                  		move.b	d1,oDrawW(a0)
00019D98 1141 002C                  		move.b	d1,oColW(a0)
00019D9C 1141 001B                  		move.b	d1,oDrawH(a0)
00019DA0 1141 002D                  		move.b	d1,oColH(a0)
00019DA4 E848                       		lsr.w	#4,d0
00019DA6 1140 0010                  		move.b	d0,oFrame(a0)
00019DAA 0C00 0001                  		cmpi.b	#1,d0
00019DAE 6600                       		bne.s	.ChkUpsideDown
00019DB0 5828 0025                  		addq.b	#4,oRoutine(a0)
00019DB4 317C 06AC 000E             		move.w	#$6AC,oVRAM(a0)
00019DBA                            
00019DBA                            .ChkUpsideDown:
00019DBA 0828 0001 0028             		btst	#1,oStatus(a0)
00019DC0 6700                       		beq.s	.SavePos
00019DC2 117C 000C 0025             		move.b	#$C,oRoutine(a0)
00019DC8                            
00019DC8                            .SavePos:
00019DC8 3168 0014 0030             		move.w	oXPos(a0),oSpikeX(a0)
00019DCE 3168 0018 0032             		move.w	oYPos(a0),oSpikeY(a0)
00019DD4                            
00019DD4 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00019DD8 0C28 0001 0010             		cmpi.b	#1,oFrame(a0)		; is object type $1x ?
00019DDE 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00019DE0                            ; ===========================================================================
00019DE0                            ; Upright spikes
00019DE0                            ; ===========================================================================
00019DE0                            ObjSpike_Upright:
00019DE0 6100 0000                  		bsr.w	MoveSpikes
00019DE4 7200                       		moveq	#0,d1
00019DE6 1228 0017                  		move.b	oDrawW(a0),d1
00019DEA 0641 000B                  		addi.w	#$B,d1
00019DEE 7400                       		moveq	#0,d2
00019DF0 1428 001B                  		move.b	oDrawH(a0),d2
00019DF4 3602                       		move.w	d2,d3
00019DF6 5243                       		addq.w	#1,d3
00019DF8 3828 0014                  		move.w	oXPos(a0),d4
00019DFC 4EB8 43BC                  		jsr	SolidObject
00019E00 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
00019E06 6700                       		beq.s	ObjSpike_UprightEnd
00019E08 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019E0C 6100 0000                  		bsr.w	Touch_ChkHurt2
00019E10                            
00019E10                            ObjSpike_UprightEnd:
00019E10 3028 0030                  		move.w	oSpikeX(a0),d0
00019E14 4EF8 1FB8                  		jmp	CheckObjActive.w
00019E18                            ; ===========================================================================
00019E18                            ; Sideways spikes
00019E18                            ; ===========================================================================
00019E18                            ObjSpike_Sideways:
00019E18 3F28 0014                  		move.w	oXPos(a0),-(sp)	
00019E1C 6100 0000                  		bsr.w	MoveSpikes
00019E20 7200                       		moveq	#0,d1
00019E22 1228 0017                  		move.b	oDrawW(a0),d1
00019E26 0641 000B                  		addi.w	#$B,d1
00019E2A 7400                       		moveq	#0,d2
00019E2C 1428 001B                  		move.b	oDrawH(a0),d2
00019E30 3602                       		move.w	d2,d3
00019E32 5243                       		addq.w	#1,d3
00019E34 381F                       		move.w	(sp)+,d4
00019E36 4EB8 43BC                  		jsr	SolidObject
00019E3A 0806 0000                  		btst	#cTouchSideBit,d6
00019E3E 6700                       		beq.s	ObjSpike_SidewaysEnd
00019E40 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019E44 6100 0000                  		bsr.w	Touch_ChkHurt2
00019E48                            
00019E48                            ObjSpike_SidewaysEnd:
00019E48 3028 0030                  		move.w	oSpikeX(a0),d0
00019E4C 4EF8 1FB8                  		jmp	CheckObjActive.w
00019E50                            ; ===========================================================================
00019E50                            ; Upside down spikes
00019E50                            ; ===========================================================================
00019E50                            ObjSpike_UpsideDown:
00019E50 6100 0000                  		bsr.w	MoveSpikes
00019E54 7200                       		moveq	#0,d1
00019E56 1228 0017                  		move.b	oDrawW(a0),d1
00019E5A 0641 000B                  		addi.w	#$B,d1
00019E5E 7400                       		moveq	#0,d2
00019E60 1428 001B                  		move.b	oDrawH(a0),d2
00019E64 3602                       		move.w	d2,d3
00019E66 5243                       		addq.w	#1,d3
00019E68 3828 0014                  		move.w	oXPos(a0),d4
00019E6C 4EB8 43BC                  		jsr	SolidObject
00019E70 0806 0002                  		btst	#cTouchBtmBit,d6
00019E74 6700                       		beq.s	ObjSpike_UpsideDownEnd
00019E76 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019E7A 6100 0000                  		bsr.w	Touch_ChkHurt2
00019E7E                            
00019E7E                            ObjSpike_UpsideDownEnd:
00019E7E 3028 0030                  		move.w	oSpikeX(a0),d0
00019E82 4EF8 1FB8                  		jmp	CheckObjActive.w
00019E86                            ; ===========================================================================
00019E86                            Touch_ChkHurt2:
00019E86 4A29 0042                  		tst.b	oInvulTime(a1)			; is Sonic invincible?
00019E8A 6600                       		bne.s	.End				; if yes, branch
00019E8C 0C29 0008 0025             		cmpi.b	#8,oRoutine(a1)
00019E92 6700                       		beq.s	.End
00019E94 2629 0018                  		move.l	oYPos(a1),d3
00019E98 3029 001E                  		move.w	oYVel(a1),d0
00019E9C 48C0                       		ext.l	d0
00019E9E E180                       		asl.l	#8,d0
00019EA0 9680                       		sub.l	d0,d3
00019EA2 2343 0018                  		move.l	d3,oYPos(a1)
00019EA6 2448                       		movea.l	a0,a2
00019EA8 2049                       		movea.l	a1,a0
00019EAA 4EB9 0000 BDFE             		jsr	ObjMighty_GetHurt
00019EB0 204A                       		movea.l	a2,a0
00019EB2                            
00019EB2                            .End:
00019EB2 4E75                       		rts
00019EB4                            ; ===========================================================================
00019EB4                            MoveSpikes:	
00019EB4 7000                       		moveq	#0,d0
00019EB6 1028 0024                  		move.b	oSubtype(a0),d0
00019EBA D040                       		add.w	d0,d0
00019EBC 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00019EC0                            ; ===========================================================================
00019EC0                            MoveSpikes_Behaviors:
00019EC0 6000                       		bra.s MoveSpikes_Still
00019EC2 6000                       		bra.s MoveSpikes_Vertical
00019EC4 6000                       		bra.s MoveSpikes_Horizontal
00019EC6                            ; ===========================================================================
00019EC6                            MoveSpikes_Still:
00019EC6 4E75                       		rts			; don't move the object
00019EC8                            ; ===========================================================================
00019EC8                            MoveSpikes_Vertical:
00019EC8 6100 0000                  		bsr.w	MoveSpikes_Delay
00019ECC 7000                       		moveq	#0,d0
00019ECE 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019ED2 D068 0032                  		add.w	oSpikeY(a0),d0
00019ED6 3140 0018                  		move.w	d0,oYPos(a0)	; move the object vertically
00019EDA 4E75                       		rts
00019EDC                            ; ===========================================================================
00019EDC                            MoveSpikes_Horizontal:
00019EDC 6100 0000                  		bsr.w	MoveSpikes_Delay
00019EE0 7000                       		moveq	#0,d0
00019EE2 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019EE6 D068 0030                  		add.w	oSpikeX(a0),d0
00019EEA 3140 0014                  		move.w	d0,oXPos(a0)	; move the object horizontally
00019EEE 4E75                       		rts
00019EF0                            ; ===========================================================================
00019EF0                            MoveSpikes_Delay:
00019EF0 4A68 0038                  		tst.w	oSpkMvTime(a0)		; is time delay	= zero?
00019EF4 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00019EF6 5368 0038                  		subq.w	#1,oSpkMvTime(a0)	; subtract 1 from time delay
00019EFA 6600                       		bne.s	locret_CFE6
00019EFC 4A28 000D                  		tst.b	oRender(a0)
00019F00 6A00                       		bpl.s	locret_CFE6
00019F02                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00019F02 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00019F08 6000                       		bra.s	locret_CFE6
00019F0A                            ; ===========================================================================
00019F0A                            MoveSpikes_ChkDir:
00019F0A 4A68 0036                  		tst.w	oSpkMvState(a0)
00019F0E 6700                       		beq.s	MoveSpikes_Retract
00019F10 0468 0800 0034             		subi.w	#$800,oSpkMvOff(a0)
00019F16 6400                       		bcc.s	locret_CFE6
00019F18 317C 0000 0034             		move.w	#0,oSpkMvOff(a0)
00019F1E 317C 0000 0036             		move.w	#0,oSpkMvState(a0)
00019F24 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019F2A 6000                       		bra.s	locret_CFE6
00019F2C                            ; ===========================================================================
00019F2C                            MoveSpikes_Retract:
00019F2C 0668 0800 0034             		addi.w	#$800,oSpkMvOff(a0)
00019F32 0C68 2000 0034             		cmpi.w	#$2000,oSpkMvOff(a0)
00019F38 6500                       		bcs.s	locret_CFE6
00019F3A 317C 2000 0034             		move.w	#$2000,oSpkMvOff(a0)
00019F40 317C 0001 0036             		move.w	#1,oSpkMvState(a0)
00019F46 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019F4C                            
00019F4C                            locret_CFE6:
00019F4C 4E75                       		rts
00019F4E                            ; ===========================================================================
00019F4E                            ; Spike object mappings
00019F4E                            ; ===========================================================================
00019F4E                            Map_ObjSpike:
00019F4E                            	include "Level/Objects/Spikes/Mappings.asm"
00019F4E                            ; --------------------------------------------------------------------------------
00019F4E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019F4E                            ; --------------------------------------------------------------------------------
00019F4E                            
00019F4E                            SME_5AG23:	
00019F4E 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00019F52 0004                       SME_5AG23_4:	dc.b 0, 4	
00019F54 F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
00019F5A F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00019F60 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
00019F66 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
00019F6C 0004                       SME_5AG23_1E:	dc.b 0, 4	
00019F6E F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
00019F74 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00019F7A 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
00019F80 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
00019F86                            		even
00019F86                            ; ===========================================================================
00019F86                            ArtKosM_SpikesN:
00019F86                            		incbin	"Level/Objects/Spikes/Art - Normal.kosm.bin"
00019FC6                            		even
00019FC6                            ; ===========================================================================
00019FC6                            ArtKosM_SpikesS:
00019FC6                            		incbin	"Level/Objects/Spikes/Art - Sideways.kosm.bin"
0001A008 00                         		even
0001A008                            ; ===========================================================================
0001A008                            		include	"Level/Objects/Spring/Code.asm"		; Spring object
0001A008                            ; =========================================================================================================================================================
0001A008                            ; Mighty The Armadillo in PRISM PARADISE
0001A008                            ; By Nat The Porcupine 2021
0001A008                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A008                            ; Spring object
0001A008                            ; =========================================================================================================================================================
0001A008                            		rsset	oLvlSSTs
0001A008 =00000030                  oSprSpd		rs.w	1				; Spring strength
0001A008                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A008                            ObjSpring:
0001A008 217C 0000 0000 0010        		move.l	#Map_ObjSpring,oMap(a0)		; Mappings
0001A010 317C 05BA 000E             		move.w	#$5BA,oVRAM(a0)			; Tile properties
0001A016 0028 0004 000D             		ori.b	#4,oRender(a0)			; Render flags
0001A01C 117C 0010 0017             		move.b	#$10,oDrawW(a0)			; Sprite width
0001A022 117C 0008 001B             		move.b	#8,oDrawH(a0)			; Sprite height
0001A028 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A02E                            	displaySprite	4,a0,a1,0			; Priority
0001A02E 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
0001A034 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
0001A038 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A03C 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A040 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0001A044                          M .no_251
0001A044                            		
0001A044 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A048 E648                       		lsr.w	#3,d0				; Turn into offset
0001A04A 0240 000E                  		andi.w	#$E,d0				; ''
0001A04E 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
0001A052                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A052                            .Subtypes:
0001A052 6000                       		bra.s .Init_Up				; Up
0001A054 6000                       		bra.s .Init_Horizontal			; Horizontal
0001A056 6000                       		bra.s .Init_Down			; Down
0001A058 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
0001A05A 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
0001A05C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A05C                            .Init_Horizontal:
0001A05C 117C 0002 0020             		move.b	#2,oAni(a0)			; Animation
0001A062 117C 0002 0010             		move.b	#2,oFrame(a0)			; Mapping frame
0001A068 317C 05CA 000E             		move.w	#$5CA,oVRAM(a0)			; Tile properties
0001A06E 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A074 117C 0010 001B             		move.b	#$10,oDrawH(a0)			; Sprite height
0001A07A 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A080 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,oAddr(a0)	; Next routine
0001A086 6000                       		bra.s	.Init_Common			; Continue
0001A088                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A088                            .Init_Down:
0001A088 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A08E 20BC 0000 0000             		move.l	#ObjSpring_Down,oAddr(a0)	; Next routine
0001A094 6000                       		bra.s	.Init_Common			; Continue
0001A096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A096                            .Init_DiagonallyUp:
0001A096 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A09C 117C 0004 0010             		move.b	#4,oFrame(a0)			; Map frame
0001A0A2 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A0A8 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,oAddr(a0); Next routine
0001A0AE 6000                       		bra.s	.Init_Common			; Continue
0001A0B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0B0                            .Init_DiagonallyDown:
0001A0B0 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A0B6 117C 0006 0010             		move.b	#6,oFrame(a0)			; Map frame
0001A0BC 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A0C2 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A0C8 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,oAddr(a0); Next routine
0001A0CE 6000                       		bra.s	.Init_Common			; Continue
0001A0D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0D0                            .Init_Up:
0001A0D0 20BC 0000 0000             		move.l	#ObjSpring_Up,oAddr(a0)		; Next routine
0001A0D6                            
0001A0D6                            .Init_Common:
0001A0D6 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A0DA 0240 0002                  		andi.w	#2,d0				; Turn into offset
0001A0DE 317B 0000 0030             		move.w	.Strengths(pc,d0.w),oSprSpd(a0)	; Get spring strength
0001A0E4 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
0001A0E8 6700                       		beq.s	.NotYellow			; If not, branch
0001A0EA 08E8 0005 000E             		bset	#5,oVRAM(a0)			; Make the spring yellow
0001A0F0                            
0001A0F0                            .NotYellow:
0001A0F0                            	nextObject
0001A0F0 3068 0004                M 	movea.w	onext(a0),a0
0001A0F4 2250                     M 	move.l	oaddr(a0),a1
0001A0F6 4ED1                     M 	jmp	(a1)
0001A0F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0F8                            .Strengths:
0001A0F8 F000                       		dc.w	-$1000				; Strength of red spring
0001A0FA F600                       		dc.w	-$A00				; Strength of yellow spring
0001A0FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0FC                            ObjSpring_Up:
0001A0FC 323C 001A                  		move.w	#27-1,d1			; Width
0001A100 343C 0008                  		move.w	#16/2,d2			; Height
0001A104 3602                       		move.w	d2,d3				; ''
0001A106 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A10A 4EB8 440C                  		jsr	SolidObject_Always		; Set object as solid
0001A10E 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the top of the of spring?
0001A114 6700                       		beq.s	.Display			; If not, branch
0001A116 6100                       		bsr.s	.Bounce				; Bounce the player up
0001A118                            
0001A118                            .Display:
0001A118 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A11C 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001A120 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display sprite
0001A124                            	nextObject
0001A124 3068 0004                M 	movea.w	onext(a0),a0
0001A128 2250                     M 	move.l	oaddr(a0),a1
0001A12A 4ED1                     M 	jmp	(a1)
0001A12C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A12C                            .Bounce:
0001A12C 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A132 5069 0018                  		addq.w	#8,oYPos(a1)			; Align player to spring
0001A136 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A13C 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A142 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A148 4229 0040                  		clr.b	oJumping(a1)			; Clear the player's jump flag
0001A14C 137C 0010 0020             		move.b	#$10,oAni(a1)			; Set the player's animation to the spring animation
0001A152 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A158                            		
0001A158 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A15C 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A15E 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A162                            
0001A162                            .ChkPath1:
0001A162 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A166 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A16A 6600                       		bne.s	.ChkPath2			; If not, branch
0001A16C 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A172 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A178                            
0001A178                            .ChkPath2:
0001A178 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A17C 6600                       		bne.s	.PlaySound			; If not, branch
0001A17E 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A184 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A18A                            
0001A18A                            .PlaySound:
0001A18A                            		playSnd	#sSpring, 2			; Play spring sound
0001A18A 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A190 4E75                       		rts
0001A192                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A192                            ObjSpring_Horizontal:
0001A192 323C 0013                  		move.w	#20-1,d1			; Width
0001A196 343C 000E                  		move.w	#28/2,d2			; Height
0001A19A 3602                       		move.w	d2,d3				; ''
0001A19C 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A1A0 4EB8 440C                  		jsr	SolidObject_Always		; Set object as solid
0001A1A4 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
0001A1A8 6700                       		beq.s	.Display			; If not, branch
0001A1AA 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001A1AE 3028 0014                  		move.w	oXPos(a0),d0			; Get which side of the spring the player is facing
0001A1B2 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001A1B6 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
0001A1B8 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
0001A1BC                            
0001A1BC                            .NoFlip:
0001A1BC 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
0001A1C0 6600                       		bne.s	.Display			; If not, branch
0001A1C2 6100                       		bsr.s	.Bounce				; Bounce the player
0001A1C4                            
0001A1C4                            .Display:
0001A1C4 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A1C8 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001A1CC 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display sprite
0001A1D0                            	nextObject
0001A1D0 3068 0004                M 	movea.w	onext(a0),a0
0001A1D4 2250                     M 	move.l	oaddr(a0),a1
0001A1D6 4ED1                     M 	jmp	(a1)
0001A1D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1D8                            .Bounce:	
0001A1D8 317C 0300 0020             		move.w	#$300,oAni(a0)			; Reset animation
0001A1DE 5069 0014                  		addq.w	#8,oXPos(a1)			; Align player to spring
0001A1E2 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)		; Set the player's X velocity
0001A1E8 08E9 0000 0028             		bset	#0,oStatus(a1)			; Make the player face the left
0001A1EE 0828 0000 0028             		btst	#0,oStatus(a0)			; Is this spring facing the left?
0001A1F4 6600                       		bne.s	.SetMoveLock			; If so, branch
0001A1F6 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Make the player face the right
0001A1FC 0469 0010 0014             		subi.w	#$10,oXPos(a1)			; Align player to spring
0001A202 4469 001C                  		neg.w	oXVel(a1)			; Move the player to the right
0001A206                            
0001A206                            .SetMoveLock:
0001A206 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Lock the player's movement for a bit
0001A20C 3369 001C 003A             		move.w	oXVel(a1),oGVel(a1)		; Set the player's ground velocity
0001A212                            		
0001A212 0829 0002 0028             		btst	#2,oStatus(a1)			; Is the player jumping?
0001A218 6600                       		bne.s	.ChkYStop			; If so, branch
0001A21A 4229 0020                  		clr.b	oAni(a1)			; Set the animation to the walking animation
0001A21E                            		
0001A21E                            .ChkYStop:
0001A21E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A222 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
0001A224 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's Y movement
0001A228                            
0001A228                            .ChkPath1:
0001A228 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A22C 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A230 6600                       		bne.s	.ChkPath2			; If not, branch
0001A232 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A238 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A23E                            
0001A23E                            .ChkPath2:
0001A23E 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A242 6600                       		bne.s	.PlaySound			; If not, branch
0001A244 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A24A 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A250                            
0001A250                            .PlaySound:
0001A250 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear "push" flags
0001A256 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001A25C                            		playSnd	#sSpring, 2			; Play spring sound
0001A25C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A262 4E75                       		rts
0001A264                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A264                            ObjSpring_Down:
0001A264 323C 0012                  		move.w	#19-1,d1			; Width
0001A268 343C 0008                  		move.w	#16/2,d2			; Height
0001A26C 3602                       		move.w	d2,d3				; ''
0001A26E 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A272 4EB8 440C                  		jsr	SolidObject_Always		; Set object as solid
0001A276 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
0001A27A 6600                       		bne.s	.Display			; If not, branch
0001A27C 6100                       		bsr.s	.Bounce				; Bounce the player
0001A27E                            
0001A27E                            .Display:
0001A27E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A282 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001A286 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display sprite
0001A28A                            	nextObject
0001A28A 3068 0004                M 	movea.w	onext(a0),a0
0001A28E 2250                     M 	move.l	oaddr(a0),a1
0001A290 4ED1                     M 	jmp	(a1)
0001A292                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A292                            .Bounce:
0001A292 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A298 5169 0018                  		subq.w	#8,oYPos(a1)			; Align player with the spring
0001A29C 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A2A2 4469 001E                  		neg.w	oYVel(a1)			; Move the player down
0001A2A6                            		
0001A2A6 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A2AA 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A2AC 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A2B0                            
0001A2B0                            .ChkPath1:
0001A2B0 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A2B4 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A2B8 6600                       		bne.s	.ChkPath2			; If not, branch
0001A2BA 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A2C0 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A2C6                            
0001A2C6                            .ChkPath2:
0001A2C6 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A2CA 6600                       		bne.s	.PlaySound			; If not, branch
0001A2CC 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A2D2 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A2D8                            
0001A2D8                            .PlaySound:
0001A2D8 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A2DE 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A2E4 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A2EA                            		playSnd	#sSpring, 2			; Play spring sound
0001A2EA 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A2F0 4E75                       		rts
0001A2F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A2F2                            ObjSpring_DiagonallyUp:
0001A2F2 323C 0019                  		move.w	#26-1,d1			; Width
0001A2F6 343C 0010                  		move.w	#32/2,d2			; Height
0001A2FA 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A2FE 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
0001A302 4EB8 445C                  		jsr	SlopedSolid			; Set object as a solid slope
0001A306                            		
0001A306 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the spring?
0001A30C 6700                       		beq.s	.End				; If not, branch
0001A30E 6100                       		bsr.s	.Bounce				; Bounce the player
0001A310                            
0001A310                            .End:
0001A310 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A314 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001A318 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display sprite
0001A31C                            	nextObject
0001A31C 3068 0004                M 	movea.w	onext(a0),a0
0001A320 2250                     M 	move.l	oaddr(a0),a1
0001A322 4ED1                     M 	jmp	(a1)
0001A324                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A324                            .Bounce:
0001A324 0828 0000 0028             		btst	#0,oStatus(a0)			; Is the spring facing left?
0001A32A 6600                       		bne.s	.FaceLeft			; If so, branch
0001A32C 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0001A330 5940                       		subq.w	#4,d0				; Subtract 4
0001A332 B069 0014                  		cmp.w	oXPos(a1),d0			; Is the player
0001A336 6500                       		blo.s	.DoBounce
0001A338 4E75                       		rts
0001A33A                            
0001A33A                            .FaceLeft:
0001A33A 3028 0014                  		move.w	oXPos(a0),d0
0001A33E 5840                       		addq.w	#4,d0
0001A340 B069 0014                  		cmp.w	oXPos(a1),d0
0001A344 6400                       		bhs.s	.DoBounce
0001A346 4E75                       		rts
0001A348                            
0001A348                            .DoBounce:
0001A348 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A34E 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A354 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A35A 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A35E 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A362 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A368 0828 0000 0028             		btst	#0,oStatus(a0)
0001A36E 6600                       		bne.s	.SetAni
0001A370 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A376 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A37C 4469 001C                  		neg.w	oXVel(a1)
0001A380                            
0001A380                            .SetAni:
0001A380 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A386 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A38C 137C 0010 0020             		move.b	#$10,oAni(a1)
0001A392 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A398                            
0001A398 1028 0024                  		move.b	oSubtype(a0),d0
0001A39C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A3A0 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A3A4 6600                       		bne.s	.ChkPath2			; If not, branch
0001A3A6 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A3AC 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A3B2                            
0001A3B2                            .ChkPath2:
0001A3B2 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A3B6 6600                       		bne.s	.PlaySound			; If not, branch
0001A3B8 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A3BE 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A3C4                            
0001A3C4                            .PlaySound:
0001A3C4                            		playSnd	#sSpring, 2			; Play spring sound
0001A3C4 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A3CA 4E75                       		rts
0001A3CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3CC                            .SlopeData:
0001A3CC 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
0001A3D3 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
0001A3DA 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
0001A3E1 FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
0001A3E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3E8                            ObjSpring_DiagonallyDown:
0001A3E8 323C 0019                  		move.w	#26-1,d1			; Width
0001A3EC 343C 0010                  		move.w	#32/2,d2
0001A3F0 3828 0014                  		move.w	oXPos(a0),d4
0001A3F4 45FA 0000                  		lea	.SlopeData(pc),a2
0001A3F8 4EB8 445C                  		jsr	SlopedSolid			; Set object as a solid slope
0001A3FC 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
0001A400 6600                       		bne.s	.End				; If not, branch
0001A402 6100                       		bsr.s	.Bounce				; Bounce the player
0001A404                            
0001A404                            .End:
0001A404 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A408 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001A40C 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display sprite
0001A410                            	nextObject
0001A410 3068 0004                M 	movea.w	onext(a0),a0
0001A414 2250                     M 	move.l	oaddr(a0),a1
0001A416 4ED1                     M 	jmp	(a1)
0001A418                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A418                            .Bounce:
0001A418 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A41E 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A424 4469 001E                  		neg.w	oYVel(a1)
0001A428 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A42E 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A432 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A436 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A43C 0828 0000 0028             		btst	#0,oStatus(a0)
0001A442 6600                       		bne.s	.SetAni
0001A444 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A44A 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A450 4469 001C                  		neg.w	oXVel(a1)
0001A454                            
0001A454                            .SetAni:
0001A454 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A45A 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A460 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A466                            
0001A466 1028 0024                  		move.b	oSubtype(a0),d0
0001A46A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A46E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A472 6600                       		bne.s	.ChkPath2			; If not, branch
0001A474 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A47A 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A480                            
0001A480                            .ChkPath2:
0001A480 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A484 6600                       		bne.s	.PlaySound			; If not, branch
0001A486 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A48C 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A492                            
0001A492                            .PlaySound:
0001A492                            		playSnd	#sSpring, 2			; Play spring sound
0001A492 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A498 4E75                       		rts
0001A49A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A49A                            .SlopeData:
0001A49A F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
0001A4A1 F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
0001A4A8 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
0001A4AF 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
0001A4B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4B6                            ; Data
0001A4B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4B6                            Ani_ObjSpring:
0001A4B6                            		include	"Level/Objects/Spring/Animations.asm"
0001A4B6                            ; ---------------------------------------------------------------------------
0001A4B6                            ; Animation script - springs
0001A4B6                            ; ---------------------------------------------------------------------------
0001A4B6 0000                       		dc.w byte_18FEE-Ani_ObjSpring
0001A4B8 0000                       		dc.w byte_18FF1-Ani_ObjSpring
0001A4BA 0000                       		dc.w byte_18FFD-Ani_ObjSpring
0001A4BC 0000                       		dc.w byte_19000-Ani_ObjSpring
0001A4BE 0000                       		dc.w byte_1900C-Ani_ObjSpring
0001A4C0 0000                       		dc.w byte_1900F-Ani_ObjSpring
0001A4C2                            byte_18FEE:
0001A4C2 0F00 FF                    		dc.b  $F, 0, $FF
0001A4C6 00                         		even
0001A4C6                            byte_18FF1:
0001A4C6 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
0001A4D0 00                         		even
0001A4D0                            byte_18FFD:
0001A4D0 0F02 FF                    		dc.b $F, 2, $FF
0001A4D4 00                         		even
0001A4D4                            byte_19000:
0001A4D4 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
0001A4DE 00                         		even
0001A4DE                            byte_1900C:
0001A4DE 0F04 FF                    		dc.b $F, 4, $FF
0001A4E2 00                         		even
0001A4E2                            byte_1900F:
0001A4E2 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
0001A4EC 00                         		even
0001A4EC                            Map_ObjSpring:
0001A4EC                            		include	"Level/Objects/Spring/Mappings.asm"
0001A4EC                            ; --------------------------------------------------------------------------------
0001A4EC                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001A4EC                            ; --------------------------------------------------------------------------------
0001A4EC                            
0001A4EC                            SME_q_6K9:	
0001A4EC 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
0001A4F0 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
0001A4F4 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
0001A4F8 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
0001A4FA 0002                       SME_q_6K9_E:	dc.b 0, 2	
0001A4FC F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A502 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
0001A508 0005                       SME_q_6K9_1C:	dc.b 0, 5	
0001A50A E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
0001A510 E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
0001A516 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
0001A51C F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
0001A522 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
0001A528 0001                       SME_q_6K9_3C:	dc.b 0, 1	
0001A52A E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
0001A530 0007                       SME_q_6K9_44:	dc.b 0, 7	
0001A532 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
0001A538 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
0001A53E F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
0001A544 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
0001A54A F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
0001A550 E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
0001A556 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
0001A55C 0002                       SME_q_6K9_70:	dc.b 0, 2	
0001A55E F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0001A564 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
0001A56A 0005                       SME_q_6K9_7E:	dc.b 0, 5	
0001A56C E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
0001A572 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
0001A578 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
0001A57E FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
0001A584 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
0001A58A 0002                       SME_q_6K9_9E:	dc.b 0, 2	
0001A58C 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
0001A592 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
0001A598                            		even
0001A598                            ArtKosM_SpringH:
0001A598                            		incbin	"Level/Objects/Spring/Art - Horizontal.kosm.bin"
0001A674 00                         		even
0001A674                            ArtKosM_SpringV:
0001A674                            		incbin	"Level/Objects/Spring/Art - Vertical.kosm.bin"
0001A75A 00                         		even
0001A75A                            ArtKosM_SpringD:
0001A75A                            		incbin	"Level/Objects/Spring/Art - Diagonal.kosm.bin"
0001A974 00                         		even
0001A974                            ; =========================================================================================================================================================
0001A974                            		include	"Level/Objects/Checkpoint/Code.asm"	; Checkpoint object
0001A974                            ; =========================================================================================================================================================
0001A974                            ; Mighty The Armadillo in PRISM PARADISE
0001A974                            ; By Nat The Porcupine 2021
0001A974                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A974                            ; Checkpoint object
0001A974                            ; =========================================================================================================================================================
0001A974                            		rsset	oLvlSSTs
0001A974 =00000030                  oDongleX	rs.w	1				; Ball dongle X
0001A974 =00000032                  oDongleY	rs.w	1				; Ball dongle Y
0001A974 =00000034                  oDongleTime	rs.w	1				; Ball dongle timer
0001A974 =00000036                  oDonglePar	rs.w	1				; Ball dongle parent
0001A974                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A974                            ObjCheckpoint:
0001A974 7000                       		moveq	#0,d0
0001A976 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0001A97A 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0001A97E                            	nextObject
0001A97E 3068 0004                M 	movea.w	onext(a0),a0
0001A982 2250                     M 	move.l	oaddr(a0),a1
0001A984 4ED1                     M 	jmp	(a1)
0001A986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A986                            .Index:
0001A986 6000 0000                  		bra.w	ObjChkpoint_Init
0001A98A 6000 0000                  		bra.w	ObjChkpoint_Main
0001A98E 6000 0000                  		bra.w	ObjChkpoint_Animate
0001A992                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A992                            ObjChkpoint_Init:
0001A992 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0001A996                            		
0001A996 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,oMap(a0)	; Mappings
0001A99E 317C 057E 000E             		move.w	#$57E,oVRAM(a0)			; Tile properties
0001A9A4 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001A9AA 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A9B0 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
0001A9B6                            	displaySprite	5,a0,a1,0			; Priority
0001A9B6 317C BE82 0008           M 	move.w	#rdispinput+(5*dsize),odrawnext(a0)
0001A9BC 3278 BE8C                M 	move.w	rdispinput+dprev+(5*dsize).w,a1
0001A9C0 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A9C4 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A9C8 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
0001A9CC                          M .no_264
0001A9CC                            		
0001A9CC 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001A9D0 3440                       		movea.w	d0,a2				; ''
0001A9D2 0812 0000                  		btst	#0,(a2)				; Is it already set?
0001A9D6 6600                       		bne.s	.AlreadySet			; If so, branch
0001A9D8                            
0001A9D8 1228 0024                  		move.b	oSubtype(a0),d1			; Get checkpoint ID
0001A9DC B238 C7AE                  		cmp.b	rLastChkpoint.w,d1		; Has a later checkpoint already been hit?
0001A9E0 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
0001A9E2                            
0001A9E2                            .AlreadySet:
0001A9E2 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001A9E6 117C 0002 0020             		move.b	#2,oAni(a0)			; ''
0001A9EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A9EC                            ObjChkpoint_Main:
0001A9EC 4A38 F8D1                  		tst.b	rDebugMode.w			; Are we in debug placement mode?
0001A9F0 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
0001A9F4                            		
0001A9F4 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Player object
0001A9F8 1238 C7AE                  		move.b	rLastChkpoint.w,d1		; Get last checkpoint hit
0001A9FC B228 0024                  		cmp.b	oSubtype(a0),d1			; Has a later checkpoint already been hit?
0001AA00 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
0001AA04                            
0001AA04 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0001AA08 9068 0014                  		sub.w	oXPos(a0),d0			; Get delta X from current position
0001AA0C 5040                       		addq.w	#8,d0				; Add 8
0001AA0E 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
0001AA12 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AA16 3029 0018                  		move.w	oYPos(a1),d0			; Get player's Y position
0001AA1A 9068 0018                  		sub.w	oYPos(a0),d0			; Get delta Y from current position
0001AA1E 0640 0040                  		addi.w	#$40,d0				; Add $40
0001AA22 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
0001AA26 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AA2A                            		
0001AA2A                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0001AA2A 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
0001AA30                            
0001AA30 4EB8 19B0                  		jsr	FindFreeObj.w			; Find a free object slot
0001AA34 6700                       		beq.s	.SetPoint			; If there is none, branch
0001AA36 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,oAddr(a1)	; Load the checkpoint ball dongle object
0001AA3C 3368 0014 0030             		move.w	oXPos(a0),oDongleX(a1)		; Dongle X
0001AA42 3368 0018 0032             		move.w	oYPos(a0),oDongleY(a1)		; Dongle Y
0001AA48 0469 0014 0032             		subi.w	#$14,oDongleY(a1)		; ''
0001AA4E 2368 0010 0010             		move.l	oMap(a0),oMap(a1)		; Mappings
0001AA54 3368 000E 000E             		move.w	oVRAM(a0),oVRAM(a1)		; Tile properties
0001AA5A 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
0001AA60 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
0001AA66 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
0001AA6C                            	displaySprite	4,a1,a2,0			; Priority
0001AA6C 337C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a1)
0001AA72 3478 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a2
0001AA76 334A 000A                M 	move.w	a2,odrawprev(a1)
0001AA7A 3549 0008                M 	move.w	a1,odrawnext(a2)
0001AA7E 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
0001AA82                          M .no_266
0001AA82 137C 0002 0010             		move.b	#2,oFrame(a1)			; Map frame
0001AA88 337C 0020 0034             		move.w	#$20,oDongleTime(a1)		; Dongle timer
0001AA8E 3348 0036                  		move.w	a0,oDonglePar(a1)		; Dongle parent
0001AA92                            
0001AA92                            .SetPoint:
0001AA92 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AA96 3440                       		movea.w	d0,a2				; ''
0001AA98 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AA9C                            		
0001AA9C 117C 0001 0020             		move.b	#1,oAni(a0)			; Use dongling animation
0001AAA2 11E8 0024 C7AE             		move.b	oSubtype(a0),rLastChkpoint.w	; Set checkpoint ID
0001AAA8                            
0001AAA8 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AAAC 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
0001AAB2 4EF8 49EE                  		jmp	Level_SaveInfo			; Save data
0001AAB6                            		
0001AAB6                            .ChkSetAnim:
0001AAB6 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AABA 4A28 0020                  		tst.b	oAni(a0)			; Are we still unset?
0001AABE 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
0001AAC0 117C 0002 0020             		move.b	#2,oAni(a0)			; Use the set animation
0001AAC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AAC6                            ObjChkpoint_Animate:
0001AAC6 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0001AACC 4EB8 1BFA                  		jsr	AnimateObject.w			; ''
0001AAD0 4EF8 1FB8                  		jmp	CheckObjActive.w		; Display
0001AAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AAD4                            ; Ball dongle object
0001AAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AAD4                            ObjChkPoint_Dongle:
0001AAD4 5368 0034                  		subq.w	#1,oDongleTime(a0)		; Decrement timer
0001AAD8 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0001AADA 3268 0036                  		movea.w	oDonglePar(a0),a1		; Get parent
0001AADE 137C 0002 0020             		move.b	#2,oAni(a1)			; Set set animation for parent
0001AAE4 4229 0010                  		clr.b	oFrame(a1)			; Reset map frame for parent
0001AAE8 4EB8 1A06                  		jsr	DeleteObject.w			; Delete ourselves
0001AAEC                            	nextObject
0001AAEC 3068 0004                M 	movea.w	onext(a0),a0
0001AAF0 2250                     M 	move.l	oaddr(a0),a1
0001AAF2 4ED1                     M 	jmp	(a1)
0001AAF4                            
0001AAF4                            .MoveDongle:
0001AAF4 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0001AAF8 0428 0010 0041             		subi.b	#$10,oAngle(a0)			; Decrement angle
0001AAFE 0400 0040                  		subi.b	#$40,d0				; Subtract $40
0001AB02 4EB8 1308                  		jsr	CalcSine.w			; Get sine and cosine
0001AB06 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
0001AB0A 4841                       		swap	d1				; Get high word
0001AB0C D268 0030                  		add.w	oDongleX(a0),d1			; Add dongle X
0001AB10 3141 0014                  		move.w	d1,oXPos(a0)			; Set actual X
0001AB14 C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
0001AB18 4840                       		swap	d0				; Get high word
0001AB1A D068 0032                  		add.w	oDongleY(a0),d0			; Add dongle X
0001AB1E 3140 0018                  		move.w	d0,oYPos(a0)			; Set actual X
0001AB22 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display
0001AB26                            	nextObject
0001AB26 3068 0004                M 	movea.w	onext(a0),a0
0001AB2A 2250                     M 	move.l	oaddr(a0),a1
0001AB2C 4ED1                     M 	jmp	(a1)
0001AB2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AB2E                            ; Data
0001AB2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AB2E                            ArtKosM_Chkpoint:
0001AB2E                            		incbin	"Level/Objects/Checkpoint/Art.kosm.bin"
0001AC2E 00                         		even
0001AC2E                            Ani_ObjChkpoint:
0001AC2E 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
0001AC30 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
0001AC32 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
0001AC34 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
0001AC38 00                         		even
0001AC38 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
0001AC3C 00                         		even
0001AC3C 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
0001AC40                            		even
0001AC40                            Map_ObjChkpoint:
0001AC40                            		include	"Level/Objects/Checkpoint/Mappings.asm"
0001AC40                            ; --------------------------------------------------------------------------------
0001AC40                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AC40                            ; --------------------------------------------------------------------------------
0001AC40                            
0001AC40                            SME_JjCUP:	
0001AC40 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
0001AC44 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
0001AC48 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
0001AC4A 0004                       SME_JjCUP_A:	dc.b 0, 4	
0001AC4C E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC52 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC58 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC5E D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
0001AC64 0003                       SME_JjCUP_24:	dc.b 0, 3	
0001AC66 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC6C F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC72 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC78 0001                       SME_JjCUP_38:	dc.b 0, 1	
0001AC7A F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
0001AC80 0001                       SME_JjCUP_40:	dc.b 0, 1	
0001AC82 F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0001AC88 0004                       SME_JjCUP_48:	dc.b 0, 4	
0001AC8A E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC90 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC96 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC9C D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
0001ACA2                            		even
0001ACA2                            ; =========================================================================================================================================================
0001ACA2                            		include	"Level/Objects/Wall Spring/Code.asm"	; Wall spring object
0001ACA2                            ; =========================================================================================================================================================
0001ACA2                            ; Mighty The Armadillo in PRISM PARADISE
0001ACA2                            ; By Nat The Porcupine 2021
0001ACA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ACA2                            ; Wall spring object
0001ACA2                            ; =========================================================================================================================================================
0001ACA2                            ObjWallSpring:
0001ACA2 20BC 0000 0000             		move.l	#ObjWallSpring_Main,oAddr(a0)	; Next routine
0001ACA8                            	;	move.l	#Map_ObjWallSpring,oMap(a0)	; Mappings
0001ACA8                            	;	clr.w	oVRAM(a0)			; Tile properties
0001ACA8                            	;	ori.b	#4,oRender(a0)			; Render flags
0001ACA8                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0001ACA8                            	;	move.b	#8,oDrawW(a0)			; Sprite width
0001ACA8                            	;	move.b	#$40,oDrawH(a0)			; Sprite height
0001ACA8 117C 0008 002C             		move.b	#8,oColW(a0)			; Collision width
0001ACAE 117C 0040 002D             		move.b	#$40,oColH(a0)			; Collision height
0001ACB4                            
0001ACB4 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001ACB8 E808                       		lsr.b	#4,d0				; Get map frame
0001ACBA 0200 0007                  		andi.b	#7,d0				; ''
0001ACBE 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0001ACC2 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
0001ACC4                            	;	move.b	#$80,oDrawH(a0)			; Larger sprite height
0001ACC4 117C 0080 002D             		move.b	#$80,oColH(a0)			; Larger collision height
0001ACCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ACCA                            ObjWallSpring_Main:
0001ACCA 7208                       		moveq	#8,d1				; Width
0001ACCC 7400                       		moveq	#0,d2
0001ACCE 1428 002D                  		move.b	oColH(a0),d2			; Height
0001ACD2 3602                       		move.w	d2,d3				; ''
0001ACD4 5243                       		addq.w	#1,d3				; ''
0001ACD6 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001ACDA 4EB8 440C                  		jsr	SolidObject_Always		; Make us solid
0001ACDE                            
0001ACDE 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
0001ACE2 6700                       		beq.s	.Display			; If not, branch
0001ACE4 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set in air
0001ACEA 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001ACEE 3028 0014                  		move.w	oXPos(a0),d0			; Get distance between us and Sonic
0001ACF2 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001ACF6 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
0001ACF8 0A01 0001                  		eori.b	#1,d1				; Go the other way
0001ACFC                            
0001ACFC                            .ChkXStat:
0001ACFC 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
0001AD00 6600                       		bne.s	.Display			; If not, branch
0001AD02 6100                       		bsr.s	.Bounce
0001AD04                            
0001AD04                            .Display:
0001AD04 4EB8 1FB8                  		jsr	CheckObjActive.w		; Delete if inactive
0001AD08                            	nextObject
0001AD08 3068 0004                M 	movea.w	onext(a0),a0
0001AD0C 2250                     M 	move.l	oaddr(a0),a1
0001AD0E 4ED1                     M 	jmp	(a1)
0001AD10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AD10                            .Bounce:
0001AD10 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is Sonic dead?
0001AD16 6500                       		blo.s	.DoBounce			; If not, branch
0001AD18 4E75                       		rts
0001AD1A                            
0001AD1A                            .DoBounce:
0001AD1A 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Make Sonic not hurt if he is
0001AD20 337C F800 001C             		move.w	#-$800,oXVel(a1)		; Bounce left
0001AD26 337C F800 001E             		move.w	#-$800,oYVel(a1)		; Bounce up
0001AD2C 08E9 0000 0028             		bset	#0,oStatus(a1)			; Face left
0001AD32 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing left?
0001AD38 6600                       		bne.s	.MoveLock			; If so, branch
0001AD3A 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Face right
0001AD40 4469 001C                  		neg.w	oXVel(a1)			; Go right
0001AD44                            
0001AD44                            .MoveLock:
0001AD44 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Set move lock timer
0001AD4A 0829 0002 0028             		btst	#2,oStatus(a1)			; Was Sonic jumping?
0001AD50 6600                       		bne.s	.ChkNoYVel			; If so, branch
0001AD52 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AD56                            
0001AD56                            .ChkNoYVel:
0001AD56 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001AD5A 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0001AD5C 4229 001E                  		clr.b	oYVel(a1)			; Stop Y velocity
0001AD60                            
0001AD60                            .ChkFlip:
0001AD60 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
0001AD64 6700                       		beq.s	.PlaySnd			; If not, branch
0001AD66 337C 0001 003A             		move.w	#1,oFlipDir(a1)			; Set flip direction
0001AD6C 137C 0001 0047             		move.b	#1,oFlipAngle(a1)		; Set flip angle
0001AD72 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AD76 137C 0001 0049             		move.b	#1,oFlipRemain(a1)		; Set flips remaining
0001AD7C 137C 0008 004A             		move.b	#8,oFlipSpeed(a1)		; Set flip speed
0001AD82 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
0001AD86 6600                       		bne.s	.ChkDir				; If not, branch
0001AD88 137C 0003 0049             		move.b	#3,oFlipRemain(a1)		; Do 3 flips isntead
0001AD8E                            
0001AD8E                            .ChkDir:
0001AD8E 0829 0000 0028             		btst	#0,oStatus(a1)			; Was Sonic facing left?
0001AD94 6700                       		beq.s	.PlaySnd			; If not, branch
0001AD96 4429 0047                  		neg.b	oFlipAngle(a1)			; Flip the other way
0001AD9A 4469 003A                  		neg.w	oFlipDir(a1)			; ''
0001AD9E                            
0001AD9E                            .PlaySnd:
0001AD9E 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Stop pushing
0001ADA4 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001ADAA                            		playSnd	#sSpring, 2			; Play spring sound
0001ADAA 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001ADB0 4E75                       		rts
0001ADB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADB2                            ; Data
0001ADB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADB2                            Map_ObjWallSpring:
0001ADB2                            		include	"Level/Objects/Wall Spring/Mappings.asm"
0001ADB2                            ; --------------------------------------------------------------------------------
0001ADB2                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001ADB2                            ; --------------------------------------------------------------------------------
0001ADB2                            
0001ADB2                            SME_ReVf5:	
0001ADB2 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
0001ADB6 0002                       SME_ReVf5_4:	dc.b 0, 2	
0001ADB8 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
0001ADBE 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
0001ADC4 0002                       SME_ReVf5_12:	dc.b 0, 2	
0001ADC6 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0001ADCC 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
0001ADD2                            		even
0001ADD2                            		even
0001ADD2                            ; =========================================================================================================================================================
0001ADD2                            		include	"Level/Objects/Ball Mode/Code.asm"	; Ball mode switch object
0001ADD2                            ; =========================================================================================================================================================
0001ADD2                            ; Mighty The Armadillo in PRISM PARADISE
0001ADD2                            ; By Nat The Porcupine 2021
0001ADD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADD2                            ; Ball mode enable/disable object
0001ADD2                            ; =========================================================================================================================================================
0001ADD2                            		rsset	oLvlSSTs
0001ADD2 =00000030                  oBModeTouch	rs.b	1				; Touched flag
0001ADD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADD2                            ObjBallMode:
0001ADD2                            	;	move.l	#ObjBallMode_Main,oAddr(a0)	; Next routine
0001ADD2                            	;	move.l	#Map_ObjMonitor,oMap(a0)	; Mappings
0001ADD2                            	;	clr.w	oVRAM(a0)			; Tile properties
0001ADD2                            	;	ori.b	#4,oRender(a0)			; Render flags
0001ADD2                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
0001ADD2                            	;	move.b	#$10,oDrawW(a0)			; Sprite width
0001ADD2                            	;	move.b	#$10,oDrawH(a0)			; Sprite height
0001ADD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADD2                            ObjBallMode_Main:
0001ADD2 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001ADD6 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001ADDA 4EB8 1D1A                  		jsr	CheckObjInRange.w		; Is the player in range?
0001ADDE 4A40                       		tst.w	d0				; ''
0001ADE0 6700                       		beq.s	.NotTouched			; If not, branch
0001ADE2                            
0001ADE2 08AA 0002 000C             		bclr	#2,oFlags(a2)
0001ADE8                            		
0001ADE8 4A28 0024                  		tst.b	oSubtype(a0)			; Should we force Sonic out of ball mode?
0001ADEC 6B00                       		bmi.s	.NoBallMode			; If so, branch
0001ADEE 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
0001ADF0                            
0001ADF0 4A28 0030                  		tst.b	oBModeTouch(a0)			; Have we already been touched?
0001ADF4 6600                       		bne.s	.End				; If so, branch
0001ADF6 50E8 0030                  		st	oBModeTouch(a0)			; Touched
0001ADFA                            
0001ADFA 462A 004B                  		not.b	oBallMode(a2)			; Switch ball mode for Sonic
0001ADFE 6700                       		beq.s	.End				; If it's not set, branch
0001AE00                            
0001AE00                            .MakeSonicRoll:
0001AE00 2248                       		movea.l	a0,a1				; Save a0
0001AE02 204A                       		movea.l	a2,a0				; Make Sonic roll
0001AE04 4EB9 0000 BAB6             		jsr	ObjMighty_DoRoll			; ''
0001AE0A 2049                       		movea.l	a1,a0				; Restore a0
0001AE0C                            	nextObject
0001AE0C 3068 0004                M 	movea.w	onext(a0),a0
0001AE10 2250                     M 	move.l	oaddr(a0),a1
0001AE12 4ED1                     M 	jmp	(a1)
0001AE14                            
0001AE14                            .NotTouched:
0001AE14 4228 0030                  		clr.b	oBModeTouch(a0)			; Not touched
0001AE18                            	nextObject
0001AE18 3068 0004                M 	movea.w	onext(a0),a0
0001AE1C 2250                     M 	move.l	oaddr(a0),a1
0001AE1E 4ED1                     M 	jmp	(a1)
0001AE20                            
0001AE20                            .BallMode:
0001AE20 50EA 004B                  		st	oBallMode(a2)			; Get in to ball mode
0001AE24 60DA                       		bra.s	.MakeSonicRoll			; ''
0001AE26                            
0001AE26                            .NoBallMode:
0001AE26 422A 004B                  		clr.b	oBallMode(a2)			; Get out of ball mode
0001AE2A                            
0001AE2A                            .End:
0001AE2A                            	nextObject
0001AE2A 3068 0004                M 	movea.w	onext(a0),a0
0001AE2E 2250                     M 	move.l	oaddr(a0),a1
0001AE30 4ED1                     M 	jmp	(a1)
0001AE32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE32                            .RangeData:
0001AE32 FFF0 0020                  		dc.w	-$10, $20
0001AE36 FFF0 0020                  		dc.w	-$10, $20
0001AE3A                            ; =========================================================================================================================================================
0001AE3A                            		include	"Level/Objects/Bumper/Code.asm"		; Bumper object
0001AE3A                            ; =========================================================================================================================================================
0001AE3A                            ; Mighty The Armadillo in PRISM PARADISE
0001AE3A                            ; By Nat The Porcupine 2021
0001AE3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE3A                            ; Water surface object
0001AE3A                            ; =========================================================================================================================================================
0001AE3A                            		rsset	oLvlSSTs
0001AE3A                            
0001AE3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE3A                            ObjBumper:
0001AE3A 20BC 0000 0000             		move.l	#ObjBumperMain,oAddr(a0)	; Next routine
0001AE40 217C 0000 0000 0010        		move.l	#Map_ObjBumper,oMap(a0)		; Mappings
0001AE48 317C 035B 000E             		move.w	#$35B,oVRAM(a0)			; Tile properties
0001AE4E 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AE54                            	displaySprite	1,a0,a1,0			; Priority
0001AE54 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
0001AE5A 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
0001AE5E 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AE62 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AE66 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
0001AE6A                          M .no_274
0001AE6A 7210                       		moveq	#$10,d1
0001AE6C 1141 0017                  		move.b	d1,oDrawW(a0)
0001AE70 1141 002C                  		move.b	d1,oColW(a0)
0001AE74 1141 001B                  		move.b	d1,oDrawH(a0)
0001AE78 1141 002D                  		move.b	d1,oColH(a0)
0001AE7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE7C                            ObjBumperMain:
0001AE7C 4A38 F8D1                  		tst.b	rDebugMode.w
0001AE80 6600 0000                  		bne.w	.Display
0001AE84                            
0001AE84 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AE88 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AE8C 0C2A 000C 0025             		cmpi.b	#$C,oRoutine(a2)
0001AE92 6400 0000                  		bcc.w	.Display
0001AE96 4EB8 1D1A                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AE9A 4A40                       		tst.w	d0				; ''
0001AE9C 6700                       		beq.s	.Display			; If not, branch
0001AE9E                            
0001AE9E 3228 0014                  		move.w	oXPos(a0),d1
0001AEA2 3428 0018                  		move.w	oYPos(a0),d2
0001AEA6 926A 0014                  		sub.w	oXPos(a2),d1
0001AEAA 946A 0018                  		sub.w	oYPos(a2),d2
0001AEAE 4EB8 171A                  		jsr	CalcArcTan.w
0001AEB2 1238 C759                  		move.b	(rFrameCnt+3).w,d1
0001AEB6 0241 0003                  		andi.w	#3,d1
0001AEBA D041                       		add.w	d1,d0
0001AEBC 4EB8 1308                  		jsr	CalcSine.w
0001AEC0 C3FC F900                  		muls.w	#-$700,d1
0001AEC4 E081                       		asr.l	#8,d1
0001AEC6 3541 001C                  		move.w	d1,oXVel(a2)
0001AECA C1FC F900                  		muls.w	#-$700,d0
0001AECE E080                       		asr.l	#8,d0
0001AED0 3540 001E                  		move.w	d0,oYVel(a2)
0001AED4 0C2A 0008 0025             		cmpi.b	#8,oRoutine(a2)
0001AEDA 6600                       		bne.s	.NotHurt
0001AEDC 157C 0002 0020             		move.b	#2,oAni(a2)
0001AEE2 5A6A 0018                  		addq.w	#5,oYPos(a2)
0001AEE6 157C 000E 002D             		move.b	#$E,oColH(a2)
0001AEEC 157C 0007 002C             		move.b	#7,oColW(a2)
0001AEF2 08EA 0002 0028             		bset	#2,oStatus(a2)
0001AEF8                            
0001AEF8                            .NotHurt:
0001AEF8 157C 0004 0025             		move.b	#4,oRoutine(a2)
0001AEFE 08EA 0001 0028             		bset	#1,oStatus(a2)
0001AF04 08AA 0005 0028             		bclr	#5,oStatus(a2)
0001AF0A 422A 0040                  		clr.b	oJumping(a2)
0001AF0E 117C 0001 0020             		move.b	#1,oAni(a0)
0001AF14                            		playSnd	#sBumper, 2
0001AF14 11FC 0091 C4BD           M 	move.b	#sbumper,(mqueue+((2)-1)).w
0001AF1A                            
0001AF1A                            .Display:
0001AF1A 43FA 0000                  		lea	Ani_ObjBumper(pc),a1
0001AF1E 4EB8 1BFA                  		jsr	AnimateObject.w
0001AF22 4EB8 1FB8                  		jsr	CheckObjActive.w		; Display
0001AF26 4EB8 49DC                  		jsr	AddToColResponse		; Allow collision
0001AF2A                            	nextObject
0001AF2A 3068 0004                M 	movea.w	onext(a0),a0
0001AF2E 2250                     M 	move.l	oaddr(a0),a1
0001AF30 4ED1                     M 	jmp	(a1)
0001AF32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF32                            .RangeData:
0001AF32 FFE8 0030                  		dc.w	-$18, $30
0001AF36 FFE8 0030                  		dc.w	-$18, $30
0001AF3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF3A                            ; Data
0001AF3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF3A                            Map_ObjBumper:
0001AF3A                            		include	"Level/Objects/Bumper/Mappings.asm"
0001AF3A                            ; --------------------------------------------------------------------------------
0001AF3A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AF3A                            ; --------------------------------------------------------------------------------
0001AF3A                            
0001AF3A                            SME_3VuTU:	
0001AF3A 0000 0000                  		dc.w SME_3VuTU_6-SME_3VuTU, SME_3VuTU_E-SME_3VuTU	
0001AF3E 0000                       		dc.w SME_3VuTU_16-SME_3VuTU	
0001AF40 0001                       SME_3VuTU_6:	dc.b 0, 1	
0001AF42 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001AF48 0001                       SME_3VuTU_E:	dc.b 0, 1	
0001AF4A F40A 0029 FFF4             		dc.b $F4, $A, 0, $29, $FF, $F4	
0001AF50 0004                       SME_3VuTU_16:	dc.b 0, 4	
0001AF52 EC0F 0010 FFEC             		dc.b $EC, $F, 0, $10, $FF, $EC	
0001AF58 EC03 0020 000C             		dc.b $EC, 3, 0, $20, 0, $C	
0001AF5E 0C0C 0024 FFEC             		dc.b $C, $C, 0, $24, $FF, $EC	
0001AF64 0C00 0028 000C             		dc.b $C, 0, 0, $28, 0, $C	
0001AF6A                            		even
0001AF6A                            		even
0001AF6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF6A                            Ani_ObjBumper:
0001AF6A 0000                       		dc.w	.Ani0-Ani_ObjBumper
0001AF6C 0000                       		dc.w	.Ani1-Ani_ObjBumper
0001AF6E 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
0001AF72 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0001AF7A 00                         		even
0001AF7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF7A                            ArtKosM_Bumper:
0001AF7A                            		incbin	"Level/Objects/Bumper/Art.kosm.bin"
0001B248 00                         		even
0001B248                            ; =========================================================================================================================================================
0001B248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B248                            ; Unused/Temporary
0001B248                            ;		include	"Level/Objects/Slicer/Code.asm"		; Slicer object
0001B248                            ;		include	"Level/Objects/Shellcracker/Code.asm"	; Shellcracker object
0001B248                            ;		include	"Level/Objects/Asteron/Code.asm"	; Asteron object
0001B248                            ;		include	"Level/Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0001B248                            ;		include	"Level/Objects/Harpoon/Code.asm"	; Harpoon object
0001B248                            ;		include	"Level/Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0001B248                            ;		include	"Level/Objects/Diamond/Code.asm"	; Diamond object
0001B248                            ;		include	"Level/Objects/Orbinaut/Code.asm"	; Orbinaut object
0001B248                            ; =========================================================================================================================================================
0001B248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B248                            ; Ending
0001B248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B248                            		include	"Ending/Main.asm"
0001B248                            ; =========================================================================================================================================================
0001B248                            ; Mighty The Armadillo in PRISM PARADISE
0001B248                            ; By Nat The Porcupine 2021
0001B248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B248                            ; End splash screen
0001B248                            ; =========================================================================================================================================================
0001B248                            
0001B248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B248                            Ending:
0001B248 60FE                       		bra.s	Ending
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ;		playSnd	#Mus_Stop, 1			; Stop sound
0001B24A                            ;
0001B24A                            ;		intsOff					; Disable interrupts
0001B24A                            ;
0001B24A                            ;		lea	VDP_CTRL,a5
0001B24A                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0001B24A                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
0001B24A                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
0001B24A                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0001B24A                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
0001B24A                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
0001B24A                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
0001B24A                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0001B24A                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
0001B24A                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0001B24A                            ;
0001B24A                            ;		jsr	ClearScreen.w			; Clear screen
0001B24A                            ;
0001B24A                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
0001B24A                            ;		lea	rBuffer,a1			; Decompress into RAM
0001B24A                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0001B24A                            ;		jsr	EniDec.w			; Decompress!
0001B24A                            ;
0001B24A                            ;		lea	rBuffer,a1			; Load mappings
0001B24A                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
0001B24A                            ;		moveq	#$27,d1				; $28x$1C tiles
0001B24A                            ;		moveq	#$1B,d2				; ''
0001B24A                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0001B24A                            ;		jsr	LoadPlaneMap.w			; Load the map
0001B24A                            ;
0001B24A                            ;		lea	ArtKosM_End,a1			; Load background art
0001B24A                            ;		move.w	#$20,d2				; ''
0001B24A                            ;		jsr	QueueKosMData.w			; ''
0001B24A                            ;
0001B24A                            ;.WaitPLCs:
0001B24A                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B24A                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0001B24A                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B24A                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0001B24A                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
0001B24A                            ;		bne.s	.WaitPLCs			; If so, branch
0001B24A                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B24A                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B24A                            ;
0001B24A                            ;		lea	SampleList+$F0,a3
0001B24A                            ;		jsr	PlayDAC1
0001B24A                            ;
0001B24A                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
0001B24A                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
0001B24A                            ;		jsr	LoadPalette.w			; ''
0001B24A                            ;
0001B24A                            ;		displayOn
0001B24A                            ;
0001B24A                            ;.Loop:
0001B24A                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
0001B24A                            ;		jsr	VSync_Routine.w			; ''
0001B24A                            ;		bra.s	.Loop
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ; Art
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ;ArtKosM_End:
0001B24A                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
0001B24A                            ;		even
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ; Plane mappings
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ;MapEni_End:
0001B24A                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
0001B24A                            ;		even
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ; Palette
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ;Pal_End:
0001B24A                            ;		incbin	"Ending/Data/Palette.pal.bin"
0001B24A                            ;Pal_End_End:
0001B24A                            ;		even
0001B24A                            ; =========================================================================================================================================================
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            ; Horizontal interrupt for palette swapping (for water)
0001B24A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B24A                            HInt_Water:
0001B24A                            		intsOff					; Disable interrupts
0001B24A 007C 0700                M 	ori	#$700,sr
0001B24E                            
0001B24E 4A38 C749                  		tst.b	rHIntFlag.w			; Is the H-INT allowed to run?
0001B252 6700                       		beq.s	.End				; If not, branch
0001B254 4238 C749                  		clr.b	rHIntFlag.w			; Clear the H-INT flag
0001B258                            
0001B258                            		push.l	a0-a1				; Save registers
0001B258 48E7 00C0                M 	movem.l	a0-a1,-(sp)
0001B25C                            
0001B25C 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
0001B262 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0001B268 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette
0001B26C                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
0001B26C 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
0001B274                            		rept	32
0001B274                            			move.l	(a0)+,(a1)		; Tranfer palette
0001B274                            		endr
0001B274 2298                     M 	move.l	(a0)+,(a1)
0001B276 2298                     M 	move.l	(a0)+,(a1)
0001B278 2298                     M 	move.l	(a0)+,(a1)
0001B27A 2298                     M 	move.l	(a0)+,(a1)
0001B27C 2298                     M 	move.l	(a0)+,(a1)
0001B27E 2298                     M 	move.l	(a0)+,(a1)
0001B280 2298                     M 	move.l	(a0)+,(a1)
0001B282 2298                     M 	move.l	(a0)+,(a1)
0001B284 2298                     M 	move.l	(a0)+,(a1)
0001B286 2298                     M 	move.l	(a0)+,(a1)
0001B288 2298                     M 	move.l	(a0)+,(a1)
0001B28A 2298                     M 	move.l	(a0)+,(a1)
0001B28C 2298                     M 	move.l	(a0)+,(a1)
0001B28E 2298                     M 	move.l	(a0)+,(a1)
0001B290 2298                     M 	move.l	(a0)+,(a1)
0001B292 2298                     M 	move.l	(a0)+,(a1)
0001B294 2298                     M 	move.l	(a0)+,(a1)
0001B296 2298                     M 	move.l	(a0)+,(a1)
0001B298 2298                     M 	move.l	(a0)+,(a1)
0001B29A 2298                     M 	move.l	(a0)+,(a1)
0001B29C 2298                     M 	move.l	(a0)+,(a1)
0001B29E 2298                     M 	move.l	(a0)+,(a1)
0001B2A0 2298                     M 	move.l	(a0)+,(a1)
0001B2A2 2298                     M 	move.l	(a0)+,(a1)
0001B2A4 2298                     M 	move.l	(a0)+,(a1)
0001B2A6 2298                     M 	move.l	(a0)+,(a1)
0001B2A8 2298                     M 	move.l	(a0)+,(a1)
0001B2AA 2298                     M 	move.l	(a0)+,(a1)
0001B2AC 2298                     M 	move.l	(a0)+,(a1)
0001B2AE 2298                     M 	move.l	(a0)+,(a1)
0001B2B0 2298                     M 	move.l	(a0)+,(a1)
0001B2B2 2298                     M 	move.l	(a0)+,(a1)
0001B2B4                            		pop.l	a0-a1				; Restore registers
0001B2B4 4CDF 0300                M 	movem.l	(sp)+,a0-a1
0001B2B8                            		
0001B2B8 4A38 C75D                  		tst.b	rHIntUpdates.w		; Do we need to do level updates in here?
0001B2BC 6600                       		bne.s	.DoUpdates			; If so, branch
0001B2BE                            
0001B2BE                            .End:
0001B2BE 4E73                       		rte
0001B2C0                            
0001B2C0                            .DoUpdates:
0001B2C0 4238 C75D                  		clr.b	rHIntUpdates.w		; Clear the update flag
0001B2C4                            		push.l	d0-a6				; Save registers
0001B2C4 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
0001B2C8 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0001B2CE 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0001B2D2 4EB8 3FBC                  		jsr	Level_UpdateHUD			; Update the HUD
0001B2D6 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0001B2DC                            		pop.l	d0-a6				; Restore registers
0001B2DC 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0001B2E0 4E73                       		rte
0001B2E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E2                            ; Sound driver
0001B2E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2E2                            		include	"../amps/code/68k.asm"
0001B2E2                            	opt oz+					; enable zero-offset optimization
0001B2E2                            	opt l.					; local lables are dots
0001B2E2                            	opt ae+					; enable automatic even's
0001B2E2                            
0001B2E2                            	include "../amps/code/routines.asm"	; include macro'd routines
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Note timout handler macro
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dNoteToutHandler	macro
0001B2E2                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0001B2E2                            		beq.s	.endt			; if is, do not timeout
0001B2E2                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0001B2E2                            		bne.s	.endt			; if still not 0, branch
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Note timout handler macro for DAC
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dNoteToutDAC	macro
0001B2E2                            	dNoteToutHandler			; include timeout handler
0001B2E2                            		moveq	#0,d0			; play stop sample
0001B2E2                            		bra.w	dNoteOnDAC2		; ''
0001B2E2                            .endt
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Note timout handler macro for FM
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dNoteToutFM	macro
0001B2E2                            	dNoteToutHandler			; include timeout handler
0001B2E2                            		bset	#cfbRest,(a5)		; set track to resting
0001B2E2                            		bsr.w	dKeyOffFM		; key off FM
0001B2E2                            		bra.\0	.next			; jump to next track
0001B2E2                            .endt
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Note timout handler macro for PSG
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dNoteToutPSG	macro
0001B2E2                            	dNoteToutHandler			; include timeout handler
0001B2E2                            		bset	#cfbRest,(a5)		; set track to resting
0001B2E2                            		bsr.w	dMutePSGmus		; mute PSG channel
0001B2E2                            		bra.s	.next			; jump to next track
0001B2E2                            .endt
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for calculating the current frequency (without modulation) into d6.
0001B2E2                            ; Used if user wants to add extra pitch effects such as pitch slides.
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dCalcFreq	macro
0001B2E2                            		move.b	cDetune(a5),d6		; get detune value to d6
0001B2E2                            		ext.w	d6			; extend to word
0001B2E2                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for generating frequency modulation code
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dModulate	macro jump,loop,type
0001B2E2                            		btst	#cfbMod,(a5)		; check if modulation is active
0001B2E2                            		beq.s	.noret			; if not, update volume and return
0001B2E2                            		tst.b	cModDelay(a5)		; check if there is delay left
0001B2E2                            		beq.s	.started		; if not, modulate!
0001B2E2                            		subq.b	#1,cModDelay(a5)	; decrease delay
0001B2E2                            .noret
0001B2E2                            	if narg>0
0001B2E2                            		if narg=3
0001B2E2                            			if type<2
0001B2E2                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2E2                            				beq.s	.noupdatevol		; if not, skip
0001B2E2                            				jsr	dUpdateVolFM(pc)	; update FM volume
0001B2E2                            			.noupdatevol:
0001B2E2                            			endif
0001B2E2                            			if type>=4
0001B2E2                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2E2                            				beq.s	.noupdatevol		; if not, skip
0001B2E2                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0001B2E2                            			.noupdatevol:
0001B2E2                            			endif
0001B2E2                            			if \type<>5
0001B2E2                            				dbf	d7,\loop		; loop for all channels
0001B2E2                            			endif
0001B2E2                            		endif
0001B2E2                            		bra.w	\jump			; jump to next routine
0001B2E2                            	else
0001B2E2                            		bra.s	.endm			; jump to the next .endm routine
0001B2E2                            	endif
0001B2E2                            .started
0001B2E2                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0001B2E2                            		bne.s	.noret			; if there's still delay left, update vol and return
0001B2E2                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0001B2E2                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0001B2E2                            		tst.b	cModCount(a5)		; check if this was the last step
0001B2E2                            		bne.s	.norev			; if was not, do not reverse
0001B2E2                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0001B2E2                            		neg.b	cModStep(a5)		; negate step amount
0001B2E2                            .norev
0001B2E2                            		subq.b	#1,cModCount(a5)	; decrease step counter
0001B2E2                            		move.b	cModStep(a5),d5		; get step offset into d5
0001B2E2                            		ext.w	d5			; extend to word
0001B2E2                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0001B2E2                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0001B2E2                            		add.w	d5,d6			; add to channel base frequency
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for processing the tracker
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dDoTracker	macro
0001B2E2                            		movea.l	cData(a5),a4		; grab tracker address
0001B2E2                            	if safe=1
0001B2E2                            		AMPS_Debug_TrackUpd		; check if this address is valid
0001B2E2                            	endif
0001B2E2                            .data
0001B2E2                            		moveq	#0,d5
0001B2E2                            		move.b	(a4)+,d5		; get a byte from tracker
0001B2E2                            		cmpi.b	#$E0,d5			; is this a command?
0001B2E2                            		blo.s	.notcomm		; if not, continue
0001B2E2                            		jsr	dCommands(pc)		; run the condition flag
0001B2E2                            		bra.s	.data			; for most commands, use this branch to loop
0001B2E2                            		bra.s	.next			; however, for example sStop will make us return here.
0001B2E2                            .notcomm
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for playing a note, and setting up for it (software updates only)
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dProcNote	macro sfx, psg
0001B2E2                            		move.l	a4,cData(a5)		; save tracker address
0001B2E2                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0001B2E2                            		btst	#cfbHold,(a5)		; check if we are holding
0001B2E2                            		bne.s	.endpn			; if we are, branch
0001B2E2                            	if sfx=0
0001B2E2                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0001B2E2                            	endif
0001B2E2                            	if psg<>0
0001B2E2                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0001B2E2                            	endif
0001B2E2                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0001B2E2                            		beq.s	.endpn			; if not, branch
0001B2E2                            		movea.l	cMod(a5),a1		; get modulation data address
0001B2E2                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0001B2E2                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0001B2E2                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0001B2E2                            		move.b	(a1),d0			; get number of steps
0001B2E2                            		lsr.b	#1,d0			; halve it
0001B2E2                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0001B2E2                            		clr.w	cModFreq(a5)		; clear frequency offset
0001B2E2                            .endpn
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for processing a note in DAC channel
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dTrackNoteDAC	macro
0001B2E2                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0001B2E2                            		bne.s	.pitch			; if so, load pitch
0001B2E2                            		move.b	d5,cSample(a5)		; else, save as a sample
0001B2E2                            		bra.s	.cont
0001B2E2                            .pitch
0001B2E2                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001B2E2                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0001B2E2                            		moveq	#0,d0			; play stop sample
0001B2E2                            		bsr.w	dNoteOnDAC2		; ''
0001B2E2                            		moveq	#-$80,d6		; tell the code we are resting
0001B2E2                            		bra.s	.cont
0001B2E2                            .noprest
0001B2E2                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2E2                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2E2                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001B2E2                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2E2                            .cont
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for doing keying-on FM channel
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dKeyOnFM	macro
0001B2E2                            		btst	#cfbHold,(a5)		; check if note is held
0001B2E2                            		bne.s	.k			; if so, do not note on
0001B2E2                            		btst	#cfbRest,(a5)		; check if channel is resting
0001B2E2                            		bne.s	.k			; if so, do not note on
0001B2E2                            	if narg=0
0001B2E2                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0001B2E2                            		bne.s	.k			; if so, do not note on
0001B2E2                            	endif
0001B2E2                            		moveq	#$28,d0			; YM command: Key on
0001B2E2                            		move.b	cType(a5),d1		; get channel type bits
0001B2E2                            		ori.b	#$F0,d1			; turn all FM operators on
0001B2E2                            		bsr.w	WriteYM_Pt1		; send note-on event
0001B2E2                            .k
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Macro for processing a note in PSG channel
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            dGetFreqPSG	macro
0001B2E2                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0001B2E2                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0001B2E2                            		bset	#cfbRest,(a5)		; set channel to resting
0001B2E2                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0001B2E2                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0001B2E2                            		bra.s	.freqgot
0001B2E2                            .norest
0001B2E2                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2E2                            		andi.w	#$7F,d5			; keep within $80 notes
0001B2E2                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2E2                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2E2                            	if safe=1
0001B2E2                            		AMPS_Debug_NotePSG		; check if the note was valid
0001B2E2                            	endif
0001B2E2                            .freqgot
0001B2E2                                endm
0001B2E2                            ; ===========================================================================
0001B2E2                            	include "../amps/code/debug.asm"	; debug data blob
0001B2E2                            ; ===========================================================================
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            ; Routine for loading the Dual PCM driver into Z80 RAM
0001B2E2                            ; ---------------------------------------------------------------------------
0001B2E2                            
0001B2E2                            LoadDualPCM:
0001B2E2 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0001B2EA 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B2F2                            
0001B2F2 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0001B2F8 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0001B2FE 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0001B302                            
0001B302                            .z80
0001B302 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0001B30A 66F6                       		bne.s	.z80			; if not, wait more
0001B30C                            
0001B30C                            .load
0001B30C 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0001B30E 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0001B312                            
0001B312 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0001B316 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0001B31C                            
0001B31C                            	rept 6
0001B31C                            		move.b	(a0)+,(a1)+		; copy all required data
0001B31C                            	endr
0001B31C 12D8                     M 	move.b	(a0)+,(a1)+
0001B31E 12D8                     M 	move.b	(a0)+,(a1)+
0001B320 12D8                     M 	move.b	(a0)+,(a1)+
0001B322 12D8                     M 	move.b	(a0)+,(a1)+
0001B324 12D8                     M 	move.b	(a0)+,(a1)+
0001B326 12D8                     M 	move.b	(a0)+,(a1)+
0001B328                            
0001B328 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0001B32A 0838 0006 C744             		btst	#6,rHWVersion.w	; is this a PAL Mega Drive?
0001B330 6700                       		beq.s	.ntsc			; if not, branch
0001B332 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0001B334                            .ntsc
0001B334 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0001B33A                            
0001B33A 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0001B342 727F                       		moveq	#$7F,d1			; wait for a little bit
0001B344 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0001B348                            
0001B348 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0001B350 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B358 4E75                       		rts
0001B35A                            ; ---------------------------------------------------------------------------
0001B35A                            ; Play DAC
0001B35A                            ; ---------------------------------------------------------------------------
0001B35A                            
0001B35A                            PlayDAC2:
0001B35A 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B360                            	StopZ80					; wait for Z80 to stop
0001B360 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B368                          M 	waitz80stop
0001B368 0839 0000 00A1 1100      M .wait_284:	btst	#0,z80_bus_req
0001B370 66F6                     M 	bne.s	.wait_284
0001B372                            	rept 12
0001B372                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B372                            	endr
0001B372 12DB                     M 	move.b	(a3)+,(a1)+
0001B374 12DB                     M 	move.b	(a3)+,(a1)+
0001B376 12DB                     M 	move.b	(a3)+,(a1)+
0001B378 12DB                     M 	move.b	(a3)+,(a1)+
0001B37A 12DB                     M 	move.b	(a3)+,(a1)+
0001B37C 12DB                     M 	move.b	(a3)+,(a1)+
0001B37E 12DB                     M 	move.b	(a3)+,(a1)+
0001B380 12DB                     M 	move.b	(a3)+,(a1)+
0001B382 12DB                     M 	move.b	(a3)+,(a1)+
0001B384 12DB                     M 	move.b	(a3)+,(a1)+
0001B386 12DB                     M 	move.b	(a3)+,(a1)+
0001B388 12DB                     M 	move.b	(a3)+,(a1)+
0001B38A 101B                       		move.b	(a3)+,d0
0001B38C 5200                       		addq.b	#1,d0
0001B38E 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0001B394 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0001B39A 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B3A2                            
0001B3A2 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001B3AA                            	StartZ80				; enable Z80 execution
0001B3AA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B3B2 4E75                       		rts
0001B3B4                            
0001B3B4                            ; ---------------------------------------------------------------------------
0001B3B4                            
0001B3B4                            PlayDAC1:
0001B3B4 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0001B3BA                            	StopZ80					; wait for Z80 to stop
0001B3BA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B3C2                          M 	waitz80stop
0001B3C2 0839 0000 00A1 1100      M .wait_287:	btst	#0,z80_bus_req
0001B3CA 66F6                     M 	bne.s	.wait_287
0001B3CC                            	rept 12
0001B3CC                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B3CC                            	endr
0001B3CC 12DB                     M 	move.b	(a3)+,(a1)+
0001B3CE 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D0 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D2 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D4 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D6 12DB                     M 	move.b	(a3)+,(a1)+
0001B3D8 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DA 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DC 12DB                     M 	move.b	(a3)+,(a1)+
0001B3DE 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E0 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E2 12DB                     M 	move.b	(a3)+,(a1)+
0001B3E4 101B                       		move.b	(a3)+,d0
0001B3E6 5200                       		addq.b	#1,d0
0001B3E8 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0001B3EE 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0001B3F4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B3FC                            
0001B3FC 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B404                            	StartZ80				; enable Z80 execution
0001B404 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B40C 4E75                       		rts
0001B40E                            ; ===========================================================================
0001B40E                            ; ---------------------------------------------------------------------------
0001B40E                            ; Handle Dual PCM YM Cue correctly
0001B40E                            ; ---------------------------------------------------------------------------
0001B40E                            
0001B40E                            UpdateAMPS:
0001B40E                            	StopZ80					; wait for Z80 to stop
0001B40E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B416                          M 	waitz80stop
0001B416 0839 0000 00A1 1100      M .wait_290:	btst	#0,z80_bus_req
0001B41E 66F6                     M 	bne.s	.wait_290
0001B420 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0001B426                            	StartZ80				; enable Z80 execution
0001B426 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B42E                            
0001B42E 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0001B434 4A00                       		tst.b	d0			; check buffer to use
0001B436 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0001B438 D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0001B43C                            
0001B43C                            .gotbuffer
0001B43C 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0001B43E                            
0001B43E                            	StopZ80					; wait for Z80 to stop
0001B43E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B446                          M 	waitz80stop
0001B446 0839 0000 00A1 1100      M .wait_293:	btst	#0,z80_bus_req
0001B44E 66F6                     M 	bne.s	.wait_293
0001B450 50D0                       		st	(a0)			; make sure cue is marked as completed
0001B452                            	StartZ80				; enable Z80 execution
0001B452 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B45A                            
0001B45A                            dPaused:
0001B45A 4E75                       		rts
0001B45C                            ; ===========================================================================
0001B45C                            ; ---------------------------------------------------------------------------
0001B45C                            ; Main routine for updating the AMPS driver
0001B45C                            ; ---------------------------------------------------------------------------
0001B45C                            
0001B45C                            dUpdateAllAMPS:
0001B45C 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0001B460 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0001B464 6BF4                       		bmi.s	dPaused			; if yes, branch
0001B466                            ; ---------------------------------------------------------------------------
0001B466                            ; This is the new fading feature I created, to make custom fading
0001B466                            ; types easier to program. You can define series of 3 bytes, each
0001B466                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0001B466                            ; once per frame. If the first value in a frame is a command flag,
0001B466                            ; instead its code is executed. Additionally, no fade program may
0001B466                            ; appear before ROM offset $10000, or else it will never be executed.
0001B466                            ; ---------------------------------------------------------------------------
0001B466                            
0001B466 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001B46A 6700                       		beq.s	.chkregion		; branch if not
0001B46C                            
0001B46C 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0001B470 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0001B474                            
0001B474 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0001B476 7000                       		moveq	#0,d0
0001B478 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0001B47A 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0001B47C                            
0001B47C 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0001B480 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0001B484 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0001B488 6000                       		bra.s	.chkregion		; go check the region
0001B48A                            
0001B48A                            .nofadeend
0001B48A B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0001B48E 6700                       		beq.s	.fadedac		; if did not, branch
0001B490 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0001B494 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0001B498                            
0001B498                            .fadedac
0001B498 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0001B49A B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0001B49E 6700                       		beq.s	.fadepsg		; if did not, branch
0001B4A0 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0001B4A4                            
0001B4A4 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001B4A4                            	rept Mus_DAC				; do for all music DAC channels
0001B4A4                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4A4                            .ch =		.ch+cSize			; go to next channel
0001B4A4                            	endr
0001B4A4 8338 C4C4                M 	or.b	d1,.ch.w
0001B4A8 =FFFFC4F0                M .ch	=	.ch+csize
0001B4A8 8338 C4F0                M 	or.b	d1,.ch.w
0001B4AC =FFFFC51C                M .ch	=	.ch+csize
0001B4AC 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0001B4B0                            
0001B4B0                            .fadepsg
0001B4B0 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0001B4B2 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0001B4B6 6700                       		beq.s	.chkregion		; if did not, branch
0001B4B8 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0001B4BC                            
0001B4BC =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001B4BC                            	rept Mus_PSG				; do for all music PSG channels
0001B4BC                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4BC                            .ch =		.ch+cSize			; go to next channel
0001B4BC                            	endr
0001B4BC 8338 C5F8                M 	or.b	d1,.ch.w
0001B4C0 =FFFFC624                M .ch	=	.ch+csize
0001B4C0 8338 C624                M 	or.b	d1,.ch.w
0001B4C4 =FFFFC650                M .ch	=	.ch+csize
0001B4C4 8338 C650                M 	or.b	d1,.ch.w
0001B4C8 =FFFFC67C                M .ch	=	.ch+csize
0001B4C8                            
0001B4C8 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001B4C8                            	rept SFX_PSG				; do for all SFX PSG channels
0001B4C8                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4C8                            .ch =		.ch+cSizeSFX			; go to next channel
0001B4C8                            	endr
0001B4C8 8338 C6EC                M 	or.b	d1,.ch.w
0001B4CC =FFFFC708                M .ch	=	.ch+csizesfx
0001B4CC 8338 C708                M 	or.b	d1,.ch.w
0001B4D0 =FFFFC724                M .ch	=	.ch+csizesfx
0001B4D0 8338 C724                M 	or.b	d1,.ch.w
0001B4D4 =FFFFC740                M .ch	=	.ch+csizesfx
0001B4D4                            ; ---------------------------------------------------------------------------
0001B4D4                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0001B4D4                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0001B4D4                            ; on PAL systems. This will cause issues with some songs that rely on
0001B4D4                            ; game engine to seem "in sync". Because of that, I added a flag to
0001B4D4                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0001B4D4                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0001B4D4                            ; play at the exact right speed, instead of slightly too slow.
0001B4D4                            ; ---------------------------------------------------------------------------
0001B4D4                            
0001B4D4 0838 0006 C744             .chkregion	btst	#6,rHWVersion.w	; is this PAL system?
0001B4DA 6700                       		beq.s	.driver			; if not, branch
0001B4DC 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0001B4E0 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0001B4E2                            
0001B4E2 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0001B4E8 6600                       		bne.s	.nofix			; if yes, run music and SFX
0001B4EA 6100                       		bsr.s	.nosfx			; run the sound driver
0001B4EC                            
0001B4EC                            .nofix
0001B4EC 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0001B4F2                            .driver
0001B4F2 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0001B4F6                            
0001B4F6                            .nosfx		; continue to run sound driver again
0001B4F6                            ; ---------------------------------------------------------------------------
0001B4F6                            ; There are 2 methods of handling tempo adjustments in SMPS,
0001B4F6                            ; overflow (where a value is added to the accumulator, and when it
0001B4F6                            ; range overflows, tick of delay is added), and counter (where a
0001B4F6                            ; counter is copied to the tempo, which is then decreased each frame,
0001B4F6                            ; until it becomes 0, after which a tick of delay is added). AMPS
0001B4F6                            ; supports these both too, because there is no single right answer,
0001B4F6                            ; and users may prefer one over the other. The overflow method is
0001B4F6                            ; really good for low values, as it provides very fine control over
0001B4F6                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0001B4F6                            ; method isn't as good for small values, but for large value it works
0001B4F6                            ; better. You may choose this setting in the macro.asm file,
0001B4F6                            ; ---------------------------------------------------------------------------
0001B4F6                            
0001B4F6 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0001B4FA D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0001B4FE 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0001B500                            
0001B500                            
0001B500 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0001B500                            	rept Mus_Ch				; loop through all music channels
0001B500                            		addq.b	#1,.ch.w		; add 1 to duration
0001B500                            .ch =		.ch+cSize			; go to next channel
0001B500                            	endr
0001B500 5238 C4D0                M 	addq.b	#1,.ch.w
0001B504 =FFFFC4FC                M .ch	=	.ch+csize
0001B504 5238 C4FC                M 	addq.b	#1,.ch.w
0001B508 =FFFFC528                M .ch	=	.ch+csize
0001B508 5238 C528                M 	addq.b	#1,.ch.w
0001B50C =FFFFC554                M .ch	=	.ch+csize
0001B50C 5238 C554                M 	addq.b	#1,.ch.w
0001B510 =FFFFC580                M .ch	=	.ch+csize
0001B510 5238 C580                M 	addq.b	#1,.ch.w
0001B514 =FFFFC5AC                M .ch	=	.ch+csize
0001B514 5238 C5AC                M 	addq.b	#1,.ch.w
0001B518 =FFFFC5D8                M .ch	=	.ch+csize
0001B518 5238 C5D8                M 	addq.b	#1,.ch.w
0001B51C =FFFFC604                M .ch	=	.ch+csize
0001B51C 5238 C604                M 	addq.b	#1,.ch.w
0001B520 =FFFFC630                M .ch	=	.ch+csize
0001B520 5238 C630                M 	addq.b	#1,.ch.w
0001B524 =FFFFC65C                M .ch	=	.ch+csize
0001B524 5238 C65C                M 	addq.b	#1,.ch.w
0001B528 =FFFFC688                M .ch	=	.ch+csize
0001B528                            ; ===========================================================================
0001B528                            ; ---------------------------------------------------------------------------
0001B528                            ; Process music DAC channels
0001B528                            ; ---------------------------------------------------------------------------
0001B528                            
0001B528                            dAMPSdoAll:
0001B528 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B52C 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0001B530 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0001B532                            
0001B532                            dAMPSdoDAC:
0001B532 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0001B536 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B538 6A00 0000                  		bpl.w	.next			; if not, branch
0001B53C 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B540 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B544                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0001B544                          M 	dnotetouthandler
0001B544 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001B548 6700                     M 	beq.s	.endt
0001B54A 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001B54E 6600                     M 	bne.s	.endt
0001B550 7000                     M 	moveq	#0,d0
0001B552 6000 0000                M 	bra.w	dnoteondac2
0001B556                          M .endt
0001B556                            
0001B556                            	dCalcFreq				; calculate channel base frequency
0001B556 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B55A 4886                     M 	ext.w	d6
0001B55C DC6D 000E                M 	add.w	cfreq(a5),d6
0001B560                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0001B560 0815 0003                M 	btst	#cfbmod,(a5)
0001B564 6700                     M 	beq.s	.noret
0001B566 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B56A 6700                     M 	beq.s	.started
0001B56C 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B570                          M .noret
0001B570 0895 0005                M 	bclr	#cfbvol,(a5)
0001B574 6700                     M 	beq.s	.noupdatevol
0001B576 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B57A                          M 	.noupdatevol:
0001B57A 51CF FFB6                M 	dbf	d7,dampsdodac
0001B57E 6000 0000                M 	bra.w	dampsdofm
0001B582                          M .started
0001B582 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B586 66E8                     M 	bne.s	.noret
0001B588 226D 0010                M 	movea.l	cmod(a5),a1
0001B58C 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B592 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B596 6600                     M 	bne.s	.norev
0001B598 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B59E 442D 0017                M 	neg.b	cmodstep(a5)
0001B5A2                          M .norev
0001B5A2 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B5A6 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B5AA 4885                     M 	ext.w	d5
0001B5AC DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B5B0 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B5B4 DC45                     M 	add.w	d5,d6
0001B5B6 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0001B5BA                            
0001B5BA 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B5BE 6700                       		beq.s	.next			; if not, skip
0001B5C0 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0001B5C4                            
0001B5C4                            .next
0001B5C4 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B5C8 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0001B5CC                            
0001B5CC                            .update
0001B5CC 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B5D0                            	dDoTracker				; process tracker
0001B5D0 286D 0002                M 	movea.l	cdata(a5),a4
0001B5D4                          M .data
0001B5D4 7A00                     M 	moveq	#0,d5
0001B5D6 1A1C                     M 	move.b	(a4)+,d5
0001B5D8 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B5DC 6500                     M 	blo.s	.notcomm
0001B5DE 4EBA 0000                M 	jsr	dcommands(pc)
0001B5E2 60F0                     M 	bra.s	.data
0001B5E4 60DE                     M 	bra.s	.next
0001B5E6                          M .notcomm
0001B5E6 7C00                       		moveq	#0,d6			; clear rest flag
0001B5E8 4A05                       		tst.b	d5			; check if note is being played
0001B5EA 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B5EC                            
0001B5EC                            	dTrackNoteDAC				; calculate frequency or update sample
0001B5EC 0815 0000                M 	btst	#cfbmode,(a5)
0001B5F0 6600                     M 	bne.s	.pitch
0001B5F2 1B45 000B                M 	move.b	d5,csample(a5)
0001B5F6 6000                     M 	bra.s	.cont
0001B5F8                          M .pitch
0001B5F8 0405 0080                M 	subi.b	#$80,d5
0001B5FC 6600                     M 	bne.s	.noprest
0001B5FE 7000                     M 	moveq	#0,d0
0001B600 6100 0000                M 	bsr.w	dnoteondac2
0001B604 7C80                     M 	moveq	#-$80,d6
0001B606 6000                     M 	bra.s	.cont
0001B608                          M .noprest
0001B608 DA2D 0008                M 	add.b	cpitch(a5),d5
0001B60C DA45                     M 	add.w	d5,d5
0001B60E 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B612 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B618                          M .cont
0001B618 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B61A 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B61C 534C                       		subq.w	#1,a4			; else, undo the increment
0001B61E 6000                       		bra.s	.pcnote			; do not calculate duration
0001B620                            
0001B620                            .timer
0001B620 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0001B624                            .pcnote
0001B624                            	dProcNote 0, 0				; reset necessary channel memory
0001B624 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B628 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B62E 0815 0002                M 	btst	#cfbhold,(a5)
0001B632 6600                     M 	bne.s	.endpn
0001B634 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001B63A 0815 0003                M 	btst	#cfbmod,(a5)
0001B63E 6700                     M 	beq.s	.endpn
0001B640 226D 0010                M 	movea.l	cmod(a5),a1
0001B644 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B648 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B64C 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B650 1011                     M 	move.b	(a1),d0
0001B652 E208                     M 	lsr.b	#1,d0
0001B654 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B658 426D 0014                M 	clr.w	cmodfreq(a5)
0001B65C                          M .endpn
0001B65C                            
0001B65C 4A06                       		tst.b	d6			; check if channel was resting
0001B65E 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B660 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0001B662                            
0001B662 51CF FECE                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B666 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0001B66A                            ; ===========================================================================
0001B66A                            ; ---------------------------------------------------------------------------
0001B66A                            ; Write DAC sample information to Dual PCM
0001B66A                            ; ---------------------------------------------------------------------------
0001B66A                            
0001B66A                            dNoteOnDAC2:
0001B66A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B66E 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0001B670 4E75                       		rts
0001B672                            
0001B672                            dNoteOnDAC:
0001B672 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B676 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0001B678                            
0001B678 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B67A 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B67E 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B682 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001B686 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0001B68A                            
0001B68A                            dNoteOnDAC3:
0001B68A E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B68C 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0001B690                            
0001B690 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0001B694 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B69A 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0001B69C                            ; ---------------------------------------------------------------------------
0001B69C                            ; This code is for updating the note to Dual PCM. We have tracker commands
0001B69C                            ; for also playing notes on DAC channels, which is why the code seems a
0001B69C                            ; little weird.
0001B69C                            ; ---------------------------------------------------------------------------
0001B69C                            
0001B69C                            dNoteWriteDAC2:
0001B69C 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B6A2 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0001B6A8 6000                       		bra.s	dNoteOnDAC4
0001B6AA                            
0001B6AA                            dNoteWriteDAC1:
0001B6AA                            
0001B6AA 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0001B6B0 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0001B6B6                            
0001B6B6                            dNoteOnDAC4:
0001B6B6                            	StopZ80					; wait for Z80 to stop
0001B6B6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B6BE                          M 	waitz80stop
0001B6BE 0839 0000 00A1 1100      M .wait_303:	btst	#0,z80_bus_req
0001B6C6 66F6                     M 	bne.s	.wait_303
0001B6C8                            	rept 12
0001B6C8                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B6C8                            	endr
0001B6C8 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CA 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CC 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CE 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D0 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D2 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D4 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D6 12DB                     M 	move.b	(a3)+,(a1)+
0001B6D8 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DA 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DC 12DB                     M 	move.b	(a3)+,(a1)+
0001B6DE 12DB                     M 	move.b	(a3)+,(a1)+
0001B6E0                            
0001B6E0 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0001B6E4                            	StartZ80				; enable Z80 execution
0001B6E4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B6EC                            
0001B6EC                            locret_dNoteOnDAC4:
0001B6EC 4E75                       		rts
0001B6EE                            ; ===========================================================================
0001B6EE                            ; ---------------------------------------------------------------------------
0001B6EE                            ; Write DAC frequency to Dual PCM
0001B6EE                            ; ---------------------------------------------------------------------------
0001B6EE                            
0001B6EE                            dUpdateFreqOffDAC2:
0001B6EE E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B6F0 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0001B6F4                            
0001B6F4                            dUpdateFreqOffDAC:
0001B6F4 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001B6F8 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0001B6FA                            
0001B6FA 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0001B6FE 4880                       		ext.w	d0			; extend to word
0001B700 DC40                       		add.w	d0,d6			; add it to d6
0001B702                            
0001B702 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001B706 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0001B708 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001B70C 6000                       		bra.s	dUpdateFreqDAC3
0001B70E                            
0001B70E                            dUpdateFreqDAC:
0001B70E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B712 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0001B714                            
0001B714                            dUpdateFreqDAC2:
0001B714 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B716 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B71A 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B71E E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0001B720 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0001B724                            
0001B724                            dUpdateFreqDAC3:
0001B724                            
0001B724 1006                       		move.b	d6,d0			; copy the frequency to d0
0001B726 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0001B728 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0001B72E 6700                       		beq.s	dFreqDAC1		; if is, branch
0001B730                            
0001B730                            	StopZ80					; wait for Z80 to stop
0001B730 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B738                          M 	waitz80stop
0001B738 0839 0000 00A1 1100      M .wait_306:	btst	#0,z80_bus_req
0001B740 66F6                     M 	bne.s	.wait_306
0001B742 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0001B748 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0001B74E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B756                            	StartZ80				; enable Z80 execution
0001B756 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B75E                            
0001B75E                            locret_UpdFreqDAC;
0001B75E 4E75                       		rts
0001B760                            
0001B760                            dFreqDAC1:
0001B760                            	StopZ80					; wait for Z80 to stop
0001B760 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B768                          M 	waitz80stop
0001B768 0839 0000 00A1 1100      M .wait_309:	btst	#0,z80_bus_req
0001B770 66F6                     M 	bne.s	.wait_309
0001B772 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0001B778 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0001B77E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B786                            	StartZ80				; enable Z80 execution
0001B786 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B78E 4E75                       		rts
0001B790                            ; ===========================================================================
0001B790                            ; ---------------------------------------------------------------------------
0001B790                            ; Routine to multiply duration by tick rate
0001B790                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0001B790                            ; around the loop will be faster than a single mulu instruction
0001B790                            ; ---------------------------------------------------------------------------
0001B790                            
0001B790                            dCalcDuration:
0001B790 7000                       		moveq	#0,d0			; clear duration
0001B792 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0001B794 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0001B798                            
0001B798 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0001B79A 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0001B79E                            
0001B79E 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0001B7A2 4E75                       		rts				; get copied to duration by later code
0001B7A4                            ; ===========================================================================
0001B7A4                            ; ---------------------------------------------------------------------------
0001B7A4                            ; Process SFX DAC channels
0001B7A4                            ; ---------------------------------------------------------------------------
0001B7A4                            
0001B7A4                            dAMPSdoSFX:
0001B7A4 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0001B7A8                            
0001B7A8                            dAMPSdoDACSFX:
0001B7A8 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001B7AC 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B7AE 6A00                       		bpl.s	.next			; if not, branch
0001B7B0                            
0001B7B0 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B7B4 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B7B8 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B7BC                            
0001B7BC                            	dCalcFreq				; calculate channel base frequency
0001B7BC 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B7C0 4886                     M 	ext.w	d6
0001B7C2 DC6D 000E                M 	add.w	cfreq(a5),d6
0001B7C6                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0001B7C6 0815 0003                M 	btst	#cfbmod,(a5)
0001B7CA 6700                     M 	beq.s	.noret
0001B7CC 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B7D0 6700                     M 	beq.s	.started
0001B7D2 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B7D6                          M .noret
0001B7D6 0895 0005                M 	bclr	#cfbvol,(a5)
0001B7DA 6700                     M 	beq.s	.noupdatevol
0001B7DC 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B7E0                          M 	.noupdatevol:
0001B7E0 6000 0000                M 	bra.w	dampsdofmsfx
0001B7E4                          M .started
0001B7E4 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B7E8 66EC                     M 	bne.s	.noret
0001B7EA 226D 0010                M 	movea.l	cmod(a5),a1
0001B7EE 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B7F4 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B7F8 6600                     M 	bne.s	.norev
0001B7FA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B800 442D 0017                M 	neg.b	cmodstep(a5)
0001B804                          M .norev
0001B804 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B808 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B80C 4885                     M 	ext.w	d5
0001B80E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B812 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B816 DC45                     M 	add.w	d5,d6
0001B818 6100 FEFA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0001B81C                            
0001B81C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B820 6700                       		beq.s	.next			; if not, skip
0001B822 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0001B826                            
0001B826                            .next
0001B826 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B82A                            
0001B82A                            .update
0001B82A 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B82E                            	dDoTracker				; process tracker
0001B82E 286D 0002                M 	movea.l	cdata(a5),a4
0001B832                          M .data
0001B832 7A00                     M 	moveq	#0,d5
0001B834 1A1C                     M 	move.b	(a4)+,d5
0001B836 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B83A 6500                     M 	blo.s	.notcomm
0001B83C 4EBA 0000                M 	jsr	dcommands(pc)
0001B840 60F0                     M 	bra.s	.data
0001B842 60E2                     M 	bra.s	.next
0001B844                          M .notcomm
0001B844 7C00                       		moveq	#0,d6			; clear rest flag
0001B846 4A05                       		tst.b	d5			; check if note is being played
0001B848 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B84A                            
0001B84A                            	dTrackNoteDAC				; calculate frequency or update sample
0001B84A 0815 0000                M 	btst	#cfbmode,(a5)
0001B84E 6600                     M 	bne.s	.pitch
0001B850 1B45 000B                M 	move.b	d5,csample(a5)
0001B854 6000                     M 	bra.s	.cont
0001B856                          M .pitch
0001B856 0405 0080                M 	subi.b	#$80,d5
0001B85A 6600                     M 	bne.s	.noprest
0001B85C 7000                     M 	moveq	#0,d0
0001B85E 6100 FE0A                M 	bsr.w	dnoteondac2
0001B862 7C80                     M 	moveq	#-$80,d6
0001B864 6000                     M 	bra.s	.cont
0001B866                          M .noprest
0001B866 DA2D 0008                M 	add.b	cpitch(a5),d5
0001B86A DA45                     M 	add.w	d5,d5
0001B86C 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B870 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B876                          M .cont
0001B876 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B878 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B87A 534C                       		subq.w	#1,a4			; else, undo the increment
0001B87C 6000                       		bra.s	.pcnote			; do not calculate duration
0001B87E                            
0001B87E                            .timer
0001B87E 4EBA FF10                  		jsr	dCalcDuration(pc)	; calculate duration
0001B882                            .pcnote
0001B882                            	dProcNote 1, 0				; reset necessary channel memory
0001B882 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B886 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B88C 0815 0002                M 	btst	#cfbhold,(a5)
0001B890 6600                     M 	bne.s	.endpn
0001B892 0815 0003                M 	btst	#cfbmod,(a5)
0001B896 6700                     M 	beq.s	.endpn
0001B898 226D 0010                M 	movea.l	cmod(a5),a1
0001B89C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B8A0 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B8A4 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B8A8 1011                     M 	move.b	(a1),d0
0001B8AA E208                     M 	lsr.b	#1,d0
0001B8AC 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B8B0 426D 0014                M 	clr.w	cmodfreq(a5)
0001B8B4                          M .endpn
0001B8B4 4A06                       		tst.b	d6			; check if channel was resting
0001B8B6 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B8B8 6100 FDB8                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0001B8BC                            
0001B8BC                            .noplay
0001B8BC 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B8C0                            ; ===========================================================================
0001B8C0                            ; ---------------------------------------------------------------------------
0001B8C0                            ; Write DAC volume to Dual PCM
0001B8C0                            ; ---------------------------------------------------------------------------
0001B8C0                            
0001B8C0                            dUpdateVolDAC:
0001B8C0 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B8C4 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0001B8C6                            
0001B8C6                            dUpdateVolDAC2:
0001B8C6 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0001B8CA D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0001B8CE 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0001B8D0 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0001B8D2                            
0001B8D2                            .gotvol
0001B8D2                            	StopZ80					; wait for Z80 to stop
0001B8D2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B8DA                          M 	waitz80stop
0001B8DA 0839 0000 00A1 1100      M .wait_317:	btst	#0,z80_bus_req
0001B8E2 66F6                     M 	bne.s	.wait_317
0001B8E4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0001B8EC                            
0001B8EC 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B8F2 6700                       		beq.s	.dac1			; if is, branch
0001B8F4 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0001B8FA                            	StartZ80				; enable Z80 execution
0001B8FA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B902 4E75                       		rts
0001B904                            
0001B904                            .dac1
0001B904 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0001B90A                            	StartZ80				; enable Z80 execution
0001B90A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B912                            
0001B912                            locret_VolDAC:
0001B912 4E75                       		rts
0001B914                            ; ===========================================================================
0001B914                            ; ---------------------------------------------------------------------------
0001B914                            ; Routine for unpausing the sound driver
0001B914                            ; ---------------------------------------------------------------------------
0001B914                            
0001B914                            dPlaySnd_Unpause:
0001B914 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0001B91A 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0001B91C                            ; ---------------------------------------------------------------------------
0001B91C                            ; The following code will reset the panning values for each running
0001B91C                            ; channel. It also makes sure that the channel is not interrupted
0001B91C                            ; by sound effects, and that each running sound effect channel gets
0001B91C                            ; updated. We do not handle key on's, since that could potentially
0001B91C                            ; cause issues if notes are half-done. The next time tracker plays
0001B91C                            ; notes, they start being audible again.
0001B91C                            ; ---------------------------------------------------------------------------
0001B91C                            
0001B91C 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001B920 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0001B922 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0001B924                            
0001B924                            .musloop
0001B924 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B926 6A00                       		bpl.s	.skipmus		; if not, do not update
0001B928 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B92C 6600                       		bne.s	.skipmus		; if is, do not update
0001B92E                            
0001B92E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B930 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B934 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B938                            
0001B938                            .skipmus
0001B938 DAC3                       		adda.w	d3,a5			; go to next channel
0001B93A 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0001B93E                            
0001B93E 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0001B942 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0001B944 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0001B946                            
0001B946                            .sfxloop
0001B946 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B948 6A00                       		bpl.s	.skipsfx		; if not, do not update
0001B94A                            
0001B94A 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B94C 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B950 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B954                            
0001B954                            .skipsfx
0001B954 DAC3                       		adda.w  d3,a5			; go to next channel
0001B956 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0001B95A                            ; ---------------------------------------------------------------------------
0001B95A                            ; Since the DAC channels have or based panning behavior, we need this
0001B95A                            ; piece of code to update its panning
0001B95A                            ; ---------------------------------------------------------------------------
0001B95A                            
0001B95A 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001B95E 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001B964 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001B966 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001B96A                            
0001B96A                            .nodacsfx
0001B96A 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001B96E 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001B970 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001B974                            ; ===========================================================================
0001B974                            ; ---------------------------------------------------------------------------
0001B974                            ; Routine for pausing the sound driver
0001B974                            ; ---------------------------------------------------------------------------
0001B974                            
0001B974                            dPlaySnd_Pause:
0001B974 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0001B97A 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0001B97C                            ; ---------------------------------------------------------------------------
0001B97C                            ; The following code will set channel panning to none for all FM channels.
0001B97C                            ; This will ensure they are muted while we are pausing.
0001B97C                            ; ---------------------------------------------------------------------------
0001B97C                            
0001B97C 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0001B97E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B980 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0001B982                            
0001B982                            .muteFM
0001B982 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B986 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001B98A 5200                       		addq.b	#1,d0			; go to next FM channel
0001B98C 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0001B990                            ; ---------------------------------------------------------------------------
0001B990                            ; The following code will key off all FM channels. There is a special
0001B990                            ; behavior in that, we must write all channels into part 1, and we
0001B990                            ; control the channel we are writing in the data portion.
0001B990                            ; 4 bits are reserved for which operators are active (in this case,
0001B990                            ; none), and 3 bits are reserved for the channel we want to affect.
0001B990                            ; ---------------------------------------------------------------------------
0001B990                            
0001B990 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001B992 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001B994                            
0001B994                            .note
0001B994 1203                       		move.b	d3,d1			; copy value into d1
0001B996 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B99A 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001B99C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001B9A0 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0001B9A4                            
0001B9A4 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0001B9A8                            	; continue to mute all DAC channels
0001B9A8                            ; ===========================================================================
0001B9A8                            ; ---------------------------------------------------------------------------
0001B9A8                            ; Routine for muting all DAC channels
0001B9A8                            ; ---------------------------------------------------------------------------
0001B9A8                            
0001B9A8                            dMuteDAC:
0001B9A8                            	StopZ80					; wait for Z80 to stop
0001B9A8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B9B0                          M 	waitz80stop
0001B9B0 0839 0000 00A1 1100      M .wait_321:	btst	#0,z80_bus_req
0001B9B8 66F6                     M 	bne.s	.wait_321
0001B9BA 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9BE 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0001B9C4                            
0001B9C4                            	rept 12
0001B9C4                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9C4                            	endr
0001B9C4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9CE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9D8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DC                            
0001B9DC 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B9E4                            
0001B9E4 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9E8 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0001B9EE                            
0001B9EE                            	rept 12
0001B9EE                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9EE                            	endr
0001B9EE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9FE 12DA                     M 	move.b	(a2)+,(a1)+
0001BA00 12DA                     M 	move.b	(a2)+,(a1)+
0001BA02 12DA                     M 	move.b	(a2)+,(a1)+
0001BA04 12DA                     M 	move.b	(a2)+,(a1)+
0001BA06                            
0001BA06 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001BA0E                            	StartZ80				; enable Z80 execution
0001BA0E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BA16                            
0001BA16                            locret_MuteDAC:
0001BA16 4E75                       		rts
0001BA18                            ; ===========================================================================
0001BA18                            ; ---------------------------------------------------------------------------
0001BA18                            ; Subroutine to play any queued music tracks, sound effects or commands
0001BA18                            ; ---------------------------------------------------------------------------
0001BA18                            
0001BA18                            dPlaySnd:
0001BA18 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0001BA1C 7E00                       		moveq	#0,d7
0001BA1E 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA20 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA22 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA24 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA26 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA28 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0001BA2A                            
0001BA2A                            .found
0001BA2A 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0001BA2E 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0001BA32 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0001BA36 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0001BA3A 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0001BA3E                            	; it was music, handle it below
0001BA3E                            ; ===========================================================================
0001BA3E                            ; ---------------------------------------------------------------------------
0001BA3E                            ; Subroutine to play a queued music track
0001BA3E                            ; ---------------------------------------------------------------------------
0001BA3E                            
0001BA3E                            dPlaySnd_Music:
0001BA3E 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0001BA42 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0001BA46                            ; ---------------------------------------------------------------------------
0001BA46                            ; To save few cycles, we don't directly substract the music offset from
0001BA46                            ; the ID, and instead offset the table position. In practice this will
0001BA46                            ; have the same effect, but saves us 8 cycles overall.
0001BA46                            ; ---------------------------------------------------------------------------
0001BA46                            
0001BA46 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0001BA4A DE47                       		add.w	d7,d7			; quadruple music ID
0001BA4C DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BA4E 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0001BA54 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0001BA58                            
0001BA58                            
0001BA58 264C                       		move.l	a4,a3			; copy pointer to a3
0001BA5A 584C                       		addq.w	#4,a4			; go to DAC1 data section
0001BA5C                            
0001BA5C 7000                       		moveq	#0,d0
0001BA5E 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0001BA62 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0001BA66 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0001BA6C 6700                       		beq.s	.tempogot		; if not, use main tempo
0001BA6E 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0001BA72                            
0001BA72                            .tempogot
0001BA72 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0001BA76 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0001BA7A 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0001BA80                            ; ---------------------------------------------------------------------------
0001BA80                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0001BA80                            ; disabled. I know, very weird place to put it, but we dont have
0001BA80                            ; much free room in the song header
0001BA80                            ; ---------------------------------------------------------------------------
0001BA80                            
0001BA80 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0001BA82 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0001BA84 0244 007F                  		and.w	#$7F,d4			; keep value in range
0001BA88 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0001BA8E                            
0001BA8E                            .noPAL
0001BA8E 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0001BA90 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0001BA92 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0001BA94 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0001BA96                            
0001BA96 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0001BA9A 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0001BA9E 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0001BAA0 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0001BAA4                            
0001BAA4                            .loopDAC
0001BAA4 1282                       		move.b	d2,(a1)			; save channel flags
0001BAA6 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BAAA 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BAAE 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BAB2 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAB6 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BABA 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0001BABE                            
0001BABE 7000                       		moveq	#0,d0
0001BAC0 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BAC2 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BAC4 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BAC8                            
0001BAC8 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0001BACC 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0001BAD0 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0001BAD2 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0001BAD6                            
0001BAD6                            .sampmode
0001BAD6 D2C6                       		add.w	d6,a1			; go to the next channel
0001BAD8 51CF FFCA                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0001BADC                            
0001BADC 7E00                       		moveq	#0,d7
0001BADE 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0001BAE0 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0001BAE4 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0001BAE6                            
0001BAE6                            .loopFM
0001BAE6 1282                       		move.b	d2,(a1)			; save channel flags
0001BAE8 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BAEC 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BAF0 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BAF4 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAF8 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BAFC                            
0001BAFC 7000                       		moveq	#0,d0
0001BAFE 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BB00 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BB02 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BB06                            
0001BB06 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BB0A D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB0C 51CF FFD8                  		dbf	d7,.loopFM		; repeat for all FM channels
0001BB10                            
0001BB10                            .doPSG
0001BB10 7E00                       		moveq	#0,d7
0001BB12 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0001BB16 6B00                       		bmi.s	.intSFX			; if no PSG channels are loaded, branch
0001BB18                            ; ---------------------------------------------------------------------------
0001BB18                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BB18                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BB18                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BB18                            ; is controlled by the 68000, we would be off by a single frame without
0001BB18                            ; this fix.
0001BB18                            ; ---------------------------------------------------------------------------
0001BB18                            
0001BB18 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0001BB1A 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0001BB1E 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0001BB22                            
0001BB22                            .loopPSG
0001BB22 1282                       		move.b	d2,(a1)			; save channel flags
0001BB24 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BB28 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BB2C 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BB30 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BB34                            
0001BB34 7000                       		moveq	#0,d0
0001BB36 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BB38 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BB3A 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BB3E                            
0001BB3E 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BB42 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0001BB46 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0001BB4A D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB4C 51CF FFD4                  		dbf	d7,.loopPSG		; repeat for all FM channels
0001BB50                            
0001BB50                            .intSFX
0001BB50                            ; ---------------------------------------------------------------------------
0001BB50                            ; Now follows initializing FM6 to be ready for PCM streaming,
0001BB50                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0001BB50                            ; clears some YM registers.
0001BB50                            ; ---------------------------------------------------------------------------
0001BB50                            
0001BB50 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BB52 7206                       		moveq	#6,d1			; FM6, all operators off
0001BB54 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BB58                            
0001BB58 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BB5A 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0001BB5C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB60 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0001BB62 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB66 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0001BB68 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB6C 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0001BB6E 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB72                            
0001BB72 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BB74 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001BB76 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB7A                            
0001BB7A 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0001BB7E 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0001BB82                            ; ---------------------------------------------------------------------------
0001BB82                            ; This piece of code here handles SFX overriding our newly loaded
0001BB82                            ; music channels. Since we did not do this at the initialization
0001BB82                            ; step, we will handle it here instead.
0001BB82                            ; ---------------------------------------------------------------------------
0001BB82                            
0001BB82 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0001BB86 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0001BB8A 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0001BB8C 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BB8E                            
0001BB8E                            .loopSFX
0001BB8E 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0001BB90 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0001BB92                            
0001BB92 7000                       		moveq	#0,d0
0001BB94 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0001BB98 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0001BB9A                            
0001BB9A 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0001BB9E 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0001BBA0 D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0001BBA2 6000                       		bra.s	.override
0001BBA4                            ; ---------------------------------------------------------------------------
0001BBA4                            
0001BBA4                            .SFXPSG
0001BBA4 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0001BBA6                            .override
0001BBA6 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0001BBAA 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0001BBAE                            
0001BBAE                            .nextSFX
0001BBAE D2C6                       		adda.w	d6,a1			; go to the next channel
0001BBB0 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0001BBB4                            ; ---------------------------------------------------------------------------
0001BBB4                            ; Here we mute all non-interrupted FM and PSG channels
0001BBB4                            ; ---------------------------------------------------------------------------
0001BBB4                            
0001BBB4 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001BBB8 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0001BBBA                            .stopFM
0001BBBA 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0001BBBE DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBC0 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0001BBC4                            
0001BBC4 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0001BBC6                            .mutePSG
0001BBC6 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0001BBCA DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBCC 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0001BBD0 4E75                       		rts
0001BBD2                            
0001BBD2                            ; ===========================================================================
0001BBD2                            ; ---------------------------------------------------------------------------
0001BBD2                            ; Type values for different channels. Used for playing music
0001BBD2                            ; ---------------------------------------------------------------------------
0001BBD2 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0001BBD4 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0001BBD9 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0001BBDC                            		even
0001BBDC                            ; ===========================================================================
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            ; Subroutine to play a queued sound effect
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            
0001BBDC                            dPlaySnd_SFX:
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            ; This is a little special case with Sonic 1 - 3K, where the ring
0001BBDC                            ; sound effect would change panning each time it is played. AMPS
0001BBDC                            ; emulates this behavior like the original drivers did, by
0001BBDC                            ; playing a different sound effect ID.
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            
0001BBDC                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0001BBDC                            		;bne.s	.noring			; if not, skip
0001BBDC                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0001BBDC                            		;beq.s	.noring			; if was not, do not change sound effect
0001BBDC                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            ; To save few cycles, we don't directly substract the SFX offset from
0001BBDC                            ; the ID, and instead offset the table position. In practice this will
0001BBDC                            ; have the same effect, but saves us 8 cycles overall.
0001BBDC                            ; ---------------------------------------------------------------------------
0001BBDC                            
0001BBDC                            .noring
0001BBDC 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0001BBE0 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0001BBE2 DE47                       		add.w	d7,d7			; quadruple sfx ID
0001BBE4 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BBE6 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0001BBEA                            
0001BBEA                            ; ---------------------------------------------------------------------------
0001BBEA                            ; Continous SFX is a very special type of sound effect. Unlike other
0001BBEA                            ; sound effects, when a continous SFX is played, it will run a loop
0001BBEA                            ; again, until it is no longer queued. This is very useful for sound
0001BBEA                            ; effects that need to be queued very often, but that really do not
0001BBEA                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0001BBEA                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0001BBEA                            ; but the code was not quite as matured as this here. Only one continous
0001BBEA                            ; SFX may be running at once, when other type is loaded, the earlier one
0001BBEA                            ; is stopped and replaced.
0001BBEA                            ; ---------------------------------------------------------------------------
0001BBEA                            
0001BBEA 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0001BBEE 6A00                       		bpl.s	.nocont			; if not, skip
0001BBF0 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0001BBF6 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0001BBFA 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0001BBFC 4E75                       		rts
0001BBFE                            
0001BBFE                            .setcont
0001BBFE 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0001BC02                            .nocont
0001BC02 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0001BC04                            
0001BC04 7E00                       		moveq	#0,d7
0001BC06 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0001BC0A 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0001BC0E 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0001BC10 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0001BC12 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BC14                            ; ---------------------------------------------------------------------------
0001BC14                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BC14                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BC14                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BC14                            ; is controlled by the 68000, we would be off by a single frame without
0001BC14                            ; this fix.
0001BC14                            ; ---------------------------------------------------------------------------
0001BC14                            
0001BC14                            .loopSFX
0001BC14 7600                       		moveq	#0,d3
0001BC16 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0001BC18 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0001BC1C 1803                       		move.b	d3,d4			; copy type to d4
0001BC1E 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0001BC20                            
0001BC20 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001BC24 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001BC26 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001BC28                            
0001BC28 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC2C BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC30 6500                       		blo.s	.skip			; if not, we can not override it
0001BC32                            
0001BC32 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC36 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC3A 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0001BC3C 6000                       		bra.s	.clearCh
0001BC3E                            ; ---------------------------------------------------------------------------
0001BC3E                            
0001BC3E                            .skip
0001BC3E 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0001BC40 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BC44 4E75                       		rts
0001BC46                            ; ---------------------------------------------------------------------------
0001BC46                            
0001BC46                            .chPSG
0001BC46 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0001BC48 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC4C BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC50 65EC                       		blo.s	.skip			; if not, we can not override it
0001BC52                            
0001BC52 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC56 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC5A 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0001BC5E 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0001BC64                            
0001BC64 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0001BC68 6600                       		bne.s	.clearCh		; if not, skip
0001BC6A 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0001BC72                            
0001BC72                            .clearCh
0001BC72 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0001BC74 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0001BC76                            .clear
0001BC76 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0001BC78 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0001BC7C                            
0001BC7C                            
0001BC7C 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0001BC7E 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0001BC82 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0001BC86                            
0001BC86 7000                       		moveq	#0,d0
0001BC88 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0001BC8A D08C                       		add.l	a4,d0			; add music header offset to d0
0001BC8C 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0001BC90                            
0001BC90 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0001BC94 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0001BC96 6B00                       		bmi.s	.loop			; if is, skip over this
0001BC98                            
0001BC98 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BC9A 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0001BC9E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BCA0 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0001BCA4                            
0001BCA4 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0001BCA8 6600                       		bne.s	.fm			; if not, branch
0001BCAA 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0001BCB0                            
0001BCB0                            .loop
0001BCB0 51CF FF62                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BCB4 4E75                       		rts
0001BCB6                            ; ---------------------------------------------------------------------------
0001BCB6                            ; The instant release for FM channels behavior was not in the Sonic 1
0001BCB6                            ; SMPS driver by default, but it has been added since it fixes an
0001BCB6                            ; issue with YM2612, where sometimes subsequent sound effect activations
0001BCB6                            ; would sound different over time. This fix will help to mitigate that.
0001BCB6                            ; ---------------------------------------------------------------------------
0001BCB6                            
0001BCB6                            .fm
0001BCB6 720F                       		moveq	#$F,d1			; set to release note instantly
0001BCB8 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0001BCBA 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCBE 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0001BCC0 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCC4 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0001BCC6 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCCA 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0001BCCC 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCD0                            
0001BCD0 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BCD2 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0001BCD6 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0001BCDA                            
0001BCDA 51CF FF38                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BCDE 4E75                       		rts
0001BCE0                            ; ===========================================================================
0001BCE0                            ; ---------------------------------------------------------------------------
0001BCE0                            ; pointers for music channels SFX can override and addresses of SFX channels
0001BCE0                            ; ---------------------------------------------------------------------------
0001BCE0                            
0001BCE0 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0001BCE2 C67C                       		dc.w mSFXDAC1			; DAC1
0001BCE4 C6B4                       		dc.w mSFXFM4			; FM4
0001BCE6 C6D0                       		dc.w mSFXFM5			; FM5
0001BCE8 C6EC                       		dc.w mSFXPSG1			; PSG1
0001BCEA C708                       		dc.w mSFXPSG2			; PSG2
0001BCEC C724                       		dc.w mSFXPSG3			; PSG3
0001BCEE C724                       		dc.w mSFXPSG3			; PSG4
0001BCF0                            
0001BCF0 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0001BCF2 C4C4                       		dc.w mDAC1			; SFX DAC1
0001BCF4 C5A0                       		dc.w mFM4			; SFX FM4
0001BCF6 C5CC                       		dc.w mFM5			; SFX FM5
0001BCF8 C5F8                       		dc.w mPSG1			; SFX PSG1
0001BCFA C624                       		dc.w mPSG2			; SFX PSG2
0001BCFC C650                       		dc.w mPSG3			; SFX PSG3
0001BCFE C650                       		dc.w mPSG3			; SFX PSG4
0001BD00                            ; ===========================================================================
0001BD00                            ; ---------------------------------------------------------------------------
0001BD00                            ; Play queued command
0001BD00                            ; ---------------------------------------------------------------------------
0001BD00                            
0001BD00                            dPlaySnd_Comm:
0001BD00                            
0001BD00 DE47                       		add.w	d7,d7			; quadruple ID
0001BD02 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0001BD04 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0001BD08                            
0001BD08                            ; ---------------------------------------------------------------------------
0001BD08                            dSoundCommands:
0001BD08 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0001BD0C 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0001BD10 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0001BD14 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0001BD18 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0001BD1C 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0001BD20 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0001BD24 6000 FC4E                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0001BD28 6000 FBEA                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0001BD2C                            dSoundCommands_End:
0001BD2C                            ; ===========================================================================
0001BD2C                            ; ---------------------------------------------------------------------------
0001BD2C                            ; Commands for what to do after a volume fade
0001BD2C                            ; ---------------------------------------------------------------------------
0001BD2C                            
0001BD2C                            dFadeCommands:
0001BD2C 4E75                       		rts				; 80 - Do nothing
0001BD2E 4E75                       		rts
0001BD30 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0001BD32 4E75                       		rts
0001BD34 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0001BD38 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0001BD3A 60F4                       		bra.s	.stop
0001BD3C                            ; ===========================================================================
0001BD3C                            ; ---------------------------------------------------------------------------
0001BD3C                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0001BD3C                            ; ---------------------------------------------------------------------------
0001BD3C                            
0001BD3C                            dPlaySnd_Stop:
0001BD3C                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0001BD3C                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0001BD3C                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD3C                            
0001BD3C 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0001BD3E 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0001BD40 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD44                            
0001BD44 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0001BD48                            
0001BD48                            	rept (mSize-mSFXDAC1)/4
0001BD48                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0001BD48                            	endr
0001BD48 4299                     M 	clr.l	(a1)+
0001BD4A 4299                     M 	clr.l	(a1)+
0001BD4C 4299                     M 	clr.l	(a1)+
0001BD4E 4299                     M 	clr.l	(a1)+
0001BD50 4299                     M 	clr.l	(a1)+
0001BD52 4299                     M 	clr.l	(a1)+
0001BD54 4299                     M 	clr.l	(a1)+
0001BD56 4299                     M 	clr.l	(a1)+
0001BD58 4299                     M 	clr.l	(a1)+
0001BD5A 4299                     M 	clr.l	(a1)+
0001BD5C 4299                     M 	clr.l	(a1)+
0001BD5E 4299                     M 	clr.l	(a1)+
0001BD60 4299                     M 	clr.l	(a1)+
0001BD62 4299                     M 	clr.l	(a1)+
0001BD64 4299                     M 	clr.l	(a1)+
0001BD66 4299                     M 	clr.l	(a1)+
0001BD68 4299                     M 	clr.l	(a1)+
0001BD6A 4299                     M 	clr.l	(a1)+
0001BD6C 4299                     M 	clr.l	(a1)+
0001BD6E 4299                     M 	clr.l	(a1)+
0001BD70 4299                     M 	clr.l	(a1)+
0001BD72 4299                     M 	clr.l	(a1)+
0001BD74 4299                     M 	clr.l	(a1)+
0001BD76 4299                     M 	clr.l	(a1)+
0001BD78 4299                     M 	clr.l	(a1)+
0001BD7A 4299                     M 	clr.l	(a1)+
0001BD7C 4299                     M 	clr.l	(a1)+
0001BD7E 4299                     M 	clr.l	(a1)+
0001BD80 4299                     M 	clr.l	(a1)+
0001BD82 4299                     M 	clr.l	(a1)+
0001BD84 4299                     M 	clr.l	(a1)+
0001BD86 4299                     M 	clr.l	(a1)+
0001BD88 4299                     M 	clr.l	(a1)+
0001BD8A 4299                     M 	clr.l	(a1)+
0001BD8C 4299                     M 	clr.l	(a1)+
0001BD8E 4299                     M 	clr.l	(a1)+
0001BD90 4299                     M 	clr.l	(a1)+
0001BD92 4299                     M 	clr.l	(a1)+
0001BD94 4299                     M 	clr.l	(a1)+
0001BD96 4299                     M 	clr.l	(a1)+
0001BD98 4299                     M 	clr.l	(a1)+
0001BD9A 4299                     M 	clr.l	(a1)+
0001BD9C 4299                     M 	clr.l	(a1)+
0001BD9E 4299                     M 	clr.l	(a1)+
0001BDA0 4299                     M 	clr.l	(a1)+
0001BDA2 4299                     M 	clr.l	(a1)+
0001BDA4 4299                     M 	clr.l	(a1)+
0001BDA6 4299                     M 	clr.l	(a1)+
0001BDA8 4299                     M 	clr.l	(a1)+
0001BDAA                            
0001BDAA                            	; continue straight to stopping music
0001BDAA                            ; ===========================================================================
0001BDAA                            ; ---------------------------------------------------------------------------
0001BDAA                            ; Stop music from playing, reset driver memory and mute hardware
0001BDAA                            ; ---------------------------------------------------------------------------
0001BDAA                            
0001BDAA                            dStopMusic:
0001BDAA 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0001BDAE 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0001BDB0 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0001BDB4 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0001BDB8 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0001BDBE                            
0001BDBE                            	rept (mSFXDAC1-mFlags)/4
0001BDBE                            		clr.l	(a1)+			; clear driver and music channel memory
0001BDBE                            	endr
0001BDBE 4299                     M 	clr.l	(a1)+
0001BDC0 4299                     M 	clr.l	(a1)+
0001BDC2 4299                     M 	clr.l	(a1)+
0001BDC4 4299                     M 	clr.l	(a1)+
0001BDC6 4299                     M 	clr.l	(a1)+
0001BDC8 4299                     M 	clr.l	(a1)+
0001BDCA 4299                     M 	clr.l	(a1)+
0001BDCC 4299                     M 	clr.l	(a1)+
0001BDCE 4299                     M 	clr.l	(a1)+
0001BDD0 4299                     M 	clr.l	(a1)+
0001BDD2 4299                     M 	clr.l	(a1)+
0001BDD4 4299                     M 	clr.l	(a1)+
0001BDD6 4299                     M 	clr.l	(a1)+
0001BDD8 4299                     M 	clr.l	(a1)+
0001BDDA 4299                     M 	clr.l	(a1)+
0001BDDC 4299                     M 	clr.l	(a1)+
0001BDDE 4299                     M 	clr.l	(a1)+
0001BDE0 4299                     M 	clr.l	(a1)+
0001BDE2 4299                     M 	clr.l	(a1)+
0001BDE4 4299                     M 	clr.l	(a1)+
0001BDE6 4299                     M 	clr.l	(a1)+
0001BDE8 4299                     M 	clr.l	(a1)+
0001BDEA 4299                     M 	clr.l	(a1)+
0001BDEC 4299                     M 	clr.l	(a1)+
0001BDEE 4299                     M 	clr.l	(a1)+
0001BDF0 4299                     M 	clr.l	(a1)+
0001BDF2 4299                     M 	clr.l	(a1)+
0001BDF4 4299                     M 	clr.l	(a1)+
0001BDF6 4299                     M 	clr.l	(a1)+
0001BDF8 4299                     M 	clr.l	(a1)+
0001BDFA 4299                     M 	clr.l	(a1)+
0001BDFC 4299                     M 	clr.l	(a1)+
0001BDFE 4299                     M 	clr.l	(a1)+
0001BE00 4299                     M 	clr.l	(a1)+
0001BE02 4299                     M 	clr.l	(a1)+
0001BE04 4299                     M 	clr.l	(a1)+
0001BE06 4299                     M 	clr.l	(a1)+
0001BE08 4299                     M 	clr.l	(a1)+
0001BE0A 4299                     M 	clr.l	(a1)+
0001BE0C 4299                     M 	clr.l	(a1)+
0001BE0E 4299                     M 	clr.l	(a1)+
0001BE10 4299                     M 	clr.l	(a1)+
0001BE12 4299                     M 	clr.l	(a1)+
0001BE14 4299                     M 	clr.l	(a1)+
0001BE16 4299                     M 	clr.l	(a1)+
0001BE18 4299                     M 	clr.l	(a1)+
0001BE1A 4299                     M 	clr.l	(a1)+
0001BE1C 4299                     M 	clr.l	(a1)+
0001BE1E 4299                     M 	clr.l	(a1)+
0001BE20 4299                     M 	clr.l	(a1)+
0001BE22 4299                     M 	clr.l	(a1)+
0001BE24 4299                     M 	clr.l	(a1)+
0001BE26 4299                     M 	clr.l	(a1)+
0001BE28 4299                     M 	clr.l	(a1)+
0001BE2A 4299                     M 	clr.l	(a1)+
0001BE2C 4299                     M 	clr.l	(a1)+
0001BE2E 4299                     M 	clr.l	(a1)+
0001BE30 4299                     M 	clr.l	(a1)+
0001BE32 4299                     M 	clr.l	(a1)+
0001BE34 4299                     M 	clr.l	(a1)+
0001BE36 4299                     M 	clr.l	(a1)+
0001BE38 4299                     M 	clr.l	(a1)+
0001BE3A 4299                     M 	clr.l	(a1)+
0001BE3C 4299                     M 	clr.l	(a1)+
0001BE3E 4299                     M 	clr.l	(a1)+
0001BE40 4299                     M 	clr.l	(a1)+
0001BE42 4299                     M 	clr.l	(a1)+
0001BE44 4299                     M 	clr.l	(a1)+
0001BE46 4299                     M 	clr.l	(a1)+
0001BE48 4299                     M 	clr.l	(a1)+
0001BE4A 4299                     M 	clr.l	(a1)+
0001BE4C 4299                     M 	clr.l	(a1)+
0001BE4E 4299                     M 	clr.l	(a1)+
0001BE50 4299                     M 	clr.l	(a1)+
0001BE52 4299                     M 	clr.l	(a1)+
0001BE54 4299                     M 	clr.l	(a1)+
0001BE56 4299                     M 	clr.l	(a1)+
0001BE58 4299                     M 	clr.l	(a1)+
0001BE5A 4299                     M 	clr.l	(a1)+
0001BE5C 4299                     M 	clr.l	(a1)+
0001BE5E 4299                     M 	clr.l	(a1)+
0001BE60 4299                     M 	clr.l	(a1)+
0001BE62 4299                     M 	clr.l	(a1)+
0001BE64 4299                     M 	clr.l	(a1)+
0001BE66 4299                     M 	clr.l	(a1)+
0001BE68 4299                     M 	clr.l	(a1)+
0001BE6A 4299                     M 	clr.l	(a1)+
0001BE6C 4299                     M 	clr.l	(a1)+
0001BE6E 4299                     M 	clr.l	(a1)+
0001BE70 4299                     M 	clr.l	(a1)+
0001BE72 4299                     M 	clr.l	(a1)+
0001BE74 4299                     M 	clr.l	(a1)+
0001BE76 4299                     M 	clr.l	(a1)+
0001BE78 4299                     M 	clr.l	(a1)+
0001BE7A 4299                     M 	clr.l	(a1)+
0001BE7C 4299                     M 	clr.l	(a1)+
0001BE7E 4299                     M 	clr.l	(a1)+
0001BE80 4299                     M 	clr.l	(a1)+
0001BE82 4299                     M 	clr.l	(a1)+
0001BE84 4299                     M 	clr.l	(a1)+
0001BE86 4299                     M 	clr.l	(a1)+
0001BE88 4299                     M 	clr.l	(a1)+
0001BE8A 4299                     M 	clr.l	(a1)+
0001BE8C 4299                     M 	clr.l	(a1)+
0001BE8E 4299                     M 	clr.l	(a1)+
0001BE90 4299                     M 	clr.l	(a1)+
0001BE92 4299                     M 	clr.l	(a1)+
0001BE94 4299                     M 	clr.l	(a1)+
0001BE96 4299                     M 	clr.l	(a1)+
0001BE98 4299                     M 	clr.l	(a1)+
0001BE9A 4299                     M 	clr.l	(a1)+
0001BE9C 4299                     M 	clr.l	(a1)+
0001BE9E 4299                     M 	clr.l	(a1)+
0001BEA0 4299                     M 	clr.l	(a1)+
0001BEA2 4299                     M 	clr.l	(a1)+
0001BEA4 4299                     M 	clr.l	(a1)+
0001BEA6 4299                     M 	clr.l	(a1)+
0001BEA8                            
0001BEA8 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0001BEAA                            
0001BEAA 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0001BEAE 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0001BEB2 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0001BEB6 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0001BEBC                            
0001BEBC 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0001BEBE 4EBA FAE8                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0001BEC2                            	; continue straight to hardware muting FM
0001BEC2                            ; ===========================================================================
0001BEC2                            ; ---------------------------------------------------------------------------
0001BEC2                            ; Mute all FM channels
0001BEC2                            ; ---------------------------------------------------------------------------
0001BEC2                            
0001BEC2                            dMuteFM:
0001BEC2 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BEC4 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001BEC6                            
0001BEC6                            .noteoff
0001BEC6 1203                       		move.b	d3,d1			; copy value into d1
0001BEC8 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BECC 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001BECE 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BED2 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0001BED6                            
0001BED6 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0001BED8 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BEDA 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0001BEDC                            
0001BEDC                            .chloop
0001BEDC 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0001BEDE 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0001BEE0                            
0001BEE0                            .oploop
0001BEE0 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BEE4 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BEE8 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0001BEEA 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0001BEEE                            
0001BEEE 9005                       		sub.b	d5,d0			; go to next FM channel
0001BEF0 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0001BEF4 4E75                       		rts
0001BEF6                            ; ===========================================================================
0001BEF6                            ; ---------------------------------------------------------------------------
0001BEF6                            ; Routine for muting all PSG channels
0001BEF6                            ; ---------------------------------------------------------------------------
0001BEF6                            
0001BEF6                            dMutePSG:
0001BEF6 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0001BEFC 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0001BF00 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0001BF04 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0001BF08 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0001BF0C 4E75                       		rts
0001BF0E                            ; ===========================================================================
0001BF0E                            ; ---------------------------------------------------------------------------
0001BF0E                            ; Normal fade out data
0001BF0E                            ; ---------------------------------------------------------------------------
0001BF0E                            
0001BF0E                            dFadeOutDataLog:
0001BF0E 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0001BF1A 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0001BF26 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0001BF32 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0001BF3E 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0001BF4A 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0001BF56 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0001BF62 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0001BF6E 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0001BF78                            
0001BF78                            ;dFadeOutDataLinear:
0001BF78                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0001BF78                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0001BF78                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0001BF78                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0001BF78                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0001BF78                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0001BF78                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0001BF78                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0001BF78                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0001BF78                            	even
0001BF78                            ; ===========================================================================
0001BF78                            ; ---------------------------------------------------------------------------
0001BF78                            ; Subroutine for initializing a fade effect.
0001BF78                            ; Since the driver allows for such an extensive and customizable
0001BF78                            ; fading code, we may hit a snag if we use fades too fast. It is
0001BF78                            ; possible, for example, to fade out, then in the middle of that,
0001BF78                            ; start fading in. This would normally cause a quick jump in the
0001BF78                            ; volume level from maybe half to completely mute. This routine
0001BF78                            ; aims to combat this by actually searching for the closest FM
0001BF78                            ; volume level in the fade program, and to start the new fade from
0001BF78                            ; where that byte appears. This can alter how long a volume fade
0001BF78                            ; lasts however, and if PSG and DAC volume are not correct faded,
0001BF78                            ; it may still cause a jump in their volume (especially if only,
0001BF78                            ; say, DAC fades volume). In the future, there might be a fix for
0001BF78                            ; that.
0001BF78                            ; ---------------------------------------------------------------------------
0001BF78                            
0001BF78                            dPlaySnd_FadeOut:
0001BF78 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0001BF7C                            
0001BF7C                            dLoadFade:
0001BF7C 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0001BF80 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001BF84 6700                       		beq.s	.nofade			; if not, load fade as is
0001BF86                            
0001BF86 2449                       		move.l	a1,a2			; copy fade program address to a2
0001BF88 74FF                       		moveq	#-1,d2			; prepare max byter difference
0001BF8A                            
0001BF8A                            .find
0001BF8A 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0001BF8C 6A00                       		bpl.s	.search			; branch if this is not a command
0001BF8E                            
0001BF8E                            .nofade
0001BF8E 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0001BF92 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0001BF96 4E75                       		rts
0001BF98                            
0001BF98                            .search
0001BF98 568A                       		addq.l	#3,a2			; skip over the current volume group
0001BF9A 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0001BF9C 6A00                       		bpl.s	.abs			; if positive, do not negate
0001BF9E 4401                       		neg.b	d1			; negative to positive
0001BFA0                            
0001BFA0                            .abs
0001BFA0 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0001BFA2 64E6                       		bhs.s	.find			; if not, read next group
0001BFA4                            
0001BFA4 1401                       		move.b	d1,d2			; else save the new difference
0001BFA6 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0001BFA8 60E0                       		bra.s	.find			; loop through each group in the program
0001BFAA                            ; ===========================================================================
0001BFAA                            ; ---------------------------------------------------------------------------
0001BFAA                            ; Routine for loading a volume filter into Dual PCM ROM.
0001BFAA                            ; This routine will actually write the bank number the volume filter
0001BFAA                            ; is in. This requires volume filters are aligned to Z80 banks, and
0001BFAA                            ; just because we can, we write 9 bits (yeah its not necessary, but
0001BFAA                            ; what the hell, you have to have fun sometimes!)
0001BFAA                            ; ---------------------------------------------------------------------------
0001BFAA                            
0001BFAA                            dSetFilter:
0001BFAA 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0001BFB0 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0001BFB2 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0001BFB4                            	StopZ80					; wait for Z80 to stop
0001BFB4 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001BFBC                          M 	waitz80stop
0001BFBC 0839 0000 00A1 1100      M .wait_324:	btst	#0,z80_bus_req
0001BFC4 66F6                     M 	bne.s	.wait_324
0001BFC6                            ; ---------------------------------------------------------------------------
0001BFC6                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0001BFC6                            ; a register AND the carry to another register. What this means, is if
0001BFC6                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0001BFC6                            ; of $74 into the carry, making us able to switch between the Z80
0001BFC6                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0001BFC6                            ; Dual PCM to bank switch into the appropriate bank.
0001BFC6                            ; ---------------------------------------------------------------------------
0001BFC6                            
0001BFC6                            .loop
0001BFC6 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0001BFC8 E248                       		lsr.w	#1,d0			; shift lsb into carry
0001BFCA D701                       		addx.b	d1,d3			; add instruction and carry into d3
0001BFCC                            
0001BFCC 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0001BFCE 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0001BFD2                            	StartZ80				; enable Z80 execution
0001BFD2 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BFDA 4E75                       		rts
0001BFDC                            
0001BFDC                            ; ===========================================================================
0001BFDC                            ; ---------------------------------------------------------------------------
0001BFDC                            ; Routine for resetting master volumes, filters and disabling fading
0001BFDC                            ; ---------------------------------------------------------------------------
0001BFDC                            
0001BFDC                            dResetVolume:
0001BFDC 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0001BFE0 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0001BFE4 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0001BFE8 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0001BFEC 61BC                       		bsr.s	dSetFilter		; load filter instructions
0001BFEE                            
0001BFEE                            dUpdateVolumeAll:
0001BFEE 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0001BFF0 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0001BFF4                            
0001BFF4 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001BFF4                            	rept Mus_DAC				; loop through all music DAC channels
0001BFF4                            		or.b	d0,.ch.w		; request channel volume update
0001BFF4                            .ch =		.ch+cSize			; go to next channel
0001BFF4                            	endr
0001BFF4 8138 C4C4                M 	or.b	d0,.ch.w
0001BFF8 =FFFFC4F0                M .ch	=	.ch+csize
0001BFF8 8138 C4F0                M 	or.b	d0,.ch.w
0001BFFC =FFFFC51C                M .ch	=	.ch+csize
0001BFFC                            
0001BFFC =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001BFFC                            	rept Mus_PSG				; loop through all music PSG channels
0001BFFC                            		or.b	d0,.ch.w		; request channel volume update
0001BFFC                            .ch =		.ch+cSize			; go to next channel
0001BFFC                            	endr
0001BFFC 8138 C5F8                M 	or.b	d0,.ch.w
0001C000 =FFFFC624                M .ch	=	.ch+csize
0001C000 8138 C624                M 	or.b	d0,.ch.w
0001C004 =FFFFC650                M .ch	=	.ch+csize
0001C004 8138 C650                M 	or.b	d0,.ch.w
0001C008 =FFFFC67C                M .ch	=	.ch+csize
0001C008                            
0001C008 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001C008                            	rept SFX_PSG				; loop through all SFX PSG channels
0001C008                            		or.b	d0,.ch.w		; request channel volume update
0001C008                            .ch =		.ch+cSizeSFX			; go to next channel
0001C008                            	endr
0001C008 8138 C6EC                M 	or.b	d0,.ch.w
0001C00C =FFFFC708                M .ch	=	.ch+csizesfx
0001C00C 8138 C708                M 	or.b	d0,.ch.w
0001C010 =FFFFC724                M .ch	=	.ch+csizesfx
0001C010 8138 C724                M 	or.b	d0,.ch.w
0001C014 =FFFFC740                M .ch	=	.ch+csizesfx
0001C014 4E75                       		rts
0001C016                            ; ===========================================================================
0001C016                            ; ---------------------------------------------------------------------------
0001C016                            ; Enable speed shoes mode
0001C016                            ; ---------------------------------------------------------------------------
0001C016                            
0001C016                            dPlaySnd_ShoesOn:
0001C016 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0001C01C 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0001C022 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0001C028 4E75                       		rts
0001C02A                            ; ===========================================================================
0001C02A                            ; ---------------------------------------------------------------------------
0001C02A                            ; Reset music flags (underwater mode and tempo mode)
0001C02A                            ; ---------------------------------------------------------------------------
0001C02A                            
0001C02A                            dPlaySnd_Reset:
0001C02A 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0001C02C                            ; ===========================================================================
0001C02C                            ; ---------------------------------------------------------------------------
0001C02C                            ; Disable speed shoes mode
0001C02C                            ; ---------------------------------------------------------------------------
0001C02C                            
0001C02C                            dPlaySnd_ShoesOff:
0001C02C 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0001C032 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0001C038 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0001C03E 4E75                       		rts
0001C040                            ; ===========================================================================
0001C040                            ; ---------------------------------------------------------------------------
0001C040                            ; Enable Underwater mode
0001C040                            ; ---------------------------------------------------------------------------
0001C040                            
0001C040                            dPlaySnd_ToWater:
0001C040 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0001C046 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0001C048                            ; ===========================================================================
0001C048                            ; ---------------------------------------------------------------------------
0001C048                            ; Disable Underwater mode
0001C048                            ; ---------------------------------------------------------------------------
0001C048                            
0001C048                            dPlaySnd_OutWater:
0001C048 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0001C04E                            ; ===========================================================================
0001C04E                            ; ---------------------------------------------------------------------------
0001C04E                            ; force volume update on all FM channels
0001C04E                            ; ---------------------------------------------------------------------------
0001C04E                            
0001C04E                            dReqVolUpFM;
0001C04E 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0001C050 =FFFFC51C                  .ch =	mFM1					; start at FM1
0001C050                            	rept Mus_FM				; loop through all music FM channels
0001C050                            		or.b	d0,.ch.w		; request channel volume update
0001C050                            .ch =		.ch+cSize			; go to next channel
0001C050                            	endr
0001C050 8138 C51C                M 	or.b	d0,.ch.w
0001C054 =FFFFC548                M .ch	=	.ch+csize
0001C054 8138 C548                M 	or.b	d0,.ch.w
0001C058 =FFFFC574                M .ch	=	.ch+csize
0001C058 8138 C574                M 	or.b	d0,.ch.w
0001C05C =FFFFC5A0                M .ch	=	.ch+csize
0001C05C 8138 C5A0                M 	or.b	d0,.ch.w
0001C060 =FFFFC5CC                M .ch	=	.ch+csize
0001C060 8138 C5CC                M 	or.b	d0,.ch.w
0001C064 =FFFFC5F8                M .ch	=	.ch+csize
0001C064                            
0001C064 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0001C064                            	rept SFX_FM				; loop through all SFX FM channels
0001C064                            		or.b	d0,.ch.w		; request channel volume update
0001C064                            .ch =		.ch+cSizeSFX			; go to next channel
0001C064                            	endr
0001C064 8138 C698                M 	or.b	d0,.ch.w
0001C068 =FFFFC6B4                M .ch	=	.ch+csizesfx
0001C068 8138 C6B4                M 	or.b	d0,.ch.w
0001C06C =FFFFC6D0                M .ch	=	.ch+csizesfx
0001C06C 8138 C6D0                M 	or.b	d0,.ch.w
0001C070 =FFFFC6EC                M .ch	=	.ch+csizesfx
0001C070 4E75                       		rts
0001C072                            ; ===========================================================================
0001C072                            ; ---------------------------------------------------------------------------
0001C072                            ; Subroutine for updating Total Levels for FM channel
0001C072                            ; ---------------------------------------------------------------------------
0001C072                            
0001C072                            dUpdateVolFM:
0001C072 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C076 6600                       		bne.s	locret_VolFM		; if yes, do not update
0001C078                            
0001C078 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001C07C D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001C080 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001C082 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001C084                            
0001C084                            .noover
0001C084 7000                       		moveq	#0,d0
0001C086 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001C08A 224E                       		move.l	a6,a1			; copy music voice table address to a1
0001C08C                            
0001C08C                            	dCALC_VOICE				; get address of the specific voice to a1
0001C08C EB48                     M 	lsl.w	#5,d0
0001C08E D2C0                     M 	add.w	d0,a1
0001C090 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0001C092 7C00                       		moveq	#0,d6			; reset the modulator offset
0001C094                            
0001C094 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001C09A 6700                       		beq.s	.uwdone			; if not, skip
0001C09C 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0001C09E 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001C0A2 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001C0A4 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0001C0A6                            
0001C0A6                            .uwdone
0001C0A6 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001C0A8 D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0001C0AC 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0001C0B0                            
0001C0B0                            .tlloop
0001C0B0 101A                       		move.b	(a2)+,d0		; load YM address to write to
0001C0B2 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001C0B4 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001C0B6                            
0001C0B6 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001C0B8 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001C0BA 727F                       		moveq	#$7F,d1			; cap to silent volume
0001C0BC 6000                       		bra.s	.slot
0001C0BE                            
0001C0BE                            .noslot
0001C0BE D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001C0C0                            .slot
0001C0C0 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0001C0C4                            .ignore
0001C0C4 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001C0C8                            
0001C0C8                            
0001C0C8                            locret_VolFM:
0001C0C8 4E75                       		rts
0001C0CA                            ; ===========================================================================
0001C0CA                            ; ---------------------------------------------------------------------------
0001C0CA                            ; YM2612 register update list
0001C0CA                            ; ---------------------------------------------------------------------------
0001C0CA                            
0001C0CA 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0001C0CE 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0001C0D2 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0001C0D6 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0001C0DA 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0001C0DE 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0001C0E2 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0001C0E6                            ; ===========================================================================
0001C0E6                            ; ---------------------------------------------------------------------------
0001C0E6                            ; Process SFX FM channels
0001C0E6                            ; ---------------------------------------------------------------------------
0001C0E6                            
0001C0E6                            dAMPSdoFMSFX:
0001C0E6 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0001C0EA 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0001C0EC                            
0001C0EC                            dAMPSnextFMSFX:
0001C0EC DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C0F0 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C0F2 6A00 0000                  		bpl.w	.next			; if not, branch
0001C0F6 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C0FA 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C0FE                            
0001C0FE                            	dCalcFreq				; calculate channel base frequency
0001C0FE 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C102 4886                     M 	ext.w	d6
0001C104 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C108                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0001C108 0815 0003                M 	btst	#cfbmod,(a5)
0001C10C 6700                     M 	beq.s	.noret
0001C10E 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C112 6700                     M 	beq.s	.started
0001C114 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C118                          M .noret
0001C118 0895 0005                M 	bclr	#cfbvol,(a5)
0001C11C 6700                     M 	beq.s	.noupdatevol
0001C11E 4EBA FF52                M 	jsr	dupdatevolfm(pc)
0001C122                          M 	.noupdatevol:
0001C122 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0001C126 6000 0000                M 	bra.w	dampsdopsgsfx
0001C12A                          M .started
0001C12A 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C12E 66E8                     M 	bne.s	.noret
0001C130 226D 0010                M 	movea.l	cmod(a5),a1
0001C134 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C13A 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C13E 6600                     M 	bne.s	.norev
0001C140 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C146 442D 0017                M 	neg.b	cmodstep(a5)
0001C14A                          M .norev
0001C14A 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C14E 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C152 4885                     M 	ext.w	d5
0001C154 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C158 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C15C DC45                     M 	add.w	d5,d6
0001C15E 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0001C162                            
0001C162 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C166 6700                       		beq.s	.next			; if not, skip
0001C168 4EBA FF08                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C16C                            
0001C16C                            .next
0001C16C 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C170 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C174                            
0001C174                            .update
0001C174 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C178                            	dDoTracker				; process tracker
0001C178 286D 0002                M 	movea.l	cdata(a5),a4
0001C17C                          M .data
0001C17C 7A00                     M 	moveq	#0,d5
0001C17E 1A1C                     M 	move.b	(a4)+,d5
0001C180 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C184 6500                     M 	blo.s	.notcomm
0001C186 4EBA 0000                M 	jsr	dcommands(pc)
0001C18A 60F0                     M 	bra.s	.data
0001C18C 60DE                     M 	bra.s	.next
0001C18E                          M .notcomm
0001C18E 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0001C192 4A05                       		tst.b	d5			; check if note is being played
0001C194 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C196                            
0001C196 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C19A 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C19C 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C19E 534C                       		subq.w	#1,a4			; if not, then return back
0001C1A0 6000                       		bra.s	.pcnote			; do some extra clearing
0001C1A2                            
0001C1A2                            .timer
0001C1A2 4EBA F5EC                  		jsr	dCalcDuration(pc)	; calculate duration
0001C1A6                            .pcnote
0001C1A6                            	dProcNote 1, 0				; reset necessary channel memory
0001C1A6 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C1AA 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C1B0 0815 0002                M 	btst	#cfbhold,(a5)
0001C1B4 6600                     M 	bne.s	.endpn
0001C1B6 0815 0003                M 	btst	#cfbmod,(a5)
0001C1BA 6700                     M 	beq.s	.endpn
0001C1BC 226D 0010                M 	movea.l	cmod(a5),a1
0001C1C0 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C1C4 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C1C8 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C1CC 1011                     M 	move.b	(a1),d0
0001C1CE E208                     M 	lsr.b	#1,d0
0001C1D0 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C1D4 426D 0014                M 	clr.w	cmodfreq(a5)
0001C1D8                          M .endpn
0001C1D8 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0001C1DC                            	dKeyOnFM 1				; send key-on command to YM
0001C1DC 0815 0002                M 	btst	#cfbhold,(a5)
0001C1E0 6600                     M 	bne.s	.k
0001C1E2 0815 0000                M 	btst	#cfbrest,(a5)
0001C1E6 6600                     M 	bne.s	.k
0001C1E8 7028                     M 	moveq	#$28,d0
0001C1EA 122D 0001                M 	move.b	ctype(a5),d1
0001C1EE 0001 00F0                M 	ori.b	#$f0,d1
0001C1F2 6100 0000                M 	bsr.w	writeym_pt1
0001C1F6                          M .k
0001C1F6                            
0001C1F6 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C1FA 6700                       		beq.s	.noupdate		; if not, branch
0001C1FC 4EBA FE74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C200                            
0001C200 51CF FEEA                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C204 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C208                            ; ===========================================================================
0001C208                            ; ---------------------------------------------------------------------------
0001C208                            ; Process music FM channels
0001C208                            ; ---------------------------------------------------------------------------
0001C208                            
0001C208                            dAMPSdoFM:
0001C208 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0001C20C 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0001C20E                            
0001C20E                            dAMPSnextFM:
0001C20E DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0001C212 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C214 6A00 0000                  		bpl.w	.next			; if not, branch
0001C218 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C21C 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C220                            
0001C220                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0001C220                          M 	dnotetouthandler
0001C220 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C224 6700                     M 	beq.s	.endt
0001C226 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C22A 6600                     M 	bne.s	.endt
0001C22C 08D5 0000                M 	bset	#cfbrest,(a5)
0001C230 6100 0000                M 	bsr.w	dkeyofffm
0001C234 6000 0000                M 	bra.w	.next
0001C238                          M .endt
0001C238                            	dCalcFreq				; calculate channel base frequency
0001C238 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C23C 4886                     M 	ext.w	d6
0001C23E DC6D 000E                M 	add.w	cfreq(a5),d6
0001C242                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0001C242 0815 0003                M 	btst	#cfbmod,(a5)
0001C246 6700                     M 	beq.s	.noret
0001C248 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C24C 6700                     M 	beq.s	.started
0001C24E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C252                          M .noret
0001C252 0895 0005                M 	bclr	#cfbvol,(a5)
0001C256 6700                     M 	beq.s	.noupdatevol
0001C258 4EBA FE18                M 	jsr	dupdatevolfm(pc)
0001C25C                          M 	.noupdatevol:
0001C25C 51CF FFB0                M 	dbf	d7,dampsnextfm
0001C260 6000 0000                M 	bra.w	dampsdopsg
0001C264                          M .started
0001C264 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C268 66E8                     M 	bne.s	.noret
0001C26A 226D 0010                M 	movea.l	cmod(a5),a1
0001C26E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C274 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C278 6600                     M 	bne.s	.norev
0001C27A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C280 442D 0017                M 	neg.b	cmodstep(a5)
0001C284                          M .norev
0001C284 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C288 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C28C 4885                     M 	ext.w	d5
0001C28E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C292 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C296 DC45                     M 	add.w	d5,d6
0001C298 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0001C29C                            
0001C29C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C2A0 6700                       		beq.s	.next			; if not, skip
0001C2A2 4EBA FDCE                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C2A6                            
0001C2A6                            .next
0001C2A6 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C2AA 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C2AE                            
0001C2AE                            .update
0001C2AE 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C2B2                            	dDoTracker				; process tracker
0001C2B2 286D 0002                M 	movea.l	cdata(a5),a4
0001C2B6                          M .data
0001C2B6 7A00                     M 	moveq	#0,d5
0001C2B8 1A1C                     M 	move.b	(a4)+,d5
0001C2BA 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C2BE 6500                     M 	blo.s	.notcomm
0001C2C0 4EBA 0000                M 	jsr	dcommands(pc)
0001C2C4 60F0                     M 	bra.s	.data
0001C2C6 60DE                     M 	bra.s	.next
0001C2C8                          M .notcomm
0001C2C8 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001C2CC 4A05                       		tst.b	d5			; check if note is being played
0001C2CE 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C2D0                            
0001C2D0 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C2D4 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C2D6 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C2D8 534C                       		subq.w	#1,a4			; if not, then return back
0001C2DA 6000                       		bra.s	.pcnote			; do some extra clearing
0001C2DC                            
0001C2DC                            .timer
0001C2DC 4EBA F4B2                  		jsr	dCalcDuration(pc)	; calculate duration
0001C2E0                            .pcnote
0001C2E0                            	dProcNote 0, 0				; reset necessary channel memory
0001C2E0 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C2E4 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C2EA 0815 0002                M 	btst	#cfbhold,(a5)
0001C2EE 6600                     M 	bne.s	.endpn
0001C2F0 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C2F6 0815 0003                M 	btst	#cfbmod,(a5)
0001C2FA 6700                     M 	beq.s	.endpn
0001C2FC 226D 0010                M 	movea.l	cmod(a5),a1
0001C300 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C304 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C308 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C30C 1011                     M 	move.b	(a1),d0
0001C30E E208                     M 	lsr.b	#1,d0
0001C310 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C314 426D 0014                M 	clr.w	cmodfreq(a5)
0001C318                          M .endpn
0001C318 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0001C31A                            	dKeyOnFM				; send key-on command to YM
0001C31A 0815 0002                M 	btst	#cfbhold,(a5)
0001C31E 6600                     M 	bne.s	.k
0001C320 0815 0000                M 	btst	#cfbrest,(a5)
0001C324 6600                     M 	bne.s	.k
0001C326 0815 0001                M 	btst	#cfbint,(a5)
0001C32A 6600                     M 	bne.s	.k
0001C32C 7028                     M 	moveq	#$28,d0
0001C32E 122D 0001                M 	move.b	ctype(a5),d1
0001C332 0001 00F0                M 	ori.b	#$f0,d1
0001C336 6100 0000                M 	bsr.w	writeym_pt1
0001C33A                          M .k
0001C33A                            
0001C33A 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C33E 6700                       		beq.s	.noupdate		; if not, branch
0001C340 4EBA FD30                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C344                            
0001C344                            .noupdate
0001C344 51CF FEC8                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C348 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C34C                            ; ===========================================================================
0001C34C                            ; ---------------------------------------------------------------------------
0001C34C                            ; Write FM frequency to Dual PCM YMCue
0001C34C                            ; ---------------------------------------------------------------------------
0001C34C                            
0001C34C                            dUpdateFreqFM:
0001C34C 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C350 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0001C352 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0001C356 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0001C358                            
0001C358 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C35C 4880                       		ext.w	d0			; extend to word
0001C35E DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C360                            
0001C360 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C364 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0001C366 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0001C36A                            
0001C36A                            dUpdateFreqFM2:
0001C36A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C36E 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0001C370                            
0001C370                            dUpdateFreqFM3:
0001C370 3206                       		move.w	d6,d1			; copy frequency to d1
0001C372 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0001C374 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0001C376 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001C37A                            
0001C37A 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0001C37C 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0001C380 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001C384                            
0001C384                            dUpdFreqFMrest:
0001C384 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C388                            
0001C388                            locret_UpdFreqFM:
0001C388 4E75                       		rts
0001C38A                            ; ===========================================================================
0001C38A                            ; ---------------------------------------------------------------------------
0001C38A                            ; Process a note in FM channel (enable resting or get frequency)
0001C38A                            ; ---------------------------------------------------------------------------
0001C38A                            
0001C38A                            dGetFreqFM:
0001C38A 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001C38E 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0001C390 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C394 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0001C398 4E75                       		rts
0001C39A                            
0001C39A                            .norest
0001C39A DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0001C39E 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0001C3A2 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0001C3A4                            
0001C3A4 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0001C3A8 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001C3AE                            
0001C3AE 4E75                       		rts
0001C3B0                            ; ===========================================================================
0001C3B0                            ; ---------------------------------------------------------------------------
0001C3B0                            ; Subroutine for doing keying-off FM channel
0001C3B0                            ; ---------------------------------------------------------------------------
0001C3B0                            
0001C3B0                            dKeyOffFM:
0001C3B0 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0001C3B4 66D2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3B6                            
0001C3B6                            dKeyOffFM2:
0001C3B6 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001C3BA 66CC                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3BC                            
0001C3BC 7028                       		moveq	#$28,d0			; YM command: Key on
0001C3BE 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0001C3C2 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0001C3C4                            ; ===========================================================================
0001C3C4                            ; ---------------------------------------------------------------------------
0001C3C4                            ; Write to YMCue according to channel and check if interrupted by sfx
0001C3C4                            ; ---------------------------------------------------------------------------
0001C3C4                            
0001C3C4                            dWriteYMchnInt:
0001C3C4 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0001C3C8 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0001C3CA                            ; ===========================================================================
0001C3CA                            ; ---------------------------------------------------------------------------
0001C3CA                            ; Write to YMCue according to channel
0001C3CA                            ; ---------------------------------------------------------------------------
0001C3CA                            
0001C3CA                            WriteChYM:
0001C3CA 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0001C3D0 6600                       		bne.s	WriteChYM2		; if part 2, branch
0001C3D2 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0001C3D6                            ; ===========================================================================
0001C3D6                            ; ---------------------------------------------------------------------------
0001C3D6                            ; Write to YMCue using part 1
0001C3D6                            ; ---------------------------------------------------------------------------
0001C3D6                            
0001C3D6                            WriteYM_Pt1:
0001C3D6                            	StopZ80					; wait for Z80 to stop
0001C3D6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C3DE                          M 	waitz80stop
0001C3DE 0839 0000 00A1 1100      M .wait_340:	btst	#0,z80_bus_req
0001C3E6 66F6                     M 	bne.s	.wait_340
0001C3E8 51D8                       		sf	(a0)+			; set YM port address as 0
0001C3EA 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C3EC 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C3EE                            	;	st	(a0)			; mark as the end of the cue data
0001C3EE                            	StartZ80				; enable Z80 execution
0001C3EE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C3F6                            
0001C3F6                            WriteYM_Pt1_rts:
0001C3F6 4E75                       		rts
0001C3F8                            ; ===========================================================================
0001C3F8                            ; ---------------------------------------------------------------------------
0001C3F8                            ; Write to YMCue according to channel in part 2
0001C3F8                            ; ---------------------------------------------------------------------------
0001C3F8                            
0001C3F8                            WriteChYM2:
0001C3F8 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0001C3FC 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0001C400 D002                       		add.b	d2,d0			; add to YM address
0001C402                            ; ===========================================================================
0001C402                            ; ---------------------------------------------------------------------------
0001C402                            ; Write to YMCue using part 2
0001C402                            ; ---------------------------------------------------------------------------
0001C402                            
0001C402                            WriteYM_Pt2:
0001C402                            	StopZ80					; wait for Z80 to stop
0001C402 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C40A                          M 	waitz80stop
0001C40A 0839 0000 00A1 1100      M .wait_343:	btst	#0,z80_bus_req
0001C412 66F6                     M 	bne.s	.wait_343
0001C414 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0001C418 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C41A 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C41C                            	;	st	(a0)			; mark as the end of the cue data
0001C41C                            	StartZ80				; enable Z80 execution
0001C41C 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C424 4E75                       		rts
0001C426                            ; ===========================================================================
0001C426                            ; ---------------------------------------------------------------------------
0001C426                            ; Note to FM frequency conversion table
0001C426                            ; ---------------------------------------------------------------------------
0001C426                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C426 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0001C428 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0001C440 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0001C458 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0001C470 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0001C488 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0001C4A0 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0001C4B8 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0001C4D0 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0001C4E6                            dFreqFM_:
0001C4E6                            ; ===========================================================================
0001C4E6                            ; ---------------------------------------------------------------------------
0001C4E6                            ; Note to Dual PCM frequency conversion table
0001C4E6                            ; ---------------------------------------------------------------------------
0001C4E6                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C4E6 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0001C4E8 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0001C500 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0001C518 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0001C530 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0001C548 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0001C560 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0001C578 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0001C590 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0001C5A8 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0001C5C0 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0001C5D8 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0001C5E6                            
0001C5E6 F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0001C5F6 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0001C60E F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0001C626 F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0001C63E F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0001C656 FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0001C66E FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0001C686 FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0001C69E FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0001C6B6 FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0001C6CE FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0001C6E6                            ; ===========================================================================
0001C6E6                            ; ---------------------------------------------------------------------------
0001C6E6                            ; Note to PSG frequency conversion table
0001C6E6                            ; ---------------------------------------------------------------------------
0001C6E6                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C6E6 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0001C6FE 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0001C716 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0001C72E 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0001C746 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0001C75E 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0001C770 0000                       	dc.w  $0000								     ; Note (C6)
0001C772                            dFreqPSG_:
0001C772                            ; ===========================================================================
0001C772                            ; ---------------------------------------------------------------------------
0001C772                            ; Process SFX PSG channels
0001C772                            ; ---------------------------------------------------------------------------
0001C772                            
0001C772                            dAMPSdoPSGSFX:
0001C772 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0001C774 4DFA FF70                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C778                            
0001C778                            dAMPSnextPSGSFX:
0001C778 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C77C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C77E 6A00                       		bpl.s	.next			; if not, branch
0001C780 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C784 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C788                            
0001C788                            	dCalcFreq				; calculate channel base frequency
0001C788 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C78C 4886                     M 	ext.w	d6
0001C78E DC6D 000E                M 	add.w	cfreq(a5),d6
0001C792                            	dModulate				; run modulation code
0001C792 0815 0003                M 	btst	#cfbmod,(a5)
0001C796 6700                     M 	beq.s	.noret
0001C798 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C79C 6700                     M 	beq.s	.started
0001C79E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C7A2                          M .noret
0001C7A2 6000                     M 	bra.s	.endm
0001C7A4                          M .started
0001C7A4 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C7A8 66F8                     M 	bne.s	.noret
0001C7AA 226D 0010                M 	movea.l	cmod(a5),a1
0001C7AE 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C7B4 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C7B8 6600                     M 	bne.s	.norev
0001C7BA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C7C0 442D 0017                M 	neg.b	cmodstep(a5)
0001C7C4                          M .norev
0001C7C4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C7C8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C7CC 4885                     M 	ext.w	d5
0001C7CE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C7D2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C7D6 DC45                     M 	add.w	d5,d6
0001C7D8 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0001C7DC                            
0001C7DC                            .endm
0001C7DC 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C7E0                            .next
0001C7E0 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C7E4 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0001C7E8                            
0001C7E8                            .update
0001C7E8 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C7EC                            	dDoTracker				; process tracker
0001C7EC 286D 0002                M 	movea.l	cdata(a5),a4
0001C7F0                          M .data
0001C7F0 7A00                     M 	moveq	#0,d5
0001C7F2 1A1C                     M 	move.b	(a4)+,d5
0001C7F4 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C7F8 6500                     M 	blo.s	.notcomm
0001C7FA 4EBA 0000                M 	jsr	dcommands(pc)
0001C7FE 60F0                     M 	bra.s	.data
0001C800 60DE                     M 	bra.s	.next
0001C802                          M .notcomm
0001C802 4A05                       		tst.b	d5			; check if note is being played
0001C804 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C806                            
0001C806                            	dGetFreqPSG				; get PSG frequency
0001C806 0405 0081                M 	subi.b	#$81,d5
0001C80A 6400                     M 	bhs.s	.norest
0001C80C 08D5 0000                M 	bset	#cfbrest,(a5)
0001C810 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C816 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C81A 6000                     M 	bra.s	.freqgot
0001C81C                          M .norest
0001C81C DA2D 0008                M 	add.b	cpitch(a5),d5
0001C820 0245 007F                M 	andi.w	#$7f,d5
0001C824 DA45                     M 	add.w	d5,d5
0001C826 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C82C                          M .freqgot
0001C82C 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C82E 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C830 534C                       		subq.w	#1,a4			; else, undo the increment
0001C832 6000                       		bra.s	.pcnote			; do not calculate duration
0001C834                            
0001C834                            .timer
0001C834 4EBA EF5A                  		jsr	dCalcDuration(pc)	; calculate duration
0001C838                            .pcnote
0001C838                            	dProcNote 1, 1				; reset necessary channel memory
0001C838 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C83C 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C842 0815 0002                M 	btst	#cfbhold,(a5)
0001C846 6600                     M 	bne.s	.endpn
0001C848 422D 0006                M 	clr.b	cenvpos(a5)
0001C84C 0815 0003                M 	btst	#cfbmod,(a5)
0001C850 6700                     M 	beq.s	.endpn
0001C852 226D 0010                M 	movea.l	cmod(a5),a1
0001C856 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C85A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C85E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C862 1011                     M 	move.b	(a1),d0
0001C864 E208                     M 	lsr.b	#1,d0
0001C866 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C86A 426D 0014                M 	clr.w	cmodfreq(a5)
0001C86E                          M .endpn
0001C86E                            
0001C86E 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0001C872 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C876 51CF FF00                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C87A                            	; continue to check tracker and end loop
0001C87A                            ; ===========================================================================
0001C87A                            ; ---------------------------------------------------------------------------
0001C87A                            ; End channel loop and check if tracker debugger should be opened
0001C87A                            ; ---------------------------------------------------------------------------
0001C87A                            
0001C87A                            dCheckTracker:
0001C87A                            .rts
0001C87A 4E75                       		rts
0001C87C                            ; ===========================================================================
0001C87C                            ; ---------------------------------------------------------------------------
0001C87C                            ; Music PSG channel loop
0001C87C                            ; ---------------------------------------------------------------------------
0001C87C                            
0001C87C                            dAMPSdoPSG:
0001C87C 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0001C87E 4DFA FE66                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C882                            
0001C882                            dAMPSnextPSG:
0001C882 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0001C886 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C888 6A00 0000                  		bpl.w	.next			; if not, branch
0001C88C 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C890 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C894                            
0001C894                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0001C894                          M 	dnotetouthandler
0001C894 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C898 6700                     M 	beq.s	.endt
0001C89A 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C89E 6600                     M 	bne.s	.endt
0001C8A0 08D5 0000                M 	bset	#cfbrest,(a5)
0001C8A4 6100 0000                M 	bsr.w	dmutepsgmus
0001C8A8 6000                     M 	bra.s	.next
0001C8AA                          M .endt
0001C8AA                            	dCalcFreq				; calculate channel base frequency
0001C8AA 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C8AE 4886                     M 	ext.w	d6
0001C8B0 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C8B4                            	dModulate				; run modulation code
0001C8B4 0815 0003                M 	btst	#cfbmod,(a5)
0001C8B8 6700                     M 	beq.s	.noret
0001C8BA 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C8BE 6700                     M 	beq.s	.started
0001C8C0 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C8C4                          M .noret
0001C8C4 6000                     M 	bra.s	.endm
0001C8C6                          M .started
0001C8C6 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C8CA 66F8                     M 	bne.s	.noret
0001C8CC 226D 0010                M 	movea.l	cmod(a5),a1
0001C8D0 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C8D6 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C8DA 6600                     M 	bne.s	.norev
0001C8DC 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C8E2 442D 0017                M 	neg.b	cmodstep(a5)
0001C8E6                          M .norev
0001C8E6 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C8EA 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C8EE 4885                     M 	ext.w	d5
0001C8F0 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C8F4 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C8F8 DC45                     M 	add.w	d5,d6
0001C8FA 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0001C8FE                            
0001C8FE                            .endm
0001C8FE 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C902                            .next
0001C902 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C906 4EFA EEA0                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C90A                            
0001C90A                            .update
0001C90A 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C90E                            	dDoTracker				; process tracker
0001C90E 286D 0002                M 	movea.l	cdata(a5),a4
0001C912                          M .data
0001C912 7A00                     M 	moveq	#0,d5
0001C914 1A1C                     M 	move.b	(a4)+,d5
0001C916 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C91A 6500                     M 	blo.s	.notcomm
0001C91C 4EBA 0000                M 	jsr	dcommands(pc)
0001C920 60F0                     M 	bra.s	.data
0001C922 60DE                     M 	bra.s	.next
0001C924                          M .notcomm
0001C924 4A05                       		tst.b	d5			; check if note is being played
0001C926 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C928                            
0001C928                            	dGetFreqPSG				; get PSG frequency
0001C928 0405 0081                M 	subi.b	#$81,d5
0001C92C 6400                     M 	bhs.s	.norest
0001C92E 08D5 0000                M 	bset	#cfbrest,(a5)
0001C932 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C938 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C93C 6000                     M 	bra.s	.freqgot
0001C93E                          M .norest
0001C93E DA2D 0008                M 	add.b	cpitch(a5),d5
0001C942 0245 007F                M 	andi.w	#$7f,d5
0001C946 DA45                     M 	add.w	d5,d5
0001C948 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C94E                          M .freqgot
0001C94E 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C950 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C952 534C                       		subq.w	#1,a4			; else, undo the increment
0001C954 6000                       		bra.s	.pcnote			; do not calculate duration
0001C956                            
0001C956                            .timer
0001C956 4EBA EE38                  		jsr	dCalcDuration(pc)	; calculate duration
0001C95A                            .pcnote
0001C95A                            	dProcNote 0, 1				; reset necessary channel memory
0001C95A 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C95E 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C964 0815 0002                M 	btst	#cfbhold,(a5)
0001C968 6600                     M 	bne.s	.endpn
0001C96A 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C970 422D 0006                M 	clr.b	cenvpos(a5)
0001C974 0815 0003                M 	btst	#cfbmod,(a5)
0001C978 6700                     M 	beq.s	.endpn
0001C97A 226D 0010                M 	movea.l	cmod(a5),a1
0001C97E 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C982 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C986 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C98A 1011                     M 	move.b	(a1),d0
0001C98C E208                     M 	lsr.b	#1,d0
0001C98E 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C992 426D 0014                M 	clr.w	cmodfreq(a5)
0001C996                          M .endpn
0001C996                            
0001C996 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0001C998 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C99C 51CF FEE4                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C9A0 4EFA EE06                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C9A4                            ; ===========================================================================
0001C9A4                            ; ---------------------------------------------------------------------------
0001C9A4                            ; Write PSG frequency to hardware
0001C9A4                            ; ---------------------------------------------------------------------------
0001C9A4                            
0001C9A4                            dUpdateFreqPSG:
0001C9A4 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001C9A8 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0001C9AA 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C9AE 4E75                       		rts
0001C9B0                            
0001C9B0                            .detune
0001C9B0 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C9B4 4880                       		ext.w	d0			; extend to word
0001C9B6 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C9B8                            
0001C9B8 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C9BC 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001C9BE DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001C9C2                            
0001C9C2                            dUpdateFreqPSG2:
0001C9C2 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001C9C6 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9C8                            
0001C9C8                            dUpdateFreqPSG3:
0001C9C8 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C9CC 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9CE                            
0001C9CE 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0001C9D2 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0001C9D6 6600                       		bne.s	.notPSG4		; if not, branch
0001C9D8 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001C9DA                            
0001C9DA                            .notPSG4
0001C9DA 3206                       		move.w	d6,d1			; copy frequency to d1
0001C9DC 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001C9E0 8001                       		or.b	d1,d0			; combine with channel type
0001C9E2                            ; ---------------------------------------------------------------------------
0001C9E2                            ; Note about the and instruction below: If this instruction is
0001C9E2                            ; not commented out, the instashield SFX will not sound correct.
0001C9E2                            ; This instruction was removed in Sonic 3K because of this, but
0001C9E2                            ; this can cause issues when values overflow the valid range of
0001C9E2                            ; PSG frequency. This may cause erroneous behavior if not anded,
0001C9E2                            ; but will also make the instashield SFX not sound correctly.
0001C9E2                            ; Comment out the instruction with caution, if you are planning
0001C9E2                            ; to port said sound effect to this driver. This has not caused
0001C9E2                            ; any issues for me, and if you are careful you can avoid any
0001C9E2                            ; such case, but beware of this issue!
0001C9E2                            ; ---------------------------------------------------------------------------
0001C9E2                            
0001C9E2 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0001C9E4 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001C9E8 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001C9EE 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0001C9F4                            
0001C9F4                            locret_dUpdateFreqPSG:
0001C9F4 4E75                       		rts
0001C9F6                            ; ===========================================================================
0001C9F6                            ; ---------------------------------------------------------------------------
0001C9F6                            ; Routine for running envelope programs
0001C9F6                            ; ---------------------------------------------------------------------------
0001C9F6                            
0001C9F6                            dEnvProgPSG:
0001C9F6 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001C9FA DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001C9FE                            
0001C9FE 7800                       		moveq	#0,d4
0001CA00 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CA04 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0001CA06 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001CA08                            
0001CA08                            dEnvelopePSG:
0001CA08 7800                       		moveq	#0,d4
0001CA0A 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CA0E 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001CA10                            
0001CA10 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001CA14 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CA18                            
0001CA18                            dEnvProgPSG2:
0001CA18                            
0001CA18 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0001CA1C D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001CA1E D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001CA20 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0001CA24                            
0001CA24 7200                       		moveq	#0,d1
0001CA26 7000                       		moveq	#0,d0
0001CA28                            
0001CA28                            dEnvProgPSG3:
0001CA28 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0001CA2C 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001CA30 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001CA32                            
0001CA32 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0001CA36 DA00                       		add.b	d0,d5			; add envelope volume to d5
0001CA38                            	; continue to update PSG volume
0001CA38                            ; ===========================================================================
0001CA38                            ; ---------------------------------------------------------------------------
0001CA38                            ; Routine for updating PSG volume to hardware
0001CA38                            ; ---------------------------------------------------------------------------
0001CA38                            
0001CA38                            dUpdateVolPSG2:
0001CA38 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0001CA3C 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001CA3E 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001CA40                            
0001CA40                            dUpdateVolPSG:
0001CA40 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001CA44 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA46 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001CA4A 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA4C                            
0001CA4C 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001CA50 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA52 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0001CA56 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0001CA58                            
0001CA58 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0001CA5C 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA5E 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001CA62 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0001CA64                            
0001CA64                            dUpdVolPSGset:
0001CA64 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0001CA68 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0001CA6C 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001CA72                            
0001CA72                            locret_UpdVolPSG:
0001CA72 4E75                       		rts
0001CA74                            ; ===========================================================================
0001CA74                            ; ---------------------------------------------------------------------------
0001CA74                            ; Subroutine for handling volume envelope commands
0001CA74                            ; ---------------------------------------------------------------------------
0001CA74                            
0001CA74                            dEnvCommand:
0001CA74                            
0001CA74 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001CA78                            
0001CA78                            .comm
0001CA78 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001CA7A 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001CA7C 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001CA7E                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001CA7E                            ; ---------------------------------------------------------------------------
0001CA7E                            
0001CA7E                            .stop
0001CA7E 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0001CA82 6000                       		bra.s	dMutePSGmus		; nute the channel
0001CA84                            ; ---------------------------------------------------------------------------
0001CA84                            
0001CA84                            .hold
0001CA84 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001CA88 4EFA FF9E                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001CA8C                            ; ---------------------------------------------------------------------------
0001CA8C                            
0001CA8C                            .reset
0001CA8C 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0001CA90 4EFA FF96                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CA94                            ; ---------------------------------------------------------------------------
0001CA94                            
0001CA94                            .loop
0001CA94 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001CA9A 4EFA FF8C                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CA9E                            ; ===========================================================================
0001CA9E                            ; ---------------------------------------------------------------------------
0001CA9E                            ; Routine for hardware muting a PSG channel
0001CA9E                            ; ---------------------------------------------------------------------------
0001CA9E                            
0001CA9E                            dMutePSGmus:
0001CA9E 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0001CAA2 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0001CAA4                            
0001CAA4                            dMutePSGsfx:
0001CAA4 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001CAA6 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001CAAA 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0001CAB0                            
0001CAB0                            locret_MutePSG:
0001CAB0 4E75                       		rts
0001CAB2                            
0001CAB2 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001CABA                            ; ===========================================================================
0001CABA                            ; ---------------------------------------------------------------------------
0001CABA                            ; Routine to execute tracker commands
0001CABA                            ;
0001CABA                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001CABA                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001CABA                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001CABA                            ; but it may be helpful with speed anyway.
0001CABA                            ; ---------------------------------------------------------------------------
0001CABA                            
0001CABA                            dCommands:
0001CABA DA05                       		add.b	d5,d5			; quadruple command ID
0001CABC DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001CABE                            
0001CABE 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0001CAC2 6600 0000                  		bne.w	.falsecomm		; branch if false
0001CAC6 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001CACA                            ; ===========================================================================
0001CACA                            ; ---------------------------------------------------------------------------
0001CACA                            ; Command handlers for normal execution
0001CACA                            ; ---------------------------------------------------------------------------
0001CACA                            
0001CACA                            .comm
0001CACA 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CACE 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0001CAD2 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001CAD6 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CADA 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CADE 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CAE2 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CAE6 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CAEA 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CAEE 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0001CAF2 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CAF6 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CAFA 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CAFE 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CB02 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CB06 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CB0A 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0001CB0E 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CB12 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CB16 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001CB1A 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0001CB1E 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0001CB22 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001CB26 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CB2A 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CB2E 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0001CB32 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CB36 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CB3A 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001CB3E 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CB42 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0001CB46                            				; FF - META
0001CB46                            ; ===========================================================================
0001CB46                            ; ---------------------------------------------------------------------------
0001CB46                            ; Routine to execute tracker meta and false condition commands
0001CB46                            ; ---------------------------------------------------------------------------
0001CB46                            
0001CB46                            .metacall
0001CB46 1A1C                       		move.b	(a4)+,d5		; get next command byte
0001CB48 DA45                       		add.w	d5,d5			; quadruple ID
0001CB4A DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001CB4C 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0001CB50                            
0001CB50                            .falsecomm
0001CB50 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0001CB54                            ; ===========================================================================
0001CB54                            ; ---------------------------------------------------------------------------
0001CB54                            ; Command handlers for meta commands
0001CB54                            ; ---------------------------------------------------------------------------
0001CB54                            
0001CB54                            .meta
0001CB54 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0001CB58 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001CB5C 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0001CB60 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0001CB64 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001CB68 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001CB6C 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0001CB70 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CB74 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001CB78 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001CB7C 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0001CB80 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0001CB84 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001CB88 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001CB8C                            
0001CB8C                            ; ===========================================================================
0001CB8C                            ; ---------------------------------------------------------------------------
0001CB8C                            ; Command handlers for false condition execution
0001CB8C                            ; ---------------------------------------------------------------------------
0001CB8C                            
0001CB8C                            .false
0001CB8C 524C                       	addq.w	#1,a4
0001CB8E 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CB90 524C                       	addq.w	#1,a4
0001CB92 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001CB94 524C                       	addq.w	#1,a4
0001CB96 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0001CB98 524C                       	addq.w	#1,a4
0001CB9A 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CB9C 524C                       	addq.w	#1,a4
0001CB9E 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CBA0 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CBA4 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CBA8 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CBAC 524C                       	addq.w	#1,a4
0001CBAE 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CBB0 524C                       	addq.w	#1,a4
0001CBB2 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CBB4 524C                       	addq.w	#1,a4
0001CBB6 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CBB8 4E75                       	rts
0001CBBA 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CBBC 4E75                       	rts
0001CBBE 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CBC0 524C                       	addq.w	#1,a4
0001CBC2 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CBC4 524C                       	addq.w	#1,a4
0001CBC6 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CBC8 524C                       	addq.w	#1,a4
0001CBCA 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CBCC 584C                       	addq.w	#4,a4
0001CBCE 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001CBD0 4E75                       	rts
0001CBD2 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CBD4 4E75                       	rts
0001CBD6 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CBD8 524C                       	addq.w	#1,a4
0001CBDA 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0001CBDC 544C                       	addq.w	#2,a4
0001CBDE 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001CBE0 4E75                       	rts
0001CBE2 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0001CBE4 544C                       	addq.w	#2,a4
0001CBE6 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0001CBE8 584C                       	addq.w	#4,a4
0001CBEA 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CBEC 544C                       	addq.w	#2,a4
0001CBEE 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CBF0 4E75                       	rts
0001CBF2 4E75                       	rts			; F9 - Return (RETURN)
0001CBF4 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CBF8 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CBFC 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001CC00 524C                       	addq.w	#1,a4
0001CC02 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CC04 524C                       	addq.w	#1,a4
0001CC06 4E75                       	rts			; FE - YM command (YMCMD)
0001CC08 6000 FF3C                  	bra.w	.metacall	; FF - META
0001CC0C                            ; ===========================================================================
0001CC0C                            ; ---------------------------------------------------------------------------
0001CC0C                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0001CC0C                            ; Note that this will override any DAC already being played,
0001CC0C                            ; and in turn trackers may override these DAC samples at any
0001CC0C                            ; time. Use with caution!
0001CC0C                            ; ---------------------------------------------------------------------------
0001CC0C                            
0001CC0C                            dcWriteDAC1:
0001CC0C 7000                       		moveq	#0,d0
0001CC0E 101C                       		move.b	(a4)+,d0		; get note to write
0001CC10 4EFA EA98                  		jmp	dNoteWriteDAC1(pc)	; note-on
0001CC14                            
0001CC14                            dcWriteDAC2:
0001CC14 7000                       		moveq	#0,d0
0001CC16 101C                       		move.b	(a4)+,d0		; get note to write
0001CC18 4EFA EA82                  		jmp	dNoteWriteDAC2(pc)	; note-on
0001CC1C                            ; ===========================================================================
0001CC1C                            ; ---------------------------------------------------------------------------
0001CC1C                            ; Tracker commands for handling spindash revving.
0001CC1C                            ; The way spindash revving works, is it actually just
0001CC1C                            ; increments a counter each time, and this counter is
0001CC1C                            ; added into the channel pitch offset.
0001CC1C                            ; ---------------------------------------------------------------------------
0001CC1C                            
0001CC1C                            dcSpRev:
0001CC1C 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001CC20 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001CC24 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0001CC28                            
0001CC28 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0001CC2C 6500                       		blo.s	.rts			; if not, skip
0001CC2E 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001CC32                            
0001CC32                            .rts
0001CC32 4E75                       		rts
0001CC34                            
0001CC34                            dcSpReset:
0001CC34 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0001CC38 4E75                       		rts
0001CC3A                            ; ===========================================================================
0001CC3A                            ; ---------------------------------------------------------------------------
0001CC3A                            ; Tracker command for changing channel panning
0001CC3A                            ; ---------------------------------------------------------------------------
0001CC3A                            
0001CC3A                            dcPan:
0001CC3A                            
0001CC3A 7237                       		moveq	#$37,d1			; prepare bits to keep
0001CC3C C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001CC40 821C                       		or.b	(a4)+,d1		; or panning value
0001CC42 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001CC46                            
0001CC46 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001CC48 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CC4E 6700 F774                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001CC52                            ; ---------------------------------------------------------------------------
0001CC52                            ; Since the DAC channels have or based panning behavior, we need this
0001CC52                            ; piece of code to update its panning
0001CC52                            ; ---------------------------------------------------------------------------
0001CC52                            
0001CC52 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001CC56 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001CC5C 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001CC5E 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001CC62                            
0001CC62                            .nodacsfx
0001CC62 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001CC66 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001CC68 4EFA F798                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001CC6C                            ; ===========================================================================
0001CC6C                            ; ---------------------------------------------------------------------------
0001CC6C                            ; Tracker commands for changing detune offset
0001CC6C                            ; ---------------------------------------------------------------------------
0001CC6C                            
0001CC6C                            dcaDetune:
0001CC6C 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0001CC6E D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001CC72 4E75                       		rts
0001CC74                            
0001CC74                            dcsDetune:
0001CC74 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001CC78 4E75                       		rts
0001CC7A                            ; ===========================================================================
0001CC7A                            ; ---------------------------------------------------------------------------
0001CC7A                            ; Tracker command for changing channel volume
0001CC7A                            ; ---------------------------------------------------------------------------
0001CC7A                            
0001CC7A                            dcsVolume:
0001CC7A 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001CC7E 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC82 4E75                       		rts
0001CC84                            
0001CC84                            dcaVolume:
0001CC84 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001CC86 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001CC8A 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC8E 4E75                       		rts
0001CC90                            ; ===========================================================================
0001CC90                            ; ---------------------------------------------------------------------------
0001CC90                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001CC90                            ; ---------------------------------------------------------------------------
0001CC90                            
0001CC90                            dcSampDAC:
0001CC90 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
0001CC96 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001CC9A 4E75                       		rts
0001CC9C                            ; ===========================================================================
0001CC9C                            ; ---------------------------------------------------------------------------
0001CC9C                            ; Tracker command for setting DAC to pitch mode
0001CC9C                            ; ---------------------------------------------------------------------------
0001CC9C                            
0001CC9C                            dcPitchDAC:
0001CC9C 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001CCA0 4E75                       		rts
0001CCA2                            ; ===========================================================================
0001CCA2                            ; ---------------------------------------------------------------------------
0001CCA2                            ; Tracker commands for changing channel tick multiplier
0001CCA2                            ; ---------------------------------------------------------------------------
0001CCA2                            
0001CCA2                            dcsTmulCh:
0001CCA2 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
0001CCA6 4E75                       		rts
0001CCA8                            
0001CCA8                            dcsTmul:
0001CCA8 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001CCAA =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001CCAA                            	rept Mus_Ch				; do for all music channels
0001CCAA                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001CCAA                            .x =		.x+cSize			; go to next channel
0001CCAA                            	endr
0001CCAA 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001CCAE =FFFFC4F0                M .x	=	.x+csize
0001CCAE 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001CCB2 =FFFFC51C                M .x	=	.x+csize
0001CCB2 11C0 C526                M 	move.b	d0,ctick+.x.w
0001CCB6 =FFFFC548                M .x	=	.x+csize
0001CCB6 11C0 C552                M 	move.b	d0,ctick+.x.w
0001CCBA =FFFFC574                M .x	=	.x+csize
0001CCBA 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001CCBE =FFFFC5A0                M .x	=	.x+csize
0001CCBE 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001CCC2 =FFFFC5CC                M .x	=	.x+csize
0001CCC2 11C0 C5D6                M 	move.b	d0,ctick+.x.w
0001CCC6 =FFFFC5F8                M .x	=	.x+csize
0001CCC6 11C0 C602                M 	move.b	d0,ctick+.x.w
0001CCCA =FFFFC624                M .x	=	.x+csize
0001CCCA 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001CCCE =FFFFC650                M .x	=	.x+csize
0001CCCE 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001CCD2 =FFFFC67C                M .x	=	.x+csize
0001CCD2 4E75                       		rts
0001CCD4                            ; ===========================================================================
0001CCD4                            ; ---------------------------------------------------------------------------
0001CCD4                            ; Tracker command for enabling or disabling the hold flag
0001CCD4                            ; ---------------------------------------------------------------------------
0001CCD4                            
0001CCD4                            dcHold:
0001CCD4 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
0001CCD8 4E75                       		rts
0001CCDA                            ; ===========================================================================
0001CCDA                            ; ---------------------------------------------------------------------------
0001CCDA                            ; Tracker command for enabling or disabling note timeout
0001CCDA                            ; ---------------------------------------------------------------------------
0001CCDA                            
0001CCDA                            dcTimeout:
0001CCDA                            
0001CCDA 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001CCDE 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001CCE2 4E75                       		rts
0001CCE4                            ; ===========================================================================
0001CCE4                            ; ---------------------------------------------------------------------------
0001CCE4                            ; Tracker commands for changing channel pitch
0001CCE4                            ; ---------------------------------------------------------------------------
0001CCE4                            
0001CCE4                            dcaTransp:
0001CCE4 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
0001CCE6 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
0001CCEA 4E75                       		rts
0001CCEC                            
0001CCEC                            dcsTransp:
0001CCEC 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001CCF0 4E75                       		rts
0001CCF2                            ; ===========================================================================
0001CCF2                            ; ---------------------------------------------------------------------------
0001CCF2                            ; Tracker commands for tempo control
0001CCF2                            ; ---------------------------------------------------------------------------
0001CCF2                            
0001CCF2                            dcsTempoShoes:
0001CCF2 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CCF4 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
0001CCF8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CCFE 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001CD00 4E75                       		rts
0001CD02                            
0001CD02                            dcsTempo:
0001CD02 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD04 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
0001CD08 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD0E 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001CD10                            
0001CD10                            dcsTempoCur:
0001CD10 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
0001CD14                            
0001CD14                            locret_Tempo:
0001CD14 4E75                       		rts
0001CD16                            
0001CD16                            dcaTempoShoes:
0001CD16 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD18 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001CD1C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD22 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
0001CD24 4E75                       		rts
0001CD26                            
0001CD26                            dcaTempo:
0001CD26 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD28 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001CD2C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD32 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
0001CD34                            
0001CD34                            dcaTempoCur:
0001CD34 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
0001CD38 4E75                       		rts
0001CD3A                            ; ===========================================================================
0001CD3A                            ; ---------------------------------------------------------------------------
0001CD3A                            ; Tracker command for enabling or disabling PSG4 noise mode
0001CD3A                            ; ---------------------------------------------------------------------------
0001CD3A                            
0001CD3A                            dcNoisePSG:
0001CD3A 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001CD3E 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001CD40 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001CD46 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001CD4C 4E75                       		rts
0001CD4E                            
0001CD4E                            .psg3
0001CD4E 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001CD54 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001CD5C 524C                       		addq.w	#1,a4			; skip param
0001CD5E 4E75                       		rts
0001CD60                            ; ===========================================================================
0001CD60                            ; ---------------------------------------------------------------------------
0001CD60                            ; Tracker command for playing another music or SFX
0001CD60                            ; ---------------------------------------------------------------------------
0001CD60                            
0001CD60                            dcSound:
0001CD60 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001CD64                            
0001CD64                            Return_dcSound:
0001CD64 4E75                       		rts
0001CD66                            ; ===========================================================================
0001CD66                            ; ---------------------------------------------------------------------------
0001CD66                            ; Tracker command for setting DAC filter bank
0001CD66                            ; ---------------------------------------------------------------------------
0001CD66                            
0001CD66                            dcFilter:
0001CD66 7000                       		moveq	#0,d0
0001CD68 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001CD6A 4EFA F23E                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001CD6E                            ; ===========================================================================
0001CD6E                            ; ---------------------------------------------------------------------------
0001CD6E                            ; Tracker command for writing a YM command to YMCue
0001CD6E                            ; ---------------------------------------------------------------------------
0001CD6E                            
0001CD6E                            dcYM:
0001CD6E 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
0001CD70 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
0001CD72 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001CD76 66EC                       		bne.s	Return_dcSound		; if so, skip
0001CD78                            
0001CD78 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001CD7C 6500 F658                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD80                            
0001CD80 1400                       		move.b	d0,d2			; copy address to d2
0001CD82 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001CD86 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001CD8A 6500 F64A                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD8E 4EFA F63A                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001CD92                            ; ===========================================================================
0001CD92                            ; ---------------------------------------------------------------------------
0001CD92                            ; Tracker command for setting channel base frequency
0001CD92                            ; ---------------------------------------------------------------------------
0001CD92                            
0001CD92                            dcsFreq:
0001CD92 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001CD96 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001CD9A                            
0001CD9A                            .rts
0001CD9A 4E75                       		rts
0001CD9C                            ; ===========================================================================
0001CD9C                            ; ---------------------------------------------------------------------------
0001CD9C                            ; Tracker command for setting channel base frequency from the note table
0001CD9C                            ; ---------------------------------------------------------------------------
0001CD9C                            
0001CD9C                            dcsFreqNote:
0001CD9C 7000                       		moveq	#0,d0
0001CD9E 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001CDA0 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001CDA4 D040                       		add.w	d0,d0			; double offset (each entry is a word)
0001CDA6                            
0001CDA6 43FA F73E                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001CDAA 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
0001CDB0                            
0001CDB0                            .rts
0001CDB0 4E75                       		rts
0001CDB2                            ; ===========================================================================
0001CDB2                            ; ---------------------------------------------------------------------------
0001CDB2                            ; Tracker command for doing a continous SFX loop
0001CDB2                            ; ---------------------------------------------------------------------------
0001CDB2                            
0001CDB2                            dcCont:
0001CDB2 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001CDB6 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001CDB8 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
0001CDBC 544C                       		addq.w	#2,a4			; skip over jump offset
0001CDBE 4E75                       		rts
0001CDC0                            ; ===========================================================================
0001CDC0                            ; ---------------------------------------------------------------------------
0001CDC0                            ; Tracker command for calling a tracker subroutine
0001CDC0                            ; ---------------------------------------------------------------------------
0001CDC0                            
0001CDC0                            dcCall:
0001CDC0                            
0001CDC0 7000                       		moveq	#0,d0
0001CDC2 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CDC6 5900                       		subq.b	#4,d0			; allocate space for another routine
0001CDC8                            
0001CDC8 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
0001CDCC 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CDD0                            ; ===========================================================================
0001CDD0                            ; ---------------------------------------------------------------------------
0001CDD0                            ; Tracker command for jumping to another tracker location
0001CDD0                            ; ---------------------------------------------------------------------------
0001CDD0                            
0001CDD0                            dcJump:
0001CDD0                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001CDD0 1E9C                     M 	move.b	(a4)+,(sp)
0001CDD2 3017                     M 	move.w	(sp),d0
0001CDD4 1014                     M 	move.b	(a4),d0
0001CDD6 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001CDD8 4E75                       		rts
0001CDDA                            ; ===========================================================================
0001CDDA                            ; ---------------------------------------------------------------------------
0001CDDA                            ; Tracker command for handling loops
0001CDDA                            ; ---------------------------------------------------------------------------
0001CDDA                            
0001CDDA                            dcLoop:
0001CDDA 7000                       		moveq	#0,d0
0001CDDC 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001CDDE                            
0001CDDE 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001CDE2 6600                       		bne.s	.loopok			; if nonzero, branch
0001CDE4 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
0001CDEA                            
0001CDEA                            .loopok
0001CDEA 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001CDEE 66E0                       		bne.s	dcJump			; if not 0, jump to routine
0001CDF0 564C                       		addq.w	#3,a4			; skip over jump offset
0001CDF2 4E75                       		rts
0001CDF4                            ; ===========================================================================
0001CDF4                            ; ---------------------------------------------------------------------------
0001CDF4                            ; Tracker command for initializing modulation
0001CDF4                            ; ---------------------------------------------------------------------------
0001CDF4                            
0001CDF4                            dcMod68K:
0001CDF4 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
0001CDF8 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
0001CDFC 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001CE00 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001CE04                            
0001CE04 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001CE06 E208                       		lsr.b	#1,d0			; halve it
0001CE08 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
0001CE0C 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001CE10                            	; continue to enabling modulation
0001CE10                            ; ===========================================================================
0001CE10                            ; ---------------------------------------------------------------------------
0001CE10                            ; Tracker commands for enabling and disabling modulation
0001CE10                            ; ---------------------------------------------------------------------------
0001CE10                            
0001CE10                            dcModOn:
0001CE10 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001CE14 4E75                       		rts
0001CE16                            
0001CE16                            dcModOff:
0001CE16 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
0001CE1A 4E75                       		rts
0001CE1C                            ; ===========================================================================
0001CE1C                            ; ---------------------------------------------------------------------------
0001CE1C                            ; Tracker command for returning from tracker subroutine
0001CE1C                            ; ---------------------------------------------------------------------------
0001CE1C                            
0001CE1C                            dcReturn:
0001CE1C 7000                       		moveq	#0,d0
0001CE1E 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CE22 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
0001CE26                            
0001CE26 544C                       		addq.w	#2,a4			; skip the call address parameter
0001CE28 5800                       		addq.b	#4,d0			; deallocate stack space
0001CE2A 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CE2E                            
0001CE2E 4E75                       		rts
0001CE30                            ; ===========================================================================
0001CE30                            ; ---------------------------------------------------------------------------
0001CE30                            ; Tracker command for initializing special FM3 mode
0001CE30                            ; ---------------------------------------------------------------------------
0001CE30                            
0001CE30                            dcSpecFM3:
0001CE30 4E75                       		rts
0001CE32                            ; ===========================================================================
0001CE32                            ; ---------------------------------------------------------------------------
0001CE32                            ; Tracker command for enabling raw frequency mode
0001CE32                            ; ---------------------------------------------------------------------------
0001CE32                            
0001CE32                            dcFreqOn:
0001CE32 4E75                       		rts
0001CE34                            ; ===========================================================================
0001CE34                            ; ---------------------------------------------------------------------------
0001CE34                            ; Tracker command for disabling raw frequency mode
0001CE34                            ; ---------------------------------------------------------------------------
0001CE34                            
0001CE34                            dcFreqOff:
0001CE34                            
0001CE34                            locret_FreqOff:
0001CE34 4E75                       		rts
0001CE36                            ; ===========================================================================
0001CE36                            ; ---------------------------------------------------------------------------
0001CE36                            ; Tracker command for changing voice, volume envelope or sample
0001CE36                            ; ---------------------------------------------------------------------------
0001CE36                            
0001CE36                            dcVoice:
0001CE36 7000                       		moveq	#0,d0
0001CE38 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
0001CE3A 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001CE3E                            
0001CE3E 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001CE42 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001CE44 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CE4A 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001CE4C                            
0001CE4C 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001CE50 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001CE52 224E                       		move.l	a6,a1			; load voice table to a1
0001CE54                            	; continue to send FM voice
0001CE54                            ; ===========================================================================
0001CE54                            ; ---------------------------------------------------------------------------
0001CE54                            ; Subroutine for sending the FM voice to YM2612
0001CE54                            ; This routine is speed optimized in a way that allows Dual PCM
0001CE54                            ; to only be stopped for as long as it must be. This will waste
0001CE54                            ; some cycles for 68000, but it will help improve DAC quality.
0001CE54                            ; ---------------------------------------------------------------------------
0001CE54                            
0001CE54                            dUpdateVoiceFM:
0001CE54                            	dCALC_VOICE				; get address of the specific voice to a1
0001CE54 EB48                     M 	lsl.w	#5,d0
0001CE56 D2C0                     M 	add.w	d0,a1
0001CE58 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001CE5C 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001CE5E                            
0001CE5E 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001CE60 16C4                       		move.b	d4,(a3)+		; save it to free space
0001CE62 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001CE66                            
0001CE66 45FA F262                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001CE6A                            	rept VoiceRegs-5
0001CE6A                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001CE6A                            		move.b	(a2)+,(a3)+		; copy each command
0001CE6A                            	endr
0001CE6A 16D9                     M 	move.b	(a1)+,(a3)+
0001CE6C 16DA                     M 	move.b	(a2)+,(a3)+
0001CE6E 16D9                     M 	move.b	(a1)+,(a3)+
0001CE70 16DA                     M 	move.b	(a2)+,(a3)+
0001CE72 16D9                     M 	move.b	(a1)+,(a3)+
0001CE74 16DA                     M 	move.b	(a2)+,(a3)+
0001CE76 16D9                     M 	move.b	(a1)+,(a3)+
0001CE78 16DA                     M 	move.b	(a2)+,(a3)+
0001CE7A 16D9                     M 	move.b	(a1)+,(a3)+
0001CE7C 16DA                     M 	move.b	(a2)+,(a3)+
0001CE7E 16D9                     M 	move.b	(a1)+,(a3)+
0001CE80 16DA                     M 	move.b	(a2)+,(a3)+
0001CE82 16D9                     M 	move.b	(a1)+,(a3)+
0001CE84 16DA                     M 	move.b	(a2)+,(a3)+
0001CE86 16D9                     M 	move.b	(a1)+,(a3)+
0001CE88 16DA                     M 	move.b	(a2)+,(a3)+
0001CE8A 16D9                     M 	move.b	(a1)+,(a3)+
0001CE8C 16DA                     M 	move.b	(a2)+,(a3)+
0001CE8E 16D9                     M 	move.b	(a1)+,(a3)+
0001CE90 16DA                     M 	move.b	(a2)+,(a3)+
0001CE92 16D9                     M 	move.b	(a1)+,(a3)+
0001CE94 16DA                     M 	move.b	(a2)+,(a3)+
0001CE96 16D9                     M 	move.b	(a1)+,(a3)+
0001CE98 16DA                     M 	move.b	(a2)+,(a3)+
0001CE9A 16D9                     M 	move.b	(a1)+,(a3)+
0001CE9C 16DA                     M 	move.b	(a2)+,(a3)+
0001CE9E 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA0 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA2 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA4 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA6 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA8 16DA                     M 	move.b	(a2)+,(a3)+
0001CEAA 16D9                     M 	move.b	(a1)+,(a3)+
0001CEAC 16DA                     M 	move.b	(a2)+,(a3)+
0001CEAE 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB0 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB2 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB4 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB6 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB8 16DA                     M 	move.b	(a2)+,(a3)+
0001CEBA 16D9                     M 	move.b	(a1)+,(a3)+
0001CEBC 16DA                     M 	move.b	(a2)+,(a3)+
0001CEBE 16D9                     M 	move.b	(a1)+,(a3)+
0001CEC0 16DA                     M 	move.b	(a2)+,(a3)+
0001CEC2 16D9                     M 	move.b	(a1)+,(a3)+
0001CEC4 16DA                     M 	move.b	(a2)+,(a3)+
0001CEC6 16D9                     M 	move.b	(a1)+,(a3)+
0001CEC8 16DA                     M 	move.b	(a2)+,(a3)+
0001CECA                            
0001CECA 7C00                       		moveq	#0,d6			; reset the modulator offset
0001CECC 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001CED0 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001CED4 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001CED6 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001CED8                            
0001CED8                            .noover
0001CED8 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001CEDE 6700                       		beq.s	.uwdone			; if not, skip
0001CEE0 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001CEE2 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001CEE6 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001CEE8 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001CEEA                            
0001CEEA                            .uwdone
0001CEEA 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001CEEC                            
0001CEEC                            .tlloop
0001CEEC 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001CEEE 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001CEF0                            
0001CEF0 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001CEF2 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001CEF4 727F                       		moveq	#$7F,d1			; cap to silent volume
0001CEF6 6000                       		bra.s	.slot
0001CEF8                            
0001CEF8                            .noslot
0001CEF8 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001CEFA                            .slot
0001CEFA 16C1                       		move.b	d1,(a3)+		; save the Total Level value
0001CEFC 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
0001CEFE 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001CF02                            
0001CF02                            
0001CF02 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001CF06 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001CF0A 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001CF0E                            
0001CF0E 7400                       		moveq	#0,d2			; prepare part 1 value
0001CF10 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001CF14 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001CF18 6700                       		beq.s	.ptok			; if so, branch
0001CF1A 0203 0003                  		and.b	#3,d3			; get channel offset only
0001CF1E 7402                       		moveq	#2,d2			; prepare part 2 value
0001CF20                            
0001CF20                            .ptok
0001CF20 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001CF22 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001CF24                            	StopZ80					; wait for Z80 to stop
0001CF24 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001CF2C                          M 	waitz80stop
0001CF2C 0839 0000 00A1 1100      M .wait_360:	btst	#0,z80_bus_req
0001CF34 66F6                     M 	bne.s	.wait_360
0001CF36                            
0001CF36                            .write
0001CF36 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
0001CF38 10DB                       		move.b	(a3)+,(a0)+		; write command values
0001CF3A                            
0001CF3A 101B                       		move.b	(a3)+,d0		; load YM command
0001CF3C 8003                       		or.b	d3,d0			; add the channel offset to command
0001CF3E 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001CF40 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001CF44 50D0                       		st	(a0)			; mark as end of the cue
0001CF46                            
0001CF46                            	StartZ80				; enable Z80 execution
0001CF46 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001CF4E DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001CF52 4E75                       		rts
0001CF54                            ; ===========================================================================
0001CF54                            ; ---------------------------------------------------------------------------
0001CF54                            ; Tracker command for stopping the current channel
0001CF54                            ; ---------------------------------------------------------------------------
0001CF54                            
0001CF54                            dcStop:
0001CF54 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
0001CF58 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001CF5C 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001CF5E                            
0001CF5E 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001CF64 6600                       		bne.s	.cont			; if we are, skip
0001CF66 4EBA F448                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001CF6A 6000                       		bra.s	.cont
0001CF6C                            ; ---------------------------------------------------------------------------
0001CF6C                            
0001CF6C                            .mutePSG
0001CF6C 4EBA FB30                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001CF70                            
0001CF70                            .cont
0001CF70 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001CF74 6500                       		blo.s	.exit			; if not, skip all this mess
0001CF76 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001CF7A                            
0001CF7A 43FA ED74                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001CF7E 7600                       		moveq	#0,d3
0001CF80 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
0001CF84 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001CF86 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001CF88                            
0001CF88 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001CF8C 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001CF8E D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001CF90 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
0001CF94                            
0001CF94                            .dacdone
0001CF94 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001CF96 6A00                       		bpl.s	.fixch			; if not, branch
0001CF98                            
0001CF98 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
0001CF9C 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
0001CFA0 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001CFA6 6600                       		bne.s	.fixch			; if yes, skip
0001CFA8                            
0001CFA8 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
0001CFAC 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
0001CFB0 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CFB4 4EBA FE9E                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001CFB8                            
0001CFB8                            .fixch
0001CFB8 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001CFBA                            .exit
0001CFBA 5497                       		addq.l	#2,(sp)			; go to next channel immediately
0001CFBC 4E75                       		rts
0001CFBE                            ; ---------------------------------------------------------------------------
0001CFBE                            ; There is nothing that would break even if the channel is not
0001CFBE                            ; running a tracker, so we do not bother checking
0001CFBE                            ; ---------------------------------------------------------------------------
0001CFBE                            
0001CFBE                            .psg
0001CFBE E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
0001CFC0 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001CFC4 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001CFC8 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
0001CFCC                            
0001CFCC 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001CFD2 66E6                       		bne.s	.exit			; if not, skip
0001CFD4 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
0001CFDC 60DC                       		bra.s	.exit
0001CFDE                            ; ===========================================================================
0001CFDE                            ; ---------------------------------------------------------------------------
0001CFDE                            ; Tracker command for enabling LFO
0001CFDE                            ; ---------------------------------------------------------------------------
0001CFDE                            
0001CFDE                            dcsLFO:
0001CFDE 7000                       		moveq	#0,d0
0001CFE0 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CFE4 224E                       		move.l	a6,a1			; load voice table to a1
0001CFE6                            
0001CFE6                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001CFE6 EB48                     M 	lsl.w	#5,d0
0001CFE8 0640 0009                M 	add.w	#9,d0
0001CFEC D2C0                     M 	add.w	d0,a1
0001CFEE 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
0001CFF0 45FA F0E0                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001CFF4 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001CFF6                            
0001CFF6                            .decayloop
0001CFF6 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001CFF8 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001CFFA                            
0001CFFA D603                       		add.b	d3,d3			; check if LFO is enabled for this channeö
0001CFFC 6400                       		bcc.s	.noLFO			; if not, skip
0001CFFE 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001D002 4EBA F3C6                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001D006                            
0001D006                            .noLFO
0001D006 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001D00A                            
0001D00A 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001D00C 7022                       		moveq	#$22,d0			; YM command: LFO
0001D00E 4EBA F3C6                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001D012                            
0001D012 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001D014 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
0001D018                            
0001D018 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001D01A 4EFA F3A8                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001D01E                            ; ===========================================================================
0001D01E                            ; ---------------------------------------------------------------------------
0001D01E                            ; Tracker command for resetting condition
0001D01E                            ; ---------------------------------------------------------------------------
0001D01E                            
0001D01E                            dcResetCond:
0001D01E 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001D022 4E75                       		rts
0001D024                            ; ===========================================================================
0001D024                            ; ---------------------------------------------------------------------------
0001D024                            ; Tracker command for writing to communications flags
0001D024                            ; ---------------------------------------------------------------------------
0001D024                            
0001D024                            dcsComm:
0001D024 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D028 7000                       		moveq	#0,d0
0001D02A 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001D02C 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001D030 4E75                       		rts
0001D032                            ; ===========================================================================
0001D032                            ; ---------------------------------------------------------------------------
0001D032                            ; RAM addresses for special condition code
0001D032                            ; ---------------------------------------------------------------------------
0001D032                            
0001D032                            dcCondRegTable:
0001D032 C744 C4A6                  	dc.w rHWVersion, mFlags	; 0
0001D036 C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
0001D03A 0000 0000                  	dc.w 0, 0			; 4
0001D03E 0000 0000                  	dc.w 0, 0			; 6
0001D042 0000 0000                  	dc.w 0, 0			; 8
0001D046 0000 0000                  	dc.w 0, 0			; $A
0001D04A 0000 0000                  	dc.w 0, 0			; $C
0001D04E 0000 0001                  	dc.w 0, cType			; $E
0001D052                            ; ===========================================================================
0001D052                            ; ---------------------------------------------------------------------------
0001D052                            ; Tracker command for checking special RAM addresses
0001D052                            ; ---------------------------------------------------------------------------
0001D052                            
0001D052                            dcCondReg:
0001D052 101C                       		move.b	(a4)+,d0		; get value from tracker
0001D054 1200                       		move.b	d0,d1			; copy to d1
0001D056                            
0001D056 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
0001D05A D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001D05C 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001D060 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
0001D062 D04D                       		add.w	a5,d0			; else it was a channel offset
0001D064                            
0001D064                            .gotit
0001D064 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
0001D066 1011                       		move.b	(a1),d0			; read byte from it
0001D068 6000                       		bra.s	dcCondCom
0001D06A                            ; ===========================================================================
0001D06A                            ; ---------------------------------------------------------------------------
0001D06A                            ; Tracker command for checking communications bytes
0001D06A                            ; ---------------------------------------------------------------------------
0001D06A                            
0001D06A                            dcCond:
0001D06A 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D06E 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001D070 1200                       		move.b	d0,d1			; copy to d1
0001D072 0240 000F                  		and.w	#$F,d0			; get offset only
0001D076 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
0001D07A                            
0001D07A                            dcCondCom:
0001D07A 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001D07E 0241 00F0                  		and.w	#$F0,d1			; get condition value only
0001D082 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
0001D084 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
0001D086 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
0001D08A                            ; ===========================================================================
0001D08A                            ; ---------------------------------------------------------------------------
0001D08A                            ; Code for setting the condition flag
0001D08A                            ; ---------------------------------------------------------------------------
0001D08A                            
0001D08A                            .c	macro x
0001D08A                            	\x	.false
0001D08A                            	rts
0001D08A                                 endm
0001D08A                            
0001D08A                            .false
0001D08A 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001D08E                            
0001D08E 4E75                       .cond	rts		; T
0001D090 4E75                       	rts
0001D092                            	.c bra.s	; F
0001D092 60F6                     M 	bra.s	.false
0001D094 4E75                     M 	rts
0001D096                            	.c bls.s	; HI
0001D096 63F2                     M 	bls.s	.false
0001D098 4E75                     M 	rts
0001D09A                            	.c bhi.s	; LS
0001D09A 62EE                     M 	bhi.s	.false
0001D09C 4E75                     M 	rts
0001D09E                            	.c blo.s	; HS/CC
0001D09E 65EA                     M 	blo.s	.false
0001D0A0 4E75                     M 	rts
0001D0A2                            	.c bhs.s	; LO/CS
0001D0A2 64E6                     M 	bhs.s	.false
0001D0A4 4E75                     M 	rts
0001D0A6                            	.c beq.s	; NE
0001D0A6 67E2                     M 	beq.s	.false
0001D0A8 4E75                     M 	rts
0001D0AA                            	.c bne.s	; EQ
0001D0AA 66DE                     M 	bne.s	.false
0001D0AC 4E75                     M 	rts
0001D0AE                            	.c bvs.s	; VC
0001D0AE 69DA                     M 	bvs.s	.false
0001D0B0 4E75                     M 	rts
0001D0B2                            	.c bvc.s	; VS
0001D0B2 68D6                     M 	bvc.s	.false
0001D0B4 4E75                     M 	rts
0001D0B6                            	.c bmi.s	; PL
0001D0B6 6BD2                     M 	bmi.s	.false
0001D0B8 4E75                     M 	rts
0001D0BA                            	.c bpl.s	; MI
0001D0BA 6ACE                     M 	bpl.s	.false
0001D0BC 4E75                     M 	rts
0001D0BE                            	.c blt.s	; GE
0001D0BE 6DCA                     M 	blt.s	.false
0001D0C0 4E75                     M 	rts
0001D0C2                            	.c bge.s	; LT
0001D0C2 6CC6                     M 	bge.s	.false
0001D0C4 4E75                     M 	rts
0001D0C6                            	.c ble.s	; GT
0001D0C6 6FC2                     M 	ble.s	.false
0001D0C8 4E75                     M 	rts
0001D0CA                            	.c bgt.s	; LE
0001D0CA 6EBE                     M 	bgt.s	.false
0001D0CC 4E75                     M 	rts
0001D0CE                            ; ===========================================================================
0001D0CE                            ; ---------------------------------------------------------------------------
0001D0CE                            ; Tracker command for freezing the CPU. DEBUG FLAG
0001D0CE                            ; ---------------------------------------------------------------------------
0001D0CE                            
0001D0CE                            ; ===========================================================================
0001D0CE                            ; ---------------------------------------------------------------------------
0001D0CE                            ; Check if a song is playing
0001D0CE                            ; ---------------------------------------------------------------------------
0001D0CE                            
0001D0CE                            dChkSongPlay:
0001D0CE 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
0001D0D2 7209                       	moveq	#Mus_Ch-1,d1
0001D0D4                            
0001D0D4                            .ChkTracks:
0001D0D4 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
0001D0D6 6B00                       	bmi.s	.Playing		; If so, branch
0001D0D8 43E9 002C                  	lea	cSize(a1),a1		; Next track
0001D0DC 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
0001D0E0 7200                       	moveq	#0,d1
0001D0E2 4E75                       	rts
0001D0E4                            
0001D0E4                            .Playing:
0001D0E4 50C1                       	st	d1
0001D0E6 4E75                       	rts
0001D0E8                            ; ===========================================================================
0001D0E8                            ; ---------------------------------------------------------------------------
0001D0E8                            ; Define music and SFX
0001D0E8                            ; ---------------------------------------------------------------------------
0001D0E8                            
0001D0E8                            	opt oz-				; disable zero-offset optimization
000C3988                            	list				; continue source listing
000C3988                            ; ===========================================================================
000C3988                            DualPCM:
000C3988                            		z80prog	0
000C3988                          M 	pusho
000C3988                          M 	opt	ae-
000C3988                          M 	opt	an+
00000000                            		include	"../amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_Fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_Fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000C54BF =00000000                M z80prg	=	0
000C54BF                          M 	mexit
000C54BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            ; Error handler
000C54BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            		include	"_ERROR_/error.asm"
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Mighty The Armadillo in PRISM PARADISE
000C54BF                            ; By Nat The Porcupine 2021
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Vladikcomper's debugger
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            
000C54BF                            exBus	EQU	ICD_BLK
000C54BF                            exAddr	EQU	ICD_BLK
000C54BF                            exIll	EQU	ICD_BLK
000C54BF                            exDiv	EQU	ICD_BLK
000C54BF                            exChk	EQU	ICD_BLK
000C54BF                            Trapv	EQU	ICD_BLK
000C54BF                            exPriv	EQU	ICD_BLK
000C54BF                            exTrace	EQU	ICD_BLK
000C54BF                            exLineA	EQU	ICD_BLK
000C54BF                            exLineF	EQU	ICD_BLK
000C54BF                            exMisc	EQU	ICD_BLK
000C54BF                            
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; =========================================================================================================================================================
