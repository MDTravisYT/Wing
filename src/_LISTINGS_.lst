00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Includes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Configuration.asm"	; User configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  DEBUG_BUILD	equ	0				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000000                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Shared.asm"		; MegaDrive includes
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Shared Includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Definitions.asm"	; Definitions
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ROM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  ROM_START		EQU	$000000		; ROM start address
00000000 =00400000                  ROM_END			EQU	$3FFFFF+1	; ROM end address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Z80 addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A00000                  Z80_RAM			EQU	$A00000		; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		EQU	$A02000		; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		EQU	$A11100		; Z80 bus rEQUest
00000000 =00A11200                  Z80_RESET		EQU	$A11200		; Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sound addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A04000                  YM2612_A0		EQU	$A04000		; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		EQU	$A04001		; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		EQU	$A04002		; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		EQU	$A04003		; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		EQU	$C00011		; M68K PSG input
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; I/O addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A10001                  HW_VERSION		EQU	$A10001		; Hardware version
00000000 =00A10003                  PORT_A_DATA		EQU	$A10003		; Port A data
00000000 =00A10005                  PORT_B_DATA		EQU	$A10005		; Port B data
00000000 =00A10007                  PORT_C_DATA		EQU	$A10007		; Port C data
00000000 =00A10009                  PORT_A_CTRL		EQU	$A10009		; Port A control
00000000 =00A1000B                  PORT_B_CTRL		EQU	$A1000B		; Port B control
00000000 =00A1000D                  PORT_C_CTRL		EQU	$A1000D		; Port C control
00000000 =00A1000F                  PORT_A_TX		EQU	$A1000F		; Port A Tx data
00000000 =00A10011                  PORT_A_RX		EQU	$A10011		; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		EQU	$A10013		; Port A S control
00000000 =00A10015                  PORT_B_TX		EQU	$A10015		; Port B Tx data
00000000 =00A10017                  PORT_B_RX		EQU	$A10017		; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		EQU	$A10019		; Port B S control
00000000 =00A1001B                  PORT_C_TX		EQU	$A1001B		; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		EQU	$A1001D		; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		EQU	$A1001F		; Port C S control
00000000 =00A130F1                  SRAM_ACCESS		EQU	$A130F1		; SRAM access port
00000000 =00A14000                  TMSS_PORT		EQU	$A14000		; TMSS port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00C00000                  VDP_DATA		EQU	$C00000		; VDP data port
00000000 =00C00004                  VDP_CTRL		EQU	$C00004		; VDP control port
00000000 =00C00008                  VDP_HV			EQU	$C00008		; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		EQU	$C0001C		; VDP debug register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RAM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00FF0000                  RAM_START		EQU	$FF0000		; RAM start address
00000000 =01000000                  RAM_END			EQU	$FFFFFF+1	; RAM end address
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rsEven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            		moveq	#0,d0
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Z80.asm"		; Z80 opcodes macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÈGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_ERROR_/debugger.asm"		; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		include	"../amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000000                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"../amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            		include	"_INCLUDE_/Shared.asm"		; User includes
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User shared includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Constants.asm"	; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  oAddr		rs.l	1				; Pointer to object code
00000000 =00000004                  oNext		rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  oPrev		rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  oDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  oDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  oFlags		rs.b	1				; Object flags
00000000 =0000000D                  oRender		rs.b	1				; Render flags
00000000 =0000000E                  oVRAM		rs.w	1				; Sprite tile properties
00000000 =00000010                  oFrame		rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  oMap		rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  oXPos		rs.l	1				; X position
00000000 =00000017                  oDrawW	=	__rs-1					; Sprite width
00000000 =00000018                  oYPos		rs.l	1				; Y position
00000000 =0000001B                  oDrawH	=	__rs-1					; Sprite height
00000000 =0000001C                  oXVel		rs.w	1				; X velocity
00000000 =0000001E                  oYVel		rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  oAni		rs.b	1				; Animation ID
00000000 =00000021                  oPrevAni	rs.b	1				; Saved animation ID
00000000 =00000022                  oAniFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  oAniTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  oSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  oRoutine	rs.b	1				; Routine ID
00000000 =00000026                  oRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  oStatus		rs.b	1				; Status flags
00000000 =00000029                  oShield		rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  oDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  oSize		rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oDynSSTs
00000000 =0000002A                  oColType	rs.b	1				; Collision type
00000000 =0000002B                  oColStat	rs.b	1				; Collision status
00000000 =0000002B                  oHitCnt		equ	oColStat			; Boss hit count
00000000 =0000002C                  oColW		rs.b	1				; Collision width
00000000 =0000002D                  oColH		rs.b	1				; Collision height
00000000 =0000002E                  oNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  oTilt		rs.b	1				; Tilt value
00000000 =00000030                  oLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oSubXPos	rs.w	1				; Sub sprite X position
00000000 =00000002                  oSubYPos	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000 =00000005                  oSubFrame	rs.b	1				; Sub sprite mapping frame
00000000 =00000006                  oSubSize	rs.b	0				; Sub sprite SSTs size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  oSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  oSubCnt		rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  oSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            oSub\$ct\X	rs.w	1				; Sub sprite X position
00000000                            oSub\$ct\Y	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000                            oSub\$ct\Frame	rs.b	1				; Sub sprite mapping frame position
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M osub0x	rs.w	1
00000000 =00000032                M osub0y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000035                M osub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M osub1x	rs.w	1
00000000 =00000038                M osub1y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000003B                M osub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M osub2x	rs.w	1
00000000 =0000003E                M osub2y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000041                M osub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M osub3x	rs.w	1
00000000 =00000044                M osub3y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000047                M osub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M osub4x	rs.w	1
00000000 =0000004A                M osub4y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000004D                M osub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M osub5x	rs.w	1
00000000 =00000050                M osub5y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000053                M osub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M osub6x	rs.w	1
00000000 =00000056                M osub6y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000059                M osub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M osub7x	rs.w	1
00000000 =0000005C                M osub7y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000005F                M osub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset oDrawPrev-6			; this awkward thing will make dPrev == oDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	oSize
00000000                            curobj_size		=	curobj_size+oSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/RAM.asm"		; RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  rBuffer		rs.b	0				; General buffer
00000000 =00FF0000                  rChunks		rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  rBuffer_End	rs.b	0
00000000                            
00000000                            		rsset	$FF000000|(RAM_START+$8000)
00000000                            
00000000 =FFFF8000                  rKosPBuf	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  rDMAQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  rDMASlot	rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  rHScroll	rs.b	$380				; HScroll table
00000000 =FFFF947E                  rHScroll_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  rVScroll	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  rVScroll_End	rs.b	0				; ''
00000000 =FFFF947E                  rVScrollFG	EQU	rVScroll			; VScroll foreground value
00000000 =FFFF9480                  rVScrollBG	EQU	rVScroll+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  rSprites	rs.b	$280				; Sprite table
00000000 =FFFF974E                  rSprites_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;rDestWtrPal	equ	rSprites_End-$100		; Target water palette buffer
00000000                            ;rDestPal	equ	rSprites_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  rDestWtrPal	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  rDestPal	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  rWaterPal	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  rPalette	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  rKosPVars	rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  rKosPCnt	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  rKosPRegs	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  rKosPSR		rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  rKosPBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  rKosPList	rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  rKosPSrc	equ	rKosPList			; ''
00000000 =FFFF9974                  rKosPDest	equ	rKosPList+4			; ''
00000000 =FFFF9990                  rKosPList_End	rs.b	0				; ''
00000000 =FFFF9990                  rKosPMMods	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  rKosPMLastSz	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  rKosPMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  rKosPMSrc	equ	rKosPMList			; ''
00000000 =FFFF9998                  rKosPMDest	equ	rKosPMList+4			; ''
00000000 =FFFF9A54                  rKosPMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  rKosPVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  rObjects	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9A54                M robj_0	rs.b	osize
00000000 =00000060                M curobj_size	=	curobj_size+osize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9AB4                M robj_1	rs.b	osize
00000000 =000000C0                M curobj_size	=	curobj_size+osize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9B14                M robj_2	rs.b	osize
00000000 =00000120                M curobj_size	=	curobj_size+osize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9B74                M robj_3	rs.b	osize
00000000 =00000180                M curobj_size	=	curobj_size+osize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9BD4                M robj_4	rs.b	osize
00000000 =000001E0                M curobj_size	=	curobj_size+osize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9C34                M robj_5	rs.b	osize
00000000 =00000240                M curobj_size	=	curobj_size+osize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9C94                M robj_6	rs.b	osize
00000000 =000002A0                M curobj_size	=	curobj_size+osize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9CF4                M robj_7	rs.b	osize
00000000 =00000300                M curobj_size	=	curobj_size+osize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFF9D54                M robj_8	rs.b	osize
00000000 =00000360                M curobj_size	=	curobj_size+osize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_9	rs.b	osize
00000000 =000003C0                M curobj_size	=	curobj_size+osize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_a	rs.b	osize
00000000 =00000420                M curobj_size	=	curobj_size+osize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_b	rs.b	osize
00000000 =00000480                M curobj_size	=	curobj_size+osize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_c	rs.b	osize
00000000 =000004E0                M curobj_size	=	curobj_size+osize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_d	rs.b	osize
00000000 =00000540                M curobj_size	=	curobj_size+osize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_e	rs.b	osize
00000000 =000005A0                M curobj_size	=	curobj_size+osize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_f	rs.b	osize
00000000 =00000600                M curobj_size	=	curobj_size+osize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_10	rs.b	osize
00000000 =00000660                M curobj_size	=	curobj_size+osize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_11	rs.b	osize
00000000 =000006C0                M curobj_size	=	curobj_size+osize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_12	rs.b	osize
00000000 =00000720                M curobj_size	=	curobj_size+osize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_13	rs.b	osize
00000000 =00000780                M curobj_size	=	curobj_size+osize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_14	rs.b	osize
00000000 =000007E0                M curobj_size	=	curobj_size+osize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_15	rs.b	osize
00000000 =00000840                M curobj_size	=	curobj_size+osize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_16	rs.b	osize
00000000 =000008A0                M curobj_size	=	curobj_size+osize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_17	rs.b	osize
00000000 =00000900                M curobj_size	=	curobj_size+osize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_18	rs.b	osize
00000000 =00000960                M curobj_size	=	curobj_size+osize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_19	rs.b	osize
00000000 =000009C0                M curobj_size	=	curobj_size+osize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_1a	rs.b	osize
00000000 =00000A20                M curobj_size	=	curobj_size+osize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_1b	rs.b	osize
00000000 =00000A80                M curobj_size	=	curobj_size+osize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_1c	rs.b	osize
00000000 =00000AE0                M curobj_size	=	curobj_size+osize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_1d	rs.b	osize
00000000 =00000B40                M curobj_size	=	curobj_size+osize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_1e	rs.b	osize
00000000 =00000BA0                M curobj_size	=	curobj_size+osize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_1f	rs.b	osize
00000000 =00000C00                M curobj_size	=	curobj_size+osize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_20	rs.b	osize
00000000 =00000C60                M curobj_size	=	curobj_size+osize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_21	rs.b	osize
00000000 =00000CC0                M curobj_size	=	curobj_size+osize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_22	rs.b	osize
00000000 =00000D20                M curobj_size	=	curobj_size+osize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_23	rs.b	osize
00000000 =00000D80                M curobj_size	=	curobj_size+osize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_24	rs.b	osize
00000000 =00000DE0                M curobj_size	=	curobj_size+osize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_25	rs.b	osize
00000000 =00000E40                M curobj_size	=	curobj_size+osize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_26	rs.b	osize
00000000 =00000EA0                M curobj_size	=	curobj_size+osize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_27	rs.b	osize
00000000 =00000F00                M curobj_size	=	curobj_size+osize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_28	rs.b	osize
00000000 =00000F60                M curobj_size	=	curobj_size+osize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_29	rs.b	osize
00000000 =00000FC0                M curobj_size	=	curobj_size+osize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_2a	rs.b	osize
00000000 =00001020                M curobj_size	=	curobj_size+osize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_2b	rs.b	osize
00000000 =00001080                M curobj_size	=	curobj_size+osize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_2c	rs.b	osize
00000000 =000010E0                M curobj_size	=	curobj_size+osize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_2d	rs.b	osize
00000000 =00001140                M curobj_size	=	curobj_size+osize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_2e	rs.b	osize
00000000 =000011A0                M curobj_size	=	curobj_size+osize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_2f	rs.b	osize
00000000 =00001200                M curobj_size	=	curobj_size+osize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_30	rs.b	osize
00000000 =00001260                M curobj_size	=	curobj_size+osize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_31	rs.b	osize
00000000 =000012C0                M curobj_size	=	curobj_size+osize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_32	rs.b	osize
00000000 =00001320                M curobj_size	=	curobj_size+osize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_33	rs.b	osize
00000000 =00001380                M curobj_size	=	curobj_size+osize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_34	rs.b	osize
00000000 =000013E0                M curobj_size	=	curobj_size+osize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_35	rs.b	osize
00000000 =00001440                M curobj_size	=	curobj_size+osize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_36	rs.b	osize
00000000 =000014A0                M curobj_size	=	curobj_size+osize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_37	rs.b	osize
00000000 =00001500                M curobj_size	=	curobj_size+osize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_38	rs.b	osize
00000000 =00001560                M curobj_size	=	curobj_size+osize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_39	rs.b	osize
00000000 =000015C0                M curobj_size	=	curobj_size+osize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_3a	rs.b	osize
00000000 =00001620                M curobj_size	=	curobj_size+osize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_3b	rs.b	osize
00000000 =00001680                M curobj_size	=	curobj_size+osize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_3c	rs.b	osize
00000000 =000016E0                M curobj_size	=	curobj_size+osize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_3d	rs.b	osize
00000000 =00001740                M curobj_size	=	curobj_size+osize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_3e	rs.b	osize
00000000 =000017A0                M curobj_size	=	curobj_size+osize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_3f	rs.b	osize
00000000 =00001800                M curobj_size	=	curobj_size+osize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_40	rs.b	osize
00000000 =00001860                M curobj_size	=	curobj_size+osize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_41	rs.b	osize
00000000 =000018C0                M curobj_size	=	curobj_size+osize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_42	rs.b	osize
00000000 =00001920                M curobj_size	=	curobj_size+osize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_43	rs.b	osize
00000000 =00001980                M curobj_size	=	curobj_size+osize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_44	rs.b	osize
00000000 =000019E0                M curobj_size	=	curobj_size+osize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_45	rs.b	osize
00000000 =00001A40                M curobj_size	=	curobj_size+osize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_46	rs.b	osize
00000000 =00001AA0                M curobj_size	=	curobj_size+osize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_47	rs.b	osize
00000000 =00001B00                M curobj_size	=	curobj_size+osize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_48	rs.b	osize
00000000 =00001B60                M curobj_size	=	curobj_size+osize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_49	rs.b	osize
00000000 =00001BC0                M curobj_size	=	curobj_size+osize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_4a	rs.b	osize
00000000 =00001C20                M curobj_size	=	curobj_size+osize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_4b	rs.b	osize
00000000 =00001C80                M curobj_size	=	curobj_size+osize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_4c	rs.b	osize
00000000 =00001CE0                M curobj_size	=	curobj_size+osize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_4d	rs.b	osize
00000000 =00001D40                M curobj_size	=	curobj_size+osize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_4e	rs.b	osize
00000000 =00001DA0                M curobj_size	=	curobj_size+osize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_4f	rs.b	osize
00000000 =00001E00                M curobj_size	=	curobj_size+osize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_50	rs.b	osize
00000000 =00001E60                M curobj_size	=	curobj_size+osize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_51	rs.b	osize
00000000 =00001EC0                M curobj_size	=	curobj_size+osize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_52	rs.b	osize
00000000 =00001F20                M curobj_size	=	curobj_size+osize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_53	rs.b	osize
00000000 =00001F80                M curobj_size	=	curobj_size+osize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_54	rs.b	osize
00000000 =00001FE0                M curobj_size	=	curobj_size+osize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_55	rs.b	osize
00000000 =00002040                M curobj_size	=	curobj_size+osize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_56	rs.b	osize
00000000 =000020A0                M curobj_size	=	curobj_size+osize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_57	rs.b	osize
00000000 =00002100                M curobj_size	=	curobj_size+osize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_58	rs.b	osize
00000000 =00002160                M curobj_size	=	curobj_size+osize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_59	rs.b	osize
00000000 =000021C0                M curobj_size	=	curobj_size+osize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_5a	rs.b	osize
00000000 =00002220                M curobj_size	=	curobj_size+osize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_5b	rs.b	osize
00000000 =00002280                M curobj_size	=	curobj_size+osize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_5c	rs.b	osize
00000000 =000022E0                M curobj_size	=	curobj_size+osize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_5d	rs.b	osize
00000000 =00002340                M curobj_size	=	curobj_size+osize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_5e	rs.b	osize
00000000 =000023A0                M curobj_size	=	curobj_size+osize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_5f	rs.b	osize
00000000 =00002400                M curobj_size	=	curobj_size+osize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFBE54                  rObjects_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(rObjects_End-rObjects)/oSize
00000000                            
00000000 =FFFFBE54                  rTailAddr	rs.l	1				; pointer to tail object code
00000000 =FFFFBE58                  rTailNext	rs.w	1				; pointer to the first object in linked list
00000000 =FFFFBE5A                  rTailPrev	rs.w	1				; pointer to the last object in linked list
00000000 =FFFFBE5C                  rFreeHead	rs.w	1				; pointer to the first object that is not loaded
00000000                            
00000000 =FFFFBE5A                  rDispInput	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFBE9E                  rDispInput_End	rs.b	0				; 
00000000                            
00000000 =FFFFBE9E                  rRespawns	rs.b	$300				; Object respawn table
00000000 =FFFFC19E                  rRespawns_End	rs.b	0				; ''
00000000                            
00000000 =FFFFC19E                  rFGRowBuf	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  rFGColBuf	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  rBGRowBuf	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  rBGColBuf	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  rAMPS		rs.b	0			; AMPS variables
00000000                            		include	"../amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC740                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC740                  rP1Data		rs.b	0				; Controller 1 data
00000000 =FFFFC740                  rP1Hold		rs.b	1				; Controller 1 held button data
00000000 =FFFFC741                  rP1Press	rs.b	1				; Controller 1 pressed button data
00000000 =FFFFC742                  rP2Data		rs.b	0				; Controller 2 data
00000000 =FFFFC742                  rP2Hold		rs.b	1				; Controller 2 held button data
00000000 =FFFFC743                  rP2Press	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC744                  rHWVersion	rs.b	1				; Hardware version
00000000 =FFFFC745                  rVINTFlag	rs.b	0				; V-INT flag
00000000 =FFFFC745                  rVINTRout	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC746                  rPalFade	rs.b	0				; Palette fade properties
00000000 =FFFFC746                  rFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC747                  rFadeLen	rs.b	1				; Palette fade size
00000000                            
00000000 =FFFFC748                  rLagCount	rs.b	1				; Lag frame counter
00000000                            
00000000 =FFFFC749                  rHIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74A                  rVIntJmp	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74C                  rVIntAddr	rs.l	1				; V-INT address
00000000 =FFFFC750                  rHIntJmp	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC752                  rHIntAddr	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC756                  rFrameCnt	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75A                  rGameMode	rs.b	1				; Game mode ID
00000000 =FFFFC75B                  rSprCount	rs.b	1				; Sprite count
00000000 =FFFFC75C                  rPauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75D                  rHIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC75E                  rHIntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC75F                  rHIntCnt	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC760                  rRNGSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC764                  rVDPReg1	rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC766                  rWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC768                  rMoveCheat	rs.b	1
00000000 =FFFFC769                  rArtCheat	rs.b	1
00000000                            
00000000 =FFFFC76A                  rOscNums	rs.b	0				; Oscillation numbers
00000000 =FFFFC76A                  rOscCtrl	rs.w	1				; Oscillation control
00000000 =FFFFC76C                  rOscData	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AC                  rOscNums_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AC                  rLevel		rs.b	0				; Level ID
00000000 =FFFFC7AC                  rZone		rs.b	1				; Zone ID
00000000 =FFFFC7AD                  rAct		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7AE                  rChkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7AE                  rLastChkpoint	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B0                  rSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B2                  rSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B4                  rChkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B4                  rObjPosAddr	rs.l	1				; Object position data pointer
00000000 =FFFFC7B8                  rObjManInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B9                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7BA                  rObjLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7BE                  rObjLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C2                  rObjRespL	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C4                  rObjRespR	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C6                  rObjXCoarse	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7C8                  rObjYCoarse	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CA                  rObjManX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CC                  rObjManY	rs.w	1				; Object manager's camera Y position
00000000                            
00000000 =FFFFC7CE                  rPalCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7CF                  rPalCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D0                  rGameVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  rGameVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  rStackSpace	rs.b	$100				; Stack space
00000000 =00000000                  rStackBase	rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000 =FFFFC7D0                  rBlocks		rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD0                  rLayout		rs.b	$1000				; Level layout
00000000                            
00000000 =FFFFEFD0                  rScrlSecs	rs.b	$384				; Scroll sections
00000000 =FFFFF354                  rScrlSecs_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF354                  rColList	rs.b	$80				; Collision response list
00000000 =FFFFF3D4                  rColList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF3D4                  rRings		rs.w	1				; Ring count
00000000                            
00000000 =FFFFF3D6                  rRingManRout	rs.b	1				; Ring manager routine
00000000 =FFFFF3D7                  rRingFrame	rs.b	1				; Ring animation frame
00000000                            
00000000 =FFFFF3D8                  rRingAniTime	rs.b	1				; Ring animation timer
00000000 =FFFFF3D9                  rRLossAniT	rs.b	1
00000000 =FFFFF3DA                  rRLossAniA	rs.w	1
00000000 =FFFFF3DC                  rRLossAniF	rs.b	1
00000000                            
00000000 =FFFFF3DD                  rBossDefeat	rs.b	1
00000000                            
00000000 =FFFFF3DE                  rRingStat	rs.b	$400				; Ring status table
00000000 =FFFFF7DE                  rRingStat_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF7DE                  rRingCol	rs.b	0				; Ring collection table
00000000 =FFFFF7DE                  rRingColCnt	rs.w	1				; Ring collection count
00000000 =FFFFF7E0                  rRingColList	rs.b	$7E				; Ring collection list
00000000 =FFFFF85E                  rRingCol_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF85E                  rRingPosAddr	rs.l	1				; Ring position data pointer
00000000 =FFFFF862                  rRingLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFF866                  rRingLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFF86A                  rRingStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFF86C                  rPlayer1Addr	rs.w	1				; Player 1 object address
00000000 =FFFFF86E                  rShield1Addr	rs.w	1				; Player 1 shield address
00000000 =FFFFF870                  rInvinc1Addr	rs.w	1				; Player 1 invincibility address
00000000 =FFFFF872                  rAftImg1Addr	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFF874                  rPlayer2Addr	rs.w	1				; Player 2 object address
00000000 =FFFFF876                  rShield2Addr	rs.w	1				; Player 2 shield address
00000000 =FFFFF878                  rInvinc2Addr	rs.w	1				; Player 2 invincibility address
00000000 =FFFFF87A                  rAftImg2Addr	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFF87C                  rWater1Addr	rs.w	1				; Water surface 1 address
00000000 =FFFFF87E                  rWater2Addr	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFF880                  rCamera		rs.b	0				; Camera RAM
00000000                            
00000000 =FFFFF880                  rFGCam		rs.b	cSize2				; Foreground variables
00000000 =FFFFF89E                  rBGCam		rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFF8BC                  rDestMaxCam	rs.b	0				; Target maximum camera positions
00000000 =FFFFF8BC                  rDestMaxX	rs.w	1				; Target maximum camera X position
00000000 =FFFFF8BE                  rDestMaxY	rs.w	1				; Target maximum camera Y position
00000000 =FFFFF8C0                  rMaxCam		rs.b	0				; Maximum camera positions
00000000 =FFFFF8C0                  rMaxCamX	rs.w	1				; Maximum camera X position
00000000 =FFFFF8C2                  rMaxCamY	rs.w	1				; Maximum camera Y position
00000000 =FFFFF8C4                  rDestMinCam	rs.b	0				; Target minimum camera positions
00000000 =FFFFF8C4                  rDestMinX	rs.w	1				; Target minimum camera X position
00000000 =FFFFF8C6                  rDestMinY	rs.w	1				; Target minimum camera Y position
00000000 =FFFFF8C8                  rMinCam		rs.b	0				; Minimum camera positions
00000000 =FFFFF8C8                  rMinCamX	rs.w	1				; Minimum camera X position
00000000 =FFFFF8CA                  rMinCamY	rs.w	1				; Minimum camera Y position
00000000 =FFFFF8CC                  rCamYPosDist	rs.w	1				; Distance from the player's Y position and the camera's
00000000 =FFFFF8CE                  rCamLocked	rs.b	0				; Camera locked flags
00000000 =FFFFF8CE                  rCamLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFF8CF                  rCamLockY	rs.b	1				; Camera locked vertically flag
00000000 =FFFFF8D0                  rCamMaxChg	rs.b	1				; Camera max Y position changing flag
00000000                            
00000000 =FFFFF8D1                  rCamera_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFF8D1                  rDebugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFF8D2                  rCamXPosCenter	rs.w	1				; Camera X center
00000000                            
00000000 =FFFFF8D4                  rCtrl		rs.b	0				; Player control data
00000000 =FFFFF8D4                  rCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFF8D5                  rCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFF8D6                  rLevelMusic	rs.b	1				; Level music ID
00000000 =FFFFF8D7                  rBossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFF8D8                  r1stCol		rs.l	1				; Primary level collision data pointer
00000000 =FFFFF8DC                  r2ndCol		rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFF8E0                  rColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFF8E4                  rLayerPos	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFF8E6                  rAngleVals	rs.l	1				; Angle value array pointer
00000000 =FFFFF8EA                  rColArrayN	rs.l	1				; Normal height map array pointer
00000000 =FFFFF8EE                  rColArrayR	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFF8F2                  rNextLevel	rs.b	1				; Flag to go to the next level
00000000                            
00000000 =FFFFF8F3                  rUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFF8F4                  rWaterFlag	rs.b	1				; Water in level flag
00000000 =FFFFF8F5                  rWaterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFF8F6                  rWaterLvl	rs.w	1				; Water height
00000000 =FFFFF8F8                  rDestWtrLvl	rs.w	1				; Target water height
00000000                            
00000000 =FFFFF8FA                  rLvlFrames	rs.w	1				; Level frame counter
00000000 =FFFFF8FC                  rLvlReload	rs.b	1				; Level reload flag
00000000 =FFFFF8FD                  rTimeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFF8FE                  rDynEvRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFF8FF                  rFloorActive	rs.b	1				; Floor active flag
00000000 =FFFFF900                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFF902                  rAnimCnts	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFF880                  rCamXPos		equ	rFGCam+cXPos			; Camera X position
00000000 =FFFFF888                  rCamYPos		equ	rFGCam+cYPos			; Camera Y position
00000000 =FFFFF89E                  rCamBGXPos		equ	rBGCam+cXPos			; Background camera X position
00000000 =FFFFF8A6                  rCamBGYPos		equ	rBGCam+cYPos			; Background camera Y position
00000000 =FFFFF89C                  rFGRedraw	equ	rFGCam+cRedraw		; Foreground redraw flag
00000000 =FFFFF8BA                  rBGRedraw	equ	rBGCam+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74A                  vInterrupt	equ	rVIntJmp			; V-INT
00000000 =FFFFC750                  hInterrupt	equ	rHIntJmp			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User Defined Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	rTailNext.w,a0				; load first object slot into a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	oNext(a0),a0				; load the next object address to a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	#rDispInput+(\layer*dSize),oDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	rDispInput+dPrev+(\layer*dSize).w,\fre	; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w	; copy the pointer from the end marker to dst register
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	layer,oDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	oDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,oDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            		move.w	oDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	oDrawNext(\obj),oDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	oDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	oDrawPrev(\obj),oDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            		clr.l	oDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- Character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C750                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74A                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	rStackBase.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4D69 6768 7479 2054 6865+M 	dc.b	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Function libraries
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            		include	"_LIB_/VDP.asm"			; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; Mighty The Armadillo in PRISM PARADISE
000001BC                            ; By Nat The Porcupine 2021
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Initialize the VDP
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; PARAMETERS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; RETURNS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            InitVDP:
000001BC 31FC 8134 C764             		move.w	#$8134,rVDPReg1.w		; Save VDP register 1 in RAM
000001C2 31FC 8AFF C75E             		move.w	#$8AFF,rHIntReg.w		; Save H-INT counter register in RAM
000001C8                            
000001C8 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; Clear the screen and other VDP data (64 tile width)
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; PARAMETERS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; RETURNS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ClearScreen:
000001CC 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000001D2                            		dmaFill	0,$C000,$3000			; Clear planes
000001D2 3CBC 8F01                M 	move.w	#$8f01,(a6)
000001D6 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
000001DC 3CBC 9780                M 	move.w	#$9780,(a6)
000001E0 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
000001E6 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
000001EC                          M 	waitdma	(a6)
000001EC                          M .wait_22:
000001EC 3216                     M 	move.w	(a6),d1
000001EE 0801 0001                M 	btst	#1,d1
000001F2 66F8                     M 	bne.s	.wait_22
000001F4 3CBC 8F02                M 	move.w	#$8f02,(a6)
000001F8                            
000001F8                            		clrRAM	rHScroll, rVScroll_End	; Clear scroll tables
000001F8                          M 	local	endaddr
000001F8                          M endaddr	equs	"rvscroll_end"
000001F8 7000                     M 	moveq	#0,d0
000001FA 43F8 90FE                M 	lea	(rhscroll).w,a1
000001FE 323C 00F3                M 	move.w	#(((rvscroll_end)-(rhscroll))-((rhscroll)&1))>>2-1,d1
00000202 22C0                     M .clear_23:	move.l	d0,(a1)+
00000204 51C9 FFFC                M 	dbf	d1,.clear_23
00000208                            		
00000208 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; Load a plane map
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; PARAMETERS:
0000020C                            ;	d0.l	- VDP command for writing the data to VRAM
0000020C                            ;	d1.w	- Width in tiles (minus 1)
0000020C                            ;	d2.w	- Height in tiles (minus 1)
0000020C                            ;	d3.w	- Base tile properties for each tile
0000020C                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
0000020C                            ;	a1.l	- Plane map address
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; RETURNS:
0000020C                            ;	Nothing
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            LoadPlaneMap:
0000020C                            LoadPlaneMap_H64:
0000020C 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
00000212 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000214                            
00000214                            LoadPlaneMap_H32:
00000214 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
0000021A 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
0000021C                            
0000021C                            LoadPlaneMap_H128:
0000021C 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
00000222                            
00000222                            LoadPlaneMap_Custom:
00000222                            .RowLoop:
00000222 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000228 3801                       		move.w	d1,d4				; Store width
0000022A                            
0000022A                            .TileLoop:
0000022A 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
0000022C DA43                       		add.w	d3,d5				; Add base tile properties
0000022E 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
00000234 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000238 D086                       		add.l	d6,d0				; Next row
0000023A 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
0000023E 4E75                       		rts
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; Load a plane map into RAM
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; PARAMETERS:
00000240                            ;	d1.w	- Width in tiles (minus 1)
00000240                            ;	d2.w	- Height in tiles (minus 1)
00000240                            ;	d3.w	- Base tile properties for each tile
00000240                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000240                            ;	a0.l	- Buffer to load into
00000240                            ;	a1.l	- Plane map address
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; RETURNS:
00000240                            ;	Nothing
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            LoadPlaneMap_RAM:
00000240                            .RowLoop:
00000240 2448                       		movea.l	a0,a2				; Copy buffer address
00000242 3801                       		move.w	d1,d4				; Store width
00000244                            
00000244                            .TileLoop:
00000244 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
00000246 DA43                       		add.w	d3,d5				; Add base tile properties
00000248 34C5                       		move.w	d5,(a2)+			; Save in RAM
0000024A 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
0000024E D0FC 0080                  		adda.w	#$80,a0				; Next row
00000252 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000256 4E75                       		rts
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; Fill the plane map with a value in a specific region
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; PARAMETERS:
00000258                            ;	d0.l	- VDP command for writing the data to VRAM
00000258                            ;	d1.w	- Width in tiles (minus 1)
00000258                            ;	d2.w	- Height in tiles (minus 1)
00000258                            ;	d3.w	- Value to fill plane map with
00000258                            ;	d6.l	- Delta value for drawing to the next row
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; RETURNS:
00000258                            ;	Nothing
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            FillPlaneMap:
00000258                            FillPlaneMap_H64:
00000258 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000025E 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000260                            
00000260                            FillPlaneMap_H32:
00000260 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000266 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000268                            
00000268                            FillPlaneMap_H128:
00000268 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000026E                            
0000026E                            FillPlaneMap_Custom:
0000026E                            .RowLoop:
0000026E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000274 3801                       		move.w	d1,d4				; Store width
00000276                            
00000276                            .TileLoop:
00000276 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
0000027C 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000280 D086                       		add.l	d6,d0				; Next row
00000282 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000286 4E75                       		rts
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000288                            ; to be cleared by issuing the commands (this checks for overflow)
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ; 	d1.l	- Source address
00000288                            ; 	d2.w	- Destination address
00000288                            ; 	d3.w	- Transfer length
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000288                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000288 =00000001                  Use128kbSafeDMA		= 1
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000288                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000288                            ; before calling and then restore interrupts after.
00000288 =00000000                  UseVIntSafeDMA		= 0
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000288                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000288                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000288 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Convenience macros, for increased maintainability of the code.
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Like vdpComm, but starting from an address contained in a register
00000288 =00000001                  vdpCommReg_defined = 1
00000288                            vdpCommReg	macro	reg, type, rwd, clr
00000288                            		local	cd
00000288                            cd		= \type&\rwd
00000288                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000288                            		if ((cd)&3)<>0
00000288                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000288                            		endif
00000288                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000288                            							; (word-swapped) places
00000288                            		swap	\reg				; Put all bits in proper places
00000288                            		if \clr<>0
00000288                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000288                            		endif
00000288                            		if ((cd)&$FC)=$20
00000288                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000288                            		elseif ((cd)&$FC)<>0
00000288                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000288                            		endif
00000288                            		endm
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            QueueDMATransfer:
00000288                            
00000288 3278 90FC                  		movea.w	rDMASlot.w,a1
0000028C B2FC 90FC                  		cmpa.w	#rDMASlot,a1
00000290 6700                       		beq.s	.Done				; Return if there's no more room in the queue
00000292                            
00000292 E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000294                            
00000294 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000296                            			; Compute position of last transferred word. This handles 2 cases:
00000296                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000296                            			; (2) (source+length)&$FFFF = 0
00000296 5340                       			subq.w  #1,d0
00000298 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
0000029A 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
0000029C                            
0000029C                            		; Store VDP commands for specifying DMA into the queue
0000029C 4841                       		swap	d1				; Want the high byte first
0000029E 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
000002A2 C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
000002A4 32C0                       		move.w	d0,(a1)+			; Store command
000002A6 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
000002A8 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
000002AC 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
000002B0                            
000002B0                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
000002B0                          M 	local	cd
000002B0 =00000021                M cd	=	vram&dma
000002B0 E58A                     M 	lsl.l	#2,d2
000002B2 5242                     M 	addq.w	#((cd)&3),d2
000002B4 E45A                     M 	ror.w	#2,d2
000002B6 4842                     M 	swap	d2
000002B8 0242 0003                M 	andi.w	#3,d2
000002BC 4AC2                     M 	tas.b	d2
000002BE 22C2                       		move.l	d2,(a1)+			; Store command
000002C0                            
000002C0 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
000002C2 31C9 90FC                  		move.w	a1,rDMASlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000002C6                            
000002C6                            .Done:
000002C6 4E75                       		rts
000002C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002C8                            .DoubleTransfer:
000002C8                            			; Hand-coded version to break the DMA transfer into two smaller transfers
000002C8                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
000002C8                            			; of space) than by the method of saving parameters and calling the normal
000002C8                            			; DMA function twice, as Sonic3_Complete does.
000002C8                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
000002C8 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
000002CA 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
000002CC                            
000002CC                            			; Store VDP commands for specifying DMA into the queue
000002CC 4841                       			swap	d1			; Want the high byte first
000002CE                            
000002CE                            			; Sadly, all registers we can spare are in use right now, so we can't use
000002CE                            			; no-cost RAM source safety.
000002CE 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
000002D2 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
000002D6 32C1                       			move.w	d1,(a1)+		; Store command
000002D8 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
000002DA 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
000002DE 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
000002E0 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
000002E4 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
000002E8                            
000002E8 3602                       			move.w	d2,d3			; Save for later
000002EA                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
000002EA                          M 	local	cd
000002EA =00000021                M cd	=	vram&dma
000002EA E58A                     M 	lsl.l	#2,d2
000002EC 5242                     M 	addq.w	#((cd)&3),d2
000002EE E45A                     M 	ror.w	#2,d2
000002F0 4842                     M 	swap	d2
000002F2 0242 0003                M 	andi.w	#3,d2
000002F6 4AC2                     M 	tas.b	d2
000002F8 22C2                       			move.l	d2,(a1)+		; Store command
000002FA                            
000002FA B2FC 90FC                  			cmpa.w	#rDMASlot,a1		; Did this command fill the queue?
000002FE 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
00000300                            
00000300                            			; Store VDP commands for specifying DMA into the queue
00000300                            			; The source address high byte was done above already in the comments marked
00000300                            			; with (**)
00000300 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
00000302 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000304 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000308 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
0000030C                            
0000030C                            			; d1 contains length up to the end of the 128kB boundary
0000030C D241                       			add.w	d1,d1			; Convert it into byte length...
0000030E D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
00000310                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
00000310                          M 	local	cd
00000310 =00000021                M cd	=	vram&dma
00000310 E589                     M 	lsl.l	#2,d1
00000312 5241                     M 	addq.w	#((cd)&3),d1
00000314 E459                     M 	ror.w	#2,d1
00000316 4841                     M 	swap	d1
00000318 0241 0003                M 	andi.w	#3,d1
0000031C 4AC1                     M 	tas.b	d1
0000031E 22C1                       			move.l	d1,(a1)+		; Store command
00000320                            
00000320 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
00000322 31C9 90FC                  			move.w	a1,rDMASlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000326                            
00000326 4E75                       			rts
00000328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000328                            .SkipSecondTransfer:
00000328 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
0000032A                            	
0000032A 4E75                       			rts
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; PARAMETERS:
0000032C                            ;	a6.l	- VDP control port
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; RETURNS:
0000032C                            ;	Nothing
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ProcessDMAQueue:
0000032C 43F8 9000                  		lea	rDMAQueue.w,a1
00000330 31C9 90FC                  		move.w	a1,rDMASlot.w
00000334                            
00000334                            		rept (rDMASlot-rDMAQueue)/(7*2)
00000334                            			move.w	(a1)+,d0
00000334                            			beq.w	.Done			; Branch if we reached a stop token
00000334                            			
00000334                            			move.w	d0,(a6)			; Issue a set of VDP commands...
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            		endr
00000334 3019                     M 	move.w	(a1)+,d0
00000336 6700 0000                M 	beq.w	.done
0000033A 3C80                     M 	move.w	d0,(a6)
0000033C 2C99                     M 	move.l	(a1)+,(a6)
0000033E 2C99                     M 	move.l	(a1)+,(a6)
00000340 3C99                     M 	move.w	(a1)+,(a6)
00000342 3C99                     M 	move.w	(a1)+,(a6)
00000344 3019                     M 	move.w	(a1)+,d0
00000346 6700 0000                M 	beq.w	.done
0000034A 3C80                     M 	move.w	d0,(a6)
0000034C 2C99                     M 	move.l	(a1)+,(a6)
0000034E 2C99                     M 	move.l	(a1)+,(a6)
00000350 3C99                     M 	move.w	(a1)+,(a6)
00000352 3C99                     M 	move.w	(a1)+,(a6)
00000354 3019                     M 	move.w	(a1)+,d0
00000356 6700 0000                M 	beq.w	.done
0000035A 3C80                     M 	move.w	d0,(a6)
0000035C 2C99                     M 	move.l	(a1)+,(a6)
0000035E 2C99                     M 	move.l	(a1)+,(a6)
00000360 3C99                     M 	move.w	(a1)+,(a6)
00000362 3C99                     M 	move.w	(a1)+,(a6)
00000364 3019                     M 	move.w	(a1)+,d0
00000366 6700 0000                M 	beq.w	.done
0000036A 3C80                     M 	move.w	d0,(a6)
0000036C 2C99                     M 	move.l	(a1)+,(a6)
0000036E 2C99                     M 	move.l	(a1)+,(a6)
00000370 3C99                     M 	move.w	(a1)+,(a6)
00000372 3C99                     M 	move.w	(a1)+,(a6)
00000374 3019                     M 	move.w	(a1)+,d0
00000376 6700 0000                M 	beq.w	.done
0000037A 3C80                     M 	move.w	d0,(a6)
0000037C 2C99                     M 	move.l	(a1)+,(a6)
0000037E 2C99                     M 	move.l	(a1)+,(a6)
00000380 3C99                     M 	move.w	(a1)+,(a6)
00000382 3C99                     M 	move.w	(a1)+,(a6)
00000384 3019                     M 	move.w	(a1)+,d0
00000386 6700 0000                M 	beq.w	.done
0000038A 3C80                     M 	move.w	d0,(a6)
0000038C 2C99                     M 	move.l	(a1)+,(a6)
0000038E 2C99                     M 	move.l	(a1)+,(a6)
00000390 3C99                     M 	move.w	(a1)+,(a6)
00000392 3C99                     M 	move.w	(a1)+,(a6)
00000394 3019                     M 	move.w	(a1)+,d0
00000396 6700 0000                M 	beq.w	.done
0000039A 3C80                     M 	move.w	d0,(a6)
0000039C 2C99                     M 	move.l	(a1)+,(a6)
0000039E 2C99                     M 	move.l	(a1)+,(a6)
000003A0 3C99                     M 	move.w	(a1)+,(a6)
000003A2 3C99                     M 	move.w	(a1)+,(a6)
000003A4 3019                     M 	move.w	(a1)+,d0
000003A6 6700 0000                M 	beq.w	.done
000003AA 3C80                     M 	move.w	d0,(a6)
000003AC 2C99                     M 	move.l	(a1)+,(a6)
000003AE 2C99                     M 	move.l	(a1)+,(a6)
000003B0 3C99                     M 	move.w	(a1)+,(a6)
000003B2 3C99                     M 	move.w	(a1)+,(a6)
000003B4 3019                     M 	move.w	(a1)+,d0
000003B6 6700 0000                M 	beq.w	.done
000003BA 3C80                     M 	move.w	d0,(a6)
000003BC 2C99                     M 	move.l	(a1)+,(a6)
000003BE 2C99                     M 	move.l	(a1)+,(a6)
000003C0 3C99                     M 	move.w	(a1)+,(a6)
000003C2 3C99                     M 	move.w	(a1)+,(a6)
000003C4 3019                     M 	move.w	(a1)+,d0
000003C6 6700 0000                M 	beq.w	.done
000003CA 3C80                     M 	move.w	d0,(a6)
000003CC 2C99                     M 	move.l	(a1)+,(a6)
000003CE 2C99                     M 	move.l	(a1)+,(a6)
000003D0 3C99                     M 	move.w	(a1)+,(a6)
000003D2 3C99                     M 	move.w	(a1)+,(a6)
000003D4 3019                     M 	move.w	(a1)+,d0
000003D6 6700 0000                M 	beq.w	.done
000003DA 3C80                     M 	move.w	d0,(a6)
000003DC 2C99                     M 	move.l	(a1)+,(a6)
000003DE 2C99                     M 	move.l	(a1)+,(a6)
000003E0 3C99                     M 	move.w	(a1)+,(a6)
000003E2 3C99                     M 	move.w	(a1)+,(a6)
000003E4 3019                     M 	move.w	(a1)+,d0
000003E6 6700 0000                M 	beq.w	.done
000003EA 3C80                     M 	move.w	d0,(a6)
000003EC 2C99                     M 	move.l	(a1)+,(a6)
000003EE 2C99                     M 	move.l	(a1)+,(a6)
000003F0 3C99                     M 	move.w	(a1)+,(a6)
000003F2 3C99                     M 	move.w	(a1)+,(a6)
000003F4 3019                     M 	move.w	(a1)+,d0
000003F6 6700 0000                M 	beq.w	.done
000003FA 3C80                     M 	move.w	d0,(a6)
000003FC 2C99                     M 	move.l	(a1)+,(a6)
000003FE 2C99                     M 	move.l	(a1)+,(a6)
00000400 3C99                     M 	move.w	(a1)+,(a6)
00000402 3C99                     M 	move.w	(a1)+,(a6)
00000404 3019                     M 	move.w	(a1)+,d0
00000406 6700 0000                M 	beq.w	.done
0000040A 3C80                     M 	move.w	d0,(a6)
0000040C 2C99                     M 	move.l	(a1)+,(a6)
0000040E 2C99                     M 	move.l	(a1)+,(a6)
00000410 3C99                     M 	move.w	(a1)+,(a6)
00000412 3C99                     M 	move.w	(a1)+,(a6)
00000414 3019                     M 	move.w	(a1)+,d0
00000416 6700 0000                M 	beq.w	.done
0000041A 3C80                     M 	move.w	d0,(a6)
0000041C 2C99                     M 	move.l	(a1)+,(a6)
0000041E 2C99                     M 	move.l	(a1)+,(a6)
00000420 3C99                     M 	move.w	(a1)+,(a6)
00000422 3C99                     M 	move.w	(a1)+,(a6)
00000424 3019                     M 	move.w	(a1)+,d0
00000426 6700 0000                M 	beq.w	.done
0000042A 3C80                     M 	move.w	d0,(a6)
0000042C 2C99                     M 	move.l	(a1)+,(a6)
0000042E 2C99                     M 	move.l	(a1)+,(a6)
00000430 3C99                     M 	move.w	(a1)+,(a6)
00000432 3C99                     M 	move.w	(a1)+,(a6)
00000434 3019                     M 	move.w	(a1)+,d0
00000436 6700 0000                M 	beq.w	.done
0000043A 3C80                     M 	move.w	d0,(a6)
0000043C 2C99                     M 	move.l	(a1)+,(a6)
0000043E 2C99                     M 	move.l	(a1)+,(a6)
00000440 3C99                     M 	move.w	(a1)+,(a6)
00000442 3C99                     M 	move.w	(a1)+,(a6)
00000444 3019                     M 	move.w	(a1)+,d0
00000446 6700 0000                M 	beq.w	.done
0000044A 3C80                     M 	move.w	d0,(a6)
0000044C 2C99                     M 	move.l	(a1)+,(a6)
0000044E 2C99                     M 	move.l	(a1)+,(a6)
00000450 3C99                     M 	move.w	(a1)+,(a6)
00000452 3C99                     M 	move.w	(a1)+,(a6)
00000454 7000                       		moveq	#0,d0
00000456                            
00000456                            .Done:
00000456 31C0 9000                  		move.w	d0,rDMAQueue.w
0000045A 4E75                       		rts
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; Initialize the DMA queue
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; PARAMETERS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; RETURNS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            InitDMAQueue:
0000045C 43F8 9000                  		lea	rDMAQueue.w,a1
00000460 32BC 0000                  		move.w	#0,(a1)
00000464 31C9 90FC                  		move.w	a1,rDMASlot.w
00000468 223C 9695 9493             		move.l	#$96959493,d1
0000046E =00000000                  c		= 0
0000046E                            		rept (rDMASlot-rDMAQueue)/(7*2)
0000046E                            			movep.l	d1,2+c(a1)
0000046E                            c			= c+14
0000046E                            		endr
0000046E 03C9 0002                M 	movep.l	d1,2+c(a1)
00000472 =0000000E                M c	=	c+14
00000472 03C9 0010                M 	movep.l	d1,2+c(a1)
00000476 =0000001C                M c	=	c+14
00000476 03C9 001E                M 	movep.l	d1,2+c(a1)
0000047A =0000002A                M c	=	c+14
0000047A 03C9 002C                M 	movep.l	d1,2+c(a1)
0000047E =00000038                M c	=	c+14
0000047E 03C9 003A                M 	movep.l	d1,2+c(a1)
00000482 =00000046                M c	=	c+14
00000482 03C9 0048                M 	movep.l	d1,2+c(a1)
00000486 =00000054                M c	=	c+14
00000486 03C9 0056                M 	movep.l	d1,2+c(a1)
0000048A =00000062                M c	=	c+14
0000048A 03C9 0064                M 	movep.l	d1,2+c(a1)
0000048E =00000070                M c	=	c+14
0000048E 03C9 0072                M 	movep.l	d1,2+c(a1)
00000492 =0000007E                M c	=	c+14
00000492 03C9 0080                M 	movep.l	d1,2+c(a1)
00000496 =0000008C                M c	=	c+14
00000496 03C9 008E                M 	movep.l	d1,2+c(a1)
0000049A =0000009A                M c	=	c+14
0000049A 03C9 009C                M 	movep.l	d1,2+c(a1)
0000049E =000000A8                M c	=	c+14
0000049E 03C9 00AA                M 	movep.l	d1,2+c(a1)
000004A2 =000000B6                M c	=	c+14
000004A2 03C9 00B8                M 	movep.l	d1,2+c(a1)
000004A6 =000000C4                M c	=	c+14
000004A6 03C9 00C6                M 	movep.l	d1,2+c(a1)
000004AA =000000D2                M c	=	c+14
000004AA 03C9 00D4                M 	movep.l	d1,2+c(a1)
000004AE =000000E0                M c	=	c+14
000004AE 03C9 00E2                M 	movep.l	d1,2+c(a1)
000004B2 =000000EE                M c	=	c+14
000004B2 03C9 00F0                M 	movep.l	d1,2+c(a1)
000004B6 =000000FC                M c	=	c+14
000004B6 4E75                       		rts
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; Load a palette into the main palette buffer
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; PARAMETERS:
000004B8                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004B8                            ;	a0.l	- Pointer to palette data
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            LoadPalette:
000004B8 43F8 98CE                  		lea	rPalette.w,a1			; Main palette buffer
000004BC 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; Load a palette into the target palette buffer
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; PARAMETERS:
000004BE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004BE                            ;	a0.l	- Pointer to palette data
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            LoadTargetPal:
000004BE 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000004C2 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; Load a palette into the main water palette buffer
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; PARAMETERS:
000004C4                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004C4                            ;	a0.l	- Pointer to palette data
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            LoadWaterPal:
000004C4 43F8 984E                  		lea	rWaterPal.w,a1		; Main water palette buffer
000004C8 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; Load a palette into the target water palette buffer
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; PARAMETERS:
000004CA                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CA                            ;	a0.l	- Pointer to palette data
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            LoadTargetWaterPal:
000004CA 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; Load a palette into a palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; PARAMETERS:
000004CE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CE                            ;	a0.l	- Pointer to palette data
000004CE                            ;	a1.l	- Pointer to destination buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            LoadPalToBuf:
000004CE 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
000004D0 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
000004D4 4E75                       		rts
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; Fade the palette to black
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; PARAMETERS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; RETURNS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            FadeToBlack:
000004D6 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000004DC                            
000004DC                            FadeToBlack_Custom:
000004DC 7807                       		moveq	#7,d4				; Set repeat times
000004DE                            		
000004DE                            .FadeLoop:
000004DE                            		rept	2
000004DE                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000004DE                            			bsr.w	VSync_Routine		; Do V-SYNC
000004DE                            		endr
000004DE 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004E4 6100 0000                M 	bsr.w	vsync_routine
000004E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004EE 6100 0000                M 	bsr.w	vsync_routine
000004F2 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
000004F4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000004F8 4E75                       		rts
000004FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004FA                            FadeToBlack_Once:
000004FA 7000                       		moveq	#0,d0
000004FC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000500 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000504 D0C0                       		adda.w	d0,a0				; ''
00000506 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000050A                            
0000050A                            .FadeLoop:
0000050A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000050C 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000510                            
00000510 7000                       		moveq	#0,d0
00000512 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000516 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000051A D0C0                       		adda.w	d0,a0				; ''
0000051C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000520                            
00000520                            .FadeLoopWater:
00000520 6100                       		bsr.s	.FadeColor			; Fade a color			
00000522 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000526 4E75                       		rts
00000528                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000528                            .FadeColor:
00000528 3A10                       		move.w	(a0),d5				; Load color
0000052A 6700                       		beq.s	.NoRed				; If the color is already black, branch
0000052C 3205                       		move.w	d5,d1				; Copy color
0000052E 1401                       		move.b	d1,d2				; Load green and red
00000530 1601                       		move.b	d1,d3				; Load only red
00000532                            
00000532 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000536 6700                       		beq.s	.NoBlue				; If blue is finished, branch
00000538 0445 0200                  		subi.w	#$200,d5			; Decrease blue
0000053C                            
0000053C                            .NoBlue:
0000053C 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000540 6700                       		beq.s	.NoGreen			; If green is finished, branch
00000542 0445 0020                  		subi.w	#$20,d5				; Decrease green
00000546                            
00000546                            .NoGreen:
00000546 0203 000E                  		andi.b	#$E,d3				; Get only red
0000054A 6700                       		beq.s	.NoRed				; If red is finished, branch
0000054C 5545                       		subq.w	#2,d5				; Decrease red
0000054E                            
0000054E                            .NoRed:
0000054E 30C5                       		move.w	d5,(a0)+			; Save the color
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette from black to the target palette
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeFromBlack:
00000552 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000558                            
00000558                            FadeFromBlack_Custom:
00000558 780E                       		moveq	#$E,d4				; Maximum color check
0000055A                            
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
00000570 5504                       		subq.b	#2,d4				; Decrement color check
00000572 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
00000574                            
00000574 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
0000057A 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000057E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000057E                            FadeFromBlack_Once:
0000057E 7000                       		moveq	#0,d0
00000580 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000584 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000588 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000058C D0C0                       		adda.w	d0,a0				; ''
0000058E D2C0                       		adda.w	d0,a1				; ''
00000590 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000594                            
00000594                            .FadeLoop:
00000594 6100                       		bsr.s	.FadeColor			; Fade a color			
00000596 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000059A                            
0000059A 7000                       		moveq	#0,d0
0000059C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000005A0 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000005A4 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000005A8 D0C0                       		adda.w	d0,a0				; ''
000005AA D2C0                       		adda.w	d0,a1				; ''
000005AC 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000005B0                            
000005B0                            .FadeLoopWater:
000005B0 6100                       		bsr.s	.FadeColor			; Fade a color			
000005B2 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005B6 4E75                       		rts
000005B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005B8                            .FadeColor:
000005B8 1A11                       		move.b	(a1),d5				; Load blue
000005BA 3219                       		move.w	(a1)+,d1			; Load green and red
000005BC 1401                       		move.b	d1,d2				; Load red
000005BE E809                       		lsr.b	#4,d1				; Get only green
000005C0 0202 000E                  		andi.b	#$E,d2				; Get only red
000005C4                            
000005C4 3610                       		move.w	(a0),d3				; Load current color
000005C6 B805                       		cmp.b	d5,d4				; Should the blue fade?
000005C8 6200                       		bhi.s	.NoBlue				; If not, branch
000005CA 0643 0200                  		addi.w	#$200,d3			; Increase blue
000005CE                            
000005CE                            .NoBlue:
000005CE B801                       		cmp.b	d1,d4				; Should the green fade?
000005D0 6200                       		bhi.s	.NoGreen			; If not, branch
000005D2 0643 0020                  		addi.w	#$20,d3				; Increase green
000005D6                            
000005D6                            .NoGreen:
000005D6 B802                       		cmp.b	d2,d4				; Should the red fade?
000005D8 6200                       		bhi.s	.NoRed				; If not, branch
000005DA 5443                       		addq.w	#2,d3				; Increase red
000005DC                            
000005DC                            .NoRed:
000005DC 30C3                       		move.w	d3,(a0)+			; Save the color
000005DE 4E75                       		rts
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; Fade the palette to white
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; PARAMETERS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; RETURNS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            FadeToWhite:
000005E0 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000005E6                            
000005E6                            FadeToWhite_Custom:
000005E6 7807                       		moveq	#7,d4				; Set repeat times
000005E8                            
000005E8                            .FadeLoop:
000005E8                            		rept	2
000005E8                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000005E8                            			bsr.w	VSync_Routine		; Do V-SYNC
000005E8                            		endr
000005E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005EE 6100 0000                M 	bsr.w	vsync_routine
000005F2 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005F8 6100 0000                M 	bsr.w	vsync_routine
000005FC 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
000005FE 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000602 4E75                       		rts
00000604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000604                            FadeToWhite_Once:
00000604 7000                       		moveq	#0,d0
00000606 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000060A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000060E D0C0                       		adda.w	d0,a0				; ''
00000610 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000614                            
00000614                            .FadeLoop:
00000614 6100                       		bsr.s	.FadeColor			; Fade a color			
00000616 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000061A                            
0000061A 7000                       		moveq	#0,d0
0000061C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000620 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000062A                            
0000062A                            .FadeLoopWater:
0000062A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000630 4E75                       		rts
00000632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000632                            .FadeColor:
00000632 3A10                       		move.w	(a0),d5				; Load color
00000634 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
00000638 6700                       		beq.s	.NoRed				; If so, branch
0000063A 3205                       		move.w	d5,d1				; Copy color
0000063C 1401                       		move.b	d1,d2				; Load green and red
0000063E 1601                       		move.b	d1,d3				; Load only red
00000640                            
00000640 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000644 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
00000648 6700                       		beq.s	.NoBlue				; If do, branch
0000064A 0645 0200                  		addi.w	#$200,d5			; Increase blue
0000064E                            
0000064E                            .NoBlue:
0000064E 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000652 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
00000656 6700                       		beq.s	.NoGreen			; If so, branch
00000658 0645 0020                  		addi.w	#$20,d5				; Increase green
0000065C                            
0000065C                            .NoGreen:
0000065C 0203 000E                  		andi.b	#$E,d3				; Get only red
00000660 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
00000664 6700                       		beq.s	.NoRed				; If so, branch
00000666 5445                       		addq.w	#2,d5				; Increase red
00000668                            
00000668                            .NoRed:
00000668 30C5                       		move.w	d5,(a0)+			; Save the color
0000066A 4E75                       		rts
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; Fade the palette from white to the target palette
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; PARAMETERS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; RETURNS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            FadeFromWhite:
0000066C 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000672                            
00000672                            FadeFromWhite_Custom:
00000672 7800                       		moveq	#0,d4				; Minimum color check
00000674                            		
00000674                            .FadeLoop:
00000674                            		rept	2
00000674                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000674                            			bsr.w	VSync_Routine		; Do V-SYNC
00000674                            		endr
00000674 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000067A 6100 0000                M 	bsr.w	vsync_routine
0000067E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000684 6100 0000                M 	bsr.w	vsync_routine
00000688 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
0000068A 5404                       		addq.b	#2,d4				; Decrement color check
0000068C 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
00000690 66E2                       		bne.s	.FadeLoop			; If not, branch
00000692                            
00000692 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
00000698 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000069C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000069C                            FadeFromWhite_Once:
0000069C 7000                       		moveq	#0,d0
0000069E 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
000006A2 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000006A6 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006AA D0C0                       		adda.w	d0,a0				; ''
000006AC D2C0                       		adda.w	d0,a1				; ''
000006AE 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006B2                            
000006B2                            .FadeLoop:
000006B2 6100                       		bsr.s	.FadeColor			; Fade a color			
000006B4 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000006B8                            
000006B8 7000                       		moveq	#0,d0
000006BA 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000006BE 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000006C2 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006C6 D0C0                       		adda.w	d0,a0				; ''
000006C8 D2C0                       		adda.w	d0,a1				; ''
000006CA 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006CE                            
000006CE                            .FadeLoopWater:
000006CE 6100                       		bsr.s	.FadeColor			; Fade a color			
000006D0 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006D4 4E75                       		rts
000006D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006D6                            .FadeColor:
000006D6 1A11                       		move.b	(a1),d5				; Load blue
000006D8 3219                       		move.w	(a1)+,d1			; Load green and red
000006DA 1401                       		move.b	d1,d2				; Load red
000006DC E809                       		lsr.b	#4,d1				; Get only green
000006DE 0202 000E                  		andi.b	#$E,d2				; Get only red
000006E2                            
000006E2 3610                       		move.w	(a0),d3				; Load current color
000006E4 B805                       		cmp.b	d5,d4				; Should the blue fade?
000006E6 6500                       		bcs.s	.NoBlue				; If not, branch
000006E8 0443 0200                  		subi.w	#$200,d3			; Decrease blue
000006EC                            
000006EC                            .NoBlue:
000006EC B801                       		cmp.b	d1,d4				; Should the green fade?
000006EE 6500                       		bcs.s	.NoGreen			; If not, branch
000006F0 0443 0020                  		subi.w	#$20,d3				; Decrease green
000006F4                            
000006F4                            .NoGreen:
000006F4 B802                       		cmp.b	d2,d4				; Should the red fade?
000006F6 6500                       		bcs.s	.NoRed				; If not, branch
000006F8 5543                       		subq.w	#2,d3				; Decrease red
000006FA                            
000006FA                            .NoRed:
000006FA 30C3                       		move.w	d3,(a0)+			; Save the color
000006FC 4E75                       		rts
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; Fade the palette from the current palette to the target palette
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; PARAMETERS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; RETURNS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            FadeToPalette:
000006FE 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000704                            
00000704                            FadeToPalette_Custom:
00000704 7000                       		moveq	#0,d0
00000706 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000070A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000070E D0C0                       		adda.w	d0,a0				; ''
00000710                            
00000710 7807                       		moveq	#7,d4				; Set repeat times
00000712                            
00000712                            .FadeLoop:
00000712                            		rept	2
00000712                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000712                            			bsr.w	VSync_Routine		; Do V-SYNC
00000712                            		endr
00000712 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000718 6100 0000                M 	bsr.w	vsync_routine
0000071C 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000722 6100 0000                M 	bsr.w	vsync_routine
00000726 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
00000728 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000072C 4E75                       		rts
0000072E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000072E                            FadeToPalette_Once:
0000072E 7000                       		moveq	#0,d0
00000730 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000734 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000738 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000073C D0C0                       		adda.w	d0,a0				; ''
0000073E D2C0                       		adda.w	d0,a1				; ''
00000740 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000744                            
00000744                            .FadeLoop:
00000744 6100                       		bsr.s	.FadeColor			; Fade a color			
00000746 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000074A                            
0000074A 7000                       		moveq	#0,d0
0000074C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000750 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
00000754 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000758 D0C0                       		adda.w	d0,a0				; ''
0000075A D2C0                       		adda.w	d0,a1				; ''
0000075C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000760                            
00000760                            .FadeLoopWater:
00000760 6100                       		bsr.s	.FadeColor			; Fade a color			
00000762 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000766 4E75                       		rts
00000768                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000768                            .FadeColor:
00000768 3610                       		move.w	(a0),d3				; Get color
0000076A B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
0000076C 6700                       		beq.s	.NoRed				; If so, branch
0000076E                            		
0000076E 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
00000772 1401                       		move.b	d1,d2				; Get red only
00000774 0202 000E                  		andi.b	#$E,d2				; ''
00000778 E809                       		lsr.b	#4,d1				; Get green only
0000077A                            
0000077A 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
0000077E BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
00000780 6700                       		beq.s	.NoBlue				; If not, branch
00000782 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000784 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000788 6000                       		bra.s	.NoBlue				; Continue
0000078A                            
0000078A                            .DecBlue:
0000078A 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000078E                            
0000078E                            .NoBlue:
0000078E 3A10                       		move.w	(a0),d5				; Get green
00000790 E80D                       		lsr.b	#4,d5				; ''
00000792 B205                       		cmp.b	d5,d1				; Does green need to fade?
00000794 6700                       		beq.s	.NoGreen			; If not, branch
00000796 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000798 0603 0020                  		addi.b	#$20,d3				; Increase green
0000079C 6000                       		bra.s	.NoGreen			; Continue
0000079E                            
0000079E                            .DecGreen:
0000079E 0403 0020                  		subi.b	#$20,d3				; Decrease green
000007A2                            
000007A2                            .NoGreen:
000007A2 3A10                       		move.w	(a0),d5				; Get red
000007A4 0205 000E                  		andi.b	#$E,d5				; ''
000007A8 B405                       		cmp.b	d5,d2				; Does red need to fade?
000007AA 6700                       		beq.s	.NoRed				; If not, branch
000007AC 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
000007AE 5403                       		addq.b	#2,d3				; Increase red
000007B0 6000                       		bra.s	.NoRed				; Continue
000007B2                            
000007B2                            .DecRed:
000007B2 5503                       		subq.b	#2,d3				; Decrease red
000007B4                            
000007B4                            .NoRed:
000007B4 30C3                       		move.w	d3,(a0)+			; Save new color
000007B6 4E75                       		rts
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            ; Initialize the sprite table
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            InitSpriteTable:
000007B8 7000                       		moveq	#0,d0
000007BA 41F8 94CE                  		lea	rSprites.w,a0			; Sprite table buffer
000007BE 7201                       		moveq	#1,d1				; Link value
000007C0 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
000007C2                            
000007C2                            .Loop:
000007C2 3080                       		move.w	d0,(a0)				; Move off screen
000007C4 1141 0003                  		move.b	d1,3(a0)			; Set link value
000007C8 5241                       		addq.w	#1,d1				; Increment link value
000007CA 5048                       		addq.w	#8,a0				; Next sprite
000007CC 51CF FFF4                  		dbf	d7,.Loop			; Loop
000007D0 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
000007D4 4E75                       		rts
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; Draw the sprites from mappings
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; PARAMETERS:
000007D6                            ;	d0.w	- X position
000007D6                            ;	d1.w	- Y position
000007D6                            ;	d4.w	- Number of sprites to draw
000007D6                            ;	d5.w	- Sprite tile properties
000007D6                            ;	d6.b	- Render flags
000007D6                            ;	d7.w	- Max number of sprites left to draw
000007D6                            ;	a1.l	- Mappings frame data
000007D6                            ;	a6.l	- Sprite table buffer
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; RETURNS:
000007D6                            ;	Nothing
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            DrawSprite:
000007D6 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000007D8 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
000007DA E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000007DC 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            ; Draw the sprites from mappings with no flip checks
000007E0                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            DrawSprite_Loop:
000007E0 1419                       		move.b	(a1)+,d2			; Get Y offset
000007E2 4882                       		ext.w	d2				; ''
000007E4 D441                       		add.w	d1,d2				; Add onto Y position
000007E6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007E8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000007EA 524E                       		addq.w	#1,a6				; Skip link data
000007EC 3419                       		move.w	(a1)+,d2			; Get tile properties
000007EE D445                       		add.w	d5,d2				; Add base tile properties
000007F0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F2 3419                       		move.w	(a1)+,d2			; Get X offset
000007F4 D440                       		add.w	d0,d2				; Add onto X position
000007F6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F8 5347                       		subq.w	#1,d7				; Decrement sprite count
000007FA 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
000007FE                            		
000007FE                            DrawSprite_End:
000007FE 4E75                       		rts
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            ; Draw the sprites from mappings, horizontally flipped
00000800                            ; (Parameters inherited from DrawSprite)
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            DrawSprite_FlipX:
00000800 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000802 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000804                            
00000804                            .Loop:
00000804 1419                       		move.b	(a1)+,d2			; Get Y offset
00000806 4882                       		ext.w	d2				; ''
00000808 D441                       		add.w	d1,d2				; Add onto Y position
0000080A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000080C 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000080E 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000810 524E                       		addq.w	#1,a6				; Skip link data
00000812 3419                       		move.w	(a1)+,d2			; Get tile properties
00000814 D445                       		add.w	d5,d2				; Add base tile properties
00000816 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
0000081A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000081C 3419                       		move.w	(a1)+,d2			; Get X offset
0000081E 4442                       		neg.w	d2				; Negate it
00000820 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
00000824 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000826 D440                       		add.w	d0,d2				; Add onto X position
00000828 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000082A 5347                       		subq.w	#1,d7				; Decrement sprite count
0000082C 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000830 4E75                       		rts
00000832                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000832                            DrawSprite_XFlipOff:
00000832 0808 0808                  		dc.b	8, 8, 8, 8
00000836 1010 1010                  		dc.b	$10, $10, $10, $10
0000083A 1818 1818                  		dc.b	$18, $18, $18, $18
0000083E 2020 2020                  		dc.b	$20, $20, $20, $20
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            ; Draw the sprites from mappings, horizontally and vertically flipped
00000842                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            DrawSprite_FlipXY:
00000842 1419                       		move.b	(a1)+,d2			; Get Y offset
00000844 4882                       		ext.w	d2				; ''
00000846 4442                       		neg.w	d2				; Negate it
00000848 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000084A 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000084E 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000850 D441                       		add.w	d1,d2				; Add onto Y position
00000852 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000854 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000856 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000858 524E                       		addq.w	#1,a6				; Skip link data
0000085A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000085C D445                       		add.w	d5,d2				; Add base tile properties
0000085E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 3419                       		move.w	(a1)+,d2			; Get X offset
00000866 4442                       		neg.w	d2				; Negate it
00000868 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
0000086C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000086E D440                       		add.w	d0,d2				; Add onto X position
00000870 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000872 5347                       		subq.w	#1,d7				; Decrement sprite count
00000874 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
00000878 4E75                       		rts
0000087A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087A                            DrawSprite_YFlipOff:
0000087A 0810 1820                  		dc.b	8, $10, $18, $20
0000087E 0810 1820                  		dc.b	8, $10, $18, $20
00000882 0810 1820                  		dc.b	8, $10, $18, $20
00000886 0810 1820                  		dc.b	8, $10, $18, $20
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            ; Draw the sprites from mappings, vertically flipped
0000088A                            ; (Parameters inherited from DrawSprite)
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            DrawSprite_FlipY:
0000088A 1419                       		move.b	(a1)+,d2			; Get Y offset
0000088C 4882                       		ext.w	d2				; ''
0000088E 4442                       		neg.w	d2				; Negate it
00000890 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000892 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000896 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000089A 9446                       		sub.w	d6,d2				; Subtract from the Y offset
0000089C D441                       		add.w	d1,d2				; Add onto Y position
0000089E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A0 544E                       		addq.w	#2,a6				; Skip link data
000008A2 3419                       		move.w	(a1)+,d2			; Get tile properties
000008A4 D445                       		add.w	d5,d2				; Add base tile properties
000008A6 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
000008AA 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008AC 3419                       		move.w	(a1)+,d2			; Get X offset
000008AE D440                       		add.w	d0,d2				; Add onto X position
000008B0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008B2 5347                       		subq.w	#1,d7				; Decrement sprite count
000008B4 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
000008B8 4E75                       		rts
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; Draw the sprites from mappings (with boundary checks)
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; PARAMETERS:
000008BA                            ;	d0.w	- X position
000008BA                            ;	d1.w	- Y position
000008BA                            ;	d4.w	- Number of sprites to draw
000008BA                            ;	d5.w	- Sprite tile properties
000008BA                            ;	d6.b	- Render flags
000008BA                            ;	d7.w	- Max number of sprites left to draw
000008BA                            ;	a1.l	- Mappings frame data
000008BA                            ;	a6.l	- Sprite table buffer
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; RETURNS:
000008BA                            ;	Nothing
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            DrawSprite_BoundChk:
000008BA E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000008BC 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
000008BE E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000008C0 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
000008C4                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            DrawSprBndChk_Loop:
000008C4 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C6 4882                       		ext.w	d2				; ''
000008C8 D441                       		add.w	d1,d2				; Add onto Y position
000008CA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000008CE 6300                       		bls.s	.Next_YOffScr			; If so, branch
000008D0 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
000008D4 6400                       		bhs.s	.Next_YOffScr			; If so, branch
000008D6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000008DA 524E                       		addq.w	#1,a6				; Skip link data
000008DC 3419                       		move.w	(a1)+,d2			; Get tile properties
000008DE D445                       		add.w	d5,d2				; Add base tile properties
000008E0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E2 3419                       		move.w	(a1)+,d2			; Get X offset
000008E4 D440                       		add.w	d0,d2				; Add onto X position
000008E6 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000008EA 6300                       		bls.s	.Next_XOffScr			; If so, branch
000008EC 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000008F0 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000008F2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008F4 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F6 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
000008FA 4E75                       		rts
000008FC                            
000008FC                            .Next_XOffScr:
000008FC 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000008FE 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000902 4E75                       		rts
00000904                            
00000904                            .Next_YOffScr:
00000904 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000906 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000090A 4E75                       		rts
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
0000090C                            ; (Parameters inherited from DrawSprite_BoundChk)
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            DrawSprite_BndChk_FlipX:
0000090C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000090E 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
00000910                            
00000910                            .Loop:
00000910 1419                       		move.b	(a1)+,d2			; Get Y offset
00000912 4882                       		ext.w	d2				; ''
00000914 D441                       		add.w	d1,d2				; Add onto Y position
00000916 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000091A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000091C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000920 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000922 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000924 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000926 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000928 524E                       		addq.w	#1,a6				; Skip link data
0000092A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000092C D445                       		add.w	d5,d2				; Add base tile properties
0000092E 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000932 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000934 3419                       		move.w	(a1)+,d2			; Get X offset
00000936 4442                       		neg.w	d2				; Negate it
00000938 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
0000093C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000093E D440                       		add.w	d0,d2				; Add onto X position
00000940 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000944 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000946 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000094A 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000094C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000094E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000950 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000954 4E75                       		rts
00000956                            
00000956                            .Next_XOffScr:
00000956 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000958 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
0000095C 4E75                       		rts
0000095E                            
0000095E                            .Next_YOffScr:
0000095E 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000960 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
00000964 4E75                       		rts
00000966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000966                            DrwSprBndChk_XFlips:
00000966 0808 0808                  		dc.b	8, 8, 8, 8
0000096A 1010 1010                  		dc.b	$10, $10, $10, $10
0000096E 1818 1818                  		dc.b	$18, $18, $18, $18
00000972 2020 2020                  		dc.b	$20, $20, $20, $20
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
00000976                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            DrawSprite_BndChk_FlipXY:
00000976 1419                       		move.b	(a1)+,d2			; Get Y offset
00000978 4882                       		ext.w	d2				; ''
0000097A 4442                       		neg.w	d2				; Negate it
0000097C 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000097E 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000982 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000984 D441                       		add.w	d1,d2				; Add onto Y position
00000986 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000098A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000098C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000990 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000992 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000994 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000996 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000998 524E                       		addq.w	#1,a6				; Skip link data
0000099A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000099C D445                       		add.w	d5,d2				; Add base tile properties
0000099E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000009A2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A4 3419                       		move.w	(a1)+,d2			; Get X offset
000009A6 4442                       		neg.w	d2				; Negate it
000009A8 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009AC 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009AE D440                       		add.w	d0,d2				; Add onto X position
000009B0 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009B4 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009B6 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009BA 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009BC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009BE 5347                       		subq.w	#1,d7				; Decrement sprite count
000009C0 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009C4 4E75                       		rts
000009C6                            
000009C6                            .Next_XOffScr:
000009C6 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009C8 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009CC 4E75                       		rts
000009CE                            
000009CE                            .Next_YOffScr:
000009CE 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009D0 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009D4 4E75                       		rts
000009D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009D6                            DrwSprBndChk_YFlips:
000009D6 0810 1820                  		dc.b	8, $10, $18, $20
000009DA 0810 1820                  		dc.b	8, $10, $18, $20
000009DE 0810 1820                  		dc.b	8, $10, $18, $20
000009E2 0810 1820                  		dc.b	8, $10, $18, $20
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
000009E6                            ; (Parameters inherited from DrawSprite_BoundChk)
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            DrawSprite_BndChk_FlipY:
000009E6 1419                       		move.b	(a1)+,d2			; Get Y offset
000009E8 4882                       		ext.w	d2				; ''
000009EA 4442                       		neg.w	d2				; Negate it
000009EC 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
000009EE 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
000009F2 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009F6 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000009F8 D441                       		add.w	d1,d2				; Add onto Y position
000009FA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000009FE 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A00 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A04 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A06 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A08 544E                       		addq.w	#2,a6				; Skip link data
00000A0A 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A0C D445                       		add.w	d5,d2				; Add base tile properties
00000A0E 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A12 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A14 3419                       		move.w	(a1)+,d2			; Get X offset
00000A16 D440                       		add.w	d0,d2				; Add onto X position
00000A18 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A1C 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A1E 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A22 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A24 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A26 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A28 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A2C 4E75                       		rts
00000A2E                            
00000A2E                            .Next_XOffScr:
00000A2E 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A30 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A34 4E75                       		rts
00000A36                            
00000A36                            .Next_YOffScr:
00000A36 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A38 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A3C 4E75                       		rts
00000A3E                            ; =========================================================================================================================================================
00000A3E                            		include	"_LIB_/Joypad.asm"		; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; Mighty The Armadillo in PRISM PARADISE
00000A3E                            ; By Nat The Porcupine 2021
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Read joypad input
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; PARAMETERS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; RETURNS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ReadJoypads:
00000A3E 41F8 C740                  		lea	rP1Data.w,a0			; Controller data in RAM
00000A42 43F9 00A1 0003             		lea	PORT_A_DATA,a1			; Port 1
00000A48 6100                       		bsr.s	ReadJoypad			; Read the joypad data
00000A4A 5449                       		addq.w	#rP2Data-rP1Data,a1		; Port 2
00000A4C                            
00000A4C                            ReadJoypad:
00000A4C 12BC 0000                  		move.b	#0,(a1)				; Set TH = 0
00000A50 4E71                       		nop					; Wait
00000A52 4E71                       		nop					; ''
00000A54 1011                       		move.b	(a1),d0				; Input data when TH = 0
00000A56 E500                       		asl.b	#2,d0				; Chane data when TH = 0 & wait
00000A58 12BC 0040                  		move.b	#$40,(a1)			; Set TH = 1
00000A5C 0200 00C0                  		andi.b	#$C0,d0				; Chane data when TH = 0 & wait
00000A60 1211                       		move.b	(a1),d1				; Input data when TH = 1
00000A62 0201 003F                  		andi.b	#$3F,d1
00000A66 8001                       		or.b	d1,d0	
00000A68 4600                       		not.b	d0				; Push -> 1
00000A6A 1210                       		move.b	(a0),d1				; Copy
00000A6C B101                       		eor.b	d0,d1
00000A6E 10C0                       		move.b	d0,(a0)+			; Switch data
00000A70 C200                       		and.b	d0,d1			
00000A72 10C1                       		move.b	d1,(a0)+			; Switch edge data
00000A74 4E75                       		rts
00000A76                            ; =========================================================================================================================================================
00000A76                            		include	"_LIB_/Interrupt.asm"		; Interrupt functions
00000A76                            ; =========================================================================================================================================================
00000A76                            ; Mighty The Armadillo in PRISM PARADISE
00000A76                            ; By Nat The Porcupine 2021
00000A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A76                            ; Interrupt functions
00000A76                            ; =========================================================================================================================================================
00000A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A76                            ; Wait for the vertical interrupt to run and finish
00000A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A76                            ; PARAMETERS:
00000A76                            ;	Nothing
00000A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A76                            ; RETURNS:
00000A76                            ;	Nothing
00000A76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A76                            VSync:
00000A76 50F8 C745                  		st	rVINTFlag.w			; Set V-INT flag
00000A7A                            
00000A7A                            VSync_Routine:
00000A7A                            		intsOn					; Enable interrupts
00000A7A 027C F8FF                M 	andi	#$f8ff,sr
00000A7E                            		lagOff					; Turn off the lag-o-meter
00000A7E                            
00000A7E                            .Wait:
00000A7E 4A38 C745                  		tst.b	rVINTFlag.w			; Has the V-INT run yet?
00000A82 66FA                       		bne.s	.Wait				; If not, wait some more
00000A84 4E75                       		rts
00000A86                            ; =========================================================================================================================================================
00000A86                            		include	"_LIB_/Decompression.asm"	; Decompression functions
00000A86                            ; =========================================================================================================================================================
00000A86                            ; Mighty The Armadillo in PRISM PARADISE
00000A86                            ; By Nat The Porcupine 2021
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            ; Decompression functions
00000A86                            ; =========================================================================================================================================================
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            ; Kosinski decompression (General purpose)
00000A86                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            ; PARAMETERS:
00000A86                            ;	a0.l	- Source address
00000A86                            ;	a1.l	- Destination address
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            ; RETURNS:
00000A86                            ;	a1.l	- End of decompressed data address
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86 =00000001                  _Kos_UseLUT			equ	1
00000A86 =00000003                  _Kos_LoopUnroll			equ	3
00000A86 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            _Kos_RunBitStream macro
00000A86                            		dbra	d2,.skip\@
00000A86                            		moveq	#7,d2				; Set repeat count to 8.
00000A86                            		move.b	d1,d0				; Use the remaining 8 bits.
00000A86                            		not.w	d3				; Have all 16 bits been used up?
00000A86                            		bne.s	.skip\@				; Branch if not.
00000A86                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000A86                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000A86                            	if _Kos_UseLUT=1
00000A86                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000A86                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000A86                            	endif
00000A86                            .skip\@:
00000A86                            		endm
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            _Kos_ReadBit macro
00000A86                            	if _Kos_UseLUT=1
00000A86                            		add.b	d0,d0				; Get a bit from the bitstream.
00000A86                            	else
00000A86                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000A86                            	endif
00000A86                            		endm
00000A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A86                            KosDec:
00000A86 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000A88 7000                       		moveq	#0,d0
00000A8A 7200                       		moveq	#0,d1
00000A8C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000A90 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000A92 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000A94 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000A98 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000A9C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000A9E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000AA0 6000                       		bra.s	.FetchNewCode
00000AA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000AA2                            .FetchCodeLoop:
00000AA2                            		; Code 1 (Uncompressed byte).
00000AA2                            		_Kos_RunBitStream
00000AA2 51CA 0000                M 	dbra	d2,.skip_30
00000AA6 7407                     M 	moveq	#7,d2
00000AA8 1001                     M 	move.b	d1,d0
00000AAA 4643                     M 	not.w	d3
00000AAC 6600                     M 	bne.s	.skip_30
00000AAE 1018                     M 	move.b	(a0)+,d0
00000AB0 1218                     M 	move.b	(a0)+,d1
00000AB2 1034 0000                M 	move.b	(a4,d0.w),d0
00000AB6 1234 1000                M 	move.b	(a4,d1.w),d1
00000ABA                          M .skip_30:
00000ABA 12D8                       		move.b	(a0)+,(a1)+
00000ABC                             
00000ABC                            .FetchNewCode:
00000ABC                            		_Kos_ReadBit
00000ABC D000                     M 	add.b	d0,d0
00000ABE 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000AC0                             
00000AC0                            		; Codes 00 and 01.
00000AC0 7AFF                       		moveq	#-1,d5
00000AC2 4BD1                       		lea	(a1),a5
00000AC4                            		_Kos_RunBitStream
00000AC4 51CA 0000                M 	dbra	d2,.skip_32
00000AC8 7407                     M 	moveq	#7,d2
00000ACA 1001                     M 	move.b	d1,d0
00000ACC 4643                     M 	not.w	d3
00000ACE 6600                     M 	bne.s	.skip_32
00000AD0 1018                     M 	move.b	(a0)+,d0
00000AD2 1218                     M 	move.b	(a0)+,d1
00000AD4 1034 0000                M 	move.b	(a4,d0.w),d0
00000AD8 1234 1000                M 	move.b	(a4,d1.w),d1
00000ADC                          M .skip_32:
00000ADC                            		_Kos_ReadBit
00000ADC D000                     M 	add.b	d0,d0
00000ADE 6500 0000                  		bcs.w	.Code_01
00000AE2                             
00000AE2                            		; Code 00 (Dictionary ref. short).
00000AE2                            		_Kos_RunBitStream
00000AE2 51CA 0000                M 	dbra	d2,.skip_34
00000AE6 7407                     M 	moveq	#7,d2
00000AE8 1001                     M 	move.b	d1,d0
00000AEA 4643                     M 	not.w	d3
00000AEC 6600                     M 	bne.s	.skip_34
00000AEE 1018                     M 	move.b	(a0)+,d0
00000AF0 1218                     M 	move.b	(a0)+,d1
00000AF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000AF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000AFA                          M .skip_34:
00000AFA                            		_Kos_ReadBit
00000AFA D000                     M 	add.b	d0,d0
00000AFC 6500                       		bcs.s	.Copy45
00000AFE                            		_Kos_RunBitStream
00000AFE 51CA 0000                M 	dbra	d2,.skip_36
00000B02 7407                     M 	moveq	#7,d2
00000B04 1001                     M 	move.b	d1,d0
00000B06 4643                     M 	not.w	d3
00000B08 6600                     M 	bne.s	.skip_36
00000B0A 1018                     M 	move.b	(a0)+,d0
00000B0C 1218                     M 	move.b	(a0)+,d1
00000B0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B12 1234 1000                M 	move.b	(a4,d1.w),d1
00000B16                          M .skip_36:
00000B16                            		_Kos_ReadBit
00000B16 D000                     M 	add.b	d0,d0
00000B18 6500                       		bcs.s	.Copy3
00000B1A                            		_Kos_RunBitStream
00000B1A 51CA 0000                M 	dbra	d2,.skip_38
00000B1E 7407                     M 	moveq	#7,d2
00000B20 1001                     M 	move.b	d1,d0
00000B22 4643                     M 	not.w	d3
00000B24 6600                     M 	bne.s	.skip_38
00000B26 1018                     M 	move.b	(a0)+,d0
00000B28 1218                     M 	move.b	(a0)+,d1
00000B2A 1034 0000                M 	move.b	(a4,d0.w),d0
00000B2E 1234 1000                M 	move.b	(a4,d1.w),d1
00000B32                          M .skip_38:
00000B32 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B34 DAC5                       		adda.w	d5,a5
00000B36 12DD                       		move.b	(a5)+,(a1)+
00000B38 12DD                       		move.b	(a5)+,(a1)+
00000B3A 6080                       		bra.s	.FetchNewCode
00000B3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B3C                            .Copy3:
00000B3C                            		_Kos_RunBitStream
00000B3C 51CA 0000                M 	dbra	d2,.skip_39
00000B40 7407                     M 	moveq	#7,d2
00000B42 1001                     M 	move.b	d1,d0
00000B44 4643                     M 	not.w	d3
00000B46 6600                     M 	bne.s	.skip_39
00000B48 1018                     M 	move.b	(a0)+,d0
00000B4A 1218                     M 	move.b	(a0)+,d1
00000B4C 1034 0000                M 	move.b	(a4,d0.w),d0
00000B50 1234 1000                M 	move.b	(a4,d1.w),d1
00000B54                          M .skip_39:
00000B54 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B56 DAC5                       		adda.w	d5,a5
00000B58 12DD                       		move.b	(a5)+,(a1)+
00000B5A 12DD                       		move.b	(a5)+,(a1)+
00000B5C 12DD                       		move.b	(a5)+,(a1)+
00000B5E 6000 FF5C                  		bra.w	.FetchNewCode
00000B62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B62                            .Copy45:
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_40
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_40
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_40:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy5
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_42
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_42
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_42:
00000B96 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B98 DAC5                       		adda.w	d5,a5
00000B9A 12DD                       		move.b	(a5)+,(a1)+
00000B9C 12DD                       		move.b	(a5)+,(a1)+
00000B9E 12DD                       		move.b	(a5)+,(a1)+
00000BA0 12DD                       		move.b	(a5)+,(a1)+
00000BA2 6000 FF18                  		bra.w	.FetchNewCode
00000BA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BA6                            .Copy5:
00000BA6                            		_Kos_RunBitStream
00000BA6 51CA 0000                M 	dbra	d2,.skip_43
00000BAA 7407                     M 	moveq	#7,d2
00000BAC 1001                     M 	move.b	d1,d0
00000BAE 4643                     M 	not.w	d3
00000BB0 6600                     M 	bne.s	.skip_43
00000BB2 1018                     M 	move.b	(a0)+,d0
00000BB4 1218                     M 	move.b	(a0)+,d1
00000BB6 1034 0000                M 	move.b	(a4,d0.w),d0
00000BBA 1234 1000                M 	move.b	(a4,d1.w),d1
00000BBE                          M .skip_43:
00000BBE 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BC0 DAC5                       		adda.w	d5,a5
00000BC2 12DD                       		move.b	(a5)+,(a1)+
00000BC4 12DD                       		move.b	(a5)+,(a1)+
00000BC6 12DD                       		move.b	(a5)+,(a1)+
00000BC8 12DD                       		move.b	(a5)+,(a1)+
00000BCA 12DD                       		move.b	(a5)+,(a1)+
00000BCC 6000 FEEE                  		bra.w	.FetchNewCode
00000BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BD0                            .Code_01:
00000BD0 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000BD2                            		; Code 01 (Dictionary ref. long / special).
00000BD2                            		_Kos_RunBitStream
00000BD2 51CA 0000                M 	dbra	d2,.skip_44
00000BD6 7407                     M 	moveq	#7,d2
00000BD8 1001                     M 	move.b	d1,d0
00000BDA 4643                     M 	not.w	d3
00000BDC 6600                     M 	bne.s	.skip_44
00000BDE 1018                     M 	move.b	(a0)+,d0
00000BE0 1218                     M 	move.b	(a0)+,d1
00000BE2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BE6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BEA                          M .skip_44:
00000BEA 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000BEC 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000BEE 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000BF0 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000BF2 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000BF4 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000BF6 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000BF8                             
00000BF8                            		; special mode (extended counter)
00000BF8 1818                       		move.b	(a0)+,d4			; Read cnt
00000BFA 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000BFC 5304                       		subq.b	#1,d4
00000BFE 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C02                             
00000C02 DAC5                       		adda.w	d5,a5
00000C04 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C06 3C04                       		move.w	d4,d6
00000C08 4646                       		not.w	d6
00000C0A CC47                       		and.w	d7,d6
00000C0C DC46                       		add.w	d6,d6
00000C0E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C10 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C14                            .LargeCopy:
00000C14                            	rept (1<<_Kos_LoopUnroll)
00000C14                            		move.b	(a5)+,(a1)+
00000C14                            	endr
00000C14 12DD                     M 	move.b	(a5)+,(a1)+
00000C16 12DD                     M 	move.b	(a5)+,(a1)+
00000C18 12DD                     M 	move.b	(a5)+,(a1)+
00000C1A 12DD                     M 	move.b	(a5)+,(a1)+
00000C1C 12DD                     M 	move.b	(a5)+,(a1)+
00000C1E 12DD                     M 	move.b	(a5)+,(a1)+
00000C20 12DD                     M 	move.b	(a5)+,(a1)+
00000C22 12DD                     M 	move.b	(a5)+,(a1)+
00000C24 51CC FFEE                  		dbra	d4,.LargeCopy
00000C28 6000 FE92                  		bra.w	.FetchNewCode
00000C2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C2C                            .StreamCopy:
00000C2C DAC5                       		adda.w	d5,a5
00000C2E 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C30 BF44                       		eor.w	d7,d4
00000C32 D844                       		add.w	d4,d4
00000C34 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000C38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C38                            .MediumCopy:
00000C38                            	rept 8
00000C38                            		move.b	(a5)+,(a1)+
00000C38                            	endr
00000C38 12DD                     M 	move.b	(a5)+,(a1)+
00000C3A 12DD                     M 	move.b	(a5)+,(a1)+
00000C3C 12DD                     M 	move.b	(a5)+,(a1)+
00000C3E 12DD                     M 	move.b	(a5)+,(a1)+
00000C40 12DD                     M 	move.b	(a5)+,(a1)+
00000C42 12DD                     M 	move.b	(a5)+,(a1)+
00000C44 12DD                     M 	move.b	(a5)+,(a1)+
00000C46 12DD                     M 	move.b	(a5)+,(a1)+
00000C48 6000 FE72                  		bra.w	.FetchNewCode
00000C4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C4C                            .Quit:
00000C4C 4E75                       		rts
00000C4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C4E                            KosDec_ByteMap:
00000C4E 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000C5E 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000C6E 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000C7E 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000C8E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000C9E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000CAE 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000CBE 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000CCE 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000CDE 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000CEE 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000CFE 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D0E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D1E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000D2E 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000D3E 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000D4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D4E                            ; Enigma decompression (Mainly for plane mappings)
00000D4E                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000D4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D4E                            ; PARAMETERS:
00000D4E                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000D4E                            ;	a0.l	- Source address
00000D4E                            ;	a1.l	- Destination address
00000D4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D4E                            ; RETURNS:
00000D4E                            ;	a1.l	- End of decompressed data address
00000D4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D4E                            EniDec:
00000D4E                            		push.l d0-d7/a1-a5
00000D4E 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000D52 3640                       		movea.w d0,a3				; Store base tile properties
00000D54 1018                       		move.b	(a0)+,d0
00000D56 4880                       		ext.w	d0
00000D58 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000D5A 1818                       		move.b	(a0)+,d4			; Store second byte
00000D5C E70C                       		lsl.b	#3,d4				; Multiply by 8
00000D5E 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000D60 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000D62 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000D64 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000D66 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000D68 E145                       		asl.w	#8,d5				; Shift up by a byte
00000D6A 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000D6C 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000D6E                            
00000D6E                            EniDec_Loop:
00000D6E 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000D70 3E06                       		move.w	d6,d7
00000D72 9E40                       		sub.w	d0,d7
00000D74 3205                       		move.w	d5,d1
00000D76 EE69                       		lsr.w	d7,d1
00000D78 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000D7C 3401                       		move.w	d1,d2
00000D7E 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000D82 6400                       		bcc.s	.getnext			; If so, branch
00000D84 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000D86 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000D88                            
00000D88                            .getnext:
00000D88 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000D8C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000D90 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000D92 D241                       		add.w	d1,d1
00000D94 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000D98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D98                            EniDec_Sub0:
00000D98 32CA                       		move.w	a2,(a1)+			; Write to destination
00000D9A 524A                       		addq.w	#1,a2				; Increment
00000D9C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000DA0 60CC                       		bra.s	EniDec_Loop
00000DA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DA2                            EniDec_Sub4:
00000DA2 32CC                       		move.w	a4,(a1)+			; Write to destination
00000DA4 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000DA8 60C4                       		bra.s	EniDec_Loop
00000DAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DAA                            EniDec_Sub8:
00000DAA 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DAE                            
00000DAE                            .loop1:
00000DAE 32C1                       		move.w	d1,(a1)+
00000DB0 51CA FFFC                  		dbf	d2,.loop1
00000DB4 60B8                       		bra.s	EniDec_Loop
00000DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DB6                            EniDec_SubA:
00000DB6 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DBA                            
00000DBA                            .loop2:
00000DBA 32C1                       		move.w	d1,(a1)+
00000DBC 5241                       		addq.w	#1,d1
00000DBE 51CA FFFA                  		dbf	d2,.loop2
00000DC2 60AA                       		bra.s	EniDec_Loop
00000DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DC4                            EniDec_SubC:
00000DC4 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DC8                            
00000DC8                            .loop3:
00000DC8 32C1                       		move.w	d1,(a1)+
00000DCA 5341                       		subq.w	#1,d1
00000DCC 51CA FFFA                  		dbf	d2,.loop3
00000DD0 609C                       		bra.s	EniDec_Loop
00000DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DD2                            EniDec_SubE:
00000DD2 0C42 000F                  		cmpi.w	#$F,d2
00000DD6 6700                       		beq.s	EniDec_End
00000DD8                            
00000DD8                            .loop4:
00000DD8 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DDC 32C1                       		move.w	d1,(a1)+
00000DDE 51CA FFF8                  		dbf	d2,.loop4
00000DE2 608A                       		bra.s	EniDec_Loop
00000DE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DE4                            EniDec_JmpTable:
00000DE4 60B2                       		bra.s	EniDec_Sub0
00000DE6 60B0                       		bra.s	EniDec_Sub0
00000DE8 60B8                       		bra.s	EniDec_Sub4
00000DEA 60B6                       		bra.s	EniDec_Sub4
00000DEC 60BC                       		bra.s	EniDec_Sub8
00000DEE 60C6                       		bra.s	EniDec_SubA
00000DF0 60D2                       		bra.s	EniDec_SubC
00000DF2 60DE                       		bra.s	EniDec_SubE
00000DF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DF4                            EniDec_End:
00000DF4 5348                       		subq.w	#1,a0
00000DF6 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000DFA 6600                       		bne.s	.norollback			; If not, branch
00000DFC 5348                       		subq.w	#1,a0
00000DFE                            
00000DFE                            .norollback:
00000DFE 3008                       		move.w	a0,d0
00000E00 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E02 6400                       		bcc.s	.evendest			; If not, branch
00000E04 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E06                            
00000E06                            .evendest:
00000E06                            		pop.l	d0-d7/a1-a5
00000E06 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E0A 4E75                       		rts
00000E0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E0C                            EniDec_GetInlineCopyVal:
00000E0C 360B                       		move.w	a3,d3				; Store base tile properties
00000E0E 1204                       		move.b	d4,d1
00000E10 D201                       		add.b	d1,d1
00000E12 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E14 5346                       		subq.w	#1,d6				; Get next bit number
00000E16 0D05                       		btst	d6,d5				; Is the bit set?
00000E18 6700                       		beq.s	.nopriority			; If not, branch
00000E1A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E1E                            
00000E1E                            .nopriority:
00000E1E D201                       		add.b	d1,d1
00000E20 6400                       		bcc.s	.nopal1				; If d4 < $40
00000E22 5346                       		subq.w	#1,d6				; Get next bit number
00000E24 0D05                       		btst	d6,d5				; Is the bit set?
00000E26 6700                       		beq.s	.nopal1				; If not, branch
00000E28 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000E2C                            
00000E2C                            .nopal1:
00000E2C D201                       		add.b	d1,d1
00000E2E 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000E30 5346                       		subq.w	#1,d6				; Get next bit number
00000E32 0D05                       		btst	d6,d5				; Is the bit set?
00000E34 6700                       		beq.s	.nopal0				; If not, branch
00000E36 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000E3A                            
00000E3A                            .nopal0:
00000E3A D201                       		add.b	d1,d1
00000E3C 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000E3E 5346                       		subq.w	#1,d6				; Get next bit number
00000E40 0D05                       		btst	d6,d5				; Is the bit set?
00000E42 6700                       		beq.s	.noyflip			; If not, branch
00000E44 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000E48                            
00000E48                            .noyflip:
00000E48 D201                       		add.b	d1,d1
00000E4A 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000E4C 5346                       		subq.w	#1,d6				; Get next bit number
00000E4E 0D05                       		btst	d6,d5				; Is the bit set?
00000E50 6700                       		beq.s	.noxflip			; If not, branch
00000E52 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000E56                            
00000E56                            .noxflip:
00000E56 3205                       		move.w	d5,d1
00000E58 3E06                       		move.w	d6,d7				; Get remaining bits
00000E5A 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000E5C 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000E5E 3C07                       		move.w	d7,d6
00000E60 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000E64 4447                       		neg.w	d7				; Calculate bit deficit
00000E66 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000E68 1A10                       		move.b	(a0),d5				; Get next byte
00000E6A EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000E6C DE47                       		add.w	d7,d7
00000E6E CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000E72 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000E74                            
00000E74                            .AddBits:
00000E74 300D                       		move.w	a5,d0
00000E76 D040                       		add.w	d0,d0
00000E78 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000E7C D243                       		add.w	d3,d1				; Add base tile properties
00000E7E 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000E80 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000E82 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000E84 4E75                       		rts
00000E86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E86                            .GotEnoughBits:
00000E86 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000E88 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000E8A 300D                       		move.w	a5,d0
00000E8C D040                       		add.w	d0,d0
00000E8E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000E92 D243                       		add.w	d3,d1				; Add base tile properties
00000E94 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000E96 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000E98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E98                            .GotExactCount:
00000E98 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000E9A 60D8                       		bra.s	.AddBits
00000E9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E9C                            EniDec_AndVals:
00000E9C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000EA4 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000EAC 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000EB4 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000EBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EBC                            EniDec_ChkGetNextByte:
00000EBC 9C40                       		sub.w	d0,d6
00000EBE 0C46 0009                  		cmpi.w	#9,d6
00000EC2 6400                       		bcc.s	.Done
00000EC4 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000EC6 E145                       		asl.w	#8,d5				; Shift up by a byte
00000EC8 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000ECA                            
00000ECA                            .Done:
00000ECA 4E75                       		rts
00000ECC                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000ECC                            ; Load a Kosinski Moduled Queue
00000ECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ECC                            ; PARAMETERS:
00000ECC                            ;	a3.l	- Queue pointer
00000ECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ECC                            ; RETURNS:
00000ECC                            ;	Nothing
00000ECC                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000ECC                            LoadKosMQueue:
00000ECC 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000ECE 6B00                       		bmi.s	.End				; If it's negative, branch
00000ED0                            
00000ED0                            .Queue:
00000ED0 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000ED2 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000ED4 6100                       		bsr.s	QueueKosMData			; Queue
00000ED6 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000EDA                            
00000EDA                            .End:
00000EDA 4E75                       		rts
00000EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EDC                            ; Adds a Kosinski Moduled archive to the module queue
00000EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EDC                            ; PARAMETERS:
00000EDC                            ;	d2.w	- Destination in VRAM
00000EDC                            ;	a1.l	- Address of the archive
00000EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EDC                            ; RETURNS:
00000EDC                            ;	Nothing
00000EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EDC                            QueueKosMData:
00000EDC 45F8 9994                  		lea	rKosPMList.w,a2
00000EE0 4A92                       		tst.l	(a2)				; Is the first slot free?
00000EE2 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000EE4                            		
00000EE4                            .FindFreeSlot:
00000EE4 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000EE6 4A92                       		tst.l	(a2)
00000EE8 66FA                       		bne.s	.FindFreeSlot
00000EEA 24C9                       		move.l	a1,(a2)+			; Store source address
00000EEC 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000EEE 4E75                       		rts
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; Initializes processing of the first module on the queue
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; PARAMETERS:
00000EF0                            ;	Nothing
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; RETURNS:
00000EF0                            ;	Nothing
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ProcessKosM_Init:
00000EF0 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000EF2 0C43 A000                  		cmpi.w	#$A000,d3
00000EF6 6600                       		bne.s	.GotSize
00000EF8 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000EFC                            
00000EFC                            .GotSize:
00000EFC E24B                       		lsr.w	#1,d3
00000EFE 3003                       		move.w	d3,d0
00000F00 EB58                       		rol.w	#5,d0
00000F02 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F06 11C0 9990                  		move.b	d0,rKosPMMods.w
00000F0A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F10 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F12 5338 9990                  		subq.b	#1,rKosPMMods.w		; Otherwise decrement the number of modules
00000F16 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F1C                            
00000F1C                            .GotLeftover:
00000F1C 31C3 9992                  		move.w	d3,rKosPMLastSz.w
00000F20 31C2 9998                  		move.w	d2,rKosPMDest.w
00000F24 21C9 9994                  		move.l	a1,rKosPMSrc.w
00000F28 5238 9990                  		addq.b	#1,rKosPMMods.w		; Store total number of modules
00000F2C 4E75                       		rts
00000F2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F2E                            ; Processes the first module on the queue
00000F2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F2E                            ; PARAMETERS:
00000F2E                            ;	Nothing
00000F2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F2E                            ; RETURNS:
00000F2E                            ;	Nothing
00000F2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F2E                            ProcessKosM:
00000F2E 4A38 9990                  		tst.b	rKosPMMods.w
00000F32 6600                       		bne.s	.ModulesLeft
00000F34                            
00000F34                            .Done:
00000F34 4E75                       		rts
00000F36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F36                            .ModulesLeft:
00000F36 6B00                       		bmi.s	.DecompressionStarted
00000F38 0C78 0004 994E             		cmpi.w	#(rKosPList_End-rKosPList)/8,rKosPCnt.w
00000F3E 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000F40 2278 9994                  		movea.l	rKosPMList.w,a1
00000F44 45F8 8000                  		lea	rKosPBuf.w,a2
00000F48 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000F4C 0038 0080 9990             		ori.b	#$80,rKosPMMods.w		; And set bit to signify decompression in progress
00000F52 4E75                       		rts
00000F54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F54                            .DecompressionStarted:
00000F54 4A78 994E                  		tst.w	rKosPCnt.w
00000F58 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000F5A                            
00000F5A                            		; Otherwise, DMA the decompressed data to VRAM
00000F5A 0238 007F 9990             		andi.b	#$7F,rKosPMMods.w
00000F60 263C 0000 0800             		move.l	#$1000/2,d3
00000F66 5338 9990                  		subq.b	#1,rKosPMMods.w
00000F6A 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000F6C 3638 9992                  		move.w	rKosPMLastSz.w,d3
00000F70                            
00000F70                            .Skip:
00000F70 3438 9998                  		move.w	rKosPMDest.w,d2
00000F74 3002                       		move.w	d2,d0
00000F76 D043                       		add.w	d3,d0
00000F78 D043                       		add.w	d3,d0
00000F7A 31C0 9998                  		move.w	d0,rKosPMDest.w		; Set new destination
00000F7E 2038 9994                  		move.l	rKosPMList.w,d0
00000F82 2238 9970                  		move.l	rKosPList.w,d1
00000F86 9081                       		sub.l	d1,d0
00000F88 0280 0000 000F             		andi.l	#$F,d0
00000F8E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00000F90 21C1 9994                  		move.l	d1,rKosPMList.w		; And set new source
00000F94 223C FFFF 8000             		move.l	#rKosPBuf,d1
00000F9A 6100 F2EC                  		bsr.w	QueueDMATransfer
00000F9E 4A38 9990                  		tst.b	rKosPMMods.w
00000FA2 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00000FA6 41F8 9994                  		lea	rKosPMList.w,a0
00000FAA 43F8 999A                  		lea	(rKosPMList+6).w,a1
00000FAE                            	rept (rKosPMList_End-rKosPMList)/6-1
00000FAE                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
00000FAE                            		move.w	(a1)+,(a0)+
00000FAE                            	endr
00000FAE 20D9                     M 	move.l	(a1)+,(a0)+
00000FB0 30D9                     M 	move.w	(a1)+,(a0)+
00000FB2 20D9                     M 	move.l	(a1)+,(a0)+
00000FB4 30D9                     M 	move.w	(a1)+,(a0)+
00000FB6 20D9                     M 	move.l	(a1)+,(a0)+
00000FB8 30D9                     M 	move.w	(a1)+,(a0)+
00000FBA 20D9                     M 	move.l	(a1)+,(a0)+
00000FBC 30D9                     M 	move.w	(a1)+,(a0)+
00000FBE 20D9                     M 	move.l	(a1)+,(a0)+
00000FC0 30D9                     M 	move.w	(a1)+,(a0)+
00000FC2 20D9                     M 	move.l	(a1)+,(a0)+
00000FC4 30D9                     M 	move.w	(a1)+,(a0)+
00000FC6 20D9                     M 	move.l	(a1)+,(a0)+
00000FC8 30D9                     M 	move.w	(a1)+,(a0)+
00000FCA 20D9                     M 	move.l	(a1)+,(a0)+
00000FCC 30D9                     M 	move.w	(a1)+,(a0)+
00000FCE 20D9                     M 	move.l	(a1)+,(a0)+
00000FD0 30D9                     M 	move.w	(a1)+,(a0)+
00000FD2 20D9                     M 	move.l	(a1)+,(a0)+
00000FD4 30D9                     M 	move.w	(a1)+,(a0)+
00000FD6 20D9                     M 	move.l	(a1)+,(a0)+
00000FD8 30D9                     M 	move.w	(a1)+,(a0)+
00000FDA 20D9                     M 	move.l	(a1)+,(a0)+
00000FDC 30D9                     M 	move.w	(a1)+,(a0)+
00000FDE 20D9                     M 	move.l	(a1)+,(a0)+
00000FE0 30D9                     M 	move.w	(a1)+,(a0)+
00000FE2 20D9                     M 	move.l	(a1)+,(a0)+
00000FE4 30D9                     M 	move.w	(a1)+,(a0)+
00000FE6 20D9                     M 	move.l	(a1)+,(a0)+
00000FE8 30D9                     M 	move.w	(a1)+,(a0)+
00000FEA 20D9                     M 	move.l	(a1)+,(a0)+
00000FEC 30D9                     M 	move.w	(a1)+,(a0)+
00000FEE 20D9                     M 	move.l	(a1)+,(a0)+
00000FF0 30D9                     M 	move.w	(a1)+,(a0)+
00000FF2 20D9                     M 	move.l	(a1)+,(a0)+
00000FF4 30D9                     M 	move.w	(a1)+,(a0)+
00000FF6 20D9                     M 	move.l	(a1)+,(a0)+
00000FF8 30D9                     M 	move.w	(a1)+,(a0)+
00000FFA 20D9                     M 	move.l	(a1)+,(a0)+
00000FFC 30D9                     M 	move.w	(a1)+,(a0)+
00000FFE 20D9                     M 	move.l	(a1)+,(a0)+
00001000 30D9                     M 	move.w	(a1)+,(a0)+
00001002 20D9                     M 	move.l	(a1)+,(a0)+
00001004 30D9                     M 	move.w	(a1)+,(a0)+
00001006 20D9                     M 	move.l	(a1)+,(a0)+
00001008 30D9                     M 	move.w	(a1)+,(a0)+
0000100A 20D9                     M 	move.l	(a1)+,(a0)+
0000100C 30D9                     M 	move.w	(a1)+,(a0)+
0000100E 20D9                     M 	move.l	(a1)+,(a0)+
00001010 30D9                     M 	move.w	(a1)+,(a0)+
00001012 20D9                     M 	move.l	(a1)+,(a0)+
00001014 30D9                     M 	move.w	(a1)+,(a0)+
00001016 20D9                     M 	move.l	(a1)+,(a0)+
00001018 30D9                     M 	move.w	(a1)+,(a0)+
0000101A 20D9                     M 	move.l	(a1)+,(a0)+
0000101C 30D9                     M 	move.w	(a1)+,(a0)+
0000101E 20D9                     M 	move.l	(a1)+,(a0)+
00001020 30D9                     M 	move.w	(a1)+,(a0)+
00001022 20D9                     M 	move.l	(a1)+,(a0)+
00001024 30D9                     M 	move.w	(a1)+,(a0)+
00001026 20D9                     M 	move.l	(a1)+,(a0)+
00001028 30D9                     M 	move.w	(a1)+,(a0)+
0000102A 4298                       		clr.l	(a0)+				; And mark the last slot as free
0000102C 4258                       		clr.w	(a0)+
0000102E 2038 9994                  		move.l	rKosPMList.w,d0
00001032 6700                       		beq.s	.Exit				; Return if the queue is now empty
00001034 2240                       		movea.l	d0,a1
00001036 3438 9998                  		move.w	rKosPMDest.w,d2
0000103A 6000 FEB4                  		bra.w	ProcessKosM_Init
0000103E                            
0000103E                            .Exit:
0000103E 4E75                       		rts
00001040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001040                            ; Adds Kosinski-compressed data to the decompression queue
00001040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001040                            ; PARAMETERS:
00001040                            ;	a1.l	- Compressed data address
00001040                            ;	a2.l	- Decompression destination in RAM
00001040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001040                            ; RETURNS:
00001040                            ;	Nothing
00001040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001040                            QueueKosData:
00001040 3038 994E                  		move.w	rKosPCnt.w,d0
00001044 E748                       		lsl.w	#3,d0
00001046 47F8 9970                  		lea	rKosPList.w,a3
0000104A 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
0000104E 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
00001052 5278 994E                  		addq.w	#1,rKosPCnt.w
00001056 4E75                       		rts
00001058                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001058                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
00001058                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001058                            ; PARAMETERS:
00001058                            ;	Nothing
00001058                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001058                            ; RETURNS:
00001058                            ;	Nothing
00001058                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001058                            SetKosBookmark:
00001058 4A78 994E                  		tst.w	rKosPCnt.w
0000105C 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
0000105E 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
00001062 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
00001068 6500                       		bcs.s	.Done
0000106A 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
00001070 6400                       		bcc.s	.Done
00001072 21EF 0042 996C             		move.l	$42(sp),rKosPBookmark.w
00001078 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001080                            
00001080                            .Done:
00001080 4E75                       		rts
00001082                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001082                            ; Processes the first entry in the Kosinski decompression queue
00001082                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001082                            ; PARAMETERS:
00001082                            ;	Nothing
00001082                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001082                            ; RETURNS:
00001082                            ;	Nothing
00001082                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001082                            ProcessKos:
00001082 4A78 994E                  		tst.w	rKosPCnt.w
00001086 6700 0000                  		beq.w	ProcessKos_Done
0000108A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000108E                            
0000108E                            ProcessKos_Main:
0000108E 0078 8000 994E             		ori.w	#$8000,rKosPCnt.w	; Set sign bit to signify decompression in progress
00001094 2078 9970                  		movea.l	rKosPList.w,a0
00001098 2278 9974                  		movea.l	rKosPDest.w,a1
0000109C                            		
0000109C                            		; What follows is identical to the normal Kosinski decompressor
0000109C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000109E 7000                       		moveq	#0,d0
000010A0 7200                       		moveq	#0,d1
000010A2 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
000010A6 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
000010A8 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
000010AA 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
000010AE 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
000010B2 7407                       		moveq	#7,d2				; Set repeat count to 8.
000010B4 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
000010B6 6000                       		bra.s	.FetchNewCode
000010B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010B8                            .FetchCodeLoop:
000010B8                            		; Code 1 (Uncompressed byte).
000010B8                            		_Kos_RunBitStream
000010B8 51CA 0000                M 	dbra	d2,.skip_47
000010BC 7407                     M 	moveq	#7,d2
000010BE 1001                     M 	move.b	d1,d0
000010C0 4643                     M 	not.w	d3
000010C2 6600                     M 	bne.s	.skip_47
000010C4 1018                     M 	move.b	(a0)+,d0
000010C6 1218                     M 	move.b	(a0)+,d1
000010C8 1034 0000                M 	move.b	(a4,d0.w),d0
000010CC 1234 1000                M 	move.b	(a4,d1.w),d1
000010D0                          M .skip_47:
000010D0 12D8                       		move.b	(a0)+,(a1)+
000010D2                            
000010D2                            .FetchNewCode:
000010D2                            		_Kos_ReadBit
000010D2 D000                     M 	add.b	d0,d0
000010D4 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
000010D6                            
000010D6                            		; Codes 00 and 01.
000010D6 7AFF                       		moveq	#-1,d5
000010D8 4BD1                       		lea	(a1),a5
000010DA                            		_Kos_RunBitStream
000010DA 51CA 0000                M 	dbra	d2,.skip_49
000010DE 7407                     M 	moveq	#7,d2
000010E0 1001                     M 	move.b	d1,d0
000010E2 4643                     M 	not.w	d3
000010E4 6600                     M 	bne.s	.skip_49
000010E6 1018                     M 	move.b	(a0)+,d0
000010E8 1218                     M 	move.b	(a0)+,d1
000010EA 1034 0000                M 	move.b	(a4,d0.w),d0
000010EE 1234 1000                M 	move.b	(a4,d1.w),d1
000010F2                          M .skip_49:
000010F2                            		_Kos_ReadBit
000010F2 D000                     M 	add.b	d0,d0
000010F4 6500 0000                  		bcs.w	.Code_01
000010F8                            
000010F8                            		; Code 00 (Dictionary ref. short).
000010F8                            		_Kos_RunBitStream
000010F8 51CA 0000                M 	dbra	d2,.skip_51
000010FC 7407                     M 	moveq	#7,d2
000010FE 1001                     M 	move.b	d1,d0
00001100 4643                     M 	not.w	d3
00001102 6600                     M 	bne.s	.skip_51
00001104 1018                     M 	move.b	(a0)+,d0
00001106 1218                     M 	move.b	(a0)+,d1
00001108 1034 0000                M 	move.b	(a4,d0.w),d0
0000110C 1234 1000                M 	move.b	(a4,d1.w),d1
00001110                          M .skip_51:
00001110                            		_Kos_ReadBit
00001110 D000                     M 	add.b	d0,d0
00001112 6500                       		bcs.s	.Copy45
00001114                            		_Kos_RunBitStream
00001114 51CA 0000                M 	dbra	d2,.skip_53
00001118 7407                     M 	moveq	#7,d2
0000111A 1001                     M 	move.b	d1,d0
0000111C 4643                     M 	not.w	d3
0000111E 6600                     M 	bne.s	.skip_53
00001120 1018                     M 	move.b	(a0)+,d0
00001122 1218                     M 	move.b	(a0)+,d1
00001124 1034 0000                M 	move.b	(a4,d0.w),d0
00001128 1234 1000                M 	move.b	(a4,d1.w),d1
0000112C                          M .skip_53:
0000112C                            		_Kos_ReadBit
0000112C D000                     M 	add.b	d0,d0
0000112E 6500                       		bcs.s	.Copy3
00001130                            		_Kos_RunBitStream
00001130 51CA 0000                M 	dbra	d2,.skip_55
00001134 7407                     M 	moveq	#7,d2
00001136 1001                     M 	move.b	d1,d0
00001138 4643                     M 	not.w	d3
0000113A 6600                     M 	bne.s	.skip_55
0000113C 1018                     M 	move.b	(a0)+,d0
0000113E 1218                     M 	move.b	(a0)+,d1
00001140 1034 0000                M 	move.b	(a4,d0.w),d0
00001144 1234 1000                M 	move.b	(a4,d1.w),d1
00001148                          M .skip_55:
00001148 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000114A DAC5                       		adda.w	d5,a5
0000114C 12DD                       		move.b	(a5)+,(a1)+
0000114E 12DD                       		move.b	(a5)+,(a1)+
00001150 6080                       		bra.s	.FetchNewCode
00001152                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001152                            .Copy3:
00001152                            		_Kos_RunBitStream
00001152 51CA 0000                M 	dbra	d2,.skip_56
00001156 7407                     M 	moveq	#7,d2
00001158 1001                     M 	move.b	d1,d0
0000115A 4643                     M 	not.w	d3
0000115C 6600                     M 	bne.s	.skip_56
0000115E 1018                     M 	move.b	(a0)+,d0
00001160 1218                     M 	move.b	(a0)+,d1
00001162 1034 0000                M 	move.b	(a4,d0.w),d0
00001166 1234 1000                M 	move.b	(a4,d1.w),d1
0000116A                          M .skip_56:
0000116A 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000116C DAC5                       		adda.w	d5,a5
0000116E 12DD                       		move.b	(a5)+,(a1)+
00001170 12DD                       		move.b	(a5)+,(a1)+
00001172 12DD                       		move.b	(a5)+,(a1)+
00001174 6000 FF5C                  		bra.w	.FetchNewCode
00001178                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001178                            .Copy45:
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_57
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_57
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_57:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy5
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_59
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_59
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_59:
000011AC 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011AE DAC5                       		adda.w	d5,a5
000011B0 12DD                       		move.b	(a5)+,(a1)+
000011B2 12DD                       		move.b	(a5)+,(a1)+
000011B4 12DD                       		move.b	(a5)+,(a1)+
000011B6 12DD                       		move.b	(a5)+,(a1)+
000011B8 6000 FF18                  		bra.w	.FetchNewCode
000011BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011BC                            .Copy5:
000011BC                            		_Kos_RunBitStream
000011BC 51CA 0000                M 	dbra	d2,.skip_60
000011C0 7407                     M 	moveq	#7,d2
000011C2 1001                     M 	move.b	d1,d0
000011C4 4643                     M 	not.w	d3
000011C6 6600                     M 	bne.s	.skip_60
000011C8 1018                     M 	move.b	(a0)+,d0
000011CA 1218                     M 	move.b	(a0)+,d1
000011CC 1034 0000                M 	move.b	(a4,d0.w),d0
000011D0 1234 1000                M 	move.b	(a4,d1.w),d1
000011D4                          M .skip_60:
000011D4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011D6 DAC5                       		adda.w	d5,a5
000011D8 12DD                       		move.b	(a5)+,(a1)+
000011DA 12DD                       		move.b	(a5)+,(a1)+
000011DC 12DD                       		move.b	(a5)+,(a1)+
000011DE 12DD                       		move.b	(a5)+,(a1)+
000011E0 12DD                       		move.b	(a5)+,(a1)+
000011E2 6000 FEEE                  		bra.w	.FetchNewCode
000011E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011E6                            .Code_01:
000011E6 7800                       		moveq	#0,d4				; d4 will contain copy count.
000011E8                            		; Code 01 (Dictionary ref. long / special).
000011E8                            		_Kos_RunBitStream
000011E8 51CA 0000                M 	dbra	d2,.skip_61
000011EC 7407                     M 	moveq	#7,d2
000011EE 1001                     M 	move.b	d1,d0
000011F0 4643                     M 	not.w	d3
000011F2 6600                     M 	bne.s	.skip_61
000011F4 1018                     M 	move.b	(a0)+,d0
000011F6 1218                     M 	move.b	(a0)+,d1
000011F8 1034 0000                M 	move.b	(a4,d0.w),d0
000011FC 1234 1000                M 	move.b	(a4,d1.w),d1
00001200                          M .skip_61:
00001200 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001202 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001204 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001206 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001208 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000120A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000120C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000120E                            
0000120E                            		; special mode (extended counter)
0000120E 1818                       		move.b	(a0)+,d4			; Read cnt
00001210 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001212 5304                       		subq.b	#1,d4
00001214 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001218                            
00001218 DAC5                       		adda.w	d5,a5
0000121A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000121C 3C04                       		move.w	d4,d6
0000121E 4646                       		not.w	d6
00001220 CC47                       		and.w	d7,d6
00001222 DC46                       		add.w	d6,d6
00001224 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00001226 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
0000122A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000122A                            .LargeCopy:
0000122A                            	rept (1<<_Kos_LoopUnroll)
0000122A                            		move.b	(a5)+,(a1)+
0000122A                            	endr
0000122A 12DD                     M 	move.b	(a5)+,(a1)+
0000122C 12DD                     M 	move.b	(a5)+,(a1)+
0000122E 12DD                     M 	move.b	(a5)+,(a1)+
00001230 12DD                     M 	move.b	(a5)+,(a1)+
00001232 12DD                     M 	move.b	(a5)+,(a1)+
00001234 12DD                     M 	move.b	(a5)+,(a1)+
00001236 12DD                     M 	move.b	(a5)+,(a1)+
00001238 12DD                     M 	move.b	(a5)+,(a1)+
0000123A 51CC FFEE                  		dbra	d4,.LargeCopy
0000123E 6000 FE92                  		bra.w	.FetchNewCode
00001242                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001242                            .StreamCopy:
00001242 DAC5                       		adda.w	d5,a5
00001244 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00001246 BF44                       		eor.w	d7,d4
00001248 D844                       		add.w	d4,d4
0000124A 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
0000124E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000124E                            .MediumCopy:
0000124E                            	rept 8
0000124E                            		move.b	(a5)+,(a1)+
0000124E                            	endr
0000124E 12DD                     M 	move.b	(a5)+,(a1)+
00001250 12DD                     M 	move.b	(a5)+,(a1)+
00001252 12DD                     M 	move.b	(a5)+,(a1)+
00001254 12DD                     M 	move.b	(a5)+,(a1)+
00001256 12DD                     M 	move.b	(a5)+,(a1)+
00001258 12DD                     M 	move.b	(a5)+,(a1)+
0000125A 12DD                     M 	move.b	(a5)+,(a1)+
0000125C 12DD                     M 	move.b	(a5)+,(a1)+
0000125E 6000 FE72                  		bra.w	.FetchNewCode
00001262                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001262                            .Quit:	
00001262 21C8 9970                  		move.l	a0,rKosPList.w
00001266 21C9 9974                  		move.l	a1,rKosPDest.w
0000126A 0278 7FFF 994E             		andi.w	#$7FFF,rKosPCnt.w		; Clear decompression in progress bit
00001270 5378 994E                  		subq.w	#1,rKosPCnt.w
00001274 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
00001276 41F8 9970                  		lea	rKosPList.w,a0
0000127A 43F8 9978                  		lea	(rKosPList+8).w,a1		; Otherwise, shift all entries up
0000127E                            	rept (rKosPList_End-rKosPList)/8-1
0000127E                            		move.l	(a1)+,(a0)+
0000127E                            		move.l	(a1)+,(a0)+
0000127E                            	endr
0000127E 20D9                     M 	move.l	(a1)+,(a0)+
00001280 20D9                     M 	move.l	(a1)+,(a0)+
00001282 20D9                     M 	move.l	(a1)+,(a0)+
00001284 20D9                     M 	move.l	(a1)+,(a0)+
00001286 20D9                     M 	move.l	(a1)+,(a0)+
00001288 20D9                     M 	move.l	(a1)+,(a0)+
0000128A                            
0000128A                            ProcessKos_Done:
0000128A 4E75                       		rts
0000128C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000128C                            RestoreKosBookmark:
0000128C 4CB8 007F 9950             		movem.w	rKosPRegs.w,d0-d6
00001292 4CF8 2300 995E             		movem.l	(rKosPRegs+2*7).w,a0-a1/a5
00001298 2F38 996C                  		move.l	rKosPBookmark.w,-(sp)
0000129C 3F38 996A                  		move.w	rKosPSR.w,-(sp)
000012A0 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
000012A2 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
000012A6 4E73                       		rte
000012A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012A8                            BackupKosRegs:
000012A8 40F8 996A                  		move	sr,rKosPSR.w
000012AC 48B8 007F 9950             		movem.w	d0-d6,rKosPRegs.w
000012B2 48F8 2300 995E             		movem.l	a0-a1/a5,(rKosPRegs+2*7).w
000012B8 4E75                       		rts
000012BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BA                            ; Load Kosinski compressed art into VRAM
000012BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BA                            ; PARAMETERS:
000012BA                            ;	a0.l	- Source address
000012BA                            ;	a1.l	- Destination address
000012BA                            ;	a2.w	- VRAM address
000012BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BA                            ; RETURNS:
000012BA                            ;	Nothing
000012BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BA                            LoadKosArt:
000012BA 2649                       		movea.l	a1,a3				; Save destination address
000012BC 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
000012C0                            
000012C0 93CB                       		suba.l	a3,a1				; Get size of decompressed art
000012C2 3609                       		move.w	a1,d3				; ''
000012C4 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
000012C6 220B                       		move.l	a3,d1				; Use destination address for DMA source
000012C8 340A                       		move.w	a2,d2				; Get destination VRAM address
000012CA 6000 EFBC                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
000012CE                            ; =========================================================================================================================================================
000012CE                            		include	"_LIB_/Math.asm"		; Math functions
000012CE                            ; =========================================================================================================================================================
000012CE                            ; Mighty The Armadillo in PRISM PARADISE
000012CE                            ; By Nat The Porcupine 2021
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; Math functions
000012CE                            ; =========================================================================================================================================================
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; Get a pseudo random number
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; PARAMETERS:
000012CE                            ;	Nothing
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; RETURNS:
000012CE                            ;	d0.l	- Random number
000012CE                            ;	d1.l	- New seed
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            RandomNumber:
000012CE 2238 C760                  		move.l	rRNGSeed.w,d1			; Get seed
000012D2 6600                       		bne.s	.Generate			; If it's already initialized, branch
000012D4 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
000012DA                            
000012DA                            .Generate:
000012DA 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
000012DC E581                       		asl.l	#2,d1				; ''
000012DE D280                       		add.l	d0,d1				; ''
000012E0 E781                       		asl.l	#3,d1				; ''
000012E2 D280                       		add.l	d0,d1				; ''
000012E4 3001                       		move.w	d1,d0				; ''
000012E6 4841                       		swap	d1				; ''
000012E8 D041                       		add.w	d1,d0				; ''
000012EA 3200                       		move.w	d0,d1				; ''
000012EC 4841                       		swap	d1				; ''
000012EE 21C1 C760                  		move.l	d1,rRNGSeed.w			; Set new seed
000012F2 4E75                       		rts
000012F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012F4                            ; Calculate the sine and cosine of an angle
000012F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012F4                            ; PARAMETERS:
000012F4                            ;	d0.b	- Angle
000012F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012F4                            ; RETURNS:
000012F4                            ;	d0.w	- Sine value
000012F4                            ;	d1.w	- Cosine value	
000012F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012F4                            CalcSine:
000012F4 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
000012F8 5040                       		addq.w	#8,d0				; Turn into offset
000012FA D040                       		add.w	d0,d0				; ''
000012FC 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001300 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001304 4E75                       		rts
00001306                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001306                            SineTable:
00001306 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
00001326 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
00001346 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
00001366 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001386 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000013A6 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000013C6 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000013E6 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001406 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
00001426 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
00001446 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
00001466 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001486 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000014A6 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000014C6 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000014E6 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001506 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
00001526 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
00001546 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
00001566 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001586 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000015A6 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000015C6 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000015E6 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001606 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
00001626 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
00001646 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
00001666 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001686 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000016A6 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000016C6 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000016E6 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001706                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001706                            ; Calculate the arctangent of y/x
00001706                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001706                            ; PARAMETERS:
00001706                            ;	d1.w	- X position
00001706                            ;	d2.w	- Y position
00001706                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001706                            ; RETURNS:
00001706                            ;	d0.w	- The angle
00001706                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001706                            CalcArcTan:
00001706                            		push.l	d3-d4
00001706 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000170A 7600                       		moveq	#0,d3
0000170C 7800                       		moveq	#0,d4
0000170E 3601                       		move.w	d1,d3
00001710 3802                       		move.w	d2,d4
00001712 8843                       		or.w	d3,d4
00001714 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001716 3802                       		move.w	d2,d4
00001718                            		
00001718 4A43                       		tst.w	d3
0000171A 6A00                       		bpl.s	.NotNeg
0000171C 4443                       		neg.w	d3
0000171E                            
0000171E                            .NotNeg:
0000171E 4A44                       		tst.w	d4
00001720 6A00                       		bpl.s	.NotNeg2
00001722 4444                       		neg.w	d4
00001724                            
00001724                            .NotNeg2:
00001724 B843                       		cmp.w	d3,d4
00001726 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
00001728 E18C                       		lsl.l	#8,d4
0000172A 88C3                       		divu.w	d3,d4
0000172C 7000                       		moveq	#0,d0
0000172E 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
00001732 6000                       		bra.s	.Skip
00001734                            
00001734                            .NotGreater:
00001734 E18B                       		lsl.l	#8,d3
00001736 86C4                       		divu.w	d4,d3
00001738 7040                       		moveq	#$40,d0
0000173A 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
0000173E                            
0000173E                            .Skip:
0000173E 4A41                       		tst.w	d1
00001740 6A00                       		bpl.s	.Skip2
00001742 4440                       		neg.w	d0
00001744 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
00001748                            
00001748                            .Skip2:
00001748 4A42                       		tst.w	d2
0000174A 6A00                       		bpl.s	.Skip3
0000174C 4440                       		neg.w	d0
0000174E 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
00001752                            
00001752                            .Skip3:
00001752                            		pop.l	d3-d4
00001752 4CDF 0018                M 	movem.l	(sp)+,d3-d4
00001756 4E75                       		rts
00001758                            
00001758                            GetArcTan_Zero:
00001758 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
0000175C                            		pop.l	d3-d4
0000175C 4CDF 0018                M 	movem.l	(sp)+,d3-d4
00001760 4E75                       		rts
00001762                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001762                            ArcTanTable:
00001762 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
00001768 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
0000176E 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
00001774 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
0000177A 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001780 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001786 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000178C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001792 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001798 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000179E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
000017A4 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
000017AA 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
000017B0 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
000017B6 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
000017BC 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
000017C2 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
000017C8 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
000017CE 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
000017D4 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
000017DA 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
000017E0 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
000017E6 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
000017EC 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
000017F2 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
000017F8 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
000017FE 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001804 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000180A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001810 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001816 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000181C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
00001822 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
00001828 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
0000182E 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
00001834 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
0000183A 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
00001840 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
00001846 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
0000184C 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
00001852 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
00001858 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
0000185E 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
00001864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001864                            ; Initialize oscillation
00001864                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001864                            InitOscillation:
00001864 43F8 C76A                  		lea	rOscNums.w,a1
00001868 45FA 0000                  		lea	OscInitData(pc),a2
0000186C 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
0000186E                            
0000186E                            .LoadData:
0000186E 32DA                       		move.w	(a2)+,(a1)+
00001870 51C9 FFFC                  		dbf	d1,.LoadData
00001874 4E75                       		rts
00001876                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001876                            OscInitData:
00001876 007D                       		dc.w	%0000000001111101
00001878 0080 0000                  		dc.w	$0080, $0000
0000187C 0080 0000                  		dc.w	$0080, $0000
00001880 0080 0000                  		dc.w	$0080, $0000
00001884 0080 0000                  		dc.w	$0080, $0000
00001888 0080 0000                  		dc.w	$0080, $0000
0000188C 0080 0000                  		dc.w	$0080, $0000
00001890 0080 0000                  		dc.w	$0080, $0000
00001894 0080 0000                  		dc.w	$0080, $0000
00001898 0080 0000                  		dc.w	$0080, $0000
0000189C 3848 00EE                  		dc.w	$3848, $00EE
000018A0 2080 00B4                  		dc.w	$2080, $00B4
000018A4 3080 010E                  		dc.w	$3080, $010E
000018A8 5080 01C2                  		dc.w	$5080, $01C2
000018AC 7080 0276                  		dc.w	$7080, $0276
000018B0 0080 0000                  		dc.w	$0080, $0000
000018B4 4000 00FE                  		dc.w	$4000, $00FE
000018B8                            OscInitData_End:
000018B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018B8                            ; Update oscillation
000018B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018B8                            UpdateOscillation:
000018B8 43F8 C76A                  		lea	rOscNums.w,a1
000018BC 45FA 0000                  		lea	OscUpdateData(pc),a2
000018C0 3619                       		move.w	(a1)+,d3
000018C2 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
000018C4                            
000018C4                            .OscLoop:
000018C4 341A                       		move.w	(a2)+,d2
000018C6 381A                       		move.w	(a2)+,d4
000018C8 0303                       		btst	d1,d3
000018CA 6600                       		bne.s	.Sub
000018CC 3029 0002                  		move.w	2(a1),d0
000018D0 D042                       		add.w	d2,d0
000018D2 3340 0002                  		move.w	d0,2(a1)
000018D6 D151                       		add.w	d0,(a1)
000018D8 B811                       		cmp.b	(a1),d4
000018DA 6200                       		bhi.s	.DoLoop
000018DC 03C3                       		bset	d1,d3
000018DE 6000                       		bra.s	.DoLoop
000018E0                            
000018E0                            .Sub:
000018E0 3029 0002                  		move.w	2(a1),d0
000018E4 9042                       		sub.w	d2,d0
000018E6 3340 0002                  		move.w	d0,2(a1)
000018EA D151                       		add.w	d0,(a1)
000018EC B811                       		cmp.b	(a1),d4
000018EE 6300                       		bls.s	.DoLoop
000018F0 0383                       		bclr	d1,d3
000018F2                            
000018F2                            .DoLoop:
000018F2 5849                       		addq.w	#4,a1
000018F4 51C9 FFCE                  		dbf	d1,.OscLoop
000018F8                            
000018F8 31C3 C76A                  		move.w	d3,rOscCtrl.w
000018FC                            
000018FC                            .End:
000018FC 4E75                       		rts
000018FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018FE                            OscUpdateData:
000018FE 0002 0010                  		dc.w	$02, $10
00001902 0002 0018                  		dc.w	$02, $18
00001906 0002 0020                  		dc.w	$02, $20
0000190A 0002 0030                  		dc.w	$02, $30
0000190E 0004 0020                  		dc.w	$04, $20
00001912 0008 0008                  		dc.w	$08, $08
00001916 0008 0040                  		dc.w	$08, $40
0000191A 0004 0040                  		dc.w	$04, $40
0000191E 0002 0038                  		dc.w	$02, $38
00001922 0002 0038                  		dc.w	$02, $38
00001926 0002 0020                  		dc.w	$02, $20
0000192A 0003 0030                  		dc.w	$03, $30
0000192E 0005 0050                  		dc.w	$05, $50
00001932 0007 0070                  		dc.w	$07, $70
00001936 0002 0040                  		dc.w	$02, $40
0000193A 0002 0040                  		dc.w	$02, $40
0000193E                            OscUpdateData_End:
0000193E                            ; =========================================================================================================================================================
0000193E                            		include	"_LIB_/Object.asm"		; Object functions
0000193E                            ; =========================================================================================================================================================
0000193E                            ; Mighty The Armadillo in PRISM PARADISE
0000193E                            ; By Nat The Porcupine 2021
0000193E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000193E                            ; Object functions
0000193E                            ; =========================================================================================================================================================
0000193E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000193E                            ; Initialize object lists
0000193E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000193E                            ; PARAMETERS:
0000193E                            ;	Nothing
0000193E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000193E                            ; RETURNS:
0000193E                            ;	Nothing
0000193E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000193E                            InitObjectList:
0000193E                            		clrRAM	rRespawns			; Clear object respawn table
0000193E                          M 	local	endaddr
0000193E                          M endaddr	equs	"rrespawns_End"
0000193E 7000                     M 	moveq	#0,d0
00001940 43F8 BE9E                M 	lea	(rrespawns).w,a1
00001944 323C 00BF                M 	move.w	#(((rrespawns_end)-(rrespawns))-((rrespawns)&1))>>2-1,d1
00001948 22C0                     M .clear_65:	move.l	d0,(a1)+
0000194A 51C9 FFFC                M 	dbf	d1,.clear_65
0000194E                            
0000194E                            	; setup tail object
0000194E 31FC BE54 BE58             		move.w	#rTailAddr,rTailNext.w		; set the first object as the tail object
00001954 31FC BE54 BE5A             		move.w	#rTailAddr,rTailPrev.w		; set the last object as the tail object
0000195A 21FC 0000 0000 BE54        		move.l	#.rts,rTailAddr.w		; set the next rts as the tail object pointer
00001962                            
00001962                            	; setup free object list
00001962 41F8 9A54                  		lea	rObjects.w,a0			; load the objects list into a0
00001966 31C8 BE5C                  		move.w	a0,rFreeHead.w			; set the first object as the first free object
0000196A 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
0000196C 7260                       		moveq	#oSize,d1			; load object size to d1
0000196E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000196E                            
0000196E                            .load
0000196E D0C1                       		add.w	d1,a0				; go to the next object now
00001970 3148 FFA6                  		move.w	a0,oPrev-oSize(a0)		; save new previous pointer
00001974 51C8 FFF8                  		dbf	d0,.load			; loop for every object
00001978                            
00001978 4268 0006                  		clr.w	oPrev(a0)			; set the last previous pointer to 0
0000197C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197C                            
0000197C                            	; reset display table
0000197C 43F8 BE56                  		lea	rDispInput-dNext.w,a1		; get display table address to a1
00001980 7207                       		moveq	#8-1,d1				; loop for all the layers
00001982                            
00001982                            .dsp
00001982 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001986 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001988 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
0000198C                            
0000198C 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001990 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001992 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001996                            
00001996                            .rts
00001996 4E75                       		rts
00001998                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001998                            ; Find the first free object space available
00001998                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001998                            ; PARAMETERS:
00001998                            ;	Nothing
00001998                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001998                            ; RETURNS:
00001998                            ;	a1.l	- Pointer to the SST space in the free object space
00001998                            ;	a2.l	- Trashed
00001998                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001998                            FindFreeObj:
00001998 3278 BE5C                  		move.w	rFreeHead.w,a1			; load the next free object to a1
0000199C B2FC 0000                  		cmp.w	#0,a1				; check if its a null pointer
000019A0 6700 0000                  		beq.w	.rts				; branch if so (z=1)
000019A4 31E9 0006 BE5C             		move.w	oPrev(a1),rFreeHead.w		; copy the next free object pointer to list start
000019AA                            ; --------------------------------------------------------------
000019AA                            
000019AA                            	; clear object memory
000019AA 45E9 000A                  		lea	oDrawPrev(a1),a2		; load the first byte to clear to a2
000019AE 425A                       		clr.w	(a2)+				; clear a word of data
000019B0                            
000019B0                            	rept (oSize-oDrawPrev) / 4			; repeat for every object property
000019B0                            		clr.l	(a2)+				; clear a longword of data
000019B0                            	endr
000019B0 429A                     M 	clr.l	(a2)+
000019B2 429A                     M 	clr.l	(a2)+
000019B4 429A                     M 	clr.l	(a2)+
000019B6 429A                     M 	clr.l	(a2)+
000019B8 429A                     M 	clr.l	(a2)+
000019BA 429A                     M 	clr.l	(a2)+
000019BC 429A                     M 	clr.l	(a2)+
000019BE 429A                     M 	clr.l	(a2)+
000019C0 429A                     M 	clr.l	(a2)+
000019C2 429A                     M 	clr.l	(a2)+
000019C4 429A                     M 	clr.l	(a2)+
000019C6 429A                     M 	clr.l	(a2)+
000019C8 429A                     M 	clr.l	(a2)+
000019CA 429A                     M 	clr.l	(a2)+
000019CC 429A                     M 	clr.l	(a2)+
000019CE 429A                     M 	clr.l	(a2)+
000019D0 429A                     M 	clr.l	(a2)+
000019D2 429A                     M 	clr.l	(a2)+
000019D4 429A                     M 	clr.l	(a2)+
000019D6 429A                     M 	clr.l	(a2)+
000019D8 429A                     M 	clr.l	(a2)+
000019DA                            ; --------------------------------------------------------------
000019DA                            
000019DA 3478 BE5A                  		move.w	rTailPrev.w,a2			; load last object to a2
000019DE 31C9 BE5A                  		move.w	a1,rTailPrev.w			; save as the new last object
000019E2 336A 0004 0004             		move.w	oNext(a2),oNext(a1)		; copy the next pointer from old tail to new object
000019E8 3549 0004                  		move.w	a1,oNext(a2)			; save new object as next pointer for old tail
000019EC 334A 0006                  		move.w	a2,oPrev(a1)			; save old tail as prev pointer for new object
000019F0                            
000019F0                            .rts
000019F0 4E75                       		rts
000019F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019F2                            ; Delete the current object
000019F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019F2                            ; PARAMETERS:
000019F2                            ;	Nothing
000019F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019F2                            ; RETURNS:
000019F2                            ;	a1.l	- Trashed
000019F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019F2                            DeleteObject:
000019F2                            	removeSprite	a0, a1, 1			; remove object display
000019F2 4A68 0008                M 	tst.w	odrawnext(a0)
000019F6 6700                     M 	beq.s	.yes_66
000019F8 3268 000A                M 	move.w	odrawprev(a0),a1
000019FC 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00001A02 3268 0008                M 	move.w	odrawnext(a0),a1
00001A06 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00001A0C 42A8 0008                M 	clr.l	odrawnext(a0)
00001A10                          M .yes_66
00001A10 3268 0006                  		move.w	oPrev(a0),a1			; copy previous pointer to a1
00001A14 3368 0004 0004             		move.w	oNext(a0),oNext(a1)		; copy next pointer to previous object
00001A1A 3268 0004                  		move.w	oNext(a0),a1			; get next object to a1
00001A1E 3368 0006 0006             		move.w	oPrev(a0),oPrev(a1)		; copy previous pointer
00001A24                            
00001A24 3178 BE5C 0006             		move.w	rFreeHead.w,oPrev(a0)		; get the head of the free list to previous pointer of this object
00001A2A 31C8 BE5C                  		move.w	a0,rFreeHead.w			; save as the new head of free list
00001A2E 4E75                       		rts
00001A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A30                            ; Delete an object
00001A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A30                            ; PARAMETERS:
00001A30                            ;	a1.l	- Pointer to object space to clear
00001A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A30                            ; RETURNS:
00001A30                            ;	a1.l	- Trashed
00001A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A30                            DeleteOtherObj:
00001A30                            		push.l	a0
00001A30 2F08                     M 	move.l	a0,-(sp)
00001A32 2049                       		move.l	a1,a0
00001A34 61BC                       		bsr.s	DeleteObject
00001A36                            		pop.l	a0
00001A36 205F                     M 	move.l	(sp)+,a0
00001A38 4E75                       		rts
00001A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A3A                            ; Render object sprites
00001A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A3A                            ; PARAMETERS:
00001A3A                            ;	Nothing
00001A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A3A                            ; RETURNS:
00001A3A                            ;	Nothing
00001A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A3A                            RenderObjects:
00001A3A 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001A3C 7C00                       		moveq	#0,d6				; Render flags
00001A3E                            
00001A3E 47F8 F880                  		lea	rFGCam.w,a3			; Foreground camera variables
00001A42 4BF8 BE5E                  		lea	rDispInput+dNext.w,a5	; Sprite input table
00001A46 4DF8 94CE                  		lea	rSprites.w,a6			; Sprite table buffer
00001A4A                            
00001A4A 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Are we in level mode?
00001A50 6600                       		bne.s	.PrioLvlLoop			; If not, branch
00001A52 4EB9 0000 0000             		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001A58                            
00001A58                            .PrioLvlLoop:
00001A58 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001A5A 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001A5C 4A68 0008                  		tst.w	oDrawNext(a0)			; Is the next pointer for a valid object?
00001A60 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001A64                            
00001A64                            .ObjectLoop:
00001A64                            	;	movea.w	(a4)+,a0			; Get object SST address
00001A64 4A90                       		tst.l	oAddr(a0)			; Is this object slot used?
00001A66 6700 0000                  		beq.w	.NextObject			; If not, branch
00001A6A                            
00001A6A 0228 007F 000D             		andi.b	#$7F,oRender(a0)		; Clear on-screen flag
00001A70 1C28 000D                  		move.b	oRender(a0),d6			; Store render flags
00001A74 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001A78 3228 0018                  		move.w	oYPos(a0),d1			; Get Y position
00001A7C                            
00001A7C 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001A80 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001A84 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001A88 6700                       		beq.s	.Render				; If not, branch
00001A8A                            
00001A8A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001A8C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001A90                            
00001A90                            .Render:
00001A90 7400                       		moveq	#0,d2
00001A92 1428 0017                  		move.b	oDrawW(a0),d2			; Get sprite width
00001A96 3600                       		move.w	d0,d3				; Get sprite X position
00001A98 D642                       		add.w	d2,d3				; Add width
00001A9A 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001A9C 3600                       		move.w	d0,d3				; Get sprite X position
00001A9E 9642                       		sub.w	d2,d3				; Subtract width
00001AA0 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001AA4 6C00                       		bge.s	.NextObject			; If so, branch
00001AA6 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001AAA                            
00001AAA 7400                       		moveq	#0,d2
00001AAC 1428 001B                  		move.b	oDrawH(a0),d2			; Get sprite height
00001AB0 3601                       		move.w	d1,d3				; Get sprite Y position
00001AB2 D642                       		add.w	d2,d3				; Add height
00001AB4 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001AB6 3601                       		move.w	d1,d3				; Get sprite Y position
00001AB8 9642                       		sub.w	d2,d3				; Subtract height
00001ABA 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001ABE 6C00                       		bge.s	.NextObject			; If so, branch
00001AC0 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001AC4                            
00001AC4 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001ACA 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001ACC 6B00                       		bmi.s	.NextObject			; If not, branch
00001ACE                            
00001ACE 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001AD2 6700                       		beq.s	.NextObject			; If blank, branch
00001AD4 2244                       		movea.l	d4,a1				; Store it
00001AD6 7800                       		moveq	#0,d4
00001AD8 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001ADC 6600                       		bne.s	.Static				; If so, branch
00001ADE 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001AE2 D844                       		add.w	d4,d4				; Turn into offset
00001AE4 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001AE8 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001AEA 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001AEC 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001AEE                            
00001AEE                            .Static:
00001AEE 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001AF2 6100 ECE2                  		bsr.w	DrawSprite			; Draw the sprites
00001AF6                            
00001AF6                            .NextObject:	
00001AF6 3068 0008                  		move.w	oDrawNext(a0),a0		; Load next object to a0
00001AFA 4A68 0008                  		tst.w	oDrawNext(a0)			; Check the next pointer for valid object
00001AFE 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B02                            
00001B02                            .NextPrioLvl:
00001B02 BAFC BE9E                  		cmpa.w	#rDispInput_End,a5		; Are we at the end of the input table?
00001B06 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B0A                            
00001B0A 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B0C 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B0E 7000                       		moveq	#0,d0
00001B10                            
00001B10                            .FillRest:
00001B10 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B12 504E                       		addq.w	#8,a6				; Next sprite
00001B14 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B18                            
00001B18                            .SetDrawnSprites:
00001B18 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B1C 4446                       		neg.w	d6				; ''
00001B1E 11C6 C75B                  		move.b	d6,rSprCount.w		; Store it
00001B22                            
00001B22 4E75                       		rts
00001B24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B24                            .MultiDraw:
00001B24 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B28 6700                       		beq.s	.RenderMain			; If not, branch
00001B2A                            
00001B2A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B2C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B30                            
00001B30                            .RenderMain:
00001B30 7400                       		moveq	#0,d2
00001B32 1428 0017                  		move.b	oDrawW(a0),d2			; Get main sprite width
00001B36 3600                       		move.w	d0,d3				; Get main sprite X position
00001B38 D642                       		add.w	d2,d3				; Add width
00001B3A 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B3C 3600                       		move.w	d0,d3				; Get main sprite X position
00001B3E 9642                       		sub.w	d2,d3				; Subtract width
00001B40 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B44 6CB0                       		bge.s	.NextObject			; If so, branch
00001B46 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B4A                            
00001B4A 1428 001B                  		move.b	oDrawH(a0),d2			; Get main sprite height
00001B4E 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B50 D642                       		add.w	d2,d3				; Add height
00001B52 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B54 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B56 9642                       		sub.w	d2,d3				; Subtract height
00001B58 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B5C 6C98                       		bge.s	.NextObject			; If so, branch
00001B5E 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B62                            
00001B62 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001B68 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B6A 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001B6E                            
00001B6E 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B72 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001B76 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001B7A 2444                       		movea.l	d4,a2				; Store it
00001B7C 7800                       		moveq	#0,d4
00001B7E 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001B82 D844                       		add.w	d4,d4				; Turn into offset
00001B84 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001B86 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B8A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B8C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B8E 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001B90 3606                       		move.w	d6,d3				; Store render flags
00001B92 6100 ED26                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001B96 3C03                       		move.w	d3,d6				; Restore render flags
00001B98                            
00001B98 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B9A 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001B9E                            
00001B9E                            .RenderSubSprites:
00001B9E 3628 002E                  		move.w	oSubCnt(a0),d3			; Get sub sprite count
00001BA2 5343                       		subq.w	#1,d3				; Subtract 1
00001BA4 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001BA8 41E8 0030                  		lea	oSubStart(a0),a0		; Get sub sprite SSTs start
00001BAC                            
00001BAC                            .RenderSubSprs_Loop:
00001BAC 3018                       		move.w	(a0)+,d0			; Get X position
00001BAE 0640 0080                  		addi.w	#128,d0				; Move on screen
00001BB2 3218                       		move.w	(a0)+,d1			; Get Y position
00001BB4 0641 0080                  		addi.w	#128,d1				; Move on screen
00001BB8                            
00001BB8 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001BBC 6700                       		beq.s	.RenderSub			; If not, branch
00001BBE                            
00001BBE 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001BC0 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001BC4                            
00001BC4                            .RenderSub:
00001BC4 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001BC6 D844                       		add.w	d4,d4				; Turn into offset
00001BC8 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BCA D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BCE 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BD0 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BD2 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001BD4                            		push.w	d6				; Store render flags
00001BD4 3F06                     M 	move.w	d6,-(sp)
00001BD6 6100 ECE2                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BDA                            		pop.w	d6				; Restore render flags
00001BDA 3C1F                     M 	move.w	(sp)+,d6
00001BDC                            
00001BDC                            .RenderSubSprs_ChkLoop:
00001BDC 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BDE 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001BE2 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001BE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BE6                            ; Animate an object's sprite
00001BE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BE6                            ; PARAMETERS:
00001BE6                            ;	a0.l	- Object space pointer
00001BE6                            ;	a1.l	- Animation script pointer
00001BE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BE6                            ; RETURNS:
00001BE6                            ;	Nothing
00001BE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BE6                            AnimateObject:
00001BE6 7000                       		moveq	#0,d0
00001BE8 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00001BEC B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00001BF0 6700                       		beq.s	.Run				; If not, branch
00001BF2 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00001BF6 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001BFA 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001BFE                            
00001BFE                            .Run:
00001BFE 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00001C02 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C04 D040                       		add.w	d0,d0				; Turn ID into offset
00001C06 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C0A 1151 0023                  		move.b	(a1),oAniTimer(a0)		; Set new animation timer
00001C0E                            
00001C0E 7200                       		moveq	#0,d1
00001C10 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00001C14 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C18 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C1C 6400                       		bhs.s	.CmdReset			; If so, branch
00001C1E                            
00001C1E                            .Next:
00001C1E 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00001C22 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00001C26 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C2A 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00001C30 8128 000D                  		or.b	d0,oRender(a0)			; Set flip bits
00001C34 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00001C38                            
00001C38                            .Wait:
00001C38 4E75                       		rts
00001C3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C3A                            .CmdReset:
00001C3A 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C3C 6600                       		bne.s	.CmdJump			; If not, branch
00001C3E 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C42 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001C46 60D6                       		bra.s	.Next				; Continue
00001C48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C48                            .CmdJump:
00001C48 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001C4A 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001C4C 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001C50 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00001C54 9200                       		sub.b	d0,d1				; ''
00001C56 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001C5A 60C2                       		bra.s	.Next				; Continue
00001C5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C5C                            .CmdSetAnim:
00001C5C 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001C5E 6600                       		bne.s	.CmdNextRout			; If not, branch
00001C60 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00001C66 4E75                       		rts
00001C68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C68                            .CmdNextRout:
00001C68 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001C6A 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001C6C 5428 0025                  		addq.b	#2,oRoutine(a0)			; Next routine
00001C70 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C74 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next animation frame
00001C78 4E75                       		rts
00001C7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C7A                            .CmdReset2ndRout:
00001C7A 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001C7C 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001C7E 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C82                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001C82 4E75                       		rts
00001C84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C84                            .CmdNext2ndRout:
00001C84 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001C86 6600                       		bne.s	.CmdEnd				; If not, branch
00001C88                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001C88 4E75                       		rts
00001C8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8A                            .CmdEnd:
00001C8A 4E75                       		rts
00001C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8C                            ; Load object DPLCs
00001C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8C                            ; PARAMETERS:
00001C8C                            ;	d4.w	- Target VRAM address
00001C8C                            ;	d6.l	- Pointer to uncompressed art
00001C8C                            ;	a2.l	- Pointer to DPLCs
00001C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8C                            ; RETURNS:
00001C8C                            ;	Nothing
00001C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8C                            LoadObjDPLCs:
00001C8C 7000                       		moveq	#0,d0
00001C8E 1028 0010                  		move.b	oFrame(a0),d0			; Get mapping frame
00001C92 B010                       		cmp.b	oPrevDPLC(a0),d0		; Do we need to update the art?
00001C94 6700                       		beq.s	.End				; If not, branch
00001C96 1080                       		move.b	d0,oPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001C98 D040                       		add.w	d0,d0				; Turn ID into offset
00001C9A D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001C9E 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CA0 5345                       		subq.w	#1,d5				; Subtract 1
00001CA2 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001CA4                            
00001CA4                            .ReadEntries:
00001CA4 7200                       		moveq	#0,d1
00001CA6 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001CA8 3601                       		move.w	d1,d3				; Copy that
00001CAA E04B                       		lsr.w	#8,d3				; Get tile count
00001CAC 0243 00F0                  		andi.w	#$F0,d3				; ''
00001CB0 0643 0010                  		addi.w	#$10,d3				; ''
00001CB4 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001CB8 EB89                       		lsl.l	#5,d1				; ''
00001CBA D286                       		add.l	d6,d1				; Get pointer in art data
00001CBC 3404                       		move.w	d4,d2				; Copy VRAM address
00001CBE D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001CC0 D843                       		add.w	d3,d4				; ''
00001CC2 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the art
00001CC6 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001CCA                            
00001CCA                            .End:
00001CCA 4E75                       		rts
00001CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CCC                            ; Move an object by it's velocity values
00001CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CCC                            ; PARAMETERS:
00001CCC                            ;	a0.l	- Object space pointer
00001CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CCC                            ; RETURNS:
00001CCC                            ;	Nothing
00001CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CCC                            ObjectMove:
00001CCC 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001CD0 48C0                       		ext.l	d0				; ''
00001CD2 E188                       		lsl.l	#8,d0				; Shift
00001CD4 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001CD8 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001CDC 48C0                       		ext.l	d0				; ''
00001CDE E188                       		lsl.l	#8,d0				; Shift
00001CE0 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001CE4 4E75                       		rts
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            ; Move an object by it's velocity values (with gravity)
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            ; PARAMETERS:
00001CE6                            ;	a0.l	- Object space pointer
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            ; RETURNS:
00001CE6                            ;	Nothing
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            ObjectMoveAndFall:
00001CE6 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001CEA 48C0                       		ext.l	d0				; ''
00001CEC E188                       		lsl.l	#8,d0				; Shift
00001CEE D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001CF2 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001CF6 0668 0038 001E             		addi.w	#$38,oYVel(a0)			; Apply gravity
00001CFC 48C0                       		ext.l	d0				; ''
00001CFE E188                       		lsl.l	#8,d0				; Shift
00001D00 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D04 4E75                       		rts
00001D06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D06                            ; Check if a specific object is nearby
00001D06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D06                            ; PARAMETERS:
00001D06                            ;	a0.l	- Current object space pointer
00001D06                            ;	a1.l	- Range data pointer
00001D06                            ;	a2.l	- Object to check's space pointer
00001D06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D06                            ; RETURNS:
00001D06                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D06                            CheckObjInRange:
00001D06 7000                       		moveq	#0,d0
00001D08 322A 0014                  		move.w	oXPos(a2),d1			; Get other object's position
00001D0C 342A 0018                  		move.w	oYPos(a2),d2			; ''
00001D10 3628 0014                  		move.w	oXPos(a0),d3			; Get current object's position
00001D14 3828 0018                  		move.w	oYPos(a0),d4			; ''
00001D18 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D1A 3A03                       		move.w	d3,d5				; Copy
00001D1C DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D1E D859                       		add.w	(a1)+,d4			; Get top boundary
00001D20 3C04                       		move.w	d4,d6				; Copy
00001D22 DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D24 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D26 6500                       		blo.s	.End				; If not, branch
00001D28 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D2A 6400                       		bhs.s	.End				; If not, branch
00001D2C B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D2E 6500                       		blo.s	.End				; If not, branch
00001D30 B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D32 6400                       		bhs.s	.End				; If not, branch
00001D34 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D36                            
00001D36                            .End:
00001D36 4E75                       		rts
00001D38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D38                            ; Object manager
00001D38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D38                            ObjectManager:
00001D38 4A38 C7B8                  		tst.b	rObjManInit.w
00001D3C 6600                       		bne.s	ObjectManagerMain
00001D3E                            
00001D3E                            ObjectManagerInit:
00001D3E 50F8 C7B8                  		st	rObjManInit.w			; Set the init flag
00001D42                            
00001D42 2078 C7B4                  		movea.l	rObjPosAddr.w,a0		; Get object data pointer
00001D46 21C8 C7BA                  		move.l	a0,rObjLoadR.w
00001D4A 21C8 C7BE                  		move.l	a0,rObjLoadL.w			; Store address of object layout
00001D4E                            
00001D4E 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001D52                            
00001D52 3C38 F880                  		move.w	rCamXPos.w,d6			; Camera's X position
00001D56 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001D5A 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001D5C 7C00                       		moveq	#0,d6				; Cap at left boundary
00001D5E                            
00001D5E                            .NoReset:
00001D5E 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001D62                            
00001D62 2078 C7BA                  		movea.l	rObjLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001D66                            
00001D66                            .ChkObjsLeft:
00001D66 BC50                       		cmp.w	(a0),d6				; Compare object position
00001D68 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001D6A 5C48                       		addq.w	#6,a0				; Next object
00001D6C 524B                       		addq.w	#1,a3				; Next respawn table index
00001D6E 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001D70                            
00001D70                            .ChkDone:
00001D70 21C8 C7BA                  		move.l	a0,rObjLoadR.w			; Store new addresses
00001D74 31CB C7C4                  		move.w	a3,rObjRespR.w			; ''
00001D78                            
00001D78 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001D7C                            
00001D7C 2078 C7BE                  		movea.l	rObjLoadL.w,a0
00001D80 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001D84 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001D86                            
00001D86                            .ChkObjsRight:
00001D86 BC50                       		cmp.w	(a0),d6				; Compate object position
00001D88 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001D8A 5C48                       		addq.w	#6,a0				; Next object
00001D8C 524B                       		addq.w	#1,a3				; Next respawn table index
00001D8E 60F6                       		bra.s	.ChkObjsRight			; Loop
00001D90                            
00001D90                            .ChkDone2:
00001D90 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001D94 31CB C7C2                  		move.w	a3,rObjRespL.w		; ''
00001D98                            
00001D98 31FC FFFF C7CA             		move.w	#-1,rObjManX.w		; Reset manager's camera X position
00001D9E 3038 F888                  		move.w	rCamYPos.w,d0			; Get camera's Y position
00001DA2 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001DA6 31C0 C7CC                  		move.w	d0,rObjManY.w		; Store it so unnecessary Y checks shouldn't be done
00001DAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DAA                            ObjectManagerMain:
00001DAA 3238 F888                  		move.w	rCamYPos.w,d1			; Get camera's Y position
00001DAE 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DB2 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DB6 31C1 C7C8                  		move.w	d1,rObjYCoarse.w		; Store this
00001DBA                            
00001DBA 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera's X position
00001DBE 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DC2 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DC6 31C1 C7C6                  		move.w	d1,rObjXCoarse.w		; Store this
00001DCA                            		
00001DCA 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001DD0                            
00001DD0 3638 F888                  		move.w	rCamYPos.w,d3			; Get camera's Y position
00001DD4 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001DD8 3803                       		move.w	d3,d4				; Copy
00001DDA 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001DDE 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001DE2 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001DE4 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001DE6                            
00001DE6                            .SetNoWrap:
00001DE6 3A3C 0FFF                  		move.w	#$FFF,d5
00001DEA 3C38 F880                  		move.w	rCamXPos.w,d6			; Get camera's X position
00001DEE 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001DF2 BC78 C7CA                  		cmp.w	rObjManX.w,d6		; Check against last range
00001DF6 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001DFA 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001DFC                            
00001DFC 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E00                            
00001E00 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E04 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E08                            
00001E08 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E0C 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E0E                            
00001E0E 4EB8 1998                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E12 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E14                            
00001E14                            .LoadLoop:
00001E14 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E18 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E1A 5D88                       		subq.l	#6,a0				; Get actual object address
00001E1C 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E1E                            
00001E1E 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E22 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E24 5D88                       		subq.l	#6,a0
00001E26 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E28                            
00001E28                            .LoadFail:
00001E28 5C88                       		addq.l	#6,a0				; Undo object loading
00001E2A 524B                       		addq.w	#1,a3
00001E2C 6000                       		bra.s	.EndLoad
00001E2E                            .EndLoadRst:
00001E2E 4EB8 1A30                  		jsr	DeleteOtherObj.w
00001E32                            
00001E32                            .EndLoad:
00001E32 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001E36 31CB C7C2                  		move.w	a3,rObjRespL.w
00001E3A                            
00001E3A 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E3E 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E42                            
00001E42 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001E46                            
00001E46                            .ChkLoop:
00001E46 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001E4A 6E00                       		bgt.s	.ChkDone			; If so, branch
00001E4C 5D88                       		subq.l	#6,a0				; Get the object before this
00001E4E 534B                       		subq.w	#1,a3				; And its respawn index
00001E50 60F4                       		bra.s	.ChkLoop			; Check next object
00001E52                            
00001E52                            .ChkDone:
00001E52 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001E56 31CB C7C4                  		move.w	a3,rObjRespR.w
00001E5A 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001E5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E5C                            Level_LoadObjs_Forward:
00001E5C 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E60                            
00001E60 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E64 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E68                            
00001E68 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001E6C                            
00001E6C 4EB8 1998                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E70 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E72                            
00001E72                            .LoadLoop:
00001E72 BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001E74 6300                       		bls.s	.EndLoadRst			; If not, branch
00001E76 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E7A 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001E7C 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001E7E 60F2                       		bra.s	.LoadLoop
00001E80                            
00001E80                            .EndLoadRst:
00001E80 4EB8 1A30                  		jsr	DeleteOtherObj.w
00001E84                            
00001E84                            .EndLoad:
00001E84 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001E88 31CB C7C4                  		move.w	a3,rObjRespR.w
00001E8C                            
00001E8C 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E90 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E94                            
00001E94 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001E98 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001E9A                            
00001E9A                            .ChkLoop:
00001E9A BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001E9C 6300                       		bls.s	.ChkDone			; If so, branch
00001E9E 5C88                       		addq.l	#6,a0				; Get the object before this
00001EA0 524B                       		addq.w	#1,a3				; And its respawn index
00001EA2 60F6                       		bra.s	.ChkLoop			; Check next object
00001EA4                            
00001EA4                            .ChkDone:
00001EA4 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001EA8 31CB C7C2                  		move.w	a3,rObjRespL.w
00001EAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EAC                            Level_LoadObjs_SameXRange:
00001EAC 3C38 F888                  		move.w	rCamYPos.w,d6			; Get camera's X position
00001EB0 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001EB4 3606                       		move.w	d6,d3				; Copy
00001EB6 BC78 C7CC                  		cmp.w	rObjManY.w,d6		; Check against last range
00001EBA 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001EBE 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001EC0                            
00001EC0 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001EC4 6B00 0000                  		bmi.w	.LoadEnd
00001EC8 6000                       		bra.s	.YCheck
00001ECA                            
00001ECA                            .MovingDown:
00001ECA 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001ECE                            
00001ECE                            .YCheck:
00001ECE 4EB8 1998                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001ED2 6700                       		beq.s	.LoadEnd			; If failed, branch
00001ED4                            		
00001ED4 3803                       		move.w	d3,d4				; Copy Y position
00001ED6 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001EDA 3A3C 0FFF                  		move.w	#$FFF,d5
00001EDE                            
00001EDE 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001EE2 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001EE6 2E38 C7BA                  		move.l	rObjLoadR.w,d7		; Get current objects on the right side of the screen
00001EEA 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001EEC 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001EEE 5488                       		addq.l	#2,a0				; Align to object's Y position
00001EF0                            
00001EF0                            .LoadNext:
00001EF0 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001EF2 6B00                       		bmi.s	.LoadFail			; If so, branch
00001EF4                            
00001EF4 3210                       		move.w	(a0),d1				; Get object's Y position
00001EF6 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001EF8 B243                       		cmp.w	d3,d1
00001EFA 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001EFC B244                       		cmp.w	d4,d1
00001EFE 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F00                            
00001F00 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F04 3368 FFFE 0014             		move.w	-2(a0),oXPos(a1)			; Set X position
00001F0A 3210                       		move.w	(a0),d1				; Get object's Y position
00001F0C 3401                       		move.w	d1,d2				; Copy it
00001F0E C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F10 3341 0018                  		move.w	d1,oYPos(a1)			; Set Y position
00001F14                            
00001F14 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F16 0242 0003                  		andi.w	#3,d2				; ''
00001F1A 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F1E 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001F22                            
00001F22 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F26 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F28 D442                       		add.w	d2,d2
00001F2A 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001F2E                            
00001F2E 1368 0003 0024             		move.b	3(a0),oSubtype(a1)		; Set subtype
00001F34 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001F38                            
00001F38 4EB8 1998                  		jsr	FindFreeObj.w			; Find a free object slot
00001F3C 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F3E                            
00001F3E                            .LoadFail:
00001F3E 5C88                       		addq.l	#6,a0				; Next object
00001F40 524B                       		addq.w	#1,a3				; ''
00001F42 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001F44 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001F46                            
00001F46                            .LoadEndRst:
00001F46 4EB8 1A30                  		jsr	DeleteOtherObj.w
00001F4A                            
00001F4A                            .LoadEnd:
00001F4A 31C6 C7CC                  		move.w	d6,rObjManY.w		; Store manager's camera Y position
00001F4E 4E75                       		rts
00001F50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F50                            ; Load an object from the object layout
00001F50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F50                            ; PARAMETERS:
00001F50                            ;	d3.w	- Upper boundary
00001F50                            ;	d4.w	- Lower boundary
00001F50                            ;	d5.w	- Y position limit
00001F50                            ;	a0.l	- Index of object layout
00001F50                            ;	a1.l	- Target object
00001F50                            ;	a3.l	- Respawn table address
00001F50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F50                            Level_LoadObject:
00001F50 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F52 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001F54 5C88                       		addq.l	#6,a0				; Next object
00001F56 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F58 4E75                       		rts
00001F5A                            
00001F5A                            .NotLoaded:
00001F5A 3E18                       		move.w	(a0)+,d7			; X position
00001F5C 3218                       		move.w	(a0)+,d1			; Y position
00001F5E 3401                       		move.w	d1,d2				; Copy
00001F60 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001F62 C245                       		and.w	d5,d1				; Keey Y in range
00001F64 B243                       		cmp.w	d3,d1
00001F66 6500                       		bcs.s	.End				; Branch if in range
00001F68 B244                       		cmp.w	d4,d1
00001F6A 6300                       		bls.s	.Spawn				; Branch if in range
00001F6C                            
00001F6C                            .End:
00001F6C 5448                       		addq.w	#2,a0				; Next objeect
00001F6E 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F70 4E75                       		rts
00001F72                            
00001F72                            .LoadNoY:
00001F72 C245                       		and.w	d5,d1				; Keey Y in range
00001F74                            
00001F74                            .Spawn:
00001F74 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F78 3347 0014                  		move.w	d7,oXPos(a1)			; Store X position
00001F7C 3341 0018                  		move.w	d1,oYPos(a1)			; Store Y position
00001F80                            
00001F80 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F82 0242 0003                  		andi.w	#3,d2				; ''
00001F86 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F8A 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001F8E                            
00001F8E 1418                       		move.b	(a0)+,d2			; Get ID
00001F90 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F92 D442                       		add.w	d2,d2
00001F94 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001F98                            
00001F98 1358 0024                  		move.b	(a0)+,oSubtype(a1)		; Set subtype
00001F9C 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001FA0                            		
00001FA0 6000 F9F6                  		bra.w	FindFreeObj			; Find a free object slot
00001FA4                            		
00001FA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FA4                            ; Check if the object is in range on the camera. If it isn't, delete it
00001FA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FA4                            ; PARAMETERS:
00001FA4                            ;	a0.l	- Object space pointer
00001FA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FA4                            ; RETURNS:
00001FA4                            ;	Nothing
00001FA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FA4                            CheckObjActive:
00001FA4 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001FA8                            
00001FA8                            CheckObjActive2:
00001FA8 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00001FAC 9078 C7C6                  		sub.w	rObjXCoarse.w,d0		; Subtract the camera's coarse X position
00001FB0 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00001FB4 6200                       		bhi.s	.Delete				; If so, branch
00001FB6 4E75                       		rts
00001FB8                            
00001FB8                            .Delete:
00001FB8 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table entry address
00001FBC 6700                       		beq.s	.DoDelete			; If 0, branch
00001FBE 3440                       		movea.w	d0,a2
00001FC0 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00001FC4                            
00001FC4                            .DoDelete:
00001FC4 4EF8 19F2                  		jmp	DeleteObject.w			; Delete the object
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; Get orientation to player
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; PARAMETERS:
00001FC8                            ;	a0.l	- Object space pointer
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; RETURNS:
00001FC8                            ;	a1.l	- Player object
00001FC8                            ;	d0.w	- 0 if player is left from object, 2 if right
00001FC8                            ;	d1.w	- 0 if player is above object, 2 if below
00001FC8                            ;	d2.w	- Player's horizontal distance to object
00001FC8                            ;	d3.w	- Player's vertical distance to object
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            GetOrientToPlayer:
00001FC8 7000                       		moveq	#0,d0
00001FCA 7200                       		moveq	#0,d1
00001FCC                            
00001FCC 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get player object
00001FD0                            
00001FD0 3428 0014                  		move.w	oXPos(a0),d2			; Get horizonal distance
00001FD4 9469 0014                  		sub.w	oXPos(a1),d2			; ''
00001FD8 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00001FDA 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00001FDC                            
00001FDC                            .GetY:
00001FDC 3628 0018                  		move.w	oYPos(a0),d3			; Get vertical distance
00001FE0 9669 0018                  		sub.w	oYPos(a1),d3			; ''
00001FE4 6400                       		bhs.s	.End				; Branch if the player is above the object
00001FE6 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00001FE8                            
00001FE8                            .End:
00001FE8 4E75                       		rts
00001FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEA                            ; Cap an object's speed
00001FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEA                            ; PARAMETERS:
00001FEA                            ;	a0.l	- Object space pointer
00001FEA                            ;	d0.w	- Max X speed
00001FEA                            ;	d1.w	- Max Y speed
00001FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEA                            ; RETURNS:
00001FEA                            ;	Nothing
00001FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEA                            CapObjSpeed:
00001FEA 3428 001C                  		move.w	oXVel(a0),d2			; Get X velocity
00001FEE 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
00001FF0 4440                       		neg.w	d0				; Get absolute speed
00001FF2 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00001FF4 6400                       		bhs.s	.ChkUp				; If not, branch
00001FF6 3400                       		move.w	d0,d2				; Cap the speed
00001FF8 6000                       		bra.s	.ChkUp				; Continue
00001FFA                            
00001FFA                            .ChkRight:
00001FFA B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00001FFC 6300                       		bls.s	.ChkUp				; If not, branch
00001FFE 3400                       		move.w	d0,d2				; Cap the speed
00002000                            
00002000                            .ChkUp:
00002000 3628 001E                  		move.w	oYVel(a0),d3			; Get Y velocity
00002004 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002006 4441                       		neg.w	d1				; Get absolute speed
00002008 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000200A 6400                       		bhs.s	.UpdateVel			; If not, branch
0000200C 3601                       		move.w	d1,d3				; Cap the speed
0000200E 6000                       		bra.s	.UpdateVel			; Continue
00002010                            
00002010                            .ChkDown:
00002010 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002012 6300                       		bls.s	.UpdateVel			; If not, branch
00002014 3601                       		move.w	d1,d3				; Cap the speed
00002016                            
00002016                            .UpdateVel:
00002016 3142 001C                  		move.w	d2,oXVel(a0)			; Set X velocity
0000201A 3142 001E                  		move.w	d2,oYVel(a0)			; Set Y velocity
0000201E 4E75                       		rts
00002020                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002020                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
00002020                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002020                            ; PARAMETERS:
00002020                            ;	a2.l	- Object data
00002020                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002020                            ; RETURNS:
00002020                            ;	Nothing
00002020                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002020                            ; LoadChildObject:
00002020 6100 F976                  		bsr.w	FindFreeObj			; Find a free object slot
00002024 6600                       		bne.s	.End				; If there is non, branch
00002026 301A                       		move.w	(a2)+,d0			; Get parent object SST
00002028 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
0000202C 301A                       		move.w	(a2)+,d0			; Get child object SST
0000202E 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
00002032 229A                       		move.l	(a2)+,oAddr(a1)			; Set object pointer
00002034 135A 0024                  		move.b	(a2)+,oSubtype(a1)		; Set subtype
00002038 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)			; Set X
0000203E 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)			; Set Y
00002044                            
00002044                            .End:
00002044 4E75                       		rts
00002046                            ; =========================================================================================================================================================
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; Entry point
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            GameInit:
00002046                            		intsOff						; Disable interrupts
00002046 007C 0700                M 	ori	#$700,sr
0000204A                            		
0000204A                            		clrRAM	RAM_START, RAM_END			; Clear RAM
0000204A                          M 	local	endaddr
0000204A                          M endaddr	equs	"ram_end"
0000204A 7000                     M 	moveq	#0,d0
0000204C 43F9 00FF 0000           M 	lea	ram_start,a1
00002052 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
00002056 22C0                     M .clear_72:	move.l	d0,(a1)+
00002058 51C9 FFFC                M 	dbf	d1,.clear_72
0000205C                            		
0000205C 6100 E3FE                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
00002060 6100 E15A                  		bsr.w	InitVDP					; Initialize the VDP
00002064 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
0000206A                            		
0000206A 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
00002070 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
00002074 11C0 C744                  		move.b	d0,rHWVersion.w				; Store in RAM
00002078                            
00002078 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
0000207C 31C0 C74A                  		move.w	d0,rVIntJmp.w				; Set the "JMP" command for V-INT
00002080 31C0 C750                  		move.w	d0,rHIntJmp.w				; Set the "JMP" command for H-INT
00002084 21FC 0000 0000 C74C        		move.l	#VInt_Standard,rVIntAddr.w		; Set the V-INT pointer to the standard V-INT routine
0000208C 21FC 0000 0000 C752        		move.l	#HInt_Water,rHIntAddr.w			; Set the H-INT pointer to the standard V-INT routine
00002094                            
00002094 4278 9000                  		clr.w	rDMAQueue.w				; Set stop token at the beginning of the DMA queue
00002098 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w			; Reset the DMA queue slot
0000209E                            
0000209E 11FC 0004 C75A             		move.b	#gLevel,rGameMode.w			; Set game mode to "title"
000020A4 4EF9 0000 0000             		jmp	Level					; Go to the title screen
000020AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020AA                            ; Go to the correct game mode
000020AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020AA                            GotoGameMode:
000020AA 7000                       		moveq	#0,d0
000020AC 1038 C75A                  		move.b	rGameMode.w,d0				; Get game mode ID
000020B0 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
000020B4 4ED0                       		jmp	(a0)					; Jump to it
000020B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020B6                            .GameModes:
000020B6 0000 0000                  		dc.l	TitleScreen				; Title screen
000020BA 0000 0000                  		dc.l	Level					; Level mode
000020BE 0000 0000                  		dc.l	Ending					; Ending
000020C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C2                            ; Check for pausing
000020C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C2                            CheckPause:
000020C2 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game already paused?
000020C6 6600                       		bne.s	.SetPause			; If so, branch
000020C8 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000020CE 6700                       		beq.s	.End				; If not, branch
000020D0                            
000020D0                            .SetPause:
000020D0 50F8 C75C                  		st	rPauseFlag.w			; Pause the game
000020D4                            		AMPS_MUSPAUSE				; Pause the music
000020D4 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
000020DA                            
000020DA                            .PauseLoop:
000020DA 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; General V-INT routine
000020E0 6100 E998                  		bsr.w	VSync_Routine			; V-SYNC
000020E4 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000020EA 67EE                       		beq.s	.PauseLoop			; If not, branch
000020EC                            
000020EC                            		AMPS_MUSUNPAUSE				; Unpause the music
000020EC 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
000020F2 4238 C75C                  		clr.b	rPauseFlag.w			; Unpause the game
000020F6                            
000020F6                            .End:
000020F6 4E75                       		rts
000020F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020F8                            ; Interrupts
000020F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020F8                            VInt_Standard:
000020F8                            		intsOff					; Turn interrupts off
000020F8 007C 0700                M 	ori	#$700,sr
000020FC                            		push.l	d0-a6				; Save registers
000020FC 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002100                            		
00002100 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002106 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0000210A                            
0000210A                            .WaitForVBLANK:
0000210A 3016                       		move.w	(a6),d0				; Get VDP status
0000210C 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
00002110 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
00002112                            
00002112 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
00002118 6700                       		beq.s	.SetVScroll			; If not, branch
0000211A 303C 0700                  		move.w	#$700,d0			; Do a delay
0000211E 51C8 FFFE                  		dbf	d0,*				; ''
00002122                            
00002122                            .SetVScroll:
00002122                            		dma68k	rVScroll,0,$50,VSRAM		; Load VScroll buffer into VSRAM
00002122 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
00002128 2CBC 96CA 953F           M 	move.l	#$96009500|((((rvscroll)/2)&$ff00)<<8)|(((rvscroll)/2)&$ff),(a6)
0000212E 3CBC 977F                M 	move.w	#$9700|(((rvscroll)>>17)&$7f),(a6)
00002132                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
00002132 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002136                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
00002136 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000213A 3C9F                     M 	move.w	(sp)+,(a6)
0000213C                            
0000213C 4A38 C745                  		tst.b	rVINTRout.w			; Is the game lagging?
00002140 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
00002144 4238 C748                  		clr.b	rLagCount.w			; Clear lag frame counter
00002148                            
00002148 7000                       		moveq	#0,d0
0000214A 1038 C745                  		move.b	rVINTRout.w,d0		; Get V-INT routine ID
0000214E 4238 C745                  		clr.b	rVINTRout.w			; Clear V-INT routine ID
00002152 50F8 C749                  		st	rHIntFlag.w			; Allow the H-INT to run
00002156 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
0000215A 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
0000215E                            
0000215E                            VInt_FinishUpdates:
0000215E 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002164                            
00002164                            VInt_End:
00002164 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
00002168 6100 F164                  		bsr.w	RandomNumber			; Generate a random number
0000216C                            		
0000216C                            		pop.l	d0-a6				; Restore registers
0000216C 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002170                            		intsOn					; Turn interrupts on
00002170 027C F8FF                M 	andi	#$f8ff,sr
00002174                            		lagOn					; Turn on the lag-o-meter
00002174 4E73                       		rte
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            ; V-INT routines
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            VInt_Routines:
00002176 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002178 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
0000217A 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
0000217C 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
0000217E 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
00002180 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
00002182                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002182                            ; V-INT lag routine
00002182                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002182                            VInt_Lag:
00002182 584F                       		addq.w	#4,sp				; Don't return to caller
00002184                            
00002184                            VInt_Lag_Main:
00002184 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002188 6600                       		bne.s	.WaterPal			; If so, branch
0000218A                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
0000218A 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002190 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002196 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
0000219A                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000219A 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000219E                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000219E 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021A2 3C9F                     M 	move.w	(sp)+,(a6)
000021A4 6000                       		bra.s	.Cont				; Continue
000021A6                            
000021A6                            .WaterPal:
000021A6                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021A6 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021AC 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000021B2 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000021B6                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021B6 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021BA                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021BA 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021BE 3C9F                     M 	move.w	(sp)+,(a6)
000021C0                            
000021C0                            .Cont:	
000021C0 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000021C4                            
000021C4 5238 C748                  		addq.b	#1,rLagCount.w		; Increment lag counter
000021C8 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
000021CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021CC                            ; V-INT general routine
000021CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021CC                            VInt_General:
000021CC 6100 0000                  		bsr.w	VInt_Update			; Do updates
000021D0 6000 EE86                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021D4                            ; V-INT level load routine
000021D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021D4                            VInt_LevelLoad:
000021D4 6100 E868                  		bsr.w	ReadJoypads			; Read joypads
000021D8                            
000021D8 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000021DC 6600                       		bne.s	.WaterPal			; If so, branch
000021DE                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000021DE 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021E4 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021EA 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000021EE                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021EE 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021F2                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021F2 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021F6 3C9F                     M 	move.w	(sp)+,(a6)
000021F8 6000                       		bra.s	.Cont				; Continue
000021FA                            
000021FA                            .WaterPal:
000021FA                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021FA 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002200 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002206 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000220A                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000220A 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000220E                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000220E 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002212 3C9F                     M 	move.w	(sp)+,(a6)
00002214                            
00002214                            .Cont:
00002214 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002218                            		
00002218                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
00002218 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000221E 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002224 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
00002228                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002228 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000222C                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000222C 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
00002230 3C9F                     M 	move.w	(sp)+,(a6)
00002232                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002232 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002238 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
0000223E 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002242                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002242 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002246                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002246 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000224A 3C9F                     M 	move.w	(sp)+,(a6)
0000224C 6100 E0DE                  		bsr.w	ProcessDMAQueue			; Process DMA queue
00002250                            		
00002250 6000 EE06                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002254                            ; V-INT level routine
00002254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002254                            VInt_Level:
00002254 43F8 F880                  		lea	rFGCam.w,a1			; Foreground level drawing variables
00002258 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Foreground column plane buffer
0000225C 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Foreground row plane buffer
00002260 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002266 43F8 F89E                  		lea	rBGCam.w,a1			; Background level drawing variables
0000226A 47F8 C424                  		lea	rBGColBuf.w,a3		; Background column plane buffer
0000226E 49F8 C322                  		lea	rBGRowBuf.w,a4		; Background row plane buffer
00002272 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002278                            
00002278 6100 E7C4                  		bsr.w	ReadJoypads			; Read joypads
0000227C                            
0000227C 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002280 6600                       		bne.s	.WaterPal			; If so, branch
00002282                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002282 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002288 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000228E 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002292                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002292 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002296                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002296 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000229A 3C9F                     M 	move.w	(sp)+,(a6)
0000229C 6000                       		bra.s	.Cont				; Continue
0000229E                            
0000229E                            .WaterPal:
0000229E                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000229E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022A4 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000022AA 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000022AE                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022AE 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022B2                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022B2 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022B6 3C9F                     M 	move.w	(sp)+,(a6)
000022B8                            
000022B8                            .Cont:
000022B8 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000022BC                            
000022BC                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000022BC 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022C2 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000022C8 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000022CC                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022CC 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022D0                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022D0 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022D4 3C9F                     M 	move.w	(sp)+,(a6)
000022D6                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000022D6 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000022DC 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
000022E2 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
000022E6                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000022E6 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000022EA                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000022EA 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000022EE 3C9F                     M 	move.w	(sp)+,(a6)
000022F0 6100 E03A                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000022F4                            		
000022F4 0C38 005C C75F             		cmpi.b	#92,rHIntCnt.w		; Would V-INT be unable to do updates in the next frame?
000022FA 6400                       		bhs.s	.DoUpdates			; If not, branch
000022FC 50F8 C75D                  		st	rHIntUpdates.W		; Set updates in H-INT flag
00002300 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
00002302 6100 ED54                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002306 6000 FE5C                  		bra.w	VInt_End			; Continue
0000230A                            
0000230A                            .DoUpdates:
0000230A 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
00002310 6000 ED46                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002314                            ; V-INT title screen update routine
00002314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002314                            VInt_Title:
00002314 4E75                       		rts
00002316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002316                            ;		bsr.w	ReadJoypads			; Read joypads
00002316                            ;
00002316                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
00002316                            ;		lea	rPalette.w,a0			; ''
00002316                            ;		moveq	#$80>>2-1,d0			; ''
00002316                            ;
00002316                            ;.WritePal:
00002316                            ;		move.l	(a0)+,VDP_DATA			; ''
00002316                            ;		dbf	d0,.WritePal			; ''
00002316                            ;
00002316                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
00002316                            ;		lea	rSprites.w,a0			; ''
00002316                            ;		move.w	#$280>>2-1,d0			; ''
00002316                            ;
00002316                            ;.WriteSprs:
00002316                            ;		move.l	(a0)+,VDP_DATA			; ''
00002316                            ;		dbf	d0,.WriteSprs			; ''
00002316                            ;
00002316                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
00002316                            ;		lea	rHScroll.w,a0			; ''
00002316                            ;		move.w	#$380>>2-1,d0			; ''
00002316                            ;
00002316                            ;.WriteHScrl:
00002316                            ;		move.l	(a0)+,VDP_DATA			; ''
00002316                            ;		dbf	d0,.WriteHScrl			; ''
00002316                            ;		rts
00002316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002316                            ; Do standard updates in V-INT
00002316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002316                            VInt_Update:
00002316                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
00002316                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
00002316 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000231C 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002322 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
00002326                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002326 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000232A                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000232A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
0000232E 3C9F                     M 	move.w	(sp)+,(a6)
00002330                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002330                            ; V-INT fade routine
00002330                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002330                            VInt_Fade:
00002330 6100 E70C                  		bsr.w	ReadJoypads			; Read joypads
00002334                            
00002334 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002338 6600                       		bne.s	.WaterPal			; If so, branch
0000233A                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
0000233A 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002340 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002346 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
0000234A                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000234A 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000234E                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000234E 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002352 3C9F                     M 	move.w	(sp)+,(a6)
00002354 6000                       		bra.s	.Cont				; Continue
00002356                            
00002356                            .WaterPal:
00002356                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
00002356 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000235C 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002362 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
00002366                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002366 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000236A                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000236A 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000236E 3C9F                     M 	move.w	(sp)+,(a6)
00002370                            
00002370                            .Cont:
00002370 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002374                            
00002374                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002374 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
0000237A 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
00002380 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002384                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002384 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002388                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002388 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000238C 3C9F                     M 	move.w	(sp)+,(a6)
0000238E 6000 DF9C                  		bra.w	ProcessDMAQueue			; Process DMA queue
00002392                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002392                            ; V-INT routine that only runs the SMPS driver
00002392                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002392                            VInt_RunSMPS:
00002392                            		push.l	d0-a6				; Save registers
00002392 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002396                            		
00002396                            .WaitForVBLANK:
00002396 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
0000239C 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000023A0 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
000023A2                            
000023A2 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
000023A8 6700                       		beq.s	.UpdateSMPS			; If not, branch
000023AA 303C 0700                  		move.w	#$700,d0			; Do a delay
000023AE 51C8 FFFE                  		dbf	d0,*				; ''
000023B2                            
000023B2                            .UpdateSMPS:
000023B2 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
000023B8                            
000023B8 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
000023BC 6100 EF10                  		bsr.w	RandomNumber			; Generate a random number
000023C0                            		
000023C0                            		pop.l	d0-a6				; Restore registers
000023C0 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
000023C4 4E73                       		rte
000023C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C6                            ; Title screen
000023C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C6                            		include	"Title Screen/Main.asm"
000023C6                            ; =========================================================================================================================================================
000023C6                            ; Mighty The Armadillo in PRISM PARADISE
000023C6                            ; By Nat The Porcupine 2021
000023C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C6                            ; Title splash screen
000023C6                            ; =========================================================================================================================================================
000023C6                            
000023C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C6                            TitleScreen:
000023C6 60FE                       		bra.s	TitleScreen
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
000023C8                            ;		playSnd	#Mus_Stop, 1			; Stop sound
000023C8                            ;
000023C8                            ;		bsr.w	FadeToBlack			; Fade to black
000023C8                            ;
000023C8                            ;		intsOff					; Disable interrupts
000023C8                            ;		clrRAM	rKosPVars
000023C8                            ;		clrRAM	rChkpoint
000023C8                            ;		clrRAM	rGameVars
000023C8                            ;		clrRAM	rObjects
000023C8                            ;
000023C8                            ;		lea	VDP_CTRL,a5
000023C8                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
000023C8                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
000023C8                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
000023C8                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
000023C8                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
000023C8                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
000023C8                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
000023C8                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
000023C8                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
000023C8                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
000023C8                            ;
000023C8                            ;		bsr.w	ClearScreen			; Clear screen
000023C8                            ;
000023C8                            ;		lea	rDestPal.w,a0			; Fade target palette
000023C8                            ;		moveq	#$80>>2-1,d0			; Size
000023C8                            ;
000023C8                            ;.FillPal:
000023C8                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
000023C8                            ;		dbf	d0,.FillPal			; Loop
000023C8                            ;
000023C8                            ;		bsr.w	FadeFromBlack			; Fade from black
000023C8                            ;		
000023C8                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
000023C8                            ;
000023C8                            ;TitleScreen2:
000023C8                            ;		intsOff
000023C8                            ;
000023C8                            ;		clr.b	rArtCheat.w
000023C8                            ;		clrRAM	rGameVars
000023C8                            ;		clrRAM	rObjects
000023C8                            ;
000023C8                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
000023C8                            ;		bsr.w	FadeToWhite			; Fade to white
000023C8                            ;
000023C8                            ;		intsOff
000023C8                            ;		bsr.w	ClearScreen			; Clear screen
000023C8                            ;
000023C8                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
000023C8                            ;		lea	rBuffer,a1			; Decompress into RAM
000023C8                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023C8                            ;		bsr.w	EniDec				; Decompress!
000023C8                            ;
000023C8                            ;		lea	rBuffer,a1			; Load mappings
000023C8                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
000023C8                            ;		moveq	#$27,d1				; $28x$1C tiles
000023C8                            ;		moveq	#$1B,d2				; ''
000023C8                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023C8                            ;		bsr.w	LoadPlaneMap			; Load the map
000023C8                            ;
000023C8                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
000023C8                            ;		lea	rBuffer,a1			; Decompress into RAM
000023C8                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
000023C8                            ;		bsr.w	EniDec				; Decompress!
000023C8                            ;
000023C8                            ;		lea	rBuffer,a1			; Load mappings
000023C8                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
000023C8                            ;		moveq	#$E,d1				; $28x$1C tiles
000023C8                            ;		moveq	#$C,d2				; ''
000023C8                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023C8                            ;		bsr.w	LoadPlaneMap			; Load the map
000023C8                            ;
000023C8                            ;		lea	Pal_Title,a0			; Load palette to target buffer
000023C8                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
000023C8                            ;		bsr.w	LoadTargetPal			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
000023C8                            ;		move.w	#$20,d2				; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
000023C8                            ;		move.w	#$6E00,d2			; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
000023C8                            ;		move.w	#$4000,d2			; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
000023C8                            ;		move.w	#$8400,d2			; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
000023C8                            ;		move.w	#$8600,d2			; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;.WaitPLCs:
000023C8                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023C8                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023C8                            ;		jsr	VSync_Routine.w			; V-SYNC
000023C8                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023C8                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023C8                            ;		bne.s	.WaitPLCs			; If so, branch
000023C8                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023C8                            ;		jsr	VSync_Routine.w			; V-SYNC
000023C8                            ;		
000023C8                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
000023C8                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
000023C8                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
000023C8                            ;
000023C8                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
000023C8                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
000023C8                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
000023C8                            ;
000023C8                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
000023C8                            ;		move.w	#224,(rObj_2+oX).w		; Set X
000023C8                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
000023C8                            ;
000023C8                            ;		jsr	RunObjects.w			; Run objects
000023C8                            ;		jsr	RenderObjects.w			; Render objects
000023C8                            ;
000023C8                            ;		clr.w	rPalCycTimer.w		; Reset palette cycle
000023C8                            ;
000023C8                            ;		bsr.w	FadeFromWhite			; Fade from white
000023C8                            ;
000023C8                            ;		lea	SampleList+$C0,a3		; Play title screen music
000023C8                            ;		jsr	PlayDAC1			; ''
000023C8                            ;
000023C8                            ;.Loop:
000023C8                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023C8                            ;		bsr.w	VSync_Routine			; ''
000023C8                            ;
000023C8                            ;		bsr.s	Title_Updates			; Do updates
000023C8                            ;		
000023C8                            ;		jsr	RunObjects.w			; Run objects
000023C8                            ;		jsr	RenderObjects.w			; Render objects
000023C8                            ;
000023C8                            ;		lea	FreeMove_Cheat(pc),a0
000023C8                            ;		lea	rMoveCheat.w,a1
000023C8                            ;		lea	rCheatEntry.w,a2
000023C8                            ;		bsr.w	Title_ChkCheats
000023C8                            ;		lea	Art_Cheat(pc),a0
000023C8                            ;		lea	rArtCheat.w,a1
000023C8                            ;		lea	rCheatEntry2.w,a2
000023C8                            ;		bsr.w	Title_ChkCheats
000023C8                            ;
000023C8                            ;		tst.b	rArtCheat.w
000023C8                            ;		bne.w	BinbowieArt
000023C8                            ;
000023C8                            ;		tst.b	rP1Press.w			; Has start been pressed
000023C8                            ;		bpl.s	.Loop				; If so, branch
000023C8                            ;
000023C8                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
000023C8                            ;
000023C8                            ;		lea	SampleList+$E0,a3		; Punch
000023C8                            ;		jsr	PlayDAC1			; ''
000023C8                            ;
000023C8                            ;.PunchLoop:
000023C8                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023C8                            ;		bsr.w	VSync_Routine			; ''
000023C8                            ;
000023C8                            ;		bsr.s	Title_Updates			; Do updates
000023C8                            ;
000023C8                            ;		jsr	RunObjects.w			; Run objects
000023C8                            ;		jsr	RenderObjects.w			; Render objects
000023C8                            ;		
000023C8                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
000023C8                            ;		bpl.s	.PunchLoop			; If not, loop
000023C8                            ;		
000023C8                            ;		st	rStartFall.w			; Set flag to start the level by falling
000023C8                            ;
000023C8                            ;		move.b	#gLevel,rGameMode.w		; Set game mode to "level"
000023C8                            ;		jmp	Level				; Go to level
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Palette cycle
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;Title_Updates:
000023C8                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
000023C8                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
000023C8                            ;		jsr	CalcSine.w			; Get sine
000023C8                            ;		asr.w	#5,d0				; ''
000023C8                            ;		move.w	d0,rVScrollFG.w		; Set logo's Y position
000023C8                            ;
000023C8                            ;		subq.b	#1,rPalCycTimer.w		; Decrement timer
000023C8                            ;		bpl.s	.End				; If it hasn't run out, branch
000023C8                            ;		move.b	#6,rPalCycTimer.w		; Reset timer
000023C8                            ;		
000023C8                            ;		moveq	#0,d0
000023C8                            ;		move.b	rPalCycIndex.w,d0		; Get index
000023C8                            ;		mulu.w	#$C,d0				; Turn into offset
000023C8                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
000023C8                            ;		lea	(rPalette+$14).w,a1		; Palette
000023C8                            ;		move.w	(a0)+,(a1)+			; Load palette
000023C8                            ;		move.w	(a0)+,(a1)+			; ''
000023C8                            ;		move.w	(a0)+,(a1)+			; ''
000023C8                            ;		move.w	(a0)+,(a1)+			; ''
000023C8                            ;		move.w	(a0)+,(a1)+			; ''
000023C8                            ;		move.w	(a0)+,(a1)+			; ''
000023C8                            ;		
000023C8                            ;		addq.b	#1,rPalCycIndex.w		; Increment index
000023C8                            ;		cmpi.b	#6,rPalCycIndex.w		; Has it reached the end?
000023C8                            ;		bcs.s	.End				; If not, branch
000023C8                            ;		clr.b	rPalCycIndex.w		; Reset index
000023C8                            
000023C8                            ;.End:
000023C8                            ;		rts
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;PalCyc_Title:
000023C8                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
000023C8                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
000023C8                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
000023C8                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
000023C8                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
000023C8                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Check for cheats
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;Title_ChkCheats:
000023C8                            ;		tst.b	(a1)
000023C8                            ;		bne.s	.End
000023C8                            ;		move.w	(a2),d0
000023C8                            ;		adda.w	d0,a0
000023C8                            ;		move.b	rP1Press.w,d0
000023C8                            ;		cmp.b	(a0),d0
000023C8                            ;		bne.s	.ResetCheat
000023C8                            ;		addq.w	#1,(a2)
000023C8                            ;		tst.b	d0
000023C8                            ;		bne.s	.End
000023C8                            ;		st	(a1)
000023C8                            ;		playSnd	#sRing, 2
000023C8                            ;		rts
000023C8                            ;
000023C8                            ;.ResetCheat:
000023C8                            ;		tst.b	d0
000023C8                            ;		beq.s	.End
000023C8                            ;		clr.w	(a2)
000023C8                            ;
000023C8                            ;.End:
000023C8                            ;		rts
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;FreeMove_Cheat:
000023C8                            ;		dc.b	1, 2, 4, 8, 0, $FF
000023C8                            ;		even
000023C8                            ;Art_Cheat:
000023C8                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
000023C8                            ;		even
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; BinBowie's art
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;BinbowieArt:
000023C8                            ;		bsr.w	FadeToWhite			; Fade to white
000023C8                            ;		
000023C8                            ;		lea	SampleList,a3
000023C8                            ;		jsr	PlayDAC1
000023C8                            ;
000023C8                            ;		intsOff
000023C8                            ;
000023C8                            ;		jsr	ClearScreen.w
000023C8                            ;
000023C8                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
000023C8                            ;		lea	rBuffer,a1			; Decompress into RAM
000023C8                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023C8                            ;		bsr.w	EniDec				; Decompress!
000023C8                            ;
000023C8                            ;		lea	rBuffer,a1			; Load mappings
000023C8                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
000023C8                            ;		moveq	#$27,d1				; $28x$1C tiles
000023C8                            ;		moveq	#$1B,d2				; ''
000023C8                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023C8                            ;		bsr.w	LoadPlaneMap			; Load the map
000023C8                            ;
000023C8                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
000023C8                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
000023C8                            ;		bsr.w	LoadTargetPal			; ''
000023C8                            ;
000023C8                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
000023C8                            ;		move.w	#$20,d2				; ''
000023C8                            ;		bsr.w	QueueKosMData			; ''
000023C8                            ;
000023C8                            ;.WaitPLCs:
000023C8                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023C8                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023C8                            ;		jsr	VSync_Routine.w			; V-SYNC
000023C8                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023C8                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023C8                            ;		bne.s	.WaitPLCs			; If so, branch
000023C8                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023C8                            ;		jsr	VSync_Routine.w			; V-SYNC
000023C8                            ;
000023C8                            ;		jsr	FadeFromWhite.w
000023C8                            ;
000023C8                            ;		lea	SampleList+$100,a3
000023C8                            ;		jsr	PlayDAC1
000023C8                            ;
000023C8                            ;.Loop:
000023C8                            ;		move.b	#vTitle,rVINTRout.w		; Level load V-INT routine
000023C8                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023C8                            ;		move.b	rP1Press.w,d0
000023C8                            ;		andi.b	#%10010000,d0
000023C8                            ;		beq.s	.Loop
000023C8                            ;
000023C8                            ;		jmp	TitleScreen2
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Objects
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
000023C8                            ;		include	"Title Screen/Objects/Bird/Code.asm"
000023C8                            ;		include	"Title Screen/Objects/Glove/Code.asm"
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Art
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;ArtKosM_TitleBG:
000023C8                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
000023C8                            ;		even
000023C8                            ;ArtKosM_TitleLogo:
000023C8                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
000023C8                            ;		even
000023C8                            ;ArtKosM_BinBowieArt:
000023C8                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
000023C8                            ;		even
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Plane mappings
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;MapEni_TitleBG:
000023C8                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
000023C8                            ;		even
000023C8                            ;MapEni_TitleLogo:
000023C8                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
000023C8                            ;		even
000023C8                            ;MapEni_BinBowieArt:
000023C8                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
000023C8                            ;		even
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Palette
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;Pal_Title:
000023C8                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
000023C8                            ;Pal_Title_End:
000023C8                            ;		even
000023C8                            ;Pal_BinBowieArt:
000023C8                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
000023C8                            ;Pal_BinBowieArt_End:
000023C8                            ;		even
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; SEGA FMV
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
000023C8                            ; =========================================================================================================================================================
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Level
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            		include	"Level/Main.asm"
000023C8                            ; =========================================================================================================================================================
000023C8                            ; Mighty The Armadillo in PRISM PARADISE
000023C8                            ; By Nat The Porcupine 2021
000023C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023C8                            ; Level
000023C8                            ; =========================================================================================================================================================
000023C8                            Level:
000023C8                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
000023C8 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
000023CE                            
000023CE 4EB8 04D6                  		jsr	FadeToBlack			; Fade to black
000023D2                            
000023D2                            Level_NoFade:
000023D2                            		; --- Set up the VDP ---
000023D2                            
000023D2                            		intsOff					; Disable interrupts
000023D2 007C 0700                M 	ori	#$700,sr
000023D6                            		displayOff				; Disable display
000023D6 3038 C764                M 	move.w	rvdpreg1.w,d0
000023DA 0200 00BF                M 	andi.b	#%10111111,d0
000023DE 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000023E4                            
000023E4 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
000023EA 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
000023EE 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
000023F2 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
000023F6 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
000023FA 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
000023FE 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
00002402 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
00002406 31C0 C766                  		move.w	d0,rWindowY.w			; ''
0000240A 3A80                       		move.w	d0,(a5)				; ''
0000240C 4278 9000                  		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002410 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
00002416                            
00002416 4EB8 01CC                  		jsr	ClearScreen.w			; Clear the screen
0000241A                            
0000241A                            		; --- Clear some RAM ---
0000241A                            
0000241A                            		clrRAM	rKosPVars			; Clear Kosinski queue variables
0000241A                          M 	local	endaddr
0000241A                          M endaddr	equs	"rkospvars_End"
0000241A 7000                     M 	moveq	#0,d0
0000241C 43F8 994E                M 	lea	(rkospvars).w,a1
00002420 323C 0040                M 	move.w	#(((rkospvars_end)-(rkospvars))-((rkospvars)&1))>>2-1,d1
00002424 22C0                     M .clear_130:	move.l	d0,(a1)+
00002426 51C9 FFFC                M 	dbf	d1,.clear_130
0000242A 32C0                     M 	move.w	d0,(a1)+
0000242C                            		clrRAM	rGameVars			; Clear variables
0000242C                          M 	local	endaddr
0000242C                          M endaddr	equs	"rgamevars_End"
0000242C 7000                     M 	moveq	#0,d0
0000242E 43F8 C7D0                M 	lea	(rgamevars).w,a1
00002432 323C 0DCB                M 	move.w	#(((rgamevars_end)-(rgamevars))-((rgamevars)&1))>>2-1,d1
00002436 22C0                     M .clear_131:	move.l	d0,(a1)+
00002438 51C9 FFFC                M 	dbf	d1,.clear_131
0000243C                            		clrRAM	rOscNums			; Clear oscillation data
0000243C                          M 	local	endaddr
0000243C                          M endaddr	equs	"roscnums_End"
0000243C 7000                     M 	moveq	#0,d0
0000243E 43F8 C76A                M 	lea	(roscnums).w,a1
00002442 323C 000F                M 	move.w	#(((roscnums_end)-(roscnums))-((roscnums)&1))>>2-1,d1
00002446 22C0                     M .clear_132:	move.l	d0,(a1)+
00002448 51C9 FFFC                M 	dbf	d1,.clear_132
0000244C 32C0                     M 	move.w	d0,(a1)+
0000244E                            
0000244E                            		; --- Do some final initializing and play the level music ---
0000244E                            
0000244E 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Set ring animation timer
00002454 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set floor timer
0000245A 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset palette cycle
0000245E                            
0000245E 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002462 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002466 E218                       		ror.b	#1,d0				; Turn into offset
00002468 EE48                       		lsr.w	#7,d0				; ''
0000246A 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
0000246E 11C0 F8D6                  		move.b	d0,rLevelMusic.w		; Store it
00002472                            		playSnd	d0, 1				; Play it
00002472 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
00002476                            
00002476                            		intsOn					; Enable interrupts
00002476 027C F8FF                M 	andi	#$f8ff,sr
0000247A                            
0000247A                            		; --- Load level data ---
0000247A                            
0000247A 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
00002480 4EB8 0ECC                  		jsr	LoadKosMQueue.w			; ''
00002484                            
00002484 4EB8 193E                  		jsr	InitObjectList.w
00002488                            
00002488 4EB8 1998                  		jsr	FindFreeObj.w
0000248C 22BC 0000 0000             		move.l	#ObjMighty,oAddr(a1)		; Load Mighty object
00002492 31C9 F86C                  		move.w	a1,rPlayer1Addr.w		; Store the address
00002496                            
00002496 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
0000249A 6700                       		beq.s	.NoSurface			; If not, branch
0000249C                            
0000249C                            							; Load water surfaces
0000249C 4EB8 1998                  		jsr	FindFreeObj.w
000024A0 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024A6 337C 0060 0014             		move.w	#$60,oXPos(a1)
000024AC 31C9 F87C                  		move.w	a1,rWater1Addr.w		; Store the address
000024B0                            
000024B0 4EB8 1998                  		jsr	FindFreeObj.w
000024B4 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024BA 337C 0120 0014             		move.w	#$120,oXPos(a1)
000024C0 31C9 F87E                  		move.w	a1,rWater2Addr.w		; Store the address
000024C4                            
000024C4                            .NoSurface:
000024C4 6100 0000                  		bsr.w	Level_LoadData			; Load level data
000024C8                            
000024C8                            .WaitPLCs:
000024C8 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000024CE 4EB8 1082                  		jsr	ProcessKos.w			; Process Kosinski queue
000024D2 4EB8 0A7A                  		jsr	VSync_Routine.w			; V-SYNC
000024D6 4EB8 0F2E                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000024DA 4A38 9990                  		tst.b	rKosPMMods.w			; Are there still modules left?
000024DE 66E8                       		bne.s	.WaitPLCs			; If so, branch
000024E0                            
000024E0 4238 F8F4                  		clr.b	rWaterFlag.w			; Clear the water flag
000024E4                            
000024E4 41FA 0000                  		lea	Level_WaterLevels(pc),a0	; Water heights
000024E8 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000024EC E218                       		ror.b	#1,d0				; Turn into offset
000024EE EC48                       		lsr.w	#6,d0				; ''
000024F0 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
000024F4 6B00                       		bmi.s	.NoWater			; If it's negative, branch
000024F6 31C0 F8F6                  		move.w	d0,rWaterLvl.w		; Set the water height
000024FA 31C0 F8F8                  		move.w	d0,rDestWtrLvl.w
000024FE                            
000024FE 50F8 F8F4                  		st	rWaterFlag.w			; Set the water flag
00002502 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
0000250A 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
0000250E 33F8 C75E 00C0 0004        		move.w	rHIntReg.w,VDP_CTRL		; Set H-INT counter
00002516                            
00002516                            .NoWater:
00002516 31FC 00A0 F8D2             		move.w	#320/2,rCamXPosCenter.w		; Set camera X center
0000251C                            
0000251C 4EB8 1864                  		jsr	InitOscillation.w		; Initialize oscillation
00002520                            
00002520 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
00002524 6100 0000                  		bsr.w	Level_InitHUD			; Initialize the HUD
00002528 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
0000252C                            
0000252C 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002530                            
00002530                            		; --- Load the planes ---
00002530                            
00002530                            		intsOff					; Disable interrupts
00002530 007C 0700                M 	ori	#$700,sr
00002534 21FC 0000 2392 C74C        		move.l	#VInt_RunSMPS,rVIntAddr.w	; Swap V-INT
0000253C                            		intsOn					; Enable interrupts
0000253C 027C F8FF                M 	andi	#$f8ff,sr
00002540 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
00002544                            		intsOff					; Disable interrupts
00002544 007C 0700                M 	ori	#$700,sr
00002548 21FC 0000 20F8 C74C        		move.l	#VInt_Standard,rVIntAddr.w	; Swap V-INT
00002550                            		intsOn					; Enable interrupts
00002550 027C F8FF                M 	andi	#$f8ff,sr
00002554 11FC 0006 C745             		move.b	#vLvlLoad,rVINTRout.w		; Level load V-INT routine
0000255A 4EB8 0A7A                  		jsr	VSync_Routine.w			; V-SYNC
0000255E                            
0000255E                            		; --- Load the level objects and rings ---
0000255E                            
0000255E 51F8 C7B8                  		sf	rObjManInit.w			; Reset object manager routine
00002562 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
00002566 4EB8 1D38                  		jsr	ObjectManager.w			; Run the object manager
0000256A                            	runObjects
0000256A 3078 BE58                M 	movea.w	rtailnext.w,a0
0000256E 2250                     M 	move.l	oaddr(a0),a1
00002570 4E91                     M 	jsr	(a1)
00002572 4EB8 1A3A                  		jsr	RenderObjects.w			; Render objects
00002576                            
00002576 4238 F8FC                  		clr.b	rLvlReload.w			; Clear the level reload flag
0000257A                            
0000257A                            		displayOn				; Enable display
0000257A 3038 C764                M 	move.w	rvdpreg1.w,d0
0000257E 0000 0040                M 	ori.b	#%01000000,d0
00002582 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002588 4EB8 0552                  		jsr	FadeFromBlack.w			; Fade from black
0000258C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000258C                            ; Main loop
0000258C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000258C                            .Loop:
0000258C 11FC 0004 C745             		move.b	#vLevel,rVINTRout.w		; Level V-INT routine
00002592 4EB8 1082                  		jsr	ProcessKos.w			; Process Kosinski queue
00002596 4EB8 0A7A                  		jsr	VSync_Routine.w			; V-SYNC
0000259A                            
0000259A 4EB8 20C2                  		jsr	CheckPause.w			; Check for pausing
0000259E 5278 F8FA                  		addq.w	#1,rLvlFrames.w			; Increment frame counter
000025A2                            
000025A2 4EB8 18B8                  		jsr	UpdateOscillation.w		; Update oscillation
000025A6                            
000025A6 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
000025AA 4EB8 1D38                  		jsr	ObjectManager.w			; Run the object manager
000025AE                            
000025AE                            	runObjects
000025AE 3078 BE58                M 	movea.w	rtailnext.w,a0
000025B2 2250                     M 	move.l	oaddr(a0),a1
000025B4 4E91                     M 	jsr	(a1)
000025B6                            
000025B6 4A38 F8FC                  		tst.b	rLvlReload.w			; Does the level need to be reloaded?
000025BA 6600 FE0C                  		bne.w	Level				; If so, branch
000025BE                            
000025BE 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
000025C2 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
000025C6 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
000025CA                            
000025CA 4EB8 1A3A                  		jsr	RenderObjects.w			; Render objects
000025CE                            
000025CE 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000025D2 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025D6 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
000025DA 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
000025DE                            
000025DE 5338 F3D8                  		subq.b	#1,rRingAniTime.w		; Decrement ring animation timer
000025E2 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
000025E4 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Reset animation timer
000025EA 5238 F3D7                  		addq.b	#1,rRingFrame.w			; Next ring frame
000025EE 0238 0007 F3D7             		andi.b	#7,rRingFrame.w			; Limit it
000025F4                            
000025F4 7000                       		moveq	#0,d0
000025F6 1038 F3D7                  		move.b	rRingFrame.w,d0			; Get ring frame
000025FA EF48                       		lsl.w	#7,d0				; Convert to offset
000025FC 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002602 D280                       		add.l	d0,d1				; ''
00002604 343C D780                  		move.w	#$D780,d2			; VRAM address
00002608 363C 0040                  		move.w	#$80/2,d3			; Size
0000260C 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002610                            
00002610                            .NoRingAni:
00002610 4A38 F3D9                  		tst.b	rRLossAniT.w
00002614 6700                       		beq.s	.NoRingLossAni
00002616 7000                       		moveq	#0,d0
00002618 1038 F3D9                  		move.b	rRLossAniT.w,d0
0000261C D078 F3DA                  		add.w	rRLossAniA.w,d0
00002620 31C0 F3DA                  		move.w	d0,rRLossAniA.w
00002624 E158                       		rol.w	#8,d0
00002626 0240 0007                  		andi.w	#7,d0
0000262A 11C0 F3DC                  		move.b	d0,rRLossAniF.w
0000262E 5338 F3D9                  		subq.b	#1,rRLossAniT.w
00002632                            
00002632 7000                       		moveq	#0,d0
00002634 1038 F3DC                  		move.b	rRLossAniF.w,d0		; Get ring frame
00002638 EF48                       		lsl.w	#7,d0				; Convert to offset
0000263A 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002640 D280                       		add.l	d0,d1				; ''
00002642 343C D680                  		move.w	#$D680,d2			; VRAM address
00002646 363C 0040                  		move.w	#$80/2,d3			; Size
0000264A 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
0000264E                            
0000264E                            .NoRingLossAni:
0000264E 4EB8 0F2E                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002652                            
00002652 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Is the game mode level?
00002658 6700 FF32                  		beq.w	.Loop				; If so, branch
0000265C 4EF8 20AA                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            ; Level functions
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            		include	"Level/Level Drawing.asm"
00002660                            ; =========================================================================================================================================================
00002660                            ; Mighty The Armadillo in PRISM PARADISE
00002660                            ; By Nat The Porcupine 2021
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002660                            ; =========================================================================================================================================================
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            ; Initialize the planes
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            ; PARAMETERS:
00002660                            ;	Nothing
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            ; RETURNS:
00002660                            ;	Nothing
00002660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002660                            Level_InitPlanes:
00002660 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002664 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
00002668 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
0000266C                            
0000266C 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002674 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002678                            		
00002678 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
0000267C E218                       		ror.b	#1,d0				; Turn into offset
0000267E E648                       		lsr.w	#3,d0				; ''
00002680 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002686 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
0000268C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002690 4E90                       		jsr	(a0)				; Jump to it
00002692                            
00002692 31E9 0008 947E             		move.w	cYPos(a1),rVScrollFG.w		; Set the V-Scroll value for the foreground
00002698                            
00002698 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
0000269C 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
000026A0 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000026A4                            		
000026A4 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
000026AC 337C 0080 0016             		move.w	#$80,cLayout(a1)		; Set the offset for the level layout (background)
000026B2                            		
000026B2 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000026B6 E218                       		ror.b	#1,d0				; Turn into offset
000026B8 E648                       		lsr.w	#3,d0				; ''
000026BA 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
000026C0 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000026C6 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000026CA 4E90                       		jsr	(a0)				; Jump to it
000026CC                            
000026CC 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
000026D2 4E75                       		rts
000026D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D4                            ; Update the planes
000026D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D4                            Level_UpdatePlanes:
000026D4 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
000026D8 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
000026DC 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
000026E0                            		
000026E0 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000026E4 4E90                       		jsr	(a0)				; Jump to it
000026E6                            		
000026E6 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
000026EA 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
000026EE 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000026F2                            
000026F2 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000026F6 4E90                       		jsr	(a0)				; Jump to it
000026F8                            
000026F8 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000026FC 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002700 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
00002706 31EA 0008 947E             		move.w	cYPos(a2),rVScrollFG.w		; Set the V-Scroll value for the foreground
0000270C 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002710 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
00002716 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
0000271C                            
0000271C 4E75                       		rts
0000271E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000271E                            ; General foreground initialization
0000271E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000271E                            General_InitFG:
0000271E 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002722                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002722                            ; General background initialization
00002722                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002722                            General_InitBG:
00002722 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
00002726 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002728 E240                       		asr.w	#1,d0				; Divide by 2
0000272A 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
0000272C 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002730 E240                       		asr.w	#1,d0				; Divide by 2
00002732 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002736                            
00002736 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
0000273A                            		
0000273A 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
0000273E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000273E                            ; General foreground update
0000273E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000273E                            General_UpdateFG:
0000273E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002742                            		
00002742 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002744 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002746 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
0000274A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000274A                            ; General background update
0000274A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000274A                            General_UpdateBG:
0000274A 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
0000274E 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002750 E240                       		asr.w	#1,d0				; Divide by 2
00002752 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002754 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002758 E240                       		asr.w	#1,d0				; Divide by 2
0000275A 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000275E                            
0000275E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002762 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002764 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002766 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
0000276A                            		
0000276A 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            ; Draw new tiles in the level
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            ; PARAMETERS:
0000276E                            ;	a1.l	- Camera RAM
0000276E                            ;	a2.l	- Plane buffer for columns
0000276E                            ;	a3.l	- Plane buffer for rows
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            ; RETURNS:
0000276E                            ;	Nothing
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            VInt_DrawLevel:
0000276E 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002772 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002776                            
00002776 3013                       		move.w	(a3),d0				; Get high VDP command word
00002778 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
0000277C 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
0000277E 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002782                            
00002782                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002782                            
00002782 3200                       		move.w	d0,d1				; Save high VDP command
00002784 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002786 7C00                       		moveq	#0,d6
00002788 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
0000278C 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000278E                            
0000278E 3C80                       		move.w	d0,(a6)				; Set VDP command
00002790 3C84                       		move.w	d4,(a6)				; ''
00002792 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002794                            
00002794                            .DrawCol1_1_Loop:
00002794 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002796                            
00002796                            .DrawCol1_1_Start:
00002796 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
0000279A                            
0000279A 3403                       		move.w	d3,d2				; Wrap to the top of the plane
0000279C 0642 007C                  		addi.w	#$7C,d2				; ''
000027A0 C042                       		and.w	d2,d0				; ''
000027A2                            
000027A2 3C80                       		move.w	d0,(a6)				; Set VDP command
000027A4 3C84                       		move.w	d4,(a6)				; ''
000027A6                            
000027A6                            .DrawCol1_2_Loop:
000027A6 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027A8 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
000027AC                            
000027AC                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
000027AC                            
000027AC 5441                       		addq.w	#2,d1				; Move over to the right
000027AE 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
000027B0 7C00                       		moveq	#0,d6
000027B2 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
000027B6 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027B8                            
000027B8 3C81                       		move.w	d1,(a6)				; Set VDP command
000027BA 3C84                       		move.w	d4,(a6)				; ''
000027BC 6000                       		bra.s	.DrawCol2_1_Start		; Start
000027BE                            
000027BE                            .DrawCol2_1_Loop:
000027BE 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027C0                            
000027C0                            .DrawCol2_1_Start:
000027C0 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
000027C4                            
000027C4 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000027C6 0642 007E                  		addi.w	#$7E,d2				; ''
000027CA C242                       		and.w	d2,d1				; ''
000027CC                            
000027CC 3C81                       		move.w	d1,(a6)				; Set VDP command
000027CE 3C84                       		move.w	d4,(a6)				; ''
000027D0                            
000027D0                            .DrawCol2_2_Loop:
000027D0 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027D2 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
000027D6                            
000027D6 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
000027DA 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
000027DC                            
000027DC                            VInt_DrawLvlRows:
000027DC 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
000027E0 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
000027E4                            
000027E4                            VInt_DrawLvlRows2:
000027E4 3014                       		move.w	(a4),d0				; Get high VDP command
000027E6 6700 0000                  		beq.w	.End				; If it's 0, branch
000027EA 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
000027EC                            		
000027EC                            		; --- DRAW THE FIRST HALF OF THE ROW ---
000027EC                            
000027EC 3200                       		move.w	d0,d1				; Save high VDP command
000027EE 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
000027F0 7C00                       		moveq	#0,d6
000027F2 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000027F6 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027F8                            
000027F8 3C80                       		move.w	d0,(a6)				; Set VDP command
000027FA 3C84                       		move.w	d4,(a6)				; ''
000027FC 6000                       		bra.s	.DrawRow1_1_Start		; Start
000027FE                            
000027FE                            .DrawRow1_1_Loop:
000027FE 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002800                            
00002800                            .DrawRow1_1_Start:
00002800 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002804                            
00002804 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002806 0642 0F00                  		addi.w	#$F00,d2			; ''
0000280A C042                       		and.w	d2,d0				; ''
0000280C                            
0000280C 3C80                       		move.w	d0,(a6)				; Set VDP command
0000280E 3C84                       		move.w	d4,(a6)				; ''
00002810                            
00002810                            .DrawRow1_2_Loop:
00002810 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002812 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
00002816                            
00002816                            		; --- DRAW THE SECOND HALF OF THE ROW ---
00002816                            
00002816 0641 0080                  		addi.w	#$80,d1				; Move over down
0000281A 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
0000281C 7C00                       		moveq	#0,d6
0000281E 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002822 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002824                            
00002824 3C81                       		move.w	d1,(a6)				; Set VDP command
00002826 3C84                       		move.w	d4,(a6)				; ''
00002828 6000                       		bra.s	.DrawRow2_1_Start		; Start
0000282A                            
0000282A                            .DrawRow2_1_Loop:
0000282A 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
0000282C                            
0000282C                            .DrawRow2_1_Start:
0000282C 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002830                            
00002830 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002832 0642 0F80                  		addi.w	#$F80,d2			; ''
00002836 C242                       		and.w	d2,d1				; ''
00002838                            
00002838 3C81                       		move.w	d1,(a6)				; Set VDP command
0000283A 3C84                       		move.w	d4,(a6)				; ''
0000283C                            
0000283C                            .DrawRow2_2_Loop:
0000283C 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
0000283E 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002842                            
00002842                            .End:
00002842 4E75                       		rts
00002844                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002844                            ; Handle plane drawing
00002844                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002844                            ; PARAMETERS:
00002844                            ;	d4.w	- Number of blocks per column
00002844                            ;	d5.w	- Number of blocks per row
00002844                            ;	a1.l	- Camera variables
00002844                            ;	a2.l	- Layout pointer
00002844                            ;	a3.l	- Column plane buffer
00002844                            ;	a4.l	- Row plane buffer
00002844                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002844                            ; RETURNS:
00002844                            ;	Nothing
00002844                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002844                            Level_UpdatePlane:
00002844                            		push.l	d5/a4				; Push row plane buffer address
00002844 48E7 0408                M 	movem.l	d5/a4,-(sp)
00002848 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
0000284A                            		pop.l	d5/a4				; Restore row plane buffer address
0000284A 4CDF 1020                M 	movem.l	(sp)+,d5/a4
0000284E 3805                       		move.w	d5,d4				; Number of blocks per column
00002850                            		; Continue to update the plane vertically
00002850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002850                            ; Handle plane drawing (vertical redrawing only)
00002850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002850                            ; PARAMETERS:
00002850                            ;	d4.w	- Number of blocks per row
00002850                            ;	a1.l	- Camera variables
00002850                            ;	a4.l	- Row plane buffer
00002850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002850                            ; RETURNS:
00002850                            ;	Nothing
00002850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002850                            Level_UpdatePlaneY:
00002850 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002854 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002858 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
0000285C 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002860                            		
00002860 9240                       		sub.w	d0,d1				; Get distance travelled
00002862 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002864 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002866                            		
00002866                            .DrawUp:
00002866 3011                       		move.w	cXPos(a1),d0			; Get X
00002868 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
0000286C 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002870                            
00002870                            .DrawDown:
00002870 3011                       		move.w	cXPos(a1),d0			; Get X
00002872 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002876 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
0000287A 6000 0000                  		bra.w	Level_GetRow			; Draw a row
0000287E                            
0000287E                            .End:
0000287E 4E75                       		rts
00002880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002880                            ; Handle plane drawing (horizontal redrawing only)
00002880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002880                            ; PARAMETERS:
00002880                            ;	d4.w	- Number of blocks per column
00002880                            ;	a1.l	- Camera variables
00002880                            ;	a3.l	- Column plane buffer
00002880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002880                            ; RETURNS:
00002880                            ;	Nothing
00002880                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002880                            Level_UpdatePlaneX:
00002880 3011                       		move.w	cXPos(a1),d0			; Get X
00002882 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002886 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
0000288A 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
0000288E                            		
0000288E 9240                       		sub.w	d0,d1				; Get distance travelled
00002890 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002892 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002894                            		
00002894                            .DrawLeft:
00002894 3011                       		move.w	cXPos(a1),d0			; Get X
00002896 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
0000289A 6000 0000                  		bra.w	Level_GetCol			; Draw a column
0000289E                            		
0000289E                            .DrawRight:
0000289E 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
000028A2 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
000028A6 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
000028AA 6000 0000                  		bra.w	Level_GetCol			; Draw a column
000028AE                            
000028AE                            .End:
000028AE 4E75                       		rts
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; Macro to calculate the high VDP command word for the plane buffer
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; PARAMETERS:
000028B0                            ;	a1.l	- Camera variables
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; RETURNS:
000028B0                            ;	d2.w	- The high VDP command word
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            calcHiVDP	macro
000028B0                            		move.w	d0,d2				; Copy X
000028B0                            		move.w	d1,d3				; Copy Y
000028B0                            		lsl.w	#4,d3				; Multiply Y by $10
000028B0                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000028B0                            		lsr.w	#2,d2				; Divide X by 4
000028B0                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000028B0                            		add.w	d3,d2				; Add Y onto X
000028B0                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
000028B0                            		endm
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; Macro to get an address in chunk data relative to a position
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; PARAMETERS:
000028B0                            ;	d1.l	- $FFFFXXXX
000028B0                            ;	a2.l	- Layout data
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; RETURNS:
000028B0                            ;	a6.l	- Pointer in chunk data to the correct block
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            getChunk	macro
000028B0                            		move.b	(a2,d0.w),d1			; Get chunk ID
000028B0                            		andi.w	#$FF,d1				; ''
000028B0                            		lsl.w	#7,d1				; Turn into offset
000028B0                            		movea.l	d1,a6				; Store into a6
000028B0                            		endm
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; Get a block row and store it in a plane buffer
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; PARAMETERS:
000028B0                            ;	d0.w	- X position
000028B0                            ;	d1.w	- Y position
000028B0                            ;	d4.w	- Number of blocks to draw (minus 1)
000028B0                            ;	a1.l	- Camera variables
000028B0                            ;	a4.l	- Row plane buffer
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            ; RETURNS:
000028B0                            ;	Nothing
000028B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028B0                            Level_GetRow:
000028B0 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
000028B4 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
000028B8 47F8 C7D0                  		lea	rBlocks.w,a3			; Get block table address
000028BC 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
000028C0                            
000028C0                            		calcHiVDP				; Get high VDP command word
000028C0 3400                     M 	move.w	d0,d2
000028C2 3601                     M 	move.w	d1,d3
000028C4 E94B                     M 	lsl.w	#4,d3
000028C6 0243 0F00                M 	andi.w	#$f00,d3
000028CA E44A                     M 	lsr.w	#2,d2
000028CC 0242 007C                M 	andi.w	#$7c,d2
000028D0 D443                     M 	add.w	d3,d2
000028D2 8469 0012                M 	or.w	cvdp(a1),d2
000028D6 38C2                       		move.w	d2,(a4)+			; Store it
000028D8                            
000028D8 3400                       		move.w	d0,d2				; Get X
000028DA E44A                       		lsr.w	#2,d2				; Divide X by 4
000028DC 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000028E0 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
000028E4 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
000028E6 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
000028EA E44D                       		lsr.w	#2,d5				; Divide by 4
000028EC 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
000028F0                            		
000028F0 E648                       		lsr.w	#3,d0				; Get X within chunk data
000028F2 3400                       		move.w	d0,d2				; ''
000028F4 0242 000E                  		andi.w	#$E,d2				; ''
000028F8 E848                       		lsr.w	#4,d0				; Get X within layout data
000028FA 0240 007F                  		andi.w	#$7F,d0				;''
000028FE 3601                       		move.w	d1,d3				; Get Y within chunk data
00002900 0243 0070                  		andi.w	#$70,d3				; ''
00002904 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
00002906                            
00002906 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
0000290A D241                       		add.w	d1,d1				; ''
0000290C D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
0000290E                            
0000290E 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002910                            		getChunk				; Get chunk pointer at current location
00002910 1232 0000                M 	move.b	(a2,d0.w),d1
00002914 0241 00FF                M 	andi.w	#$ff,d1
00002918 EF49                     M 	lsl.w	#7,d1
0000291A 2C41                     M 	movea.l	d1,a6
0000291C                            
0000291C                            .DrawBlock_Loop:
0000291C 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002920 3C05                       		move.w	d5,d6				; ''
00002922 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002926 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002928                            		
00002928 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
0000292C 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002930                            
00002930 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002934 6700                       		beq.s	.ChkYFlip			; If not, branch
00002936 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
0000293C 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002942 4847                       		swap	d7				; ''
00002944 4845                       		swap	d5				; ''
00002946                            
00002946                            .ChkYFlip:
00002946 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
0000294A 6700                       		beq.s	.DrawBlock			; If not, branch
0000294C 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002952 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002958 CB47                       		exg.l	d7,d5				; ''
0000295A                            
0000295A                            .DrawBlock:
0000295A 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
0000295C 2AC5                       		move.l	d5,(a5)+			; ''
0000295E                            
0000295E 5442                       		addq.w	#2,d2				; Go to the next block
00002960 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002964 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002966 5240                       		addq.w	#1,d0				; Next chunk
00002968                            		getChunk				; ''
00002968 1232 0000                M 	move.b	(a2,d0.w),d1
0000296C 0241 00FF                M 	andi.w	#$ff,d1
00002970 EF49                     M 	lsl.w	#7,d1
00002972 2C41                     M 	movea.l	d1,a6
00002974                            
00002974                            .DrawBlock_Cont:
00002974 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002976 51CC FFA4                  		dbf	d4,.DrawBlock_Loop		; Loop
0000297A                            
0000297A 4E75                       		rts
0000297C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000297C                            ; Get a block column and store it in a plane buffer
0000297C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000297C                            ; PARAMETERS:
0000297C                            ;	d0.w	- X position
0000297C                            ;	d1.w	- Y position
0000297C                            ;	d4.w	- Number of blocks to draw (minus 1)
0000297C                            ;	a1.l	- Camera RAM
0000297C                            ;	a3.l	- Column plane buffer
0000297C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000297C                            ; RETURNS:
0000297C                            ;	Nothing
0000297C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000297C                            Level_GetCol:
0000297C 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002980 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002984 49F8 C7D0                  		lea	rBlocks.w,a4			; Get block table address
00002988 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
0000298C                            		
0000298C                            		calcHiVDP				; Get high VDP command word
0000298C 3400                     M 	move.w	d0,d2
0000298E 3601                     M 	move.w	d1,d3
00002990 E94B                     M 	lsl.w	#4,d3
00002992 0243 0F00                M 	andi.w	#$f00,d3
00002996 E44A                     M 	lsr.w	#2,d2
00002998 0242 007C                M 	andi.w	#$7c,d2
0000299C D443                     M 	add.w	d3,d2
0000299E 8469 0012                M 	or.w	cvdp(a1),d2
000029A2 36C2                       		move.w	d2,(a3)+			; Store it
000029A4                            
000029A4 3601                       		move.w	d1,d3				; Get Y
000029A6 E94B                       		lsl.w	#4,d3				; Multiply by $10
000029A8 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000029AC 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
000029B0 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
000029B2 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
000029B6 E04D                       		lsr.w	#8,d5				; Divide by $100
000029B8 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
000029BC                            
000029BC E648                       		lsr.w	#3,d0				; Get X within chunk data
000029BE 3400                       		move.w	d0,d2				; ''
000029C0 0242 000E                  		andi.w	#$E,d2				; ''
000029C4 E848                       		lsr.w	#4,d0				; Get X within layout data
000029C6 0240 007F                  		andi.w	#$7F,d0				;''
000029CA 3601                       		move.w	d1,d3				; Get Y within chunk data
000029CC 0243 0070                  		andi.w	#$70,d3				; ''
000029D0 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
000029D2                            
000029D2 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029D6 D241                       		add.w	d1,d1				; ''
000029D8 D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
000029DA                            
000029DA 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
000029DC                            		getChunk				; Get chunk pointer at current location
000029DC 1232 0000                M 	move.b	(a2,d0.w),d1
000029E0 0241 00FF                M 	andi.w	#$ff,d1
000029E4 EF49                     M 	lsl.w	#7,d1
000029E6 2C41                     M 	movea.l	d1,a6
000029E8                            
000029E8                            .DrawBlock_Loop:
000029E8 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
000029EC 3C05                       		move.w	d5,d6				; ''
000029EE 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
000029F2 E74D                       		lsl.w	#3,d5				; Get offset in block data
000029F4                            		
000029F4 3E05                       		move.w	d5,d7				; Get block tiles
000029F6 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
000029FA 3A07                       		move.w	d7,d5				; ''
000029FC 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002A00 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002A04 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002A08                            
00002A08 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002A0C 6700                       		beq.s	.ChkYFlip			; If not, branch
00002A0E 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002A14 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002A1A CB47                       		exg.l	d7,d5				; ''
00002A1C                            
00002A1C                            .ChkYFlip:
00002A1C 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002A20 6700                       		beq.s	.DrawBlock			; If not, branch
00002A22 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A28 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A2E 4847                       		swap	d7				; ''
00002A30 4845                       		swap	d5				; ''
00002A32                            
00002A32                            .DrawBlock:
00002A32 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002A34 2AC5                       		move.l	d5,(a5)+			; ''
00002A36                            
00002A36 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002A3A 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002A3E 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A40 0640 0100                  		addi.w	#$100,d0			; Next chunk
00002A44                            		getChunk				; ''
00002A44 1232 0000                M 	move.b	(a2,d0.w),d1
00002A48 0241 00FF                M 	andi.w	#$ff,d1
00002A4C EF49                     M 	lsl.w	#7,d1
00002A4E 2C41                     M 	movea.l	d1,a6
00002A50                            
00002A50                            .DrawBlock_Cont:
00002A50 D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002A52 51CC FF94                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A56                            
00002A56 4E75                       		rts
00002A58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A58                            ; Refresh a plane
00002A58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A58                            ; PARAMETERS:
00002A58                            ;	a1.l	- Camera variables
00002A58                            ;	a4.l	- Row plane buffer
00002A58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A58                            ; RETURNS:
00002A58                            ;	Nothing
00002A58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A58                            Level_RefreshPlane:
00002A58 3011                       		move.w	cXPos(a1),d0			; Get X position
00002A5A 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002A5E 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002A62 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002A66                            		
00002A66 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002A6A 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002A6E 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002A72 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002A76                            		
00002A76 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002A78 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002A7A                            		
00002A7A                            		push.l	a4				; Save plane buffer address
00002A7A 2F0C                     M 	move.l	a4,-(sp)
00002A7C                            		
00002A7C                            .DrawRows:
00002A7C                            		push.w	d0/d1/d4/d6			; Save registers
00002A7C 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002A80 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002A84 6100 FE2A                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002A88 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002A8C 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002A92 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002A96 6100 FD44                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002A9A                            		pop.w	d0/d1/d4/d6			; Restore registers
00002A9A 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002A9E                            		
00002A9E 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002AA2 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002AA6                            		
00002AA6                            		pop.l	a4				; Restore a3
00002AA6 285F                     M 	move.l	(sp)+,a4
00002AA8 4E75                       		rts
00002AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AAA                            ; Check if the plane needs to be redrawn
00002AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AAA                            ; PARAMETERS:
00002AAA                            ;	a1.l	- Camera RAM
00002AAA                            ;	a3.l	- Row plane buffer
00002AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AAA                            ; RETURNS:
00002AAA                            ;	Nothing
00002AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AAA                            Level_ChkRedrawPlane:
00002AAA 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002AAE                            		; Comment out the following line to disable blast processing :^)
00002AAE 6700                       		beq.s	.End				; If not, branch
00002AB0 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002AB4 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002AB6                            
00002AB6                            .End:
00002AB6 4E75                       		rts
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            ; Scroll sections macro
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            scrollInit	macro	label
00002AB8                            SCROLL_LABEL	equs	"\label"
00002AB8                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002AB8                            		endm
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            scrollEnd	macro
00002AB8                            \SCROLL_LABEL\_End:					; End label
00002AB8                            		endm
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            scrollSection	macro
00002AB8                            	if narg<3
00002AB8                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002AB8                            	else
00002AB8                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002AB8                            	endif
00002AB8                            		endm
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            ; Do section scrolling
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            ; PARAMERERS:
00002AB8                            ;	a1.l	- Background camera RAM
00002AB8                            ;	a3.l	- Scroll section data
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            ; RETURNS:
00002AB8                            ;	Nothing
00002AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AB8                            ScrollSections:
00002AB8 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing variables
00002ABC 49F8 EFD0                  		lea	rScrlSecs.w,a4		; Deformation offset buffer
00002AC0 4BF8 90FE                  		lea	rHScroll.w,a5			; Horizontal scroll buffer
00002AC4                            
00002AC4 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002AC6                            
00002AC6 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002AC8 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002ACC 48C4                       		ext.l	d4				; ''
00002ACE E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002AD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AD0                            		; Update each section offset
00002AD0                            		push.w	d0/a4				; Save registers
00002AD0 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002AD4                            
00002AD4                            .ScrollSects:
00002AD4 361B                       		move.w	(a3)+,d3			; Get section speed
00002AD6 48C3                       		ext.l	d3				; ''
00002AD8                            
00002AD8 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002ADA 6A00                       		bpl.s	.NotAuto			; If not, branch
00002ADC 3C04                       		move.w	d4,d6				; Get camera speed
00002ADE CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002AE0 E183                       		asl.l	#8,d3				; Shift section speed
00002AE2 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002AE4 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002AE6                            
00002AE6                            .NotAuto:
00002AE6 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002AE8                            
00002AE8                            .ApplySpeed:
00002AE8 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002AEA 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002AEC 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002AF0                            
00002AF0                            		pop.w	d0/a4				; Restore registers
00002AF0 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002AF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AF4                            		; Set the scroll offsets on screen
00002AF4 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002AF8 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002AFC                            		
00002AFC                            .FindStart:
00002AFC 221C                       		move.l	(a4)+,d1			; Get section offset
00002AFE 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002B00 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002B02 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002B06 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B08 4441                       		neg.w	d1				; Make it scroll the right direction
00002B0A 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B0C 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B0E 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002B10                            
00002B10                            .FoundStart:
00002B10 4446                       		neg.w	d6				; Get remaining size of the section
00002B12 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B14 4441                       		neg.w	d1				; Make it scroll the right direction
00002B16 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B18 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B1A 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002B1C                            
00002B1C                            .NextSection:
00002B1C 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002B1E 4441                       		neg.w	d1				; Make the section scroll the correct way
00002B20 2C1C                       		move.l	(a4)+,d6			; Get section size
00002B22                            		
00002B22                            .CheckScroll:
00002B22 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002B24 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002B26 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002B28                            
00002B28                            .Scroll:
00002B28 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002B2A 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002B2E 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002B32 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002B34                            		
00002B34                            .EndSection:
00002B34 DA46                       		add.w	d6,d5				; Get remaining screen space
00002B36                            		
00002B36                            .LastSection:
00002B36 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002B38 6B00                       		bmi.s	.End				; If there are none, exit
00002B3A                            
00002B3A                            .FillScroll:
00002B3A 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002B3C 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002B40                            
00002B40                            .End:
00002B40 4E75                       		rts
00002B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B42                            ; Static background scrolling (no parallax)
00002B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B42                            ; PARAMERERS:
00002B42                            ;	a1.l	- Background camera RAM
00002B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B42                            ; RETURNS:
00002B42                            ;	Nothing
00002B42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B42                            ScrollStaticBG:
00002B42 45F8 F880                  		lea	rFGCam.w,a2		; Get foreground level drawing variables
00002B46 4BF8 90FE                  		lea	rHScroll.w,a5		; Horizontal scroll buffer
00002B4A                            		
00002B4A 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002B4C 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002B4E 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002B50 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002B52                            
00002B52 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002B56                            
00002B56                            .Scroll:
00002B56 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002B58 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002B5C 4E75                       		rts
00002B5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5E                            ; Generate fake layer art
00002B5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5E                            ; PARAMETERS:
00002B5E                            ;	a0.l	- Layer art data pointer
00002B5E                            ;	a1.l	- Layer tile ID mappings pointer
00002B5E                            ;	d0.w	- Layer offset
00002B5E                            ;	d1.l	- Buffer pointer
00002B5E                            ;	d2.w	- VRAM destination address
00002B5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5E                            Level_UpdateLayer:
00002B5E                            		; Prepare for transfer
00002B5E 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002B60 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002B62                            		
00002B62                            		; Queue a DMA transfer for later
00002B62                            		push.l	d0/d3/a1			; Save registers
00002B62 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002B66 5243                       		addq.w	#1,d3				; Get size of transfer
00002B68 E94B                       		lsl.w	#4,d3				; ''
00002B6A 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002B6E                            		pop.l	d0/d3/a1			; Restore registers
00002B6E 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002B72                            
00002B72                            		; Copy the tiles for the layer
00002B72 D040                       		add.w	d0,d0				; Double it
00002B74 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002B78                            		
00002B78                            .CopyTiles:
00002B78 3219                       		move.w	(a1)+,d1			; Get tile offset
00002B7A 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002B7E 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002B80 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B82 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B84 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B86 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B88 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B8A 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B8C 24DB                       		move.l	(a3)+,(a2)+			; ''
00002B8E 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002B92                            
00002B92                            .End
00002B92 4E75                       		rts
00002B94                            ; =========================================================================================================================================================
00002B94                            		include	"Level/Level Collision.asm"
00002B94                            ; =========================================================================================================================================================
00002B94                            ; Mighty The Armadillo in PRISM PARADISE
00002B94                            ; By Nat The Porcupine 2021
00002B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B94                            ; Level collision functions
00002B94                            ; =========================================================================================================================================================
00002B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B94                            ; Check if a player object has touched any level collision
00002B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B94                            PlayerChkCollision:
00002B94 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002B9A 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002BA0 6700                       		beq.s	.NotPrimary			; If not, branch
00002BA2 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002BA8                            
00002BA8                            .NotPrimary:
00002BA8 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002BAC                            		
00002BAC 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002BB0 3428 001E                  		move.w	oYVel(a0),d2			; Get Y velocity
00002BB4 4EB8 1706                  		jsr	CalcArcTan.w			; Get the angle
00002BB8 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002BBC 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002BC0 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002BC4 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002BC8 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002BCC 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002BD0 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002BD4 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002BD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BD8                            PlayerHitFloorAndWalls:
00002BD8 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002BDC 4A41                       		tst.w	d1				; Have we hit the wall?
00002BDE 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002BE0 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002BE4 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002BE8                            
00002BE8                            .NoLeftHit:
00002BE8 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002BEC 4A41                       		tst.w	d1				; Have we hit the wall?
00002BEE 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002BF0 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002BF4 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002BF8                            
00002BF8                            .NoRightHit:
00002BF8 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002BFC 4A41                       		tst.w	d1				; Have we hit the floor?
00002BFE 6A00                       		bpl.s	.End				; If not, branch
00002C00                            
00002C00 1428 001E                  		move.b	oYVel(a0),d2			; Get the integer part of the Y velocity
00002C04 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002C06 4402                       		neg.b	d2				; Negate it since we are in the floor
00002C08 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002C0A 6C00                       		bge.s	.TouchFloor			; If so, branch
00002C0C B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002C0E 6D00                       		blt.s	.End				; If not, branch
00002C10                            
00002C10                            .TouchFloor:
00002C10 1143 0000                  		move.b	d3,oAngle(a0)			; Set the angle
00002C14 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the floor
00002C18 1003                       		move.b	d3,d0				; Copy angle
00002C1A 0600 0020                  		addi.b	#$20,d0				; Shift it
00002C1E 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002C22 6600                       		bne.s	.HitWall			; If so, branch
00002C24 1003                       		move.b	d3,d0				; Copy angle
00002C26 0600 0010                  		addi.b	#$10,d0				; Shift it
00002C2A 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002C2E 6700                       		beq.s	.HitFloor			; If not, branch
00002C30 E0E8 001E                  		asr	oYVel(a0)			; Divide the Y velocity by 2
00002C34 6000                       		bra.s	.HitSlope			; Continue
00002C36                            
00002C36                            .HitFloor:
00002C36 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002C3A 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002C40 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002C44                            
00002C44                            .HitWall:
00002C44 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
00002C48 0C68 0FC0 001E             		cmpi.w	#$FC0,oYVel(a0)			; Cap the Y velocity at $FC0
00002C4E 6F00                       		ble.s	.HitSlope			; ''
00002C50 317C 0FC0 001E             		move.w	#$FC0,oYVel(a0)			; ''
00002C56                            
00002C56                            .HitSlope:
00002C56 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002C5A 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002C60 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002C62 6A00                       		bpl.s	.End				; If so, branch
00002C64 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002C68                            
00002C68                            .End:
00002C68 4E75                       		rts
00002C6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C6A                            PlayerHitLWall:
00002C6A 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C6E 4A41                       		tst.w	d1				; Have we hit the wall?
00002C70 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002C72 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C76 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C7A 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002C80                            
00002C80                            .ChkCeil:
00002C80 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002C84 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002C86 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002C88 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002C8A 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002C8E 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002C90 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002C94 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002C98 6A00                       		bpl.s	.End				; If not, branch
00002C9A 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002C9E                            
00002C9E                            .End:
00002C9E 4E75                       		rts
00002CA0                            
00002CA0                            .ChkRightWall:
00002CA0 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002CA4 4A41                       		tst.w	d1				; Have we hit the wall?
00002CA6 6A00                       		bpl.s	.End2				; If not, branch
00002CA8 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CAC 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CB0                            		
00002CB0                            .End2:
00002CB0 4E75                       		rts
00002CB2                            
00002CB2                            .ChkFloor:
00002CB2 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002CB6 6B00                       		bmi.s	.End3				; If so, branch
00002CB8 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002CBC 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002CBE 6A00                       		bpl.s	.End3				; If not, branch
00002CC0 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002CC4 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002CC8 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CCC 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002CD2 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002CD6                            		
00002CD6                            .End3:
00002CD6 4E75                       		rts
00002CD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CD8                            PlayerHitCeilAndWalls:
00002CD8 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002CDC 4A41                       		tst.w	d1				; Have we hit the wall?
00002CDE 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002CE0 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002CE4 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CE8                            
00002CE8                            .NoLeftHit:
00002CE8 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002CEC 4A41                       		tst.w	d1				; Have we hit the wall?
00002CEE 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002CF0 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CF4 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CF8                            
00002CF8                            .NoRightHit:
00002CF8 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002CFC 4A41                       		tst.w	d1				; Have we hit the floor?
00002CFE 6A00                       		bpl.s	.End				; If not, branch
00002D00 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of ceiling
00002D04 1003                       		move.b	d3,d0				; Get angle
00002D06 0600 0020                  		addi.b	#$20,d0				; Shift it
00002D0A 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002D0E 6600                       		bne.s	.HitWall			; If so, branch
00002D10 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D14 4E75                       		rts
00002D16                            
00002D16                            .HitWall:
00002D16 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D1A 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D1E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D24 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D26 6A00                       		bpl.s	.End				; If so, branch
00002D28 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002D2C                            
00002D2C                            .End:
00002D2C 4E75                       		rts
00002D2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D2E                            PlayerHitRWall:
00002D2E 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D32 4A41                       		tst.w	d1				; Have we hit the wall?
00002D34 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D36 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D3A 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D3E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D44                            
00002D44                            .ChkCeil:
00002D44 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D48 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D4A 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D4C 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of the ceiling
00002D50 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D54 6A00                       		bpl.s	.End				; If not, branch
00002D56 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D5A                            
00002D5A                            .End:
00002D5A 4E75                       		rts
00002D5C                            
00002D5C                            .ChkFloor:
00002D5C 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D60 6B00                       		bmi.s	.End2				; If so, branch
00002D62 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D66 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D68 6A00                       		bpl.s	.End2				; If not, branch
00002D6A D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D6E 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D72 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D76 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002D7C 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002D7E                            		
00002D7E                            .End2:
00002D7E 4E75                       		rts
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            ; Reset a player object's status on the floor
00002D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D80                            PlayerResetOnFloor:
00002D80 4A28 0000                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00002D84 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002D86 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002D8A                            		
00002D8A                            PlayerResetOnFloorPart2:
00002D8A 0828 0002 0028             		btst	#2,oStatus(a0)			; Was Sonic rolling?
00002D90 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002D92 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
00002D98 1168 0000 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00002D9E 1168 0000 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00002DA4 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002DA8 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align with floor
00002DAC                            
00002DAC                            PlayerResetOnFloorPart3:
00002DAC 0228 00DD 0028             		andi.b	#$DD,oStatus(a0)		; Clear "pushing", and "jumping" flag
00002DB2 4228 0000                  		clr.b	oJumping(a0)			; Clear jumping flag
00002DB6 4228 0000                  		clr.b	oFlipAngle(a0)			; Reset flip angle
00002DBA 4228 0000                  		clr.b	oFlipTurned(a0)			; Reset flip inverted flag
00002DBE 4228 0000                  		clr.b	oFlipRemain(a0)			; Reset flips remaining
00002DC2 4E75                       		rts
00002DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DC4                            ; Calculate the room in front of a player object
00002DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DC4                            PlayerCalcRoomInFront:
00002DC4 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002DCA 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002DD0 6700                       		beq.s	.NotPrimary			; If not, branch
00002DD2 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002DD8                            
00002DD8                            .NotPrimary:
00002DD8 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002DDC                            		
00002DDC 2628 0014                  		move.l	oXPos(a0),d3			; Get X position
00002DE0 2428 0018                  		move.l	oYPos(a0),d2			; Get Y position
00002DE4 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002DE8 48C1                       		ext.l	d1				; ''
00002DEA E181                       		asl.l	#8,d1				; Shift it
00002DEC D681                       		add.l	d1,d3				; Add onto X position
00002DEE 3228 001E                  		move.w	oYVel(a0),d1			; Get Y velocity
00002DF2 48C1                       		ext.l	d1				; ''
00002DF4 E181                       		asl.l	#8,d1				; Shift it
00002DF6 D481                       		add.l	d1,d2				; Add onto Y position
00002DF8 4842                       		swap	d2				; Get actual Y
00002DFA 4843                       		swap	d3				; Get actual X
00002DFC 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E00 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E04 1200                       		move.b	d0,d1				; Copy angle
00002E06 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002E0A 6700                       		beq.s	.DownUp				; If not, branch
00002E0C 5200                       		addq.b	#1,d0				; Shift the angle
00002E0E                            
00002E0E                            .DownUp:
00002E0E 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002E12 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E16 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002E1A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E1E 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002E22 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002E26 6600                       		bne.s	.ChkWall			; If not, branch
00002E28 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002E2A                            
00002E2A                            .ChkWall:
00002E2A 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E2E 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002E32 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E36                            ; Calculate the room over a player object
00002E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E36                            PlayerCalcRoomOverHead:
00002E36 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E3C 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E42 6700                       		beq.s	.NotPrimary			; If not, branch
00002E44 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E4A                            
00002E4A                            .NotPrimary:
00002E4A 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E4E 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E52 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E56                            		
00002E56 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002E5A 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E5E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E62 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002E66 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E6A 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002E6E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002E72 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002E76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E76                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002E76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E76                            PlayerChkFloor:
00002E76 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E7C 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E82 6700                       		beq.s	.NotPrimary			; If not, branch
00002E84 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E8A                            
00002E8A                            .NotPrimary:
00002E8A 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00002E8E                            		
00002E8E                            		; Get the angle on the bottom right sensor
00002E8E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002E92 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002E96 7000                       		moveq	#0,d0
00002E98 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002E9C 4880                       		ext.w	d0				; ''
00002E9E D440                       		add.w	d0,d2				; Add onto Y position
00002EA0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002EA4 4880                       		ext.w	d0				; ''
00002EA6 D640                       		add.w	d0,d3				; Add onto X position
00002EA8 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002EAC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002EB0 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002EB2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002EB6                            		push.w	d1				; Save the primary floor distance
00002EB6 3F01                     M 	move.w	d1,-(sp)
00002EB8                            
00002EB8                            		; Get the angle on the bottom left sensor
00002EB8 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002EBC 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002EC0 7000                       		moveq	#0,d0
00002EC2 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002EC6 4880                       		ext.w	d0				; ''
00002EC8 D440                       		add.w	d0,d2				; Add onto Y position
00002ECA 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002ECE 4880                       		ext.w	d0				; ''
00002ED0 9640                       		sub.w	d0,d3				; Subtract from X position
00002ED2 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00002ED6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002EDA 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002EDC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002EE0                            		
00002EE0                            		; Update the object's angle
00002EE0                            		pop.w	d0				; Restore the primary floor distance
00002EE0 301F                     M 	move.w	(sp)+,d0
00002EE2 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE4                            PlayerPickAngle:
00002EE4 1628 002F                  		move.b	oTilt(a0),d3			; Get secondary angle
00002EE8 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002EEA 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002EEC 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002EF0 C141                       		exg.l	d0,d1				; Switch floor distance values
00002EF2                            		
00002EF2                            .ChkSetAngle:
00002EF2 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002EF6 6700                       		beq.s	.End				; If not, branch
00002EF8 1602                       		move.b	d2,d3				; Set the new angle value
00002EFA                            		
00002EFA                            .End:
00002EFA 4E75                       		rts
00002EFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EFC                            ; Get the distance between the floor and the player object
00002EFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EFC                            PlayerChkFloorDist:
00002EFC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F00 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F04                            
00002F04                            PlayerChkFloorDist_Part2:
00002F04 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00002F08 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F0C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F10 4246                       		clr.w	d6				; No flip bits
00002F12 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F16 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F18                            PlayerGetPrimaryAngle:
00002F18 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F1C 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002F20 6700                       		beq.s	.End				; If not, branch
00002F22 1602                       		move.b	d2,d3				; Set the new angle value
00002F24                            		
00002F24                            .End:
00002F24 4E75                       		rts
00002F26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F26                            sub_F846:
00002F26 3628 0014                  		move.w	oXPos(a0),d3
00002F2A 3428 0018                  		move.w	oYPos(a0),d2
00002F2E 5942                       		subq.w	#4,d2
00002F30 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F36 0C28 000D 0000             		cmpi.b	#$D,oLRBSolid(a0)		; Are we on the primary path?
00002F3C 6700                       		beq.s	.NotPrimary			; If not, branch
00002F3E 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F44                            
00002F44                            .NotPrimary:
00002F44 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F48 4214                       		clr.b	(a4)				; Clear it
00002F4A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F4E 4246                       		clr.w	d6				; No flip bits
00002F50 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Solidity bits
00002F54 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F58 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F5C 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002F60 6700                       		beq.s	.End				; If not, branch
00002F62 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002F64                            
00002F64                            .End:
00002F64 4E75                       		rts
00002F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F66                            ; Check for the edge of a floor
00002F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F66                            PlayerChkFloorEdge:
00002F66 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F6A                            
00002F6A                            PlayerChkFloorEdge_Part2:
00002F6A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F6E 7000                       		moveq	#0,d0
00002F70 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F74 4880                       		ext.w	d0				; ''
00002F76 D440                       		add.w	d0,d2				; Add onto Y position
00002F78                            
00002F78                            PlayerChkFloorEdge_Part3:
00002F78 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F7E 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002F84 6700                       		beq.s	.NotPrimary			; If not, branch
00002F86 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F8C                            
00002F8C                            .NotPrimary:
00002F8C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F90 4214                       		clr.b	(a4)				; Clear it
00002F92 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F96 4246                       		clr.w	d6				; No flip bits
00002F98 1A28 0000                  		move.b	oTopSolid(a0),d5		; Solidity bits
00002F9C 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FA0 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FA4 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FA8 6700                       		beq.s	.End				; If not, branch
00002FAA 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002FAC                            
00002FAC                            .End:
00002FAC 4E75                       		rts
00002FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAE                            ; Get the distance between the floor and an object
00002FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAE                            ObjCheckFloorDist:
00002FAE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FB2                            		
00002FB2                            ObjCheckFloorDist_Part2:
00002FB2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FB6                            
00002FB6                            ObjCheckFloorDist_Part3:
00002FB6 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002FBA 4880                       		ext.w	d0				; ''
00002FBC D440                       		add.w	d0,d2				; Add onto Y position
00002FBE 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FC2 4214                       		clr.b	(a4)				; Clear it
00002FC4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FC8 4246                       		clr.w	d6				; No flip bits
00002FCA 7A0C                       		moveq	#$C,d5				; Solidity bits
00002FCC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FD0 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FD4 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FD8 6700                       		beq.s	.End				; If not, branch
00002FDA 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002FDC                            
00002FDC                            .End:
00002FDC 4E75                       		rts
00002FDE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FDE                            ; Get the distance between a right ceiling and a player object
00002FDE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FDE                            PlayerChkRightCeilDist:
00002FDE                            		; Get the angle on the bottom right (rotated) sensor
00002FDE 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FE2 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FE6 7000                       		moveq	#0,d0
00002FE8 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
00002FEC 4880                       		ext.w	d0				; ''
00002FEE 9440                       		sub.w	d0,d2				; Subtract from Y position
00002FF0 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
00002FF4 4880                       		ext.w	d0				; ''
00002FF6 D640                       		add.w	d0,d3				; Add onto X position
00002FF8 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002FFC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003000 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003002 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003006                            		push.w	d1				; Save the primary floor distance
00003006 3F01                     M 	move.w	d1,-(sp)
00003008                            
00003008                            		; Get the angle on the bottom left (rotated) sensor
00003008 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000300C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003010 7000                       		moveq	#0,d0
00003012 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
00003016 4880                       		ext.w	d0				; ''
00003018 D440                       		add.w	d0,d2				; Add onto Y position
0000301A 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
0000301E 4880                       		ext.w	d0				; ''
00003020 D640                       		add.w	d0,d3				; Add onto X position
00003022 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003026 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000302A 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000302C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003030                            
00003030                            		; Update the object's angle
00003030                            		pop.w	d0				; Restore the primary floor distance
00003030 301F                     M 	move.w	(sp)+,d0
00003032 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003036 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
0000303A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000303A                            ; Get the distance between a right wall and a player object
0000303A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000303A                            PlayerChkRightWallDist:
0000303A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000303E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003042                            
00003042                            PlayerChkRightWallDist_Part2:
00003042 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
00003046 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000304A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000304E 4246                       		clr.w	d6				; No flip bits
00003050 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003054 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003058 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ; Get the distance between a right wall and an object
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ObjCheckRightWallDist:
0000305C D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003060 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003064 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003068 4214                       		clr.b	(a4)				; Clear it
0000306A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000306E 4246                       		clr.w	d6				; No flip bits
00003070 7A0D                       		moveq	#$D,d5				; Solidity bits
00003072 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003076 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
0000307A 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000307E 6700                       		beq.s	.End				; If not, branch
00003080 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
00003084                            
00003084                            .End:
00003084 4E75                       		rts
00003086                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003086                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
00003086                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003086                            PlayerChkCeiling:
00003086                            		; Get the angle on the bottom right sensor
00003086 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000308A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000308E 7000                       		moveq	#0,d0
00003090 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003094 4880                       		ext.w	d0				; ''
00003096 9440                       		sub.w	d0,d2				; Subtract from Y position
00003098 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000309C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030A0 4880                       		ext.w	d0				; ''
000030A2 D640                       		add.w	d0,d3				; Add onto X position
000030A4 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000030A8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000030AC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000030B0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030B4                            		push.w	d1				; Save the primary floor distance
000030B4 3F01                     M 	move.w	d1,-(sp)
000030B6                            
000030B6                            		; Get the angle on the bottom left sensor
000030B6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030BA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030BE 7000                       		moveq	#0,d0
000030C0 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000030C4 4880                       		ext.w	d0				; ''
000030C6 9440                       		sub.w	d0,d2				; Subtract from Y position
000030C8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030CC 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030D0 4880                       		ext.w	d0				; ''
000030D2 9640                       		sub.w	d0,d3				; Subtract from X position
000030D4 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000030D8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000030DC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000030E0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030E4                            		
000030E4                            		; Update the object's angle
000030E4                            		pop.w	d0				; Restore the primary floor distance
000030E4 301F                     M 	move.w	(sp)+,d0
000030E6 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
000030EA 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
000030EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030EE                            ; Get the distance between a ceiling and a player object
000030EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030EE                            PlayerChkCeilingDist:
000030EE 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030F2 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030F6                            
000030F6                            PlayerChkCeilingDist_Part2:
000030F6 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
000030FA 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030FE 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003102 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003106 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000310A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000310E 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003112 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003116                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003116                            ; Get the distance between a ceiling and an object
00003116                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003116                            ObjCheckCeilingDist:
00003116 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000311A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000311E 7000                       		moveq	#0,d0
00003120 1028 002D                  		move.b	oColH(a0),d0		; Get collision height
00003124 4880                       		ext.w	d0				; ''
00003126 9440                       		sub.w	d0,d2				; Subtract it from Y position
00003128 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000312C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003130 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003134 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003138 7A0D                       		moveq	#$D,d5				; Solidity bits
0000313A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000313E 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003142 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003146 6700                       		beq.s	.End				; If not, branch
00003148 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000314C                            
0000314C                            .End:
0000314C 4E75                       		rts
0000314E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000314E                            ; Get the distance between a left ceiling and a player object
0000314E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000314E                            PlayerChkLeftCeilDist:
0000314E                            		; Get the angle on the bottom right (rotated) sensor
0000314E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003152 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003156 7000                       		moveq	#0,d0
00003158 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000315C 4880                       		ext.w	d0				; ''
0000315E 9440                       		sub.w	d0,d2				; Subtract from Y position
00003160 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003164 4880                       		ext.w	d0				; ''
00003166 9640                       		sub.w	d0,d3				; Subtract from X position
00003168 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000316C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003170 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003174 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003178 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000317C                            		push.w	d1				; Save the primary floor distance
0000317C 3F01                     M 	move.w	d1,-(sp)
0000317E                            
0000317E                            		; Get the angle on the bottom left (rotated) sensor
0000317E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003182 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003186 7000                       		moveq	#0,d0
00003188 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000318C 4880                       		ext.w	d0				; ''
0000318E D440                       		add.w	d0,d2				; Add onto Y position
00003190 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003194 4880                       		ext.w	d0				; ''
00003196 9640                       		sub.w	d0,d3				; Subtract from X position
00003198 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000319C 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000031A0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031A4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031A8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031AC                            
000031AC                            		; Update the object's angle
000031AC                            		pop.w	d0				; Restore the primary floor distance
000031AC 301F                     M 	move.w	(sp)+,d0
000031AE 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031B2 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
000031B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031B6                            ; Get the distance between a left wall and a player object
000031B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031B6                            PlayerChkLeftWallDist:
000031B6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031BA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031BE                            
000031BE                            PlayerChkLeftWallDist_Part2:
000031BE 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
000031C2 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031C6 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031CA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031CE 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031D2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031D6 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031DA 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000031DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031DE                            ; Get the distance between a left wall and an object
000031DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031DE                            ObjCheckLeftWallDist:
000031DE D668 0014                  		add.w	oXPos(a0),d3			; Add X position
000031E2 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031E6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031EA 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031EE 4214                       		clr.b	(a4)				; Clear it
000031F0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031F4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031F8 7A0D                       		moveq	#$D,d5				; Solidity bits
000031FA 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031FE 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003202 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003206 6700                       		beq.s	.End				; If not, branch
00003208 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000320C                            
0000320C                            .End:
0000320C 4E75                       		rts
0000320E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000320E                            ; Move a player object along on the ground
0000320E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000320E                            PlayerAnglePos:
0000320E 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00003214 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
0000321A 6700                       		beq.s	.NotPrimary			; If not, branch
0000321C 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00003222                            
00003222                            .NotPrimary:
00003222 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00003226 0828 0003 0028             		btst	#3,oStatus(a0)			; Are we standing on a player object?
0000322C 6700                       		beq.s	.NotOnObj			; If not, branch
0000322E 4268 002E                  		clr.w	oNextTilt(a0)			; Set the angles to 0
00003232 4E75                       		rts
00003234                            
00003234                            .NotOnObj:
00003234 317C 0303 002E             		move.w	#$0303,oNextTilt(a0)		; Set the angles to 3
0000323A                            		
0000323A                            		; Get which quadrant the object is in on the ground
0000323A                            		; This makes it so that angles:
0000323A                            		; 	$E0-$20 = Quadrant 0 (floor)
0000323A                            		;	$1F-$5F = Quadrant $40 (left wall)
0000323A                            		;	$60-$A0 = Quadrant $80 (ceiling)
0000323A                            		;	$A1-$DF = Quadrant $C0 (right wall)
0000323A 1028 0000                  		move.b	oAngle(a0),d0			; Get the angle
0000323E 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003242 6700                       		beq.s	.DownUp				; If not, branch
00003244 5200                       		addq.b	#1,d0				; Shift the angle
00003246                            
00003246                            .DownUp:
00003246 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000324A 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
0000324E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003252 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
00003256 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
0000325A 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
0000325E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003262 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
00003266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003266                            ; Move the object along the floor
00003266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003266                            PlayerMoveFloor:
00003266                            		; Get the angle on the bottom right sensor
00003266 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000326A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000326E 7000                       		moveq	#0,d0
00003270 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003274 4880                       		ext.w	d0				; ''
00003276 D440                       		add.w	d0,d2				; Add onto Y position
00003278 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000327C 4880                       		ext.w	d0				; ''
0000327E D640                       		add.w	d0,d3				; Add onto X position
00003280 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003284 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003288 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000328A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000328E                            		push.w	d1				; Save the primary floor distance
0000328E 3F01                     M 	move.w	d1,-(sp)
00003290                            
00003290                            		; Get the angle on the bottom left sensor
00003290 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003294 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003298 7000                       		moveq	#0,d0
0000329A 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000329E 4880                       		ext.w	d0				; ''
000032A0 D440                       		add.w	d0,d2				; Add onto Y position
000032A2 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000032A6 4880                       		ext.w	d0				; ''
000032A8 9640                       		sub.w	d0,d3				; Add onto X position
000032AA 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000032AE 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000032B2 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000032B4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000032B8                            		
000032B8                            		; Update the object's angle
000032B8                            		pop.w	d0				; Restore the primary floor distance
000032B8 301F                     M 	move.w	(sp)+,d0
000032BA 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
000032BE                            		
000032BE                            		; Check if the object has hit a wall or is about to fall
000032BE 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000032C0 6700                       		beq.s	.End				; If so, branch
000032C2 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000032C4 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000032C8 6D00                       		blt.s	.End				; If so, branch
000032CA D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
000032CE                            
000032CE                            .End:
000032CE 4E75                       		rts
000032D0                            
000032D0                            .ChkFall:
000032D0 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
000032D4 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000032D6 4400                       		neg.b	d0				; Force it to be positive
000032D8                            
000032D8                            .GetMinDist:
000032D8 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000032DA 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000032DE 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000032E0 103C 000E                  		move.b	#$E,d0				; ''
000032E4                            
000032E4                            .ChkDist:
000032E4 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000032E6 6E00                       		bgt.s	.SetAir				; If so, branch
000032E8 D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
000032EC 4E75                       		rts
000032EE                            
000032EE                            .SetAir:
000032EE 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000032F4 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000032FA 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003300 4E75                       		rts
00003302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003302                            ; Set the objects's angle
00003302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003302                            PlayerSetAngle:
00003302 1428 002F                  		move.b	oTilt(a0),d2			; Get secondary angle
00003306 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00003308 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000330A 1428 002E                  		move.b	oNextTilt(a0),d2		; Get primary angle
0000330E 3200                       		move.w	d0,d1				; Get primary floor distance
00003310                            		
00003310                            .ChkSetAngle:
00003310 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
00003314 6600                       		bne.s	.LatchOnFlat			; If so, branch
00003316 1002                       		move.b	d2,d0				; Get angle change
00003318 9028 0000                  		sub.b	oAngle(a0),d0			; ''
0000331C 6A00                       		bpl.s	.ChkDist			; ''
0000331E 4400                       		neg.b	d0				; ''
00003320                            
00003320                            .ChkDist:
00003320 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
00003324 6400                       		bhs.s	.LatchOnFlat			; If so, branch
00003326 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
0000332A 4E75                       		rts
0000332C                            
0000332C                            .LatchOnFlat:
0000332C 1428 0000                  		move.b	oAngle(a0),d2			; Get old angle value
00003330 0602 0020                  		addi.b	#$20,d2				; Shift the angle
00003334 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
00003338 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
0000333C 4E75                       		rts
0000333E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000333E                            ; Move the object along the right wall
0000333E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000333E                            PlayerMoveRWall:
0000333E                            		; Get the angle on the bottom right (rotated) sensor
0000333E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003342 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003346 7000                       		moveq	#0,d0
00003348 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000334C 4880                       		ext.w	d0				; ''
0000334E 9440                       		sub.w	d0,d2				; Add onto Y position
00003350 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003354 4880                       		ext.w	d0				; ''
00003356 D640                       		add.w	d0,d3				; Add onto X position
00003358 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
0000335C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003360 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003362 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003366                            		push.w	d1				; Save the primary floor distance
00003366 3F01                     M 	move.w	d1,-(sp)
00003368                            
00003368                            		; Get the angle on the bottom left (rotated) sensor
00003368 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000336C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003370 7000                       		moveq	#0,d0
00003372 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003376 4880                       		ext.w	d0				; ''
00003378 D440                       		add.w	d0,d2				; Add onto Y position
0000337A 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000337E 4880                       		ext.w	d0				; ''
00003380 D640                       		add.w	d0,d3				; Add onto X position
00003382 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003386 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000338A 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000338C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003390                            		
00003390                            		; Update the object's angle
00003390                            		pop.w	d0				; Restore the primary floor distance
00003390 301F                     M 	move.w	(sp)+,d0
00003392 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003396                            
00003396                            		; Check if the object has hit a wall or is about to fall
00003396 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003398 6700                       		beq.s	.End				; If so, branch
0000339A 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000339C 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000033A0 6D00                       		blt.s	.End				; If so, branch
000033A2 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033A6                            
000033A6                            .End:
000033A6 4E75                       		rts
000033A8                            
000033A8                            .ChkFall:
000033A8 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000033AC 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000033AE 4400                       		neg.b	d0				; Force it to be positive
000033B0                            
000033B0                            .GetMinDist:
000033B0 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000033B2 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000033B6 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000033B8 103C 000E                  		move.b	#$E,d0				; ''
000033BC                            
000033BC                            .ChkDist:
000033BC B200                       		cmp.b	d0,d1				; Are we about to fall off?
000033BE 6E00                       		bgt.s	.SetAir				; If so, branch
000033C0 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033C4 4E75                       		rts
000033C6                            
000033C6                            .SetAir:
000033C6 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000033CC 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000033D2 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000033D8 4E75                       		rts
000033DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033DA                            ; Move the object along the ceiling
000033DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033DA                            PlayerMoveCeiling:
000033DA                            		; Get the angle on the bottom right (rotated) sensor
000033DA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000033DE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000033E2 7000                       		moveq	#0,d0
000033E4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000033E8 4880                       		ext.w	d0				; ''
000033EA 9440                       		sub.w	d0,d2				; Subtract from the Y position
000033EC 0A42 000F                  		eori.w	#$F,d2				; Flip it
000033F0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000033F4 4880                       		ext.w	d0				; ''
000033F6 D640                       		add.w	d0,d3				; Add onto X position
000033F8 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000033FC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003400 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003404 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003408                            		push.w	d1				; Save the primary floor distance
00003408 3F01                     M 	move.w	d1,-(sp)
0000340A                            
0000340A                            		; Get the angle on the bottom left (rotated) sensor
0000340A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000340E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003412 7000                       		moveq	#0,d0
00003414 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003418 4880                       		ext.w	d0				; ''
0000341A 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000341C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003420 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003424 4880                       		ext.w	d0				; ''
00003426 9640                       		sub.w	d0,d3				; Subtract from the X position
00003428 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000342C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003430 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003434 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003438                            		
00003438                            		; Update the object's angle
00003438                            		pop.w	d0				; Restore the primary floor distance
00003438 301F                     M 	move.w	(sp)+,d0
0000343A 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
0000343E                            		
0000343E                            		; Check if the object has hit a wall or is about to fall
0000343E 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003440 6700                       		beq.s	.End				; If so, branch
00003442 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003444 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003448 6D00                       		blt.s	.End				; If so, branch
0000344A 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
0000344E                            
0000344E                            .End:
0000344E 4E75                       		rts
00003450                            
00003450                            .ChkFall:
00003450 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003454 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003456 4400                       		neg.b	d0				; Force it to be positive
00003458                            
00003458                            .GetMinDist:
00003458 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
0000345A 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000345E 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003460 103C 000E                  		move.b	#$E,d0				; ''
00003464                            
00003464                            .ChkDist:
00003464 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003466 6E00                       		bgt.s	.SetAir				; If so, branch
00003468 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
0000346C 4E75                       		rts
0000346E                            
0000346E                            .SetAir:
0000346E 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003474 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000347A 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003480 4E75                       		rts
00003482                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003482                            ; Move the object along the left wall
00003482                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003482                            PlayerMoveLWall:
00003482                            		; Get the angle on the bottom right (rotated) sensor
00003482 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003486 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000348A 7000                       		moveq	#0,d0
0000348C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003490 4880                       		ext.w	d0				; ''
00003492 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003494 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003498 4880                       		ext.w	d0				; ''
0000349A 9640                       		sub.w	d0,d3				; Subtract from X position
0000349C 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034A0 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000034A4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034A8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000034AC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034B0                            		push.w	d1				; Save the primary floor distance
000034B0 3F01                     M 	move.w	d1,-(sp)
000034B2                            
000034B2                            		; Get the angle on the bottom left (rotated) sensor
000034B2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034B6 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034BA 7000                       		moveq	#0,d0
000034BC 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034C0 4880                       		ext.w	d0				; ''
000034C2 D440                       		add.w	d0,d2				; Add onto Y position
000034C4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034C8 4880                       		ext.w	d0				; ''
000034CA 9640                       		sub.w	d0,d3				; Subtract from X position
000034CC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034D0 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000034D4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034D8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000034DC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034E0                            		
000034E0                            		; Update the object's angle
000034E0                            		pop.w	d0				; Restore the primary floor distance
000034E0 301F                     M 	move.w	(sp)+,d0
000034E2 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
000034E6                            		
000034E6                            		; Check if the object has hit a wall or is about to fall
000034E6 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000034E8 6700                       		beq.s	.End				; If so, branch
000034EA 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000034EC 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000034F0 6D00                       		blt.s	.End				; If so, branch
000034F2 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
000034F6                            
000034F6                            .End:
000034F6 4E75                       		rts
000034F8                            
000034F8                            .ChkFall:
000034F8 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000034FC 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000034FE 4400                       		neg.b	d0				; Force it to be positive
00003500                            
00003500                            .GetMinDist:
00003500 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003502 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003506 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003508 103C 000E                  		move.b	#$E,d0				; ''
0000350C                            
0000350C                            .ChkDist:
0000350C B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000350E 6E00                       		bgt.s	.SetAir				; If so, branch
00003510 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
00003514 4E75                       		rts
00003516                            
00003516                            .SetAir:
00003516 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000351C 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003522 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003528 4E75                       		rts
0000352A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000352A                            ; Find the nearest floor from the object's position
0000352A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000352A                            ; PARAMETERS:
0000352A                            ;	d2.w	- Y position of the object's bottom sensor
0000352A                            ;	d3.w	- X position of the object's bottom sensor
0000352A                            ;	d5.w	- Bit to chect for solidity
0000352A                            ;	d6.w	- Flip bits (for walls and ceilings)
0000352A                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
0000352A                            ;	a4.w	- Pointer to where the angle value will be stored
0000352A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000352A                            ; RETURNS:
0000352A                            ;	d1.w	- The distance from the object to the floor
0000352A                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000352A                            ;	(a4).w	- The floor angle
0000352A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000352A                            Level_FindFloor:
0000352A 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000352E 3011                       		move.w	(a1),d0				; Get block ID
00003530 3800                       		move.w	d0,d4				; Copy that
00003532 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003536 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003538 0B04                       		btst	d5,d4				; Is the block solid?
0000353A 6600                       		bne.s	.IsSolid			; If so, branch
0000353C                            
0000353C                            .IsBlank:
0000353C D44B                       		add.w	a3,d2				; Check below the sensor
0000353E 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003542 944B                       		sub.w	a3,d2				; Restore Y position of sensor
00003544 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003548 4E75                       		rts
0000354A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000354A                            .IsSolid:
0000354A 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
0000354E D040                       		add.w	d0,d0				; Turn ID into offset
00003550 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003554 0240 00FF                  		andi.w	#$FF,d0				; ''
00003558 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000355A                            
0000355A 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
0000355E 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003562 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003564                            
00003564 3203                       		move.w	d3,d1				; Get the object's X position
00003566 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000356A 6700                       		beq.s	.NoXFlip			; If not, branch
0000356C 4641                       		not.w	d1				; Flip the X position
0000356E 4414                       		neg.b	(a4)				; Flip the angle
00003570                            		
00003570                            .NoXFlip:
00003570 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003574 6700                       		beq.s	.NoYFlip			; If not, branch
00003576 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000357A 4414                       		neg.b	(a4)				; ''
0000357C 0414 0040                  		subi.b	#$40,(a4)			; ''
00003580                            
00003580                            .NoYFlip:
00003580 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003584 D240                       		add.w	d0,d1				; Add the collision block's offset
00003586                            
00003586 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
0000358A 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000358E 4880                       		ext.w	d0				; ''
00003590 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003592 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003596 6700                       		beq.s	.NoYFlip2			; If not, branch
00003598 4440                       		neg.w	d0				; Flip the height
0000359A                            
0000359A                            .NoYFlip2:
0000359A 4A40                       		tst.w	d0				; Check the height
0000359C 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000359E 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000035A0 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000035A4 6700                       		beq.s	.MaxFloor			; If so, branch
000035A6 3202                       		move.w	d2,d1				; Get the object's Y position
000035A8 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035AC D041                       		add.w	d1,d0				; Add onto the height
000035AE 323C 000F                  		move.w	#$F,d1				; Get actual distance
000035B2 9240                       		sub.w	d0,d1				; ''
000035B4 4E75                       		rts
000035B6                            
000035B6                            .NegHeight:
000035B6 3202                       		move.w	d2,d1				; Get the object's Y position
000035B8 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035BC D041                       		add.w	d1,d0				; Add onto the height
000035BE 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000035C2                            
000035C2                            .MaxFloor:
000035C2 944B                       		sub.w	a3,d2				; Check above the sensor
000035C4 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
000035C6 D44B                       		add.w	a3,d2				; Restore Y position of sensor
000035C8 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000035CC 4E75                       		rts
000035CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035CE                            Level_FindFloor2:
000035CE 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000035D2 3011                       		move.w	(a1),d0				; Get block ID
000035D4 3800                       		move.w	d0,d4				; Copy that
000035D6 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000035DA 6700                       		beq.s	.IsBlank			; If it's blank, branch
000035DC 0B04                       		btst	d5,d4				; Is the block solid?
000035DE 6600                       		bne.s	.IsSolid			; If so, branch
000035E0                            
000035E0                            .IsBlank:
000035E0 323C 000F                  		move.w	#$F,d1				; Get max distance
000035E4 3002                       		move.w	d2,d0				; Get the object's Y position
000035E6 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
000035EA 9240                       		sub.w	d0,d1				; Get actual distance
000035EC 4E75                       		rts
000035EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035EE                            .IsSolid:
000035EE 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000035F2 D040                       		add.w	d0,d0				; Turn ID into offset
000035F4 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000035F8 0240 00FF                  		andi.w	#$FF,d0				; ''
000035FC 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000035FE                            
000035FE 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003602 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003606 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003608                            
00003608 3203                       		move.w	d3,d1				; Get the object's X position
0000360A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000360E 6700                       		beq.s	.NoXFlip			; If not, branch
00003610 4641                       		not.w	d1				; Flip the X position
00003612 4414                       		neg.b	(a4)				; Flip the angle
00003614                            
00003614                            .NoXFlip:
00003614 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003618 6700                       		beq.s	.NoYFlip			; If not, branch
0000361A 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000361E 4414                       		neg.b	(a4)				; ''
00003620 0414 0040                  		subi.b	#$40,(a4)			; ''
00003624                            
00003624                            .NoYFlip:
00003624 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003628 D240                       		add.w	d0,d1				; Add the collision block's offset
0000362A                            
0000362A 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
0000362E 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003632 4880                       		ext.w	d0				; ''
00003634 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003636 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000363A 6700                       		beq.s	.NoYFlip2			; If not, branch
0000363C 4440                       		neg.w	d0				; Flip the height
0000363E                            
0000363E                            .NoYFlip2:
0000363E 4A40                       		tst.w	d0				; Check the height
00003640 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003642 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003644 3202                       		move.w	d2,d1				; Get the object's Y position
00003646 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000364A D041                       		add.w	d1,d0				; Add onto the height
0000364C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003650 9240                       		sub.w	d0,d1				; ''
00003652 4E75                       		rts
00003654                            
00003654                            .NegHeight:
00003654 3202                       		move.w	d2,d1				; Get the object's Y position
00003656 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000365A D041                       		add.w	d1,d0				; Add onto the height
0000365C 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003660 4641                       		not.w	d1				; Flip the height
00003662 4E75                       		rts
00003664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003664                            ; Find the nearest wall from the object's position
00003664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003664                            ; PARAMETERS:
00003664                            ;	d2.w	- Y position of the object's bottom sensor
00003664                            ;	d3.w	- X position of the object's bottom sensor
00003664                            ;	d5.w	- Bit to chect for solidity
00003664                            ;	d6.w	- Flip bits (for walls and ceilings)
00003664                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003664                            ;	a4.w	- Pointer to where the angle value will be stored
00003664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003664                            ; RETURNS:
00003664                            ;	d1.w	- The distance from the object to the floor
00003664                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003664                            ;	(a4).w	- The floor angle
00003664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003664                            Level_FindWall:
00003664 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003668 3011                       		move.w	(a1),d0				; Get block ID
0000366A 3800                       		move.w	d0,d4				; Copy that
0000366C 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003670 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003672 0B04                       		btst	d5,d4				; Is the block solid?
00003674 6600                       		bne.s	.IsSolid			; If so, branch
00003676                            
00003676                            .IsBlank:
00003676 D64B                       		add.w	a3,d3				; Check right to the sensor
00003678 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
0000367C 964B                       		sub.w	a3,d3				; Restore X position of sensor
0000367E 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003682 4E75                       		rts
00003684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003684                            .IsSolid:
00003684 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003688 D040                       		add.w	d0,d0				; Turn ID into offset
0000368A 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000368E 0240 00FF                  		andi.w	#$FF,d0				; ''
00003692 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003694                            
00003694 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003698 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000369C E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000369E                            
0000369E 3202                       		move.w	d2,d1				; Get the object's Y position
000036A0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036A4 6700                       		beq.s	.NoYFlip			; If not, branch
000036A6 4641                       		not.w	d1				; Flip the Y position
000036A8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000036AC 4414                       		neg.b	(a4)				; ''
000036AE 0414 0040                  		subi.b	#$40,(a4)			; ''
000036B2                            
000036B2                            .NoYFlip:
000036B2 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000036B6 6700                       		beq.s	.NoXFlip			; If not, branch
000036B8 4414                       		neg.b	(a4)				; Flip the angle
000036BA                            
000036BA                            .NoXFlip:
000036BA 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000036BE D240                       		add.w	d0,d1				; Add the collision block's offset
000036C0                            
000036C0 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
000036C4 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000036C8 4880                       		ext.w	d0				; ''
000036CA BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000036CC 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
000036D0 6700                       		beq.s	.NoYFlip2			; If not, branch
000036D2 4440                       		neg.w	d0				; Flip the height
000036D4                            
000036D4                            .NoYFlip2:
000036D4 4A40                       		tst.w	d0				; Check the height
000036D6 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036D8 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036DA 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000036DE 6700                       		beq.s	.MaxFloor			; If so, branch
000036E0 3203                       		move.w	d3,d1				; Get the object's X position
000036E2 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000036E6 D041                       		add.w	d1,d0				; Add onto the height
000036E8 323C 000F                  		move.w	#$F,d1				; Get actual distance
000036EC 9240                       		sub.w	d0,d1				; ''
000036EE 4E75                       		rts
000036F0                            
000036F0                            .NegHeight:
000036F0 3203                       		move.w	d3,d1				; Get the object's X position
000036F2 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000036F6 D041                       		add.w	d1,d0				; Add onto the height
000036F8 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000036FC                            
000036FC                            .MaxFloor:
000036FC 964B                       		sub.w	a3,d3				; Check left to the sensor
000036FE 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003700 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003702 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003706 4E75                       		rts
00003708                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003708                            Level_FindWall2:
00003708 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000370C 3011                       		move.w	(a1),d0				; Get block ID
0000370E 3800                       		move.w	d0,d4				; Copy that
00003710 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003714 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003716 0B04                       		btst	d5,d4				; Is the block solid?
00003718 6600                       		bne.s	.IsSolid			; If so, branch
0000371A                            
0000371A                            .IsBlank:
0000371A 323C 000F                  		move.w	#$F,d1				; Get max distance
0000371E 3003                       		move.w	d3,d0				; Get the object's X position
00003720 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003724 9240                       		sub.w	d0,d1				; Get actual distance
00003726 4E75                       		rts
00003728                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003728                            .IsSolid:
00003728 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
0000372C D040                       		add.w	d0,d0				; Turn ID into offset
0000372E 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003732 0240 00FF                  		andi.w	#$FF,d0				; ''
00003736 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003738                            
00003738 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
0000373C 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003740 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003742                            
00003742 3202                       		move.w	d2,d1				; Get the object's Y position
00003744 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003748 6700                       		beq.s	.NoYFlip			; If not, branch
0000374A 4641                       		not.w	d1				; Flip the Y position
0000374C 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003750 4414                       		neg.b	(a4)				; ''
00003752 0414 0040                  		subi.b	#$40,(a4)			; ''
00003756                            
00003756                            .NoYFlip:
00003756 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000375A 6700                       		beq.s	.NoXFlip			; If not, branch
0000375C 4414                       		neg.b	(a4)				; Flip the angle
0000375E                            
0000375E                            .NoXFlip:
0000375E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003762 D240                       		add.w	d0,d1				; Add the collision block's offset
00003764                            
00003764 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
00003768 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000376C 4880                       		ext.w	d0				; ''
0000376E BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003770 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003774 6700                       		beq.s	.NoYFlip2			; If not, branch
00003776 4440                       		neg.w	d0				; Flip the height
00003778                            
00003778                            .NoYFlip2:
00003778 4A40                       		tst.w	d0				; Check the height
0000377A 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000377C 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000377E 3203                       		move.w	d3,d1				; Get the object's X position
00003780 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003784 D041                       		add.w	d1,d0				; Add onto the height
00003786 323C 000F                  		move.w	#$F,d1				; Get actual distance
0000378A 9240                       		sub.w	d0,d1				; ''
0000378C 4E75                       		rts
0000378E                            
0000378E                            .NegHeight:
0000378E 3203                       		move.w	d3,d1				; Get the object's X position
00003790 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003794 D041                       		add.w	d1,d0				; Add onto the height
00003796 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
0000379A 4641                       		not.w	d1				; Flip the height
0000379C 4E75                       		rts
0000379E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000379E                            ; Find the nearest block in the level from the player
0000379E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000379E                            ; PARAMETERS:
0000379E                            ;	d2.w	- Y position of the object's sensor
0000379E                            ;	d3.w	- X position of the object's sensor
0000379E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000379E                            ; RETURNS:
0000379E                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000379E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000379E                            Level_FindBlock:
0000379E 3002                       		move.w	d2,d0				; Get the object's Y position
000037A0 D040                       		add.w	d0,d0				; Double it
000037A2 0240 0F00                  		andi.w	#$F00,d0			; Get chunk row offset
000037A6 3203                       		move.w	d3,d1				; Get the object's X position
000037A8 E649                       		lsr.w	#3,d1				; Divide by 8
000037AA 3801                       		move.w	d1,d4				; Save for later
000037AC E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
000037AE 0241 007F                  		andi.w	#$7F,d1				; Only 128 chunks per row
000037B2 D041                       		add.w	d1,d0				; Get offset in the level layout
000037B4 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
000037B6 4241                       		clr.w	d1				; ''
000037B8 43F8 DFD0                  		lea	rLayout.w,a1			; Get layout pointer
000037BC 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
000037C0 D241                       		add.w	d1,d1				; Turn into offset
000037C2 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
000037C6 3002                       		move.w	d2,d0				; Get the object's Y position
000037C8 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
000037CC D240                       		add.w	d0,d1				; Add onto the offset
000037CE 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
000037D2 D244                       		add.w	d4,d1				; Add onto the offset
000037D4 2241                       		movea.l	d1,a1				; Get pointer in chunk table
000037D6 4E75                       		rts
000037D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037D8                            .ChunkOffsets:
000037D8 =00000000                  c		= 0
000037D8                            		rept	256
000037D8                            			dc.w	c
000037D8                            c			= c+$80
000037D8                            		endr
000037D8 0000                     M 	dc.w	c
000037DA =00000080                M c	=	c+$80
000037DA 0080                     M 	dc.w	c
000037DC =00000100                M c	=	c+$80
000037DC 0100                     M 	dc.w	c
000037DE =00000180                M c	=	c+$80
000037DE 0180                     M 	dc.w	c
000037E0 =00000200                M c	=	c+$80
000037E0 0200                     M 	dc.w	c
000037E2 =00000280                M c	=	c+$80
000037E2 0280                     M 	dc.w	c
000037E4 =00000300                M c	=	c+$80
000037E4 0300                     M 	dc.w	c
000037E6 =00000380                M c	=	c+$80
000037E6 0380                     M 	dc.w	c
000037E8 =00000400                M c	=	c+$80
000037E8 0400                     M 	dc.w	c
000037EA =00000480                M c	=	c+$80
000037EA 0480                     M 	dc.w	c
000037EC =00000500                M c	=	c+$80
000037EC 0500                     M 	dc.w	c
000037EE =00000580                M c	=	c+$80
000037EE 0580                     M 	dc.w	c
000037F0 =00000600                M c	=	c+$80
000037F0 0600                     M 	dc.w	c
000037F2 =00000680                M c	=	c+$80
000037F2 0680                     M 	dc.w	c
000037F4 =00000700                M c	=	c+$80
000037F4 0700                     M 	dc.w	c
000037F6 =00000780                M c	=	c+$80
000037F6 0780                     M 	dc.w	c
000037F8 =00000800                M c	=	c+$80
000037F8 0800                     M 	dc.w	c
000037FA =00000880                M c	=	c+$80
000037FA 0880                     M 	dc.w	c
000037FC =00000900                M c	=	c+$80
000037FC 0900                     M 	dc.w	c
000037FE =00000980                M c	=	c+$80
000037FE 0980                     M 	dc.w	c
00003800 =00000A00                M c	=	c+$80
00003800 0A00                     M 	dc.w	c
00003802 =00000A80                M c	=	c+$80
00003802 0A80                     M 	dc.w	c
00003804 =00000B00                M c	=	c+$80
00003804 0B00                     M 	dc.w	c
00003806 =00000B80                M c	=	c+$80
00003806 0B80                     M 	dc.w	c
00003808 =00000C00                M c	=	c+$80
00003808 0C00                     M 	dc.w	c
0000380A =00000C80                M c	=	c+$80
0000380A 0C80                     M 	dc.w	c
0000380C =00000D00                M c	=	c+$80
0000380C 0D00                     M 	dc.w	c
0000380E =00000D80                M c	=	c+$80
0000380E 0D80                     M 	dc.w	c
00003810 =00000E00                M c	=	c+$80
00003810 0E00                     M 	dc.w	c
00003812 =00000E80                M c	=	c+$80
00003812 0E80                     M 	dc.w	c
00003814 =00000F00                M c	=	c+$80
00003814 0F00                     M 	dc.w	c
00003816 =00000F80                M c	=	c+$80
00003816 0F80                     M 	dc.w	c
00003818 =00001000                M c	=	c+$80
00003818 1000                     M 	dc.w	c
0000381A =00001080                M c	=	c+$80
0000381A 1080                     M 	dc.w	c
0000381C =00001100                M c	=	c+$80
0000381C 1100                     M 	dc.w	c
0000381E =00001180                M c	=	c+$80
0000381E 1180                     M 	dc.w	c
00003820 =00001200                M c	=	c+$80
00003820 1200                     M 	dc.w	c
00003822 =00001280                M c	=	c+$80
00003822 1280                     M 	dc.w	c
00003824 =00001300                M c	=	c+$80
00003824 1300                     M 	dc.w	c
00003826 =00001380                M c	=	c+$80
00003826 1380                     M 	dc.w	c
00003828 =00001400                M c	=	c+$80
00003828 1400                     M 	dc.w	c
0000382A =00001480                M c	=	c+$80
0000382A 1480                     M 	dc.w	c
0000382C =00001500                M c	=	c+$80
0000382C 1500                     M 	dc.w	c
0000382E =00001580                M c	=	c+$80
0000382E 1580                     M 	dc.w	c
00003830 =00001600                M c	=	c+$80
00003830 1600                     M 	dc.w	c
00003832 =00001680                M c	=	c+$80
00003832 1680                     M 	dc.w	c
00003834 =00001700                M c	=	c+$80
00003834 1700                     M 	dc.w	c
00003836 =00001780                M c	=	c+$80
00003836 1780                     M 	dc.w	c
00003838 =00001800                M c	=	c+$80
00003838 1800                     M 	dc.w	c
0000383A =00001880                M c	=	c+$80
0000383A 1880                     M 	dc.w	c
0000383C =00001900                M c	=	c+$80
0000383C 1900                     M 	dc.w	c
0000383E =00001980                M c	=	c+$80
0000383E 1980                     M 	dc.w	c
00003840 =00001A00                M c	=	c+$80
00003840 1A00                     M 	dc.w	c
00003842 =00001A80                M c	=	c+$80
00003842 1A80                     M 	dc.w	c
00003844 =00001B00                M c	=	c+$80
00003844 1B00                     M 	dc.w	c
00003846 =00001B80                M c	=	c+$80
00003846 1B80                     M 	dc.w	c
00003848 =00001C00                M c	=	c+$80
00003848 1C00                     M 	dc.w	c
0000384A =00001C80                M c	=	c+$80
0000384A 1C80                     M 	dc.w	c
0000384C =00001D00                M c	=	c+$80
0000384C 1D00                     M 	dc.w	c
0000384E =00001D80                M c	=	c+$80
0000384E 1D80                     M 	dc.w	c
00003850 =00001E00                M c	=	c+$80
00003850 1E00                     M 	dc.w	c
00003852 =00001E80                M c	=	c+$80
00003852 1E80                     M 	dc.w	c
00003854 =00001F00                M c	=	c+$80
00003854 1F00                     M 	dc.w	c
00003856 =00001F80                M c	=	c+$80
00003856 1F80                     M 	dc.w	c
00003858 =00002000                M c	=	c+$80
00003858 2000                     M 	dc.w	c
0000385A =00002080                M c	=	c+$80
0000385A 2080                     M 	dc.w	c
0000385C =00002100                M c	=	c+$80
0000385C 2100                     M 	dc.w	c
0000385E =00002180                M c	=	c+$80
0000385E 2180                     M 	dc.w	c
00003860 =00002200                M c	=	c+$80
00003860 2200                     M 	dc.w	c
00003862 =00002280                M c	=	c+$80
00003862 2280                     M 	dc.w	c
00003864 =00002300                M c	=	c+$80
00003864 2300                     M 	dc.w	c
00003866 =00002380                M c	=	c+$80
00003866 2380                     M 	dc.w	c
00003868 =00002400                M c	=	c+$80
00003868 2400                     M 	dc.w	c
0000386A =00002480                M c	=	c+$80
0000386A 2480                     M 	dc.w	c
0000386C =00002500                M c	=	c+$80
0000386C 2500                     M 	dc.w	c
0000386E =00002580                M c	=	c+$80
0000386E 2580                     M 	dc.w	c
00003870 =00002600                M c	=	c+$80
00003870 2600                     M 	dc.w	c
00003872 =00002680                M c	=	c+$80
00003872 2680                     M 	dc.w	c
00003874 =00002700                M c	=	c+$80
00003874 2700                     M 	dc.w	c
00003876 =00002780                M c	=	c+$80
00003876 2780                     M 	dc.w	c
00003878 =00002800                M c	=	c+$80
00003878 2800                     M 	dc.w	c
0000387A =00002880                M c	=	c+$80
0000387A 2880                     M 	dc.w	c
0000387C =00002900                M c	=	c+$80
0000387C 2900                     M 	dc.w	c
0000387E =00002980                M c	=	c+$80
0000387E 2980                     M 	dc.w	c
00003880 =00002A00                M c	=	c+$80
00003880 2A00                     M 	dc.w	c
00003882 =00002A80                M c	=	c+$80
00003882 2A80                     M 	dc.w	c
00003884 =00002B00                M c	=	c+$80
00003884 2B00                     M 	dc.w	c
00003886 =00002B80                M c	=	c+$80
00003886 2B80                     M 	dc.w	c
00003888 =00002C00                M c	=	c+$80
00003888 2C00                     M 	dc.w	c
0000388A =00002C80                M c	=	c+$80
0000388A 2C80                     M 	dc.w	c
0000388C =00002D00                M c	=	c+$80
0000388C 2D00                     M 	dc.w	c
0000388E =00002D80                M c	=	c+$80
0000388E 2D80                     M 	dc.w	c
00003890 =00002E00                M c	=	c+$80
00003890 2E00                     M 	dc.w	c
00003892 =00002E80                M c	=	c+$80
00003892 2E80                     M 	dc.w	c
00003894 =00002F00                M c	=	c+$80
00003894 2F00                     M 	dc.w	c
00003896 =00002F80                M c	=	c+$80
00003896 2F80                     M 	dc.w	c
00003898 =00003000                M c	=	c+$80
00003898 3000                     M 	dc.w	c
0000389A =00003080                M c	=	c+$80
0000389A 3080                     M 	dc.w	c
0000389C =00003100                M c	=	c+$80
0000389C 3100                     M 	dc.w	c
0000389E =00003180                M c	=	c+$80
0000389E 3180                     M 	dc.w	c
000038A0 =00003200                M c	=	c+$80
000038A0 3200                     M 	dc.w	c
000038A2 =00003280                M c	=	c+$80
000038A2 3280                     M 	dc.w	c
000038A4 =00003300                M c	=	c+$80
000038A4 3300                     M 	dc.w	c
000038A6 =00003380                M c	=	c+$80
000038A6 3380                     M 	dc.w	c
000038A8 =00003400                M c	=	c+$80
000038A8 3400                     M 	dc.w	c
000038AA =00003480                M c	=	c+$80
000038AA 3480                     M 	dc.w	c
000038AC =00003500                M c	=	c+$80
000038AC 3500                     M 	dc.w	c
000038AE =00003580                M c	=	c+$80
000038AE 3580                     M 	dc.w	c
000038B0 =00003600                M c	=	c+$80
000038B0 3600                     M 	dc.w	c
000038B2 =00003680                M c	=	c+$80
000038B2 3680                     M 	dc.w	c
000038B4 =00003700                M c	=	c+$80
000038B4 3700                     M 	dc.w	c
000038B6 =00003780                M c	=	c+$80
000038B6 3780                     M 	dc.w	c
000038B8 =00003800                M c	=	c+$80
000038B8 3800                     M 	dc.w	c
000038BA =00003880                M c	=	c+$80
000038BA 3880                     M 	dc.w	c
000038BC =00003900                M c	=	c+$80
000038BC 3900                     M 	dc.w	c
000038BE =00003980                M c	=	c+$80
000038BE 3980                     M 	dc.w	c
000038C0 =00003A00                M c	=	c+$80
000038C0 3A00                     M 	dc.w	c
000038C2 =00003A80                M c	=	c+$80
000038C2 3A80                     M 	dc.w	c
000038C4 =00003B00                M c	=	c+$80
000038C4 3B00                     M 	dc.w	c
000038C6 =00003B80                M c	=	c+$80
000038C6 3B80                     M 	dc.w	c
000038C8 =00003C00                M c	=	c+$80
000038C8 3C00                     M 	dc.w	c
000038CA =00003C80                M c	=	c+$80
000038CA 3C80                     M 	dc.w	c
000038CC =00003D00                M c	=	c+$80
000038CC 3D00                     M 	dc.w	c
000038CE =00003D80                M c	=	c+$80
000038CE 3D80                     M 	dc.w	c
000038D0 =00003E00                M c	=	c+$80
000038D0 3E00                     M 	dc.w	c
000038D2 =00003E80                M c	=	c+$80
000038D2 3E80                     M 	dc.w	c
000038D4 =00003F00                M c	=	c+$80
000038D4 3F00                     M 	dc.w	c
000038D6 =00003F80                M c	=	c+$80
000038D6 3F80                     M 	dc.w	c
000038D8 =00004000                M c	=	c+$80
000038D8 4000                     M 	dc.w	c
000038DA =00004080                M c	=	c+$80
000038DA 4080                     M 	dc.w	c
000038DC =00004100                M c	=	c+$80
000038DC 4100                     M 	dc.w	c
000038DE =00004180                M c	=	c+$80
000038DE 4180                     M 	dc.w	c
000038E0 =00004200                M c	=	c+$80
000038E0 4200                     M 	dc.w	c
000038E2 =00004280                M c	=	c+$80
000038E2 4280                     M 	dc.w	c
000038E4 =00004300                M c	=	c+$80
000038E4 4300                     M 	dc.w	c
000038E6 =00004380                M c	=	c+$80
000038E6 4380                     M 	dc.w	c
000038E8 =00004400                M c	=	c+$80
000038E8 4400                     M 	dc.w	c
000038EA =00004480                M c	=	c+$80
000038EA 4480                     M 	dc.w	c
000038EC =00004500                M c	=	c+$80
000038EC 4500                     M 	dc.w	c
000038EE =00004580                M c	=	c+$80
000038EE 4580                     M 	dc.w	c
000038F0 =00004600                M c	=	c+$80
000038F0 4600                     M 	dc.w	c
000038F2 =00004680                M c	=	c+$80
000038F2 4680                     M 	dc.w	c
000038F4 =00004700                M c	=	c+$80
000038F4 4700                     M 	dc.w	c
000038F6 =00004780                M c	=	c+$80
000038F6 4780                     M 	dc.w	c
000038F8 =00004800                M c	=	c+$80
000038F8 4800                     M 	dc.w	c
000038FA =00004880                M c	=	c+$80
000038FA 4880                     M 	dc.w	c
000038FC =00004900                M c	=	c+$80
000038FC 4900                     M 	dc.w	c
000038FE =00004980                M c	=	c+$80
000038FE 4980                     M 	dc.w	c
00003900 =00004A00                M c	=	c+$80
00003900 4A00                     M 	dc.w	c
00003902 =00004A80                M c	=	c+$80
00003902 4A80                     M 	dc.w	c
00003904 =00004B00                M c	=	c+$80
00003904 4B00                     M 	dc.w	c
00003906 =00004B80                M c	=	c+$80
00003906 4B80                     M 	dc.w	c
00003908 =00004C00                M c	=	c+$80
00003908 4C00                     M 	dc.w	c
0000390A =00004C80                M c	=	c+$80
0000390A 4C80                     M 	dc.w	c
0000390C =00004D00                M c	=	c+$80
0000390C 4D00                     M 	dc.w	c
0000390E =00004D80                M c	=	c+$80
0000390E 4D80                     M 	dc.w	c
00003910 =00004E00                M c	=	c+$80
00003910 4E00                     M 	dc.w	c
00003912 =00004E80                M c	=	c+$80
00003912 4E80                     M 	dc.w	c
00003914 =00004F00                M c	=	c+$80
00003914 4F00                     M 	dc.w	c
00003916 =00004F80                M c	=	c+$80
00003916 4F80                     M 	dc.w	c
00003918 =00005000                M c	=	c+$80
00003918 5000                     M 	dc.w	c
0000391A =00005080                M c	=	c+$80
0000391A 5080                     M 	dc.w	c
0000391C =00005100                M c	=	c+$80
0000391C 5100                     M 	dc.w	c
0000391E =00005180                M c	=	c+$80
0000391E 5180                     M 	dc.w	c
00003920 =00005200                M c	=	c+$80
00003920 5200                     M 	dc.w	c
00003922 =00005280                M c	=	c+$80
00003922 5280                     M 	dc.w	c
00003924 =00005300                M c	=	c+$80
00003924 5300                     M 	dc.w	c
00003926 =00005380                M c	=	c+$80
00003926 5380                     M 	dc.w	c
00003928 =00005400                M c	=	c+$80
00003928 5400                     M 	dc.w	c
0000392A =00005480                M c	=	c+$80
0000392A 5480                     M 	dc.w	c
0000392C =00005500                M c	=	c+$80
0000392C 5500                     M 	dc.w	c
0000392E =00005580                M c	=	c+$80
0000392E 5580                     M 	dc.w	c
00003930 =00005600                M c	=	c+$80
00003930 5600                     M 	dc.w	c
00003932 =00005680                M c	=	c+$80
00003932 5680                     M 	dc.w	c
00003934 =00005700                M c	=	c+$80
00003934 5700                     M 	dc.w	c
00003936 =00005780                M c	=	c+$80
00003936 5780                     M 	dc.w	c
00003938 =00005800                M c	=	c+$80
00003938 5800                     M 	dc.w	c
0000393A =00005880                M c	=	c+$80
0000393A 5880                     M 	dc.w	c
0000393C =00005900                M c	=	c+$80
0000393C 5900                     M 	dc.w	c
0000393E =00005980                M c	=	c+$80
0000393E 5980                     M 	dc.w	c
00003940 =00005A00                M c	=	c+$80
00003940 5A00                     M 	dc.w	c
00003942 =00005A80                M c	=	c+$80
00003942 5A80                     M 	dc.w	c
00003944 =00005B00                M c	=	c+$80
00003944 5B00                     M 	dc.w	c
00003946 =00005B80                M c	=	c+$80
00003946 5B80                     M 	dc.w	c
00003948 =00005C00                M c	=	c+$80
00003948 5C00                     M 	dc.w	c
0000394A =00005C80                M c	=	c+$80
0000394A 5C80                     M 	dc.w	c
0000394C =00005D00                M c	=	c+$80
0000394C 5D00                     M 	dc.w	c
0000394E =00005D80                M c	=	c+$80
0000394E 5D80                     M 	dc.w	c
00003950 =00005E00                M c	=	c+$80
00003950 5E00                     M 	dc.w	c
00003952 =00005E80                M c	=	c+$80
00003952 5E80                     M 	dc.w	c
00003954 =00005F00                M c	=	c+$80
00003954 5F00                     M 	dc.w	c
00003956 =00005F80                M c	=	c+$80
00003956 5F80                     M 	dc.w	c
00003958 =00006000                M c	=	c+$80
00003958 6000                     M 	dc.w	c
0000395A =00006080                M c	=	c+$80
0000395A 6080                     M 	dc.w	c
0000395C =00006100                M c	=	c+$80
0000395C 6100                     M 	dc.w	c
0000395E =00006180                M c	=	c+$80
0000395E 6180                     M 	dc.w	c
00003960 =00006200                M c	=	c+$80
00003960 6200                     M 	dc.w	c
00003962 =00006280                M c	=	c+$80
00003962 6280                     M 	dc.w	c
00003964 =00006300                M c	=	c+$80
00003964 6300                     M 	dc.w	c
00003966 =00006380                M c	=	c+$80
00003966 6380                     M 	dc.w	c
00003968 =00006400                M c	=	c+$80
00003968 6400                     M 	dc.w	c
0000396A =00006480                M c	=	c+$80
0000396A 6480                     M 	dc.w	c
0000396C =00006500                M c	=	c+$80
0000396C 6500                     M 	dc.w	c
0000396E =00006580                M c	=	c+$80
0000396E 6580                     M 	dc.w	c
00003970 =00006600                M c	=	c+$80
00003970 6600                     M 	dc.w	c
00003972 =00006680                M c	=	c+$80
00003972 6680                     M 	dc.w	c
00003974 =00006700                M c	=	c+$80
00003974 6700                     M 	dc.w	c
00003976 =00006780                M c	=	c+$80
00003976 6780                     M 	dc.w	c
00003978 =00006800                M c	=	c+$80
00003978 6800                     M 	dc.w	c
0000397A =00006880                M c	=	c+$80
0000397A 6880                     M 	dc.w	c
0000397C =00006900                M c	=	c+$80
0000397C 6900                     M 	dc.w	c
0000397E =00006980                M c	=	c+$80
0000397E 6980                     M 	dc.w	c
00003980 =00006A00                M c	=	c+$80
00003980 6A00                     M 	dc.w	c
00003982 =00006A80                M c	=	c+$80
00003982 6A80                     M 	dc.w	c
00003984 =00006B00                M c	=	c+$80
00003984 6B00                     M 	dc.w	c
00003986 =00006B80                M c	=	c+$80
00003986 6B80                     M 	dc.w	c
00003988 =00006C00                M c	=	c+$80
00003988 6C00                     M 	dc.w	c
0000398A =00006C80                M c	=	c+$80
0000398A 6C80                     M 	dc.w	c
0000398C =00006D00                M c	=	c+$80
0000398C 6D00                     M 	dc.w	c
0000398E =00006D80                M c	=	c+$80
0000398E 6D80                     M 	dc.w	c
00003990 =00006E00                M c	=	c+$80
00003990 6E00                     M 	dc.w	c
00003992 =00006E80                M c	=	c+$80
00003992 6E80                     M 	dc.w	c
00003994 =00006F00                M c	=	c+$80
00003994 6F00                     M 	dc.w	c
00003996 =00006F80                M c	=	c+$80
00003996 6F80                     M 	dc.w	c
00003998 =00007000                M c	=	c+$80
00003998 7000                     M 	dc.w	c
0000399A =00007080                M c	=	c+$80
0000399A 7080                     M 	dc.w	c
0000399C =00007100                M c	=	c+$80
0000399C 7100                     M 	dc.w	c
0000399E =00007180                M c	=	c+$80
0000399E 7180                     M 	dc.w	c
000039A0 =00007200                M c	=	c+$80
000039A0 7200                     M 	dc.w	c
000039A2 =00007280                M c	=	c+$80
000039A2 7280                     M 	dc.w	c
000039A4 =00007300                M c	=	c+$80
000039A4 7300                     M 	dc.w	c
000039A6 =00007380                M c	=	c+$80
000039A6 7380                     M 	dc.w	c
000039A8 =00007400                M c	=	c+$80
000039A8 7400                     M 	dc.w	c
000039AA =00007480                M c	=	c+$80
000039AA 7480                     M 	dc.w	c
000039AC =00007500                M c	=	c+$80
000039AC 7500                     M 	dc.w	c
000039AE =00007580                M c	=	c+$80
000039AE 7580                     M 	dc.w	c
000039B0 =00007600                M c	=	c+$80
000039B0 7600                     M 	dc.w	c
000039B2 =00007680                M c	=	c+$80
000039B2 7680                     M 	dc.w	c
000039B4 =00007700                M c	=	c+$80
000039B4 7700                     M 	dc.w	c
000039B6 =00007780                M c	=	c+$80
000039B6 7780                     M 	dc.w	c
000039B8 =00007800                M c	=	c+$80
000039B8 7800                     M 	dc.w	c
000039BA =00007880                M c	=	c+$80
000039BA 7880                     M 	dc.w	c
000039BC =00007900                M c	=	c+$80
000039BC 7900                     M 	dc.w	c
000039BE =00007980                M c	=	c+$80
000039BE 7980                     M 	dc.w	c
000039C0 =00007A00                M c	=	c+$80
000039C0 7A00                     M 	dc.w	c
000039C2 =00007A80                M c	=	c+$80
000039C2 7A80                     M 	dc.w	c
000039C4 =00007B00                M c	=	c+$80
000039C4 7B00                     M 	dc.w	c
000039C6 =00007B80                M c	=	c+$80
000039C6 7B80                     M 	dc.w	c
000039C8 =00007C00                M c	=	c+$80
000039C8 7C00                     M 	dc.w	c
000039CA =00007C80                M c	=	c+$80
000039CA 7C80                     M 	dc.w	c
000039CC =00007D00                M c	=	c+$80
000039CC 7D00                     M 	dc.w	c
000039CE =00007D80                M c	=	c+$80
000039CE 7D80                     M 	dc.w	c
000039D0 =00007E00                M c	=	c+$80
000039D0 7E00                     M 	dc.w	c
000039D2 =00007E80                M c	=	c+$80
000039D2 7E80                     M 	dc.w	c
000039D4 =00007F00                M c	=	c+$80
000039D4 7F00                     M 	dc.w	c
000039D6 =00007F80                M c	=	c+$80
000039D6 7F80                     M 	dc.w	c
000039D8 =00008000                M c	=	c+$80
000039D8                            ; =========================================================================================================================================================
000039D8                            		include	"Level/Level Functions.asm"
000039D8                            ; =========================================================================================================================================================
000039D8                            ; Mighty The Armadillo in PRISM PARADISE
000039D8                            ; By Nat The Porcupine 2021
000039D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039D8                            ; General level functions
000039D8                            ; =========================================================================================================================================================
000039D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039D8                            ; Load level data
000039D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039D8                            Level_LoadData:
000039D8                            		; --- Initialize the start position and camera ---
000039D8                            
000039D8 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
000039DE 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000039E2 E218                       		ror.b	#1,d0				; Turn into offset
000039E4 E848                       		lsr.w	#4,d0				; ''
000039E6 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
000039EA                            
000039EA 42B8 F8C4                  		clr.l	rDestMinCam.w		; Set target minimum camera values
000039EE 42B8 F8C8                  		clr.l	rMinCam.w			; Set minimum camera values
000039F2 21D3 F8BC                  		move.l	(a3),rDestMaxCam.w		; Set target maximum camera values
000039F6 21DB F8C0                  		move.l	(a3)+,rMaxCam.w		; Set maximum camera values
000039FA                            
000039FA 31FC 0060 F8CC             		move.w	#(224/2)-16,rCamYPosDist.w	; Set camera Y distance
00003A00                            
00003A00 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Player object
00003A04 321B                       		move.w	(a3)+,d1			; Get starting X position
00003A06 3141 0014                  		move.w	d1,oXPos(a0)			; Set the player's X position
00003A0A 3013                       		move.w	(a3),d0				; Get starting Y position
00003A0C 3140 0018                  		move.w	d0,oYPos(a0)			; Set the player's Y position
00003A10                            
00003A10 4A38 C7B9                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003A14 6700                       		beq.s	.InitCam			; If not, branch
00003A16 08E8 0002 000C             		bset	#2,oFlags(a0)
00003A1C 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003A1E 3141 0014                  		move.w	d1,oXPos(a0)			; ''
00003A22 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003A24 3140 0018                  		move.w	d0,oYPos(a0)			; ''
00003A28                            
00003A28                            .InitCam:
00003A28 4A38 C7AE                  		tst.b	rLastChkpoint.w		; Has a checkpoint been hit?
00003A2C 6700                       		beq.s	.SetCam				; If not, branch
00003A2E 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003A32 3228 0014                  		move.w	oXPos(a0),d1			; Get X position
00003A36 3028 0018                  		move.w	oYPos(a0),d0			; Get Y position
00003A3A                            
00003A3A                            .SetCam:
00003A3A 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003A3E 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003A40 7200                       		moveq	#0,d1				; Cap it
00003A42                            
00003A42                            .ChkMaxX:
00003A42 3438 F8C0                  		move.w	rMaxCamX.w,d2		; Get max camera X position
00003A46 B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003A48 6500                       		bcs.s	.SetCamX			; If not, branch
00003A4A 3202                       		move.w	d2,d1				; Cap it
00003A4C                            
00003A4C                            .SetCamX:	
00003A4C 31C1 F880                  		move.w	d1,rCamXPos.w			; Set the camera's X position
00003A50                            
00003A50 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003A54 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003A56 7000                       		moveq	#0,d0				; Cap it
00003A58                            
00003A58                            .ChkMaxY:
00003A58 3438 F8C2                  		move.w	rMaxCamY.w,d2		; Get max camera Y position
00003A5C B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003A5E 6D00                       		blt.s	.SetCamY			; If not, branch
00003A60 3002                       		move.w	d2,d0				; Cap it
00003A62                            
00003A62                            .SetCamY:	
00003A62 31C0 F888                  		move.w	d0,rCamYPos.w			; Set the camera's Y position
00003A66                            
00003A66                            		; --- Load level data ---
00003A66                            
00003A66 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003A6C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A70 E218                       		ror.b	#1,d0				; Turn into offset
00003A72 E448                       		lsr.w	#2,d0				; ''
00003A74 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A78                            
00003A78 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003A7A 43F9 00FF 0000             		lea	rChunks,a1			; Decompress into chunk table
00003A80 4EB8 0A86                  		jsr	KosDec.w			; ''
00003A84                            
00003A84 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003A86 43F8 C7D0                  		lea	rBlocks.w,a1			; Decompress into block table
00003A8A 4EB8 0A86                  		jsr	KosDec.w			; ''
00003A8E                            
00003A8E 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003A90 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003A92 4EB8 0EDC                  		jsr	QueueKosMData.w			; Queue for decompression
00003A96                            
00003A96 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003A98 3018                       		move.w	(a0)+,d0			; Size of palette data
00003A9A 4EB8 04BE                  		jsr	LoadTargetPal.w			; Load the palette
00003A9E                            
00003A9E 205B                       		movea.l	(a3)+,a0			; Get layout pointer
00003AA0 43F8 DFD0                  		lea	rLayout.w,a1			; Decompress into layout buffer
00003AA4 4EB8 0A86                  		jsr	KosDec.w			; ''
00003AA8                            
00003AA8 21DB C7B4                  		move.l	(a3)+,rObjPosAddr.w		; Set object position data pointer
00003AAC 21DB F85E                  		move.l	(a3)+,rRingPosAddr.w		; Set ring position data pointer
00003AB0 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003AB2 201B                       		move.l	(a3)+,d0			; Get collision data address
00003AB4 21C0 F8E0                  		move.l	d0,rColAddr.w			; Set collision address to primary
00003AB8 21C0 F8D8                  		move.l	d0,r1stCol.w			; Set primary collision data pointer
00003ABC 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003ABE 21C0 F8DC                  		move.l	d0,r2ndCol.w			; Set secondary collision data pointer
00003AC2 43F8 F8E6                  		lea	rAngleVals.w,a1		; Collision pointers
00003AC6 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003AC8 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003ACA 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003ACC                            
00003ACC 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003AD2 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003AD6 E218                       		ror.b	#1,d0				; Turn into offset
00003AD8 EA48                       		lsr.w	#5,d0				; ''
00003ADA 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003ADE 4EF8 0ECC                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003AE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AE2                            ; Update the water surface
00003AE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AE2                            Level_UpdateWaterSurface:
00003AE2 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003AE6 6700                       		beq.s	.End				; If not, branch
00003AE8 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera X position
00003AEC 0838 0000 F8FB             		btst	#0,(rLvlFrames+1).w		; Are we on an odd frame?
00003AF2 6700                       		beq.s	.SetXPos			; If not, branch
00003AF4 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003AF8                            
00003AF8                            .SetXPos:
00003AF8 3001                       		move.w	d1,d0				; Copy X postion
00003AFA 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003AFE 3078 F87C                  		movea.w	rWater1Addr.w,a0
00003B02 3140 0014                  		move.w	d0,oXPos(a0)			; Set it
00003B06 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003B0A 3078 F87E                  		movea.w	rWater2Addr.w,a0
00003B0E 3141 0014                  		move.w	d1,oXPos(a0)			; Set it
00003B12                            
00003B12                            .End:
00003B12 4E75                       		rts
00003B14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B14                            ; Handle water height
00003B14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B14                            Level_WaterHeight:
00003B14 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B18 6700                       		beq.s	.End				; If not, branch
00003B1A 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003B1E 4238 F8F5                  		clr.b	rWaterFullscr.w		; Clear water fullscreen flag
00003B22                            
00003B22 7201                       		moveq	#1,d1				; Water movement speed
00003B24 3038 F8F8                  		move.w	rDestWtrLvl.w,d0		; Get destination water level
00003B28 9078 F8F6                  		sub.w	rWaterLvl.w,d0		; Is the current water level at that destination?
00003B2C 6700                       		beq.s	.ChkOnScr			; If so, branch
00003B2E 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003B30 4441                       		neg.w	d1				; Go up
00003B32                            
00003B32                            .MoveDown:
00003B32 D378 F8F6                  		add.w	d1,rWaterLvl.w		; Move water
00003B36                            
00003B36                            .ChkOnScr:
00003B36 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00003B3A 9078 F888                  		sub.w	rCamYPos.w,d0			; Get camera's Y position
00003B3E 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003B40 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003B42                            		
00003B42                            .Fullscreen:
00003B42 50F8 F8F5                  		st	rWaterFullscr.w		; Set water fullscreen flag
00003B46 50F8 C75F                  		st	rHIntCnt.w			; Set H-INT counter to be offscreen
00003B4A 4E75                       		rts
00003B4C                            
00003B4C                            .ChkBottom:
00003B4C 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003B50 6500                       		blo.s	.SetCounter			; If not, branch
00003B52 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003B54                            
00003B54                            .SetCounter:
00003B54 11C0 C75F                  		move.b	d0,rHIntCnt.w			; Set H-INT counter
00003B58                            
00003B58                            .End:
00003B58 4E75                       		rts
00003B5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B5A                            Level_MoveWater:
00003B5A 4E75                       		rts
00003B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B5C                            ; Do level palette cycling
00003B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B5C                            Level_PalCycle:
00003B5C 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003B62 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B66 E218                       		ror.b	#1,d0				; Turn into offset
00003B68 EA48                       		lsr.w	#5,d0				; ''
00003B6A 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B6E 4ED0                       		jmp	(a0)				; Jump to it
00003B70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B70                            ; Do level art animation
00003B70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B70                            Level_AnimateArt:
00003B70 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003B76 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B7A E218                       		ror.b	#1,d0				; Turn into offset
00003B7C EA48                       		lsr.w	#5,d0				; ''
00003B7E 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B82 4ED0                       		jmp	(a0)				; Jump to it
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            ; Do dynamic events
00003B84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B84                            Level_DynEvents:
00003B84 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003B8A 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B8E E218                       		ror.b	#1,d0				; Turn into offset
00003B90 EA48                       		lsr.w	#5,d0				; ''
00003B92 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B96 4ED0                       		jmp	(a0)				; Jump to it
00003B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B98                            ; Handle the camera
00003B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B98                            Level_HandleCamera:
00003B98 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Get player object
00003B9C                            		
00003B9C 4A38 F8CE                  		tst.b	rCamLockX.w			; Is the camera locked horizontally?
00003BA0 6600                       		bne.s	.ChkY				; If so, branch
00003BA2 43F8 F880                  		lea	rCamXPos.w,a1			; Get foreground level variables
00003BA6 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003BA8                            		
00003BA8                            .ChkY:
00003BA8 4A38 F8CF                  		tst.b	rCamLockY.w			; Is the camera locked vertically?
00003BAC 6600                       		bne.s	.ChkMaxY			; If not, branch
00003BAE 43F8 F888                  		lea	rCamYPos.w,a1			; Get foreground level variables
00003BB2 3638 F8CC                  		move.w	rCamYPosDist.w,d3		; Get camera Y distance
00003BB6 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003BBA                            
00003BBA                            .ChkMaxY:
00003BBA 7202                       		moveq	#2,d1				; Target camera scroll speed
00003BBC 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get distance between target and actual target max camera Y position
00003BC0 9078 F8C2                  		sub.w	rMaxCamY.w,d0		; ''
00003BC4 6700                       		beq.s	.End				; If it's 0, branch
00003BC6 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003BC8 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003BCC B078 F8BE                  		cmp.w	rDestMaxY.w,d0		; Is it past the boundary?
00003BD0 6300                       		bls.s	.ScrollUp			; If not, branch
00003BD2 31C0 F8C2                  		move.w	d0,rMaxCamY.w		; Set max camera Y position
00003BD6 0278 FFFE F8C2             		andi.w	#$FFFE,rMaxCamY.w		; Keep it a multiple of 2
00003BDC                            
00003BDC                            .ScrollUp:
00003BDC 9378 F8C2                  		sub.w	d1,rMaxCamY.w		; Scroll up
00003BE0 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003BE4                            
00003BE4                            
00003BE4                            .End:
00003BE4 4E75                       		rts
00003BE6                            
00003BE6                            .MoveDown:
00003BE6 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003BEA 5040                       		addq.w	#8,d0				; ''
00003BEC B078 F8C2                  		cmp.w	rMaxCamY.w,d0		; Is it past the boundary?
00003BF0 6500                       		bcs.s	.ScrollDown			; If not, branch
00003BF2 0828 0001 0028             		btst	#1,oStatus(a0)		; Is the player in the air?
00003BF8 6700                       		beq.s	.ScrollDown			; If not, branch
00003BFA D241                       		add.w	d1,d1				; Scroll down faster
00003BFC D241                       		add.w	d1,d1				; ''
00003BFE                            
00003BFE                            .ScrollDown:
00003BFE D378 F8C2                  		add.w	d1,rMaxCamY.w		; Scroll down
00003C02 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C06 4E75                       		rts
00003C08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C08                            Level_MoveCameraX:
00003C08 3028 0014                  		move.w	oXPos(a0),d0			; Get the player's X position
00003C0C 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003C0E 9078 F8D2                  		sub.w	rCamXPosCenter.w,d0		; Subtract center
00003C12 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003C14 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003C16 4E75                       		rts
00003C18                            
00003C18                            .MoveLeft:
00003C18 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003C1C 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003C1E 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003C22                            
00003C22                            .ChkLeftBound:
00003C22 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C24 B078 F8C8                  		cmp.w	rMinCamX.w,d0		; Have we gone past the left boundary?
00003C28 6E00                       		bgt.s	.SetCamX			; If not, branch
00003C2A 3038 F8C8                  		move.w	rMinCamX.w,d0		; Cap at the left boundary
00003C2E 6000                       		bra.s	.SetCamX			; Continue
00003C30                            
00003C30                            .MoveRight:
00003C30 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003C34 6500                       		blo.s	.ChkRightBound			; If not, branch
00003C36 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003C3A                            
00003C3A                            .ChkRightBound:
00003C3A D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C3C B078 F8C0                  		cmp.w	rMaxCamX.w,d0		; Has the camera gone beyond the right boundary?
00003C40 6D00                       		blt.s	.SetCamX			; If not, branch
00003C42 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Cap at the right boundary
00003C46                            
00003C46                            .SetCamX:
00003C46 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003C48 4E75                       		rts
00003C4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C4A                            Level_MoveCameraY:
00003C4A 7200                       		moveq	#0,d1
00003C4C 3028 0018                  		move.w	oYPos(a0),d0			; Get the player's Y position
00003C50 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003C52                            
00003C52 0828 0002 0028             		btst	#2,oStatus(a0)			; Is the player rolling?
00003C58 6700                       		beq.s	.NoRoll				; If not, branch
00003C5A 5B40                       		subq.w	#5,d0				; Move up some
00003C5C                            
00003C5C                            .NoRoll:
00003C5C 0828 0001 0028             		btst	#1,oStatus(a0)			; Is the player in the air?
00003C62 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003C64                            
00003C64                            .ChkBoundCross_Air:
00003C64 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003C68 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003C6A 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003C6C 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003C70 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003C72                            
00003C72 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003C76 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003C78 6000                       		bra.s	.NoScroll			; Continue
00003C7A                            
00003C7A                            .ChkBoundCross_Ground:
00003C7A 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003C7C 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003C7E 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003C82 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003C84                            
00003C84                            .NoScroll:
00003C84 4E75                       		rts		
00003C86                            
00003C86                            .DecideScrollType:
00003C86 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003C8A 6600                       		bne.s	.ScrollSlow			; If not, branch
00003C8C                            
00003C8C 3228 0000                  		move.w	oGVel(a0),d1			; Get the players' ground velocity
00003C90 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003C92 4441                       		neg.w	d1				; Force it to be positive
00003C94                            
00003C94                            .Positive:
00003C94 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003C98 6400                       		bhs.s	.ScrollFast			; If so, branch
00003C9A                            
00003C9A                            .ScrollMedium:
00003C9A 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003C9E 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003CA2 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CA4 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003CA8 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CAA 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CAC                            
00003CAC                            .ScrollSlow:
00003CAC 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003CB0 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003CB4 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CB6 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003CBA 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CBC 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CBE                            
00003CBE                            .ScrollFast:
00003CBE 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003CC2 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003CC6 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CC8 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003CCC 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CCE 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CD0                            
00003CD0                            .ScrollMaxYChange:
00003CD0 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003CD2 11C0 F8D0                  		move.b	d0,rCamMaxChg.w		; Clear the max Y boundary changing flag
00003CD6                            		
00003CD6                            .ScrollUpOrDown:
00003CD6 7200                       		moveq	#0,d1
00003CD8 3200                       		move.w	d0,d1				; Get position difference
00003CDA D251                       		add.w	(a1),d1				; Add old camera Y position
00003CDC 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003CDE 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003CE0 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003CE4                            
00003CE4                            .ScrollUpMax:
00003CE4 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003CE6 48C1                       		ext.l	d1
00003CE8 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003CEA D291                       		add.l	(a1),d1				; Add the camera's Y position
00003CEC 4841                       		swap	d1				; Get the actual Y position
00003CEE                            
00003CEE                            .ScrollUp:
00003CEE B278 F8CA                  		cmp.w	rMinCamY.w,d1		; Has the camera gone beyond the upper boundary?
00003CF2 6E00                       		bgt.s	.DoScroll			; If not, branch
00003CF4 3238 F8CA                  		move.w	rMinCamY.w,d1		; Cap at upper boundary
00003CF8 6000                       		bra.s	.DoScroll			; Continue
00003CFA                            
00003CFA                            .ScrollDownMax:
00003CFA 48C1                       		ext.l	d1
00003CFC E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003CFE D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D00 4841                       		swap	d1				; Get the actual Y position
00003D02                            
00003D02                            .ScrollDown:
00003D02 B278 F8C2                  		cmp.w	rMaxCamY.w,d1		; Has the camera gone beyond the lower boundary?
00003D06 6D00                       		blt.s	.DoScroll			; If not, branch
00003D08 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Cap at lower boundary
00003D0C                            
00003D0C                            .DoScroll:
00003D0C 4841                       		swap	d1				; Put Y coordinate in the higher word
00003D0E 2281                       		move.l	d1,(a1)				; Set Y position
00003D10 4E75                       		rts
00003D12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D12                            ; Level ring manager
00003D12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D12                            Level_RingsManager:
00003D12 7000                       		moveq	#0,d0
00003D14 1038 F3D6                  		move.b	rRingManRout.w,d0		; Get routine
00003D18 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003D1C 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003D20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D20                            .Routines:
00003D20 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003D22 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003D24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D24                            ; Ring manager initialization
00003D24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D24                            Level_RingsManagerInit:
00003D24 5438 F3D6                  		addq.b	#2,rRingManRout.w		; The next time the manager is run, only go to the main routine
00003D28                            		
00003D28 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003D2C                            
00003D2C                            		; Set up the addresses to use in the current location of the level
00003D2C                            
00003D2C                            		; Start at the left side of the screen
00003D2C                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003D2C                            
00003D2C 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get current ring data address for the left side of the screen
00003D30 45F8 F3DE                  		lea	rRingStat.w,a2		; Ring status table
00003D34 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D38 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D3A 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003D3C 7801                       		moveq	#1,d4				; Cap left side to 1
00003D3E 6000                       		bra.s	.CheckLeftSide			; Start checking
00003D40                            
00003D40                            .NextLeftRing:
00003D40 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D42 544A                       		addq.w	#2,a2				; Next ring in status table
00003D44                            
00003D44                            .CheckLeftSide:
00003D44 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003D46 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003D48 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003D4C 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003D50                            
00003D50                            		; Now the right side of the screen
00003D50                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003D50                            
00003D50 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003D54 6000                       		bra.s	.CheckRightSide			; Start checking
00003D56                            
00003D56                            .NextRightRing:
00003D56 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D58                            
00003D58                            .CheckRightSide:
00003D58 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003D5A 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003D5C 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003D60 4E75                       		rts
00003D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D62                            ; Ring manager main routine
00003D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D62                            Level_RingsManagerMain:
00003D62 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003D66                            
00003D66 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get the current starting address for the ring data
00003D6A 3478 F86A                  		movea.w	rRingStatPtr.w,a2		; Get the current starting address for the status table
00003D6E                            		
00003D6E                            		; Get the new starting addresses for ring data
00003D6E                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003D6E                            		; and then going back to get the very first ring that's on screen
00003D6E                            
00003D6E 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D72 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D74 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003D76 7801                       		moveq	#1,d4				; Cap left side to 1
00003D78 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003D7A                            
00003D7A                            .NextNewLeftRing:
00003D7A 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D7C 544A                       		addq.w	#2,a2				; Next ring in status table
00003D7E                            
00003D7E                            .CheckNewLeftSide:
00003D7E B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003D80 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003D82 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003D84                            
00003D84                            .NextNewLeftRing2:
00003D84 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003D86 554A                       		subq.w	#2,a2				; Previous ring in status table
00003D88                            
00003D88                            .CheckNewLeftSide2:
00003D88 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003D8C 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003D8E 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003D92 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003D96                            
00003D96                            		; Now get the new ending addresses for ring data
00003D96                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003D96                            		; and then going back to get the very first ring that's on screen on the left side
00003D96                            
00003D96 2278 F866                  		movea.l	rRingLoadR.w,a1		; Get the current ending address for the ring data
00003D9A                            
00003D9A 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003D9E 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003DA0                            
00003DA0                            .NextNewRightRing:
00003DA0 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DA2                            
00003DA2                            .CheckNewRightSide:
00003DA2 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003DA4 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003DA6 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003DA8                            
00003DA8                            .NextNewRightRing2:
00003DA8 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003DAA                            
00003DAA                            .CheckNewRightSide2:
00003DAA B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003DAE 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003DB0 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003DB4 4E75                       		rts
00003DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DB6                            ; Handle ring collection
00003DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DB6                            Level_RingsManagerDoCollect:
00003DB6 45F8 F7DE                  		lea	rRingCol.w,a2			; Ring collection table
00003DBA 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003DBC 5341                       		subq.w	#1,d1				; Sutbract 1
00003DBE 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003DC0                            
00003DC0                            .Loop:
00003DC0 301A                       		move.w	(a2)+,d0			; Get ring status address
00003DC2 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003DC4 3240                       		movea.w	d0,a1				; Save in a1
00003DC6 5311                       		subq.b	#1,(a1)				; Decrement timer
00003DC8 6600                       		bne.s	.Next				; If nonzero, branch
00003DCA 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003DCE 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003DD2                            							; Is it the last frame?
00003DD2 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003DD8 6600                       		bne.s	.Next				; If not, branch
00003DDA 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003DDE 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003DE2 5378 F7DE                  		subq.w	#1,rRingColCnt.w		; Decrement collection table count
00003DE6                            
00003DE6                            .Next:
00003DE6 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003DEA                            
00003DEA                            .End:
00003DEA 4E75                       		rts
00003DEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DEC                            ; Set up the tables and load ring data
00003DEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DEC                            Level_RingsManagerSetup:
00003DEC                            		; Clear tables
00003DEC                            		clrRAM	rRingStat
00003DEC                          M 	local	endaddr
00003DEC                          M endaddr	equs	"rringstat_End"
00003DEC 7000                     M 	moveq	#0,d0
00003DEE 43F8 F3DE                M 	lea	(rringstat).w,a1
00003DF2 323C 00FF                M 	move.w	#(((rringstat_end)-(rringstat))-((rringstat)&1))>>2-1,d1
00003DF6 22C0                     M .clear_174:	move.l	d0,(a1)+
00003DF8 51C9 FFFC                M 	dbf	d1,.clear_174
00003DFC                            		clrRAM	rRingCol
00003DFC                          M 	local	endaddr
00003DFC                          M endaddr	equs	"rringcol_End"
00003DFC 7000                     M 	moveq	#0,d0
00003DFE 43F8 F7DE                M 	lea	(rringcol).w,a1
00003E02 323C 001F                M 	move.w	#(((rringcol_end)-(rringcol))-((rringcol)&1))>>2-1,d1
00003E06 22C0                     M .clear_175:	move.l	d0,(a1)+
00003E08 51C9 FFFC                M 	dbf	d1,.clear_175
00003E0C                            
00003E0C 2278 F85E                  		movea.l	rRingPosAddr.w,a1		; Get ring data pointer
00003E10 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store address
00003E14 5849                       		addq.w	#4,a1				; Increment address by 4
00003E16 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003E18 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003E1C                            
00003E1C                            .GetRingCount:
00003E1C 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003E1E 6B00                       		bmi.s	.Exit				; If so, branch
00003E20 5245                       		addq.w	#1,d5				; Increment ring counter
00003E22 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003E26                            
00003E26                            .Exit:
00003E26 4E75                       		rts
00003E28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E28                            ; Do ring collision for the player
00003E28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E28                            PlayerRingCollision:
00003E28 0C28 0069 0000             		cmpi.b	#105,oInvulTime(a0)		; Is the player able to collect rings while hurt?
00003E2E 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003E32 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get starting address of ring data
00003E36 2478 F866                  		movea.l	rRingLoadR.w,a2		; Get starting address of status table
00003E3A B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003E3C 6700 0000                  		beq.w	.End				; If not, branch
00003E40 3878 F86A                  		movea.w	rRingStatPtr.w,a4
00003E44 3428 0014                  		move.w	oXPos(a0),d2			; Player's X position
00003E48 3628 0018                  		move.w	oYPos(a0),d3			; Player's Y position
00003E4C 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003E4E 7A00                       		moveq	#0,d5
00003E50 1A28 002D                  		move.b	oColH(a0),d5			; Player's collision height
00003E54 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003E56 9645                       		sub.w	d5,d3				; Subtract from Y
00003E58 323C 0006                  		move.w	#6,d1
00003E5C 3C3C 000C                  		move.w	#$C,d6
00003E60 383C 0010                  		move.w	#$10,d4				; Width
00003E64 DA45                       		add.w	d5,d5				; Double the height
00003E66                            
00003E66                            .NextRing:
00003E66 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003E68 6600                       		bne.s	.GetNext			; If so, get the next ring
00003E6A 3011                       		move.w	(a1),d0				; Get ring's X position
00003E6C 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003E6E 9042                       		sub.w	d2,d0				; Check collision
00003E70 6400                       		bcc.s	.ChkCol
00003E72 D046                       		add.w	d6,d0
00003E74 6500                       		bcs.s	.ChkCol2
00003E76 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003E7A                            
00003E7A                            .ChkCol:
00003E7A B044                       		cmp.w	d4,d0				; Check collision
00003E7C 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003E80                            
00003E80                            .ChkCol2:
00003E80 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003E84 9041                       		sub.w	d1,d0
00003E86 9043                       		sub.w	d3,d0
00003E88 6400                       		bcc.s	.ChkCol3
00003E8A D046                       		add.w	d6,d0
00003E8C 6500                       		bcs.s	.Collect
00003E8E 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003E92                            
00003E92                            .ChkCol3:
00003E92 B045                       		cmp.w	d5,d0
00003E94 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003E98                            
00003E98                            .Collect:
00003E98                            							; Consume the ring
00003E98 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003E9C 6100                       		bsr.s	CollectRing			; Collect it
00003E9E 47F8 F7E0                  		lea	rRingColList.w,a3		; Get collection list
00003EA2                            
00003EA2                            .Consume:
00003EA2 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003EA4 66FC                       		bne.s	.Consume			; If not, get the next one
00003EA6 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003EA8 5278 F7DE                  		addq.w	#1,rRingColCnt.w		; Add to the number of rings consumed
00003EAC                            
00003EAC                            .GetNext:
00003EAC 5849                       		addq.w	#4,a1				; Next ring in ring data
00003EAE 544C                       		addq.w	#2,a4				; Next ring in status table
00003EB0 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003EB2 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003EB6                            
00003EB6                            .End:
00003EB6 4E75                       		rts
00003EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EB8                            ; Collect a ring
00003EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EB8                            CollectRing:
00003EB8 5278 F3D4                  		addq.w	#1,rRings.w			; Incremment ring count
00003EBC 50F8 F8F3                  		st	rUpdateRings.w			; Update ring counter in HUD
00003EC0                            		playSnd	#sRing, 2			; Play ring sound
00003EC0 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003EC6 4E75                       		rts
00003EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EC8                            ; Render the HUD
00003EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EC8                            Level_RenderHUDAndRings:
00003EC8 7C00                       		moveq	#0,d6				; Clear render flags
00003ECA 7802                       		moveq	#1*2,d4				; Standard frame
00003ECC 4A78 F3D4                  		tst.w	rRings.w			; Do we have 0 rings?
00003ED0 6600                       		bne.s	.Not0Rings			; If not, branch
00003ED2 0838 0003 F8FB             		btst	#3,(rLvlFrames+1).w		; Can the timer blink?
00003ED8 6600                       		bne.s	.Not0Rings			; If not, branch
00003EDA 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003EDC                            
00003EDC                            .Not0Rings:
00003EDC 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003EE0                            		
00003EE0 303C 0090                  		move.w	#16+128,d0			; X position
00003EE4 323C 0088                  		move.w	#8+128,d1			; Y position
00003EE8 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003EEC D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003EF0 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003EF2 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003EF4 4EB8 07D6                  		jsr	DrawSprite.w			; Draw the HUD frame
00003EF8                            
00003EF8                            .RenderRings:
00003EF8 2078 F862                  		movea.l	rRingLoadL.w,a0			; Get starting address of ring data
00003EFC 2438 F866                  		move.l	rRingLoadR.w,d2			; Get ending address of ring data
00003F00 9488                       		sub.l	a0,d2				; Get length of the data to read
00003F02 6700                       		beq.s	.End				; If zero length, branch
00003F04 3878 F86A                  		movea.w	rRingStatPtr.w,a4		; Get starting address of status table
00003F08 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00003F0C 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00003F10                            		
00003F10                            .Loop:
00003F10 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00003F12 6B00                       		bmi.s	.Next				; If so, branch
00003F14 3228 0002                  		move.w	2(a0),d1			; Get Y position
00003F18 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00003F1C 5041                       		addq.w	#8,d1				; Add 8
00003F1E B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00003F20 6400                       		bhs.s	.Next				; If so, branch
00003F22 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00003F26 3010                       		move.w	(a0),d0				; Get X position
00003F28 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00003F2A 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00003F2E 7C00                       		moveq	#0,d6
00003F30 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00003F34                            
00003F34                            .Draw:
00003F34 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00003F36 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00003F3A D25A                       		add.w	(a2)+,d1			; Add Y offset
00003F3C 3CC1                       		move.w	d1,(a6)+			; Save Y position
00003F3E 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00003F40 1C86                       		move.b	d6,(a6)				; Save it
00003F42 544E                       		addq.w	#2,a6				; Skip link value
00003F44 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00003F46 D05A                       		add.w	(a2)+,d0			; Add X offset
00003F48 3CC0                       		move.w	d0,(a6)+			; Save X position
00003F4A 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00003F4C                            
00003F4C                            .Next:
00003F4C 5848                       		addq.w	#4,a0				; Next ring in ring data
00003F4E 5942                       		subq.w	#4,d2				; Decrement the ring count
00003F50 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00003F52                            
00003F52                            .End:
00003F52 4E75                       		rts
00003F54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F54                            ; Custom mappings format.
00003F54                            ; Differences include...
00003F54                            ;	No offset table (each sprite assumed to be 8 bytes)
00003F54                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00003F54                            ;	Sign-extended Y-pos value
00003F54                            ;	Sign-extended sprite size value
00003F54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F54                            CMap_Ring:
00003F54                            		; Main ring frame
00003F54 FFF8                       		dc.w	$FFF8
00003F56 0005                       		dc.w	$0005
00003F58 26BC                       		dc.w	$0000+$26BC
00003F5A FFF8                       		dc.w	$FFF8
00003F5C                            
00003F5C                            CMap_Ring_Sparkle:
00003F5C                            		; Ring sparkle frame 1
00003F5C FFF8                       		dc.w	$FFF8
00003F5E 0005                       		dc.w	$0005
00003F60 26B8                       		dc.w	$0000+$26B8
00003F62 FFF8                       		dc.w	$FFF8
00003F64                            		; Ring sparkle frame 2
00003F64 FFF8                       		dc.w	$FFF8
00003F66 0005                       		dc.w	$0005
00003F68 3EB8                       		dc.w	($0000+$26B8)|$1800
00003F6A FFF8                       		dc.w	$FFF8
00003F6C                            		; Ring sparkle frame 3
00003F6C FFF8                       		dc.w	$FFF8
00003F6E 0005                       		dc.w	$0005
00003F70 2EB8                       		dc.w	($0000+$26B8)|$800
00003F72 FFF8                       		dc.w	$FFF8
00003F74                            		; Ring sparkle frame 4
00003F74 FFF8                       		dc.w	$FFF8
00003F76 0005                       		dc.w	$0005
00003F78 36B8                       		dc.w	($0000+$26B8)|$1000
00003F7A FFF8                       		dc.w	$FFF8
00003F7C                            CMap_Ring_Sparkle_Last:
00003F7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F7C                            ; HUD mappings
00003F7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F7C                            Map_HUD:	include	"Level/Objects/HUD/Mappings.asm"
00003F7C                            ; --------------------------------------------------------------------------------
00003F7C                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00003F7C                            ; --------------------------------------------------------------------------------
00003F7C                            
00003F7C                            SME_dLu6r:	
00003F7C 0000 0000                  		dc.w SME_dLu6r4-SME_dLu6r, SME_dLu6r18-SME_dLu6r	
00003F80 0003                       SME_dLu6r4:	dc.b 0, 3	
00003F82 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00003F88 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
00003F8E 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003F94 0003                       SME_dLu6r18:	dc.b 0, 3	
00003F96 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
00003F9C 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00003FA2 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003FA8                            		even
00003FA8                            		even
00003FA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA8                            ; Update the HUD
00003FA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA8                            ; PARAMETERS:
00003FA8                            ;	a5.l	- VDP data port
00003FA8                            ;	a6.l	- VDP control port
00003FA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA8                            ; RETURNS:
00003FA8                            ;	Nothing
00003FA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA8                            Level_UpdateHUD:
00003FA8 4A38 F8F3                  		tst.b	rUpdateRings.w		; Does the ring counter need to be updated?
00003FAC 6700                       		beq.s	.End				; If not, branch
00003FAE 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
00003FB0 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00003FB4                            
00003FB4                            .DontZero:
00003FB4 4238 F8F3                  		clr.b	rUpdateRings.w		; Clear update value
00003FB8                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00003FB8 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
00003FBE 7200                       		moveq	#0,d1
00003FC0 3238 F3D4                  		move.w	rRings.w,d1			; Ring count
00003FC4 6000                       		bra.s	.UpdateRings			; Update the rings counter
00003FC6                            
00003FC6                            .End
00003FC6 4E75                       		rts
00003FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FC8                            .UpdateRings:
00003FC8 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00003FCA 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
00003FD0 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00003FD2 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers
00003FD6                            		
00003FD6                            .LoadDigit_Loop:
00003FD6 7400                       		moveq	#0,d2				; Reset the digit
00003FD8 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
00003FDA                            		
00003FDA                            .GetDigit:
00003FDA 9283                       		sub.l	d3,d1				; Subtract
00003FDC 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
00003FDE 5242                       		addq.w	#1,d2				; Increment digit
00003FE0 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00003FE2                            
00003FE2                            .InitDrawDigit:
00003FE2 D283                       		add.l	d3,d1				; Add back
00003FE4 4A42                       		tst.w	d2				; Is the digit 0?
00003FE6 6700                       		beq.s	.DrawDigit			; If so, branch
00003FE8 50C4                       		st	d4				; Set the "draw digit" flag
00003FEA                            
00003FEA                            .DrawDigit:
00003FEA 4A04                       		tst.b	d4				; Should we draw the digit?
00003FEC 6700                       		beq.s	.NextDigit			; If not, branch
00003FEE ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00003FF0 2C80                       		move.l	d0,(a6)				; Set the VDP command
00003FF2 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
00003FF6                            		rept	16
00003FF6                            			move.l	(a3)+,(a5)		; Load the digit art
00003FF6                            		endr
00003FF6 2A9B                     M 	move.l	(a3)+,(a5)
00003FF8 2A9B                     M 	move.l	(a3)+,(a5)
00003FFA 2A9B                     M 	move.l	(a3)+,(a5)
00003FFC 2A9B                     M 	move.l	(a3)+,(a5)
00003FFE 2A9B                     M 	move.l	(a3)+,(a5)
00004000 2A9B                     M 	move.l	(a3)+,(a5)
00004002 2A9B                     M 	move.l	(a3)+,(a5)
00004004 2A9B                     M 	move.l	(a3)+,(a5)
00004006 2A9B                     M 	move.l	(a3)+,(a5)
00004008 2A9B                     M 	move.l	(a3)+,(a5)
0000400A 2A9B                     M 	move.l	(a3)+,(a5)
0000400C 2A9B                     M 	move.l	(a3)+,(a5)
0000400E 2A9B                     M 	move.l	(a3)+,(a5)
00004010 2A9B                     M 	move.l	(a3)+,(a5)
00004012 2A9B                     M 	move.l	(a3)+,(a5)
00004014 2A9B                     M 	move.l	(a3)+,(a5)
00004016                            		
00004016                            .NextDigit:
00004016 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
0000401C 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
00004020 4E75                       		rts
00004022                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004022 0000 0064                  HUDMod_100:	dc.l	100
00004026 0000 000A                  HUDMod_10:	dc.l	10
0000402A 0000 0001                  HUDMod_1:	dc.l	1
0000402E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402E                            ; Initialize the HUD
0000402E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402E                            Level_InitHUD:
0000402E 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
00004034 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
00004038                            		
00004038                            Level_HUDResetRings:
00004038                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
00004038 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
0000403E 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
00004042 343C 0002                  		move.w	#3-1,d2				; Length
00004046                            
00004046 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers art
0000404A                            
0000404A                            .LoadTiles:
0000404A 101A                       		move.b	(a2)+,d0			; Get digit
0000404C 4880                       		ext.w	d0
0000404E ED48                       		lsl.w	#6,d0				; Turn into offset
00004050 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004054                            
00004054                            		rept	8*2
00004054                            			move.l	(a3)+,(a5)		; Load art
00004054                            		endr
00004054 2A9B                     M 	move.l	(a3)+,(a5)
00004056 2A9B                     M 	move.l	(a3)+,(a5)
00004058 2A9B                     M 	move.l	(a3)+,(a5)
0000405A 2A9B                     M 	move.l	(a3)+,(a5)
0000405C 2A9B                     M 	move.l	(a3)+,(a5)
0000405E 2A9B                     M 	move.l	(a3)+,(a5)
00004060 2A9B                     M 	move.l	(a3)+,(a5)
00004062 2A9B                     M 	move.l	(a3)+,(a5)
00004064 2A9B                     M 	move.l	(a3)+,(a5)
00004066 2A9B                     M 	move.l	(a3)+,(a5)
00004068 2A9B                     M 	move.l	(a3)+,(a5)
0000406A 2A9B                     M 	move.l	(a3)+,(a5)
0000406C 2A9B                     M 	move.l	(a3)+,(a5)
0000406E 2A9B                     M 	move.l	(a3)+,(a5)
00004070 2A9B                     M 	move.l	(a3)+,(a5)
00004072 2A9B                     M 	move.l	(a3)+,(a5)
00004074                            
00004074 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
00004078                            
00004078 4E75                       		rts
0000407A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407A                            HUD_RingsBase:
0000407A 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
0000407E 00                         		even
0000407E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407E                            ; HUD art
0000407E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000407E                            ArtUnc_HUDNumbers:
0000407E                            		incbin	"Level/Objects/HUD/Art - HUD Numbers.unc.bin"
000042FE 0000 0000 0000 0000 0000+  		dcb.l	16, 0
0000433E                            		even
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            ; Animate the level art
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            ; LEVEL ANIMATION SCRIPTS
0000433E                            ;
0000433E                            ; The AniArt_DoAnimate subroutine uses these scripts to reload certain tiles,
0000433E                            ; thus animating them. All the relevant art must be uncompressed, because
0000433E                            ; otherwise the subroutine would spend so much time waiting for the art to be
0000433E                            ; decompressed that the VBLANK window would close before all the animating was done.
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
0000433E                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
0000433E                            ;		ArtUnc_Flowers1		Source address
0000433E                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
0000433E                            ;		6			Number of frames
0000433E                            ;		2			Number of tiles to load into VRAM for each frame
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            ;	dc.b   0,$7F			Start of the script proper
0000433E                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
0000433E                            ;		$7F			Frame duration. Only here if global duration is -1
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            AniArt_DoAnimate:
0000433E 47F8 F902                  		lea	rAnimCnts.w,a3		; Level art animation counters
00004342 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004344 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
00004346 4E75                       		rts
00004348                            
00004348                            .ListNotEmpty:
00004348                            .Loop:
00004348 5313                       		subq.b	#1,(a3)				; Tick down frame duration
0000434A 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
0000434C                            
0000434C                            .NextFrame:
0000434C 7000                       		moveq	#0,d0
0000434E 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004352 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
00004356 6500                       		blo.s	.NotLastFrame			; If not, branch
00004358 7000                       		moveq	#0,d0				; If so, reset to first frame
0000435A 1740 0001                  		move.b	d0,1(a3)			; ''
0000435E                            
0000435E                            .NotLastFrame:
0000435E 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004362 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004364 6A00                       		bpl.s	.GlobalDuration
00004366 D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
00004368 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
0000436C                            
0000436C                            .GlobalDuration:
0000436C 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004370 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004372 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
00004376 2212                       		move.l	(a2),d1				; Get ROM source address
00004378 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
0000437E D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
00004380 7600                       		moveq	#0,d3
00004382 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
00004386 E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
00004388 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
0000438C                            
0000438C                            .NextScript:
0000438C 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
00004390 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
00004392 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
00004394 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
00004396                            
00004396                            .GlobalDuration2:
00004396 5200                       		addq.b	#1,d0
00004398 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
0000439C 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
000043A0 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
000043A2 51CE FFA4                  		dbf	d6,.Loop			; Loop
000043A6 4E75                       		rts
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            ; Set an object as solid and check for collision
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For oStatus):
000043A8                            ;	XXPXSXAX
000043A8                            ;	X	- Unused
000043A8                            ;	P	- Pushing flag
000043A8                            ;	S	- Standing on flag
000043A8                            ;	A	- In air flag (for the player)
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
000043A8                            ;	XXXTXBXS
000043A8                            ;	X	- Unused
000043A8                            ;	T	- Touch top flag
000043A8                            ;	B	- Touch bottom flag
000043A8                            ;	S	- Touch side flag
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            ; PARAMETERS:
000043A8                            ;	d1.w	- Object width
000043A8                            ;	d2.w	- Object height / 2 (when jumping)
000043A8                            ;	d3.w	- Object height / 2 (when walking)
000043A8                            ;	d4.w	- Object x-axis position
000043A8                            ;	a0.l	- Object space pointer
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            ; RETURNS:
000043A8                            ;	See object collision return values above
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            SolidObject:
000043A8 7C00                       		moveq	#0,d6				; Clear collision flag register
000043AA 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000043AE 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000043B4 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
000043B8 3401                       		move.w	d1,d2				; Copy object width
000043BA D442                       		add.w	d2,d2				; Double it
000043BC 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000043C2 6600                       		bne.s	.NotOnTop			; If so, branch
000043C4 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000043C8 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000043CC D041                       		add.w	d1,d0				; Add width
000043CE 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000043D0 B042                       		cmp.w	d2,d0				; Compare with the width
000043D2 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000043D4                            
000043D4                            .NotOnTop:
000043D4 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
000043DA 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000043E0 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000043E6 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000043EA 7800                       		moveq	#0,d4				; Set collision status to 0
000043EC 4E75                       		rts
000043EE                            
000043EE                            .IsOnTop:
000043EE 3404                       		move.w	d4,d2				; Copy X position to d2
000043F0 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000043F4 7800                       		moveq	#0,d4				; Set collision status to 0
000043F6 4E75                       		rts
000043F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043F8                            ; Set an object as solid and check for collision (even if off screen)
000043F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043F8                            ; PARAMETERS:
000043F8                            ;	d1.w	- Object width
000043F8                            ;	d2.w	- Object height / 2 (when jumping)
000043F8                            ;	d3.w	- Object height / 2 (when walking)
000043F8                            ;	d4.w	- Object x-axis position
000043F8                            ;	a0.l	- Object space pointer
000043F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043F8                            ; RETURNS:
000043F8                            ;	See object collision return values above
000043F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043F8                            SolidObject_Always:
000043F8 7C00                       		moveq	#0,d6				; Clear collision flag register
000043FA 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000043FE 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004404 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
00004408 3401                       		move.w	d1,d2				; Copy object width
0000440A D442                       		add.w	d2,d2				; Double it
0000440C 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004412 6600                       		bne.s	.NotOnTop			; If so, branch
00004414 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004418 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000441C D041                       		add.w	d1,d0				; Add width
0000441E 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004420 B042                       		cmp.w	d2,d0				; Compare with the width
00004422 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004424                            
00004424                            .NotOnTop:
00004424 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000442A 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004430 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004436 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000443A 7800                       		moveq	#0,d4				; Set collision status to 0
0000443C 4E75                       		rts
0000443E                            
0000443E                            .IsOnTop:
0000443E 3404                       		move.w	d4,d2				; Copy X position to d2
00004440 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004444 7800                       		moveq	#0,d4				; Set collision status to 0
00004446 4E75                       		rts
00004448                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004448                            ; Set an object as a solid slope and check for collision
00004448                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004448                            ; PARAMETERS:
00004448                            ;	d1.w	- Object width
00004448                            ;	d2.w	- Object height / 2 (when jumping)
00004448                            ;	d3.w	- Object height / 2 (when walking)
00004448                            ;	d4.w	- Object x-axis position
00004448                            ;	a0.l	- Object space pointer
00004448                            ;	a2.l	- Slope height data pointer
00004448                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004448                            ; RETURNS:
00004448                            ;	See object collision return values above
00004448                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004448                            SlopedSolid:
00004448 7C00                       		moveq	#0,d6				; Clear collision flag register
0000444A 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
0000444E 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004454 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
00004458 3401                       		move.w	d1,d2				; Copy object width
0000445A D442                       		add.w	d2,d2				; Double it
0000445C 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004462 6600                       		bne.s	.NotOnTop			; If so, branch
00004464 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004468 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000446C D041                       		add.w	d1,d0				; Add width
0000446E 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004470 B042                       		cmp.w	d2,d0				; Compare with the width
00004472 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004474                            
00004474                            .NotOnTop:
00004474 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000447A 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004480 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004486 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000448A 7800                       		moveq	#0,d4				; Set collision status to 0
0000448C 4E75                       		rts
0000448E                            
0000448E                            .IsOnTop:
0000448E 3404                       		move.w	d4,d2				; Copy X position to d2
00004490 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
00004494 7800                       		moveq	#0,d4				; Set collision status to 0
00004496 4E75                       		rts
00004498                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004498                            SlopedSolid_ChkCollision:
00004498 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000449C 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract current object's X position
000044A0 D041                       		add.w	d1,d0				; Add width to it
000044A2 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000044A6 3601                       		move.w	d1,d3				; Copy width to d3
000044A8 D643                       		add.w	d3,d3				; Double it
000044AA B043                       		cmp.w	d3,d0				; Compare to the X position
000044AC 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000044B0 3A00                       		move.w	d0,d5				; Copy the X position to d5
000044B2 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X-flipped?
000044B8 6700                       		beq.s	.NoFlip				; If not, branch
000044BA 4645                       		not.w	d5				; Logical notation on d5
000044BC DA43                       		add.w	d3,d5				; Add width
000044BE                            
000044BE                            .NoFlip:
000044BE E24D                       		lsr.w	#1,d5				; Divide by 2
000044C0 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
000044C4 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
000044C6 4883                       		ext.w	d3				; Sign extend to word
000044C8 3A28 0018                  		move.w	oYPos(a0),d5			; Get the current object's Y position
000044CC 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
000044CE 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
000044D2 4883                       		ext.w	d3				; Sign extend to word
000044D4 D443                       		add.w	d3,d2				; Add collision height to the object height
000044D6 3629 0018                  		move.w	oYPos(a1),d3			; Get the player's Y position
000044DA 9645                       		sub.w	d5,d3				; Subtract d5
000044DC 5843                       		addq.w	#4,d3				; Add 4
000044DE D642                       		add.w	d2,d3				; Add height and collision height
000044E0 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000044E4 3802                       		move.w	d2,d4				; Copy height and collision height
000044E6 D844                       		add.w	d4,d4				; Double it
000044E8 B644                       		cmp.w	d4,d3				; Compare to Y position
000044EA 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
000044EE 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
000044F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044F2                            SolidObject_ChkColOnScr:
000044F2 4A28 000D                  		tst.b	oRender(a0)			; Is the object on screen?
000044F6 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
000044FA                            
000044FA                            SolidObject_ChkCollision:
000044FA 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000044FE 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004502 D041                       		add.w	d1,d0				; Add width
00004504 3601                       		move.w	d1,d3				; Copy width
00004506 D643                       		add.w	d3,d3				; Double it
00004508 B043                       		cmp.w	d3,d0				; Compare with the X position
0000450A 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
0000450E                            		
0000450E 1829 0000                  		move.b	oInitColH(a1),d4		; Get the player's default collision height
00004512 4884                       		ext.w	d4				; Sign extend to word
00004514 D842                       		add.w	d2,d4				; Add height
00004516 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
0000451A 4883                       		ext.w	d3				; Sign extend to word
0000451C D443                       		add.w	d3,d2				; Add to height
0000451E 3629 0018                  		move.w	oYPos(a1),d3			; Get player's Y position
00004522 9668 0018                  		sub.w	oYPos(a0),d3			; Subtract the current object's Y position
00004526 5843                       		addq.w	#4,d3				; Add 4
00004528 D642                       		add.w	d2,d3				; Add height
0000452A 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
0000452E D842                       		add.w	d2,d4				; Add height
00004530 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004532 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004536                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004536                            SolidObject_ChkBounds:
00004536 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000453A 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
0000453E 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004544 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
00004548 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
0000454C 6600 0000                  		bne.w	SolidObject_End			; If so, branch
00004550                            
00004550 3A00                       		move.w	d0,d5				; Copy X offset
00004552 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004554 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
00004556 D241                       		add.w	d1,d1				; Double collision width
00004558 9041                       		sub.w	d1,d0				; Subtract from X offset
0000455A 3A00                       		move.w	d0,d5				; Copy X offset
0000455C 4445                       		neg.w	d5				; Negate offset
0000455E                            
0000455E                            .IsLeft:
0000455E 3203                       		move.w	d3,d1				; Copy Y offset
00004560 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004562 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004564 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
00004566 9644                       		sub.w	d4,d3				; Subtract height from the collision height
00004568 3203                       		move.w	d3,d1				; Copy Y offset
0000456A 4441                       		neg.w	d1				; Negate offset
0000456C                            
0000456C                            .IsAbove:
0000456C BA41                       		cmp.w	d1,d5
0000456E 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004572 0C41 0004                  		cmpi.w	#4,d1
00004576 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            SolidObject_Sides:
0000457A 4A40                       		tst.w	d0
0000457C 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
0000457E 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
00004580 4A69 001C                  		tst.w	oXVel(a1)			; Is the player moving left?
00004584 6B00                       		bmi.s	.AlignPlayer			; If so, branch
00004586 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
00004588                            
00004588                            .ChkRight:
00004588 4A69 001C                  		tst.w	oXVel(a1)
0000458C 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
0000458E                            
0000458E                            .ClearGroundVel:
0000458E 4269 0000                  		clr.w	oGVel(a1)			; Stop the player from moving
00004592 4269 001C                  		clr.w	oXVel(a1)			; Clear the player's X velocity
00004596                            
00004596                            .AlignPlayer:
00004596 9169 0014                  		sub.w	d0,oXPos(a1)			; Align player to the side of the object
0000459A 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000045A0 6600                       		bne.s	.InAir				; If so, branch
000045A2 08E8 0005 0028             		bset	#cPushBit,oStatus(a0)		; Set the pushing bit
000045A8 08E9 0005 0028             		bset	#cPushBit,oStatus(a1)		; Set the player's pushing bit
000045AE 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045B2 7801                       		moveq	#1,d4				; Set collision status to 1
000045B4 4E75                       		rts
000045B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045B6                            .InAir:
000045B6 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
000045B8 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045BC 7801                       		moveq	#1,d4				; Set collision status to 1
000045BE 4E75                       		rts
000045C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045C0                            SolidObject_TestClearPush:
000045C0 0828 0005 0028             		btst	#cPushBit,oStatus(a0)		; Is the player pushing this object?
000045C6 6700                       		beq.s	SolidObject_End			; If not, branch
000045C8 0C29 0002 0020             		cmpi.b	#2,oAni(a1)			; Is the player jumping/rolling?
000045CE 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045D0 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)			; Is the player in using the drowning animation
000045D6 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045D8 0C29 001A 0020             		cmpi.b	#$1A,oAni(a1)			; Is the player in using the hurt animation
000045DE 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045E0 337C 0001 0020             		move.w	#1,oAni(a1)			; Make the player use the walking animation
000045E6                            
000045E6                            SolidObject_ClearPush:
000045E6 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear the pushing bit
000045EC 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; Clear the player's pushing bit
000045F2                            
000045F2                            SolidObject_End:
000045F2 7800                       		moveq	#0,d4				; Set collision status to 0
000045F4 4E75                       		rts
000045F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045F6                            SolidObject_UpDown:
000045F6 4A43                       		tst.w	d3				; Is the player below the middle of the object?
000045F8 6B00                       		bmi.s	SolidObject_Below		; If so, branch
000045FA 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
000045FE 6500                       		bcs.s	SolidObject_Above		; If so, branch
00004600 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
00004602                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004602                            SolidObject_Below:
00004602 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving vertically?
00004606 6700                       		beq.s	.CheckCrush			; If so, branch
00004608 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
0000460A 4A43                       		tst.w	d3				; Is the player above the middle of the object?
0000460C 6A00                       		bpl.s	.SetY				; If so, branch
0000460E 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004612                            
00004612                            .SetY:
00004612 9769 0018                  		sub.w	d3,oYPos(a1)			; Push the player below the object
00004616 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
0000461A 78FE                       		moveq	#-2,d4				; Set the collision status to -2
0000461C 4E75                       		rts
0000461E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461E                            .CheckCrush:
0000461E 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004624 66EC                       		bne.s	.SetY				; If so, branch
00004626 3800                       		move.w	d0,d4				; Get x offset
00004628 6A00                       		bpl.s	.NoNeg				; If it's positive branch
0000462A 4444                       		neg.w	d4				; Negate it (absolute value)
0000462C                            
0000462C                            .NoNeg:
0000462C 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004630 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004634                            		
00004634                            		push.l	a0				; Store the current object's address
00004634 2F08                     M 	move.l	a0,-(sp)
00004636 2049                       		movea.l	a1,a0				; Replace with the player's address
00004638 4EB9 0000 0000             		jsr	ObjMighty_GetKilled		; Kill the player
0000463E                            		pop.l	a0				; Restore the current object's address
0000463E 205F                     M 	move.l	(sp)+,a0
00004640 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004644 78FE                       		moveq	#-2,d4				; Set collision status to -2
00004646 4E75                       		rts
00004648                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004648                            SolidObject_Above:
00004648 5943                       		subq.w	#4,d3				; Get the sub Y offset
0000464A                            		
0000464A                            		; This next bit ensures the player does not collide with the top when next to the walls
0000464A                            		; recalculates object width.
0000464A                            
0000464A 7200                       		moveq	#0,d1
0000464C 1228 002C                  		move.b	oColW(a0),d1			; Get the current object's width
00004650 3401                       		move.w	d1,d2				; Copy it
00004652 D442                       		add.w	d2,d2				; Double it
00004654                            		
00004654 D269 0014                  		add.w	oXPos(a1),d1			; Add the player's X position
00004658 9268 0014                  		sub.w	oXPos(a0),d1			; Subtract the current object's X position
0000465C 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
0000465E                            		
0000465E B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
00004660 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004662                            		
00004662 5369 0018                  		subq.w	#1,oYPos(a1)			; Subtract 1 from the player's Y position
00004666 9769 0018                  		sub.w	d3,oYPos(a1)			; Move the player above the object
0000466A 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
0000466E 6B00                       		bmi.s	.NoCollision			; If so, branch
00004670 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004674 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
00004678 78FF                       		moveq	#-1,d4				; Set collision status to -1
0000467A 4E75                       		rts
0000467C                            
0000467C                            .NoCollision:
0000467C 7800                       		moveq	#0,d4				; Set collision status to 0
0000467E 4E75                       		rts
00004680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004680                            ; Set an object as a platform and check for collision
00004680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004680                            ; PARAMETERS:
00004680                            ;	d1.w	- Object's width
00004680                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
00004680                            ;	d3.w	- Object's height
00004680                            ;	d4.w	- Object x-axis position
00004680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004680                            ; RETURNS:
00004680                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004680                            PlatformObject:
00004680 7C00                       		moveq	#0,d6				; Clear collision flag register
00004682 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
00004686 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
0000468C 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
00004690 3401                       		move.w	d1,d2				; Copy the object's width
00004692 D442                       		add.w	d2,d2				; Double it
00004694 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
0000469A 6600                       		bne.s	.NotOnTop			; If so, branch
0000469C 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046A0 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046A4 D041                       		add.w	d1,d0				; Add width
000046A6 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000046A8 B042                       		cmp.w	d2,d0				; Compare with the width
000046AA 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000046AC                            
000046AC                            .NotOnTop:
000046AC 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000046B2 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000046B8 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000046BE 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000046C2 7800                       		moveq	#0,d4				; Set the collision status to 0
000046C4 4E75                       		rts
000046C6                            
000046C6                            .OnTop:
000046C6 3404                       		move.w	d4,d2				; Copy X position
000046C8 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
000046CC 7800                       		moveq	#0,d4				; Set the collision status to 0
000046CE 4E75                       		rts
000046D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046D0                            Platform_ChkBridgeCol:
000046D0 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000046D4 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000046D8 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046DC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046E0 D041                       		add.w	d1,d0				; Add width
000046E2 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000046E6 B042                       		cmp.w	d2,d0				; Compare with width
000046E8 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000046EC 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
000046EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046EE                            Platform_ChkCollision:
000046EE 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000046F2 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000046F6 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046FA 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046FE D041                       		add.w	d1,d0				; Add width
00004700 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004704 D241                       		add.w	d1,d1				; Double width
00004706 B041                       		cmp.w	d1,d0				; Compare with width
00004708 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
0000470C                            
0000470C                            Platform_ChkCol_Cont:
0000470C 3028 0018                  		move.w	oYPos(a0),d0			; Get the object's Y position
00004710 9043                       		sub.w	d3,d0				; Subtract the height from it
00004712                            
00004712                            PlatformObject_ChkYRange:
00004712 3429 0018                  		move.w	oYPos(a1),d2			; Get the player's Y position
00004716 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
0000471A 4881                       		ext.w	d1				; Sign extend it
0000471C D242                       		add.w	d2,d1				; Add the Y position to the collision height
0000471E 5841                       		addq.w	#4,d1				; Add 4
00004720 9041                       		sub.w	d1,d0				; Subract the result from the Y position
00004722 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
00004726 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
0000472A 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
0000472E 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004732 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
00004736 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000473A 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000473E 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)		; Is the player dead?
00004744 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
00004748 D440                       		add.w	d0,d2				; Add the previous result to the Y position
0000474A 5642                       		addq.w	#3,d2				; Add 3
0000474C 3342 0018                  		move.w	d2,oYPos(a1)			; Add to the player's Y position
00004750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004750                            ; Set the player on top of the object
00004750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004750                            ; PARAMETERS:
00004750                            ;	a0.l	- Object space pointer
00004750                            ;	a1.l	- Player object space pointer
00004750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004750                            ; RETURNS:
00004750                            ;	Nothing
00004750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004750                            RideObject_SetRide:
00004750 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
00004756 6700                       		beq.s	.IsStanding			; If not, branch
00004758 3669 0000                  		movea.w	oInteract(a1),a3		; Get the object the player is standing on
0000475C 08AB 0003 0028             		bclr	#cStandBit,oStatus(a3)		; Clear its standing on object bit
00004762 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004766                            
00004766                            .IsStanding:
00004766 3348 0000                  		move.w	a0,oInteract(a1)		; Set it as the object the player is standing on
0000476A 4229 0000                  		clr.b	oAngle(a1)			; Clear the player's angle
0000476E 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004772 3369 001C 0000             		move.w	oXVel(a1),oGVel(a1)		; Set the player's X velocity as its ground velocity
00004778 08E9 0003 0028             		bset	#cStandBit,oStatus(a1)		; Set the player's standing on object bit
0000477E 08E8 0003 0028             		bset	#cStandBit,oStatus(a0)		; Set the player standing on this object bir
00004784 08A9 0001 0028             		bclr	#1,oStatus(a1)			; Clear the player's in midair bit
0000478A 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
0000478C 2F08                       		move.l	a0,-(sp)			; Store the current object's address
0000478E 2049                       		movea.l	a1,a0				; Replace it with the player's address
00004790 6100 E5EE                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
00004794 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
00004796                            
00004796                            PlatformObject_End:
00004796 4E75                       		rts
00004798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004798                            ; Set an object as a solid slope and check for collision
00004798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004798                            ; PARAMETERS:
00004798                            ;	d1.w	- Object width
00004798                            ;	d3.w	- Object height
00004798                            ;	d4.w	- Object x-axis position
00004798                            ;	a0.l	- Object space pointer
00004798                            ;	a2.l	- Slope height data pointer
00004798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004798                            ; RETURNS:
00004798                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004798                            SlopedPlatform:
00004798 7C00                       		moveq	#0,d6				; Clear collision flag register
0000479A 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
0000479E 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
000047A4 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
000047A8 3401                       		move.w	d1,d2				; Copy the object's width
000047AA D442                       		add.w	d2,d2				; Double it
000047AC 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000047B2 6600                       		bne.s	.NotOnTop			; If so, branch
000047B4 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000047B8 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000047BC D041                       		add.w	d1,d0				; Add width
000047BE 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000047C0 B042                       		cmp.w	d2,d0				; Compare with the width
000047C2 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000047C4                            
000047C4                            .NotOnTop:
000047C4 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000047CA 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000047D0 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000047D6 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000047DA 7800                       		moveq	#0,d4				; Set the collision status to 0
000047DC 4E75                       		rts
000047DE                            
000047DE                            .OnTop:
000047DE 3404                       		move.w	d4,d2				; Copy X position
000047E0 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
000047E4 7800                       		moveq	#0,d4				; Set the collision status to 0
000047E6 4E75                       		rts
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            SlopedPlarform_ChkCol:
000047E8 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000047EC 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
000047F0 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000047F4 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000047F8 D041                       		add.w	d1,d0				; Add width
000047FA 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000047FE D241                       		add.w	d1,d1				; Double width
00004800 B041                       		cmp.w	d1,d0				; Compare with width
00004802 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004806 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
0000480C 6700                       		beq.s	.NoXFlip			; If not, skip
0000480E 4640                       		not.w	d0				; Logical notation
00004810 D041                       		add.w	d1,d0				; Add width
00004812                            
00004812                            .NoXFlip:
00004812 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004814 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
00004818 4883                       		ext.w	d3				; Sign extend to word
0000481A 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
0000481E 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
00004820 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004824                            ; Move the player along a platform/solid object
00004824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004824                            ; PARAMETERS:
00004824                            ;	d2.w	- X position of the platform
00004824                            ;	d3.w	- Height of the platform
00004824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004824                            ; RETURNS:
00004824                            ;	Nothing
00004824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004824                            PlayerMoveOnPtfm:
00004824 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
00004828 9043                       		sub.w	d3,d0				; Subtract height
0000482A 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000482E 6B00                       		bmi.s	.End				; If so, branch
00004830 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004836 6400                       		bcc.s	.End				; If so, branch
00004838 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
0000483C 6600                       		bne.s	.End				; If so, branch
0000483E 7200                       		moveq	#0,d1
00004840 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004844 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004846 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000484A 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
0000484E 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004852                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004852                            		;beq.s	.End				; If not branch
00004852                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004852                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004852                            
00004852                            .End:
00004852 4E75                       		rts
00004854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004854                            ; Move the player along a sloped platform/solid object
00004854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004854                            ; PARAMETERS:
00004854                            ;	d3.w	- Height of the platform
00004854                            ;	d4.w	- X position of the platform
00004854                            ;	a2.l	- Slope height data pointer
00004854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004854                            ; RETURNS:
00004854                            ;	Nothing
00004854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004854                            PlayerMoveOnSlope:
00004854 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000485A 6700                       		beq.s	.End				; If not, branch
0000485C 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004860 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004864 D041                       		add.w	d1,d0				; Add width
00004866 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004868 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
0000486E 6700                       		beq.s	.NoXFlip			; If not, branch
00004870 4640                       		not.w	d0				; Logical notation on d0
00004872 D041                       		add.w	d1,d0				; Add width
00004874                            
00004874                            .NoXFlip:
00004874 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
00004878 4881                       		ext.w	d1				; Sign extend to word
0000487A 3028 0018                  		move.w	oYPos(a0),d0			; Get current object's Y position
0000487E 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004880 7200                       		moveq	#0,d1
00004882 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004886 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004888 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000488C 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004890 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004894                            
00004894                            .End:
00004894 4E75                       		rts
00004896                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004896                            ; Do object collision for the player object
00004896                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004896                            PlayerDoObjCollision:
00004896 4EB8 3E28                  		jsr	PlayerRingCollision		; Do ring collision
0000489A                            		
0000489A 3428 0014                  		move.w	oXPos(a0),d2			; Get X position
0000489E 3628 0018                  		move.w	oYPos(a0),d3			; Get Y position
000048A2 5142                       		subq.w	#8,d2				; Get left sensor X
000048A4 7A00                       		moveq	#0,d5
000048A6 1A28 002D                  		move.b	oColH(a0),d5			; Get collision height
000048AA 5705                       		subq.b	#3,d5				; Subtract 3
000048AC 9645                       		sub.w	d5,d3				; Get left sensor Y
000048AE 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
000048B2 DA45                       		add.w	d5,d5				; Get right sensor delta Y
000048B4                            
000048B4 49F8 F354                  		lea	rColList.w,a4			; Get collision response list
000048B8 3C1C                       		move.w	(a4)+,d6			; Get count
000048BA 6700                       		beq.s	.End				; If there are no objects to test, branch
000048BC                            
000048BC                            .ObjLoop:
000048BC 325C                       		movea.w	(a4)+,a1			; Get object
000048BE 1029 002A                  		move.b	oColType(a1),d0			; Does touching it do anything?
000048C2 6600                       		bne.s	.ChkPosition			; If so, branch
000048C4                            
000048C4                            .NextObj:
000048C4 5546                       		subq.w	#2,d6				; Decrement count
000048C6 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
000048C8 7000                       		moveq	#0,d0				; Reset d0
000048CA                            
000048CA                            .End:
000048CA 4278 F354                  		clr.w	rColList.w			; Clear the collision response list count
000048CE 4E75                       		rts
000048D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048D0                            .ChkPosition:
000048D0 7200                       		moveq	#0,d1
000048D2 1229 002C                  		move.b	oColW(a1),d1			; Get object width
000048D6 3029 0014                  		move.w	oXPos(a1),d0			; Get object X position
000048DA 9041                       		sub.w	d1,d0				; Get left side of object
000048DC 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
000048DE 6400                       		bcc.s	.ChkRightSide			; If so, branch
000048E0 D241                       		add.w	d1,d1				; Get right side delta X
000048E2 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
000048E4 6500                       		bcs.s	.ChkHeight			; If not, branch
000048E6 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
000048E8                            
000048E8                            .ChkRightSide:
000048E8 B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
000048EA 62D8                       		bhi.s	.NextObj			; If not, branch
000048EC                            
000048EC                            .ChkHeight:
000048EC 7200                       		moveq	#0,d1
000048EE 1229 002D                  		move.b	oColH(a1),d1			; Get object height
000048F2 3029 0018                  		move.w	oYPos(a1),d0			; Get object Y position
000048F6 9041                       		sub.w	d1,d0				; Get top of object
000048F8 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
000048FA 6400                       		bcc.s	.ChkBottom			; If so, branch
000048FC D241                       		add.w	d1,d1				; Get bottom delta Y
000048FE D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004900 6500                       		bcs.s	.ChkType			; If not, branch
00004902 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004904                            
00004904                            .ChkBottom:
00004904 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
00004906 62BC                       		bhi.s	.NextObj			; If not, branch
00004908                            
00004908                            .ChkType:
00004908 7000                       		moveq	#0,d0
0000490A 1029 002A                  		move.b	oColType(a1),d0			; Get collision type
0000490E 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004912                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004912                            .CollisionTypes:
00004912 6000                       		bra.s	.Enemy				; Enemy
00004914 6000                       		bra.s	.Indestructable			; Indestructable
00004916 6000                       		bra.s	.Monitor			; Monitor
00004918                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004918                            .Enemy:
00004918 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
0000491E 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004922                            
00004922                            .ChkBoss:
00004922 4A29 002B                  		tst.b	oHitCnt(a1)			; Do we have a hit count?
00004926 6700                       		beq.s	.Kill				; If not, branch
00004928 4468 001C                  		neg.w	oXVel(a0)			; Bounce backwards
0000492C 4468 001E                  		neg.w	oYVel(a0)			; ''
00004930 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004934 5329 002B                  		subq.b	#1,oHitCnt(a1)			; Decrement hit count
00004938 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
0000493A 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
00004940                            
00004940                            .BossEnd:
00004940 4E75                       		rts
00004942                            
00004942                            .Kill:
00004942 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
00004948 22BC 0000 0000             		move.l	#ObjExplosion,oAddr(a1)		; Change into an explosion
0000494E 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004952 4229 0025                  		clr.b	oRoutine(a1)			; Reset the routine ID
00004956 4A68 001E                  		tst.w	oYVel(a0)			; Are we going up?
0000495A 6B00                       		bmi.s	.MoveDown			; If so, branch
0000495C 3028 0018                  		move.w	oYPos(a0),d0			; Are we below the object?
00004960 B069 0018                  		cmp.w	oYPos(a1),d0			; ''
00004964 6400                       		bhs.s	.MoveUp				; If so, branch
00004966 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
0000496A 4E75                       		rts
0000496C                            
0000496C                            .MoveDown:
0000496C 0668 0100 001E             		addi.w	#$100,oYVel(a0)			; Move down
00004972 4E75                       		rts
00004974                            
00004974                            .MoveUp:
00004974 0468 0100 001E             		subi.w	#$100,oYVel(a0)			; Move up
0000497A 4E75                       		rts
0000497C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000497C                            .Indestructable:
0000497C 6000                       		bra.s	.ChkHurt			; Get hurt
0000497E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000497E                            .Monitor:
0000497E 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00004982 6A00                       		bpl.s	.ChkDestroy			; If it's falling or staying still, branch
00004984 3028 0018                  		move.w	oYPos(a0),d0			; Get player's Y position
00004988 0440 0010                  		subi.w	#$10,d0				; Subtract 16
0000498C B069 0018                  		cmp.w	oYPos(a1),d0			; Is the plyaer hitting the bottom of the object?
00004990 6500                       		blo.s	.MonitorEnd			; If not, branch
00004992 337C FE80 001E             		move.w	#-$180,oYVel(a1)		; Bounce the monitor up
00004998 4A29 0000                  		tst.b	oMonFall(a1)			; Is it already falling?
0000499C 6600                       		bne.s	.MonitorEnd			; If so, branch
0000499E 50E9 0000                  		st	oMonFall(a1)			; Set the fall flag
000049A2 4E75                       		rts
000049A4                            
000049A4                            .ChkDestroy:
000049A4 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
000049AA 6600                       		bne.s	.MonitorEnd			; If not, branch
000049AC 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
000049B0 22BC 0000 0000             		move.l	#ObjMonitorBreakOpen,oAddr(a1)	; Set to destroyed routine
000049B6                            		
000049B6                            .MonitorEnd:
000049B6 4E75                       		rts
000049B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049B8                            .ChkHurt:
000049B8 4A68 0000                  		tst.w	oInvulTime(a0)			; Are we invulnerable?
000049BC 6600                       		bne.s	.NoHurt				; If so, branch
000049BE 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
000049C0 4EF9 0000 0000             		jmp	ObjMighty_GetHurt		; Get hurts
000049C6                            
000049C6                            .NoHurt:
000049C6 4E75                       		rts
000049C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049C8                            ; Add a new entry to the collision response list
000049C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049C8                            AddToColResponse:
000049C8 43F8 F354                  		lea	rColList.w,a1			; Get collision response list
000049CC 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
000049D0 6400                       		bhs.s	.End				; If so, branch
000049D2 5451                       		addq.w	#2,(a1)				; Add a new entry
000049D4 D2D1                       		adda.w	(a1),a1				; Get entry pointer
000049D6 3288                       		move.w	a0,(a1)				; Store entry
000049D8                            
000049D8                            .End:
000049D8 4E75                       		rts
000049DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DA                            ; Save some info in a level (mainly for checkpoints)
000049DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DA                            ; PARAMETERS:
000049DA                            ;	a0.l	- Object space pointer
000049DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DA                            ; RETURNS:
000049DA                            ;	Nothing
000049DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DA                            Level_SaveInfo:
000049DA 31E8 0014 C7B0             		move.w	oXPos(a0),rSavedXPos.w		; Save X position
000049E0 31E8 0018 C7B2             		move.w	oYPos(a0),rSavedYPos.w		; Save Y position
000049E6 4E75                       		rts
000049E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049E8                            ; Load some info in a level (mainly for checkpoints)
000049E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049E8                            ; PARAMETERS:
000049E8                            ;	a0.l	- Object space pointer
000049E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049E8                            ; RETURNS:
000049E8                            ;	Nothing
000049E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049E8                            Level_LoadSavedInfo:
000049E8 3178 C7B0 0014             		move.w	rSavedXPos.w,oXPos(a0)		; Load X position
000049EE 3178 C7B2 0018             		move.w	rSavedYPos.w,oYPos(a0)		; Load Y position
000049F4 4E75                       		rts
000049F6                            ; =========================================================================================================================================================
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            ; Music IDs
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            Level_MusicIDs:
000049F6 0B0B                       		dc.b	mWWZ, mWWZ
000049F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F8                            ; Level water heights (-1 for no water)
000049F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F8                            Level_WaterLevels:
000049F8                            		;dc.w	$490, -1			; Wacky Workbench
000049F8 FFFF FFFF                  		dc.w	-1, -1
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            ; Level data pointers
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            ; FORMAT:
000049FC                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
000049FC                            ;	dc.l	LAYOUT, OBJECTS, RINGS, COLLISION
000049FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FC                            Level_DataPointers:
000049FC 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A0C 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A1C 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A2C 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A3C                            ; Size and start position data
00004A3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A3C                            Level_SizeStartPos:
00004A3C 3000 0580                  		dc.w	$3000, $580
00004A40                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A44 3000 0580                  		dc.w	$3000, $580
00004A48                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A4C                            ; Dynamic events routines
00004A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A4C                            Level_DynEvenRouts:
00004A4C 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004A50 0000 0000                  		dc.l	DynEv_WWZ
00004A54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A54                            ; Wacky Workbench dynamic events routine
00004A54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A54                            DynEv_WWZ:
00004A54 7000                       		moveq	#0,d0
00004A56 1038 F8FE                  		move.b	rDynEvRout.w,d0
00004A5A 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004A5E 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A62                            .Index:
00004A62 0000                       		dc.w	.WaitBoss-.Index
00004A64 0000                       		dc.w	.Done-.Index
00004A66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A66                            .WaitBoss:
00004A66 0C78 2EE0 F880             		cmpi.w	#$2EE0,rCamXPos.w
00004A6C 6D00                       		blt.s	.Done
00004A6E 31FC 0340 F8CA             		move.w	#$340,rMinCamY.w
00004A74 31FC 0340 F8BE             		move.w	#$340,rDestMaxY.w
00004A7A 31FC 2EE0 F8C8             		move.w	#$2EE0,rMinCamX.w
00004A80 31FC 2EE0 F8C0             		move.w	#$2EE0,rMaxCamX.w
00004A86 5438 F8FE                  		addq.b	#2,rDynEvRout.w
00004A8A                            
00004A8A                            .Done:
00004A8A 4E75                       		rts
00004A8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8C                            ; Palette cycle routines
00004A8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8C                            Level_PalCycRouts:
00004A8C 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004A90 0000 0000                  		dc.l	PalCycle_WWZ
00004A94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A94                            ; Wacky Workbench palette cycle routine
00004A94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A94                            PalCycle_WWZ:
00004A94 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
00004A98 6600                       		bne.s	.Flash				; If so, branch
00004A9A                            
00004A9A 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004A9E 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004AA0 50F8 F8FF                  		st	rFloorActive.w		; Set the floor active flag
00004AA4 31FC 00B4 F900             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004AAA                            
00004AAA                            .ResetPal:
00004AAA 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset the palette cycle
00004AAE 31FC 0C28 9930             		move.w	#$C28,(rPalette+$62).w		; Set the floor color to be deactivated
00004AB4 31FC 0E48 98B0             		move.w	#$E48,(rWaterPal+$62).w	; ''
00004ABA 4E75                       		rts
00004ABC                            
00004ABC                            .Flash:
00004ABC 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004AC0 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004AC2 4238 F8FF                  		clr.b	rFloorActive.w		; Clear the floor active flag
00004AC6 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004ACC                            
00004ACC                            .UpdatePal:
00004ACC 5338 C7CE                  		subq.b	#1,rPalCycTimer.w		; Decrement the palette cycle timer
00004AD0 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004AD2 11FC 0001 C7CE             		move.b	#1,rPalCycTimer.w		; Reset the palette cycle timer
00004AD8                            
00004AD8 7000                       		moveq	#0,d0
00004ADA 1038 C7CF                  		move.b	rPalCycIndex.w,d0		; Get the palette cycle index
00004ADE D040                       		add.w	d0,d0				; Turn into offset
00004AE0                            							; Set the floor color
00004AE0 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(rPalette+$62).w
00004AE6 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(rWaterPal+$62).w
00004AEC                            
00004AEC 5238 C7CF                  		addq.b	#1,rPalCycIndex.w		; Increment the palette cycle index
00004AF0 0C38 0005 C7CF             		cmpi.b	#5,rPalCycIndex.w		; Has it reached the end of the cycle?
00004AF6 6500                       		bcs.s	.End				; If not, branch
00004AF8 4238 C7CF                  		clr.b	rPalCycIndex.w		; Reset the palette cycle index
00004AFC                            
00004AFC                            .End:
00004AFC 4E75                       		rts
00004AFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AFE                            PalCyc_WWZFloor:
00004AFE 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004B08                            PalCyc_WWZFloorUW:
00004B08 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004B12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B12                            ; Animated art routines
00004B12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B12                            Level_AniArtRouts:
00004B12 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004B16 0000 0000                  		dc.l	AniArt_WWZ
00004B1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B1A                            ; Wacky Workbench animated art routine
00004B1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B1A                            AniArt_WWZ:
00004B1A 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004B1E 6000 F81E                  		bra.w	AniArt_DoAnimate		; Handle animations
00004B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B22                            .AniData:
00004B22 0002                       		dc.w	2
00004B24                            
00004B24                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004B24 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004B28 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004B2A 0408                     M 	dc.b	4,8
00004B2C 0008 1018                  		dc.b	0, 8, $10, $18
00004B30                            
00004B30                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004B30 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004B34 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004B36 0E04                     M 	dc.b	$e,4
00004B38 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004B46                            
00004B46                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004B46 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004B4A 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004B4C 0804                     M 	dc.b	8,4
00004B4E 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B56                            ; Level drawing initialization and update routines
00004B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B56                            ; PARAMETERS:
00004B56                            ;	a1.l	- Camera RAM
00004B56                            ;	a3.l	- Row plane buffer
00004B56                            ;	a4.l	- Column plane buffer
00004B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B56                            ; RETURNS:
00004B56                            ;	Nothing
00004B56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B56                            Level_RenderRouts:
00004B56 0000 271E                  		dc.l	General_InitFG			; Wacky Workbench
00004B5A 0000 0000                  		dc.l	WWZ_InitBG
00004B5E 0000 273E                  		dc.l	General_UpdateFG
00004B62 0000 0000                  		dc.l	WWZ_UpdateBG
00004B66 0000 271E                  		dc.l	General_InitFG
00004B6A 0000 0000                  		dc.l	WWZ_InitBG
00004B6E 0000 273E                  		dc.l	General_UpdateFG
00004B72 0000 0000                  		dc.l	WWZ_UpdateBG
00004B76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B76                            ; Wacky Workbench background initialization
00004B76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B76                            WWZ_InitBG:
00004B76 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004B7A 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004B7E E440                       		asr.w	#2,d0				; Divide by $20
00004B80 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004B84                            
00004B84 6100 DED2                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004B88                            
00004B88 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004B8C 6000 DF2A                  		bra.w	ScrollSections			; Scroll the planes
00004B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B90                            ; Wacky Workbench background update
00004B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B90                            WWZ_UpdateBG:
00004B90 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004B94 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004B98 E440                       		asr.w	#2,d0				; Divide by $20
00004B9A 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004B9E                            
00004B9E 6100 DF0A                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004BA2 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004BA4 6100 DCAA                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004BA8                            
00004BA8 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004BAC 6000 DF0A                  		bra.w	ScrollSections			; Scroll the planes
00004BB0                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004BB0                            		scrollInit WWZ_Scroll
00004BB0                          M scroll_label	equs	"wwz_scroll"
00004BB0 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004BB2                            
00004BB2                            		; CEILING LIGHTS
00004BB2                            		scrollSection	 48, $80
00004BB2 0080 0000 0030           M 	dc.w	$80,0,48
00004BB8                            		scrollSection	 32, $60
00004BB8 0060 0000 0020           M 	dc.w	$60,0,32
00004BBE                            		scrollSection	 32, $50
00004BBE 0050 0000 0020           M 	dc.w	$50,0,32
00004BC4                            		scrollSection	 24, $40
00004BC4 0040 0000 0018           M 	dc.w	$40,0,24
00004BCA                            		scrollSection	 24, $38
00004BCA 0038 0000 0018           M 	dc.w	$38,0,24
00004BD0                            		scrollSection	 16, $30
00004BD0 0030 0000 0010           M 	dc.w	$30,0,16
00004BD6                            		scrollSection	 16, $2C
00004BD6 002C 0000 0010           M 	dc.w	$2c,0,16
00004BDC                            		scrollSection	 16, $28
00004BDC 0028 0000 0010           M 	dc.w	$28,0,16
00004BE2                            		scrollSection	 16, $24
00004BE2 0024 0000 0010           M 	dc.w	$24,0,16
00004BE8                            		scrollSection	 16, $20
00004BE8 0020 0000 0010           M 	dc.w	$20,0,16
00004BEE                            
00004BEE                            		; BACK WALL
00004BEE                            		scrollSection	160, $40
00004BEE 0040 0000 00A0           M 	dc.w	$40,0,160
00004BF4                            
00004BF4                            		; FRONT WALL
00004BF4                            		scrollSection	368, $80
00004BF4 0080 0000 0170           M 	dc.w	$80,0,368
00004BFA                            
00004BFA                            		scrollEnd
00004BFA                          M wwz_scroll_end:
00004BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BFA                            ; Wacky Workbench level data
00004BFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BFA                            WWZ_Layout:
00004BFA                            		incbin	"Level/Level Data/Wacky Workbench/Layout.bin"
00004DD8                            		even
00004DD8                            WWZ_Chunks:
00004DD8                            		incbin	"Level/Level Data/Wacky Workbench/Chunks.bin"
00005828                            		even
00005828                            WWZ_Blocks:
00005828                            		incbin	"Level/Level Data/Wacky Workbench/Blocks.bin"
00005EEE                            		even
00005EEE                            WWZ_Tiles:
00005EEE                            		incbin	"Level/Level Data/Wacky Workbench/Tiles.kosm.bin"
0000761C                            		even
0000761C FFFF 0000 0000             		dc.w	$FFFF, 0, 0
00007622                            WWZ_Objects:
00007622                            		incbin	"Level/Level Data/Wacky Workbench/Objects.bin"
000077DE                            		even
000077DE                            WWZ_Rings:
000077DE                            		incbin	"Level/Level Data/Wacky Workbench/Rings.bin"
00007AAE                            		even
00007AAE                            WWZ_Pal:
00007AAE 007F                       		dc.w	$100>>1-1
00007AB0                            		incbin	"Level/Level Data/Wacky Workbench/Palette.pal.bin"
00007B30                            		incbin	"Level/Level Data/Wacky Workbench/Palette (Water).pal.bin"
00007BB0                            		even
00007BB0                            WWZ_Collision:
00007BB0 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
00007BC0                            .ColData:
00007BC0                            		incbin	"Level/Level Data/Wacky Workbench/Collision.bin"
000081C0                            		even
000081C0                            .Angles:
000081C0                            		incbin	"Level/Level Data/Wacky Workbench/Angle Values.bin"
000082C0                            		even
000082C0                            .Heights:
000082C0                            		incbin	"Level/Level Data/Wacky Workbench/Height Values.bin"
000092C0                            		even
000092C0                            .HeightsR:
000092C0                            		incbin	"Level/Level Data/Wacky Workbench/Height Values (Rotated).bin"
0000A2C0                            		even
0000A2C0                            ArtUnc_Electricity:
0000A2C0                            		incbin	"Level/Level Data/Wacky Workbench/Electricity.bin"
0000A6C0                            		even
0000A6C0                            ArtUnc_ElectricOrbs:
0000A6C0                            		incbin	"Level/Level Data/Wacky Workbench/Electric Orbs.bin"
0000A8C0                            		even
0000A8C0                            ArtUnc_Sirens:
0000A8C0                            		incbin	"Level/Level Data/Wacky Workbench/Sirens.bin"
0000AAC0                            		even
0000AAC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAC0                            ; Main level PLCs
0000AAC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAC0                            PLC_LevelMain:
0000AAC0 000A                       		dc.w	$A
0000AAC2 0000 0000                  		dc.l	ArtKosM_Chkpoint
0000AAC6 AFC0                       		dc.w	$AFC0
0000AAC8 0000 0000                  		dc.l	ArtKosM_Monitor
0000AACC B100                       		dc.w	$B100
0000AACE 0000 0000                  		dc.l	ArtKosM_SpringH
0000AAD2 B740                       		dc.w	$B740
0000AAD4 0000 0000                  		dc.l	ArtKosM_SpringV
0000AAD8 B940                       		dc.w	$B940
0000AADA 0000 0000                  		dc.l	ArtKosM_SpringD
0000AADE BB20                       		dc.w	$BB20
0000AAE0 0000 0000                  		dc.l	ArtKosM_HUD
0000AAE4 D000                       		dc.w	$D000
0000AAE6 0000 0000                  		dc.l	ArtKosM_WaterSurface
0000AAEA D200                       		dc.w	$D200
0000AAEC 0000 0000                  		dc.l	ArtKosM_SpikesN
0000AAF0 D500                       		dc.w	$D500
0000AAF2 0000 0000                  		dc.l	ArtKosM_SpikesS
0000AAF6 D580                       		dc.w	$D580
0000AAF8 0000 0000                  		dc.l	ArtKosM_RingSparkle
0000AAFC D700                       		dc.w	$D700
0000AAFE 0000 0000                  		dc.l	ArtKosM_Explosion
0000AB02 D800                       		dc.w	$D800
0000AB04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB04                            ; Level PLCs
0000AB04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB04                            Level_PLCs:
0000AB04 0000 0000                  		dc.l	PLC_WWZ
0000AB08 0000 0000                  		dc.l	PLC_WWZ
0000AB0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB0C                            ; Wacky Workbench PLCs
0000AB0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB0C                            PLC_WWZ:
0000AB0C 0000                       		dc.w	0
0000AB0E 0000 0000                  		dc.l	ArtKosM_Bumper
0000AB12 6B60                       		dc.w	$6B60
0000AB14                            	;	dc.l	ArtKosM_Orbinaut
0000AB14                            	;	dc.w	$71A0
0000AB14                            	;	dc.l	ArtKosM_Diamond
0000AB14                            	;	dc.w	$7580
0000AB14                            	;	dc.l	ArtKosM_CNZBarrel
0000AB14                            	;	dc.w	$7A00
0000AB14                            	;	dc.l	ArtKosM_Slicer
0000AB14                            	;	dc.w	$8000
0000AB14                            	;	dc.l	ArtKosM_ShlCrker
0000AB14                            	;	dc.w	$8400
0000AB14                            	;	dc.l	ArtKosM_Asteron
0000AB14                            	;	dc.w	$8880
0000AB14                            	;	dc.l	ArtKosM_Harpoon
0000AB14                            	;	dc.w	$8A60
0000AB14                            	;	dc.l	ArtKosM_WFZBoss
0000AB14                            	;	dc.w	$9000
0000AB14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB14                            ; Art
0000AB14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB14                            ArtKosM_HUD:
0000AB14                            		incbin	"Level/Objects/HUD/Art - HUD Base.kosm.bin"
0000AB8A                            		even
0000AB8A                            ArtKosM_RingSparkle:
0000AB8A                            		incbin	"Level/Objects/Ring/Art - Sparkle.kosm.bin"
0000ABD6 00                         		even
0000ABD6                            ArtUnc_Ring:
0000ABD6                            		incbin	"Level/Objects/Ring/Art - Ring.unc.bin"
0000AFD6                            		even
0000AFD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFD6                            ; Object index
0000AFD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFD6                            Level_ObjIndex:
0000AFD6 0000 0000                  		dc.l	ObjMonitor
0000AFDA 0000 0000                  		dc.l	ObjSpike
0000AFDE 0000 0000                  		dc.l	ObjSpring
0000AFE2 0000 0000                  		dc.l	ObjCheckpoint
0000AFE6 0000 0000                  		dc.l	ObjNull			;ObjSlicer
0000AFEA 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
0000AFEE 0000 0000                  		dc.l	ObjNull			;ObjAsteron
0000AFF2 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
0000AFF6 0000 0000                  		dc.l	ObjWallSpring
0000AFFA 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
0000AFFE 0000 0000                  		dc.l	ObjBallMode
0000B002 0000 0000                  		dc.l	ObjBumper
0000B006 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
0000B00A 0000 0000                  		dc.l	ObjNull			;ObjDiamond
0000B00E 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
0000B012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B012                            ; Objects
0000B012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B012                            ObjNull:
0000B012 4EF8 19F2                  		jmp	DeleteObject
0000B016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B016                            		include	"Level/Objects/Mighty/Code.asm"		; Mighty object
0000B016                            ; =========================================================================================================================================================
0000B016                            ; Mighty The Armadillo in PRISM PARADISE
0000B016                            ; By Nat The Porcupine 2021
0000B016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B016                            ; Sonic object
0000B016                            ; =========================================================================================================================================================
0000B016 =00000600                  TOP_SPD		EQU	$600				; Top speed
0000B016 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
0000B016 =00000080                  DEC_SPD		EQU	$80				; Deceleration
0000B016 =00000680                  JUMP_HEIGHT	EQU	$680				; Jump height
0000B016 =00000400                  MIN_JMP_HEIGHT	EQU	$400				; Minimum jump height
0000B016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B016                            		rsset	oLvlSSTs
0000B016 =00000030                  oInitColH	rs.b	1				; Initial collision height
0000B016 =00000031                  oInitColW	rs.b	1				; Initial collision width
0000B016 =00000032                  oTopSolid	rs.b	1				; Top solid bit
0000B016 =00000033                  oLRBSolid	rs.b	1				; LRB solid bit
0000B016 =00000034                  oTopSpd		rs.w	1				; Top speed
0000B016 =00000036                  oAcc		rs.w	1				; Acceleration
0000B016 =00000038                  oDec		rs.w	1				; Deceleration
0000B016 =0000003A                  oFlipDir	rs.w	0				; Flip direction
0000B016 =0000003A                  oGVel		rs.w	1				; Ground velocity
0000B016 =0000003C                  oInteract	rs.w	1				; Interacted object space pointer
0000B016 =0000003E                  oAirTimer	rs.b	1				; Air timer
0000B016 =0000003F                  oMoveLock	rs.b	1				; Move lock timer
0000B016 =00000040                  oJumping	rs.b	1				; Jumping flag
0000B016 =00000041                  oAngle		rs.b	1				; Angle
0000B016 =00000042                  oInvulTime	rs.b	1				; Invulnerability timer
0000B016 =00000043                  oDeathTimer	rs.b	1				; Death timer
0000B016 =00000044                  oScrlDelay	rs.b	1				; Look up and down scroll delay counter
0000B016 =00000045                  oDashFlag	rs.b	1				; Dash flags
0000B016 =00000046                  oDashTimer	rs.b	1				; Dash timer
0000B016 =00000047                  oFlipAngle	rs.b	1				; Flip angle about the X axis
0000B016 =00000048                  oFlipTurned	rs.b	1				; Inverted flip flag
0000B016 =00000049                  oFlipRemain	rs.b	1				; Remaining flips to do
0000B016 =0000004A                  oFlipSpeed	rs.b	1				; Flip speed
0000B016 =0000004B                  oBallMode	rs.b	1				; Ball mode flag
0000B016 =0000004C                  oHangAniTime	rs.b	1				; Hang animation timer
0000B016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B016                            ObjMighty:
0000B016 7000                       		moveq	#0,d0
0000B018 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0000B01C 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0000B020                            	nextObject
0000B020 3068 0004                M 	movea.w	onext(a0),a0
0000B024 2250                     M 	move.l	oaddr(a0),a1
0000B026 4ED1                     M 	jmp	(a1)
0000B028                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B028                            .Index:
0000B028 6000 0000                  		bra.w	ObjMighty_Init			; Initialization(00)
0000B02C 6000 0000                  		bra.w	ObjMighty_Main			; Main		(04)
0000B030 6000 0000                  		bra.w	ObjMighty_Hurt			; Hurt		(08)
0000B034 6000 0000                  		bra.w	ObjMighty_Dead			; Dead		(0C)
0000B038 6000 0000                  		bra.w	ObjMighty_Gone			; Gone		(10)
0000B03C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03C                            ; Initialization routine
0000B03C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03C                            ObjMighty_Init:
0000B03C 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0000B040                            
0000B040 117C 0009 002C             		move.b	#9,oColW(a0)			; Collision width
0000B046 117C 0013 002D             		move.b	#$13,oColH(a0)			; Collision height
0000B04C 1168 002C 0031             		move.b	oColW(a0),oInitColW(a0)		; Set initial collision width
0000B052 1168 002D 0030             		move.b	oColH(a0),oInitColH(a0)		; Set initial collision height
0000B058 217C 0000 0000 0010        		move.l	#Map_ObjMighty,oMap(a0)		; Mappings
0000B060 317C 0780 000E             		move.w	#$780,oVRAM(a0)			; Sprite tile properties
0000B066                            	displaySprite	2,a0,a1,0			; Priority
0000B066 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000B06C 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000B070 3149 000A                M 	move.w	a1,odrawprev(a0)
0000B074 3348 0008                M 	move.w	a0,odrawnext(a1)
0000B078 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000B07C                          M .no_199
0000B07C 117C 0018 0017             		move.b	#$18,oDrawW(a0)			; Sprite width
0000B082 117C 0018 001B             		move.b	#$18,oDrawH(a0)			; Sprite height
0000B088 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0000B08E                            
0000B08E 117C 000C 0032             		move.b	#$C,oTopSolid(a0)		; Top solid bit
0000B094 117C 000D 0033             		move.b	#$D,oLRBSolid(a0)		; LRB solid bit
0000B09A 117C 001E 003E             		move.b	#$1E,oAirTimer(a0)		; Set air timer
0000B0A0 50D0                       		st	oPrevDPLC(a0)			; Reset saved DPLC frame
0000B0A2 4228 0049                  		clr.b	oFlipRemain(a0)			; No flips remaining
0000B0A6 117C 0004 004A             		move.b	#4,oFlipSpeed(a0)		; Flip speed
0000B0AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0AC                            ; Main routine
0000B0AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0AC                            ObjMighty_Main:
0000B0AC 4A38 C768                  		tst.b	rMoveCheat.w
0000B0B0 6700                       		beq.s	.NoPlacementEnter
0000B0B2 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000B0B8 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000B0BA 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000B0C0 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000B0C6 4E75                       		rts
0000B0C8                            
0000B0C8                            .NoPlacementEnter:
0000B0C8 0828 0002 000C             		btst	#2,oFlags(a0)			; Are the controls locked?
0000B0CE 6600                       		bne.s	.Update				; If so, branch
0000B0D0 31F8 C740 F8D4             		move.w	rP1Data.w,rCtrl.w		; Set the player's control data
0000B0D6                            
0000B0D6                            .Update:
0000B0D6                            	;	btst	#1,oStatus(a0)
0000B0D6                            	;	bne.s	.NotOnGround
0000B0D6                            
0000B0D6                            ;.NotOnGround:
0000B0D6 6100 0000                  		bsr.w	ObjMighty_Water			; Handle Sonic in water
0000B0DA 6100 0000                  		bsr.w	ObjMighty_GetPhysics		; Update Sonic's physics
0000B0DE 6100 0000                  		bsr.w	ObjMighty_DoModes		; Do modes
0000B0E2 6100 0000                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000B0E6 4EB8 4896                  		jsr	PlayerDoObjCollision		; Do object collision
0000B0EA                            
0000B0EA 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000B0EE 6100 0000                  		bsr.w	ObjMighty_Display		; Display sprite
0000B0F2 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000B0F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0F6                            ; Handle the extended camera
0000B0F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0F6                            ObjMighty_ExtendedCam:
0000B0F6 3238 F8D2                  		move.w	rCamXPosCenter.w,d1		; Get camera X center
0000B0FA 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B0FE 6A00                       		bpl.s	.PosGVel			; Get absolute value
0000B100 4440                       		neg.w	d0				; ''
0000B102                            
0000B102                            .PosGVel:
0000B102 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
0000B106 6500                       		bcs.s	.ResetXShift			; If not, branch
0000B108 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000B10C 6A00                       		bpl.s	.MoveRight			; If so, branch
0000B10E 5441                       		addq.w	#2,d1				; Move right
0000B110 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
0000B114 6500                       		bcs.s	.SetShift			; ''
0000B116 323C 00E0                  		move.w	#$E0,d1				; ''
0000B11A 6000                       		bra.s	.SetShift			; Continue
0000B11C                            
0000B11C                            .MoveRight:
0000B11C 5541                       		subq.w	#2,d1				; Move left
0000B11E 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
0000B122 6400                       		bcc.s	.SetShift			; ''
0000B124 323C 0060                  		move.w	#$60,d1				; ''
0000B128 6000                       		bra.s	.SetShift			; Continue
0000B12A                            
0000B12A                            .ResetXShift:
0000B12A 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
0000B12E 6700                       		beq.s	.SetShift			; If so, branch
0000B130 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
0000B132 5441                       		addq.w	#2,d1				; Move back right
0000B134 6000                       		bra.s	.SetShift			; Continue
0000B136                            
0000B136                            .ReduceShift:
0000B136 5541                       		subq.w	#2,d1				; Move back left
0000B138                            
0000B138                            .SetShift:
0000B138 31C1 F8D2                  		move.w	d1,rCamXPosCenter.w		; Set camera X center
0000B13C 4E75                       		rts
0000B13E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B13E                            ; Update Sonic's physics
0000B13E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B13E                            ObjMighty_GetPhysics:
0000B13E 7000                       		moveq	#0,d0
0000B140 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000B146 6700                       		beq.s	.GetOffset			; If not, branch
0000B148 7008                       		moveq	#8,d0				; Set the underwater bit
0000B14A                            
0000B14A                            .GetOffset:
0000B14A 43FB 0000                  		lea	ObjMighty_Physics(pc,d0.w),a1	; Get pointer to correct physics values
0000B14E 2159 0034                  		move.l	(a1)+,oTopSpd(a0)		; Set top speed and acceleration
0000B152 3151 0038                  		move.w	(a1),oDec(a0)			; Set deceleration
0000B156 4E75                       		rts
0000B158                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B158                            ; Physics values
0000B158                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B158                            ; FORMAT:
0000B158                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
0000B158                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B158                            ObjMighty_Physics:
0000B158 0600 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
0000B160 0300 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
0000B168                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B168                            ; Handle Sonic in the water
0000B168                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B168                            ObjMighty_Water:
0000B168 4A38 F8F4                  	tst.b	rWaterFlag.w			; Is there water in the level?
0000B16C 6600                       	bne.s	.HandleWater			; If so, branch
0000B16E                            
0000B16E                            .End:
0000B16E 4E75                       	rts
0000B170                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B170                            .HandleWater:
0000B170 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
0000B174 B068 0018                  		cmp.w	oYPos(a0),d0			; Is Lover in the water?
0000B178 6C00                       		bge.s	.NotInWater			; If not, branch
0000B17A                            
0000B17A 08E8 0006 0028             		bset	#6,oStatus(a0)			; Set the "in water" flag
0000B180 66EC                       		bne.s	.End				; If Lover is already in the water, branch
0000B182                            
0000B182 E0E8 001C                  		asr.w	oXVel(a0)			; Make Lover move slower
0000B186 E0E8 001E                  		asr.w	oYVel(a0)
0000B18A E0E8 001E                  		asr.w	oYVel(a0)
0000B18E 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
0000B190                            
0000B190                            		playSnd	#sSplash, 2			; Play splash sound
0000B190 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B196 4E75                       		rts
0000B198                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B198                            .NotInWater:
0000B198 08A8 0006 0028             		bclr	#6,oStatus(a0)			; Clear "in water" flag
0000B19E 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
0000B1A0                            
0000B1A0 0C28 0010 0025             		cmpi.b	#$10,oRoutine(a0)			; Is Lover falling back from getting hurt?
0000B1A6 6700                       		beq.s	.ChkSplash			; If so, branch
0000B1A8 E1E8 001E                  		asl	oYVel(a0)			; Make Lover move faster vertically
0000B1AC                            
0000B1AC                            .ChkSplash:
0000B1AC 4A68 001E                  		tst.w	oYVel(a0)			; Does a splash need to be created?
0000B1B0 67BC                       		beq.s	.End				; If not, branch
0000B1B2                            
0000B1B2 0C68 F000 001E             		cmpi.w	#-$1000,oYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
0000B1B8 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
0000B1BA 317C F000 001E             		move.w	#-$1000,oYVel(a0)		; Cap the speed
0000B1C0                            
0000B1C0                            .PlaySplashSnd:
0000B1C0                            		playSnd	#sSplash, 2			; Play splash sound
0000B1C0 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B1C6 4E75                       		rts
0000B1C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1C8                            ; Do Sonic's modes
0000B1C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1C8                            ObjMighty_DoModes:
0000B1C8 0828 0000 000C             		btst	#0,oFlags(a0)			; Is running Sonic's mode disabled?
0000B1CE 6600                       		bne.s	.NoMode				; If so, branch
0000B1D0                            
0000B1D0 7000                       		moveq	#0,d0
0000B1D2 1028 0028                  		move.b	oStatus(a0),d0			; Get status
0000B1D6 0240 0006                  		andi.w	#6,d0				; Only get mode bits
0000B1DA D040                       		add.w	d0,d0
0000B1DC 4EBB 0000                  		jsr	ObjMighty_Modes(pc,d0.w)	; Jump to the right routine
0000B1E0                            
0000B1E0 6100 FF14                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000B1E4 6100 0000                  		bsr.w	ObjMighty_ChkBounce		; Check for bouncy floor collision
0000B1E8 6100 0000                  		bsr.w	ObjMighty_ChkHang		; Check for hanging
0000B1EC 6000 0000                  		bra.w	ObjMighty_ChkElectric		; Check for electricity
0000B1F0                            
0000B1F0                            .NoMode:
0000B1F0 4E75                       		rts
0000B1F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1F2                            ; Sonic's modes
0000B1F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1F2                            ObjMighty_Modes:
0000B1F2 6000 0000                  		bra.w	ObjMighty_MdGround		; Ground
0000B1F6 6000 0000                  		bra.w	ObjMighty_MdAir			; Air
0000B1FA 6000 0000                  		bra.w	ObjMighty_MdRoll		; Roll
0000B1FE 6000 0000                  		bra.w	ObjMighty_MdJump		; Jumping
0000B202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B202                            ; Ground mode
0000B202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B202                            ObjMighty_MdGround:
0000B202 6100 0000                  		bsr.w	ObjMighty_Peelout		; Handle the peelout
0000B206 6100 0000                  		bsr.w	ObjMighty_Spindash		; Handle the spindash
0000B20A 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B20E 6100 0000                  		bsr.w	ObjMighty_ChkRoll		; Check for rolling
0000B212 6100 0000                  		bsr.w	ObjMighty_MoveGround		; Do movement on the ground
0000B216 4EB8 1CCC                  		jsr	ObjectMove.w			; Allow movement
0000B21A 4EB8 320E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B21E                            
0000B21E 6100 0000                  		bsr.w	ObjMighty_SlopePush		; Affect Sonic's speed on a slope
0000B222 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B226                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B226                            ; Misc. updates
0000B226                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B226                            ObjMighty_MiscUpdates:
0000B226 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer finished?
0000B22A 6700                       		beq.s	.NoMoveLock			; If so, branch
0000B22C 5328 003F                  		subq.b	#1,oMoveLock(a0)		; Decrement the timer
0000B230                            
0000B230                            .NoMoveLock:
0000B230 4EB8 2F26                  		jsr	sub_F846
0000B234 4A41                       		tst.w	d1
0000B236 6B00 0000                  		bmi.w	ObjMighty_GetKilled
0000B23A 4EB8 31B6                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
0000B23E 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B240 6A00                       		bpl.s	.ChkRight			; If not, branch
0000B242 9368 0014                  		sub.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B246                            
0000B246                            .ChkRight:
0000B246 4EB8 303A                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
0000B24A 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B24C 6A00                       		bpl.s	.End				; If not, branch
0000B24E D368 0014                  		add.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B252                            
0000B252                            .End:
0000B252 4E75                       		rts
0000B254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B254                            ; Air and jump modes
0000B254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B254                            ObjMighty_MdJump:
0000B254                            ObjMighty_MdAir:
0000B254 4268 003C                  		clr.w	oInteract(a0)			; Sonic cannot be interacting with objects while in midair
0000B258 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; ''
0000B25E                            
0000B25E 0828 0003 000C             		btst	#3,oFlags(a0)			; Is Sonic hanging?
0000B264 6700                       		beq.s	.DoModes			; If not, branch
0000B266 6100 0000                  		bsr.w	ObjMighty_Hang			; Hang
0000B26A 6000                       		bra.s	.DoCol				; Continue
0000B26C                            
0000B26C                            .DoModes:
0000B26C 6100 0000                  		bsr.w	ObjMighty_JumpHeight		; Handle jump height
0000B270 6100 0000                  		bsr.w	ObjMighty_MoveAir		; Do movement
0000B274 4EB8 1CE6                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000B278 0C68 1000 001E             		cmpi.w	#$1000,oYVel(a0)		; Is Sonic moving down too fasr?
0000B27E 6F00                       		ble.s	.NoCap				; If not, branch
0000B280 317C 1000 001E             		move.w	#$1000,oYVel(a0)		; Cap the downward speed
0000B286                            
0000B286                            .NoCap:
0000B286 6100 0000                  		bsr.w	ObjMighty_JumpAngle		; Reset Sonic's angle in mid air
0000B28A                            
0000B28A                            .DoCol:
0000B28A 0828 0006 0028             		btst	#6,oStatus(a0)
0000B290 6700                       		beq.s	.NoWater
0000B292 0468 0028 001E             		subi.w	#$28,oYVel(a0)
0000B298                            
0000B298                            .NoWater:
0000B298 4EB8 2B94                  		jsr	PlayerChkCollision		; Check for level collision
0000B29C 6088                       		bra.s	ObjMighty_MiscUpdates
0000B29E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B29E                            ; Roll mode
0000B29E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B29E                            ObjMighty_MdRoll:
0000B29E 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B2A2 6600                       		bne.s	.NoJump				; If so, branch
0000B2A4 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B2A8                            
0000B2A8                            .NoJump:
0000B2A8 6100 0000                  		bsr.w	ObjMighty_RollSlopePush		; Push Sonic on a slope while rolling
0000B2AC 6100 0000                  		bsr.w	ObjMighty_MoveRoll		; Do movement
0000B2B0 4EB8 1CCC                  		jsr	ObjectMove.w			; Allow movement
0000B2B4 4EB8 320E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B2B8                            
0000B2B8 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B2BC 6000 FF68                  		bra.w	ObjMighty_MiscUpdates		; Do misc. updates
0000B2C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2C0                            ; Do movement on the ground
0000B2C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2C0                            ObjMighty_MoveGround:
0000B2C0 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B2C4 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B2C8 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B2CC                            
0000B2CC 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B2D0 6600 0000                  		bne.w	.ResetScr			; If so, branch
0000B2D4                            
0000B2D4 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left held?
0000B2DA 6700                       		beq.s	.NotLeft			; If so, branch
0000B2DC 6100 0000                  		bsr.w	ObjMighty_MoveLeft		; Move left
0000B2E0                            
0000B2E0                            .NotLeft:
0000B2E0 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right held?
0000B2E6 6700                       		beq.s	.NotRight			; If so, branch
0000B2E8 6100 0000                  		bsr.w	ObjMighty_MoveRight		; Move right
0000B2EC                            
0000B2EC                            .NotRight:
0000B2EC 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B2F0 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B2F4 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000B2F8 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
0000B2FC 4A68 003A                  		tst.w	oGVel(a0)			; Has Sonic already been halted?
0000B300 6600 0000                  		bne.w	.ResetScr			; If not, branch
0000B304                            
0000B304 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B30A 117C 0005 0020             		move.b	#5,oAni(a0)			; Set to ducking animation
0000B310                            
0000B310 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is Sonic standing on an object?
0000B316 6700 0000                  		beq.w	.ChkBalance			; If not, branch
0000B31A 3268 003C                  		movea.w	oInteract(a0),a1		; Get interacted object
0000B31E 4A29 0028                  		tst.b	oStatus(a1)			; Is Sonic standing on it?
0000B322 6B00                       		bmi.s	.ChkLookUp			; If not, branch
0000B324 7200                       		moveq	#0,d1
0000B326 1229 002C                  		move.b	oColW(a1),d1			; Get width of object
0000B32A 3401                       		move.w	d1,d2				; Copy it
0000B32C D442                       		add.w	d2,d2				; Double the copy
0000B32E 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
0000B330 D268 0014                  		add.w	oXPos(a0),d1			; Add Sonic's X position
0000B334 9269 0014                  		sub.w	oXPos(a1),d1			; Subtract the object's X position
0000B338 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
0000B33C 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
0000B33E B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
0000B340 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
0000B342 6000                       		bra.s	.ChkLookUp			; Continue
0000B344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B344                            .ChkBalance:
0000B344 4EB8 2EFC                  		jsr	PlayerChkFloorDist		; Get floor distance
0000B348 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
0000B34C 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000B34E 0C28 0003 002E             		cmpi.b	#3,oNextTilt(a0)		; Is Sonic balancing on the right side?
0000B354 6600                       		bne.s	.ChkLeftBalance			; If not, branch
0000B356                            
0000B356                            .BalanceOnObjRight:
0000B356 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B35C 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000B35E                            
0000B35E                            .ChkLeftBalance:
0000B35E 0C28 0003 002F             		cmpi.b	#3,oTilt(a0)			; Is Sonic balancing on the left side?
0000B364 6600                       		bne.s	.ChkLookUp			; If not, branch
0000B366                            
0000B366                            .BalanceOnObjLeft:
0000B366 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B36C                            
0000B36C                            .SetBalanceAnim:
0000B36C 117C 0006 0020             		move.b	#6,oAni(a0)			; Set balancing animation
0000B372 6000                       		bra.s	.ResetScr			; Continue
0000B374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B374                            .ChkLookUp:
0000B374 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is the up button being held?
0000B37A 6700                       		beq.s	.ChkDown			; If not, branch
0000B37C 117C 0007 0020             		move.b	#7,oAni(a0)			; Set to looking up animation
0000B382                            
0000B382 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B386 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B38C 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B38E 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B394 0C78 00C8 F8CC             		cmpi.w	#200,rCamYPosDist.w		; Has the camera finished scrolling?
0000B39A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B39C 5478 F8CC                  		addq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3A0 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B3A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3A2                            .ChkDown:
0000B3A2 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is the down button being held?
0000B3A8 6700                       		beq.s	.ResetScr			; If not, branch
0000B3AA 117C 0008 0020             		move.b	#8,oAni(a0)			; Set to ducking animation
0000B3B0                            
0000B3B0 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B3B4 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B3BA 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B3BC 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B3C2 0C78 0008 F8CC             		cmpi.w	#8,rCamYPosDist.w		; Has the camera finished scrolling?
0000B3C8 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3CA 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3CE 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B3D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3D0                            .ResetScr:
0000B3D0 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000B3D4                            
0000B3D4                            .ResetScrPart2:
0000B3D4 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B3DA 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3DC 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B3DE 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B3E2                            
0000B3E2                            .ScrollUp:
0000B3E2 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B3E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3E6                            .UpdateSpdOnGround:
0000B3E6 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000B3EA 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000B3EE 6600                       		bne.s	.ApplySpeed			; If so, branch
0000B3F0                            
0000B3F0 3028 003A                  		move.w	oGVel(a0),d0			; Get current ground velocity
0000B3F4 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
0000B3F6 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
0000B3F8                            
0000B3F8                            .SettleRight:
0000B3F8 9045                       		sub.w	d5,d0				; Slow down
0000B3FA 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
0000B3FC 7000                       		moveq	#0,d0				; Stop the movement
0000B3FE 6000                       		bra.s	.SetSpeed			; Continue
0000B400                            
0000B400                            .SettleLeft:
0000B400 D045                       		add.w	d5,d0				; Slow down
0000B402 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
0000B404 7000                       		moveq	#0,d0				; Stop the movement
0000B406                            
0000B406                            .SetSpeed:
0000B406 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B40A                            
0000B40A                            .ApplySpeed:
0000B40A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B40E 4EB8 12F4                  		jsr	CalcSine.w			; Get the sine and cosine
0000B412 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B416 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B41A E081                       		asr.l	#8,d1				; Shift the values over
0000B41C E080                       		asr.l	#8,d0				; ''
0000B41E 3141 001C                  		move.w	d1,oXVel(a0)			; Set the X velocity
0000B422 3140 001E                  		move.w	d0,oYVel(a0)			; Set the Y velocity
0000B426                            
0000B426                            ObjMighty_CheckWalls:
0000B426 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B42A 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
0000B42E 6700                       		beq.s	.Skip				; If not, branch
0000B430 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B434 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
0000B438 6B00                       		bmi.s	.End				; If so, branch
0000B43A                            
0000B43A                            .Skip:
0000B43A 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
0000B43C 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000B440 6700                       		beq.s	.End				; Branch if not moving
0000B442 6B00                       		bmi.s	.CheckPush			; Branch if going left
0000B444 4441                       		neg.w	d1				; Negate the modifier
0000B446                            
0000B446                            .CheckPush:
0000B446 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B44A D001                       		add.b	d1,d0				; Add modifier
0000B44C                            		push.w	d0				; Save it
0000B44C 3F00                     M 	move.w	d0,-(sp)
0000B44E 4EB8 2DC4                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
0000B452                            		pop.w	d0				; Restore angle
0000B452 301F                     M 	move.w	(sp)+,d0
0000B454 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
0000B456 6A00                       		bpl.s	.End				; If not, branch
0000B458 E141                       		asl.w	#8,d1				; Shift distance inside the collision
0000B45A 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000B45E 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
0000B462 6700                       		beq.s	.PushCeiling			; If so, branch
0000B464 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
0000B468 6700                       		beq.s	.PushRightWall			; If so, branch
0000B46A 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000B46E 6700                       		beq.s	.PushFloor			; If so, branch
0000B470 D368 001C                  		add.w	d1,oXVel(a0)			; Push out to the right
0000B474 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B478 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing right?
0000B47E 6600                       		bne.s	.End				; If not, branch
0000B480 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B486 4E75                       		rts
0000B488                            
0000B488                            .PushFloor:
0000B488 9368 001E                  		sub.w	d1,oYVel(a0)			; Push out upwards
0000B48C 4E75                       		rts
0000B48E                            
0000B48E                            .PushRightWall:
0000B48E 9368 001C                  		sub.w	d1,oXVel(a0)			; Push out to the left
0000B492 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B496 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B49C 6700                       		beq.s	.End				; If not, branch
0000B49E 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B4A4 4E75                       		rts
0000B4A6                            
0000B4A6                            .PushCeiling:
0000B4A6 D368 001E                  		add.w	d1,oYVel(a0)			; Push out downwards
0000B4AA                            
0000B4AA                            .End:
0000B4AA 4E75                       		rts
0000B4AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4AC                            ; Move left on the ground
0000B4AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4AC                            ObjMighty_MoveLeft:
0000B4AC 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B4B0 6700                       		beq.s	.SetFlip			; If not moving yet, branch
0000B4B2 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
0000B4B4                            
0000B4B4                            .SetFlip:
0000B4B4 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B4BA 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000B4BC 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B4C2 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B4C8                            
0000B4C8                            .MoveLeft:
0000B4C8 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B4CA 3206                       		move.w	d6,d1				; Get top speed
0000B4CC 4441                       		neg.w	d1				; Negate it
0000B4CE B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
0000B4D0 6E00                       		bgt.s	.SetSpeed			; If not, branch
0000B4D2 D045                       		add.w	d5,d0				; Add acceleration back
0000B4D4 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
0000B4D6 6F00                       		ble.s	.SetSpeed			; If not, branch
0000B4D8 3001                       		move.w	d1,d0				; Cap at the top speed
0000B4DA                            
0000B4DA                            .SetSpeed:
0000B4DA 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B4DE 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B4E2                            
0000B4E2                            .End:
0000B4E2 4E75                       		rts
0000B4E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4E4                            .Skid:
0000B4E4 9044                       		sub.w	d4,d0				; Subtract deceleration
0000B4E6 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B4E8                            
0000B4E8                            .Compare:
0000B4E8 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B4EA 6C00                       		bge.s	.SetSkidSpeed			; If not branch
0000B4EC 7080                       		moveq	#-$80,d0			; Set speed to -$80
0000B4EE                            
0000B4EE                            .SetSkidSpeed:
0000B4EE 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B4F2 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B4F6 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B4FA 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B4FE 66E2                       		bne.s	.End				; If so, branch
0000B500 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
0000B504 6DDC                       		blt.s	.End				; If not, branch
0000B506 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B50C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B512                            		playSnd	#sSkid, 2			; Play skid sound
0000B512 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B518 4E75                       		rts
0000B51A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B51A                            ; Move right on the ground
0000B51A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B51A                            ObjMighty_MoveRight:
0000B51A 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B51E 6B00                       		bmi.s	.Skid				; If it's negative, skid
0000B520 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B526 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
0000B528 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B52E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B534                            
0000B534                            .MoveRight:
0000B534 D045                       		add.w	d5,d0				; Add acceleration
0000B536 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B538 6D00                       		blt.s	.SetSpeed			; If not, branch
0000B53A 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B53C B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
0000B53E 6C00                       		bge.s	.SetSpeed			; If not, branch
0000B540 3006                       		move.w	d6,d0				; Cap at top speed
0000B542                            
0000B542                            .SetSpeed:
0000B542 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B546 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B54A                            
0000B54A                            .End:
0000B54A 4E75                       		rts
0000B54C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B54C                            .Skid:
0000B54C D044                       		add.w	d4,d0				; Add deceleration
0000B54E 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B550                            
0000B550                            .Compare:
0000B550 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B552 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
0000B554 303C 0080                  		move.w	#$80,d0				; Set speed to $80
0000B558                            
0000B558                            .SetSkidSpeed:
0000B558 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B55C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B560 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B564 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B568 66E0                       		bne.s	.End				; If so, branch
0000B56A 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000B56E 6EDA                       		bgt.s	.End				; If not, branch
0000B570 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B576 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B57C                            		playSnd	#sSkid, 2			; Play skid sound
0000B57C 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B582 4E75                       		rts
0000B584                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B584                            ; Do movement while rolling
0000B584                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B584                            ObjMighty_MoveRoll:
0000B584 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B588 E346                       		asl.w	#1,d6				; ''
0000B58A 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B58E E245                       		asr.w	#1,d5				; ''
0000B590 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B594 E444                       		asr.w	#2,d4				; ''
0000B596                            
0000B596 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B59A 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000B59E                            
0000B59E 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B5A4 6700                       		beq.s	.ChkRight			; If not, branch
0000B5A6 6100 0000                  		bsr.w	ObjMighty_RollLeft		; Handle left movement
0000B5AA                            
0000B5AA                            .ChkRight:
0000B5AA 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B5B0 6700                       		beq.s	.Decelerate			; If not, branch
0000B5B2 6100 0000                  		bsr.w	ObjMighty_RollRight		; Handle right movement
0000B5B6                            
0000B5B6                            .Decelerate:
0000B5B6 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B5BA 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
0000B5BC 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000B5BE                            
0000B5BE 9045                       		sub.w	d5,d0				; Decelerate
0000B5C0 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B5C2 7000                       		moveq	#0,d0				; Cap at 0
0000B5C4                            
0000B5C4                            .SetGVel:
0000B5C4 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B5C8 6000                       		bra.s	.ChkStop			; Continue
0000B5CA                            
0000B5CA                            .DecLeft:
0000B5CA D045                       		add.w	d5,d0				; Decelerate
0000B5CC 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000B5CE 7000                       		moveq	#0,d0				; Cap at 0
0000B5D0                            
0000B5D0                            .SetGVel2:
0000B5D0 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B5D4                            
0000B5D4                            .ChkStop:
0000B5D4 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic still moving?
0000B5D8 6600                       		bne.s	.UpdateSpd			; If so, branch
0000B5DA                            
0000B5DA 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B5DE 6600                       		bne.s	.KeepRoll			; If so, branch
0000B5E0 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Stop rolling
0000B5E6 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B5EC 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B5F2 117C 0005 0020             		move.b	#5,oAni(a0)			; Use standing animation
0000B5F8 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B5FC 6000                       		bra.s	.UpdateSpd			; Continue
0000B5FE                            
0000B5FE                            .KeepRoll:
0000B5FE 317C 0400 003A             		move.w	#$400,oGVel(a0)			; Speed up again
0000B604 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing right?
0000B60A 6700                       		beq.s	.UpdateSpd			; If so, branch
0000B60C 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B610                            
0000B610                            .UpdateSpd:
0000B610 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B614 4EB8 12F4                  		jsr	CalcSine.w			; Get sine and cosine
0000B618 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B61C E080                       		asr.l	#8,d0				; Shift over
0000B61E 3140 001E                  		move.w	d0,oYVel(a0)			; Set Y velocity
0000B622 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B626 E081                       		asr.l	#8,d1				; Shift over
0000B628                            
0000B628 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
0000B62C 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000B62E 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000B632                            
0000B632                            .ChkLeftSpd:
0000B632 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
0000B636 6C00                       		bge.s	.SetXVel			; If not, branch
0000B638 323C F000                  		move.w	#-$1000,d1			; Cap the speed
0000B63C                            
0000B63C                            .SetXVel:
0000B63C 3141 001C                  		move.w	d1,oXVel(a0)			; Set X velocity
0000B640 6000 FDE4                  		bra.w	ObjMighty_CheckWalls		; Check wall collision
0000B644                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B644                            ; Handle left movement for rolling
0000B644                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B644                            ObjMighty_RollLeft:
0000B644 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B648 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
0000B64A 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
0000B64C                            
0000B64C                            .SetLeft:
0000B64C 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B652 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B658 4E75                       		rts
0000B65A                            
0000B65A                            .Dec:
0000B65A 9044                       		sub.w	d4,d0				; Decelerate
0000B65C 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B65E 303C FF80                  		move.w	#-$80,d0			; Set new speed
0000B662                            
0000B662                            .SetGVel:
0000B662 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B666 4E75                       		rts
0000B668                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B668                            ; Handle left movement for rolling
0000B668                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B668                            ObjMighty_RollRight:
0000B668 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B66C 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
0000B66E 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B674 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B67A 4E75                       		rts
0000B67C                            
0000B67C                            .Dec:
0000B67C D044                       		add.w	d4,d0				; Decelerate
0000B67E 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B680 303C 0080                  		move.w	#$80,d0				; Set new speed
0000B684                            
0000B684                            .SetGVel:
0000B684 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B688 4E75                       		rts
0000B68A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B68A                            ; Do movement in the air
0000B68A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B68A                            ObjMighty_MoveAir:
0000B68A 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B68E 3A28 0036                  		move.w	oAcc(a0),d5			; Get accleration
0000B692 DA45                       		add.w	d5,d5				; Double it
0000B694 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B698                            
0000B698 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B69E 6700                       		beq.s	.NotLeft			; If not, branch
0000B6A0 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B6A6 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B6A8 3206                       		move.w	d6,d1				; Get top speed
0000B6AA 4441                       		neg.w	d1				; Negate it
0000B6AC B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000B6AE 6E00                       		bgt.s	.NotLeft			; If not, branch
0000B6B0 D045                       		add.w	d5,d0				; Add acceleration back
0000B6B2 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000B6B4 6F00                       		ble.s	.NotLeft			; If not, branch
0000B6B6 3001                       		move.w	d1,d0				; Cap at top speed
0000B6B8                            
0000B6B8                            .NotLeft:
0000B6B8 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B6BE 6700                       		beq.s	.NotRight			; If not, branch
0000B6C0 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B6C6 D045                       		add.w	d5,d0				; Add acceleration
0000B6C8 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B6CA 6D00                       		blt.s	.NotRight			; If not, branch
0000B6CC 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B6CE B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000B6D0 6C00                       		bge.s	.NotRight			; If not, branch
0000B6D2 3006                       		move.w	d6,d0				; Cap at top speed
0000B6D4                            
0000B6D4                            .NotRight:
0000B6D4 3140 001C                  		move.w	d0,oXVel(a0)			; Set X velocity
0000B6D8                            
0000B6D8                            .ResetScr
0000B6D8 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B6DE 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000B6E0 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B6E2 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B6E6                            
0000B6E6                            .ScrollUp:
0000B6E6 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B6EA                            
0000B6EA                            .DecelerateAtPeak:
0000B6EA 0C68 FC00 001E             		cmpi.w	#-$400,oYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000B6F0 6500                       		bcs.s	.End				; If not, branch
0000B6F2 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B6F6 3200                       		move.w	d0,d1				; Save it
0000B6F8 EA41                       		asr.w	#5,d1				; Turn it into the acceleration
0000B6FA 6700                       		beq.s	.End				; If it's 0, branch
0000B6FC 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000B6FE                            
0000B6FE                            .DecRight:
0000B6FE 9041                       		sub.w	d1,d0				; Subtract accleration
0000B700 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000B702 7000                       		moveq	#0,d0				; Cap at 0
0000B704 6000                       		bra.s	.DecSetSpeed			; Continue
0000B706                            
0000B706                            .DecLeft:
0000B706 9041                       		sub.w	d1,d0				; Subtract acceleration
0000B708 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
0000B70A 7000                       		moveq	#0,d0				; Cap at 0
0000B70C                            
0000B70C                            .DecSetSpeed:
0000B70C 3140 001C                  		move.w	d0,oXVel(a0)			; Set thhe X velocity
0000B710                            
0000B710                            .End:
0000B710 4E75                       		rts
0000B712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B712                            ; Handle level boundaries
0000B712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B712                            ObjMighty_LvlBound:
0000B712 4A68 001E                  		tst.w	oYVel(a0)
0000B716 6A00                       		bpl.s	.XBound
0000B718 3228 0018                  		move.w	oYPos(a0),d1
0000B71C 0641 0010                  		addi.w	#$10,d1
0000B720 3038 F8CA                  		move.w	rMinCamY.w,d0		; Get upper boundary position
0000B724 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
0000B726 6F00                       		ble.s	.XBound				; If so, branch
0000B728 3140 0018                  		move.w	d0,oYPos(a0)
0000B72C 4268 001E                  		clr.w	oYVel(a0)
0000B730 4268 003A                  		clr.w	oGVel(a0)
0000B734                            
0000B734                            .XBound:
0000B734 2228 0014                  		move.l	oXPos(a0),d1			; Get X position
0000B738 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B73C 48C0                       		ext.l	d0
0000B73E E180                       		asl.l	#8,d0				; Shift it
0000B740 D280                       		add.l	d0,d1				; Add to X position
0000B742 4841                       		swap	d1				; Get actual X position
0000B744 3038 F8C8                  		move.w	rMinCamX.w,d0		; Get left boundary position
0000B748 0640 0010                  		addi.w	#$10,d0				; ''
0000B74C B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
0000B74E 6E00                       		bgt.s	.TouchedSide			; If so, branch
0000B750 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Get max camera X position
0000B754 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000B758 B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
0000B75A 6F00                       		ble.s	.TouchedSide			; If so, branch
0000B75C                            
0000B75C                            .ChkBottom:
0000B75C 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
0000B760 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
0000B764 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000B768 6D00                       		blt.s	.TouchedBottom			; If so, branch
0000B76A 4E75                       		rts
0000B76C                            
0000B76C                            .TouchedBottom:
0000B76C 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get target max camera Y position
0000B770 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Get current max camera Y position
0000B774 B240                       		cmp.w	d0,d1				; Are they the same?
0000B776 6D00                       		blt.s	.NoKill				; If not, branch
0000B778 6000 0000                  		bra.w	ObjMighty_GetKilled		; Get Sonic killed
0000B77C                            
0000B77C                            .NoKill:
0000B77C 4E75                       		rts
0000B77E                            
0000B77E                            .TouchedSide:
0000B77E 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
0000B782 3140 0014                  		move.w	d0,oXPos(a0)			; Move Sonic out of the boundary
0000B786 4228 0016                  		clr.b	oXPos+2(a0)			; Clear the subpixel of the X position
0000B78A 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B78E 60CC                       		bra.s	.ChkBottom			; Continue
0000B790                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B790                            ; Handle peelout
0000B790                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B790                            ObjMighty_Peelout:
0000B790 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the peelout?
0000B794 6700                       		beq.s	.ChkUp				; If not, branch
0000B796 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000B798 4E75                       		rts
0000B79A                            
0000B79A                            .ChkUp:
0000B79A 0C28 0007 0020             		cmpi.b	#7,oAni(a0)			; Is Sonic looking up?
0000B7A0 6600 0000                  		bne.w	.End				; If not, branch
0000B7A4 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B7A8 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B7AC 6700 0000                  		beq.w	.End				; If not, branch
0000B7B0                            
0000B7B0 4228 0020                  		clr.b	oAni(a0)			; Set to peelout charge animation
0000B7B4 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B7B8 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B7BE 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B7C4 6700                       		beq.s	.SetAni				; If so, branch
0000B7C6 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B7CA                            
0000B7CA                            .SetAni:
0000B7CA                            		playSnd	#sCharge, 2			; Play charge sound
0000B7CA 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B7D0                            
0000B7D0 588F                       		addq.l	#4,sp				; Don't return to caller
0000B7D2 50E8 0045                  		st	oDashFlag(a0)			; Set the peelout flag
0000B7D6 4EF8 320E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B7DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7DA                            .ChkLaunch:
0000B7DA 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is up being held?
0000B7E0 6600 0000                  		bne.w	.Charge				; If so, branch
0000B7E4 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B7E8                            
0000B7E8 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged up enough?
0000B7EE 6600                       		bne.s	.StopSound			; If not, branch
0000B7F0                            
0000B7F0 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000B7F4 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B7FA 0828 0006 0028             		btst	#6,oStatus(a0)
0000B800 6700                       		beq.s	.NoWater
0000B802 E2E8 003A                  		lsr.w	oGVel(a0)
0000B806                            
0000B806                            .NoWater:
0000B806 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B80C 6700                       		beq.s	.FinishDash			; If not, branch
0000B80E 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B812                            
0000B812                            .FinishDash:
0000B812                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B812 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B818                            
0000B818 6000                       		bra.s	.DoUpdates			; Continue
0000B81A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B81A                            .Charge:
0000B81A 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged enough?
0000B820 6700                       		beq.s	.DoUpdates			; If so, branch
0000B822 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B826 0668 0066 003A             		addi.w	#$66,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B82C 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B832 6700                       		beq.s	.DoUpdates			; If so, branch
0000B834 0468 00CC 003A             		subi.w	#$66*2,oGVel(a0)		; Go the other way
0000B83A 6000                       		bra.s	.DoUpdates			; Continue
0000B83C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B83C                            .StopSound:
0000B83C 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B840                            
0000B840                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B840 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B846                            .DoUpdates:
0000B846 588F                       		addq.l	#4,sp				; Don't return to caller
0000B848 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B84E 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B850 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B852 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B856                            
0000B856                            .ScrollUp:
0000B856 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B85A                            
0000B85A                            .FinishUpdates:
0000B85A 4EF8 320E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B85E                            
0000B85E                            .End:
0000B85E 4E75                       		rts
0000B860                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B860                            ; Handle spindash
0000B860                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B860                            ObjMighty_Spindash:
0000B860 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the spindash?
0000B864 6700                       		beq.s	.ChkDown			; If not, branch
0000B866 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000B868 4E75                       		rts
0000B86A                            
0000B86A                            .ChkDown:
0000B86A 0C28 0008 0020             		cmpi.b	#8,oAni(a0)			; Is Sonic ducking?
0000B870 6600 0000                  		bne.w	.End				; If not, branch
0000B874 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B878 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B87C 6700 0000                  		beq.w	.End				; If not, branch
0000B880                            
0000B880 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B884 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B88A 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B890 6700                       		beq.s	.SetAni				; If so, branch
0000B892 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B896                            
0000B896                            .SetAni:
0000B896 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B89C 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B8A2 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B8A6 117C 0002 0020             		move.b	#2,oAni(a0)			; Set to spin animation
0000B8AC                            
0000B8AC                            		playSnd	#sCharge, 2			; Play charge sound
0000B8AC 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B8B2                            
0000B8B2 588F                       		addq.l	#4,sp				; Don't return to caller
0000B8B4 117C 0001 0045             		move.b	#1,oDashFlag(a0)		; Set the spindash flag
0000B8BA 4EF8 320E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B8BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8BE                            .ChkLaunch:
0000B8BE 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000B8C4 6600 0000                  		bne.w	.Charge				; If so, branch
0000B8C8 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B8CC                            
0000B8CC 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged up enough?
0000B8D2 6600                       		bne.s	.StopSound			; If not, branch
0000B8D4                            
0000B8D4 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set the roll flag
0000B8DA 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B8E0 0828 0006 0028             		btst	#6,oStatus(a0)
0000B8E6 6700                       		beq.s	.NoWater
0000B8E8 E2E8 003A                  		lsr.w	oGVel(a0)
0000B8EC                            
0000B8EC                            .NoWater:
0000B8EC 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B8F2 6700                       		beq.s	.FinishDash			; If not, branch
0000B8F4 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B8F8                            
0000B8F8                            .FinishDash:
0000B8F8                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B8F8 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B8FE                            
0000B8FE 6000                       		bra.s	.DoUpdates			; Continue
0000B900                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B900                            .Charge:
0000B900 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged enough?
0000B906 6700                       		beq.s	.DoUpdates			; If so, branch
0000B908 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B90C 0668 0046 003A             		addi.w	#$46,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B912 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B918 6700                       		beq.s	.DoUpdates			; If so, branch
0000B91A 0468 008C 003A             		subi.w	#$46*2,oGVel(a0)		; Go the other way
0000B920 6000                       		bra.s	.DoUpdates			; Continue
0000B922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B922                            .StopSound:
0000B922 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B926 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B92C 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B932 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B936                            
0000B936                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B936 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B93C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B93C                            .DoUpdates:
0000B93C 588F                       		addq.l	#4,sp				; Don't return to caller
0000B93E 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B944 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B946 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B948 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B94C                            
0000B94C                            .ScrollUp:
0000B94C 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B950                            
0000B950                            .FinishUpdates:
0000B950 4EF8 320E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B954                            
0000B954                            .End:
0000B954 4E75                       		rts
0000B956                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B956                            ; Check for jumping
0000B956                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B956                            ObjMighty_ChkJump:
0000B956 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get pressed buttons
0000B95A 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B95E 4A38 C768                  		tst.b	rMoveCheat.w
0000B962 6700                       		beq.s	.NoDebug
0000B964 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000B968                            
0000B968                            .NoDebug:
0000B968 4A00                       		tst.b	d0
0000B96A 6700 0000                  		beq.w	.End				; If not, branch
0000B96E                            
0000B96E 7000                       		moveq	#0,d0
0000B970 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B974 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
0000B978 4EB8 2E36                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000B97C 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
0000B980 6D00 0000                  		blt.w	.End				; If not, branch
0000B984                            
0000B984 343C 0680                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
0000B988 0828 0006 0028             		btst	#6,oStatus(a0)
0000B98E 6700                       		beq.s	.NoWater
0000B990 0442 0300                  		subi.w	#$300,d2
0000B994                            
0000B994                            .NoWater:
0000B994 7000                       		moveq	#0,d0
0000B996 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B99A 0400 0040                  		subi.b	#$40,d0				; Shift it
0000B99E 4EB8 12F4                  		jsr	CalcSine.w			; Get the sine and cosine
0000B9A2 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
0000B9A4 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
0000B9A6 E081                       		asr.l	#8,d1				; Shift the values over
0000B9A8 E080                       		asr.l	#8,d0				; ''
0000B9AA D368 001C                  		add.w	d1,oXVel(a0)			; Add to X velocity
0000B9AE D168 001E                  		add.w	d0,oYVel(a0)			; Add to Y velocity
0000B9B2 0028 0006 0028             		ori.b	#6,oStatus(a0)			; Set "in air" and roll flags
0000B9B8 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000B9BE 584F                       		addq.w	#4,sp				; Do not return to collaer
0000B9C0 50E8 0040                  		st	oJumping(a0)			; Set the jumping flag
0000B9C4                            		playSnd	#sLeap, 2			; Play jump sound
0000B9C4 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
0000B9CA 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B9D0 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B9D6 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B9DA 117C 0002 0020             		move.b	#2,oAni(a0)			; Set jumping animation
0000B9E0                            
0000B9E0                            .End:
0000B9E0 4E75                       		rts
0000B9E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9E2                            ; Handle variable jumping
0000B9E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B9E2                            ObjMighty_JumpHeight:
0000B9E2 4A28 0040                  		tst.b	oJumping(a0)			; Is Sonic jumping?
0000B9E6 6700                       		beq.s	.UpVelCap			; If not, branch
0000B9E8                            
0000B9E8 323C FC00                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
0000B9EC B268 001E                  		cmp.w	oYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000B9F0 6F00                       		ble.s	.End				; If not, branch
0000B9F2 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000B9F6 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B9FA 4A38 C768                  		tst.b	rMoveCheat.w
0000B9FE 6700                       		beq.s	.NoDebug
0000BA00 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000BA04                            
0000BA04                            .NoDebug:
0000BA04 4A00                       		tst.b	d0
0000BA06 6600                       		bne.s	.End				; If not, branch
0000BA08 3141 001E                  		move.w	d1,oYVel(a0)			; Set to minimum height
0000BA0C                            
0000BA0C                            .End:
0000BA0C 4E75                       		rts
0000BA0E                            
0000BA0E                            .UpVelCap:
0000BA0E 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000BA12 66F8                       		bne.s	.End				; If so, branch
0000BA14 0C68 F040 001E             		cmpi.w	#-$FC0,oYVel(a0)		; Cap Y velocity at -$FC0 when going up
0000BA1A 6CF0                       		bge.s	.End				; ''
0000BA1C 317C F040 001E             		move.w	#-$FC0,oYVel(a0)		; ''
0000BA22 4E75                       		rts
0000BA24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA24                            ; Gradually reset Sonic's angle in mid air
0000BA24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA24                            ObjMighty_JumpAngle:
0000BA24 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BA28 6700                       		beq.s	ObjMighty_JumpFlip		; If it's already reset, branch
0000BA2A 6A00                       		bpl.s	.Decrease			; If it's positive, branch
0000BA2C                            
0000BA2C                            .Increase:
0000BA2C 5400                       		addq.b	#2,d0				; Increase angle
0000BA2E 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
0000BA30 7000                       		moveq	#0,d0				; Reset the angle
0000BA32 6000                       		bra.s	.SetAngle
0000BA34                            
0000BA34                            .Decrease:
0000BA34 5500                       		subq.b	#2,d0				; Decrease angle
0000BA36 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000BA38 7000                       		moveq	#0,d0				; Reset the angle
0000BA3A                            
0000BA3A                            .SetAngle:
0000BA3A 1140 0041                  		move.b	d0,oAngle(a0)			; Set the new angle
0000BA3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA3E                            ; Update Sonic's angle while he's tumbling in the air
0000BA3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA3E                            ObjMighty_JumpFlip:
0000BA3E 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000BA42 6700                       		beq.s	.End				; If it's 0, branch
0000BA44 4A68 003A                  		tst.w	oFlipDir(a0)			; Is Sonic flipping left?
0000BA48 6B00                       		bmi.s	.FlipLeft			; IF so, branch
0000BA4A                            
0000BA4A                            .FlipRight:
0000BA4A 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA4E D001                       		add.b	d1,d0				; Add to angle
0000BA50 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA52 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BA56 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BA58 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BA5C 7000                       		moveq	#0,d0				; Reset angle
0000BA5E 6000                       		bra.s	.FlipSet			; Continue
0000BA60                            
0000BA60                            .FlipLeft:
0000BA60 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is the flipping inverted?
0000BA64 66E4                       		bne.s	.FlipRight			; If so, branch
0000BA66 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA6A 9001                       		sub.b	d1,d0				; Subtract from angle
0000BA6C 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA6E 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BA72 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BA74 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BA78 7000                       		moveq	#0,d0				; Reset angle
0000BA7A                            
0000BA7A                            .FlipSet:
0000BA7A 1140 0047                  		move.b	d0,oFlipAngle(a0)		; Update the angle
0000BA7E                            
0000BA7E                            .End:
0000BA7E 4E75                       		rts
0000BA80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA80                            ; Check for rolling
0000BA80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA80                            ObjMighty_ChkRoll:
0000BA80 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000BA84 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000BA86 4440                       		neg.w	d0				; ''
0000BA88                            
0000BA88                            .ChkSpd:
0000BA88 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
0000BA8C 6500                       		bcs.s	.NoRoll				; If not, branch
0000BA8E 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BA92 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000BA96 6600                       		bne.s	.NoRoll				; If not, branch
0000BA98 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000BA9E 6600                       		bne.s	ObjMighty_DoRoll			; If so, branch
0000BAA0                            
0000BAA0                            .NoRoll:
0000BAA0 4E75                       		rts
0000BAA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAA2                            ; Make Sonic roll
0000BAA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAA2                            ObjMighty_DoRoll:
0000BAA2 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BAA8 6600                       		bne.s	.End				; If so, branch
0000BAAA 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BAB0                            
0000BAB0 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BAB6 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BABC 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BAC0 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BAC6                            
0000BAC6 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving already?
0000BACA 6600                       		bne.s	.End				; IF not, branch
0000BACC 317C 0200 003A             		move.w	#$200,oGVel(a0)			; Set speed
0000BAD2                            
0000BAD2                            .End:
0000BAD2 4E75                       		rts
0000BAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD4                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
0000BAD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD4                            ObjMighty_SlopePush:
0000BAD4 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BAD8 0600 0060                  		addi.b	#$60,d0				; Shift it
0000BADC 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
0000BAE0 6400                       		bcc.s	.End				; If not, branch
0000BAE2 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BAE6 4EB8 12F4                  		jsr	CalcSine.w			; Get the sine of it
0000BAEA C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000BAEE E080                       		asr.l	#8,d0				; Shift it
0000BAF0 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000BAF4 6700                       		beq.s	.End				; If Sonic is not moving, branch
0000BAF6 D168 003A                  		add.w	d0,oGVel(a0)			; Add to ground velocity
0000BAFA                            
0000BAFA                            .End:
0000BAFA 4E75                       		rts
0000BAFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAFC                            ; Check if Sonic is to fall off a slope
0000BAFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAFC                            ObjMighty_FallOffSlope:
0000BAFC 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer, active?
0000BB00 6600                       		bne.s	.End				; If so, branch
0000BB02 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB06 0600 0020                  		addi.b	#$20,d0				; Shift it
0000BB0A 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000BB0E 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000BB10 3028 003A                  		move.w	oGVel(a0),d0			; Get speed
0000BB14 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
0000BB16 4440                       		neg.w	d0				; Force it to be positive
0000BB18                            
0000BB18                            .ChkSpeed:
0000BB18 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
0000BB1C 6400                       		bcc.s	.End				; If so, branch
0000BB1E 4268 003A                  		clr.w	oGVel(a0)			; Stop movement
0000BB22 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000BB28 117C 001E 003F             		move.b	#$1E,oMoveLock(a0)		; Set move lock timer
0000BB2E                            
0000BB2E                            .End:
0000BB2E 4E75                       		rts
0000BB30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB30                            ; Affect Sonic's speed on slopes while rolling
0000BB30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB30                            ObjMighty_RollSlopePush:
0000BB30 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB34 0600 0060                  		addi.b	#$60,d0				; ''
0000BB38 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000BB3C 6400                       		bcc.s	.End				; If not, branch
0000BB3E                            
0000BB3E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB42 4EB8 12F4                  		jsr	CalcSine.w			; Get sine
0000BB46 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
0000BB4A E080                       		asr.l	#8,d0				; Shift over
0000BB4C                            
0000BB4C 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000BB50 6B00                       		bmi.s	.PushLeft			; If not, branch
0000BB52 4A40                       		tst.w	d0				; Is the push speed positive?
0000BB54 6A00                       		bpl.s	.Push				; If so, branch
0000BB56 E480                       		asr.l	#2,d0				; Shift over more
0000BB58                            
0000BB58                            .Push:
0000BB58 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB5C 4E75                       		rts
0000BB5E                            
0000BB5E                            .PushLeft:
0000BB5E 4A40                       		tst.w	d0				; Is the push speed negative?
0000BB60 6B00                       		bmi.s	.Push2				; If so, branch
0000BB62 E480                       		asr.l	#2,d0				; Shift over more
0000BB64                            
0000BB64                            .Push2:
0000BB64 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB68                            
0000BB68                            .End:
0000BB68 4E75                       		rts
0000BB6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB6A                            ; Check for bouncy floor collision
0000BB6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB6A                            ObjMighty_ChkBounce:
0000BB6A 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
0000BB6E 6700 0000                  		beq.w	.End				; If so, branch
0000BB72                            
0000BB72 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic in the air?
0000BB78 6700                       		beq.s	.ChkDown			; If not, branch
0000BB7A                            
0000BB7A 4A68 001E                  		tst.w	oYVel(a0)			; Is Sonic falling?
0000BB7E 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
0000BB82 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
0000BB86                            
0000BB86                            .ChkDown:
0000BB86 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BB8A 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BB8E 4880                       		ext.w	d0				; ''
0000BB90 D440                       		add.w	d0,d2				; ''
0000BB92 5442                       		addq.w	#2,d2				; ''
0000BB94 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BB98 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BB9C 4880                       		ext.w	d0				; ''
0000BB9E 9640                       		sub.w	d0,d3				; ''
0000BBA0 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BBA4 3011                       		move.w	(a1),d0				; ''
0000BBA6 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BBAA 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BBAE 6700                       		beq.s	.Bounce				; If so, branch
0000BBB0                            
0000BBB0 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BBB4 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BBB8 4880                       		ext.w	d0				; ''
0000BBBA D440                       		add.w	d0,d2				; ''
0000BBBC 5442                       		addq.w	#2,d2				; ''
0000BBBE 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BBC2 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BBC6 4880                       		ext.w	d0				; ''
0000BBC8 D640                       		add.w	d0,d3				; ''
0000BBCA 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BBCE 3011                       		move.w	(a1),d0				; ''
0000BBD0 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BBD4 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BBD8 6600                       		bne.s	.End				; If not, branch
0000BBDA                            
0000BBDA                            .Bounce:
0000BBDA 317C EA00 001E             		move.w	#-$1600,oYVel(a0)		; Bounce Sonic up
0000BBE0 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BBE6 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BBEA 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BBEE 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BBF2                            
0000BBF2                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BBF2 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BBF8                            
0000BBF8 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BBFE 6600                       		bne.s	.End				; If so, branch
0000BC00 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BC06 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BC0C 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BC12 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BC16 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BC1C                            
0000BC1C                            .End:
0000BC1C 4E75                       		rts
0000BC1E                            
0000BC1E                            .ChkBounceUp:
0000BC1E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BC22 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC26 4880                       		ext.w	d0				; ''
0000BC28 9440                       		sub.w	d0,d2				; ''
0000BC2A 5542                       		subq.w	#2,d2				; ''
0000BC2C 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BC30 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC34 4880                       		ext.w	d0				; ''
0000BC36 9640                       		sub.w	d0,d3				; ''
0000BC38 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BC3C 3011                       		move.w	(a1),d0				; ''
0000BC3E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC42 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC46 6700                       		beq.s	.BounceUp			; If so, branch
0000BC48                            
0000BC48 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BC4C 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC50 4880                       		ext.w	d0				; ''
0000BC52 9440                       		sub.w	d0,d2				; ''
0000BC54 5542                       		subq.w	#2,d2				; ''
0000BC56 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BC5A 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC5E 4880                       		ext.w	d0				; ''
0000BC60 D640                       		add.w	d0,d3				; ''
0000BC62 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BC66 3011                       		move.w	(a1),d0				; ''
0000BC68 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC6C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC70 66AA                       		bne.s	.End				; If not, branch
0000BC72                            
0000BC72                            .BounceUp:
0000BC72 588F                       		addq.l	#4,sp				; Don't return to caller
0000BC74                            
0000BC74 317C 1600 001E             		move.w	#$1600,oYVel(a0)		; Bounce Sonic up
0000BC7A 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BC80 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BC84 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BC88 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BC8C                            
0000BC8C                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BC8C 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BC92                            
0000BC92 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BC98 6600                       		bne.s	.End2				; If so, branch
0000BC9A 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BCA0 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BCA6 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BCAC 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BCB0 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BCB6                            
0000BCB6                            .End2:
0000BCB6 4E75                       		rts
0000BCB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCB8                            ; Check for bars to hang on to
0000BCB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCB8                            ObjMighty_ChkHang:
0000BCB8 0828 0003 000C             		btst	#3,oFlags(a0)			; Are we already hanging?
0000BCBE 6600                       		bne.s	.End				; If so, branch
0000BCC0                            
0000BCC0 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BCC4 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BCC8 0442 0018                  		subi.w	#$18,d2				; ''
0000BCCC 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BCD0 3011                       		move.w	(a1),d0				; ''
0000BCD2 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BCD6 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BCDA 6600                       		bne.s	.End				; If not, branch
0000BCDC                            
0000BCDC 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
0000BCE2 42A8 001C                  		clr.l	oXVel(a0)			; Stop movement
0000BCE6 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BCEA 08E8 0003 000C             		bset	#3,oFlags(a0)			; Set hanging flag
0000BCF0 117C 000A 0020             		move.b	#$A,oAni(a0)			; Set hanging animation
0000BCF6 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Animation timer
0000BCFC 3028 0018                  		move.w	oYPos(a0),d0			; Align with bar
0000BD00 0440 0018                  		subi.w	#$18,d0				; ''
0000BD04 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
0000BD08 0640 0018                  		addi.w	#$18,d0				; ''
0000BD0C 3140 0018                  		move.w	d0,oYPos(a0)			; ''
0000BD10 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000BD14 08A8 0001 000D             		bclr	#1,oRender(a0)			; ''
0000BD1A                            
0000BD1A                            .End:
0000BD1A 4E75                       		rts
0000BD1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD1C                            ; Hang onto the bars
0000BD1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD1C                            ObjMighty_Hang:
0000BD1C 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BD20 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BD24 0442 0018                  		subi.w	#$18,d2				; ''
0000BD28 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BD2C 3011                       		move.w	(a1),d0				; ''
0000BD2E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD32 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BD36 6600                       		bne.s	.FallOff			; If not, branch
0000BD38 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get control press bits
0000BD3C 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
0000BD40 6700                       		beq.s	.MoveX				; If not, branch
0000BD42                            
0000BD42                            .FallOff:
0000BD42 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BD48 0668 0010 0018             		addi.w	#$10,oYPos(a0)			; Fall off
0000BD4E 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000BD54 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000BD5A 4E75                       		rts
0000BD5C                            
0000BD5C                            .MoveX:
0000BD5C 7002                       		moveq	#2,d0				; X speed
0000BD5E 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Are we going left?
0000BD64 6700                       		beq.s	.ChkRight			; If not, branch
0000BD66 4440                       		neg.w	d0				; Go the other way
0000BD68 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face to the left
0000BD6E 08E8 0000 000D             		bset	#0,oRender(a0)			; ''
0000BD74 6000                       		bra.s	.DoMove				; Continue
0000BD76                            
0000BD76                            .ChkRight:
0000BD76 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Are we going left?
0000BD7C 6700                       		beq.s	.ResetScr			; If not, branch
0000BD7E 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face to the right
0000BD84 08A8 0000 000D             		bclr	#0,oRender(a0)			; ''
0000BD8A                            
0000BD8A                            .DoMove:
0000BD8A D168 0014                  		add.w	d0,oXPos(a0)			; Move
0000BD8E 5328 004C                  		subq.b	#1,oHangAniTime(a0)		; Decrement animation timer
0000BD92 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
0000BD94 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Reset timer
0000BD9A 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Increment animation frame
0000BD9E 0C28 0004 0022             		cmpi.b	#4,oAniFrame(a0)		; Have we reached the last one?
0000BDA4 6500                       		bcs.s	.ResetScr			; If not, branch
0000BDA6 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation frame
0000BDAA                            
0000BDAA                            .ResetScr:
0000BDAA 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BDAE 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BDB4 6700                       		beq.s	.End				; If so, branch
0000BDB6 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BDB8 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BDBC                            
0000BDBC                            .ScrollUp:
0000BDBC 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BDC0                            
0000BDC0                            .End:
0000BDC0 4E75                       		rts
0000BDC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDC2                            ; Check for electricity
0000BDC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDC2                            ObjMighty_ChkElectric:
0000BDC2 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BDC6 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BDCA 4EB8 379E                  		jsr	Level_FindBlock			; Get the block located there
0000BDCE 3011                       		move.w	(a1),d0				; ''
0000BDD0 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BDD4                            
0000BDD4 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
0000BDD8 7C02                       		moveq	#2,d6				; ''
0000BDDA                            
0000BDDA                            .ChkBlocks:
0000BDDA B059                       		cmp.w	(a1)+,d0			; have we touched this block?
0000BDDC 6700                       		beq.s	ObjMighty_GetHurt		; If so, branch
0000BDDE 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000BDE2 4E75                       		rts
0000BDE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDE4 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
0000BDEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDEA                            ; Get Sonic hurt
0000BDEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDEA                            ObjMighty_GetHurt:
0000BDEA                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BDEA 4A68 0008                M 	tst.w	odrawnext(a0)
0000BDEE 6600                     M 	bne.s	.no_215
0000BDF0 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BDF6 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BDFA 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BDFE 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BE02 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BE06                          M .no_215
0000BE06 4A28 0042                  		tst.b	oInvulTime(a0)			; Are we invulnerable?
0000BE0A 6600 0000                  		bne.w	.End				; If so, branch
0000BE0E 4A78 F3D4                  		tst.w	rRings.w			; Does Sonic have any rings?
0000BE12 6700 0000                  		beq.w	ObjMighty_GetKilled		; If not, branch
0000BE16 4EB8 1998                  		jsr	FindFreeObj.w
0000BE1A 6700                       		beq.s	.Hurt
0000BE1C 22BC 0000 0000             		move.l	#ObjRingLoss,oAddr(a1)
0000BE22 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0000BE28 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000BE2E                            
0000BE2E                            .Hurt:
0000BE2E 117C 0008 0025             		move.b	#8,oRoutine(a0)			; Set to hurt routine
0000BE34 4EB8 2D8A                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BE38 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BE3C 08A8 0000 000C             		bclr	#0,oFlags(a0)			; Allow modes
0000BE42 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BE48 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BE4E 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Set to hurt animation
0000BE54 117C 0078 0042             		move.b	#$78,oInvulTime(a0)		; Set invulnerable timer
0000BE5A                            
0000BE5A 317C FC00 001E             		move.w	#-$400,oYVel(a0)		; Make Sonic bounce away
0000BE60 317C FE00 001C             		move.w	#-$200,oXVel(a0)		; ''
0000BE66 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BE6C 6700                       		beq.s	.ChkReverse			; If not, branch
0000BE6E 317C FE00 001E             		move.w	#-$200,oYVel(a0)		; Make Sonic bounce away slower
0000BE74 317C FF00 001C             		move.w	#-$100,oXVel(a0)
0000BE7A                            
0000BE7A                            .ChkReverse:
0000BE7A 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0000BE7E B06A 0014                  		cmp.w	oXPos(a2),d0			; Is Sonic left of the object that hurt him?
0000BE82 6500                       		bcs.s	.ChkSnd				; If so, branch
0000BE84 4468 001C                  		neg.w	oXVel(a0)			; Make Sonic bounce the other way if on the right side
0000BE88                            
0000BE88                            .ChkSnd:
0000BE88 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000BE8C                            
0000BE8C                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BE8C                            	;	beq.s	.End				; If not, branch
0000BE8C                            		playSnd	#sHurt, 2			; Play hurt sound
0000BE8C 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
0000BE92                            
0000BE92                            .End:
0000BE92 70FF                       		moveq	#-1,d0				; Set return status
0000BE94 4E75                       		rts
0000BE96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE96                            ; Hurt routine
0000BE96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE96                            ObjMighty_Hurt:
0000BE96 4A38 C768                  		tst.b	rMoveCheat.w
0000BE9A 6700                       		beq.s	.NoPlacementEnter
0000BE9C 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BEA2 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BEA4 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BEAA 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BEB0 4E75                       		rts
0000BEB2                            
0000BEB2                            .NoPlacementEnter:
0000BEB2 4EB8 1CCC                  		jsr	ObjectMove.w			; Allow movement
0000BEB6 0668 0030 001E             		addi.w	#$30,oYVel(a0)			; Apply gravity
0000BEBC 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BEC2 6700                       		beq.s	.NotWater			; If not, branch
0000BEC4 0468 0020 001E             		subi.w	#$20,oYVel(a0)			; Reduce gravity underwater
0000BECA                            
0000BECA                            .NotWater:
0000BECA 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Force the hurt animation
0000BED0 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000BED2                            
0000BED2 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BED8 6700                       		beq.s	.Cont				; If so, branch
0000BEDA 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BEDC 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BEE0                            
0000BEE0                            .ScrollUp:
0000BEE0 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BEE4                            
0000BEE4                            .Cont:
0000BEE4 6100 F82C                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000BEE8 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BEEC 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BEF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BEF0                            .ChkStop:
0000BEF0 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BEF4 0640 00E0                  		addi.w	#224,d0				; ''
0000BEF8 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BEFC 6D00                       		blt.s	ObjMighty_GetKilled		; If so, branch
0000BEFE                            
0000BEFE 4EB8 2B94                  		jsr	PlayerChkCollision		; Check for level collision
0000BF02 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic still in midair?
0000BF08 6600                       		bne.s	.End				; If so, branch
0000BF0A                            
0000BF0A 7000                       		moveq	#0,d0
0000BF0C 3140 001E                  		move.w	d0,oYVel(a0)			; Stop Sonic's movement
0000BF10 3140 001C                  		move.w	d0,oXVel(a0)			; ''
0000BF14 3140 003A                  		move.w	d0,oGVel(a0)			; ''
0000BF18 1140 000C                  		move.b	d0,oFlags(a0)			; Allow Sonic to move
0000BF1C 1140 0020                  		move.b	d0,oAni(a0)			; Reset animation
0000BF20 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set back to main routine
0000BF26                            
0000BF26                            .End:
0000BF26 4E75                       		rts
0000BF28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF28                            ; Get Sonic killed
0000BF28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF28                            ObjMighty_GetKilled:
0000BF28                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BF28 4A68 0008                M 	tst.w	odrawnext(a0)
0000BF2C 6600                     M 	bne.s	.no_217
0000BF2E 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BF34 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BF38 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BF3C 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BF40 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BF44                          M .no_217
0000BF44 117C 000C 0025             		move.b	#$C,oRoutine(a0)			; Set to the death routine
0000BF4A 4EB8 2D8A                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BF4E 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BF52 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BF58 117C 0018 0020             		move.b	#$18,oAni(a0)			; Set to death animation
0000BF5E                            
0000BF5E 317C F900 001E             		move.w	#-$700,oYVel(a0)		; Make Sonic bounce up
0000BF64 4268 001C                  		clr.w	oXVel(a0)			; Lock Sonic horizontally
0000BF68 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BF6C 31FC FFFF F8CE             		move.w	#$FFFF,rCamLocked.w		; Lock the camera
0000BF72                            
0000BF72                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BF72                            	;	beq.s	.End				; If not, branch
0000BF72                            		playSnd	#sDeath,2			; Play death sound
0000BF72 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
0000BF78                            
0000BF78                            .End:
0000BF78 70FF                       		moveq	#-1,d0				; Set return status
0000BF7A 4E75                       		rts
0000BF7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF7C                            ; Death routine
0000BF7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF7C                            ObjMighty_Dead:
0000BF7C 4A38 C768                  		tst.b	rMoveCheat.w
0000BF80 6700                       		beq.s	.NoPlacementEnter
0000BF82 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BF88 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BF8A 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BF90 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BF96 4E75                       		rts
0000BF98                            
0000BF98                            .NoPlacementEnter:
0000BF98 117C 0018 0020             		move.b	#$18,oAni(a0)			; Force the death animation
0000BF9E 0068 8000 000E             		ori.w	#$8000,oVRAM(a0)		; Force high priority
0000BFA4 6100                       		bsr.s	ObjMighty_ChkBound		; Check for when Sonic goes off screen
0000BFA6 4EB8 1CE6                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000BFAA 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BFAE 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BFB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFB2                            ObjMighty_ChkBound:
0000BFB2 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BFB6 0640 0100                  		addi.w	#$100,d0			; ''
0000BFBA B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BFBE 6C00                       		bge.s	.End				; If not, branch
0000BFC0                            
0000BFC0 117C 0010 0025             		move.b	#$10,oRoutine(a0)			; Go to gone routine
0000BFC6 117C 003C 0043             		move.b	#60,oDeathTimer(a0)		; Set death timer to 1 second
0000BFCC                            
0000BFCC                            .End:
0000BFCC 4E75                       		rts
0000BFCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFCE                            ; Wait for level reload or game/time over
0000BFCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFCE                            ObjMighty_Gone:
0000BFCE 4A28 0043                  		tst.b	oDeathTimer(a0)
0000BFD2 6700                       		beq.s	.End
0000BFD4 5328 0043                  		subq.b	#1,oDeathTimer(a0)		; Decrement the death counter
0000BFD8 6600                       		bne.s	.End				; If it hasn't run out, branch
0000BFDA 50F8 F8FC                  		st	rLvlReload.w			; Reload the level
0000BFDE                            
0000BFDE                            .End:
0000BFDE 4E75                       		rts
0000BFE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFE0                            ; Display Sonic's sprite
0000BFE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFE0                            ObjMighty_Display:
0000BFE0 1028 0042                  		move.b	oInvulTime(a0),d0		; Get invulnerability timer
0000BFE4 6700                       		beq.s	.Display			; If it's 0, branch
0000BFE6 5328 0042                  		subq.b	#1,oInvulTime(a0)		; Decrement invulnerability timer
0000BFEA E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
0000BFEC 6500                       		bcs.s	.Display			; If so, branch
0000BFEE                            	removeSprite	a0,a1,1				; Remove sprite if displayed
0000BFEE 4A68 0008                M 	tst.w	odrawnext(a0)
0000BFF2 6700                     M 	beq.s	.yes_219
0000BFF4 3268 000A                M 	move.w	odrawprev(a0),a1
0000BFF8 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
0000BFFE 3268 0008                M 	move.w	odrawnext(a0),a1
0000C002 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
0000C008 42A8 0008                M 	clr.l	odrawnext(a0)
0000C00C                          M .yes_219
0000C00C 4E75                       		rts
0000C00E                            
0000C00E                            .Display:
0000C00E                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
0000C00E 4A68 0008                M 	tst.w	odrawnext(a0)
0000C012 6600                     M 	bne.s	.no_220
0000C014 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C01A 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000C01E 3149 000A                M 	move.w	a1,odrawprev(a0)
0000C022 3348 0008                M 	move.w	a0,odrawnext(a1)
0000C026 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C02A                          M .no_220
0000C02A 4E75                       		rts
0000C02C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C02C                            ; Load Sonic's DPLCs
0000C02C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C02C                            ObjMighty_LoadDPLCs:
0000C02C 45F9 0000 0000             		lea	DPLC_ObjMighty,a2		; DPLCs
0000C032 383C F000                  		move.w	#$F000,d4			; VRAM location
0000C036 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
0000C03C 4EF8 1C8C                  		jmp	LoadObjDPLCs.w			; Load DPLCs
0000C040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C040                            ; Animate Sonic's sprite
0000C040                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C040                            ObjMighty_Animate:
0000C040 43F9 0000 0000             		lea	Ani_ObjMighty,a1			; Animation script
0000C046 7000                       		moveq	#0,d0
0000C048 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
0000C04C B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
0000C050 6700                       		beq.s	.Run				; If not, branch
0000C052 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
0000C056 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C05A 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C05E 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000C064                            
0000C064                            .Run:
0000C064 D040                       		add.w	d0,d0				; Turn ID into offset
0000C066 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
0000C06A 1011                       		move.b	(a1),d0				; Get first byte
0000C06C 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
0000C06E 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C072 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
0000C076 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C07C 8328 000D                  		or.b	d1,oRender(a0)			; Set flip bits
0000C080 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C084 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C086 1140 0023                  		move.b	d0,oAniTimer(a0)		; Set new animation timer
0000C08A                            
0000C08A                            .GetFrame:
0000C08A 7200                       		moveq	#0,d1
0000C08C 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
0000C090 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
0000C094 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
0000C098 6400                       		bhs.s	.CmdReset			; If so, branch
0000C09A                            
0000C09A                            .Next:
0000C09A 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
0000C09E 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
0000C0A2                            
0000C0A2                            .Wait:
0000C0A2 4E75                       		rts
0000C0A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0A4                            .CmdReset:
0000C0A4 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
0000C0A6 6600                       		bne.s	.CmdJump			; If not, branch
0000C0A8 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C0AC 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
0000C0B0 60E8                       		bra.s	.Next				; Continue
0000C0B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0B2                            .CmdJump:
0000C0B2 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
0000C0B4 6600                       		bne.s	.CmdSetAnim			; If not, branch
0000C0B6 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
0000C0BA 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
0000C0BE 9200                       		sub.b	d0,d1				; ''
0000C0C0 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
0000C0C4 60D4                       		bra.s	.Next				; Continue
0000C0C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0C6                            .CmdSetAnim:
0000C0C6 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
0000C0C8 6600                       		bne.s	.CmdEnd				; If not, branch
0000C0CA 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
0000C0D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0D0                            .CmdEnd:
0000C0D0 4E75                       		rts
0000C0D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C0D2                            .WalkRunAnim:
0000C0D2 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C0D6 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C0D8 5200                       		addq.b	#1,d0				; Is the animation walking/running?
0000C0DA 6600 0000                  		bne.w	.RollAnim			; If not, branch
0000C0DE                            
0000C0DE 7000                       		moveq	#0,d0
0000C0E0 1028 0047                  		move.b	oFlipAngle(a0),d0		; Is Sonic tumbling in the air?
0000C0E4 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
0000C0E8                            
0000C0E8 7200                       		moveq	#0,d1				; Intial flip bits
0000C0EA 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000C0EE 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
0000C0F0 6700                       		beq.s	.ChkStatus			; If it's zero, branch
0000C0F2 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
0000C0F4                            
0000C0F4                            .ChkStatus:
0000C0F4 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C0F8 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
0000C0FC 6600                       		bne.s	.ChkFlip			; If so, branch
0000C0FE 4600                       		not.b	d0				; Reverse angle
0000C100                            
0000C100                            .ChkFlip:
0000C100 0600 0010                  		addi.b	#$10,d0				; Shift angle
0000C104 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
0000C106 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
0000C108                            
0000C108                            .SetFlags:
0000C108 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits
0000C10E B302                       		eor.b	d1,d2				; Flip
0000C110 8528 000D                  		or.b	d2,oRender(a0)			; Set in render flags
0000C114                            
0000C114 0828 0005 0028             		btst	#5,oStatus(a0)			; Is Sonic pushing?
0000C11A 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
0000C11E                            
0000C11E E808                       		lsr.b	#4,d0				; Divide angle by $10
0000C120 0200 0006                  		andi.b	#6,d0				; Get angle section
0000C124                            
0000C124 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C128 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
0000C12A 4442                       		neg.w	d2				; Force it to be positive
0000C12C                            
0000C12C                            .GetAnim:
0000C12C 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
0000C132 4A00                       		tst.b	d0
0000C134 6600                       		bne.s	.ChkRun
0000C136 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
0000C13A 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C13C                            
0000C13C                            .ChkRun:
0000C13C 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
0000C142 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
0000C146 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C148 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
0000C14E 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
0000C150 E209                       		lsr.b	#1,d1				; ''
0000C152 D001                       		add.b	d1,d0				; ''
0000C154                            
0000C154                            .SkipWalk:
0000C154 D000                       		add.b	d0,d0				; Double the offset
0000C156 1600                       		move.b	d0,d3				; Copy the oofset
0000C158 4442                       		neg.w	d2				; Get animation speed
0000C15A 0642 0800                  		addi.w	#$800,d2			; ''
0000C15E 6A00                       		bpl.s	.SetTimer			; ''
0000C160 7400                       		moveq	#0,d2				; ''
0000C162                            
0000C162                            .SetTimer:
0000C162 E04A                       		lsr.w	#8,d2				; ''
0000C164 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C168 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
0000C16C D728 0010                  		add.b	d3,oFrame(a0)			; Add angle offset
0000C170 4E75                       		rts
0000C172                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C172                            .TumbleAnim:
0000C172 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000C176 7200                       		moveq	#0,d1
0000C178 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C17C 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
0000C180 6600                       		bne.s	.TumbleLeft			; If so, branch
0000C182                            
0000C182 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C188 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C18C 80FC 0016                  		divu.w	#$16,d0				; ''
0000C190 0600 0068                  		addi.b	#$68,d0				; ''
0000C194 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C198 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C19C 4E75                       		rts
0000C19E                            
0000C19E                            .TumbleLeft:
0000C19E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C1A4 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is flipping inverted?
0000C1A8 6700                       		beq.s	.NotInverted			; If not, branch
0000C1AA 0028 0001 000D             		ori.b	#1,oRender(a0)			; Face left
0000C1B0 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C1B4 6000                       		bra.s	.SetLeftFrame			; Continue
0000C1B6                            
0000C1B6                            .NotInverted:
0000C1B6 0028 0003 000D             		ori.b	#3,oRender(a0)			; Face left and be upside down
0000C1BC 4400                       		neg.b	d0				; Get map frame
0000C1BE 0600 008F                  		addi.b	#$8F,d0				; ''
0000C1C2                            
0000C1C2                            .SetLeftFrame:
0000C1C2 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
0000C1C6 0600 0068                  		addi.b	#$68,d0				; ''
0000C1CA 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C1CE 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C1D2 4E75                       		rts
0000C1D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C1D4                            .RollAnim:
0000C1D4 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C1D6 6600                       		bne.s	.PushAnim			; If not, branch
0000C1D8                            
0000C1D8 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C1DC 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
0000C1DE 4442                       		neg.w	d2				; Force it to be negative
0000C1E0                            
0000C1E0                            .GetAnim2:
0000C1E0 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
0000C1E6 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
0000C1EA 6400                       		bcc.s	.PrepareTimer			; If so, branch
0000C1EC 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
0000C1F2                            
0000C1F2                            .PrepareTimer:
0000C1F2 4442                       		neg.w	d2				; Get animation speed
0000C1F4 0642 0400                  		addi.w	#$400,d2			; ''
0000C1F8 6A00                       		bpl.s	.SetTimer2			; ''
0000C1FA 7400                       		moveq	#0,d2				; ''
0000C1FC                            
0000C1FC                            .SetTimer2:
0000C1FC E04A                       		lsr.w	#8,d2				; ''
0000C1FE 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C202                            
0000C202 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C206 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
0000C20A 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits in render flags
0000C210 8328 000D                  		or.b	d1,oRender(a0)			; Set new flip bits
0000C214                            
0000C214 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
0000C218                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C218                            .PushAnim:
0000C218 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C21A 6600                       		bne.s	.HangAnim			; If not, branch
0000C21C                            
0000C21C                            .DoPushAnim:
0000C21C 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C220 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
0000C222 4442                       		neg.w	d2				; Force it to be negative
0000C224                            
0000C224                            .GetAnim3:
0000C224 0642 0800                  		addi.w	#$800,d2			; Get animation speed
0000C228 6A00                       		bpl.s	.SetTimer3			; ''
0000C22A 7400                       		moveq	#0,d2				; ''
0000C22C                            
0000C22C                            .SetTimer3:
0000C22C EC4A                       		lsr.w	#6,d2				; ''
0000C22E 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C232 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000C238 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
0000C23C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C23C                            .HangAnim:
0000C23C 7200                       		moveq	#0,d1
0000C23E 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation frame
0000C242 1171 1001 0010             		move.b	1(a1,d1.w),oFrame(a0)		; Set map frame
0000C248 4228 0023                  		clr.b	oAniTimer(a0)			; Clear animation timer
0000C24C 4E75                       		rts
0000C24E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C24E                            ; Handle debug placement mode
0000C24E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C24E                            DebugPlacement:
0000C24E 7000                       		moveq	#0,d0
0000C250 1038 F8D1                  		move.b	rDebugMode.w,d0		; Get debug placement mode routine
0000C254 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000C258 D040                       		add.w	d0,d0				; Double it
0000C25A 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
0000C25E                            	nextObject
0000C25E 3068 0004                M 	movea.w	onext(a0),a0
0000C262 2250                     M 	move.l	oaddr(a0),a1
0000C264 4ED1                     M 	jmp	(a1)
0000C266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C266                            .Routines:
0000C266 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
0000C26A 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
0000C26E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C26E                            Debug_Init:
0000C26E 5438 F8D1                  		addq.b	#2,rDebugMode.w		; Next routine
0000C272 4228 0010                  		clr.b	oFrame(a0)			; Reset mapping frame
0000C276 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000C27A 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000C27E 4278 F8CE                  		clr.w	rCamLocked.w			; Unlock the camera
0000C282 4228 004B                  		clr.b	oBallMode(a0)			; Reset ball mode
0000C286 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000C28A 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set routine to main
0000C290                            
0000C290 3028 003C                  		move.w	oInteract(a0),d0		; Get object interacted with last
0000C294 6700                       		beq.s	.NoInteract			; If there is none, branch
0000C296 3240                       		movea.w	d0,a1
0000C298 08A9 0003 0028             		bclr	#3,oStatus(a1)			; Clear flags
0000C29E 08A9 0005 0028             		bclr	#5,oStatus(a1)			; ''
0000C2A4 4268 003C                  		clr.w	oInteract(a0)			; No more interaction
0000C2A8                            
0000C2A8                            .NoInteract:
0000C2A8 4228 000C                  		clr.b	oFlags(a0)			; Reset flags
0000C2AC 4228 0028                  		clr.b	oStatus(a0)			; Reset status
0000C2B0 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C2B6 117C 0001 0010             		move.b	#1,oFrame(a0)			; Display the standing frame
0000C2BC 6100 FD6E                  		bsr.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000C2C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2C0                            Debug_Main:
0000C2C0 6100 EE34                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000C2C4 6100                       		bsr.s	Debug_Control			; Control
0000C2C6                            	displaySprite	2,a0,a2,1
0000C2C6 4A68 0008                M 	tst.w	odrawnext(a0)
0000C2CA 6600                     M 	bne.s	.no_222
0000C2CC 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C2D2 3478 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a2
0000C2D6 314A 000A                M 	move.w	a2,odrawprev(a0)
0000C2DA 3548 0008                M 	move.w	a0,odrawnext(a2)
0000C2DE 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C2E2                          M .no_222
0000C2E2 4E75                       		rts
0000C2E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2E4                            Debug_Control:
0000C2E4 7006                       		moveq	#6,d0				; Speed
0000C2E6 0838 0000 C740             		btst	#0,rP1Hold.w			; Is up being held?
0000C2EC 6700                       		beq.s	.NoUp				; If not, branch
0000C2EE 9168 0018                  		sub.w	d0,oYPos(a0)			; Move up
0000C2F2                            
0000C2F2                            .NoUp:
0000C2F2 0838 0001 C740             		btst	#1,rP1Hold.w			; Is down being held?
0000C2F8 6700                       		beq.s	.NoDown				; If not, branch
0000C2FA D168 0018                  		add.w	d0,oYPos(a0)			; Move down
0000C2FE                            
0000C2FE                            .NoDown:
0000C2FE 0838 0002 C740             		btst	#2,rP1Hold.w			; Is left being held?
0000C304 6700                       		beq.s	.NoLeft				; If not, branch
0000C306 9168 0014                  		sub.w	d0,oXPos(a0)			; Move left
0000C30A                            
0000C30A                            .NoLeft:
0000C30A 0838 0003 C740             		btst	#3,rP1Hold.w			; Is right being held?
0000C310 6700                       		beq.s	.NoRight			; If not, branch
0000C312 D168 0014                  		add.w	d0,oXPos(a0)			; Move right
0000C316                            
0000C316                            .NoRight:
0000C316 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000C31C 6700                       		beq.s	.ChkWrap			; If not, branch
0000C31E 7000                       		moveq	#0,d0
0000C320 11C0 F8D1                  		move.b	d0,rDebugMode.w		; Disable debug placement mode
0000C324 1140 0016                  		move.b	d0,oXPos+2(a0)			; Reset X subpixel
0000C328 1140 001A                  		move.b	d0,oYPos+2(a0)			; Reset Y subpixel
0000C32C 3140 001C                  		move.w	d0,oXVel(a0)			; Reset X velocity
0000C330 3140 001E                  		move.w	d0,oYVel(a0)			; Reset Y velocity
0000C334 3140 003A                  		move.w	d0,oGVel(a0)			; Reset ground velocity
0000C338 0228 0001 0028             		andi.b	#1,oStatus(a0)			; Reset status
0000C33E 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000C344 20BC 0000 B016             		move.l	#ObjMighty,oAddr(a0)		; Use normal Sonic object
0000C34A 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000C350 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000C356                            
0000C356                            .ChkWrap:
0000C356 4E75                       		rts
0000C358                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C358                            ; Data
0000C358                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C358                            ArtUnc_Sonic:
0000C358                            		incbin	"Level/Objects/Mighty/Art.unc.bin"
00017E18                            		even
00017E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00017E18                            Map_ObjMighty:
00017E18                            		include	"Level/Objects/Mighty/Mappings.asm"
00017E18                            ; --------------------------------------------------------------------------------
00017E18                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00017E18                            ; --------------------------------------------------------------------------------
00017E18                            
00017E18                            SME_lde97:	
00017E18 0000 0000                  		dc.w SME_lde97_FC-SME_lde97, SME_lde97_FE-SME_lde97	
00017E1C 0000 0000                  		dc.w SME_lde97_118-SME_lde97, SME_lde97_12C-SME_lde97	
00017E20 0000 0000                  		dc.w SME_lde97_140-SME_lde97, SME_lde97_154-SME_lde97	
00017E24 0000 0000                  		dc.w SME_lde97_168-SME_lde97, SME_lde97_182-SME_lde97	
00017E28 0000 0000                  		dc.w SME_lde97_190-SME_lde97, SME_lde97_19E-SME_lde97	
00017E2C 0000 0000                  		dc.w SME_lde97_1B8-SME_lde97, SME_lde97_1C6-SME_lde97	
00017E30 0000 0000                  		dc.w SME_lde97_1DA-SME_lde97, SME_lde97_1FA-SME_lde97	
00017E34 0000 0000                  		dc.w SME_lde97_220-SME_lde97, SME_lde97_23A-SME_lde97	
00017E38 0000 0000                  		dc.w SME_lde97_25A-SME_lde97, SME_lde97_274-SME_lde97	
00017E3C 0000 0000                  		dc.w SME_lde97_294-SME_lde97, SME_lde97_2AE-SME_lde97	
00017E40 0000 0000                  		dc.w SME_lde97_2BC-SME_lde97, SME_lde97_2CA-SME_lde97	
00017E44 0000 0000                  		dc.w SME_lde97_2E4-SME_lde97, SME_lde97_2F2-SME_lde97	
00017E48 0000 0000                  		dc.w SME_lde97_306-SME_lde97, SME_lde97_32C-SME_lde97	
00017E4C 0000 0000                  		dc.w SME_lde97_352-SME_lde97, SME_lde97_36C-SME_lde97	
00017E50 0000 0000                  		dc.w SME_lde97_38C-SME_lde97, SME_lde97_3A6-SME_lde97	
00017E54 0000 0000                  		dc.w SME_lde97_3C6-SME_lde97, SME_lde97_3D4-SME_lde97	
00017E58 0000 0000                  		dc.w SME_lde97_3E2-SME_lde97, SME_lde97_3F0-SME_lde97	
00017E5C 0000 0000                  		dc.w SME_lde97_3FE-SME_lde97, SME_lde97_418-SME_lde97	
00017E60 0000 0000                  		dc.w SME_lde97_42C-SME_lde97, SME_lde97_446-SME_lde97	
00017E64 0000 0000                  		dc.w SME_lde97_45A-SME_lde97, SME_lde97_468-SME_lde97	
00017E68 0000 0000                  		dc.w SME_lde97_476-SME_lde97, SME_lde97_484-SME_lde97	
00017E6C 0000 0000                  		dc.w SME_lde97_492-SME_lde97, SME_lde97_4AC-SME_lde97	
00017E70 0000 0000                  		dc.w SME_lde97_4BA-SME_lde97, SME_lde97_4D4-SME_lde97	
00017E74 0000 0000                  		dc.w SME_lde97_4E2-SME_lde97, SME_lde97_4EA-SME_lde97	
00017E78 0000 0000                  		dc.w SME_lde97_4F2-SME_lde97, SME_lde97_4FA-SME_lde97	
00017E7C 0000 0000                  		dc.w SME_lde97_502-SME_lde97, SME_lde97_50A-SME_lde97	
00017E80 0000 0000                  		dc.w SME_lde97_50C-SME_lde97, SME_lde97_50E-SME_lde97	
00017E84 0000 0000                  		dc.w SME_lde97_510-SME_lde97, SME_lde97_512-SME_lde97	
00017E88 0000 0000                  		dc.w SME_lde97_520-SME_lde97, SME_lde97_53A-SME_lde97	
00017E8C 0000 0000                  		dc.w SME_lde97_554-SME_lde97, SME_lde97_568-SME_lde97	
00017E90 0000 0000                  		dc.w SME_lde97_57C-SME_lde97, SME_lde97_590-SME_lde97	
00017E94 0000 0000                  		dc.w SME_lde97_59E-SME_lde97, SME_lde97_5B2-SME_lde97	
00017E98 0000 0000                  		dc.w SME_lde97_5C6-SME_lde97, SME_lde97_5DA-SME_lde97	
00017E9C 0000 0000                  		dc.w SME_lde97_5F4-SME_lde97, SME_lde97_60E-SME_lde97	
00017EA0 0000 0000                  		dc.w SME_lde97_610-SME_lde97, SME_lde97_612-SME_lde97	
00017EA4 0000 0000                  		dc.w SME_lde97_620-SME_lde97, SME_lde97_634-SME_lde97	
00017EA8 0000 0000                  		dc.w SME_lde97_642-SME_lde97, SME_lde97_656-SME_lde97	
00017EAC 0000 0000                  		dc.w SME_lde97_658-SME_lde97, SME_lde97_65A-SME_lde97	
00017EB0 0000 0000                  		dc.w SME_lde97_65C-SME_lde97, SME_lde97_67C-SME_lde97	
00017EB4 0000 0000                  		dc.w SME_lde97_69C-SME_lde97, SME_lde97_69E-SME_lde97	
00017EB8 0000 0000                  		dc.w SME_lde97_6A0-SME_lde97, SME_lde97_6A2-SME_lde97	
00017EBC 0000 0000                  		dc.w SME_lde97_6A4-SME_lde97, SME_lde97_6A6-SME_lde97	
00017EC0 0000 0000                  		dc.w SME_lde97_6BA-SME_lde97, SME_lde97_6CE-SME_lde97	
00017EC4 0000 0000                  		dc.w SME_lde97_6E2-SME_lde97, SME_lde97_6F6-SME_lde97	
00017EC8 0000 0000                  		dc.w SME_lde97_704-SME_lde97, SME_lde97_712-SME_lde97	
00017ECC 0000 0000                  		dc.w SME_lde97_720-SME_lde97, SME_lde97_72E-SME_lde97	
00017ED0 0000 0000                  		dc.w SME_lde97_73C-SME_lde97, SME_lde97_73E-SME_lde97	
00017ED4 0000 0000                  		dc.w SME_lde97_740-SME_lde97, SME_lde97_742-SME_lde97	
00017ED8 0000 0000                  		dc.w SME_lde97_744-SME_lde97, SME_lde97_746-SME_lde97	
00017EDC 0000 0000                  		dc.w SME_lde97_748-SME_lde97, SME_lde97_74A-SME_lde97	
00017EE0 0000 0000                  		dc.w SME_lde97_74C-SME_lde97, SME_lde97_74E-SME_lde97	
00017EE4 0000 0000                  		dc.w SME_lde97_750-SME_lde97, SME_lde97_752-SME_lde97	
00017EE8 0000 0000                  		dc.w SME_lde97_754-SME_lde97, SME_lde97_768-SME_lde97	
00017EEC 0000 0000                  		dc.w SME_lde97_77C-SME_lde97, SME_lde97_78A-SME_lde97	
00017EF0 0000 0000                  		dc.w SME_lde97_792-SME_lde97, SME_lde97_7A0-SME_lde97	
00017EF4 0000 0000                  		dc.w SME_lde97_7B4-SME_lde97, SME_lde97_7C8-SME_lde97	
00017EF8 0000 0000                  		dc.w SME_lde97_7DC-SME_lde97, SME_lde97_7EA-SME_lde97	
00017EFC 0000 0000                  		dc.w SME_lde97_7F8-SME_lde97, SME_lde97_80C-SME_lde97	
00017F00 0000 0000                  		dc.w SME_lde97_81A-SME_lde97, SME_lde97_828-SME_lde97	
00017F04 0000 0000                  		dc.w SME_lde97_836-SME_lde97, SME_lde97_844-SME_lde97	
00017F08 0000 0000                  		dc.w SME_lde97_858-SME_lde97, SME_lde97_86C-SME_lde97	
00017F0C 0000 0000                  		dc.w SME_lde97_880-SME_lde97, SME_lde97_89A-SME_lde97	
00017F10 0000 0000                  		dc.w SME_lde97_8B4-SME_lde97, SME_lde97_8CE-SME_lde97	
00017F14 0000                       SME_lde97_FC:	dc.b 0, 0	
00017F16 0004                       SME_lde97_FE:	dc.b 0, 4	
00017F18 EC08 0000 FFF0             		dc.b $EC, 8, 0, 0, $FF, $F0	
00017F1E F40D 0003 FFF0             		dc.b $F4, $D, 0, 3, $FF, $F0	
00017F24 0408 000B FFF0             		dc.b 4, 8, 0, $B, $FF, $F0	
00017F2A 0C08 000E FFF8             		dc.b $C, 8, 0, $E, $FF, $F8	
00017F30 0003                       SME_lde97_118:	dc.b 0, 3	
00017F32 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F38 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F3E 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F44 0003                       SME_lde97_12C:	dc.b 0, 3	
00017F46 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F4C FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F52 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F58 0003                       SME_lde97_140:	dc.b 0, 3	
00017F5A EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017F60 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017F66 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F6C 0003                       SME_lde97_154:	dc.b 0, 3	
00017F6E EC0A 0000 FFF0             		dc.b $EC, $A, 0, 0, $FF, $F0	
00017F74 0408 0009 FFF0             		dc.b 4, 8, 0, 9, $FF, $F0	
00017F7A 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017F80 0004                       SME_lde97_168:	dc.b 0, 4	
00017F82 EB0D 0000 FFEC             		dc.b $EB, $D, 0, 0, $FF, $EC	
00017F88 FB09 0008 FFEC             		dc.b $FB, 9, 0, 8, $FF, $EC	
00017F8E FB06 000E 0004             		dc.b $FB, 6, 0, $E, 0, 4	
00017F94 0B04 0014 FFEC             		dc.b $B, 4, 0, $14, $FF, $EC	
00017F9A 0002                       SME_lde97_182:	dc.b 0, 2	
00017F9C EC0D 0000 FFED             		dc.b $EC, $D, 0, 0, $FF, $ED	
00017FA2 FC0E 0008 FFF5             		dc.b $FC, $E, 0, 8, $FF, $F5	
00017FA8 0002                       SME_lde97_190:	dc.b 0, 2	
00017FAA ED09 0000 FFF3             		dc.b $ED, 9, 0, 0, $FF, $F3	
00017FB0 FD0A 0006 FFF3             		dc.b $FD, $A, 0, 6, $FF, $F3	
00017FB6 0004                       SME_lde97_19E:	dc.b 0, 4	
00017FB8 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00017FBE FB09 0006 FFEC             		dc.b $FB, 9, 0, 6, $FF, $EC	
00017FC4 FB06 000C 0004             		dc.b $FB, 6, 0, $C, 0, 4	
00017FCA 0B04 0012 FFEC             		dc.b $B, 4, 0, $12, $FF, $EC	
00017FD0 0002                       SME_lde97_1B8:	dc.b 0, 2	
00017FD2 EC09 0000 FFF3             		dc.b $EC, 9, 0, 0, $FF, $F3	
00017FD8 FC0E 0006 FFEB             		dc.b $FC, $E, 0, 6, $FF, $EB	
00017FDE 0003                       SME_lde97_1C6:	dc.b 0, 3	
00017FE0 ED0D 0000 FFEC             		dc.b $ED, $D, 0, 0, $FF, $EC	
00017FE6 FD0C 0008 FFF4             		dc.b $FD, $C, 0, 8, $FF, $F4	
00017FEC 0509 000C FFF4             		dc.b 5, 9, 0, $C, $FF, $F4	
00017FF2 0005                       SME_lde97_1DA:	dc.b 0, 5	
00017FF4 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
00017FFA EB06 0006 0003             		dc.b $EB, 6, 0, 6, 0, 3	
00018000 FB08 000C FFEB             		dc.b $FB, 8, 0, $C, $FF, $EB	
00018006 0309 000F FFF3             		dc.b 3, 9, 0, $F, $FF, $F3	
0001800C 1300 0015 FFFB             		dc.b $13, 0, 0, $15, $FF, $FB	
00018012 0006                       SME_lde97_1FA:	dc.b 0, 6	
00018014 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
0001801A EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
00018020 FC0C 0008 FFEC             		dc.b $FC, $C, 0, 8, $FF, $EC	
00018026 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
0001802C FC05 0012 000C             		dc.b $FC, 5, 0, $12, 0, $C	
00018032 F400 0016 0014             		dc.b $F4, 0, 0, $16, 0, $14	
00018038 0004                       SME_lde97_220:	dc.b 0, 4	
0001803A ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00018040 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
00018046 FD0D 0008 FFF5             		dc.b $FD, $D, 0, 8, $FF, $F5	
0001804C 0D08 0010 FFFD             		dc.b $D, 8, 0, $10, $FF, $FD	
00018052 0005                       SME_lde97_23A:	dc.b 0, 5	
00018054 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
0001805A EB05 0006 0003             		dc.b $EB, 5, 0, 6, 0, 3	
00018060 FB0D 000A FFF3             		dc.b $FB, $D, 0, $A, $FF, $F3	
00018066 0B08 0012 FFF3             		dc.b $B, 8, 0, $12, $FF, $F3	
0001806C 1304 0015 FFFB             		dc.b $13, 4, 0, $15, $FF, $FB	
00018072 0004                       SME_lde97_25A:	dc.b 0, 4	
00018074 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
0001807A EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
00018080 FC0D 0008 FFF4             		dc.b $FC, $D, 0, 8, $FF, $F4	
00018086 0C08 0010 FFFC             		dc.b $C, 8, 0, $10, $FF, $FC	
0001808C 0005                       SME_lde97_274:	dc.b 0, 5	
0001808E ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00018094 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
0001809A FD00 0008 FFED             		dc.b $FD, 0, 0, 8, $FF, $ED	
000180A0 FD0D 0009 FFF5             		dc.b $FD, $D, 0, 9, $FF, $F5	
000180A6 0D08 0011 FFFD             		dc.b $D, 8, 0, $11, $FF, $FD	
000180AC 0004                       SME_lde97_294:	dc.b 0, 4	
000180AE F407 0000 FFEB             		dc.b $F4, 7, 0, 0, $FF, $EB	
000180B4 EC09 0008 FFFB             		dc.b $EC, 9, 0, 8, $FF, $FB	
000180BA FC04 000E FFFB             		dc.b $FC, 4, 0, $E, $FF, $FB	
000180C0 0409 0010 FFFB             		dc.b 4, 9, 0, $10, $FF, $FB	
000180C6 0002                       SME_lde97_2AE:	dc.b 0, 2	
000180C8 F407 0000 FFEC             		dc.b $F4, 7, 0, 0, $FF, $EC	
000180CE EC0B 0008 FFFC             		dc.b $EC, $B, 0, 8, $FF, $FC	
000180D4 0002                       SME_lde97_2BC:	dc.b 0, 2	
000180D6 F406 0000 FFED             		dc.b $F4, 6, 0, 0, $FF, $ED	
000180DC F40A 0006 FFFD             		dc.b $F4, $A, 0, 6, $FF, $FD	
000180E2 0004                       SME_lde97_2CA:	dc.b 0, 4	
000180E4 F406 0000 FFEB             		dc.b $F4, 6, 0, 0, $FF, $EB	
000180EA EC09 0006 FFFB             		dc.b $EC, 9, 0, 6, $FF, $FB	
000180F0 FC04 000C FFFB             		dc.b $FC, 4, 0, $C, $FF, $FB	
000180F6 0409 000E FFFB             		dc.b 4, 9, 0, $E, $FF, $FB	
000180FC 0002                       SME_lde97_2E4:	dc.b 0, 2	
000180FE F406 0000 FFEC             		dc.b $F4, 6, 0, 0, $FF, $EC	
00018104 F40B 0006 FFFC             		dc.b $F4, $B, 0, 6, $FF, $FC	
0001810A 0003                       SME_lde97_2F2:	dc.b 0, 3	
0001810C F407 0000 FFED             		dc.b $F4, 7, 0, 0, $FF, $ED	
00018112 EC00 0008 FFFD             		dc.b $EC, 0, 0, 8, $FF, $FD	
00018118 F40A 0009 FFFD             		dc.b $F4, $A, 0, 9, $FF, $FD	
0001811E 0006                       SME_lde97_306:	dc.b 0, 6	
00018120 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
00018126 ED04 0006 FFF3             		dc.b $ED, 4, 0, 6, $FF, $F3	
0001812C F504 0008 FFEB             		dc.b $F5, 4, 0, 8, $FF, $EB	
00018132 F50A 000A FFFB             		dc.b $F5, $A, 0, $A, $FF, $FB	
00018138 0D00 0013 FFFB             		dc.b $D, 0, 0, $13, $FF, $FB	
0001813E FD00 0014 0013             		dc.b $FD, 0, 0, $14, 0, $13	
00018144 0006                       SME_lde97_32C:	dc.b 0, 6	
00018146 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
0001814C E408 0006 FFF4             		dc.b $E4, 8, 0, 6, $FF, $F4	
00018152 EC04 0009 FFFC             		dc.b $EC, 4, 0, 9, $FF, $FC	
00018158 F404 000B FFEC             		dc.b $F4, 4, 0, $B, $FF, $EC	
0001815E F40A 000D FFFC             		dc.b $F4, $A, 0, $D, $FF, $FC	
00018164 0C00 0016 FFFC             		dc.b $C, 0, 0, $16, $FF, $FC	
0001816A 0004                       SME_lde97_352:	dc.b 0, 4	
0001816C FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00018172 F304 0006 FFED             		dc.b $F3, 4, 0, 6, $FF, $ED	
00018178 EB0A 0008 FFFD             		dc.b $EB, $A, 0, 8, $FF, $FD	
0001817E 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00018184 0005                       SME_lde97_36C:	dc.b 0, 5	
00018186 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
0001818C ED08 0006 FFF3             		dc.b $ED, 8, 0, 6, $FF, $F3	
00018192 F504 0009 FFEB             		dc.b $F5, 4, 0, 9, $FF, $EB	
00018198 F50D 000B FFFB             		dc.b $F5, $D, 0, $B, $FF, $FB	
0001819E 0508 0013 FFFB             		dc.b 5, 8, 0, $13, $FF, $FB	
000181A4 0004                       SME_lde97_38C:	dc.b 0, 4	
000181A6 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
000181AC F404 0006 FFEC             		dc.b $F4, 4, 0, 6, $FF, $EC	
000181B2 EC0A 0008 FFFC             		dc.b $EC, $A, 0, 8, $FF, $FC	
000181B8 0404 0011 FFFC             		dc.b 4, 4, 0, $11, $FF, $FC	
000181BE 0005                       SME_lde97_3A6:	dc.b 0, 5	
000181C0 FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
000181C6 EB0A 0006 FFFD             		dc.b $EB, $A, 0, 6, $FF, $FD	
000181CC F304 000F FFED             		dc.b $F3, 4, 0, $F, $FF, $ED	
000181D2 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
000181D8 0B00 0013 FFFD             		dc.b $B, 0, 0, $13, $FF, $FD	
000181DE 0002                       SME_lde97_3C6:	dc.b 0, 2	
000181E0 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000181E6 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000181EC 0002                       SME_lde97_3D4:	dc.b 0, 2	
000181EE EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000181F4 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000181FA 0002                       SME_lde97_3E2:	dc.b 0, 2	
000181FC EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018202 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018208 0002                       SME_lde97_3F0:	dc.b 0, 2	
0001820A EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018210 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018216 0004                       SME_lde97_3FE:	dc.b 0, 4	
00018218 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
0001821E EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018224 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
0001822A FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
00018230 0003                       SME_lde97_418:	dc.b 0, 3	
00018232 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018238 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
0001823E FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018244 0004                       SME_lde97_42C:	dc.b 0, 4	
00018246 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
0001824C EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00018252 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018258 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
0001825E 0003                       SME_lde97_446:	dc.b 0, 3	
00018260 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018266 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
0001826C FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018272 0002                       SME_lde97_45A:	dc.b 0, 2	
00018274 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
0001827A F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00018280 0002                       SME_lde97_468:	dc.b 0, 2	
00018282 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018288 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0001828E 0002                       SME_lde97_476:	dc.b 0, 2	
00018290 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018296 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0001829C 0002                       SME_lde97_484:	dc.b 0, 2	
0001829E F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
000182A4 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182AA 0004                       SME_lde97_492:	dc.b 0, 4	
000182AC FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
000182B2 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
000182B8 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182BE 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
000182C4 0002                       SME_lde97_4AC:	dc.b 0, 2	
000182C6 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
000182CC EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182D2 0004                       SME_lde97_4BA:	dc.b 0, 4	
000182D4 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
000182DA F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
000182E0 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182E6 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
000182EC 0002                       SME_lde97_4D4:	dc.b 0, 2	
000182EE F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
000182F4 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000182FA 0001                       SME_lde97_4E2:	dc.b 0, 1	
000182FC F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018302 0001                       SME_lde97_4EA:	dc.b 0, 1	
00018304 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001830A 0001                       SME_lde97_4F2:	dc.b 0, 1	
0001830C F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018312 0001                       SME_lde97_4FA:	dc.b 0, 1	
00018314 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001831A 0001                       SME_lde97_502:	dc.b 0, 1	
0001831C F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018322 0000                       SME_lde97_50A:	dc.b 0, 0	
00018324 0000                       SME_lde97_50C:	dc.b 0, 0	
00018326 0000                       SME_lde97_50E:	dc.b 0, 0	
00018328 0000                       SME_lde97_510:	dc.b 0, 0	
0001832A 0002                       SME_lde97_512:	dc.b 0, 2	
0001832C ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
00018332 FD0E 0006 FFF0             		dc.b $FD, $E, 0, 6, $FF, $F0	
00018338 0004                       SME_lde97_520:	dc.b 0, 4	
0001833A ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
00018340 FD0D 0006 FFF0             		dc.b $FD, $D, 0, 6, $FF, $F0	
00018346 0D04 000E 0000             		dc.b $D, 4, 0, $E, 0, 0	
0001834C 0500 0010 FFE8             		dc.b 5, 0, 0, $10, $FF, $E8	
00018352 0004                       SME_lde97_53A:	dc.b 0, 4	
00018354 F404 0000 FFFC             		dc.b $F4, 4, 0, 0, $FF, $FC	
0001835A FC0D 0002 FFF4             		dc.b $FC, $D, 0, 2, $FF, $F4	
00018360 0C08 000A FFF4             		dc.b $C, 8, 0, $A, $FF, $F4	
00018366 0400 000D FFEC             		dc.b 4, 0, 0, $D, $FF, $EC	
0001836C 0003                       SME_lde97_554:	dc.b 0, 3	
0001836E EC08 0800 FFE8             		dc.b $EC, 8, 8, 0, $FF, $E8	
00018374 F402 0803 0000             		dc.b $F4, 2, 8, 3, 0, 0	
0001837A F40F 0806 FFE0             		dc.b $F4, $F, 8, 6, $FF, $E0	
00018380 0003                       SME_lde97_568:	dc.b 0, 3	
00018382 EC0E 0800 FFE8             		dc.b $EC, $E, 8, 0, $FF, $E8	
00018388 040D 080C FFE0             		dc.b 4, $D, 8, $C, $FF, $E0	
0001838E 0C00 1814 0000             		dc.b $C, 0, $18, $14, 0, 0	
00018394 0003                       SME_lde97_57C:	dc.b 0, 3	
00018396 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
0001839C FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
000183A2 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
000183A8 0002                       SME_lde97_590:	dc.b 0, 2	
000183AA F40A 0000 FFE8             		dc.b $F4, $A, 0, 0, $FF, $E8	
000183B0 F40A 0800 0000             		dc.b $F4, $A, 8, 0, 0, 0	
000183B6 0003                       SME_lde97_59E:	dc.b 0, 3	
000183B8 F40D 0000 FFE4             		dc.b $F4, $D, 0, 0, $FF, $E4	
000183BE FC00 0008 0004             		dc.b $FC, 0, 0, 8, 0, 4	
000183C4 040C 0009 FFEC             		dc.b 4, $C, 0, 9, $FF, $EC	
000183CA 0003                       SME_lde97_5B2:	dc.b 0, 3	
000183CC F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
000183D2 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
000183D8 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
000183DE 0003                       SME_lde97_5C6:	dc.b 0, 3	
000183E0 E80B 0000 FFF0             		dc.b $E8, $B, 0, 0, $FF, $F0	
000183E6 0804 000C FFF8             		dc.b 8, 4, 0, $C, $FF, $F8	
000183EC 1000 000E FFF8             		dc.b $10, 0, 0, $E, $FF, $F8	
000183F2 0004                       SME_lde97_5DA:	dc.b 0, 4	
000183F4 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
000183FA 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
00018400 F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
00018406 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
0001840C 0004                       SME_lde97_5F4:	dc.b 0, 4	
0001840E F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
00018414 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
0001841A F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
00018420 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
00018426 0000                       SME_lde97_60E:	dc.b 0, 0	
00018428 0000                       SME_lde97_610:	dc.b 0, 0	
0001842A 0002                       SME_lde97_612:	dc.b 0, 2	
0001842C ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00018432 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
00018438 0003                       SME_lde97_620:	dc.b 0, 3	
0001843A EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
00018440 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
00018446 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
0001844C 0002                       SME_lde97_634:	dc.b 0, 2	
0001844E ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00018454 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
0001845A 0003                       SME_lde97_642:	dc.b 0, 3	
0001845C EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
00018462 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
00018468 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
0001846E 0000                       SME_lde97_656:	dc.b 0, 0	
00018470 0000                       SME_lde97_658:	dc.b 0, 0	
00018472 0000                       SME_lde97_65A:	dc.b 0, 0	
00018474 0005                       SME_lde97_65C:	dc.b 0, 5	
00018476 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
0001847C E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
00018482 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00018488 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
0001848E 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
00018494 0005                       SME_lde97_67C:	dc.b 0, 5	
00018496 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
0001849C E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
000184A2 F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
000184A8 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
000184AE 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
000184B4 0000                       SME_lde97_69C:	dc.b 0, 0	
000184B6 0000                       SME_lde97_69E:	dc.b 0, 0	
000184B8 0000                       SME_lde97_6A0:	dc.b 0, 0	
000184BA 0000                       SME_lde97_6A2:	dc.b 0, 0	
000184BC 0000                       SME_lde97_6A4:	dc.b 0, 0	
000184BE 0003                       SME_lde97_6A6:	dc.b 0, 3	
000184C0 F40D 0800 FFE4             		dc.b $F4, $D, 8, 0, $FF, $E4	
000184C6 FC05 0808 0004             		dc.b $FC, 5, 8, 8, 0, 4	
000184CC 0408 080C FFEC             		dc.b 4, 8, 8, $C, $FF, $EC	
000184D2 0003                       SME_lde97_6BA:	dc.b 0, 3	
000184D4 F40D 0800 FFFC             		dc.b $F4, $D, 8, 0, $FF, $FC	
000184DA FC00 0808 FFF4             		dc.b $FC, 0, 8, 8, $FF, $F4	
000184E0 040C 0809 FFF4             		dc.b 4, $C, 8, 9, $FF, $F4	
000184E6 0003                       SME_lde97_6CE:	dc.b 0, 3	
000184E8 F00E 0000 FFEC             		dc.b $F0, $E, 0, 0, $FF, $EC	
000184EE F801 000C 000C             		dc.b $F8, 1, 0, $C, 0, $C	
000184F4 080C 000E FFF4             		dc.b 8, $C, 0, $E, $FF, $F4	
000184FA 0003                       SME_lde97_6E2:	dc.b 0, 3	
000184FC EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00018502 FB0E 0006 FFEC             		dc.b $FB, $E, 0, 6, $FF, $EC	
00018508 0301 0012 000C             		dc.b 3, 1, 0, $12, 0, $C	
0001850E 0002                       SME_lde97_6F6:	dc.b 0, 2	
00018510 F00F 0000 FFEC             		dc.b $F0, $F, 0, 0, $FF, $EC	
00018516 F802 0010 000C             		dc.b $F8, 2, 0, $10, 0, $C	
0001851C 0002                       SME_lde97_704:	dc.b 0, 2	
0001851E F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018524 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
0001852A 0002                       SME_lde97_712:	dc.b 0, 2	
0001852C F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018532 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
00018538 0002                       SME_lde97_720:	dc.b 0, 2	
0001853A F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
00018540 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
00018546 0002                       SME_lde97_72E:	dc.b 0, 2	
00018548 F40F 0000 FFF5             		dc.b $F4, $F, 0, 0, $FF, $F5	
0001854E FC01 0010 FFED             		dc.b $FC, 1, 0, $10, $FF, $ED	
00018554 0000                       SME_lde97_73C:	dc.b 0, 0	
00018556 0000                       SME_lde97_73E:	dc.b 0, 0	
00018558 0000                       SME_lde97_740:	dc.b 0, 0	
0001855A 0000                       SME_lde97_742:	dc.b 0, 0	
0001855C 0000                       SME_lde97_744:	dc.b 0, 0	
0001855E 0000                       SME_lde97_746:	dc.b 0, 0	
00018560 0000                       SME_lde97_748:	dc.b 0, 0	
00018562 0000                       SME_lde97_74A:	dc.b 0, 0	
00018564 0000                       SME_lde97_74C:	dc.b 0, 0	
00018566 0000                       SME_lde97_74E:	dc.b 0, 0	
00018568 0000                       SME_lde97_750:	dc.b 0, 0	
0001856A 0000                       SME_lde97_752:	dc.b 0, 0	
0001856C 0003                       SME_lde97_754:	dc.b 0, 3	
0001856E E409 0000 FFF0             		dc.b $E4, 9, 0, 0, $FF, $F0	
00018574 F40B 0006 FFF0             		dc.b $F4, $B, 0, 6, $FF, $F0	
0001857A F401 0012 0008             		dc.b $F4, 1, 0, $12, 0, 8	
00018580 0003                       SME_lde97_768:	dc.b 0, 3	
00018582 E50B 0000 FFF0             		dc.b $E5, $B, 0, 0, $FF, $F0	
00018588 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0001858E 0505 000E FFF8             		dc.b 5, 5, 0, $E, $FF, $F8	
00018594 0002                       SME_lde97_77C:	dc.b 0, 2	
00018596 EC0B 0000 FFF1             		dc.b $EC, $B, 0, 0, $FF, $F1	
0001859C FC01 000C 0009             		dc.b $FC, 1, 0, $C, 0, 9	
000185A2 0001                       SME_lde97_78A:	dc.b 0, 1	
000185A4 EE0F 0000 FFF0             		dc.b $EE, $F, 0, 0, $FF, $F0	
000185AA 0002                       SME_lde97_792:	dc.b 0, 2	
000185AC F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
000185B2 FA01 000C 0008             		dc.b $FA, 1, 0, $C, 0, 8	
000185B8 0003                       SME_lde97_7A0:	dc.b 0, 3	
000185BA F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000185C0 E401 000C 0000             		dc.b $E4, 1, 0, $C, 0, 0	
000185C6 F401 000E 0008             		dc.b $F4, 1, 0, $E, 0, 8	
000185CC 0003                       SME_lde97_7B4:	dc.b 0, 3	
000185CE E509 0000 FFF0             		dc.b $E5, 9, 0, 0, $FF, $F0	
000185D4 F50B 0006 FFF0             		dc.b $F5, $B, 0, 6, $FF, $F0	
000185DA ED03 0012 0008             		dc.b $ED, 3, 0, $12, 0, 8	
000185E0 0003                       SME_lde97_7C8:	dc.b 0, 3	
000185E2 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000185E8 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
000185EE E405 000E FFF8             		dc.b $E4, 5, 0, $E, $FF, $F8	
000185F4 0002                       SME_lde97_7DC:	dc.b 0, 2	
000185F6 ED0B 0000 FFF0             		dc.b $ED, $B, 0, 0, $FF, $F0	
000185FC F501 000C 0008             		dc.b $F5, 1, 0, $C, 0, 8	
00018602 0002                       SME_lde97_7EA:	dc.b 0, 2	
00018604 F10B 0000 FFF8             		dc.b $F1, $B, 0, 0, $FF, $F8	
0001860A F401 000C FFF0             		dc.b $F4, 1, 0, $C, $FF, $F0	
00018610 0003                       SME_lde97_7F8:	dc.b 0, 3	
00018612 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
00018618 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0001861E E405 000E FFF1             		dc.b $E4, 5, 0, $E, $FF, $F1	
00018624 0002                       SME_lde97_80C:	dc.b 0, 2	
00018626 F10F 0000 FFF0             		dc.b $F1, $F, 0, 0, $FF, $F0	
0001862C E105 0010 FFF0             		dc.b $E1, 5, 0, $10, $FF, $F0	
00018632 0002                       SME_lde97_81A:	dc.b 0, 2	
00018634 EC0E 0000 FFEC             		dc.b $EC, $E, 0, 0, $FF, $EC	
0001863A 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
00018640 0002                       SME_lde97_828:	dc.b 0, 2	
00018642 EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
00018648 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
0001864E 0002                       SME_lde97_836:	dc.b 0, 2	
00018650 EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
00018656 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
0001865C 0003                       SME_lde97_844:	dc.b 0, 3	
0001865E E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00018664 0008 000C FFF0             		dc.b 0, 8, 0, $C, $FF, $F0	
0001866A 0809 000F FFF8             		dc.b 8, 9, 0, $F, $FF, $F8	
00018670 0003                       SME_lde97_858:	dc.b 0, 3	
00018672 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00018678 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
0001867E 100C 0012 FFF0             		dc.b $10, $C, 0, $12, $FF, $F0	
00018684 0003                       SME_lde97_86C:	dc.b 0, 3	
00018686 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
0001868C 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
00018692 1004 0012 FFF0             		dc.b $10, 4, 0, $12, $FF, $F0	
00018698 0004                       SME_lde97_880:	dc.b 0, 4	
0001869A EC0E 0800 FFF0             		dc.b $EC, $E, 8, 0, $FF, $F0	
000186A0 FC01 080C 0010             		dc.b $FC, 1, 8, $C, 0, $10	
000186A6 0408 080E FFF8             		dc.b 4, 8, 8, $E, $FF, $F8	
000186AC 0C04 0811 0000             		dc.b $C, 4, 8, $11, 0, 0	
000186B2 0004                       SME_lde97_89A:	dc.b 0, 4	
000186B4 EC0E 0000 FFF8             		dc.b $EC, $E, 0, 0, $FF, $F8	
000186BA FC01 000C FFF0             		dc.b $FC, 1, 0, $C, $FF, $F0	
000186C0 0408 000E FFF8             		dc.b 4, 8, 0, $E, $FF, $F8	
000186C6 0C04 0011 FFF8             		dc.b $C, 4, 0, $11, $FF, $F8	
000186CC 0004                       SME_lde97_8B4:	dc.b 0, 4	
000186CE FC0E 1000 FFF8             		dc.b $FC, $E, $10, 0, $FF, $F8	
000186D4 F401 100C FFF0             		dc.b $F4, 1, $10, $C, $FF, $F0	
000186DA F408 100E FFF8             		dc.b $F4, 8, $10, $E, $FF, $F8	
000186E0 EC04 1011 FFF8             		dc.b $EC, 4, $10, $11, $FF, $F8	
000186E6 0004                       SME_lde97_8CE:	dc.b 0, 4	
000186E8 FC0E 1800 FFF0             		dc.b $FC, $E, $18, 0, $FF, $F0	
000186EE F401 180C 0010             		dc.b $F4, 1, $18, $C, 0, $10	
000186F4 F408 180E FFF8             		dc.b $F4, 8, $18, $E, $FF, $F8	
000186FA EC04 1811 0000             		dc.b $EC, 4, $18, $11, 0, 0	
00018700                            		even
00018700                            		even
00018700                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018700                            DPLC_ObjMighty:
00018700                            		include	"Level/Objects/Mighty/DPLCs.asm"
00018700                            ; --------------------------------------------------------------------------------
00018700                            ; Dynamic Pattern Loading Cues - output from SonMapEd - Sonic 3 & Knuckles format; --------------------------------------------------------------------------------
00018700                            
00018700                            SME_CfLJT:	
00018700 0000 0000                  		dc.w SME_CfLJT_FC-SME_CfLJT, SME_CfLJT_FE-SME_CfLJT	
00018704 0000 0000                  		dc.w SME_CfLJT_108-SME_CfLJT, SME_CfLJT_110-SME_CfLJT	
00018708 0000 0000                  		dc.w SME_CfLJT_118-SME_CfLJT, SME_CfLJT_120-SME_CfLJT	
0001870C 0000 0000                  		dc.w SME_CfLJT_128-SME_CfLJT, SME_CfLJT_132-SME_CfLJT	
00018710 0000 0000                  		dc.w SME_CfLJT_138-SME_CfLJT, SME_CfLJT_13E-SME_CfLJT	
00018714 0000 0000                  		dc.w SME_CfLJT_148-SME_CfLJT, SME_CfLJT_14E-SME_CfLJT	
00018718 0000 0000                  		dc.w SME_CfLJT_156-SME_CfLJT, SME_CfLJT_162-SME_CfLJT	
0001871C 0000 0000                  		dc.w SME_CfLJT_170-SME_CfLJT, SME_CfLJT_17A-SME_CfLJT	
00018720 0000 0000                  		dc.w SME_CfLJT_186-SME_CfLJT, SME_CfLJT_190-SME_CfLJT	
00018724 0000 0000                  		dc.w SME_CfLJT_19C-SME_CfLJT, SME_CfLJT_1A6-SME_CfLJT	
00018728 0000 0000                  		dc.w SME_CfLJT_1AC-SME_CfLJT, SME_CfLJT_1B2-SME_CfLJT	
0001872C 0000 0000                  		dc.w SME_CfLJT_1BC-SME_CfLJT, SME_CfLJT_1C2-SME_CfLJT	
00018730 0000 0000                  		dc.w SME_CfLJT_1CA-SME_CfLJT, SME_CfLJT_1D8-SME_CfLJT	
00018734 0000 0000                  		dc.w SME_CfLJT_1E6-SME_CfLJT, SME_CfLJT_1F0-SME_CfLJT	
00018738 0000 0000                  		dc.w SME_CfLJT_1FC-SME_CfLJT, SME_CfLJT_206-SME_CfLJT	
0001873C 0000 0000                  		dc.w SME_CfLJT_212-SME_CfLJT, SME_CfLJT_218-SME_CfLJT	
00018740 0000 0000                  		dc.w SME_CfLJT_21E-SME_CfLJT, SME_CfLJT_224-SME_CfLJT	
00018744 0000 0000                  		dc.w SME_CfLJT_22A-SME_CfLJT, SME_CfLJT_234-SME_CfLJT	
00018748 0000 0000                  		dc.w SME_CfLJT_23C-SME_CfLJT, SME_CfLJT_246-SME_CfLJT	
0001874C 0000 0000                  		dc.w SME_CfLJT_24E-SME_CfLJT, SME_CfLJT_254-SME_CfLJT	
00018750 0000 0000                  		dc.w SME_CfLJT_25A-SME_CfLJT, SME_CfLJT_260-SME_CfLJT	
00018754 0000 0000                  		dc.w SME_CfLJT_266-SME_CfLJT, SME_CfLJT_270-SME_CfLJT	
00018758 0000 0000                  		dc.w SME_CfLJT_276-SME_CfLJT, SME_CfLJT_280-SME_CfLJT	
0001875C 0000 0000                  		dc.w SME_CfLJT_286-SME_CfLJT, SME_CfLJT_28A-SME_CfLJT	
00018760 0000 0000                  		dc.w SME_CfLJT_28E-SME_CfLJT, SME_CfLJT_292-SME_CfLJT	
00018764 0000 0000                  		dc.w SME_CfLJT_296-SME_CfLJT, SME_CfLJT_29A-SME_CfLJT	
00018768 0000 0000                  		dc.w SME_CfLJT_29C-SME_CfLJT, SME_CfLJT_29E-SME_CfLJT	
0001876C 0000 0000                  		dc.w SME_CfLJT_2A0-SME_CfLJT, SME_CfLJT_2A2-SME_CfLJT	
00018770 0000 0000                  		dc.w SME_CfLJT_2A8-SME_CfLJT, SME_CfLJT_2B2-SME_CfLJT	
00018774 0000 0000                  		dc.w SME_CfLJT_2BC-SME_CfLJT, SME_CfLJT_2C4-SME_CfLJT	
00018778 0000 0000                  		dc.w SME_CfLJT_2CC-SME_CfLJT, SME_CfLJT_2D4-SME_CfLJT	
0001877C 0000 0000                  		dc.w SME_CfLJT_2D8-SME_CfLJT, SME_CfLJT_2E0-SME_CfLJT	
00018780 0000 0000                  		dc.w SME_CfLJT_2E8-SME_CfLJT, SME_CfLJT_2F0-SME_CfLJT	
00018784 0000 0000                  		dc.w SME_CfLJT_2FA-SME_CfLJT, SME_CfLJT_304-SME_CfLJT	
00018788 0000 0000                  		dc.w SME_CfLJT_306-SME_CfLJT, SME_CfLJT_308-SME_CfLJT	
0001878C 0000 0000                  		dc.w SME_CfLJT_30E-SME_CfLJT, SME_CfLJT_316-SME_CfLJT	
00018790 0000 0000                  		dc.w SME_CfLJT_31C-SME_CfLJT, SME_CfLJT_324-SME_CfLJT	
00018794 0000 0000                  		dc.w SME_CfLJT_326-SME_CfLJT, SME_CfLJT_328-SME_CfLJT	
00018798 0000 0000                  		dc.w SME_CfLJT_32A-SME_CfLJT, SME_CfLJT_336-SME_CfLJT	
0001879C 0000 0000                  		dc.w SME_CfLJT_342-SME_CfLJT, SME_CfLJT_344-SME_CfLJT	
000187A0 0000 0000                  		dc.w SME_CfLJT_346-SME_CfLJT, SME_CfLJT_348-SME_CfLJT	
000187A4 0000 0000                  		dc.w SME_CfLJT_34A-SME_CfLJT, SME_CfLJT_34C-SME_CfLJT	
000187A8 0000 0000                  		dc.w SME_CfLJT_354-SME_CfLJT, SME_CfLJT_35C-SME_CfLJT	
000187AC 0000 0000                  		dc.w SME_CfLJT_364-SME_CfLJT, SME_CfLJT_36C-SME_CfLJT	
000187B0 0000 0000                  		dc.w SME_CfLJT_372-SME_CfLJT, SME_CfLJT_378-SME_CfLJT	
000187B4 0000 0000                  		dc.w SME_CfLJT_37E-SME_CfLJT, SME_CfLJT_384-SME_CfLJT	
000187B8 0000 0000                  		dc.w SME_CfLJT_38A-SME_CfLJT, SME_CfLJT_38C-SME_CfLJT	
000187BC 0000 0000                  		dc.w SME_CfLJT_38E-SME_CfLJT, SME_CfLJT_390-SME_CfLJT	
000187C0 0000 0000                  		dc.w SME_CfLJT_392-SME_CfLJT, SME_CfLJT_394-SME_CfLJT	
000187C4 0000 0000                  		dc.w SME_CfLJT_396-SME_CfLJT, SME_CfLJT_398-SME_CfLJT	
000187C8 0000 0000                  		dc.w SME_CfLJT_39A-SME_CfLJT, SME_CfLJT_39C-SME_CfLJT	
000187CC 0000 0000                  		dc.w SME_CfLJT_39E-SME_CfLJT, SME_CfLJT_3A0-SME_CfLJT	
000187D0 0000 0000                  		dc.w SME_CfLJT_3A2-SME_CfLJT, SME_CfLJT_3AA-SME_CfLJT	
000187D4 0000 0000                  		dc.w SME_CfLJT_3B2-SME_CfLJT, SME_CfLJT_3B8-SME_CfLJT	
000187D8 0000 0000                  		dc.w SME_CfLJT_3BC-SME_CfLJT, SME_CfLJT_3C2-SME_CfLJT	
000187DC 0000 0000                  		dc.w SME_CfLJT_3CA-SME_CfLJT, SME_CfLJT_3D2-SME_CfLJT	
000187E0 0000 0000                  		dc.w SME_CfLJT_3DA-SME_CfLJT, SME_CfLJT_3E0-SME_CfLJT	
000187E4 0000 0000                  		dc.w SME_CfLJT_3E6-SME_CfLJT, SME_CfLJT_3EE-SME_CfLJT	
000187E8 0000 0000                  		dc.w SME_CfLJT_3F4-SME_CfLJT, SME_CfLJT_3FA-SME_CfLJT	
000187EC 0000 0000                  		dc.w SME_CfLJT_400-SME_CfLJT, SME_CfLJT_406-SME_CfLJT	
000187F0 0000 0000                  		dc.w SME_CfLJT_40E-SME_CfLJT, SME_CfLJT_416-SME_CfLJT	
000187F4 0000 0000                  		dc.w SME_CfLJT_41E-SME_CfLJT, SME_CfLJT_428-SME_CfLJT	
000187F8 0000 0000                  		dc.w SME_CfLJT_432-SME_CfLJT, SME_CfLJT_43C-SME_CfLJT	
000187FC 0000                       SME_CfLJT_FC:	dc.b 0, 0	
000187FE 0004 2000 7003 200B 200E   SME_CfLJT_FE:	dc.b 0, 4, $20, 0, $70, 3, $20, $B, $20, $E	
00018808 0003 5011 5017 201D        SME_CfLJT_108:	dc.b 0, 3, $50, $11, $50, $17, $20, $1D	
00018810 0003 5020 5017 201D        SME_CfLJT_110:	dc.b 0, 3, $50, $20, $50, $17, $20, $1D	
00018818 0003 5020 5017 2026        SME_CfLJT_118:	dc.b 0, 3, $50, $20, $50, $17, $20, $26	
00018820 0003 8029 200B 200E        SME_CfLJT_120:	dc.b 0, 3, $80, $29, $20, $B, $20, $E	
00018828 0004 7032 503A 5040 1046   SME_CfLJT_128:	dc.b 0, 4, $70, $32, $50, $3A, $50, $40, $10, $46	
00018832 0002 7032 B048             SME_CfLJT_132:	dc.b 0, 2, $70, $32, $B0, $48	
00018838 0002 5054 805A             SME_CfLJT_138:	dc.b 0, 2, $50, $54, $80, $5A	
0001883E 0004 5054 5063 5069 106F   SME_CfLJT_13E:	dc.b 0, 4, $50, $54, $50, $63, $50, $69, $10, $6F	
00018848 0002 5054 B071             SME_CfLJT_148:	dc.b 0, 2, $50, $54, $B0, $71	
0001884E 0003 7032 307D 5081        SME_CfLJT_14E:	dc.b 0, 3, $70, $32, $30, $7D, $50, $81	
00018856 0005 5087 508D 2093 5096+  SME_CfLJT_156:	dc.b 0, 5, $50, $87, $50, $8D, $20, $93, $50, $96, 0, $9C	
00018862 0006 5087 109D 309F 50A3+  SME_CfLJT_162:	dc.b 0, 6, $50, $87, $10, $9D, $30, $9F, $50, $A3, $30, $A9, 0, $AD	
00018870 0004 50AE 10B4 70B6 20BE   SME_CfLJT_170:	dc.b 0, 4, $50, $AE, $10, $B4, $70, $B6, $20, $BE	
0001887A 0005 50C1 30C7 70CB 20D3+  SME_CfLJT_17A:	dc.b 0, 5, $50, $C1, $30, $C7, $70, $CB, $20, $D3, $10, $D6	
00018886 0004 50C1 10D8 70DA 20E2   SME_CfLJT_186:	dc.b 0, 4, $50, $C1, $10, $D8, $70, $DA, $20, $E2	
00018890 0005 5087 109D 0093 70E5+  SME_CfLJT_190:	dc.b 0, 5, $50, $87, $10, $9D, 0, $93, $70, $E5, $20, $ED	
0001889C 0004 70F0 50F8 10FE 5100   SME_CfLJT_19C:	dc.b 0, 4, $70, $F0, $50, $F8, $10, $FE, $51, 0	
000188A6 0002 70F0 B106             SME_CfLJT_1A6:	dc.b 0, 2, $70, $F0, $B1, 6	
000188AC 0002 5112 8118             SME_CfLJT_1AC:	dc.b 0, 2, $51, $12, $81, $18	
000188B2 0004 5112 5121 1127 5129   SME_CfLJT_1B2:	dc.b 0, 4, $51, $12, $51, $21, $11, $27, $51, $29	
000188BC 0002 5112 B12F             SME_CfLJT_1BC:	dc.b 0, 2, $51, $12, $B1, $2F	
000188C2 0003 70F0 0106 813B        SME_CfLJT_1C2:	dc.b 0, 3, $70, $F0, 1, 6, $81, $3B	
000188CA 0006 5144 114A 114C 814E+  SME_CfLJT_1CA:	dc.b 0, 6, $51, $44, $11, $4A, $11, $4C, $81, $4E, 1, $57, 1, $58	
000188D8 0006 5144 2159 115C 115E+  SME_CfLJT_1D8:	dc.b 0, 6, $51, $44, $21, $59, $11, $5C, $11, $5E, $81, $60, 1, $57	
000188E6 0004 5169 116F 8171 117A   SME_CfLJT_1E6:	dc.b 0, 4, $51, $69, $11, $6F, $81, $71, $11, $7A	
000188F0 0005 517C 2182 1185 7187+  SME_CfLJT_1F0:	dc.b 0, 5, $51, $7C, $21, $82, $11, $85, $71, $87, $21, $8F	
000188FC 0004 517C 1192 8194 119D   SME_CfLJT_1FC:	dc.b 0, 4, $51, $7C, $11, $92, $81, $94, $11, $9D	
00018906 0005 5144 819F 115E 11A8+  SME_CfLJT_206:	dc.b 0, 5, $51, $44, $81, $9F, $11, $5E, $11, $A8, 1, $57	
00018912 0002 51AA B1B0             SME_CfLJT_212:	dc.b 0, 2, $51, $AA, $B1, $B0	
00018918 0002 5054 B1BC             SME_CfLJT_218:	dc.b 0, 2, $50, $54, $B1, $BC	
0001891E 0002 51AA B1C8             SME_CfLJT_21E:	dc.b 0, 2, $51, $AA, $B1, $C8	
00018924 0002 5054 B1D4             SME_CfLJT_224:	dc.b 0, 2, $50, $54, $B1, $D4	
0001892A 0004 51E0 11E6 B1E8 01F4   SME_CfLJT_22A:	dc.b 0, 4, $51, $E0, $11, $E6, $B1, $E8, 1, $F4	
00018934 0003 51F5 11FB B1FD        SME_CfLJT_234:	dc.b 0, 3, $51, $F5, $11, $FB, $B1, $FD	
0001893C 0004 51E0 1209 B20B 01F4   SME_CfLJT_23C:	dc.b 0, 4, $51, $E0, $12, 9, $B2, $B, 1, $F4	
00018946 0003 51F5 11FB B217        SME_CfLJT_246:	dc.b 0, 3, $51, $F5, $11, $FB, $B2, $17	
0001894E 0002 5223 B229             SME_CfLJT_24E:	dc.b 0, 2, $52, $23, $B2, $29	
00018954 0002 5112 B235             SME_CfLJT_254:	dc.b 0, 2, $51, $12, $B2, $35	
0001895A 0002 5223 B241             SME_CfLJT_25A:	dc.b 0, 2, $52, $23, $B2, $41	
00018960 0002 5112 B24D             SME_CfLJT_260:	dc.b 0, 2, $51, $12, $B2, $4D	
00018966 0004 5259 125F B261 026D   SME_CfLJT_266:	dc.b 0, 4, $52, $59, $12, $5F, $B2, $61, 2, $6D	
00018970 0002 726E B276             SME_CfLJT_270:	dc.b 0, 2, $72, $6E, $B2, $76	
00018976 0004 5259 1282 B284 026D   SME_CfLJT_276:	dc.b 0, 4, $52, $59, $12, $82, $B2, $84, 2, $6D	
00018980 0002 726E B290             SME_CfLJT_280:	dc.b 0, 2, $72, $6E, $B2, $90	
00018986 0001 F29C                  SME_CfLJT_286:	dc.b 0, 1, $F2, $9C	
0001898A 0001 F2AC                  SME_CfLJT_28A:	dc.b 0, 1, $F2, $AC	
0001898E 0001 F2BC                  SME_CfLJT_28E:	dc.b 0, 1, $F2, $BC	
00018992 0001 F2CC                  SME_CfLJT_292:	dc.b 0, 1, $F2, $CC	
00018996 0001 F2DC                  SME_CfLJT_296:	dc.b 0, 1, $F2, $DC	
0001899A 0000                       SME_CfLJT_29A:	dc.b 0, 0	
0001899C 0000                       SME_CfLJT_29C:	dc.b 0, 0	
0001899E 0000                       SME_CfLJT_29E:	dc.b 0, 0	
000189A0 0000                       SME_CfLJT_2A0:	dc.b 0, 0	
000189A2 0002 52EC B2F2             SME_CfLJT_2A2:	dc.b 0, 2, $52, $EC, $B2, $F2	
000189A8 0004 52FE 7304 130C 030E   SME_CfLJT_2A8:	dc.b 0, 4, $52, $FE, $73, 4, $13, $C, 3, $E	
000189B2 0004 130F 7311 2319 031C   SME_CfLJT_2B2:	dc.b 0, 4, $13, $F, $73, $11, $23, $19, 3, $1C	
000189BC 0003 231D 2320 F323        SME_CfLJT_2BC:	dc.b 0, 3, $23, $1D, $23, $20, $F3, $23	
000189C4 0003 B333 733F 0071        SME_CfLJT_2C4:	dc.b 0, 3, $B3, $33, $73, $3F, 0, $71	
000189CC 0003 7347 334F 2353        SME_CfLJT_2CC:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
000189D4 0001 8356                  SME_CfLJT_2D4:	dc.b 0, 1, $83, $56	
000189D8 0003 735F 0367 3368        SME_CfLJT_2D8:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
000189E0 0003 736C 3374 2378        SME_CfLJT_2E0:	dc.b 0, 3, $73, $6C, $33, $74, $23, $78	
000189E8 0003 B37B 1387 0389        SME_CfLJT_2E8:	dc.b 0, 3, $B3, $7B, $13, $87, 3, $89	
000189F0 0004 B38A 3396 039A 039B   SME_CfLJT_2F0:	dc.b 0, 4, $B3, $8A, $33, $96, 3, $9A, 3, $9B	
000189FA 0004 B39C 33A8 03AC 03AD   SME_CfLJT_2FA:	dc.b 0, 4, $B3, $9C, $33, $A8, 3, $AC, 3, $AD	
00018A04 0000                       SME_CfLJT_304:	dc.b 0, 0	
00018A06 0000                       SME_CfLJT_306:	dc.b 0, 0	
00018A08 0002 83AE 73B7             SME_CfLJT_308:	dc.b 0, 2, $83, $AE, $73, $B7	
00018A0E 0003 83BF 23C8 13CB        SME_CfLJT_30E:	dc.b 0, 3, $83, $BF, $23, $C8, $13, $CB	
00018A16 0002 83CD 73D6             SME_CfLJT_316:	dc.b 0, 2, $83, $CD, $73, $D6	
00018A1C 0003 83BF 23DE 13E1        SME_CfLJT_31C:	dc.b 0, 3, $83, $BF, $23, $DE, $13, $E1	
00018A24 0000                       SME_CfLJT_324:	dc.b 0, 0	
00018A26 0000                       SME_CfLJT_326:	dc.b 0, 0	
00018A28 0000                       SME_CfLJT_328:	dc.b 0, 0	
00018A2A 0005 73E3 13EB 53ED 33F3+  SME_CfLJT_32A:	dc.b 0, 5, $73, $E3, $13, $EB, $53, $ED, $33, $F3, 3, $F7	
00018A36 0005 73F8 13EB 5400 33F3+  SME_CfLJT_336:	dc.b 0, 5, $73, $F8, $13, $EB, $54, 0, $33, $F3, 3, $F7	
00018A42 0000                       SME_CfLJT_342:	dc.b 0, 0	
00018A44 0000                       SME_CfLJT_344:	dc.b 0, 0	
00018A46 0000                       SME_CfLJT_346:	dc.b 0, 0	
00018A48 0000                       SME_CfLJT_348:	dc.b 0, 0	
00018A4A 0000                       SME_CfLJT_34A:	dc.b 0, 0	
00018A4C 0003 7347 334F 2353        SME_CfLJT_34C:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018A54 0003 735F 0367 3368        SME_CfLJT_354:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018A5C 0003 B406 1412 3414        SME_CfLJT_35C:	dc.b 0, 3, $B4, 6, $14, $12, $34, $14	
00018A64 0003 5418 B41E 106D        SME_CfLJT_364:	dc.b 0, 3, $54, $18, $B4, $1E, $10, $6D	
00018A6C 0002 F42A 243A             SME_CfLJT_36C:	dc.b 0, 2, $F4, $2A, $24, $3A	
00018A72 0002 F43D 244D             SME_CfLJT_372:	dc.b 0, 2, $F4, $3D, $24, $4D	
00018A78 0002 F450 2460             SME_CfLJT_378:	dc.b 0, 2, $F4, $50, $24, $60	
00018A7E 0002 F463 2473             SME_CfLJT_37E:	dc.b 0, 2, $F4, $63, $24, $73	
00018A84 0002 F476 1486             SME_CfLJT_384:	dc.b 0, 2, $F4, $76, $14, $86	
00018A8A 0000                       SME_CfLJT_38A:	dc.b 0, 0	
00018A8C 0000                       SME_CfLJT_38C:	dc.b 0, 0	
00018A8E 0000                       SME_CfLJT_38E:	dc.b 0, 0	
00018A90 0000                       SME_CfLJT_390:	dc.b 0, 0	
00018A92 0000                       SME_CfLJT_392:	dc.b 0, 0	
00018A94 0000                       SME_CfLJT_394:	dc.b 0, 0	
00018A96 0000                       SME_CfLJT_396:	dc.b 0, 0	
00018A98 0000                       SME_CfLJT_398:	dc.b 0, 0	
00018A9A 0000                       SME_CfLJT_39A:	dc.b 0, 0	
00018A9C 0000                       SME_CfLJT_39C:	dc.b 0, 0	
00018A9E 0000                       SME_CfLJT_39E:	dc.b 0, 0	
00018AA0 0000                       SME_CfLJT_3A0:	dc.b 0, 0	
00018AA2 0003 5488 B48E 149A        SME_CfLJT_3A2:	dc.b 0, 3, $54, $88, $B4, $8E, $14, $9A	
00018AAA 0003 B49C 14A8 34AA        SME_CfLJT_3AA:	dc.b 0, 3, $B4, $9C, $14, $A8, $34, $AA	
00018AB2 0002 B4AE 14BA             SME_CfLJT_3B2:	dc.b 0, 2, $B4, $AE, $14, $BA	
00018AB8 0001 F4BC                  SME_CfLJT_3B8:	dc.b 0, 1, $F4, $BC	
00018ABC 0002 B4CC 14D8             SME_CfLJT_3BC:	dc.b 0, 2, $B4, $CC, $14, $D8	
00018AC2 0003 B4DA 14E6 14E8        SME_CfLJT_3C2:	dc.b 0, 3, $B4, $DA, $14, $E6, $14, $E8	
00018ACA 0003 54EA B4F0 34FC        SME_CfLJT_3CA:	dc.b 0, 3, $54, $EA, $B4, $F0, $34, $FC	
00018AD2 0003 B500 150C 350E        SME_CfLJT_3D2:	dc.b 0, 3, $B5, 0, $15, $C, $35, $E	
00018ADA 0002 B512 151E             SME_CfLJT_3DA:	dc.b 0, 2, $B5, $12, $15, $1E	
00018AE0 0002 B520 152C             SME_CfLJT_3E0:	dc.b 0, 2, $B5, $20, $15, $2C	
00018AE6 0003 B52E 153A 353C        SME_CfLJT_3E6:	dc.b 0, 3, $B5, $2E, $15, $3A, $35, $3C	
00018AEE 0002 F540 3550             SME_CfLJT_3EE:	dc.b 0, 2, $F5, $40, $35, $50	
00018AF4 0002 B554 5560             SME_CfLJT_3F4:	dc.b 0, 2, $B5, $54, $55, $60	
00018AFA 0002 B566 2572             SME_CfLJT_3FA:	dc.b 0, 2, $B5, $66, $25, $72	
00018B00 0002 B575 2581             SME_CfLJT_400:	dc.b 0, 2, $B5, $75, $25, $81	
00018B06 0003 B584 2590 5593        SME_CfLJT_406:	dc.b 0, 3, $B5, $84, $25, $90, $55, $93	
00018B0E 0003 B599 55A5 35AB        SME_CfLJT_40E:	dc.b 0, 3, $B5, $99, $55, $A5, $35, $AB	
00018B16 0003 B5AF 55BB 15C1        SME_CfLJT_416:	dc.b 0, 3, $B5, $AF, $55, $BB, $15, $C1	
00018B1E 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_41E:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B28 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_428:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B32 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_432:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B3C 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_43C:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B46                            		even
00018B46                            		even
00018B46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018B46                            Ani_ObjMighty:
00018B46                            		include	"Level/Objects/Mighty/Animations.asm"
00018B46                            ; ---------------------------------------------------------------------------
00018B46                            ; Animation script - Sonic
00018B46                            ; ---------------------------------------------------------------------------
00018B46                            SonicAniData:
00018B46 0000                       		dc.w SonicAni_Walk-SonicAniData
00018B48 0000                       		dc.w SonicAni_Run-SonicAniData
00018B4A 0000                       		dc.w SonicAni_Roll-SonicAniData
00018B4C 0000                       		dc.w SonicAni_Roll2-SonicAniData
00018B4E 0000                       		dc.w SonicAni_Push-SonicAniData
00018B50 0000                       		dc.w SonicAni_Wait-SonicAniData
00018B52 0000                       		dc.w SonicAni_Balance-SonicAniData
00018B54 0000                       		dc.w SonicAni_LookUp-SonicAniData
00018B56 0000                       		dc.w SonicAni_Duck-SonicAniData
00018B58 0000                       		dc.w SonicAni_Sprint-SonicAniData
00018B5A 0000                       		dc.w SonicAni_Hang-SonicAniData
00018B5C 0000                       		dc.w SonicAni_Seizure-SonicAniData
00018B5E 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B60 0000                       		dc.w SonicAni_Skid-SonicAniData
00018B62 0000                       		dc.w SonicAni_Float1-SonicAniData
00018B64 0000                       		dc.w SonicAni_Float2-SonicAniData
00018B66 0000                       		dc.w SonicAni_Spring-SonicAniData
00018B68 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B6A 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B6C 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B6E 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B70 0000                       		dc.w SonicAni_Bubble-SonicAniData
00018B72 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B74 0000                       		dc.w SonicAni_Drown-SonicAniData
00018B76 0000                       		dc.w SonicAni_Death-SonicAniData
00018B78 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B7A 0000                       		dc.w SonicAni_Hurt-SonicAniData
00018B7C 0000                       		dc.w SonicAni_Slide-SonicAniData
00018B7E 0000                       		dc.w SonicAni_Blank-SonicAniData
00018B80 0000                       		dc.w SonicAni_Float3-SonicAniData
00018B82 0000                       		dc.w SonicAni_Float4-SonicAniData
00018B84 0100 FD00                  SonicAni_Blank:		dc.b 1, 0, $FD, 0
00018B88 FF08 090A 0B06 07FF        SonicAni_Walk:		dc.b $FF, $08, $09, $0A, $0B, $06, $07, $FF
00018B90 FF1E 1F20 21FF FFFF        SonicAni_Run:		dc.b $FF, $1E, $1F, $20, $21, $FF, $FF,	$FF
00018B98 FF58 595A 5BFF FFFF        SonicAni_Sprint:	dc.b $FF, $58, $59, $5A, $5B, $FF, $FF, $FF
00018BA0 FE2E 2F30 3132 FFFF        SonicAni_Roll:		dc.b $FE, $2E, $2F, $30, $31, $32, $FF,	$FF
00018BA8 FE2E 2F32 3031 32FF        SonicAni_Roll2:		dc.b $FE, $2E, $2F, $32, $30, $31, $32,	$FF
00018BB0 FD45 4647 48FF FFFF        SonicAni_Push:		dc.b $FD, $45, $46, $47, $48, $FF, $FF,	$FF
00018BB8 1701 0101 0101 0101 0101+  SonicAni_Wait:		dc.b $17, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 3, 2, 2, 2, 3, 4, $FE, 2, 0
00018BCE 1F3A 3BFF                  SonicAni_Balance:	dc.b $1F, $3A, $3B, $FF
00018BD2 3F05 FF00                  SonicAni_LookUp:	dc.b $3F, 5, $FF, 0
00018BD6 3F39 FF00                  SonicAni_Duck:		dc.b $3F, $39, $FF, 0
00018BDA 0737 38FF                  SonicAni_Skid:		dc.b 7,	$37, $38, $FF
00018BDE 073C 3FFF                  SonicAni_Float1:	dc.b 7,	$3C, $3F, $FF
00018BE2 073C 3D53 3E54 FF00        SonicAni_Float2:	dc.b 7,	$3C, $3D, $53, $3E, $54, $FF, 0
00018BEA 2F40 FD00                  SonicAni_Spring:	dc.b $2F, $40, $FD, 0
00018BEE FC78 7978 77FF             SonicAni_Hang:		dc.b $FC, $78, $79, $78, $77, $FF
00018BF4 0B56 560A 0BFD 0000        SonicAni_Bubble:	dc.b $B, $56, $56, $A, $B, $FD,	0, 0
00018BFC 2F4C FF00                  SonicAni_Drown:		dc.b $2F, $4C, $FF, 0
00018C00 034D FF00                  SonicAni_Death:		dc.b 3,	$4D, $FF, 0
00018C04 0355 FF00                  SonicAni_Hurt:		dc.b 3,	$55, $FF, 0
00018C08 0755 57FF                  SonicAni_Slide:		dc.b 7, $55, $57, $FF
00018C0C 033C 3D53 3E54 FF00        SonicAni_Float3:	dc.b 3,	$3C, $3D, $53, $3E, $54, $FF, 0
00018C14 033C FD00                  SonicAni_Float4:	dc.b 3,	$3C, $FD, 0
00018C18 027A 7B7C 7DFF             SonicAni_Seizure:	dc.b 2, $7A, $7B, $7C, $7D, $FF
00018C1E                            		even
00018C1E                            		even
00018C1E                            ; =========================================================================================================================================================
00018C1E                            		include	"Level/Objects/Ring/Code.asm"		; Ring loss object
00018C1E                            ; =========================================================================================================================================================
00018C1E                            ; Mighty The Armadillo in PRISM PARADISE
00018C1E                            ; By Nat The Porcupine 2021
00018C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C1E                            ; Water surface object
00018C1E                            ; =========================================================================================================================================================
00018C1E                            		rsset	oLvlSSTs
00018C1E                            
00018C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C1E                            ObjRingLoss:
00018C1E 2248                       		movea.l	a0,a1
00018C20 7A00                       		moveq	#0,d5
00018C22 3A38 F3D4                  		move.w	rRings.w,d5
00018C26 7020                       		moveq	#32,d0
00018C28 BA40                       		cmp.w	d0,d5
00018C2A 6500                       		bcs.s	.BelowMax
00018C2C 3A00                       		move.w	d0,d5
00018C2E                            
00018C2E                            .BelowMax:
00018C2E 5345                       		subq.w	#1,d5
00018C30 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00018C36 6000                       		bra.s	.MakeRings
00018C38                            
00018C38                            .Loop:
00018C38 4EB8 1998                  		jsr	FindFreeObj.w
00018C3C 6700                       		beq.s	.ResetCounter
00018C3E                            
00018C3E                            .MakeRings:
00018C3E 22BC 0000 0000             		move.l	#ObjLostRing,oAddr(a1)
00018C44 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00018C4A 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00018C50 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,oMap(a1)	; Mappings
00018C58 337C 26B4 000E             		move.w	#$26B4,oVRAM(a1)		; Tile properties
00018C5E 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00018C64                            	displaySprite	3,a1,a2,0			; Priority
00018C64 337C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a1)
00018C6A 3478 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a2
00018C6E 334A 000A                M 	move.w	a2,odrawprev(a1)
00018C72 3549 0008                M 	move.w	a1,odrawnext(a2)
00018C76 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00018C7A                          M .no_223
00018C7A 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00018C80 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00018C86 137C 0008 002C             		move.b	#8,oColW(a1)			; Collision width
00018C8C 137C 0008 002D             		move.b	#8,oColH(a1)			; Collision height
00018C92 335B 001C                  		move.w	(a3)+,oXVel(a1)
00018C96 335B 001E                  		move.w	(a3)+,oYVel(a1)
00018C9A 51CD FF9C                  		dbf	d5,.Loop
00018C9E 11FC 00FF F3D9             		move.b	#-1,rRLossAniT.w
00018CA4                            
00018CA4                            .ResetCounter:
00018CA4 4278 F3D4                  		clr.w	rRings.w
00018CA8 11FC 0001 F8F3             		move.b	#1,rUpdateRings.w
00018CAE                            		playSnd	#sRingLoss, 2
00018CAE 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00018CB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018CB4                            ObjLostRing:
00018CB4 4EB8 1CCC                  		jsr	ObjectMove.w
00018CB8 0668 0018 001E             		addi.w	#$18,oYVel(a0)
00018CBE 6B00                       		bmi.s	.ChkCol
00018CC0 1038 C759                  		move.b	(rFrameCnt+3).w,d0
00018CC4 D048                       		add.w	a0,d0
00018CC6 0200 0006                  		andi.b	#6,d0
00018CCA 6600                       		bne.s	.ChkCol
00018CCC 4EB8 2FAE                  		jsr	ObjCheckFloorDist
00018CD0 4A41                       		tst.w	d1
00018CD2 6A00                       		bpl.s	.ChkCol
00018CD4 D368 0018                  		add.w	d1,oYPos(a0)
00018CD8 3028 001E                  		move.w	oYVel(a0),d0
00018CDC E440                       		asr.w	#2,d0
00018CDE 9168 001E                  		sub.w	d0,oYVel(a0)
00018CE2 4468 001E                  		neg.w	oYVel(a0)
00018CE6                            
00018CE6                            .ChkCol:
00018CE6 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00018CEA 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00018CEE 4EB8 1D06                  		jsr	CheckObjInRange.w		; Is the player in range?
00018CF2 4A40                       		tst.w	d0				; ''
00018CF4 6700                       		beq.s	.ChkDel				; If not, branch
00018CF6 0C2A 0069 0042             		cmpi.b	#105,oInvulTime(a2)
00018CFC 6400                       		bhs.s	.ChkDel
00018CFE 6000                       		bra.s	ObjLostRing_Collect
00018D00                            
00018D00                            .ChkDel:
00018D00 4A38 F3D9                  		tst.b	rRLossAniT.w
00018D04 6700                       		beq.s	ObjLostRing_Delete
00018D06 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
00018D0A 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00018D0E B068 0018                  		cmp.w	oYPos(a0),d0			; Have we touched the bottom boundary?
00018D12 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00018D14                            	nextObject
00018D14 3068 0004                M 	movea.w	onext(a0),a0
00018D18 2250                     M 	move.l	oaddr(a0),a1
00018D1A 4ED1                     M 	jmp	(a1)
00018D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D1C                            .RangeData:
00018D1C FFF0 0020                  		dc.w	-$10, $20
00018D20 FFF0 0020                  		dc.w	-$10, $20
00018D24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D24                            ObjLostRing_Collect:
00018D24                            	removeSprite	a0,a1,0
00018D24 3268 000A                M 	move.w	odrawprev(a0),a1
00018D28 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00018D2E 3268 0008                M 	move.w	odrawnext(a0),a1
00018D32 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00018D38 42A8 0008                M 	clr.l	odrawnext(a0)
00018D3C                          M .yes_226
00018D3C                            	displaySprite	1,a0,a1,0
00018D3C 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018D42 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018D46 3149 000A                M 	move.w	a1,odrawprev(a0)
00018D4A 3348 0008                M 	move.w	a0,odrawnext(a1)
00018D4E 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018D52                          M .no_227
00018D52 4EB8 3EB8                  		jsr	CollectRing
00018D56 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00018D5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D5C                            ObjLostRing_Sparkle:
00018D5C 43F9 0000 0000             		lea	Ani_ObjRing,a1
00018D62 4EB8 1BE6                  		jsr	AnimateObject.w
00018D66 4A28 0025                  		tst.b	oRoutine(a0)
00018D6A 6600                       		bne.s	ObjLostRing_Delete
00018D6C                            	nextObject
00018D6C 3068 0004                M 	movea.w	onext(a0),a0
00018D70 2250                     M 	move.l	oaddr(a0),a1
00018D72 4ED1                     M 	jmp	(a1)
00018D74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D74                            ObjLostRing_Delete:
00018D74 4EB8 19F2                  		jsr	DeleteObject.w
00018D78                            	nextObject
00018D78 3068 0004                M 	movea.w	onext(a0),a0
00018D7C 2250                     M 	move.l	oaddr(a0),a1
00018D7E 4ED1                     M 	jmp	(a1)
00018D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D80                            ; Ring Spawn Array
00018D80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D80                            ObjLostRing_Speeds:
00018D80 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00018D90 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00018DA0 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00018DB0 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00018DC0 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00018DD0 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00018DE0 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00018DF0 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00018E00                            		even
00018E00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E00                            ; Data
00018E00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E00                            Map_ObjLostRing:
00018E00                            		include	"Level/Objects/Ring/Mappings.asm"
00018E00                            ; --------------------------------------------------------------------------------
00018E00                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00018E00                            ; --------------------------------------------------------------------------------
00018E00                            
00018E00                            SME_k4ulR:	
00018E00 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00018E04 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00018E08 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00018E0A 0001                       SME_k4ulrA:	dc.b 0, 1	
00018E0C F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00018E12 0001                       SME_k4ulrC:	dc.b 0, 1	
00018E14 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018E1A 0001                       SME_k4ulr14:	dc.b 0, 1	
00018E1C F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018E22 0001                       SME_k4ulr1C:	dc.b 0, 1	
00018E24 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00018E2A 0001                       SME_k4ulr24:	dc.b 0, 1	
00018E2C F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00018E32                            		even
00018E32                            		even
00018E32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E32                            Ani_ObjRing:
00018E32 0000                       		dc.w	.Ani0-Ani_ObjRing
00018E34 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00018E3A                            		even
00018E3A                            ; =========================================================================================================================================================
00018E3A                            		include	"Level/Objects/Explosion/Code.asm"	; Explosion object
00018E3A                            ; =========================================================================================================================================================
00018E3A                            ; Mighty The Armadillo in PRISM PARADISE
00018E3A                            ; By Nat The Porcupine 2021
00018E3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E3A                            ; Explosion object
00018E3A                            ; =========================================================================================================================================================
00018E3A =00000003                  EXPLODE_ANI	EQU	3
00018E3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E3A                            ObjBossExplode:
00018E3A                            		playSnd	#sBomb, 2			; Play explosion sound
00018E3A 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00018E40 6000                       		bra.s	ObjExplosion_Init		; Continue
00018E42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E42                            ObjExplosion:
00018E42                            		playSnd	#sBreakItem, 2			; Play explosion sound
00018E42 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00018E48                            
00018E48                            ObjExplosion_Init:
00018E48 20BC 0000 0000             		move.l	#ObjExplosion_Main,oAddr(a0)	; Next routine
00018E4E 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00018E54 317C 86C0 000E             		move.w	#$86C0,oVRAM(a0)		; Tile properties
00018E5A 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,oMap(a0)	; Mappings
00018E62                            	displaySprite	1,a0,a1,0			; Priority
00018E62 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018E68 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018E6C 3149 000A                M 	move.w	a1,odrawprev(a0)
00018E70 3348 0008                M 	move.w	a0,odrawnext(a1)
00018E74 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018E78                          M .no_232
00018E78 117C 000C 0017             		move.b	#$C,oDrawW(a0)			; Sprite width
00018E7E 117C 000C 001B             		move.b	#$C,oDrawH(a0)			; Sprite height
00018E84 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Animation timer
00018E8A 4228 0010                  		clr.b	oFrame(a0)			; Mapping frame
00018E8E                            		
00018E8E                            ObjExplosion_Main:
00018E8E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00018E92 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00018E94 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Reset animation timer
00018E9A 5228 0010                  		addq.b	#1,oFrame(a0)			; Next frame
00018E9E 0C28 0005 0010             		cmpi.b	#5,oFrame(a0)			; Has it reached the last frame?
00018EA4 6600                       		bne.s	.Display			; If not, branch
00018EA6 4EB8 19F2                  		jsr	DeleteObject.w
00018EAA                            		
00018EAA                            .Display:
00018EAA                            	nextObject
00018EAA 3068 0004                M 	movea.w	onext(a0),a0
00018EAE 2250                     M 	move.l	oaddr(a0),a1
00018EB0 4ED1                     M 	jmp	(a1)
00018EB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EB2                            ; Data
00018EB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EB2                            ArtKosM_Explosion:
00018EB2                            		incbin	"Level/Objects/Explosion/Art.kosm.bin"
00019344                            		even
00019344                            Map_ObjExplosion:
00019344                            		include	"Level/Objects/Explosion/Mappings.asm"
00019344                            ; --------------------------------------------------------------------------------
00019344                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019344                            ; --------------------------------------------------------------------------------
00019344                            
00019344                            SME_PS_OI:	
00019344 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
00019348 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
0001934C 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
0001934E 0001                       SME_PS_OI_A:	dc.b 0, 1	
00019350 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
00019356 0001                       SME_PS_OI_12:	dc.b 0, 1	
00019358 F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
0001935E 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00019360 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
00019366 0004                       SME_PS_OI_22:	dc.b 0, 4	
00019368 EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
0001936E EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
00019374 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
0001937A FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00019380 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00019382 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
00019388 EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
0001938E 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
00019394 FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
0001939A                            		even
0001939A                            		even
0001939A                            ; =========================================================================================================================================================
0001939A                            		include	"Level/Objects/Water Surface/Code.asm"	; Water surface object
0001939A                            ; =========================================================================================================================================================
0001939A                            ; Mighty The Armadillo in PRISM PARADISE
0001939A                            ; By Nat The Porcupine 2021
0001939A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001939A                            ; Water surface object
0001939A                            ; =========================================================================================================================================================
0001939A                            		rsset	oLvlSSTs
0001939A =00000030                  oSurfPause	rs.b	1			; Animation stop flag
0001939A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001939A                            ObjWaterSurface:
0001939A 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,oAddr(a0)	; Next routine
000193A0 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,oMap(a0)	; Mappings
000193A8 317C 8690 000E             		move.w	#$8690,oVRAM(a0)		; Tile properties
000193AE 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
000193B4                            	displaySprite	0,a0,a1,0			; Priority
000193B4 317C BE5A 0008           M 	move.w	#rdispinput+(0*dsize),odrawnext(a0)
000193BA 3278 BE64                M 	move.w	rdispinput+dprev+(0*dsize).w,a1
000193BE 3149 000A                M 	move.w	a1,odrawprev(a0)
000193C2 3348 0008                M 	move.w	a0,odrawnext(a1)
000193C6 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
000193CA                          M .no_234
000193CA 117C 0080 0017             		move.b	#$80,oDrawW(a0)			; Sprite width
000193D0 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
000193D6                            
000193D6                            ObjWaterSurface_Main:
000193D6 3238 F8F6                  		move.w	rWaterLvl.w,d1		; Get water height
000193DA 5D41                       		subq.w	#6,d1				; Shift it
000193DC 3141 0018                  		move.w	d1,oYPos(a0)			; Set Y position
000193E0                            
000193E0 4A28 0030                  		tst.b	oSurfPause(a0)			; Is the animation paused?
000193E4 6600                       		bne.s	.ChkUnpause			; If so, branch
000193E6 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000193EC 6700                       		beq.s	.Animate			; If not, branch
000193EE 5628 0010                  		addq.b	#3,oFrame(a0)			; Use different frames
000193F2 50E8 0030                  		st	oSurfPause(a0)			; Pause the animation
000193F6 6000                       		bra.s	.Animate			; Continue
000193F8                            
000193F8                            .ChkUnpause:
000193F8 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game paused?
000193FC 6600                       		bne.s	.Animate			; If so, branch
000193FE 4228 0030                  		clr.b	oSurfPause(a0)			; Resume animation
00019402 5728 0010                  		subq.b	#3,oFrame(a0)			; Use normal frames
00019406                            
00019406                            .Animate:
00019406 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
0001940A 7200                       		moveq	#0,d1
0001940C 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation script frame
00019410 1171 1000 0010             		move.b	(a1,d1.w),oFrame(a0)		; Set mapping frame
00019416 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next frame in animation script
0001941A 0228 003F 0022             		andi.b	#$3F,oAniFrame(a0)		; Loop in necessary
00019420                            	nextObject
00019420 3068 0004                M 	movea.w	onext(a0),a0
00019424 2250                     M 	move.l	oaddr(a0),a1
00019426 4ED1                     M 	jmp	(a1)
00019428                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019428                            .AniScript:
00019428 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00019438 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
00019448 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
00019458 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00019468 00                         		even
00019468                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019468                            ; Data
00019468                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019468                            Map_ObjWaterSurface:
00019468                            		include	"Level/Objects/Water Surface/Mappings.asm"
00019468                            MapConv_obj1B:
00019468 0000                       	dc.w	byte_11178-MapConv_obj1B
0001946A 0000                       	dc.w	byte_11188-MapConv_obj1B
0001946C 0000                       	dc.w	byte_11198-MapConv_obj1B
0001946E 0000                       	dc.w	byte_111A8-MapConv_obj1B
00019470 0000                       	dc.w	byte_111C7-MapConv_obj1B
00019472 0000                       	dc.w	byte_111E6-MapConv_obj1B
00019474                            
00019474 0003                       byte_11178:	dc.w 3
00019476 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
0001947C FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00019482 FD0D 0000 0020             	dc.w $FD0D, 0, $20
00019488                            
00019488 0003                       byte_11188:	dc.w 3
0001948A FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00019490 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00019496 FD0D 0008 0020             	dc.w $FD0D, 8, $20
0001949C                            
0001949C 0003                       byte_11198:	dc.w 3
0001949E FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000194A4 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000194AA FD0D 0800 0020             	dc.w $FD0D, $800, $20
000194B0                            
000194B0 0006                       byte_111A8:	dc.w 6
000194B2 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
000194B8 FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
000194BE FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
000194C4 FD0D 0000 0000             	dc.w $FD0D, 0, 0
000194CA FD0D 0000 0020             	dc.w $FD0D, 0, $20
000194D0 FD0D 0000 0040             	dc.w $FD0D, 0, $40
000194D6                            
000194D6 0006                       byte_111C7:	dc.w 6
000194D8 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000194DE FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
000194E4 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000194EA FD0D 0008 0000             	dc.w $FD0D, 8, 0
000194F0 FD0D 0008 0020             	dc.w $FD0D, 8, $20
000194F6 FD0D 0008 0040             	dc.w $FD0D, 8, $40
000194FC                            
000194FC 0006                       byte_111E6:	dc.w 6
000194FE FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00019504 FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
0001950A FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00019510 FD0D 0800 0000             	dc.w $FD0D, $800, 0
00019516 FD0D 0800 0020             	dc.w $FD0D, $800, $20
0001951C FD0D 0800 0040             	dc.w $FD0D, $800, $40
00019522                            
00019522                            	even
00019522                            		even
00019522                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019522                            ArtKosM_WaterSurface:
00019522                            		incbin	"Level/Objects/Water Surface/Art.kosm.bin"
0001967C                            		even
0001967C                            ; =========================================================================================================================================================
0001967C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001967C                            		include	"Level/Objects/Monitor/Code.asm"	; Monitor object
0001967C                            ; =========================================================================================================================================================
0001967C                            ; Mighty The Armadillo in PRISM PARADISE
0001967C                            ; By Nat The Porcupine 2021
0001967C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001967C                            ; Monitor object
0001967C                            ; =========================================================================================================================================================
0001967C                            		rsset	oLvlSSTs
0001967C =00000030                  oMonFall	rs.b	1				; Fall flag
0001967C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001967C                            ObjMonitor:
0001967C 20BC 0000 0000             		move.l	#ObjMonitorMain,oAddr(a0)
00019682 117C 000E 002D             		move.b	#$E,oColH(a0)
00019688 117C 000E 002C             		move.b	#$E,oColW(a0)
0001968E 217C 0000 0000 0010        		move.l	#Map_ObjMonitor,oMap(a0)
00019696 317C 0588 000E             		move.w	#$588,oVRAM(a0)
0001969C 117C 0004 000D             		move.b	#4,oRender(a0)
000196A2                            	displaySprite	3,a0,a1,0			; Priority
000196A2 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
000196A8 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
000196AC 3149 000A                M 	move.w	a1,odrawprev(a0)
000196B0 3348 0008                M 	move.w	a0,odrawnext(a1)
000196B4 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
000196B8                          M .no_236
000196B8 117C 000F 0017             		move.b	#$F,oDrawW(a0)
000196BE 117C 000F 001B             		move.b	#$F,oDrawH(a0)
000196C4 3028 0026                  		move.w	oRespawn(a0),d0
000196C8 6700                       		beq.s	ObjMonitorNotBroken
000196CA 3440                       		movea.w	d0,a2
000196CC 0812 0000                  		btst	#0,(a2)				; has monitor been broken?
000196D0 6700                       		beq.s	ObjMonitorNotBroken		; if not, branch
000196D2 117C 0007 0010             		move.b	#7,oFrame(a0)		; use broken monitor frame
000196D8 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
000196DE                            	nextObject
000196DE 3068 0004                M 	movea.w	onext(a0),a0
000196E2 2250                     M 	move.l	oaddr(a0),a1
000196E4 4ED1                     M 	jmp	(a1)
000196E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000196E6                            ObjMonitorNotBroken:
000196E6 117C 0006 002A             		move.b	#6,oColType(a0)
000196EC 1168 0024 0020             		move.b	oSubtype(a0),oAni(a0)
000196F2                            
000196F2                            ObjMonitorMain:
000196F2 6100                       		bsr.s	ObjMonitorFall
000196F4 323C 0019                  		move.w	#$19,d1
000196F8 343C 0010                  		move.w	#$10,d2
000196FC 3602                       		move.w	d2,d3
000196FE 3828 0014                  		move.w	oXPos(a0),d4
00019702 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019706 6100                       		bsr.s	SolidObject_Monitor
00019708                            
00019708 3038 F8C2                  		move.w	rMaxCamY.w,d0
0001970C 0640 00E0                  		addi.w	#$E0,d0
00019710 B068 0018                  		cmp.w	oYPos(a0),d0
00019714 6D00                       		blt.s	ObjMonitorDelete
00019716                            
00019716 4EB8 49C8                  		jsr	AddToColResponse
0001971A 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
0001971E 4EB8 1BE6                  		jsr	AnimateObject.w
00019722 4EB8 1FA4                  		jsr	CheckObjActive.w
00019726                            	nextObject
00019726 3068 0004                M 	movea.w	onext(a0),a0
0001972A 2250                     M 	move.l	oaddr(a0),a1
0001972C 4ED1                     M 	jmp	(a1)
0001972E                            
0001972E                            ObjMonitorDelete:
0001972E 4EB8 19F2                  		jsr	DeleteObject.w
00019732                            	nextObject
00019732 3068 0004                M 	movea.w	onext(a0),a0
00019736 2250                     M 	move.l	oaddr(a0),a1
00019738 4ED1                     M 	jmp	(a1)
0001973A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001973A                            ObjMonitorAnimate:
0001973A 0C28 0007 0010             		cmpi.b	#7,oFrame(a0)
00019740 6500                       		bcs.s	.NotBroken
00019742 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
00019748                            
00019748                            .NotBroken:
00019748 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
0001974C 4EB8 1BE6                  		jsr	AnimateObject.w
00019750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019750                            ObjMonitorCheckActive:
00019750 4EB8 1FA4                  		jsr	CheckObjActive.w
00019754                            	nextObject
00019754 3068 0004                M 	movea.w	onext(a0),a0
00019758 2250                     M 	move.l	oaddr(a0),a1
0001975A 4ED1                     M 	jmp	(a1)
0001975C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001975C                            ObjMonitorFall:
0001975C 1028 0030                  		move.b	oMonFall(a0),d0
00019760 6700                       		beq.s	.End
00019762 4EB8 1CE6                  		jsr	ObjectMoveAndFall.w
00019766 4A68 001E                  		tst.w	oYVel(a0)
0001976A 6B00                       		bmi.s	.End
0001976C 4EB8 2FAE                  		jsr	ObjCheckFloorDist
00019770 4A41                       		tst.w	d1
00019772 6700                       		beq.s	.InGround
00019774 6A00                       		bpl.s	.End
00019776                            
00019776                            .InGround:
00019776 D368 0018                  		add.w	d1,oYPos(a0)
0001977A 4268 001E                  		clr.w	oYVel(a0)
0001977E 4228 0030                  		clr.b	oMonFall(a0)
00019782                            
00019782                            .End:
00019782 4E75                       		rts
00019784                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019784                            SolidObject_Monitor:
00019784 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
0001978A 6600                       		bne.s	ObjMonitorChkOverEdge
0001978C 0C29 0002 0020             		cmpi.b	#2,oAni(a1)
00019792 6700                       		beq.s	.End
00019794 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)		; check if in drowning animation
0001979A 6600                       		bne.s	.SetSolid
0001979C                            
0001979C                            .End:
0001979C 4E75                       		rts
0001979E                            
0001979E                            .SetSolid:
0001979E 4EF8 44FA                  		jmp	SolidObject_ChkCollision
000197A2                            
000197A2                            ObjMonitorChkOverEdge:
000197A2 3401                       		move.w	d1,d2
000197A4 D442                       		add.w	d2,d2
000197A6 0829 0001 0028             		btst	#1,oStatus(a1)
000197AC 6600                       		bne.s	.NotOnMonitor
000197AE 3029 0014                  		move.w	oXPos(a1),d0
000197B2 9068 0014                  		sub.w	oXPos(a0),d0
000197B6 D041                       		add.w	d1,d0
000197B8 6B00                       		bmi.s	.NotOnMonitor
000197BA B042                       		cmp.w	d2,d0
000197BC 6500                       		blo.s	ObjMonitorCharStandOn
000197BE                            
000197BE                            .NotOnMonitor:
000197BE 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)
000197C4 08E9 0001 0028             		bset	#1,oStatus(a1)
000197CA 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)
000197D0 7800                       		moveq	#0,d4
000197D2 4E75                       		rts
000197D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197D4                            ObjMonitorCharStandOn:
000197D4 3404                       		move.w	d4,d2
000197D6 4EB8 4824                  		jsr	PlayerMoveOnPtfm
000197DA 7800                       		moveq	#0,d4
000197DC 4E75                       		rts
000197DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197DE                            ObjMonitorBreakOpen:
000197DE                            		playSnd	#sBreakItem, 2			; Play destroy sound
000197DE 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
000197E4                            		
000197E4 1028 0028                  		move.b	oStatus(a0),d0
000197E8 0200 0028                  		andi.b	#cStand|cPush,d0
000197EC 6700                       		beq.s	ObjMonitorSpawnIcon
000197EE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000197F2 0229 00D7 0028             		andi.b	#$D7,oStatus(a1)
000197F8 0029 0002 0028             		ori.b	#2,oStatus(a1)
000197FE                            
000197FE                            ObjMonitorSpawnIcon:
000197FE 4228 0028                  		clr.b	oStatus(a0)
00019802 117C 0000 002A             		move.b	#0,oColType(a0)
00019808 4EB8 1998                  		jsr	FindFreeObj.w
0001980C 6700                       		beq.s	.SkipIconCreation
0001980E 22BC 0000 0000             		move.l	#ObjMonitorContents,oAddr(a1)		; load monitor contents	object
00019814 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0001981A 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00019820 1368 0020 0020             		move.b	oAni(a0),oAni(a1)
00019826 1368 000D 000D             		move.b	oRender(a0),oRender(a1)
0001982C 1368 0028 0028             		move.b	oStatus(a0),oStatus(a1)
00019832                            
00019832                            .SkipIconCreation:
00019832 4EB8 1998                  		jsr	FindFreeObj.w
00019836 6700                       		beq.s	.SkipExplosionCreation
00019838 22BC 0001 8E42             		move.l	#ObjExplosion,oAddr(a1)			; load explosion object
0001983E 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00019844 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0001984A                            
0001984A                            .SkipExplosionCreation:
0001984A 3028 0026                  		move.w	oRespawn(a0),d0
0001984E 6700                       		beq.s	.NotRemembered
00019850 3440                       		movea.w	d0,a2
00019852 08D2 0000                  		bset	#0,(a2)
00019856                            
00019856                            .NotRemembered:
00019856 117C 0006 0020             		move.b	#6,oAni(a0)
0001985C 20BC 0001 973A             		move.l	#ObjMonitorAnimate,oAddr(a0)
00019862                            	nextObject
00019862 3068 0004                M 	movea.w	onext(a0),a0
00019866 2250                     M 	move.l	oaddr(a0),a1
00019868 4ED1                     M 	jmp	(a1)
0001986A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001986A                            ; Contents of monitor object
0001986A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001986A                            ObjMonitorContents:
0001986A 7000                       		moveq	#0,d0
0001986C 1028 0025                  		move.b	oRoutine(a0),d0
00019870 4EBB 0000                  		jsr	ObjMonitorContents_Index(pc,d0.w)
00019874                            	nextObject
00019874 3068 0004                M 	movea.w	onext(a0),a0
00019878 2250                     M 	move.l	oaddr(a0),a1
0001987A 4ED1                     M 	jmp	(a1)
0001987C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001987C                            ObjMonitorContents_Index:
0001987C 6000                       		bra.s	ObjMonitorContents_Main
0001987E 6000                       		bra.s	ObjMonitorContents_Move
00019880 6000 0000                  		bra.w	ObjMonitorContents_Delete
00019884                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019884                            ObjMonitorContents_Main:
00019884 5428 0025                  		addq.b	#2,oRoutine(a0)
00019888 317C 8588 000E             		move.w	#$8588,oVRAM(a0)
0001988E 117C 0024 000D             		move.b	#$24,oRender(a0)
00019894                            	displaySprite	3,a0,a1,0			; Priority
00019894 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0001989A 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
0001989E 3149 000A                M 	move.w	a1,odrawprev(a0)
000198A2 3348 0008                M 	move.w	a0,odrawnext(a1)
000198A6 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
000198AA                          M .no_244
000198AA 117C 0008 0017             		move.b	#8,oDrawW(a0)
000198B0 117C 0008 001B             		move.b	#8,oDrawH(a0)
000198B6 317C FD00 001E             		move.w	#-$300,oYVel(a0)
000198BC 7000                       		moveq	#0,d0
000198BE 1028 0020                  		move.b	oAni(a0),d0
000198C2 5200                       		addq.b	#1,d0
000198C4 227C 0000 0000             		movea.l	#Map_ObjMonitor,a1
000198CA D000                       		add.b	d0,d0
000198CC D2F1 0000                  		adda.w	(a1,d0.w),a1
000198D0 5449                       		addq.w	#2,a1
000198D2 2149 0010                  		move.l	a1,oMap(a0)
000198D6                            
000198D6 1028 0020                  		move.b	oAni(a0),d0
000198DA 5200                       		addq.b	#1,d0
000198DC 1140 0010                  		move.b	d0,oFrame(a0)
000198E0                            
000198E0                            ObjMonitorContents_Move:
000198E0 4A68 001E                  		tst.w	oYVel(a0)			; is object moving?
000198E4 6A00 0000                  		bpl.w	ObjMonitorContents_GetType	; if not, branch
000198E8 4EB8 1CCC                  		jsr	ObjectMove.w
000198EC 0668 0018 001E             		addi.w	#$18,oYVel(a0)			; reduce object	speed
000198F2 4E75                       		rts
000198F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000198F4                            ObjMonitorContents_GetType:
000198F4 5428 0025                  		addq.b	#2,oRoutine(a0)
000198F8 117C 001D 0023             		move.b	#29,oAniTimer(a0)
000198FE 1028 0020                  		move.b	oAni(a0),d0
00019902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019902 0C00 0001                  		cmpi.b	#1,d0
00019906 6600                       		bne.s	.ChkRings
00019908                            		push.l	a0
00019908 2F08                     M 	move.l	a0,-(sp)
0001990A 2448                       		movea.l	a0,a2
0001990C 3078 F86C                  		movea.w	rPlayer1Addr.w,a0
00019910 4EB9 0000 BDEA             		jsr	ObjMighty_GetHurt
00019916                            		pop.l	a0
00019916 205F                     M 	move.l	(sp)+,a0
00019918 4E75                       		rts
0001991A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001991A                            .ChkRings:
0001991A 0C00 0002                  		cmpi.b	#2,d0
0001991E 6600                       		bne.s	.Display
00019920 0678 000A F3D4             		addi.w	#10,rRings.w 				; add 10 rings to the number of rings you have
00019926 0038 0001 F8F3             		ori.b	#1,rUpdateRings.w 			; update the ring counter
0001992C                            		playSnd	#sRing, 2				; Play ring sound
0001992C 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00019932                            
00019932                            .Display:
00019932 4E75                       		rts
00019934                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019934                            ObjMonitorContents_Delete:
00019934 5328 0023                  		subq.b	#1,oAniTimer(a0)
00019938 6A00                       		bpl.s	.NoDelete
0001993A 4EF8 19F2                  		jmp	DeleteObject.w
0001993E                            
0001993E                            .NoDelete:
0001993E 4E75                       		rts
00019940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019940                            ; Data
00019940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019940                            ArtKosM_Monitor:
00019940                            		incbin	"Level/Objects/Monitor/Art.kosm.bin"
00019C62 00                         		even
00019C62                            Map_ObjMonitor:
00019C62                            		include	"Level/Objects/Monitor/Mappings.asm"
00019C62                            ; --------------------------------------------------------------------------------
00019C62                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019C62                            ; --------------------------------------------------------------------------------
00019C62                            
00019C62                            SME_7TKK1:	
00019C62 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00019C66 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00019C6A 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
00019C6E 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00019C72 0001                       SME_7TKK1_10:	dc.b 0, 1	
00019C74 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019C7A 0002                       SME_7TKK1_18:	dc.b 0, 2	
00019C7C F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00019C82 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019C88 0002                       SME_7TKK1_26:	dc.b 0, 2	
00019C8A F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00019C90 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019C96 0002                       SME_7TKK1_34:	dc.b 0, 2	
00019C98 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
00019C9E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CA4 0002                       SME_7TKK1_42:	dc.b 0, 2	
00019CA6 F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
00019CAC EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CB2 0002                       SME_7TKK1_50:	dc.b 0, 2	
00019CB4 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
00019CBA EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CC0 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00019CC2 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00019CC8 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019CCE 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00019CD0 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
00019CD6                            		even
00019CD6                            Ani_ObjMonitor:
00019CD6                            		include	"Level/Objects/Monitor/Animations.asm"
00019CD6                            ; ---------------------------------------------------------------------------
00019CD6                            ; Animation script - monitors
00019CD6                            ; ---------------------------------------------------------------------------
00019CD6 0000                       		dc.w .Static-Ani_ObjMonitor
00019CD8 0000                       		dc.w .Eggman-Ani_ObjMonitor
00019CDA 0000                       		dc.w .Rings-Ani_ObjMonitor
00019CDC 0000                       		dc.w .Shoes-Ani_ObjMonitor
00019CDE 0000                       		dc.w .Shield-Ani_ObjMonitor
00019CE0 0000                       		dc.w .Stars-Ani_ObjMonitor
00019CE2 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00019CE4 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00019CE9 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00019CF2 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00019CFB 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
00019D04 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00019D0D 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
00019D16 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00019D1E 00                         		even
00019D1E                            ; =========================================================================================================================================================
00019D1E                            		include	"Level/Objects/Spikes/Code.asm"		; Spike object
00019D1E                            ; ===========================================================================
00019D1E                            ; Mighty The Armadillo in PRISM PARADISE
00019D1E                            ; By Nat The Porcupine 2021
00019D1E                            ; ---------------------------------------------------------------------------
00019D1E                            ; Spike object
00019D1E                            ; ===========================================================================
00019D1E                            		rsset	oLvlSSTs
00019D1E =00000030                  oSpikeX		rs.w	1
00019D1E =00000032                  oSpikeY		rs.w	1
00019D1E =00000034                  oSpkMvOff	rs.w	1
00019D1E =00000036                  oSpkMvState	rs.w	1
00019D1E =00000038                  oSpkMvTime	rs.w	1
00019D1E                            ; ===========================================================================
00019D1E                            ObjSpike:
00019D1E 7000                       		moveq	#0,d0
00019D20 1028 0025                  		move.b	oRoutine(a0),d0
00019D24 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00019D28                            	nextObject
00019D28 3068 0004                M 	movea.w	onext(a0),a0
00019D2C 2250                     M 	move.l	oaddr(a0),a1
00019D2E 4ED1                     M 	jmp	(a1)
00019D30                            ; ===========================================================================
00019D30                            ObjSpike_Index:
00019D30 6000 0000                  		bra.w ObjSpike_Init
00019D34 6000 0000                  		bra.w ObjSpike_Upright
00019D38 6000 0000                  		bra.w ObjSpike_Sideways
00019D3C 6000 0000                  		bra.w ObjSpike_UpsideDown
00019D40                            ; ===========================================================================
00019D40                            ;ObjSpike_InitData:
00019D40                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00019D40                            ;		dc.b $10,$10	; 2	- Sideways spikes
00019D40                            ; ===========================================================================
00019D40                            ObjSpike_Init:
00019D40 5828 0025                  		addq.b	#4,oRoutine(a0)
00019D44 217C 0000 0000 0010        		move.l	#Map_ObjSpike,oMap(a0)
00019D4C 317C 06A8 000E             		move.w	#$6A8,oVRAM(a0)
00019D52 0028 0004 000D             		ori.b	#4,oRender(a0)
00019D58                            	displaySprite	4,a0,a1,0			; Priority
00019D58 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
00019D5E 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
00019D62 3149 000A                M 	move.w	a1,odrawprev(a0)
00019D66 3348 0008                M 	move.w	a0,odrawnext(a1)
00019D6A 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00019D6E                          M .no_249
00019D6E 1028 0024                  		move.b	oSubtype(a0),d0
00019D72 0228 000F 0024             		andi.b	#$F,oSubtype(a0)
00019D78 0240 00F0                  		andi.w	#$F0,d0
00019D7C 7210                       		moveq	#$10,d1
00019D7E 1141 0017                  		move.b	d1,oDrawW(a0)
00019D82 1141 002C                  		move.b	d1,oColW(a0)
00019D86 1141 001B                  		move.b	d1,oDrawH(a0)
00019D8A 1141 002D                  		move.b	d1,oColH(a0)
00019D8E E848                       		lsr.w	#4,d0
00019D90 1140 0010                  		move.b	d0,oFrame(a0)
00019D94 0C00 0001                  		cmpi.b	#1,d0
00019D98 6600                       		bne.s	.ChkUpsideDown
00019D9A 5828 0025                  		addq.b	#4,oRoutine(a0)
00019D9E 317C 06AC 000E             		move.w	#$6AC,oVRAM(a0)
00019DA4                            
00019DA4                            .ChkUpsideDown:
00019DA4 0828 0001 0028             		btst	#1,oStatus(a0)
00019DAA 6700                       		beq.s	.SavePos
00019DAC 117C 000C 0025             		move.b	#$C,oRoutine(a0)
00019DB2                            
00019DB2                            .SavePos:
00019DB2 3168 0014 0030             		move.w	oXPos(a0),oSpikeX(a0)
00019DB8 3168 0018 0032             		move.w	oYPos(a0),oSpikeY(a0)
00019DBE                            
00019DBE 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00019DC2 0C28 0001 0010             		cmpi.b	#1,oFrame(a0)		; is object type $1x ?
00019DC8 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00019DCA                            ; ===========================================================================
00019DCA                            ; Upright spikes
00019DCA                            ; ===========================================================================
00019DCA                            ObjSpike_Upright:
00019DCA 6100 0000                  		bsr.w	MoveSpikes
00019DCE 7200                       		moveq	#0,d1
00019DD0 1228 0017                  		move.b	oDrawW(a0),d1
00019DD4 0641 000B                  		addi.w	#$B,d1
00019DD8 7400                       		moveq	#0,d2
00019DDA 1428 001B                  		move.b	oDrawH(a0),d2
00019DDE 3602                       		move.w	d2,d3
00019DE0 5243                       		addq.w	#1,d3
00019DE2 3828 0014                  		move.w	oXPos(a0),d4
00019DE6 4EB8 43A8                  		jsr	SolidObject
00019DEA 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
00019DF0 6700                       		beq.s	ObjSpike_UprightEnd
00019DF2 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019DF6 6100 0000                  		bsr.w	Touch_ChkHurt2
00019DFA                            
00019DFA                            ObjSpike_UprightEnd:
00019DFA 3028 0030                  		move.w	oSpikeX(a0),d0
00019DFE 4EF8 1FA4                  		jmp	CheckObjActive.w
00019E02                            ; ===========================================================================
00019E02                            ; Sideways spikes
00019E02                            ; ===========================================================================
00019E02                            ObjSpike_Sideways:
00019E02 3F28 0014                  		move.w	oXPos(a0),-(sp)	
00019E06 6100 0000                  		bsr.w	MoveSpikes
00019E0A 7200                       		moveq	#0,d1
00019E0C 1228 0017                  		move.b	oDrawW(a0),d1
00019E10 0641 000B                  		addi.w	#$B,d1
00019E14 7400                       		moveq	#0,d2
00019E16 1428 001B                  		move.b	oDrawH(a0),d2
00019E1A 3602                       		move.w	d2,d3
00019E1C 5243                       		addq.w	#1,d3
00019E1E 381F                       		move.w	(sp)+,d4
00019E20 4EB8 43A8                  		jsr	SolidObject
00019E24 0806 0000                  		btst	#cTouchSideBit,d6
00019E28 6700                       		beq.s	ObjSpike_SidewaysEnd
00019E2A 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019E2E 6100 0000                  		bsr.w	Touch_ChkHurt2
00019E32                            
00019E32                            ObjSpike_SidewaysEnd:
00019E32 3028 0030                  		move.w	oSpikeX(a0),d0
00019E36 4EF8 1FA4                  		jmp	CheckObjActive.w
00019E3A                            ; ===========================================================================
00019E3A                            ; Upside down spikes
00019E3A                            ; ===========================================================================
00019E3A                            ObjSpike_UpsideDown:
00019E3A 6100 0000                  		bsr.w	MoveSpikes
00019E3E 7200                       		moveq	#0,d1
00019E40 1228 0017                  		move.b	oDrawW(a0),d1
00019E44 0641 000B                  		addi.w	#$B,d1
00019E48 7400                       		moveq	#0,d2
00019E4A 1428 001B                  		move.b	oDrawH(a0),d2
00019E4E 3602                       		move.w	d2,d3
00019E50 5243                       		addq.w	#1,d3
00019E52 3828 0014                  		move.w	oXPos(a0),d4
00019E56 4EB8 43A8                  		jsr	SolidObject
00019E5A 0806 0002                  		btst	#cTouchBtmBit,d6
00019E5E 6700                       		beq.s	ObjSpike_UpsideDownEnd
00019E60 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019E64 6100 0000                  		bsr.w	Touch_ChkHurt2
00019E68                            
00019E68                            ObjSpike_UpsideDownEnd:
00019E68 3028 0030                  		move.w	oSpikeX(a0),d0
00019E6C 4EF8 1FA4                  		jmp	CheckObjActive.w
00019E70                            ; ===========================================================================
00019E70                            Touch_ChkHurt2:
00019E70 4A29 0042                  		tst.b	oInvulTime(a1)			; is Sonic invincible?
00019E74 6600                       		bne.s	.End				; if yes, branch
00019E76 0C29 0008 0025             		cmpi.b	#8,oRoutine(a1)
00019E7C 6700                       		beq.s	.End
00019E7E 2629 0018                  		move.l	oYPos(a1),d3
00019E82 3029 001E                  		move.w	oYVel(a1),d0
00019E86 48C0                       		ext.l	d0
00019E88 E180                       		asl.l	#8,d0
00019E8A 9680                       		sub.l	d0,d3
00019E8C 2343 0018                  		move.l	d3,oYPos(a1)
00019E90 2448                       		movea.l	a0,a2
00019E92 2049                       		movea.l	a1,a0
00019E94 4EB9 0000 BDEA             		jsr	ObjMighty_GetHurt
00019E9A 204A                       		movea.l	a2,a0
00019E9C                            
00019E9C                            .End:
00019E9C 4E75                       		rts
00019E9E                            ; ===========================================================================
00019E9E                            MoveSpikes:	
00019E9E 7000                       		moveq	#0,d0
00019EA0 1028 0024                  		move.b	oSubtype(a0),d0
00019EA4 D040                       		add.w	d0,d0
00019EA6 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00019EAA                            ; ===========================================================================
00019EAA                            MoveSpikes_Behaviors:
00019EAA 6000                       		bra.s MoveSpikes_Still
00019EAC 6000                       		bra.s MoveSpikes_Vertical
00019EAE 6000                       		bra.s MoveSpikes_Horizontal
00019EB0                            ; ===========================================================================
00019EB0                            MoveSpikes_Still:
00019EB0 4E75                       		rts			; don't move the object
00019EB2                            ; ===========================================================================
00019EB2                            MoveSpikes_Vertical:
00019EB2 6100 0000                  		bsr.w	MoveSpikes_Delay
00019EB6 7000                       		moveq	#0,d0
00019EB8 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019EBC D068 0032                  		add.w	oSpikeY(a0),d0
00019EC0 3140 0018                  		move.w	d0,oYPos(a0)	; move the object vertically
00019EC4 4E75                       		rts
00019EC6                            ; ===========================================================================
00019EC6                            MoveSpikes_Horizontal:
00019EC6 6100 0000                  		bsr.w	MoveSpikes_Delay
00019ECA 7000                       		moveq	#0,d0
00019ECC 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019ED0 D068 0030                  		add.w	oSpikeX(a0),d0
00019ED4 3140 0014                  		move.w	d0,oXPos(a0)	; move the object horizontally
00019ED8 4E75                       		rts
00019EDA                            ; ===========================================================================
00019EDA                            MoveSpikes_Delay:
00019EDA 4A68 0038                  		tst.w	oSpkMvTime(a0)		; is time delay	= zero?
00019EDE 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00019EE0 5368 0038                  		subq.w	#1,oSpkMvTime(a0)	; subtract 1 from time delay
00019EE4 6600                       		bne.s	locret_CFE6
00019EE6 4A28 000D                  		tst.b	oRender(a0)
00019EEA 6A00                       		bpl.s	locret_CFE6
00019EEC                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00019EEC 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00019EF2 6000                       		bra.s	locret_CFE6
00019EF4                            ; ===========================================================================
00019EF4                            MoveSpikes_ChkDir:
00019EF4 4A68 0036                  		tst.w	oSpkMvState(a0)
00019EF8 6700                       		beq.s	MoveSpikes_Retract
00019EFA 0468 0800 0034             		subi.w	#$800,oSpkMvOff(a0)
00019F00 6400                       		bcc.s	locret_CFE6
00019F02 317C 0000 0034             		move.w	#0,oSpkMvOff(a0)
00019F08 317C 0000 0036             		move.w	#0,oSpkMvState(a0)
00019F0E 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019F14 6000                       		bra.s	locret_CFE6
00019F16                            ; ===========================================================================
00019F16                            MoveSpikes_Retract:
00019F16 0668 0800 0034             		addi.w	#$800,oSpkMvOff(a0)
00019F1C 0C68 2000 0034             		cmpi.w	#$2000,oSpkMvOff(a0)
00019F22 6500                       		bcs.s	locret_CFE6
00019F24 317C 2000 0034             		move.w	#$2000,oSpkMvOff(a0)
00019F2A 317C 0001 0036             		move.w	#1,oSpkMvState(a0)
00019F30 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019F36                            
00019F36                            locret_CFE6:
00019F36 4E75                       		rts
00019F38                            ; ===========================================================================
00019F38                            ; Spike object mappings
00019F38                            ; ===========================================================================
00019F38                            Map_ObjSpike:
00019F38                            	include "Level/Objects/Spikes/Mappings.asm"
00019F38                            ; --------------------------------------------------------------------------------
00019F38                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019F38                            ; --------------------------------------------------------------------------------
00019F38                            
00019F38                            SME_5AG23:	
00019F38 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00019F3C 0004                       SME_5AG23_4:	dc.b 0, 4	
00019F3E F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
00019F44 F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00019F4A F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
00019F50 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
00019F56 0004                       SME_5AG23_1E:	dc.b 0, 4	
00019F58 F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
00019F5E F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00019F64 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
00019F6A 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
00019F70                            		even
00019F70                            ; ===========================================================================
00019F70                            ArtKosM_SpikesN:
00019F70                            		incbin	"Level/Objects/Spikes/Art - Normal.kosm.bin"
00019FB0                            		even
00019FB0                            ; ===========================================================================
00019FB0                            ArtKosM_SpikesS:
00019FB0                            		incbin	"Level/Objects/Spikes/Art - Sideways.kosm.bin"
00019FF2 00                         		even
00019FF2                            ; ===========================================================================
00019FF2                            		include	"Level/Objects/Spring/Code.asm"		; Spring object
00019FF2                            ; =========================================================================================================================================================
00019FF2                            ; Mighty The Armadillo in PRISM PARADISE
00019FF2                            ; By Nat The Porcupine 2021
00019FF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019FF2                            ; Spring object
00019FF2                            ; =========================================================================================================================================================
00019FF2                            		rsset	oLvlSSTs
00019FF2 =00000030                  oSprSpd		rs.w	1				; Spring strength
00019FF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019FF2                            ObjSpring:
00019FF2 217C 0000 0000 0010        		move.l	#Map_ObjSpring,oMap(a0)		; Mappings
00019FFA 317C 05BA 000E             		move.w	#$5BA,oVRAM(a0)			; Tile properties
0001A000 0028 0004 000D             		ori.b	#4,oRender(a0)			; Render flags
0001A006 117C 0010 0017             		move.b	#$10,oDrawW(a0)			; Sprite width
0001A00C 117C 0008 001B             		move.b	#8,oDrawH(a0)			; Sprite height
0001A012 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A018                            	displaySprite	4,a0,a1,0			; Priority
0001A018 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
0001A01E 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
0001A022 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A026 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A02A 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0001A02E                          M .no_251
0001A02E                            		
0001A02E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A032 E648                       		lsr.w	#3,d0				; Turn into offset
0001A034 0240 000E                  		andi.w	#$E,d0				; ''
0001A038 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
0001A03C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A03C                            .Subtypes:
0001A03C 6000                       		bra.s .Init_Up				; Up
0001A03E 6000                       		bra.s .Init_Horizontal			; Horizontal
0001A040 6000                       		bra.s .Init_Down			; Down
0001A042 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
0001A044 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
0001A046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A046                            .Init_Horizontal:
0001A046 117C 0002 0020             		move.b	#2,oAni(a0)			; Animation
0001A04C 117C 0002 0010             		move.b	#2,oFrame(a0)			; Mapping frame
0001A052 317C 05CA 000E             		move.w	#$5CA,oVRAM(a0)			; Tile properties
0001A058 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A05E 117C 0010 001B             		move.b	#$10,oDrawH(a0)			; Sprite height
0001A064 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A06A 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,oAddr(a0)	; Next routine
0001A070 6000                       		bra.s	.Init_Common			; Continue
0001A072                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A072                            .Init_Down:
0001A072 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A078 20BC 0000 0000             		move.l	#ObjSpring_Down,oAddr(a0)	; Next routine
0001A07E 6000                       		bra.s	.Init_Common			; Continue
0001A080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A080                            .Init_DiagonallyUp:
0001A080 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A086 117C 0004 0010             		move.b	#4,oFrame(a0)			; Map frame
0001A08C 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A092 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,oAddr(a0); Next routine
0001A098 6000                       		bra.s	.Init_Common			; Continue
0001A09A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A09A                            .Init_DiagonallyDown:
0001A09A 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A0A0 117C 0006 0010             		move.b	#6,oFrame(a0)			; Map frame
0001A0A6 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A0AC 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A0B2 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,oAddr(a0); Next routine
0001A0B8 6000                       		bra.s	.Init_Common			; Continue
0001A0BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0BA                            .Init_Up:
0001A0BA 20BC 0000 0000             		move.l	#ObjSpring_Up,oAddr(a0)		; Next routine
0001A0C0                            
0001A0C0                            .Init_Common:
0001A0C0 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A0C4 0240 0002                  		andi.w	#2,d0				; Turn into offset
0001A0C8 317B 0000 0030             		move.w	.Strengths(pc,d0.w),oSprSpd(a0)	; Get spring strength
0001A0CE 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
0001A0D2 6700                       		beq.s	.NotYellow			; If not, branch
0001A0D4 08E8 0005 000E             		bset	#5,oVRAM(a0)			; Make the spring yellow
0001A0DA                            
0001A0DA                            .NotYellow:
0001A0DA                            	nextObject
0001A0DA 3068 0004                M 	movea.w	onext(a0),a0
0001A0DE 2250                     M 	move.l	oaddr(a0),a1
0001A0E0 4ED1                     M 	jmp	(a1)
0001A0E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0E2                            .Strengths:
0001A0E2 F000                       		dc.w	-$1000				; Strength of red spring
0001A0E4 F600                       		dc.w	-$A00				; Strength of yellow spring
0001A0E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0E6                            ObjSpring_Up:
0001A0E6 323C 001A                  		move.w	#27-1,d1			; Width
0001A0EA 343C 0008                  		move.w	#16/2,d2			; Height
0001A0EE 3602                       		move.w	d2,d3				; ''
0001A0F0 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A0F4 4EB8 43F8                  		jsr	SolidObject_Always		; Set object as solid
0001A0F8 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the top of the of spring?
0001A0FE 6700                       		beq.s	.Display			; If not, branch
0001A100 6100                       		bsr.s	.Bounce				; Bounce the player up
0001A102                            
0001A102                            .Display:
0001A102 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A106 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001A10A 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display sprite
0001A10E                            	nextObject
0001A10E 3068 0004                M 	movea.w	onext(a0),a0
0001A112 2250                     M 	move.l	oaddr(a0),a1
0001A114 4ED1                     M 	jmp	(a1)
0001A116                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A116                            .Bounce:
0001A116 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A11C 5069 0018                  		addq.w	#8,oYPos(a1)			; Align player to spring
0001A120 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A126 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A12C 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A132 4229 0040                  		clr.b	oJumping(a1)			; Clear the player's jump flag
0001A136 137C 0010 0020             		move.b	#$10,oAni(a1)			; Set the player's animation to the spring animation
0001A13C 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A142                            		
0001A142 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A146 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A148 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A14C                            
0001A14C                            .ChkPath1:
0001A14C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A150 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A154 6600                       		bne.s	.ChkPath2			; If not, branch
0001A156 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A15C 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A162                            
0001A162                            .ChkPath2:
0001A162 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A166 6600                       		bne.s	.PlaySound			; If not, branch
0001A168 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A16E 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A174                            
0001A174                            .PlaySound:
0001A174                            		playSnd	#sSpring, 2			; Play spring sound
0001A174 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A17A 4E75                       		rts
0001A17C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A17C                            ObjSpring_Horizontal:
0001A17C 323C 0013                  		move.w	#20-1,d1			; Width
0001A180 343C 000E                  		move.w	#28/2,d2			; Height
0001A184 3602                       		move.w	d2,d3				; ''
0001A186 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A18A 4EB8 43F8                  		jsr	SolidObject_Always		; Set object as solid
0001A18E 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
0001A192 6700                       		beq.s	.Display			; If not, branch
0001A194 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001A198 3028 0014                  		move.w	oXPos(a0),d0			; Get which side of the spring the player is facing
0001A19C 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001A1A0 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
0001A1A2 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
0001A1A6                            
0001A1A6                            .NoFlip:
0001A1A6 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
0001A1AA 6600                       		bne.s	.Display			; If not, branch
0001A1AC 6100                       		bsr.s	.Bounce				; Bounce the player
0001A1AE                            
0001A1AE                            .Display:
0001A1AE 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A1B2 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001A1B6 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display sprite
0001A1BA                            	nextObject
0001A1BA 3068 0004                M 	movea.w	onext(a0),a0
0001A1BE 2250                     M 	move.l	oaddr(a0),a1
0001A1C0 4ED1                     M 	jmp	(a1)
0001A1C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1C2                            .Bounce:	
0001A1C2 317C 0300 0020             		move.w	#$300,oAni(a0)			; Reset animation
0001A1C8 5069 0014                  		addq.w	#8,oXPos(a1)			; Align player to spring
0001A1CC 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)		; Set the player's X velocity
0001A1D2 08E9 0000 0028             		bset	#0,oStatus(a1)			; Make the player face the left
0001A1D8 0828 0000 0028             		btst	#0,oStatus(a0)			; Is this spring facing the left?
0001A1DE 6600                       		bne.s	.SetMoveLock			; If so, branch
0001A1E0 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Make the player face the right
0001A1E6 0469 0010 0014             		subi.w	#$10,oXPos(a1)			; Align player to spring
0001A1EC 4469 001C                  		neg.w	oXVel(a1)			; Move the player to the right
0001A1F0                            
0001A1F0                            .SetMoveLock:
0001A1F0 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Lock the player's movement for a bit
0001A1F6 3369 001C 003A             		move.w	oXVel(a1),oGVel(a1)		; Set the player's ground velocity
0001A1FC                            		
0001A1FC 0829 0002 0028             		btst	#2,oStatus(a1)			; Is the player jumping?
0001A202 6600                       		bne.s	.ChkYStop			; If so, branch
0001A204 4229 0020                  		clr.b	oAni(a1)			; Set the animation to the walking animation
0001A208                            		
0001A208                            .ChkYStop:
0001A208 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A20C 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
0001A20E 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's Y movement
0001A212                            
0001A212                            .ChkPath1:
0001A212 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A216 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A21A 6600                       		bne.s	.ChkPath2			; If not, branch
0001A21C 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A222 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A228                            
0001A228                            .ChkPath2:
0001A228 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A22C 6600                       		bne.s	.PlaySound			; If not, branch
0001A22E 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A234 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A23A                            
0001A23A                            .PlaySound:
0001A23A 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear "push" flags
0001A240 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001A246                            		playSnd	#sSpring, 2			; Play spring sound
0001A246 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A24C 4E75                       		rts
0001A24E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A24E                            ObjSpring_Down:
0001A24E 323C 0012                  		move.w	#19-1,d1			; Width
0001A252 343C 0008                  		move.w	#16/2,d2			; Height
0001A256 3602                       		move.w	d2,d3				; ''
0001A258 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A25C 4EB8 43F8                  		jsr	SolidObject_Always		; Set object as solid
0001A260 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
0001A264 6600                       		bne.s	.Display			; If not, branch
0001A266 6100                       		bsr.s	.Bounce				; Bounce the player
0001A268                            
0001A268                            .Display:
0001A268 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A26C 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001A270 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display sprite
0001A274                            	nextObject
0001A274 3068 0004                M 	movea.w	onext(a0),a0
0001A278 2250                     M 	move.l	oaddr(a0),a1
0001A27A 4ED1                     M 	jmp	(a1)
0001A27C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A27C                            .Bounce:
0001A27C 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A282 5169 0018                  		subq.w	#8,oYPos(a1)			; Align player with the spring
0001A286 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A28C 4469 001E                  		neg.w	oYVel(a1)			; Move the player down
0001A290                            		
0001A290 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A294 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A296 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A29A                            
0001A29A                            .ChkPath1:
0001A29A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A29E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A2A2 6600                       		bne.s	.ChkPath2			; If not, branch
0001A2A4 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A2AA 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A2B0                            
0001A2B0                            .ChkPath2:
0001A2B0 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A2B4 6600                       		bne.s	.PlaySound			; If not, branch
0001A2B6 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A2BC 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A2C2                            
0001A2C2                            .PlaySound:
0001A2C2 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A2C8 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A2CE 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A2D4                            		playSnd	#sSpring, 2			; Play spring sound
0001A2D4 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A2DA 4E75                       		rts
0001A2DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A2DC                            ObjSpring_DiagonallyUp:
0001A2DC 323C 0019                  		move.w	#26-1,d1			; Width
0001A2E0 343C 0010                  		move.w	#32/2,d2			; Height
0001A2E4 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A2E8 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
0001A2EC 4EB8 4448                  		jsr	SlopedSolid			; Set object as a solid slope
0001A2F0                            		
0001A2F0 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the spring?
0001A2F6 6700                       		beq.s	.End				; If not, branch
0001A2F8 6100                       		bsr.s	.Bounce				; Bounce the player
0001A2FA                            
0001A2FA                            .End:
0001A2FA 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A2FE 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001A302 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display sprite
0001A306                            	nextObject
0001A306 3068 0004                M 	movea.w	onext(a0),a0
0001A30A 2250                     M 	move.l	oaddr(a0),a1
0001A30C 4ED1                     M 	jmp	(a1)
0001A30E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A30E                            .Bounce:
0001A30E 0828 0000 0028             		btst	#0,oStatus(a0)			; Is the spring facing left?
0001A314 6600                       		bne.s	.FaceLeft			; If so, branch
0001A316 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0001A31A 5940                       		subq.w	#4,d0				; Subtract 4
0001A31C B069 0014                  		cmp.w	oXPos(a1),d0			; Is the player
0001A320 6500                       		blo.s	.DoBounce
0001A322 4E75                       		rts
0001A324                            
0001A324                            .FaceLeft:
0001A324 3028 0014                  		move.w	oXPos(a0),d0
0001A328 5840                       		addq.w	#4,d0
0001A32A B069 0014                  		cmp.w	oXPos(a1),d0
0001A32E 6400                       		bhs.s	.DoBounce
0001A330 4E75                       		rts
0001A332                            
0001A332                            .DoBounce:
0001A332 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A338 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A33E 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A344 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A348 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A34C 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A352 0828 0000 0028             		btst	#0,oStatus(a0)
0001A358 6600                       		bne.s	.SetAni
0001A35A 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A360 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A366 4469 001C                  		neg.w	oXVel(a1)
0001A36A                            
0001A36A                            .SetAni:
0001A36A 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A370 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A376 137C 0010 0020             		move.b	#$10,oAni(a1)
0001A37C 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A382                            
0001A382 1028 0024                  		move.b	oSubtype(a0),d0
0001A386 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A38A 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A38E 6600                       		bne.s	.ChkPath2			; If not, branch
0001A390 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A396 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A39C                            
0001A39C                            .ChkPath2:
0001A39C 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A3A0 6600                       		bne.s	.PlaySound			; If not, branch
0001A3A2 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A3A8 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A3AE                            
0001A3AE                            .PlaySound:
0001A3AE                            		playSnd	#sSpring, 2			; Play spring sound
0001A3AE 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A3B4 4E75                       		rts
0001A3B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3B6                            .SlopeData:
0001A3B6 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
0001A3BD 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
0001A3C4 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
0001A3CB FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
0001A3D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3D2                            ObjSpring_DiagonallyDown:
0001A3D2 323C 0019                  		move.w	#26-1,d1			; Width
0001A3D6 343C 0010                  		move.w	#32/2,d2
0001A3DA 3828 0014                  		move.w	oXPos(a0),d4
0001A3DE 45FA 0000                  		lea	.SlopeData(pc),a2
0001A3E2 4EB8 4448                  		jsr	SlopedSolid			; Set object as a solid slope
0001A3E6 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
0001A3EA 6600                       		bne.s	.End				; If not, branch
0001A3EC 6100                       		bsr.s	.Bounce				; Bounce the player
0001A3EE                            
0001A3EE                            .End:
0001A3EE 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A3F2 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001A3F6 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display sprite
0001A3FA                            	nextObject
0001A3FA 3068 0004                M 	movea.w	onext(a0),a0
0001A3FE 2250                     M 	move.l	oaddr(a0),a1
0001A400 4ED1                     M 	jmp	(a1)
0001A402                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A402                            .Bounce:
0001A402 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A408 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A40E 4469 001E                  		neg.w	oYVel(a1)
0001A412 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A418 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A41C 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A420 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A426 0828 0000 0028             		btst	#0,oStatus(a0)
0001A42C 6600                       		bne.s	.SetAni
0001A42E 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A434 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A43A 4469 001C                  		neg.w	oXVel(a1)
0001A43E                            
0001A43E                            .SetAni:
0001A43E 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A444 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A44A 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A450                            
0001A450 1028 0024                  		move.b	oSubtype(a0),d0
0001A454 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A458 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A45C 6600                       		bne.s	.ChkPath2			; If not, branch
0001A45E 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A464 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A46A                            
0001A46A                            .ChkPath2:
0001A46A 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A46E 6600                       		bne.s	.PlaySound			; If not, branch
0001A470 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A476 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A47C                            
0001A47C                            .PlaySound:
0001A47C                            		playSnd	#sSpring, 2			; Play spring sound
0001A47C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A482 4E75                       		rts
0001A484                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A484                            .SlopeData:
0001A484 F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
0001A48B F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
0001A492 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
0001A499 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
0001A4A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4A0                            ; Data
0001A4A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4A0                            Ani_ObjSpring:
0001A4A0                            		include	"Level/Objects/Spring/Animations.asm"
0001A4A0                            ; ---------------------------------------------------------------------------
0001A4A0                            ; Animation script - springs
0001A4A0                            ; ---------------------------------------------------------------------------
0001A4A0 0000                       		dc.w byte_18FEE-Ani_ObjSpring
0001A4A2 0000                       		dc.w byte_18FF1-Ani_ObjSpring
0001A4A4 0000                       		dc.w byte_18FFD-Ani_ObjSpring
0001A4A6 0000                       		dc.w byte_19000-Ani_ObjSpring
0001A4A8 0000                       		dc.w byte_1900C-Ani_ObjSpring
0001A4AA 0000                       		dc.w byte_1900F-Ani_ObjSpring
0001A4AC                            byte_18FEE:
0001A4AC 0F00 FF                    		dc.b  $F, 0, $FF
0001A4B0 00                         		even
0001A4B0                            byte_18FF1:
0001A4B0 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
0001A4BA 00                         		even
0001A4BA                            byte_18FFD:
0001A4BA 0F02 FF                    		dc.b $F, 2, $FF
0001A4BE 00                         		even
0001A4BE                            byte_19000:
0001A4BE 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
0001A4C8 00                         		even
0001A4C8                            byte_1900C:
0001A4C8 0F04 FF                    		dc.b $F, 4, $FF
0001A4CC 00                         		even
0001A4CC                            byte_1900F:
0001A4CC 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
0001A4D6 00                         		even
0001A4D6                            Map_ObjSpring:
0001A4D6                            		include	"Level/Objects/Spring/Mappings.asm"
0001A4D6                            ; --------------------------------------------------------------------------------
0001A4D6                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001A4D6                            ; --------------------------------------------------------------------------------
0001A4D6                            
0001A4D6                            SME_q_6K9:	
0001A4D6 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
0001A4DA 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
0001A4DE 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
0001A4E2 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
0001A4E4 0002                       SME_q_6K9_E:	dc.b 0, 2	
0001A4E6 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A4EC 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
0001A4F2 0005                       SME_q_6K9_1C:	dc.b 0, 5	
0001A4F4 E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
0001A4FA E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
0001A500 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
0001A506 F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
0001A50C 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
0001A512 0001                       SME_q_6K9_3C:	dc.b 0, 1	
0001A514 E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
0001A51A 0007                       SME_q_6K9_44:	dc.b 0, 7	
0001A51C E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
0001A522 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
0001A528 F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
0001A52E F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
0001A534 F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
0001A53A E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
0001A540 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
0001A546 0002                       SME_q_6K9_70:	dc.b 0, 2	
0001A548 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0001A54E FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
0001A554 0005                       SME_q_6K9_7E:	dc.b 0, 5	
0001A556 E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
0001A55C EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
0001A562 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
0001A568 FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
0001A56E 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
0001A574 0002                       SME_q_6K9_9E:	dc.b 0, 2	
0001A576 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
0001A57C 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
0001A582                            		even
0001A582                            ArtKosM_SpringH:
0001A582                            		incbin	"Level/Objects/Spring/Art - Horizontal.kosm.bin"
0001A65E 00                         		even
0001A65E                            ArtKosM_SpringV:
0001A65E                            		incbin	"Level/Objects/Spring/Art - Vertical.kosm.bin"
0001A744 00                         		even
0001A744                            ArtKosM_SpringD:
0001A744                            		incbin	"Level/Objects/Spring/Art - Diagonal.kosm.bin"
0001A95E 00                         		even
0001A95E                            ; =========================================================================================================================================================
0001A95E                            		include	"Level/Objects/Checkpoint/Code.asm"	; Checkpoint object
0001A95E                            ; =========================================================================================================================================================
0001A95E                            ; Mighty The Armadillo in PRISM PARADISE
0001A95E                            ; By Nat The Porcupine 2021
0001A95E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A95E                            ; Checkpoint object
0001A95E                            ; =========================================================================================================================================================
0001A95E                            		rsset	oLvlSSTs
0001A95E =00000030                  oDongleX	rs.w	1				; Ball dongle X
0001A95E =00000032                  oDongleY	rs.w	1				; Ball dongle Y
0001A95E =00000034                  oDongleTime	rs.w	1				; Ball dongle timer
0001A95E =00000036                  oDonglePar	rs.w	1				; Ball dongle parent
0001A95E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A95E                            ObjCheckpoint:
0001A95E 7000                       		moveq	#0,d0
0001A960 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0001A964 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0001A968                            	nextObject
0001A968 3068 0004                M 	movea.w	onext(a0),a0
0001A96C 2250                     M 	move.l	oaddr(a0),a1
0001A96E 4ED1                     M 	jmp	(a1)
0001A970                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A970                            .Index:
0001A970 6000 0000                  		bra.w	ObjChkpoint_Init
0001A974 6000 0000                  		bra.w	ObjChkpoint_Main
0001A978 6000 0000                  		bra.w	ObjChkpoint_Animate
0001A97C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A97C                            ObjChkpoint_Init:
0001A97C 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0001A980                            		
0001A980 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,oMap(a0)	; Mappings
0001A988 317C 057E 000E             		move.w	#$57E,oVRAM(a0)			; Tile properties
0001A98E 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001A994 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A99A 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
0001A9A0                            	displaySprite	5,a0,a1,0			; Priority
0001A9A0 317C BE82 0008           M 	move.w	#rdispinput+(5*dsize),odrawnext(a0)
0001A9A6 3278 BE8C                M 	move.w	rdispinput+dprev+(5*dsize).w,a1
0001A9AA 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A9AE 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A9B2 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
0001A9B6                          M .no_264
0001A9B6                            		
0001A9B6 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001A9BA 3440                       		movea.w	d0,a2				; ''
0001A9BC 0812 0000                  		btst	#0,(a2)				; Is it already set?
0001A9C0 6600                       		bne.s	.AlreadySet			; If so, branch
0001A9C2                            
0001A9C2 1228 0024                  		move.b	oSubtype(a0),d1			; Get checkpoint ID
0001A9C6 B238 C7AE                  		cmp.b	rLastChkpoint.w,d1		; Has a later checkpoint already been hit?
0001A9CA 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
0001A9CC                            
0001A9CC                            .AlreadySet:
0001A9CC 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001A9D0 117C 0002 0020             		move.b	#2,oAni(a0)			; ''
0001A9D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A9D6                            ObjChkpoint_Main:
0001A9D6 4A38 F8D1                  		tst.b	rDebugMode.w			; Are we in debug placement mode?
0001A9DA 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
0001A9DE                            		
0001A9DE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Player object
0001A9E2 1238 C7AE                  		move.b	rLastChkpoint.w,d1		; Get last checkpoint hit
0001A9E6 B228 0024                  		cmp.b	oSubtype(a0),d1			; Has a later checkpoint already been hit?
0001A9EA 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
0001A9EE                            
0001A9EE 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0001A9F2 9068 0014                  		sub.w	oXPos(a0),d0			; Get delta X from current position
0001A9F6 5040                       		addq.w	#8,d0				; Add 8
0001A9F8 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
0001A9FC 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AA00 3029 0018                  		move.w	oYPos(a1),d0			; Get player's Y position
0001AA04 9068 0018                  		sub.w	oYPos(a0),d0			; Get delta Y from current position
0001AA08 0640 0040                  		addi.w	#$40,d0				; Add $40
0001AA0C 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
0001AA10 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AA14                            		
0001AA14                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0001AA14 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
0001AA1A                            
0001AA1A 4EB8 1998                  		jsr	FindFreeObj.w			; Find a free object slot
0001AA1E 6700                       		beq.s	.SetPoint			; If there is none, branch
0001AA20 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,oAddr(a1)	; Load the checkpoint ball dongle object
0001AA26 3368 0014 0030             		move.w	oXPos(a0),oDongleX(a1)		; Dongle X
0001AA2C 3368 0018 0032             		move.w	oYPos(a0),oDongleY(a1)		; Dongle Y
0001AA32 0469 0014 0032             		subi.w	#$14,oDongleY(a1)		; ''
0001AA38 2368 0010 0010             		move.l	oMap(a0),oMap(a1)		; Mappings
0001AA3E 3368 000E 000E             		move.w	oVRAM(a0),oVRAM(a1)		; Tile properties
0001AA44 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
0001AA4A 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
0001AA50 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
0001AA56                            	displaySprite	4,a1,a2,0			; Priority
0001AA56 337C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a1)
0001AA5C 3478 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a2
0001AA60 334A 000A                M 	move.w	a2,odrawprev(a1)
0001AA64 3549 0008                M 	move.w	a1,odrawnext(a2)
0001AA68 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
0001AA6C                          M .no_266
0001AA6C 137C 0002 0010             		move.b	#2,oFrame(a1)			; Map frame
0001AA72 337C 0020 0034             		move.w	#$20,oDongleTime(a1)		; Dongle timer
0001AA78 3348 0036                  		move.w	a0,oDonglePar(a1)		; Dongle parent
0001AA7C                            
0001AA7C                            .SetPoint:
0001AA7C 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AA80 3440                       		movea.w	d0,a2				; ''
0001AA82 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AA86                            		
0001AA86 117C 0001 0020             		move.b	#1,oAni(a0)			; Use dongling animation
0001AA8C 11E8 0024 C7AE             		move.b	oSubtype(a0),rLastChkpoint.w	; Set checkpoint ID
0001AA92                            
0001AA92 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AA96 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
0001AA9C 4EF8 49DA                  		jmp	Level_SaveInfo			; Save data
0001AAA0                            		
0001AAA0                            .ChkSetAnim:
0001AAA0 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AAA4 4A28 0020                  		tst.b	oAni(a0)			; Are we still unset?
0001AAA8 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
0001AAAA 117C 0002 0020             		move.b	#2,oAni(a0)			; Use the set animation
0001AAB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AAB0                            ObjChkpoint_Animate:
0001AAB0 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0001AAB6 4EB8 1BE6                  		jsr	AnimateObject.w			; ''
0001AABA 4EF8 1FA4                  		jmp	CheckObjActive.w		; Display
0001AABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AABE                            ; Ball dongle object
0001AABE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AABE                            ObjChkPoint_Dongle:
0001AABE 5368 0034                  		subq.w	#1,oDongleTime(a0)		; Decrement timer
0001AAC2 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0001AAC4 3268 0036                  		movea.w	oDonglePar(a0),a1		; Get parent
0001AAC8 137C 0002 0020             		move.b	#2,oAni(a1)			; Set set animation for parent
0001AACE 4229 0010                  		clr.b	oFrame(a1)			; Reset map frame for parent
0001AAD2 4EB8 19F2                  		jsr	DeleteObject.w			; Delete ourselves
0001AAD6                            	nextObject
0001AAD6 3068 0004                M 	movea.w	onext(a0),a0
0001AADA 2250                     M 	move.l	oaddr(a0),a1
0001AADC 4ED1                     M 	jmp	(a1)
0001AADE                            
0001AADE                            .MoveDongle:
0001AADE 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0001AAE2 0428 0010 0041             		subi.b	#$10,oAngle(a0)			; Decrement angle
0001AAE8 0400 0040                  		subi.b	#$40,d0				; Subtract $40
0001AAEC 4EB8 12F4                  		jsr	CalcSine.w			; Get sine and cosine
0001AAF0 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
0001AAF4 4841                       		swap	d1				; Get high word
0001AAF6 D268 0030                  		add.w	oDongleX(a0),d1			; Add dongle X
0001AAFA 3141 0014                  		move.w	d1,oXPos(a0)			; Set actual X
0001AAFE C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
0001AB02 4840                       		swap	d0				; Get high word
0001AB04 D068 0032                  		add.w	oDongleY(a0),d0			; Add dongle X
0001AB08 3140 0018                  		move.w	d0,oYPos(a0)			; Set actual X
0001AB0C 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display
0001AB10                            	nextObject
0001AB10 3068 0004                M 	movea.w	onext(a0),a0
0001AB14 2250                     M 	move.l	oaddr(a0),a1
0001AB16 4ED1                     M 	jmp	(a1)
0001AB18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AB18                            ; Data
0001AB18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AB18                            ArtKosM_Chkpoint:
0001AB18                            		incbin	"Level/Objects/Checkpoint/Art.kosm.bin"
0001AC18 00                         		even
0001AC18                            Ani_ObjChkpoint:
0001AC18 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
0001AC1A 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
0001AC1C 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
0001AC1E 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
0001AC22 00                         		even
0001AC22 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
0001AC26 00                         		even
0001AC26 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
0001AC2A                            		even
0001AC2A                            Map_ObjChkpoint:
0001AC2A                            		include	"Level/Objects/Checkpoint/Mappings.asm"
0001AC2A                            ; --------------------------------------------------------------------------------
0001AC2A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AC2A                            ; --------------------------------------------------------------------------------
0001AC2A                            
0001AC2A                            SME_JjCUP:	
0001AC2A 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
0001AC2E 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
0001AC32 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
0001AC34 0004                       SME_JjCUP_A:	dc.b 0, 4	
0001AC36 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC3C F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC42 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC48 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
0001AC4E 0003                       SME_JjCUP_24:	dc.b 0, 3	
0001AC50 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC56 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC5C F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC62 0001                       SME_JjCUP_38:	dc.b 0, 1	
0001AC64 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
0001AC6A 0001                       SME_JjCUP_40:	dc.b 0, 1	
0001AC6C F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0001AC72 0004                       SME_JjCUP_48:	dc.b 0, 4	
0001AC74 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AC7A F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AC80 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AC86 D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
0001AC8C                            		even
0001AC8C                            ; =========================================================================================================================================================
0001AC8C                            		include	"Level/Objects/Wall Spring/Code.asm"	; Wall spring object
0001AC8C                            ; =========================================================================================================================================================
0001AC8C                            ; Mighty The Armadillo in PRISM PARADISE
0001AC8C                            ; By Nat The Porcupine 2021
0001AC8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AC8C                            ; Wall spring object
0001AC8C                            ; =========================================================================================================================================================
0001AC8C                            ObjWallSpring:
0001AC8C 20BC 0000 0000             		move.l	#ObjWallSpring_Main,oAddr(a0)	; Next routine
0001AC92                            	;	move.l	#Map_ObjWallSpring,oMap(a0)	; Mappings
0001AC92                            	;	clr.w	oVRAM(a0)			; Tile properties
0001AC92                            	;	ori.b	#4,oRender(a0)			; Render flags
0001AC92                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0001AC92                            	;	move.b	#8,oDrawW(a0)			; Sprite width
0001AC92                            	;	move.b	#$40,oDrawH(a0)			; Sprite height
0001AC92 117C 0008 002C             		move.b	#8,oColW(a0)			; Collision width
0001AC98 117C 0040 002D             		move.b	#$40,oColH(a0)			; Collision height
0001AC9E                            
0001AC9E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001ACA2 E808                       		lsr.b	#4,d0				; Get map frame
0001ACA4 0200 0007                  		andi.b	#7,d0				; ''
0001ACA8 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0001ACAC 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
0001ACAE                            	;	move.b	#$80,oDrawH(a0)			; Larger sprite height
0001ACAE 117C 0080 002D             		move.b	#$80,oColH(a0)			; Larger collision height
0001ACB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ACB4                            ObjWallSpring_Main:
0001ACB4 7208                       		moveq	#8,d1				; Width
0001ACB6 7400                       		moveq	#0,d2
0001ACB8 1428 002D                  		move.b	oColH(a0),d2			; Height
0001ACBC 3602                       		move.w	d2,d3				; ''
0001ACBE 5243                       		addq.w	#1,d3				; ''
0001ACC0 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001ACC4 4EB8 43F8                  		jsr	SolidObject_Always		; Make us solid
0001ACC8                            
0001ACC8 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
0001ACCC 6700                       		beq.s	.Display			; If not, branch
0001ACCE 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set in air
0001ACD4 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001ACD8 3028 0014                  		move.w	oXPos(a0),d0			; Get distance between us and Sonic
0001ACDC 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001ACE0 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
0001ACE2 0A01 0001                  		eori.b	#1,d1				; Go the other way
0001ACE6                            
0001ACE6                            .ChkXStat:
0001ACE6 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
0001ACEA 6600                       		bne.s	.Display			; If not, branch
0001ACEC 6100                       		bsr.s	.Bounce
0001ACEE                            
0001ACEE                            .Display:
0001ACEE 4EB8 1FA4                  		jsr	CheckObjActive.w		; Delete if inactive
0001ACF2                            	nextObject
0001ACF2 3068 0004                M 	movea.w	onext(a0),a0
0001ACF6 2250                     M 	move.l	oaddr(a0),a1
0001ACF8 4ED1                     M 	jmp	(a1)
0001ACFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ACFA                            .Bounce:
0001ACFA 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is Sonic dead?
0001AD00 6500                       		blo.s	.DoBounce			; If not, branch
0001AD02 4E75                       		rts
0001AD04                            
0001AD04                            .DoBounce:
0001AD04 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Make Sonic not hurt if he is
0001AD0A 337C F800 001C             		move.w	#-$800,oXVel(a1)		; Bounce left
0001AD10 337C F800 001E             		move.w	#-$800,oYVel(a1)		; Bounce up
0001AD16 08E9 0000 0028             		bset	#0,oStatus(a1)			; Face left
0001AD1C 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing left?
0001AD22 6600                       		bne.s	.MoveLock			; If so, branch
0001AD24 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Face right
0001AD2A 4469 001C                  		neg.w	oXVel(a1)			; Go right
0001AD2E                            
0001AD2E                            .MoveLock:
0001AD2E 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Set move lock timer
0001AD34 0829 0002 0028             		btst	#2,oStatus(a1)			; Was Sonic jumping?
0001AD3A 6600                       		bne.s	.ChkNoYVel			; If so, branch
0001AD3C 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AD40                            
0001AD40                            .ChkNoYVel:
0001AD40 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001AD44 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0001AD46 4229 001E                  		clr.b	oYVel(a1)			; Stop Y velocity
0001AD4A                            
0001AD4A                            .ChkFlip:
0001AD4A 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
0001AD4E 6700                       		beq.s	.PlaySnd			; If not, branch
0001AD50 337C 0001 003A             		move.w	#1,oFlipDir(a1)			; Set flip direction
0001AD56 137C 0001 0047             		move.b	#1,oFlipAngle(a1)		; Set flip angle
0001AD5C 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AD60 137C 0001 0049             		move.b	#1,oFlipRemain(a1)		; Set flips remaining
0001AD66 137C 0008 004A             		move.b	#8,oFlipSpeed(a1)		; Set flip speed
0001AD6C 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
0001AD70 6600                       		bne.s	.ChkDir				; If not, branch
0001AD72 137C 0003 0049             		move.b	#3,oFlipRemain(a1)		; Do 3 flips isntead
0001AD78                            
0001AD78                            .ChkDir:
0001AD78 0829 0000 0028             		btst	#0,oStatus(a1)			; Was Sonic facing left?
0001AD7E 6700                       		beq.s	.PlaySnd			; If not, branch
0001AD80 4429 0047                  		neg.b	oFlipAngle(a1)			; Flip the other way
0001AD84 4469 003A                  		neg.w	oFlipDir(a1)			; ''
0001AD88                            
0001AD88                            .PlaySnd:
0001AD88 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Stop pushing
0001AD8E 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001AD94                            		playSnd	#sSpring, 2			; Play spring sound
0001AD94 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001AD9A 4E75                       		rts
0001AD9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AD9C                            ; Data
0001AD9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AD9C                            Map_ObjWallSpring:
0001AD9C                            		include	"Level/Objects/Wall Spring/Mappings.asm"
0001AD9C                            ; --------------------------------------------------------------------------------
0001AD9C                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AD9C                            ; --------------------------------------------------------------------------------
0001AD9C                            
0001AD9C                            SME_ReVf5:	
0001AD9C 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
0001ADA0 0002                       SME_ReVf5_4:	dc.b 0, 2	
0001ADA2 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
0001ADA8 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
0001ADAE 0002                       SME_ReVf5_12:	dc.b 0, 2	
0001ADB0 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0001ADB6 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
0001ADBC                            		even
0001ADBC                            		even
0001ADBC                            ; =========================================================================================================================================================
0001ADBC                            		include	"Level/Objects/Ball Mode/Code.asm"	; Ball mode switch object
0001ADBC                            ; =========================================================================================================================================================
0001ADBC                            ; Mighty The Armadillo in PRISM PARADISE
0001ADBC                            ; By Nat The Porcupine 2021
0001ADBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADBC                            ; Ball mode enable/disable object
0001ADBC                            ; =========================================================================================================================================================
0001ADBC                            		rsset	oLvlSSTs
0001ADBC =00000030                  oBModeTouch	rs.b	1				; Touched flag
0001ADBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADBC                            ObjBallMode:
0001ADBC                            	;	move.l	#ObjBallMode_Main,oAddr(a0)	; Next routine
0001ADBC                            	;	move.l	#Map_ObjMonitor,oMap(a0)	; Mappings
0001ADBC                            	;	clr.w	oVRAM(a0)			; Tile properties
0001ADBC                            	;	ori.b	#4,oRender(a0)			; Render flags
0001ADBC                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
0001ADBC                            	;	move.b	#$10,oDrawW(a0)			; Sprite width
0001ADBC                            	;	move.b	#$10,oDrawH(a0)			; Sprite height
0001ADBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADBC                            ObjBallMode_Main:
0001ADBC 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001ADC0 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001ADC4 4EB8 1D06                  		jsr	CheckObjInRange.w		; Is the player in range?
0001ADC8 4A40                       		tst.w	d0				; ''
0001ADCA 6700                       		beq.s	.NotTouched			; If not, branch
0001ADCC                            
0001ADCC 08AA 0002 000C             		bclr	#2,oFlags(a2)
0001ADD2                            		
0001ADD2 4A28 0024                  		tst.b	oSubtype(a0)			; Should we force Sonic out of ball mode?
0001ADD6 6B00                       		bmi.s	.NoBallMode			; If so, branch
0001ADD8 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
0001ADDA                            
0001ADDA 4A28 0030                  		tst.b	oBModeTouch(a0)			; Have we already been touched?
0001ADDE 6600                       		bne.s	.End				; If so, branch
0001ADE0 50E8 0030                  		st	oBModeTouch(a0)			; Touched
0001ADE4                            
0001ADE4 462A 004B                  		not.b	oBallMode(a2)			; Switch ball mode for Sonic
0001ADE8 6700                       		beq.s	.End				; If it's not set, branch
0001ADEA                            
0001ADEA                            .MakeSonicRoll:
0001ADEA 2248                       		movea.l	a0,a1				; Save a0
0001ADEC 204A                       		movea.l	a2,a0				; Make Sonic roll
0001ADEE 4EB9 0000 BAA2             		jsr	ObjMighty_DoRoll			; ''
0001ADF4 2049                       		movea.l	a1,a0				; Restore a0
0001ADF6                            	nextObject
0001ADF6 3068 0004                M 	movea.w	onext(a0),a0
0001ADFA 2250                     M 	move.l	oaddr(a0),a1
0001ADFC 4ED1                     M 	jmp	(a1)
0001ADFE                            
0001ADFE                            .NotTouched:
0001ADFE 4228 0030                  		clr.b	oBModeTouch(a0)			; Not touched
0001AE02                            	nextObject
0001AE02 3068 0004                M 	movea.w	onext(a0),a0
0001AE06 2250                     M 	move.l	oaddr(a0),a1
0001AE08 4ED1                     M 	jmp	(a1)
0001AE0A                            
0001AE0A                            .BallMode:
0001AE0A 50EA 004B                  		st	oBallMode(a2)			; Get in to ball mode
0001AE0E 60DA                       		bra.s	.MakeSonicRoll			; ''
0001AE10                            
0001AE10                            .NoBallMode:
0001AE10 422A 004B                  		clr.b	oBallMode(a2)			; Get out of ball mode
0001AE14                            
0001AE14                            .End:
0001AE14                            	nextObject
0001AE14 3068 0004                M 	movea.w	onext(a0),a0
0001AE18 2250                     M 	move.l	oaddr(a0),a1
0001AE1A 4ED1                     M 	jmp	(a1)
0001AE1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE1C                            .RangeData:
0001AE1C FFF0 0020                  		dc.w	-$10, $20
0001AE20 FFF0 0020                  		dc.w	-$10, $20
0001AE24                            ; =========================================================================================================================================================
0001AE24                            		include	"Level/Objects/Bumper/Code.asm"		; Bumper object
0001AE24                            ; =========================================================================================================================================================
0001AE24                            ; Mighty The Armadillo in PRISM PARADISE
0001AE24                            ; By Nat The Porcupine 2021
0001AE24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE24                            ; Water surface object
0001AE24                            ; =========================================================================================================================================================
0001AE24                            		rsset	oLvlSSTs
0001AE24                            
0001AE24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE24                            ObjBumper:
0001AE24 20BC 0000 0000             		move.l	#ObjBumperMain,oAddr(a0)	; Next routine
0001AE2A 217C 0000 0000 0010        		move.l	#Map_ObjBumper,oMap(a0)		; Mappings
0001AE32 317C 035B 000E             		move.w	#$35B,oVRAM(a0)			; Tile properties
0001AE38 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AE3E                            	displaySprite	1,a0,a1,0			; Priority
0001AE3E 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
0001AE44 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
0001AE48 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AE4C 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AE50 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
0001AE54                          M .no_274
0001AE54 7210                       		moveq	#$10,d1
0001AE56 1141 0017                  		move.b	d1,oDrawW(a0)
0001AE5A 1141 002C                  		move.b	d1,oColW(a0)
0001AE5E 1141 001B                  		move.b	d1,oDrawH(a0)
0001AE62 1141 002D                  		move.b	d1,oColH(a0)
0001AE66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE66                            ObjBumperMain:
0001AE66 4A38 F8D1                  		tst.b	rDebugMode.w
0001AE6A 6600 0000                  		bne.w	.Display
0001AE6E                            
0001AE6E 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AE72 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AE76 0C2A 000C 0025             		cmpi.b	#$C,oRoutine(a2)
0001AE7C 6400 0000                  		bcc.w	.Display
0001AE80 4EB8 1D06                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AE84 4A40                       		tst.w	d0				; ''
0001AE86 6700                       		beq.s	.Display			; If not, branch
0001AE88                            
0001AE88 3228 0014                  		move.w	oXPos(a0),d1
0001AE8C 3428 0018                  		move.w	oYPos(a0),d2
0001AE90 926A 0014                  		sub.w	oXPos(a2),d1
0001AE94 946A 0018                  		sub.w	oYPos(a2),d2
0001AE98 4EB8 1706                  		jsr	CalcArcTan.w
0001AE9C 1238 C759                  		move.b	(rFrameCnt+3).w,d1
0001AEA0 0241 0003                  		andi.w	#3,d1
0001AEA4 D041                       		add.w	d1,d0
0001AEA6 4EB8 12F4                  		jsr	CalcSine.w
0001AEAA C3FC F900                  		muls.w	#-$700,d1
0001AEAE E081                       		asr.l	#8,d1
0001AEB0 3541 001C                  		move.w	d1,oXVel(a2)
0001AEB4 C1FC F900                  		muls.w	#-$700,d0
0001AEB8 E080                       		asr.l	#8,d0
0001AEBA 3540 001E                  		move.w	d0,oYVel(a2)
0001AEBE 0C2A 0008 0025             		cmpi.b	#8,oRoutine(a2)
0001AEC4 6600                       		bne.s	.NotHurt
0001AEC6 157C 0002 0020             		move.b	#2,oAni(a2)
0001AECC 5A6A 0018                  		addq.w	#5,oYPos(a2)
0001AED0 157C 000E 002D             		move.b	#$E,oColH(a2)
0001AED6 157C 0007 002C             		move.b	#7,oColW(a2)
0001AEDC 08EA 0002 0028             		bset	#2,oStatus(a2)
0001AEE2                            
0001AEE2                            .NotHurt:
0001AEE2 157C 0004 0025             		move.b	#4,oRoutine(a2)
0001AEE8 08EA 0001 0028             		bset	#1,oStatus(a2)
0001AEEE 08AA 0005 0028             		bclr	#5,oStatus(a2)
0001AEF4 422A 0040                  		clr.b	oJumping(a2)
0001AEF8 117C 0001 0020             		move.b	#1,oAni(a0)
0001AEFE                            		playSnd	#sBumper, 2
0001AEFE 11FC 0091 C4BD           M 	move.b	#sbumper,(mqueue+((2)-1)).w
0001AF04                            
0001AF04                            .Display:
0001AF04 43FA 0000                  		lea	Ani_ObjBumper(pc),a1
0001AF08 4EB8 1BE6                  		jsr	AnimateObject.w
0001AF0C 4EB8 1FA4                  		jsr	CheckObjActive.w		; Display
0001AF10 4EB8 49C8                  		jsr	AddToColResponse		; Allow collision
0001AF14                            	nextObject
0001AF14 3068 0004                M 	movea.w	onext(a0),a0
0001AF18 2250                     M 	move.l	oaddr(a0),a1
0001AF1A 4ED1                     M 	jmp	(a1)
0001AF1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF1C                            .RangeData:
0001AF1C FFE8 0030                  		dc.w	-$18, $30
0001AF20 FFE8 0030                  		dc.w	-$18, $30
0001AF24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF24                            ; Data
0001AF24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF24                            Map_ObjBumper:
0001AF24                            		include	"Level/Objects/Bumper/Mappings.asm"
0001AF24                            ; --------------------------------------------------------------------------------
0001AF24                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AF24                            ; --------------------------------------------------------------------------------
0001AF24                            
0001AF24                            SME_3VuTU:	
0001AF24 0000 0000                  		dc.w SME_3VuTU_6-SME_3VuTU, SME_3VuTU_E-SME_3VuTU	
0001AF28 0000                       		dc.w SME_3VuTU_16-SME_3VuTU	
0001AF2A 0001                       SME_3VuTU_6:	dc.b 0, 1	
0001AF2C F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001AF32 0001                       SME_3VuTU_E:	dc.b 0, 1	
0001AF34 F40A 0029 FFF4             		dc.b $F4, $A, 0, $29, $FF, $F4	
0001AF3A 0004                       SME_3VuTU_16:	dc.b 0, 4	
0001AF3C EC0F 0010 FFEC             		dc.b $EC, $F, 0, $10, $FF, $EC	
0001AF42 EC03 0020 000C             		dc.b $EC, 3, 0, $20, 0, $C	
0001AF48 0C0C 0024 FFEC             		dc.b $C, $C, 0, $24, $FF, $EC	
0001AF4E 0C00 0028 000C             		dc.b $C, 0, 0, $28, 0, $C	
0001AF54                            		even
0001AF54                            		even
0001AF54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF54                            Ani_ObjBumper:
0001AF54 0000                       		dc.w	.Ani0-Ani_ObjBumper
0001AF56 0000                       		dc.w	.Ani1-Ani_ObjBumper
0001AF58 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
0001AF5C 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0001AF64 00                         		even
0001AF64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF64                            ArtKosM_Bumper:
0001AF64                            		incbin	"Level/Objects/Bumper/Art.kosm.bin"
0001B232 00                         		even
0001B232                            ; =========================================================================================================================================================
0001B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B232                            ; Unused/Temporary
0001B232                            ;		include	"Level/Objects/Slicer/Code.asm"		; Slicer object
0001B232                            ;		include	"Level/Objects/Shellcracker/Code.asm"	; Shellcracker object
0001B232                            ;		include	"Level/Objects/Asteron/Code.asm"	; Asteron object
0001B232                            ;		include	"Level/Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0001B232                            ;		include	"Level/Objects/Harpoon/Code.asm"	; Harpoon object
0001B232                            ;		include	"Level/Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0001B232                            ;		include	"Level/Objects/Diamond/Code.asm"	; Diamond object
0001B232                            ;		include	"Level/Objects/Orbinaut/Code.asm"	; Orbinaut object
0001B232                            ; =========================================================================================================================================================
0001B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B232                            ; Ending
0001B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B232                            		include	"Ending/Main.asm"
0001B232                            ; =========================================================================================================================================================
0001B232                            ; Mighty The Armadillo in PRISM PARADISE
0001B232                            ; By Nat The Porcupine 2021
0001B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B232                            ; End splash screen
0001B232                            ; =========================================================================================================================================================
0001B232                            
0001B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B232                            Ending:
0001B232 60FE                       		bra.s	Ending
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ;		playSnd	#Mus_Stop, 1			; Stop sound
0001B234                            ;
0001B234                            ;		intsOff					; Disable interrupts
0001B234                            ;
0001B234                            ;		lea	VDP_CTRL,a5
0001B234                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0001B234                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
0001B234                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
0001B234                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0001B234                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
0001B234                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
0001B234                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
0001B234                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0001B234                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
0001B234                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0001B234                            ;
0001B234                            ;		jsr	ClearScreen.w			; Clear screen
0001B234                            ;
0001B234                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
0001B234                            ;		lea	rBuffer,a1			; Decompress into RAM
0001B234                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0001B234                            ;		jsr	EniDec.w			; Decompress!
0001B234                            ;
0001B234                            ;		lea	rBuffer,a1			; Load mappings
0001B234                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
0001B234                            ;		moveq	#$27,d1				; $28x$1C tiles
0001B234                            ;		moveq	#$1B,d2				; ''
0001B234                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0001B234                            ;		jsr	LoadPlaneMap.w			; Load the map
0001B234                            ;
0001B234                            ;		lea	ArtKosM_End,a1			; Load background art
0001B234                            ;		move.w	#$20,d2				; ''
0001B234                            ;		jsr	QueueKosMData.w			; ''
0001B234                            ;
0001B234                            ;.WaitPLCs:
0001B234                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B234                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0001B234                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B234                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0001B234                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
0001B234                            ;		bne.s	.WaitPLCs			; If so, branch
0001B234                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B234                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B234                            ;
0001B234                            ;		lea	SampleList+$F0,a3
0001B234                            ;		jsr	PlayDAC1
0001B234                            ;
0001B234                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
0001B234                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
0001B234                            ;		jsr	LoadPalette.w			; ''
0001B234                            ;
0001B234                            ;		displayOn
0001B234                            ;
0001B234                            ;.Loop:
0001B234                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
0001B234                            ;		jsr	VSync_Routine.w			; ''
0001B234                            ;		bra.s	.Loop
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ; Art
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ;ArtKosM_End:
0001B234                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
0001B234                            ;		even
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ; Plane mappings
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ;MapEni_End:
0001B234                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
0001B234                            ;		even
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ; Palette
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ;Pal_End:
0001B234                            ;		incbin	"Ending/Data/Palette.pal.bin"
0001B234                            ;Pal_End_End:
0001B234                            ;		even
0001B234                            ; =========================================================================================================================================================
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            ; Horizontal interrupt for palette swapping (for water)
0001B234                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B234                            HInt_Water:
0001B234                            		intsOff					; Disable interrupts
0001B234 007C 0700                M 	ori	#$700,sr
0001B238                            
0001B238 4A38 C749                  		tst.b	rHIntFlag.w			; Is the H-INT allowed to run?
0001B23C 6700                       		beq.s	.End				; If not, branch
0001B23E 4238 C749                  		clr.b	rHIntFlag.w			; Clear the H-INT flag
0001B242                            
0001B242                            		push.l	a0-a1				; Save registers
0001B242 48E7 00C0                M 	movem.l	a0-a1,-(sp)
0001B246                            
0001B246 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
0001B24C 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0001B252 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette
0001B256                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
0001B256 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
0001B25E                            		rept	32
0001B25E                            			move.l	(a0)+,(a1)		; Tranfer palette
0001B25E                            		endr
0001B25E 2298                     M 	move.l	(a0)+,(a1)
0001B260 2298                     M 	move.l	(a0)+,(a1)
0001B262 2298                     M 	move.l	(a0)+,(a1)
0001B264 2298                     M 	move.l	(a0)+,(a1)
0001B266 2298                     M 	move.l	(a0)+,(a1)
0001B268 2298                     M 	move.l	(a0)+,(a1)
0001B26A 2298                     M 	move.l	(a0)+,(a1)
0001B26C 2298                     M 	move.l	(a0)+,(a1)
0001B26E 2298                     M 	move.l	(a0)+,(a1)
0001B270 2298                     M 	move.l	(a0)+,(a1)
0001B272 2298                     M 	move.l	(a0)+,(a1)
0001B274 2298                     M 	move.l	(a0)+,(a1)
0001B276 2298                     M 	move.l	(a0)+,(a1)
0001B278 2298                     M 	move.l	(a0)+,(a1)
0001B27A 2298                     M 	move.l	(a0)+,(a1)
0001B27C 2298                     M 	move.l	(a0)+,(a1)
0001B27E 2298                     M 	move.l	(a0)+,(a1)
0001B280 2298                     M 	move.l	(a0)+,(a1)
0001B282 2298                     M 	move.l	(a0)+,(a1)
0001B284 2298                     M 	move.l	(a0)+,(a1)
0001B286 2298                     M 	move.l	(a0)+,(a1)
0001B288 2298                     M 	move.l	(a0)+,(a1)
0001B28A 2298                     M 	move.l	(a0)+,(a1)
0001B28C 2298                     M 	move.l	(a0)+,(a1)
0001B28E 2298                     M 	move.l	(a0)+,(a1)
0001B290 2298                     M 	move.l	(a0)+,(a1)
0001B292 2298                     M 	move.l	(a0)+,(a1)
0001B294 2298                     M 	move.l	(a0)+,(a1)
0001B296 2298                     M 	move.l	(a0)+,(a1)
0001B298 2298                     M 	move.l	(a0)+,(a1)
0001B29A 2298                     M 	move.l	(a0)+,(a1)
0001B29C 2298                     M 	move.l	(a0)+,(a1)
0001B29E                            		pop.l	a0-a1				; Restore registers
0001B29E 4CDF 0300                M 	movem.l	(sp)+,a0-a1
0001B2A2                            		
0001B2A2 4A38 C75D                  		tst.b	rHIntUpdates.w		; Do we need to do level updates in here?
0001B2A6 6600                       		bne.s	.DoUpdates			; If so, branch
0001B2A8                            
0001B2A8                            .End:
0001B2A8 4E73                       		rte
0001B2AA                            
0001B2AA                            .DoUpdates:
0001B2AA 4238 C75D                  		clr.b	rHIntUpdates.w		; Clear the update flag
0001B2AE                            		push.l	d0-a6				; Save registers
0001B2AE 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
0001B2B2 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0001B2B8 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0001B2BC 4EB8 3FA8                  		jsr	Level_UpdateHUD			; Update the HUD
0001B2C0 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0001B2C6                            		pop.l	d0-a6				; Restore registers
0001B2C6 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0001B2CA 4E73                       		rte
0001B2CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2CC                            ; Sound driver
0001B2CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B2CC                            		include	"../amps/code/68k.asm"
0001B2CC                            	opt oz+					; enable zero-offset optimization
0001B2CC                            	opt l.					; local lables are dots
0001B2CC                            	opt ae+					; enable automatic even's
0001B2CC                            
0001B2CC                            	include "../amps/code/routines.asm"	; include macro'd routines
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Note timout handler macro
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dNoteToutHandler	macro
0001B2CC                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0001B2CC                            		beq.s	.endt			; if is, do not timeout
0001B2CC                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0001B2CC                            		bne.s	.endt			; if still not 0, branch
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Note timout handler macro for DAC
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dNoteToutDAC	macro
0001B2CC                            	dNoteToutHandler			; include timeout handler
0001B2CC                            		moveq	#0,d0			; play stop sample
0001B2CC                            		bra.w	dNoteOnDAC2		; ''
0001B2CC                            .endt
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Note timout handler macro for FM
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dNoteToutFM	macro
0001B2CC                            	dNoteToutHandler			; include timeout handler
0001B2CC                            		bset	#cfbRest,(a5)		; set track to resting
0001B2CC                            		bsr.w	dKeyOffFM		; key off FM
0001B2CC                            		bra.\0	.next			; jump to next track
0001B2CC                            .endt
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Note timout handler macro for PSG
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dNoteToutPSG	macro
0001B2CC                            	dNoteToutHandler			; include timeout handler
0001B2CC                            		bset	#cfbRest,(a5)		; set track to resting
0001B2CC                            		bsr.w	dMutePSGmus		; mute PSG channel
0001B2CC                            		bra.s	.next			; jump to next track
0001B2CC                            .endt
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for calculating the current frequency (without modulation) into d6.
0001B2CC                            ; Used if user wants to add extra pitch effects such as pitch slides.
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dCalcFreq	macro
0001B2CC                            		move.b	cDetune(a5),d6		; get detune value to d6
0001B2CC                            		ext.w	d6			; extend to word
0001B2CC                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for generating frequency modulation code
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dModulate	macro jump,loop,type
0001B2CC                            		btst	#cfbMod,(a5)		; check if modulation is active
0001B2CC                            		beq.s	.noret			; if not, update volume and return
0001B2CC                            		tst.b	cModDelay(a5)		; check if there is delay left
0001B2CC                            		beq.s	.started		; if not, modulate!
0001B2CC                            		subq.b	#1,cModDelay(a5)	; decrease delay
0001B2CC                            .noret
0001B2CC                            	if narg>0
0001B2CC                            		if narg=3
0001B2CC                            			if type<2
0001B2CC                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2CC                            				beq.s	.noupdatevol		; if not, skip
0001B2CC                            				jsr	dUpdateVolFM(pc)	; update FM volume
0001B2CC                            			.noupdatevol:
0001B2CC                            			endif
0001B2CC                            			if type>=4
0001B2CC                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B2CC                            				beq.s	.noupdatevol		; if not, skip
0001B2CC                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0001B2CC                            			.noupdatevol:
0001B2CC                            			endif
0001B2CC                            			if \type<>5
0001B2CC                            				dbf	d7,\loop		; loop for all channels
0001B2CC                            			endif
0001B2CC                            		endif
0001B2CC                            		bra.w	\jump			; jump to next routine
0001B2CC                            	else
0001B2CC                            		bra.s	.endm			; jump to the next .endm routine
0001B2CC                            	endif
0001B2CC                            .started
0001B2CC                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0001B2CC                            		bne.s	.noret			; if there's still delay left, update vol and return
0001B2CC                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0001B2CC                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0001B2CC                            		tst.b	cModCount(a5)		; check if this was the last step
0001B2CC                            		bne.s	.norev			; if was not, do not reverse
0001B2CC                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0001B2CC                            		neg.b	cModStep(a5)		; negate step amount
0001B2CC                            .norev
0001B2CC                            		subq.b	#1,cModCount(a5)	; decrease step counter
0001B2CC                            		move.b	cModStep(a5),d5		; get step offset into d5
0001B2CC                            		ext.w	d5			; extend to word
0001B2CC                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0001B2CC                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0001B2CC                            		add.w	d5,d6			; add to channel base frequency
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for processing the tracker
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dDoTracker	macro
0001B2CC                            		movea.l	cData(a5),a4		; grab tracker address
0001B2CC                            	if safe=1
0001B2CC                            		AMPS_Debug_TrackUpd		; check if this address is valid
0001B2CC                            	endif
0001B2CC                            .data
0001B2CC                            		moveq	#0,d5
0001B2CC                            		move.b	(a4)+,d5		; get a byte from tracker
0001B2CC                            		cmpi.b	#$E0,d5			; is this a command?
0001B2CC                            		blo.s	.notcomm		; if not, continue
0001B2CC                            		jsr	dCommands(pc)		; run the condition flag
0001B2CC                            		bra.s	.data			; for most commands, use this branch to loop
0001B2CC                            		bra.s	.next			; however, for example sStop will make us return here.
0001B2CC                            .notcomm
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for playing a note, and setting up for it (software updates only)
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dProcNote	macro sfx, psg
0001B2CC                            		move.l	a4,cData(a5)		; save tracker address
0001B2CC                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0001B2CC                            		btst	#cfbHold,(a5)		; check if we are holding
0001B2CC                            		bne.s	.endpn			; if we are, branch
0001B2CC                            	if sfx=0
0001B2CC                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0001B2CC                            	endif
0001B2CC                            	if psg<>0
0001B2CC                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0001B2CC                            	endif
0001B2CC                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0001B2CC                            		beq.s	.endpn			; if not, branch
0001B2CC                            		movea.l	cMod(a5),a1		; get modulation data address
0001B2CC                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0001B2CC                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0001B2CC                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0001B2CC                            		move.b	(a1),d0			; get number of steps
0001B2CC                            		lsr.b	#1,d0			; halve it
0001B2CC                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0001B2CC                            		clr.w	cModFreq(a5)		; clear frequency offset
0001B2CC                            .endpn
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for processing a note in DAC channel
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dTrackNoteDAC	macro
0001B2CC                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0001B2CC                            		bne.s	.pitch			; if so, load pitch
0001B2CC                            		move.b	d5,cSample(a5)		; else, save as a sample
0001B2CC                            		bra.s	.cont
0001B2CC                            .pitch
0001B2CC                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001B2CC                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0001B2CC                            		moveq	#0,d0			; play stop sample
0001B2CC                            		bsr.w	dNoteOnDAC2		; ''
0001B2CC                            		moveq	#-$80,d6		; tell the code we are resting
0001B2CC                            		bra.s	.cont
0001B2CC                            .noprest
0001B2CC                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2CC                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2CC                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001B2CC                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2CC                            .cont
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for doing keying-on FM channel
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dKeyOnFM	macro
0001B2CC                            		btst	#cfbHold,(a5)		; check if note is held
0001B2CC                            		bne.s	.k			; if so, do not note on
0001B2CC                            		btst	#cfbRest,(a5)		; check if channel is resting
0001B2CC                            		bne.s	.k			; if so, do not note on
0001B2CC                            	if narg=0
0001B2CC                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0001B2CC                            		bne.s	.k			; if so, do not note on
0001B2CC                            	endif
0001B2CC                            		moveq	#$28,d0			; YM command: Key on
0001B2CC                            		move.b	cType(a5),d1		; get channel type bits
0001B2CC                            		ori.b	#$F0,d1			; turn all FM operators on
0001B2CC                            		bsr.w	WriteYM_Pt1		; send note-on event
0001B2CC                            .k
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Macro for processing a note in PSG channel
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            dGetFreqPSG	macro
0001B2CC                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0001B2CC                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0001B2CC                            		bset	#cfbRest,(a5)		; set channel to resting
0001B2CC                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0001B2CC                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0001B2CC                            		bra.s	.freqgot
0001B2CC                            .norest
0001B2CC                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B2CC                            		andi.w	#$7F,d5			; keep within $80 notes
0001B2CC                            		add.w	d5,d5			; double offset (each entry is a word)
0001B2CC                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0001B2CC                            	if safe=1
0001B2CC                            		AMPS_Debug_NotePSG		; check if the note was valid
0001B2CC                            	endif
0001B2CC                            .freqgot
0001B2CC                                endm
0001B2CC                            ; ===========================================================================
0001B2CC                            	include "../amps/code/debug.asm"	; debug data blob
0001B2CC                            ; ===========================================================================
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            ; Routine for loading the Dual PCM driver into Z80 RAM
0001B2CC                            ; ---------------------------------------------------------------------------
0001B2CC                            
0001B2CC                            LoadDualPCM:
0001B2CC 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0001B2D4 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B2DC                            
0001B2DC 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0001B2E2 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0001B2E8 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0001B2EC                            
0001B2EC                            .z80
0001B2EC 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0001B2F4 66F6                       		bne.s	.z80			; if not, wait more
0001B2F6                            
0001B2F6                            .load
0001B2F6 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0001B2F8 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0001B2FC                            
0001B2FC 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0001B300 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0001B306                            
0001B306                            	rept 6
0001B306                            		move.b	(a0)+,(a1)+		; copy all required data
0001B306                            	endr
0001B306 12D8                     M 	move.b	(a0)+,(a1)+
0001B308 12D8                     M 	move.b	(a0)+,(a1)+
0001B30A 12D8                     M 	move.b	(a0)+,(a1)+
0001B30C 12D8                     M 	move.b	(a0)+,(a1)+
0001B30E 12D8                     M 	move.b	(a0)+,(a1)+
0001B310 12D8                     M 	move.b	(a0)+,(a1)+
0001B312                            
0001B312 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0001B314 0838 0006 C744             		btst	#6,rHWVersion.w	; is this a PAL Mega Drive?
0001B31A 6700                       		beq.s	.ntsc			; if not, branch
0001B31C 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0001B31E                            .ntsc
0001B31E 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0001B324                            
0001B324 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0001B32C 727F                       		moveq	#$7F,d1			; wait for a little bit
0001B32E 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0001B332                            
0001B332 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0001B33A 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B342 4E75                       		rts
0001B344                            ; ---------------------------------------------------------------------------
0001B344                            ; Play DAC
0001B344                            ; ---------------------------------------------------------------------------
0001B344                            
0001B344                            PlayDAC2:
0001B344 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B34A                            	StopZ80					; wait for Z80 to stop
0001B34A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B352                          M 	waitz80stop
0001B352 0839 0000 00A1 1100      M .wait_284:	btst	#0,z80_bus_req
0001B35A 66F6                     M 	bne.s	.wait_284
0001B35C                            	rept 12
0001B35C                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B35C                            	endr
0001B35C 12DB                     M 	move.b	(a3)+,(a1)+
0001B35E 12DB                     M 	move.b	(a3)+,(a1)+
0001B360 12DB                     M 	move.b	(a3)+,(a1)+
0001B362 12DB                     M 	move.b	(a3)+,(a1)+
0001B364 12DB                     M 	move.b	(a3)+,(a1)+
0001B366 12DB                     M 	move.b	(a3)+,(a1)+
0001B368 12DB                     M 	move.b	(a3)+,(a1)+
0001B36A 12DB                     M 	move.b	(a3)+,(a1)+
0001B36C 12DB                     M 	move.b	(a3)+,(a1)+
0001B36E 12DB                     M 	move.b	(a3)+,(a1)+
0001B370 12DB                     M 	move.b	(a3)+,(a1)+
0001B372 12DB                     M 	move.b	(a3)+,(a1)+
0001B374 101B                       		move.b	(a3)+,d0
0001B376 5200                       		addq.b	#1,d0
0001B378 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0001B37E 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0001B384 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B38C                            
0001B38C 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001B394                            	StartZ80				; enable Z80 execution
0001B394 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B39C 4E75                       		rts
0001B39E                            
0001B39E                            ; ---------------------------------------------------------------------------
0001B39E                            
0001B39E                            PlayDAC1:
0001B39E 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0001B3A4                            	StopZ80					; wait for Z80 to stop
0001B3A4 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B3AC                          M 	waitz80stop
0001B3AC 0839 0000 00A1 1100      M .wait_287:	btst	#0,z80_bus_req
0001B3B4 66F6                     M 	bne.s	.wait_287
0001B3B6                            	rept 12
0001B3B6                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B3B6                            	endr
0001B3B6 12DB                     M 	move.b	(a3)+,(a1)+
0001B3B8 12DB                     M 	move.b	(a3)+,(a1)+
0001B3BA 12DB                     M 	move.b	(a3)+,(a1)+
0001B3BC 12DB                     M 	move.b	(a3)+,(a1)+
0001B3BE 12DB                     M 	move.b	(a3)+,(a1)+
0001B3C0 12DB                     M 	move.b	(a3)+,(a1)+
0001B3C2 12DB                     M 	move.b	(a3)+,(a1)+
0001B3C4 12DB                     M 	move.b	(a3)+,(a1)+
0001B3C6 12DB                     M 	move.b	(a3)+,(a1)+
0001B3C8 12DB                     M 	move.b	(a3)+,(a1)+
0001B3CA 12DB                     M 	move.b	(a3)+,(a1)+
0001B3CC 12DB                     M 	move.b	(a3)+,(a1)+
0001B3CE 101B                       		move.b	(a3)+,d0
0001B3D0 5200                       		addq.b	#1,d0
0001B3D2 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0001B3D8 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0001B3DE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B3E6                            
0001B3E6 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B3EE                            	StartZ80				; enable Z80 execution
0001B3EE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B3F6 4E75                       		rts
0001B3F8                            ; ===========================================================================
0001B3F8                            ; ---------------------------------------------------------------------------
0001B3F8                            ; Handle Dual PCM YM Cue correctly
0001B3F8                            ; ---------------------------------------------------------------------------
0001B3F8                            
0001B3F8                            UpdateAMPS:
0001B3F8                            	StopZ80					; wait for Z80 to stop
0001B3F8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B400                          M 	waitz80stop
0001B400 0839 0000 00A1 1100      M .wait_290:	btst	#0,z80_bus_req
0001B408 66F6                     M 	bne.s	.wait_290
0001B40A 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0001B410                            	StartZ80				; enable Z80 execution
0001B410 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B418                            
0001B418 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0001B41E 4A00                       		tst.b	d0			; check buffer to use
0001B420 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0001B422 D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0001B426                            
0001B426                            .gotbuffer
0001B426 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0001B428                            
0001B428                            	StopZ80					; wait for Z80 to stop
0001B428 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B430                          M 	waitz80stop
0001B430 0839 0000 00A1 1100      M .wait_293:	btst	#0,z80_bus_req
0001B438 66F6                     M 	bne.s	.wait_293
0001B43A 50D0                       		st	(a0)			; make sure cue is marked as completed
0001B43C                            	StartZ80				; enable Z80 execution
0001B43C 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B444                            
0001B444                            dPaused:
0001B444 4E75                       		rts
0001B446                            ; ===========================================================================
0001B446                            ; ---------------------------------------------------------------------------
0001B446                            ; Main routine for updating the AMPS driver
0001B446                            ; ---------------------------------------------------------------------------
0001B446                            
0001B446                            dUpdateAllAMPS:
0001B446 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0001B44A 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0001B44E 6BF4                       		bmi.s	dPaused			; if yes, branch
0001B450                            ; ---------------------------------------------------------------------------
0001B450                            ; This is the new fading feature I created, to make custom fading
0001B450                            ; types easier to program. You can define series of 3 bytes, each
0001B450                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0001B450                            ; once per frame. If the first value in a frame is a command flag,
0001B450                            ; instead its code is executed. Additionally, no fade program may
0001B450                            ; appear before ROM offset $10000, or else it will never be executed.
0001B450                            ; ---------------------------------------------------------------------------
0001B450                            
0001B450 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001B454 6700                       		beq.s	.chkregion		; branch if not
0001B456                            
0001B456 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0001B45A 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0001B45E                            
0001B45E 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0001B460 7000                       		moveq	#0,d0
0001B462 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0001B464 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0001B466                            
0001B466 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0001B46A 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0001B46E 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0001B472 6000                       		bra.s	.chkregion		; go check the region
0001B474                            
0001B474                            .nofadeend
0001B474 B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0001B478 6700                       		beq.s	.fadedac		; if did not, branch
0001B47A 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0001B47E 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0001B482                            
0001B482                            .fadedac
0001B482 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0001B484 B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0001B488 6700                       		beq.s	.fadepsg		; if did not, branch
0001B48A 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0001B48E                            
0001B48E =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001B48E                            	rept Mus_DAC				; do for all music DAC channels
0001B48E                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B48E                            .ch =		.ch+cSize			; go to next channel
0001B48E                            	endr
0001B48E 8338 C4C4                M 	or.b	d1,.ch.w
0001B492 =FFFFC4F0                M .ch	=	.ch+csize
0001B492 8338 C4F0                M 	or.b	d1,.ch.w
0001B496 =FFFFC51C                M .ch	=	.ch+csize
0001B496 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0001B49A                            
0001B49A                            .fadepsg
0001B49A 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0001B49C B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0001B4A0 6700                       		beq.s	.chkregion		; if did not, branch
0001B4A2 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0001B4A6                            
0001B4A6 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001B4A6                            	rept Mus_PSG				; do for all music PSG channels
0001B4A6                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4A6                            .ch =		.ch+cSize			; go to next channel
0001B4A6                            	endr
0001B4A6 8338 C5F8                M 	or.b	d1,.ch.w
0001B4AA =FFFFC624                M .ch	=	.ch+csize
0001B4AA 8338 C624                M 	or.b	d1,.ch.w
0001B4AE =FFFFC650                M .ch	=	.ch+csize
0001B4AE 8338 C650                M 	or.b	d1,.ch.w
0001B4B2 =FFFFC67C                M .ch	=	.ch+csize
0001B4B2                            
0001B4B2 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001B4B2                            	rept SFX_PSG				; do for all SFX PSG channels
0001B4B2                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B4B2                            .ch =		.ch+cSizeSFX			; go to next channel
0001B4B2                            	endr
0001B4B2 8338 C6EC                M 	or.b	d1,.ch.w
0001B4B6 =FFFFC708                M .ch	=	.ch+csizesfx
0001B4B6 8338 C708                M 	or.b	d1,.ch.w
0001B4BA =FFFFC724                M .ch	=	.ch+csizesfx
0001B4BA 8338 C724                M 	or.b	d1,.ch.w
0001B4BE =FFFFC740                M .ch	=	.ch+csizesfx
0001B4BE                            ; ---------------------------------------------------------------------------
0001B4BE                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0001B4BE                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0001B4BE                            ; on PAL systems. This will cause issues with some songs that rely on
0001B4BE                            ; game engine to seem "in sync". Because of that, I added a flag to
0001B4BE                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0001B4BE                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0001B4BE                            ; play at the exact right speed, instead of slightly too slow.
0001B4BE                            ; ---------------------------------------------------------------------------
0001B4BE                            
0001B4BE 0838 0006 C744             .chkregion	btst	#6,rHWVersion.w	; is this PAL system?
0001B4C4 6700                       		beq.s	.driver			; if not, branch
0001B4C6 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0001B4CA 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0001B4CC                            
0001B4CC 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0001B4D2 6600                       		bne.s	.nofix			; if yes, run music and SFX
0001B4D4 6100                       		bsr.s	.nosfx			; run the sound driver
0001B4D6                            
0001B4D6                            .nofix
0001B4D6 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0001B4DC                            .driver
0001B4DC 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0001B4E0                            
0001B4E0                            .nosfx		; continue to run sound driver again
0001B4E0                            ; ---------------------------------------------------------------------------
0001B4E0                            ; There are 2 methods of handling tempo adjustments in SMPS,
0001B4E0                            ; overflow (where a value is added to the accumulator, and when it
0001B4E0                            ; range overflows, tick of delay is added), and counter (where a
0001B4E0                            ; counter is copied to the tempo, which is then decreased each frame,
0001B4E0                            ; until it becomes 0, after which a tick of delay is added). AMPS
0001B4E0                            ; supports these both too, because there is no single right answer,
0001B4E0                            ; and users may prefer one over the other. The overflow method is
0001B4E0                            ; really good for low values, as it provides very fine control over
0001B4E0                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0001B4E0                            ; method isn't as good for small values, but for large value it works
0001B4E0                            ; better. You may choose this setting in the macro.asm file,
0001B4E0                            ; ---------------------------------------------------------------------------
0001B4E0                            
0001B4E0 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0001B4E4 D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0001B4E8 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0001B4EA                            
0001B4EA                            
0001B4EA =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0001B4EA                            	rept Mus_Ch				; loop through all music channels
0001B4EA                            		addq.b	#1,.ch.w		; add 1 to duration
0001B4EA                            .ch =		.ch+cSize			; go to next channel
0001B4EA                            	endr
0001B4EA 5238 C4D0                M 	addq.b	#1,.ch.w
0001B4EE =FFFFC4FC                M .ch	=	.ch+csize
0001B4EE 5238 C4FC                M 	addq.b	#1,.ch.w
0001B4F2 =FFFFC528                M .ch	=	.ch+csize
0001B4F2 5238 C528                M 	addq.b	#1,.ch.w
0001B4F6 =FFFFC554                M .ch	=	.ch+csize
0001B4F6 5238 C554                M 	addq.b	#1,.ch.w
0001B4FA =FFFFC580                M .ch	=	.ch+csize
0001B4FA 5238 C580                M 	addq.b	#1,.ch.w
0001B4FE =FFFFC5AC                M .ch	=	.ch+csize
0001B4FE 5238 C5AC                M 	addq.b	#1,.ch.w
0001B502 =FFFFC5D8                M .ch	=	.ch+csize
0001B502 5238 C5D8                M 	addq.b	#1,.ch.w
0001B506 =FFFFC604                M .ch	=	.ch+csize
0001B506 5238 C604                M 	addq.b	#1,.ch.w
0001B50A =FFFFC630                M .ch	=	.ch+csize
0001B50A 5238 C630                M 	addq.b	#1,.ch.w
0001B50E =FFFFC65C                M .ch	=	.ch+csize
0001B50E 5238 C65C                M 	addq.b	#1,.ch.w
0001B512 =FFFFC688                M .ch	=	.ch+csize
0001B512                            ; ===========================================================================
0001B512                            ; ---------------------------------------------------------------------------
0001B512                            ; Process music DAC channels
0001B512                            ; ---------------------------------------------------------------------------
0001B512                            
0001B512                            dAMPSdoAll:
0001B512 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B516 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0001B51A 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0001B51C                            
0001B51C                            dAMPSdoDAC:
0001B51C DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0001B520 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B522 6A00 0000                  		bpl.w	.next			; if not, branch
0001B526 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B52A 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B52E                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0001B52E                          M 	dnotetouthandler
0001B52E 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001B532 6700                     M 	beq.s	.endt
0001B534 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001B538 6600                     M 	bne.s	.endt
0001B53A 7000                     M 	moveq	#0,d0
0001B53C 6000 0000                M 	bra.w	dnoteondac2
0001B540                          M .endt
0001B540                            
0001B540                            	dCalcFreq				; calculate channel base frequency
0001B540 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B544 4886                     M 	ext.w	d6
0001B546 DC6D 000E                M 	add.w	cfreq(a5),d6
0001B54A                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0001B54A 0815 0003                M 	btst	#cfbmod,(a5)
0001B54E 6700                     M 	beq.s	.noret
0001B550 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B554 6700                     M 	beq.s	.started
0001B556 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B55A                          M .noret
0001B55A 0895 0005                M 	bclr	#cfbvol,(a5)
0001B55E 6700                     M 	beq.s	.noupdatevol
0001B560 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B564                          M 	.noupdatevol:
0001B564 51CF FFB6                M 	dbf	d7,dampsdodac
0001B568 6000 0000                M 	bra.w	dampsdofm
0001B56C                          M .started
0001B56C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B570 66E8                     M 	bne.s	.noret
0001B572 226D 0010                M 	movea.l	cmod(a5),a1
0001B576 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B57C 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B580 6600                     M 	bne.s	.norev
0001B582 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B588 442D 0017                M 	neg.b	cmodstep(a5)
0001B58C                          M .norev
0001B58C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B590 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B594 4885                     M 	ext.w	d5
0001B596 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B59A 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B59E DC45                     M 	add.w	d5,d6
0001B5A0 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0001B5A4                            
0001B5A4 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B5A8 6700                       		beq.s	.next			; if not, skip
0001B5AA 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0001B5AE                            
0001B5AE                            .next
0001B5AE 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B5B2 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0001B5B6                            
0001B5B6                            .update
0001B5B6 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B5BA                            	dDoTracker				; process tracker
0001B5BA 286D 0002                M 	movea.l	cdata(a5),a4
0001B5BE                          M .data
0001B5BE 7A00                     M 	moveq	#0,d5
0001B5C0 1A1C                     M 	move.b	(a4)+,d5
0001B5C2 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B5C6 6500                     M 	blo.s	.notcomm
0001B5C8 4EBA 0000                M 	jsr	dcommands(pc)
0001B5CC 60F0                     M 	bra.s	.data
0001B5CE 60DE                     M 	bra.s	.next
0001B5D0                          M .notcomm
0001B5D0 7C00                       		moveq	#0,d6			; clear rest flag
0001B5D2 4A05                       		tst.b	d5			; check if note is being played
0001B5D4 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B5D6                            
0001B5D6                            	dTrackNoteDAC				; calculate frequency or update sample
0001B5D6 0815 0000                M 	btst	#cfbmode,(a5)
0001B5DA 6600                     M 	bne.s	.pitch
0001B5DC 1B45 000B                M 	move.b	d5,csample(a5)
0001B5E0 6000                     M 	bra.s	.cont
0001B5E2                          M .pitch
0001B5E2 0405 0080                M 	subi.b	#$80,d5
0001B5E6 6600                     M 	bne.s	.noprest
0001B5E8 7000                     M 	moveq	#0,d0
0001B5EA 6100 0000                M 	bsr.w	dnoteondac2
0001B5EE 7C80                     M 	moveq	#-$80,d6
0001B5F0 6000                     M 	bra.s	.cont
0001B5F2                          M .noprest
0001B5F2 DA2D 0008                M 	add.b	cpitch(a5),d5
0001B5F6 DA45                     M 	add.w	d5,d5
0001B5F8 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B5FC 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B602                          M .cont
0001B602 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B604 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B606 534C                       		subq.w	#1,a4			; else, undo the increment
0001B608 6000                       		bra.s	.pcnote			; do not calculate duration
0001B60A                            
0001B60A                            .timer
0001B60A 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0001B60E                            .pcnote
0001B60E                            	dProcNote 0, 0				; reset necessary channel memory
0001B60E 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B612 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B618 0815 0002                M 	btst	#cfbhold,(a5)
0001B61C 6600                     M 	bne.s	.endpn
0001B61E 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001B624 0815 0003                M 	btst	#cfbmod,(a5)
0001B628 6700                     M 	beq.s	.endpn
0001B62A 226D 0010                M 	movea.l	cmod(a5),a1
0001B62E 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B632 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B636 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B63A 1011                     M 	move.b	(a1),d0
0001B63C E208                     M 	lsr.b	#1,d0
0001B63E 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B642 426D 0014                M 	clr.w	cmodfreq(a5)
0001B646                          M .endpn
0001B646                            
0001B646 4A06                       		tst.b	d6			; check if channel was resting
0001B648 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B64A 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0001B64C                            
0001B64C 51CF FECE                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B650 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0001B654                            ; ===========================================================================
0001B654                            ; ---------------------------------------------------------------------------
0001B654                            ; Write DAC sample information to Dual PCM
0001B654                            ; ---------------------------------------------------------------------------
0001B654                            
0001B654                            dNoteOnDAC2:
0001B654 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B658 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0001B65A 4E75                       		rts
0001B65C                            
0001B65C                            dNoteOnDAC:
0001B65C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B660 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0001B662                            
0001B662 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B664 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B668 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B66C 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001B670 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0001B674                            
0001B674                            dNoteOnDAC3:
0001B674 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B676 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0001B67A                            
0001B67A 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0001B67E 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B684 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0001B686                            ; ---------------------------------------------------------------------------
0001B686                            ; This code is for updating the note to Dual PCM. We have tracker commands
0001B686                            ; for also playing notes on DAC channels, which is why the code seems a
0001B686                            ; little weird.
0001B686                            ; ---------------------------------------------------------------------------
0001B686                            
0001B686                            dNoteWriteDAC2:
0001B686 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B68C 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0001B692 6000                       		bra.s	dNoteOnDAC4
0001B694                            
0001B694                            dNoteWriteDAC1:
0001B694                            
0001B694 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0001B69A 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0001B6A0                            
0001B6A0                            dNoteOnDAC4:
0001B6A0                            	StopZ80					; wait for Z80 to stop
0001B6A0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B6A8                          M 	waitz80stop
0001B6A8 0839 0000 00A1 1100      M .wait_303:	btst	#0,z80_bus_req
0001B6B0 66F6                     M 	bne.s	.wait_303
0001B6B2                            	rept 12
0001B6B2                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B6B2                            	endr
0001B6B2 12DB                     M 	move.b	(a3)+,(a1)+
0001B6B4 12DB                     M 	move.b	(a3)+,(a1)+
0001B6B6 12DB                     M 	move.b	(a3)+,(a1)+
0001B6B8 12DB                     M 	move.b	(a3)+,(a1)+
0001B6BA 12DB                     M 	move.b	(a3)+,(a1)+
0001B6BC 12DB                     M 	move.b	(a3)+,(a1)+
0001B6BE 12DB                     M 	move.b	(a3)+,(a1)+
0001B6C0 12DB                     M 	move.b	(a3)+,(a1)+
0001B6C2 12DB                     M 	move.b	(a3)+,(a1)+
0001B6C4 12DB                     M 	move.b	(a3)+,(a1)+
0001B6C6 12DB                     M 	move.b	(a3)+,(a1)+
0001B6C8 12DB                     M 	move.b	(a3)+,(a1)+
0001B6CA                            
0001B6CA 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0001B6CE                            	StartZ80				; enable Z80 execution
0001B6CE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B6D6                            
0001B6D6                            locret_dNoteOnDAC4:
0001B6D6 4E75                       		rts
0001B6D8                            ; ===========================================================================
0001B6D8                            ; ---------------------------------------------------------------------------
0001B6D8                            ; Write DAC frequency to Dual PCM
0001B6D8                            ; ---------------------------------------------------------------------------
0001B6D8                            
0001B6D8                            dUpdateFreqOffDAC2:
0001B6D8 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B6DA 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0001B6DE                            
0001B6DE                            dUpdateFreqOffDAC:
0001B6DE 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001B6E2 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0001B6E4                            
0001B6E4 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0001B6E8 4880                       		ext.w	d0			; extend to word
0001B6EA DC40                       		add.w	d0,d6			; add it to d6
0001B6EC                            
0001B6EC 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001B6F0 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0001B6F2 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001B6F6 6000                       		bra.s	dUpdateFreqDAC3
0001B6F8                            
0001B6F8                            dUpdateFreqDAC:
0001B6F8 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B6FC 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0001B6FE                            
0001B6FE                            dUpdateFreqDAC2:
0001B6FE 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B700 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B704 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B708 E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0001B70A DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0001B70E                            
0001B70E                            dUpdateFreqDAC3:
0001B70E                            
0001B70E 1006                       		move.b	d6,d0			; copy the frequency to d0
0001B710 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0001B712 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0001B718 6700                       		beq.s	dFreqDAC1		; if is, branch
0001B71A                            
0001B71A                            	StopZ80					; wait for Z80 to stop
0001B71A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B722                          M 	waitz80stop
0001B722 0839 0000 00A1 1100      M .wait_306:	btst	#0,z80_bus_req
0001B72A 66F6                     M 	bne.s	.wait_306
0001B72C 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0001B732 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0001B738 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B740                            	StartZ80				; enable Z80 execution
0001B740 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B748                            
0001B748                            locret_UpdFreqDAC;
0001B748 4E75                       		rts
0001B74A                            
0001B74A                            dFreqDAC1:
0001B74A                            	StopZ80					; wait for Z80 to stop
0001B74A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B752                          M 	waitz80stop
0001B752 0839 0000 00A1 1100      M .wait_309:	btst	#0,z80_bus_req
0001B75A 66F6                     M 	bne.s	.wait_309
0001B75C 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0001B762 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0001B768 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B770                            	StartZ80				; enable Z80 execution
0001B770 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B778 4E75                       		rts
0001B77A                            ; ===========================================================================
0001B77A                            ; ---------------------------------------------------------------------------
0001B77A                            ; Routine to multiply duration by tick rate
0001B77A                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0001B77A                            ; around the loop will be faster than a single mulu instruction
0001B77A                            ; ---------------------------------------------------------------------------
0001B77A                            
0001B77A                            dCalcDuration:
0001B77A 7000                       		moveq	#0,d0			; clear duration
0001B77C 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0001B77E 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0001B782                            
0001B782 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0001B784 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0001B788                            
0001B788 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0001B78C 4E75                       		rts				; get copied to duration by later code
0001B78E                            ; ===========================================================================
0001B78E                            ; ---------------------------------------------------------------------------
0001B78E                            ; Process SFX DAC channels
0001B78E                            ; ---------------------------------------------------------------------------
0001B78E                            
0001B78E                            dAMPSdoSFX:
0001B78E 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0001B792                            
0001B792                            dAMPSdoDACSFX:
0001B792 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001B796 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B798 6A00                       		bpl.s	.next			; if not, branch
0001B79A                            
0001B79A 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B79E 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B7A2 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B7A6                            
0001B7A6                            	dCalcFreq				; calculate channel base frequency
0001B7A6 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B7AA 4886                     M 	ext.w	d6
0001B7AC DC6D 000E                M 	add.w	cfreq(a5),d6
0001B7B0                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0001B7B0 0815 0003                M 	btst	#cfbmod,(a5)
0001B7B4 6700                     M 	beq.s	.noret
0001B7B6 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B7BA 6700                     M 	beq.s	.started
0001B7BC 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B7C0                          M .noret
0001B7C0 0895 0005                M 	bclr	#cfbvol,(a5)
0001B7C4 6700                     M 	beq.s	.noupdatevol
0001B7C6 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B7CA                          M 	.noupdatevol:
0001B7CA 6000 0000                M 	bra.w	dampsdofmsfx
0001B7CE                          M .started
0001B7CE 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B7D2 66EC                     M 	bne.s	.noret
0001B7D4 226D 0010                M 	movea.l	cmod(a5),a1
0001B7D8 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B7DE 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B7E2 6600                     M 	bne.s	.norev
0001B7E4 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B7EA 442D 0017                M 	neg.b	cmodstep(a5)
0001B7EE                          M .norev
0001B7EE 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B7F2 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B7F6 4885                     M 	ext.w	d5
0001B7F8 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B7FC 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B800 DC45                     M 	add.w	d5,d6
0001B802 6100 FEFA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0001B806                            
0001B806 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B80A 6700                       		beq.s	.next			; if not, skip
0001B80C 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0001B810                            
0001B810                            .next
0001B810 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B814                            
0001B814                            .update
0001B814 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B818                            	dDoTracker				; process tracker
0001B818 286D 0002                M 	movea.l	cdata(a5),a4
0001B81C                          M .data
0001B81C 7A00                     M 	moveq	#0,d5
0001B81E 1A1C                     M 	move.b	(a4)+,d5
0001B820 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B824 6500                     M 	blo.s	.notcomm
0001B826 4EBA 0000                M 	jsr	dcommands(pc)
0001B82A 60F0                     M 	bra.s	.data
0001B82C 60E2                     M 	bra.s	.next
0001B82E                          M .notcomm
0001B82E 7C00                       		moveq	#0,d6			; clear rest flag
0001B830 4A05                       		tst.b	d5			; check if note is being played
0001B832 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B834                            
0001B834                            	dTrackNoteDAC				; calculate frequency or update sample
0001B834 0815 0000                M 	btst	#cfbmode,(a5)
0001B838 6600                     M 	bne.s	.pitch
0001B83A 1B45 000B                M 	move.b	d5,csample(a5)
0001B83E 6000                     M 	bra.s	.cont
0001B840                          M .pitch
0001B840 0405 0080                M 	subi.b	#$80,d5
0001B844 6600                     M 	bne.s	.noprest
0001B846 7000                     M 	moveq	#0,d0
0001B848 6100 FE0A                M 	bsr.w	dnoteondac2
0001B84C 7C80                     M 	moveq	#-$80,d6
0001B84E 6000                     M 	bra.s	.cont
0001B850                          M .noprest
0001B850 DA2D 0008                M 	add.b	cpitch(a5),d5
0001B854 DA45                     M 	add.w	d5,d5
0001B856 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B85A 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B860                          M .cont
0001B860 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B862 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B864 534C                       		subq.w	#1,a4			; else, undo the increment
0001B866 6000                       		bra.s	.pcnote			; do not calculate duration
0001B868                            
0001B868                            .timer
0001B868 4EBA FF10                  		jsr	dCalcDuration(pc)	; calculate duration
0001B86C                            .pcnote
0001B86C                            	dProcNote 1, 0				; reset necessary channel memory
0001B86C 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B870 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B876 0815 0002                M 	btst	#cfbhold,(a5)
0001B87A 6600                     M 	bne.s	.endpn
0001B87C 0815 0003                M 	btst	#cfbmod,(a5)
0001B880 6700                     M 	beq.s	.endpn
0001B882 226D 0010                M 	movea.l	cmod(a5),a1
0001B886 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B88A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B88E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B892 1011                     M 	move.b	(a1),d0
0001B894 E208                     M 	lsr.b	#1,d0
0001B896 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B89A 426D 0014                M 	clr.w	cmodfreq(a5)
0001B89E                          M .endpn
0001B89E 4A06                       		tst.b	d6			; check if channel was resting
0001B8A0 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B8A2 6100 FDB8                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0001B8A6                            
0001B8A6                            .noplay
0001B8A6 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B8AA                            ; ===========================================================================
0001B8AA                            ; ---------------------------------------------------------------------------
0001B8AA                            ; Write DAC volume to Dual PCM
0001B8AA                            ; ---------------------------------------------------------------------------
0001B8AA                            
0001B8AA                            dUpdateVolDAC:
0001B8AA 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B8AE 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0001B8B0                            
0001B8B0                            dUpdateVolDAC2:
0001B8B0 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0001B8B4 D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0001B8B8 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0001B8BA 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0001B8BC                            
0001B8BC                            .gotvol
0001B8BC                            	StopZ80					; wait for Z80 to stop
0001B8BC 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B8C4                          M 	waitz80stop
0001B8C4 0839 0000 00A1 1100      M .wait_317:	btst	#0,z80_bus_req
0001B8CC 66F6                     M 	bne.s	.wait_317
0001B8CE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0001B8D6                            
0001B8D6 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B8DC 6700                       		beq.s	.dac1			; if is, branch
0001B8DE 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0001B8E4                            	StartZ80				; enable Z80 execution
0001B8E4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B8EC 4E75                       		rts
0001B8EE                            
0001B8EE                            .dac1
0001B8EE 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0001B8F4                            	StartZ80				; enable Z80 execution
0001B8F4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B8FC                            
0001B8FC                            locret_VolDAC:
0001B8FC 4E75                       		rts
0001B8FE                            ; ===========================================================================
0001B8FE                            ; ---------------------------------------------------------------------------
0001B8FE                            ; Routine for unpausing the sound driver
0001B8FE                            ; ---------------------------------------------------------------------------
0001B8FE                            
0001B8FE                            dPlaySnd_Unpause:
0001B8FE 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0001B904 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0001B906                            ; ---------------------------------------------------------------------------
0001B906                            ; The following code will reset the panning values for each running
0001B906                            ; channel. It also makes sure that the channel is not interrupted
0001B906                            ; by sound effects, and that each running sound effect channel gets
0001B906                            ; updated. We do not handle key on's, since that could potentially
0001B906                            ; cause issues if notes are half-done. The next time tracker plays
0001B906                            ; notes, they start being audible again.
0001B906                            ; ---------------------------------------------------------------------------
0001B906                            
0001B906 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001B90A 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0001B90C 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0001B90E                            
0001B90E                            .musloop
0001B90E 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B910 6A00                       		bpl.s	.skipmus		; if not, do not update
0001B912 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B916 6600                       		bne.s	.skipmus		; if is, do not update
0001B918                            
0001B918 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B91A 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B91E 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B922                            
0001B922                            .skipmus
0001B922 DAC3                       		adda.w	d3,a5			; go to next channel
0001B924 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0001B928                            
0001B928 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0001B92C 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0001B92E 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0001B930                            
0001B930                            .sfxloop
0001B930 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001B932 6A00                       		bpl.s	.skipsfx		; if not, do not update
0001B934                            
0001B934 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B936 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001B93A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001B93E                            
0001B93E                            .skipsfx
0001B93E DAC3                       		adda.w  d3,a5			; go to next channel
0001B940 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0001B944                            ; ---------------------------------------------------------------------------
0001B944                            ; Since the DAC channels have or based panning behavior, we need this
0001B944                            ; piece of code to update its panning
0001B944                            ; ---------------------------------------------------------------------------
0001B944                            
0001B944 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001B948 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001B94E 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001B950 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001B954                            
0001B954                            .nodacsfx
0001B954 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001B958 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001B95A 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001B95E                            ; ===========================================================================
0001B95E                            ; ---------------------------------------------------------------------------
0001B95E                            ; Routine for pausing the sound driver
0001B95E                            ; ---------------------------------------------------------------------------
0001B95E                            
0001B95E                            dPlaySnd_Pause:
0001B95E 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0001B964 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0001B966                            ; ---------------------------------------------------------------------------
0001B966                            ; The following code will set channel panning to none for all FM channels.
0001B966                            ; This will ensure they are muted while we are pausing.
0001B966                            ; ---------------------------------------------------------------------------
0001B966                            
0001B966 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0001B968 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001B96A 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0001B96C                            
0001B96C                            .muteFM
0001B96C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B970 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001B974 5200                       		addq.b	#1,d0			; go to next FM channel
0001B976 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0001B97A                            ; ---------------------------------------------------------------------------
0001B97A                            ; The following code will key off all FM channels. There is a special
0001B97A                            ; behavior in that, we must write all channels into part 1, and we
0001B97A                            ; control the channel we are writing in the data portion.
0001B97A                            ; 4 bits are reserved for which operators are active (in this case,
0001B97A                            ; none), and 3 bits are reserved for the channel we want to affect.
0001B97A                            ; ---------------------------------------------------------------------------
0001B97A                            
0001B97A 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001B97C 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001B97E                            
0001B97E                            .note
0001B97E 1203                       		move.b	d3,d1			; copy value into d1
0001B980 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001B984 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001B986 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001B98A 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0001B98E                            
0001B98E 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0001B992                            	; continue to mute all DAC channels
0001B992                            ; ===========================================================================
0001B992                            ; ---------------------------------------------------------------------------
0001B992                            ; Routine for muting all DAC channels
0001B992                            ; ---------------------------------------------------------------------------
0001B992                            
0001B992                            dMuteDAC:
0001B992                            	StopZ80					; wait for Z80 to stop
0001B992 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B99A                          M 	waitz80stop
0001B99A 0839 0000 00A1 1100      M .wait_321:	btst	#0,z80_bus_req
0001B9A2 66F6                     M 	bne.s	.wait_321
0001B9A4 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9A8 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0001B9AE                            
0001B9AE                            	rept 12
0001B9AE                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9AE                            	endr
0001B9AE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9B0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9B2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9B4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9B6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9B8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9BA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9BC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9BE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9C6                            
0001B9C6 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B9CE                            
0001B9CE 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001B9D2 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0001B9D8                            
0001B9D8                            	rept 12
0001B9D8                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001B9D8                            	endr
0001B9D8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9DE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9E0 12DA                     M 	move.b	(a2)+,(a1)+
0001B9E2 12DA                     M 	move.b	(a2)+,(a1)+
0001B9E4 12DA                     M 	move.b	(a2)+,(a1)+
0001B9E6 12DA                     M 	move.b	(a2)+,(a1)+
0001B9E8 12DA                     M 	move.b	(a2)+,(a1)+
0001B9EA 12DA                     M 	move.b	(a2)+,(a1)+
0001B9EC 12DA                     M 	move.b	(a2)+,(a1)+
0001B9EE 12DA                     M 	move.b	(a2)+,(a1)+
0001B9F0                            
0001B9F0 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001B9F8                            	StartZ80				; enable Z80 execution
0001B9F8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BA00                            
0001BA00                            locret_MuteDAC:
0001BA00 4E75                       		rts
0001BA02                            ; ===========================================================================
0001BA02                            ; ---------------------------------------------------------------------------
0001BA02                            ; Subroutine to play any queued music tracks, sound effects or commands
0001BA02                            ; ---------------------------------------------------------------------------
0001BA02                            
0001BA02                            dPlaySnd:
0001BA02 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0001BA06 7E00                       		moveq	#0,d7
0001BA08 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA0A 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA0C 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA0E 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BA10 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BA12 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0001BA14                            
0001BA14                            .found
0001BA14 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0001BA18 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0001BA1C 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0001BA20 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0001BA24 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0001BA28                            	; it was music, handle it below
0001BA28                            ; ===========================================================================
0001BA28                            ; ---------------------------------------------------------------------------
0001BA28                            ; Subroutine to play a queued music track
0001BA28                            ; ---------------------------------------------------------------------------
0001BA28                            
0001BA28                            dPlaySnd_Music:
0001BA28 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0001BA2C 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0001BA30                            ; ---------------------------------------------------------------------------
0001BA30                            ; To save few cycles, we don't directly substract the music offset from
0001BA30                            ; the ID, and instead offset the table position. In practice this will
0001BA30                            ; have the same effect, but saves us 8 cycles overall.
0001BA30                            ; ---------------------------------------------------------------------------
0001BA30                            
0001BA30 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0001BA34 DE47                       		add.w	d7,d7			; quadruple music ID
0001BA36 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BA38 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0001BA3E 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0001BA42                            
0001BA42                            
0001BA42 264C                       		move.l	a4,a3			; copy pointer to a3
0001BA44 584C                       		addq.w	#4,a4			; go to DAC1 data section
0001BA46                            
0001BA46 7000                       		moveq	#0,d0
0001BA48 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0001BA4C 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0001BA50 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0001BA56 6700                       		beq.s	.tempogot		; if not, use main tempo
0001BA58 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0001BA5C                            
0001BA5C                            .tempogot
0001BA5C 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0001BA60 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0001BA64 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0001BA6A                            ; ---------------------------------------------------------------------------
0001BA6A                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0001BA6A                            ; disabled. I know, very weird place to put it, but we dont have
0001BA6A                            ; much free room in the song header
0001BA6A                            ; ---------------------------------------------------------------------------
0001BA6A                            
0001BA6A 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0001BA6C 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0001BA6E 0244 007F                  		and.w	#$7F,d4			; keep value in range
0001BA72 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0001BA78                            
0001BA78                            .noPAL
0001BA78 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0001BA7A 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0001BA7C 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0001BA7E 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0001BA80                            
0001BA80 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0001BA84 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0001BA88 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0001BA8A 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0001BA8E                            
0001BA8E                            .loopDAC
0001BA8E 1282                       		move.b	d2,(a1)			; save channel flags
0001BA90 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BA94 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BA98 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BA9C 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAA0 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BAA4 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0001BAA8                            
0001BAA8 7000                       		moveq	#0,d0
0001BAAA 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BAAC D08B                       		add.l	a3,d0			; add music header offset to d0
0001BAAE 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BAB2                            
0001BAB2 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0001BAB6 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0001BABA 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0001BABC 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0001BAC0                            
0001BAC0                            .sampmode
0001BAC0 D2C6                       		add.w	d6,a1			; go to the next channel
0001BAC2 51CF FFCA                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0001BAC6                            
0001BAC6 7E00                       		moveq	#0,d7
0001BAC8 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0001BACA 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0001BACE 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0001BAD0                            
0001BAD0                            .loopFM
0001BAD0 1282                       		move.b	d2,(a1)			; save channel flags
0001BAD2 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BAD6 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BADA 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BADE 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BAE2 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BAE6                            
0001BAE6 7000                       		moveq	#0,d0
0001BAE8 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BAEA D08B                       		add.l	a3,d0			; add music header offset to d0
0001BAEC 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BAF0                            
0001BAF0 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BAF4 D2C6                       		adda.w	d6,a1			; go to the next channel
0001BAF6 51CF FFD8                  		dbf	d7,.loopFM		; repeat for all FM channels
0001BAFA                            
0001BAFA                            .doPSG
0001BAFA 7E00                       		moveq	#0,d7
0001BAFC 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0001BB00 6B00                       		bmi.s	.intSFX			; if no PSG channels are loaded, branch
0001BB02                            ; ---------------------------------------------------------------------------
0001BB02                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BB02                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BB02                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BB02                            ; is controlled by the 68000, we would be off by a single frame without
0001BB02                            ; this fix.
0001BB02                            ; ---------------------------------------------------------------------------
0001BB02                            
0001BB02 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0001BB04 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0001BB08 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0001BB0C                            
0001BB0C                            .loopPSG
0001BB0C 1282                       		move.b	d2,(a1)			; save channel flags
0001BB0E 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BB12 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BB16 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BB1A 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BB1E                            
0001BB1E 7000                       		moveq	#0,d0
0001BB20 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BB22 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BB24 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BB28                            
0001BB28 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BB2C 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0001BB30 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0001BB34 D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB36 51CF FFD4                  		dbf	d7,.loopPSG		; repeat for all FM channels
0001BB3A                            
0001BB3A                            .intSFX
0001BB3A                            ; ---------------------------------------------------------------------------
0001BB3A                            ; Now follows initializing FM6 to be ready for PCM streaming,
0001BB3A                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0001BB3A                            ; clears some YM registers.
0001BB3A                            ; ---------------------------------------------------------------------------
0001BB3A                            
0001BB3A 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BB3C 7206                       		moveq	#6,d1			; FM6, all operators off
0001BB3E 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BB42                            
0001BB42 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BB44 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0001BB46 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB4A 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0001BB4C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB50 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0001BB52 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB56 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0001BB58 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB5C                            
0001BB5C 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BB5E 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001BB60 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BB64                            
0001BB64 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0001BB68 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0001BB6C                            ; ---------------------------------------------------------------------------
0001BB6C                            ; This piece of code here handles SFX overriding our newly loaded
0001BB6C                            ; music channels. Since we did not do this at the initialization
0001BB6C                            ; step, we will handle it here instead.
0001BB6C                            ; ---------------------------------------------------------------------------
0001BB6C                            
0001BB6C 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0001BB70 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0001BB74 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0001BB76 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BB78                            
0001BB78                            .loopSFX
0001BB78 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0001BB7A 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0001BB7C                            
0001BB7C 7000                       		moveq	#0,d0
0001BB7E 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0001BB82 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0001BB84                            
0001BB84 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0001BB88 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0001BB8A D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0001BB8C 6000                       		bra.s	.override
0001BB8E                            ; ---------------------------------------------------------------------------
0001BB8E                            
0001BB8E                            .SFXPSG
0001BB8E E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0001BB90                            .override
0001BB90 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0001BB94 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0001BB98                            
0001BB98                            .nextSFX
0001BB98 D2C6                       		adda.w	d6,a1			; go to the next channel
0001BB9A 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0001BB9E                            ; ---------------------------------------------------------------------------
0001BB9E                            ; Here we mute all non-interrupted FM and PSG channels
0001BB9E                            ; ---------------------------------------------------------------------------
0001BB9E                            
0001BB9E 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001BBA2 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0001BBA4                            .stopFM
0001BBA4 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0001BBA8 DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBAA 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0001BBAE                            
0001BBAE 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0001BBB0                            .mutePSG
0001BBB0 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0001BBB4 DAC6                       		adda.w	d6,a5			; go to the next channel
0001BBB6 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0001BBBA 4E75                       		rts
0001BBBC                            
0001BBBC                            ; ===========================================================================
0001BBBC                            ; ---------------------------------------------------------------------------
0001BBBC                            ; Type values for different channels. Used for playing music
0001BBBC                            ; ---------------------------------------------------------------------------
0001BBBC 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0001BBBE 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0001BBC3 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0001BBC6                            		even
0001BBC6                            ; ===========================================================================
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            ; Subroutine to play a queued sound effect
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            
0001BBC6                            dPlaySnd_SFX:
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            ; This is a little special case with Sonic 1 - 3K, where the ring
0001BBC6                            ; sound effect would change panning each time it is played. AMPS
0001BBC6                            ; emulates this behavior like the original drivers did, by
0001BBC6                            ; playing a different sound effect ID.
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            
0001BBC6                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0001BBC6                            		;bne.s	.noring			; if not, skip
0001BBC6                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0001BBC6                            		;beq.s	.noring			; if was not, do not change sound effect
0001BBC6                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            ; To save few cycles, we don't directly substract the SFX offset from
0001BBC6                            ; the ID, and instead offset the table position. In practice this will
0001BBC6                            ; have the same effect, but saves us 8 cycles overall.
0001BBC6                            ; ---------------------------------------------------------------------------
0001BBC6                            
0001BBC6                            .noring
0001BBC6 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0001BBCA 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0001BBCC DE47                       		add.w	d7,d7			; quadruple sfx ID
0001BBCE DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BBD0 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0001BBD4                            
0001BBD4                            ; ---------------------------------------------------------------------------
0001BBD4                            ; Continous SFX is a very special type of sound effect. Unlike other
0001BBD4                            ; sound effects, when a continous SFX is played, it will run a loop
0001BBD4                            ; again, until it is no longer queued. This is very useful for sound
0001BBD4                            ; effects that need to be queued very often, but that really do not
0001BBD4                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0001BBD4                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0001BBD4                            ; but the code was not quite as matured as this here. Only one continous
0001BBD4                            ; SFX may be running at once, when other type is loaded, the earlier one
0001BBD4                            ; is stopped and replaced.
0001BBD4                            ; ---------------------------------------------------------------------------
0001BBD4                            
0001BBD4 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0001BBD8 6A00                       		bpl.s	.nocont			; if not, skip
0001BBDA 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0001BBE0 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0001BBE4 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0001BBE6 4E75                       		rts
0001BBE8                            
0001BBE8                            .setcont
0001BBE8 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0001BBEC                            .nocont
0001BBEC 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0001BBEE                            
0001BBEE 7E00                       		moveq	#0,d7
0001BBF0 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0001BBF4 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0001BBF8 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0001BBFA 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0001BBFC 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BBFE                            ; ---------------------------------------------------------------------------
0001BBFE                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BBFE                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BBFE                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BBFE                            ; is controlled by the 68000, we would be off by a single frame without
0001BBFE                            ; this fix.
0001BBFE                            ; ---------------------------------------------------------------------------
0001BBFE                            
0001BBFE                            .loopSFX
0001BBFE 7600                       		moveq	#0,d3
0001BC00 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0001BC02 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0001BC06 1803                       		move.b	d3,d4			; copy type to d4
0001BC08 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0001BC0A                            
0001BC0A 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001BC0E 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001BC10 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001BC12                            
0001BC12 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC16 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC1A 6500                       		blo.s	.skip			; if not, we can not override it
0001BC1C                            
0001BC1C 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC20 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC24 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0001BC26 6000                       		bra.s	.clearCh
0001BC28                            ; ---------------------------------------------------------------------------
0001BC28                            
0001BC28                            .skip
0001BC28 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0001BC2A 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BC2E 4E75                       		rts
0001BC30                            ; ---------------------------------------------------------------------------
0001BC30                            
0001BC30                            .chPSG
0001BC30 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0001BC32 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BC36 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BC3A 65EC                       		blo.s	.skip			; if not, we can not override it
0001BC3C                            
0001BC3C 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BC40 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BC44 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0001BC48 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0001BC4E                            
0001BC4E 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0001BC52 6600                       		bne.s	.clearCh		; if not, skip
0001BC54 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0001BC5C                            
0001BC5C                            .clearCh
0001BC5C 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0001BC5E 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0001BC60                            .clear
0001BC60 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0001BC62 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0001BC66                            
0001BC66                            
0001BC66 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0001BC68 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0001BC6C 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0001BC70                            
0001BC70 7000                       		moveq	#0,d0
0001BC72 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0001BC74 D08C                       		add.l	a4,d0			; add music header offset to d0
0001BC76 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0001BC7A                            
0001BC7A 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0001BC7E 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0001BC80 6B00                       		bmi.s	.loop			; if is, skip over this
0001BC82                            
0001BC82 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BC84 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0001BC88 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BC8A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0001BC8E                            
0001BC8E BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0001BC92 6600                       		bne.s	.fm			; if not, branch
0001BC94 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0001BC9A                            
0001BC9A                            .loop
0001BC9A 51CF FF62                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BC9E 4E75                       		rts
0001BCA0                            ; ---------------------------------------------------------------------------
0001BCA0                            ; The instant release for FM channels behavior was not in the Sonic 1
0001BCA0                            ; SMPS driver by default, but it has been added since it fixes an
0001BCA0                            ; issue with YM2612, where sometimes subsequent sound effect activations
0001BCA0                            ; would sound different over time. This fix will help to mitigate that.
0001BCA0                            ; ---------------------------------------------------------------------------
0001BCA0                            
0001BCA0                            .fm
0001BCA0 720F                       		moveq	#$F,d1			; set to release note instantly
0001BCA2 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0001BCA4 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCA8 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0001BCAA 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCAE 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0001BCB0 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCB4 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0001BCB6 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BCBA                            
0001BCBA 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BCBC 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0001BCC0 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0001BCC4                            
0001BCC4 51CF FF38                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BCC8 4E75                       		rts
0001BCCA                            ; ===========================================================================
0001BCCA                            ; ---------------------------------------------------------------------------
0001BCCA                            ; pointers for music channels SFX can override and addresses of SFX channels
0001BCCA                            ; ---------------------------------------------------------------------------
0001BCCA                            
0001BCCA C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0001BCCC C67C                       		dc.w mSFXDAC1			; DAC1
0001BCCE C6B4                       		dc.w mSFXFM4			; FM4
0001BCD0 C6D0                       		dc.w mSFXFM5			; FM5
0001BCD2 C6EC                       		dc.w mSFXPSG1			; PSG1
0001BCD4 C708                       		dc.w mSFXPSG2			; PSG2
0001BCD6 C724                       		dc.w mSFXPSG3			; PSG3
0001BCD8 C724                       		dc.w mSFXPSG3			; PSG4
0001BCDA                            
0001BCDA C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0001BCDC C4C4                       		dc.w mDAC1			; SFX DAC1
0001BCDE C5A0                       		dc.w mFM4			; SFX FM4
0001BCE0 C5CC                       		dc.w mFM5			; SFX FM5
0001BCE2 C5F8                       		dc.w mPSG1			; SFX PSG1
0001BCE4 C624                       		dc.w mPSG2			; SFX PSG2
0001BCE6 C650                       		dc.w mPSG3			; SFX PSG3
0001BCE8 C650                       		dc.w mPSG3			; SFX PSG4
0001BCEA                            ; ===========================================================================
0001BCEA                            ; ---------------------------------------------------------------------------
0001BCEA                            ; Play queued command
0001BCEA                            ; ---------------------------------------------------------------------------
0001BCEA                            
0001BCEA                            dPlaySnd_Comm:
0001BCEA                            
0001BCEA DE47                       		add.w	d7,d7			; quadruple ID
0001BCEC DE47                       		add.w	d7,d7			; because each entry is 1 long word
0001BCEE 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0001BCF2                            
0001BCF2                            ; ---------------------------------------------------------------------------
0001BCF2                            dSoundCommands:
0001BCF2 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0001BCF6 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0001BCFA 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0001BCFE 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0001BD02 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0001BD06 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0001BD0A 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0001BD0E 6000 FC4E                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0001BD12 6000 FBEA                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0001BD16                            dSoundCommands_End:
0001BD16                            ; ===========================================================================
0001BD16                            ; ---------------------------------------------------------------------------
0001BD16                            ; Commands for what to do after a volume fade
0001BD16                            ; ---------------------------------------------------------------------------
0001BD16                            
0001BD16                            dFadeCommands:
0001BD16 4E75                       		rts				; 80 - Do nothing
0001BD18 4E75                       		rts
0001BD1A 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0001BD1C 4E75                       		rts
0001BD1E 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0001BD22 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0001BD24 60F4                       		bra.s	.stop
0001BD26                            ; ===========================================================================
0001BD26                            ; ---------------------------------------------------------------------------
0001BD26                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0001BD26                            ; ---------------------------------------------------------------------------
0001BD26                            
0001BD26                            dPlaySnd_Stop:
0001BD26                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0001BD26                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0001BD26                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD26                            
0001BD26 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0001BD28 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0001BD2A 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BD2E                            
0001BD2E 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0001BD32                            
0001BD32                            	rept (mSize-mSFXDAC1)/4
0001BD32                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0001BD32                            	endr
0001BD32 4299                     M 	clr.l	(a1)+
0001BD34 4299                     M 	clr.l	(a1)+
0001BD36 4299                     M 	clr.l	(a1)+
0001BD38 4299                     M 	clr.l	(a1)+
0001BD3A 4299                     M 	clr.l	(a1)+
0001BD3C 4299                     M 	clr.l	(a1)+
0001BD3E 4299                     M 	clr.l	(a1)+
0001BD40 4299                     M 	clr.l	(a1)+
0001BD42 4299                     M 	clr.l	(a1)+
0001BD44 4299                     M 	clr.l	(a1)+
0001BD46 4299                     M 	clr.l	(a1)+
0001BD48 4299                     M 	clr.l	(a1)+
0001BD4A 4299                     M 	clr.l	(a1)+
0001BD4C 4299                     M 	clr.l	(a1)+
0001BD4E 4299                     M 	clr.l	(a1)+
0001BD50 4299                     M 	clr.l	(a1)+
0001BD52 4299                     M 	clr.l	(a1)+
0001BD54 4299                     M 	clr.l	(a1)+
0001BD56 4299                     M 	clr.l	(a1)+
0001BD58 4299                     M 	clr.l	(a1)+
0001BD5A 4299                     M 	clr.l	(a1)+
0001BD5C 4299                     M 	clr.l	(a1)+
0001BD5E 4299                     M 	clr.l	(a1)+
0001BD60 4299                     M 	clr.l	(a1)+
0001BD62 4299                     M 	clr.l	(a1)+
0001BD64 4299                     M 	clr.l	(a1)+
0001BD66 4299                     M 	clr.l	(a1)+
0001BD68 4299                     M 	clr.l	(a1)+
0001BD6A 4299                     M 	clr.l	(a1)+
0001BD6C 4299                     M 	clr.l	(a1)+
0001BD6E 4299                     M 	clr.l	(a1)+
0001BD70 4299                     M 	clr.l	(a1)+
0001BD72 4299                     M 	clr.l	(a1)+
0001BD74 4299                     M 	clr.l	(a1)+
0001BD76 4299                     M 	clr.l	(a1)+
0001BD78 4299                     M 	clr.l	(a1)+
0001BD7A 4299                     M 	clr.l	(a1)+
0001BD7C 4299                     M 	clr.l	(a1)+
0001BD7E 4299                     M 	clr.l	(a1)+
0001BD80 4299                     M 	clr.l	(a1)+
0001BD82 4299                     M 	clr.l	(a1)+
0001BD84 4299                     M 	clr.l	(a1)+
0001BD86 4299                     M 	clr.l	(a1)+
0001BD88 4299                     M 	clr.l	(a1)+
0001BD8A 4299                     M 	clr.l	(a1)+
0001BD8C 4299                     M 	clr.l	(a1)+
0001BD8E 4299                     M 	clr.l	(a1)+
0001BD90 4299                     M 	clr.l	(a1)+
0001BD92 4299                     M 	clr.l	(a1)+
0001BD94                            
0001BD94                            	; continue straight to stopping music
0001BD94                            ; ===========================================================================
0001BD94                            ; ---------------------------------------------------------------------------
0001BD94                            ; Stop music from playing, reset driver memory and mute hardware
0001BD94                            ; ---------------------------------------------------------------------------
0001BD94                            
0001BD94                            dStopMusic:
0001BD94 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0001BD98 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0001BD9A 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0001BD9E 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0001BDA2 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0001BDA8                            
0001BDA8                            	rept (mSFXDAC1-mFlags)/4
0001BDA8                            		clr.l	(a1)+			; clear driver and music channel memory
0001BDA8                            	endr
0001BDA8 4299                     M 	clr.l	(a1)+
0001BDAA 4299                     M 	clr.l	(a1)+
0001BDAC 4299                     M 	clr.l	(a1)+
0001BDAE 4299                     M 	clr.l	(a1)+
0001BDB0 4299                     M 	clr.l	(a1)+
0001BDB2 4299                     M 	clr.l	(a1)+
0001BDB4 4299                     M 	clr.l	(a1)+
0001BDB6 4299                     M 	clr.l	(a1)+
0001BDB8 4299                     M 	clr.l	(a1)+
0001BDBA 4299                     M 	clr.l	(a1)+
0001BDBC 4299                     M 	clr.l	(a1)+
0001BDBE 4299                     M 	clr.l	(a1)+
0001BDC0 4299                     M 	clr.l	(a1)+
0001BDC2 4299                     M 	clr.l	(a1)+
0001BDC4 4299                     M 	clr.l	(a1)+
0001BDC6 4299                     M 	clr.l	(a1)+
0001BDC8 4299                     M 	clr.l	(a1)+
0001BDCA 4299                     M 	clr.l	(a1)+
0001BDCC 4299                     M 	clr.l	(a1)+
0001BDCE 4299                     M 	clr.l	(a1)+
0001BDD0 4299                     M 	clr.l	(a1)+
0001BDD2 4299                     M 	clr.l	(a1)+
0001BDD4 4299                     M 	clr.l	(a1)+
0001BDD6 4299                     M 	clr.l	(a1)+
0001BDD8 4299                     M 	clr.l	(a1)+
0001BDDA 4299                     M 	clr.l	(a1)+
0001BDDC 4299                     M 	clr.l	(a1)+
0001BDDE 4299                     M 	clr.l	(a1)+
0001BDE0 4299                     M 	clr.l	(a1)+
0001BDE2 4299                     M 	clr.l	(a1)+
0001BDE4 4299                     M 	clr.l	(a1)+
0001BDE6 4299                     M 	clr.l	(a1)+
0001BDE8 4299                     M 	clr.l	(a1)+
0001BDEA 4299                     M 	clr.l	(a1)+
0001BDEC 4299                     M 	clr.l	(a1)+
0001BDEE 4299                     M 	clr.l	(a1)+
0001BDF0 4299                     M 	clr.l	(a1)+
0001BDF2 4299                     M 	clr.l	(a1)+
0001BDF4 4299                     M 	clr.l	(a1)+
0001BDF6 4299                     M 	clr.l	(a1)+
0001BDF8 4299                     M 	clr.l	(a1)+
0001BDFA 4299                     M 	clr.l	(a1)+
0001BDFC 4299                     M 	clr.l	(a1)+
0001BDFE 4299                     M 	clr.l	(a1)+
0001BE00 4299                     M 	clr.l	(a1)+
0001BE02 4299                     M 	clr.l	(a1)+
0001BE04 4299                     M 	clr.l	(a1)+
0001BE06 4299                     M 	clr.l	(a1)+
0001BE08 4299                     M 	clr.l	(a1)+
0001BE0A 4299                     M 	clr.l	(a1)+
0001BE0C 4299                     M 	clr.l	(a1)+
0001BE0E 4299                     M 	clr.l	(a1)+
0001BE10 4299                     M 	clr.l	(a1)+
0001BE12 4299                     M 	clr.l	(a1)+
0001BE14 4299                     M 	clr.l	(a1)+
0001BE16 4299                     M 	clr.l	(a1)+
0001BE18 4299                     M 	clr.l	(a1)+
0001BE1A 4299                     M 	clr.l	(a1)+
0001BE1C 4299                     M 	clr.l	(a1)+
0001BE1E 4299                     M 	clr.l	(a1)+
0001BE20 4299                     M 	clr.l	(a1)+
0001BE22 4299                     M 	clr.l	(a1)+
0001BE24 4299                     M 	clr.l	(a1)+
0001BE26 4299                     M 	clr.l	(a1)+
0001BE28 4299                     M 	clr.l	(a1)+
0001BE2A 4299                     M 	clr.l	(a1)+
0001BE2C 4299                     M 	clr.l	(a1)+
0001BE2E 4299                     M 	clr.l	(a1)+
0001BE30 4299                     M 	clr.l	(a1)+
0001BE32 4299                     M 	clr.l	(a1)+
0001BE34 4299                     M 	clr.l	(a1)+
0001BE36 4299                     M 	clr.l	(a1)+
0001BE38 4299                     M 	clr.l	(a1)+
0001BE3A 4299                     M 	clr.l	(a1)+
0001BE3C 4299                     M 	clr.l	(a1)+
0001BE3E 4299                     M 	clr.l	(a1)+
0001BE40 4299                     M 	clr.l	(a1)+
0001BE42 4299                     M 	clr.l	(a1)+
0001BE44 4299                     M 	clr.l	(a1)+
0001BE46 4299                     M 	clr.l	(a1)+
0001BE48 4299                     M 	clr.l	(a1)+
0001BE4A 4299                     M 	clr.l	(a1)+
0001BE4C 4299                     M 	clr.l	(a1)+
0001BE4E 4299                     M 	clr.l	(a1)+
0001BE50 4299                     M 	clr.l	(a1)+
0001BE52 4299                     M 	clr.l	(a1)+
0001BE54 4299                     M 	clr.l	(a1)+
0001BE56 4299                     M 	clr.l	(a1)+
0001BE58 4299                     M 	clr.l	(a1)+
0001BE5A 4299                     M 	clr.l	(a1)+
0001BE5C 4299                     M 	clr.l	(a1)+
0001BE5E 4299                     M 	clr.l	(a1)+
0001BE60 4299                     M 	clr.l	(a1)+
0001BE62 4299                     M 	clr.l	(a1)+
0001BE64 4299                     M 	clr.l	(a1)+
0001BE66 4299                     M 	clr.l	(a1)+
0001BE68 4299                     M 	clr.l	(a1)+
0001BE6A 4299                     M 	clr.l	(a1)+
0001BE6C 4299                     M 	clr.l	(a1)+
0001BE6E 4299                     M 	clr.l	(a1)+
0001BE70 4299                     M 	clr.l	(a1)+
0001BE72 4299                     M 	clr.l	(a1)+
0001BE74 4299                     M 	clr.l	(a1)+
0001BE76 4299                     M 	clr.l	(a1)+
0001BE78 4299                     M 	clr.l	(a1)+
0001BE7A 4299                     M 	clr.l	(a1)+
0001BE7C 4299                     M 	clr.l	(a1)+
0001BE7E 4299                     M 	clr.l	(a1)+
0001BE80 4299                     M 	clr.l	(a1)+
0001BE82 4299                     M 	clr.l	(a1)+
0001BE84 4299                     M 	clr.l	(a1)+
0001BE86 4299                     M 	clr.l	(a1)+
0001BE88 4299                     M 	clr.l	(a1)+
0001BE8A 4299                     M 	clr.l	(a1)+
0001BE8C 4299                     M 	clr.l	(a1)+
0001BE8E 4299                     M 	clr.l	(a1)+
0001BE90 4299                     M 	clr.l	(a1)+
0001BE92                            
0001BE92 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0001BE94                            
0001BE94 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0001BE98 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0001BE9C 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0001BEA0 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0001BEA6                            
0001BEA6 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0001BEA8 4EBA FAE8                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0001BEAC                            	; continue straight to hardware muting FM
0001BEAC                            ; ===========================================================================
0001BEAC                            ; ---------------------------------------------------------------------------
0001BEAC                            ; Mute all FM channels
0001BEAC                            ; ---------------------------------------------------------------------------
0001BEAC                            
0001BEAC                            dMuteFM:
0001BEAC 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BEAE 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001BEB0                            
0001BEB0                            .noteoff
0001BEB0 1203                       		move.b	d3,d1			; copy value into d1
0001BEB2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BEB6 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001BEB8 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BEBC 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0001BEC0                            
0001BEC0 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0001BEC2 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BEC4 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0001BEC6                            
0001BEC6                            .chloop
0001BEC6 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0001BEC8 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0001BECA                            
0001BECA                            .oploop
0001BECA 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BECE 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BED2 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0001BED4 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0001BED8                            
0001BED8 9005                       		sub.b	d5,d0			; go to next FM channel
0001BEDA 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0001BEDE 4E75                       		rts
0001BEE0                            ; ===========================================================================
0001BEE0                            ; ---------------------------------------------------------------------------
0001BEE0                            ; Routine for muting all PSG channels
0001BEE0                            ; ---------------------------------------------------------------------------
0001BEE0                            
0001BEE0                            dMutePSG:
0001BEE0 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0001BEE6 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0001BEEA 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0001BEEE 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0001BEF2 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0001BEF6 4E75                       		rts
0001BEF8                            ; ===========================================================================
0001BEF8                            ; ---------------------------------------------------------------------------
0001BEF8                            ; Normal fade out data
0001BEF8                            ; ---------------------------------------------------------------------------
0001BEF8                            
0001BEF8                            dFadeOutDataLog:
0001BEF8 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0001BF04 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0001BF10 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0001BF1C 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0001BF28 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0001BF34 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0001BF40 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0001BF4C 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0001BF58 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0001BF62                            
0001BF62                            ;dFadeOutDataLinear:
0001BF62                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0001BF62                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0001BF62                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0001BF62                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0001BF62                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0001BF62                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0001BF62                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0001BF62                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0001BF62                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0001BF62                            	even
0001BF62                            ; ===========================================================================
0001BF62                            ; ---------------------------------------------------------------------------
0001BF62                            ; Subroutine for initializing a fade effect.
0001BF62                            ; Since the driver allows for such an extensive and customizable
0001BF62                            ; fading code, we may hit a snag if we use fades too fast. It is
0001BF62                            ; possible, for example, to fade out, then in the middle of that,
0001BF62                            ; start fading in. This would normally cause a quick jump in the
0001BF62                            ; volume level from maybe half to completely mute. This routine
0001BF62                            ; aims to combat this by actually searching for the closest FM
0001BF62                            ; volume level in the fade program, and to start the new fade from
0001BF62                            ; where that byte appears. This can alter how long a volume fade
0001BF62                            ; lasts however, and if PSG and DAC volume are not correct faded,
0001BF62                            ; it may still cause a jump in their volume (especially if only,
0001BF62                            ; say, DAC fades volume). In the future, there might be a fix for
0001BF62                            ; that.
0001BF62                            ; ---------------------------------------------------------------------------
0001BF62                            
0001BF62                            dPlaySnd_FadeOut:
0001BF62 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0001BF66                            
0001BF66                            dLoadFade:
0001BF66 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0001BF6A 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001BF6E 6700                       		beq.s	.nofade			; if not, load fade as is
0001BF70                            
0001BF70 2449                       		move.l	a1,a2			; copy fade program address to a2
0001BF72 74FF                       		moveq	#-1,d2			; prepare max byter difference
0001BF74                            
0001BF74                            .find
0001BF74 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0001BF76 6A00                       		bpl.s	.search			; branch if this is not a command
0001BF78                            
0001BF78                            .nofade
0001BF78 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0001BF7C 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0001BF80 4E75                       		rts
0001BF82                            
0001BF82                            .search
0001BF82 568A                       		addq.l	#3,a2			; skip over the current volume group
0001BF84 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0001BF86 6A00                       		bpl.s	.abs			; if positive, do not negate
0001BF88 4401                       		neg.b	d1			; negative to positive
0001BF8A                            
0001BF8A                            .abs
0001BF8A B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0001BF8C 64E6                       		bhs.s	.find			; if not, read next group
0001BF8E                            
0001BF8E 1401                       		move.b	d1,d2			; else save the new difference
0001BF90 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0001BF92 60E0                       		bra.s	.find			; loop through each group in the program
0001BF94                            ; ===========================================================================
0001BF94                            ; ---------------------------------------------------------------------------
0001BF94                            ; Routine for loading a volume filter into Dual PCM ROM.
0001BF94                            ; This routine will actually write the bank number the volume filter
0001BF94                            ; is in. This requires volume filters are aligned to Z80 banks, and
0001BF94                            ; just because we can, we write 9 bits (yeah its not necessary, but
0001BF94                            ; what the hell, you have to have fun sometimes!)
0001BF94                            ; ---------------------------------------------------------------------------
0001BF94                            
0001BF94                            dSetFilter:
0001BF94 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0001BF9A 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0001BF9C 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0001BF9E                            	StopZ80					; wait for Z80 to stop
0001BF9E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001BFA6                          M 	waitz80stop
0001BFA6 0839 0000 00A1 1100      M .wait_324:	btst	#0,z80_bus_req
0001BFAE 66F6                     M 	bne.s	.wait_324
0001BFB0                            ; ---------------------------------------------------------------------------
0001BFB0                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0001BFB0                            ; a register AND the carry to another register. What this means, is if
0001BFB0                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0001BFB0                            ; of $74 into the carry, making us able to switch between the Z80
0001BFB0                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0001BFB0                            ; Dual PCM to bank switch into the appropriate bank.
0001BFB0                            ; ---------------------------------------------------------------------------
0001BFB0                            
0001BFB0                            .loop
0001BFB0 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0001BFB2 E248                       		lsr.w	#1,d0			; shift lsb into carry
0001BFB4 D701                       		addx.b	d1,d3			; add instruction and carry into d3
0001BFB6                            
0001BFB6 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0001BFB8 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0001BFBC                            	StartZ80				; enable Z80 execution
0001BFBC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BFC4 4E75                       		rts
0001BFC6                            
0001BFC6                            ; ===========================================================================
0001BFC6                            ; ---------------------------------------------------------------------------
0001BFC6                            ; Routine for resetting master volumes, filters and disabling fading
0001BFC6                            ; ---------------------------------------------------------------------------
0001BFC6                            
0001BFC6                            dResetVolume:
0001BFC6 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0001BFCA 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0001BFCE 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0001BFD2 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0001BFD6 61BC                       		bsr.s	dSetFilter		; load filter instructions
0001BFD8                            
0001BFD8                            dUpdateVolumeAll:
0001BFD8 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0001BFDA 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0001BFDE                            
0001BFDE =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001BFDE                            	rept Mus_DAC				; loop through all music DAC channels
0001BFDE                            		or.b	d0,.ch.w		; request channel volume update
0001BFDE                            .ch =		.ch+cSize			; go to next channel
0001BFDE                            	endr
0001BFDE 8138 C4C4                M 	or.b	d0,.ch.w
0001BFE2 =FFFFC4F0                M .ch	=	.ch+csize
0001BFE2 8138 C4F0                M 	or.b	d0,.ch.w
0001BFE6 =FFFFC51C                M .ch	=	.ch+csize
0001BFE6                            
0001BFE6 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001BFE6                            	rept Mus_PSG				; loop through all music PSG channels
0001BFE6                            		or.b	d0,.ch.w		; request channel volume update
0001BFE6                            .ch =		.ch+cSize			; go to next channel
0001BFE6                            	endr
0001BFE6 8138 C5F8                M 	or.b	d0,.ch.w
0001BFEA =FFFFC624                M .ch	=	.ch+csize
0001BFEA 8138 C624                M 	or.b	d0,.ch.w
0001BFEE =FFFFC650                M .ch	=	.ch+csize
0001BFEE 8138 C650                M 	or.b	d0,.ch.w
0001BFF2 =FFFFC67C                M .ch	=	.ch+csize
0001BFF2                            
0001BFF2 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001BFF2                            	rept SFX_PSG				; loop through all SFX PSG channels
0001BFF2                            		or.b	d0,.ch.w		; request channel volume update
0001BFF2                            .ch =		.ch+cSizeSFX			; go to next channel
0001BFF2                            	endr
0001BFF2 8138 C6EC                M 	or.b	d0,.ch.w
0001BFF6 =FFFFC708                M .ch	=	.ch+csizesfx
0001BFF6 8138 C708                M 	or.b	d0,.ch.w
0001BFFA =FFFFC724                M .ch	=	.ch+csizesfx
0001BFFA 8138 C724                M 	or.b	d0,.ch.w
0001BFFE =FFFFC740                M .ch	=	.ch+csizesfx
0001BFFE 4E75                       		rts
0001C000                            ; ===========================================================================
0001C000                            ; ---------------------------------------------------------------------------
0001C000                            ; Enable speed shoes mode
0001C000                            ; ---------------------------------------------------------------------------
0001C000                            
0001C000                            dPlaySnd_ShoesOn:
0001C000 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0001C006 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0001C00C 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0001C012 4E75                       		rts
0001C014                            ; ===========================================================================
0001C014                            ; ---------------------------------------------------------------------------
0001C014                            ; Reset music flags (underwater mode and tempo mode)
0001C014                            ; ---------------------------------------------------------------------------
0001C014                            
0001C014                            dPlaySnd_Reset:
0001C014 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0001C016                            ; ===========================================================================
0001C016                            ; ---------------------------------------------------------------------------
0001C016                            ; Disable speed shoes mode
0001C016                            ; ---------------------------------------------------------------------------
0001C016                            
0001C016                            dPlaySnd_ShoesOff:
0001C016 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0001C01C 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0001C022 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0001C028 4E75                       		rts
0001C02A                            ; ===========================================================================
0001C02A                            ; ---------------------------------------------------------------------------
0001C02A                            ; Enable Underwater mode
0001C02A                            ; ---------------------------------------------------------------------------
0001C02A                            
0001C02A                            dPlaySnd_ToWater:
0001C02A 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0001C030 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0001C032                            ; ===========================================================================
0001C032                            ; ---------------------------------------------------------------------------
0001C032                            ; Disable Underwater mode
0001C032                            ; ---------------------------------------------------------------------------
0001C032                            
0001C032                            dPlaySnd_OutWater:
0001C032 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0001C038                            ; ===========================================================================
0001C038                            ; ---------------------------------------------------------------------------
0001C038                            ; force volume update on all FM channels
0001C038                            ; ---------------------------------------------------------------------------
0001C038                            
0001C038                            dReqVolUpFM;
0001C038 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0001C03A =FFFFC51C                  .ch =	mFM1					; start at FM1
0001C03A                            	rept Mus_FM				; loop through all music FM channels
0001C03A                            		or.b	d0,.ch.w		; request channel volume update
0001C03A                            .ch =		.ch+cSize			; go to next channel
0001C03A                            	endr
0001C03A 8138 C51C                M 	or.b	d0,.ch.w
0001C03E =FFFFC548                M .ch	=	.ch+csize
0001C03E 8138 C548                M 	or.b	d0,.ch.w
0001C042 =FFFFC574                M .ch	=	.ch+csize
0001C042 8138 C574                M 	or.b	d0,.ch.w
0001C046 =FFFFC5A0                M .ch	=	.ch+csize
0001C046 8138 C5A0                M 	or.b	d0,.ch.w
0001C04A =FFFFC5CC                M .ch	=	.ch+csize
0001C04A 8138 C5CC                M 	or.b	d0,.ch.w
0001C04E =FFFFC5F8                M .ch	=	.ch+csize
0001C04E                            
0001C04E =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0001C04E                            	rept SFX_FM				; loop through all SFX FM channels
0001C04E                            		or.b	d0,.ch.w		; request channel volume update
0001C04E                            .ch =		.ch+cSizeSFX			; go to next channel
0001C04E                            	endr
0001C04E 8138 C698                M 	or.b	d0,.ch.w
0001C052 =FFFFC6B4                M .ch	=	.ch+csizesfx
0001C052 8138 C6B4                M 	or.b	d0,.ch.w
0001C056 =FFFFC6D0                M .ch	=	.ch+csizesfx
0001C056 8138 C6D0                M 	or.b	d0,.ch.w
0001C05A =FFFFC6EC                M .ch	=	.ch+csizesfx
0001C05A 4E75                       		rts
0001C05C                            ; ===========================================================================
0001C05C                            ; ---------------------------------------------------------------------------
0001C05C                            ; Subroutine for updating Total Levels for FM channel
0001C05C                            ; ---------------------------------------------------------------------------
0001C05C                            
0001C05C                            dUpdateVolFM:
0001C05C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C060 6600                       		bne.s	locret_VolFM		; if yes, do not update
0001C062                            
0001C062 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001C066 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001C06A 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001C06C 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001C06E                            
0001C06E                            .noover
0001C06E 7000                       		moveq	#0,d0
0001C070 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001C074 224E                       		move.l	a6,a1			; copy music voice table address to a1
0001C076                            
0001C076                            	dCALC_VOICE				; get address of the specific voice to a1
0001C076 EB48                     M 	lsl.w	#5,d0
0001C078 D2C0                     M 	add.w	d0,a1
0001C07A 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0001C07C 7C00                       		moveq	#0,d6			; reset the modulator offset
0001C07E                            
0001C07E 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001C084 6700                       		beq.s	.uwdone			; if not, skip
0001C086 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0001C088 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001C08C D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001C08E 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0001C090                            
0001C090                            .uwdone
0001C090 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001C092 D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0001C096 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0001C09A                            
0001C09A                            .tlloop
0001C09A 101A                       		move.b	(a2)+,d0		; load YM address to write to
0001C09C 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001C09E 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001C0A0                            
0001C0A0 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001C0A2 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001C0A4 727F                       		moveq	#$7F,d1			; cap to silent volume
0001C0A6 6000                       		bra.s	.slot
0001C0A8                            
0001C0A8                            .noslot
0001C0A8 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001C0AA                            .slot
0001C0AA 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0001C0AE                            .ignore
0001C0AE 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001C0B2                            
0001C0B2                            
0001C0B2                            locret_VolFM:
0001C0B2 4E75                       		rts
0001C0B4                            ; ===========================================================================
0001C0B4                            ; ---------------------------------------------------------------------------
0001C0B4                            ; YM2612 register update list
0001C0B4                            ; ---------------------------------------------------------------------------
0001C0B4                            
0001C0B4 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0001C0B8 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0001C0BC 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0001C0C0 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0001C0C4 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0001C0C8 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0001C0CC 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0001C0D0                            ; ===========================================================================
0001C0D0                            ; ---------------------------------------------------------------------------
0001C0D0                            ; Process SFX FM channels
0001C0D0                            ; ---------------------------------------------------------------------------
0001C0D0                            
0001C0D0                            dAMPSdoFMSFX:
0001C0D0 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0001C0D4 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0001C0D6                            
0001C0D6                            dAMPSnextFMSFX:
0001C0D6 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C0DA 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C0DC 6A00 0000                  		bpl.w	.next			; if not, branch
0001C0E0 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C0E4 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C0E8                            
0001C0E8                            	dCalcFreq				; calculate channel base frequency
0001C0E8 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C0EC 4886                     M 	ext.w	d6
0001C0EE DC6D 000E                M 	add.w	cfreq(a5),d6
0001C0F2                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0001C0F2 0815 0003                M 	btst	#cfbmod,(a5)
0001C0F6 6700                     M 	beq.s	.noret
0001C0F8 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C0FC 6700                     M 	beq.s	.started
0001C0FE 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C102                          M .noret
0001C102 0895 0005                M 	bclr	#cfbvol,(a5)
0001C106 6700                     M 	beq.s	.noupdatevol
0001C108 4EBA FF52                M 	jsr	dupdatevolfm(pc)
0001C10C                          M 	.noupdatevol:
0001C10C 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0001C110 6000 0000                M 	bra.w	dampsdopsgsfx
0001C114                          M .started
0001C114 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C118 66E8                     M 	bne.s	.noret
0001C11A 226D 0010                M 	movea.l	cmod(a5),a1
0001C11E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C124 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C128 6600                     M 	bne.s	.norev
0001C12A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C130 442D 0017                M 	neg.b	cmodstep(a5)
0001C134                          M .norev
0001C134 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C138 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C13C 4885                     M 	ext.w	d5
0001C13E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C142 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C146 DC45                     M 	add.w	d5,d6
0001C148 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0001C14C                            
0001C14C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C150 6700                       		beq.s	.next			; if not, skip
0001C152 4EBA FF08                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C156                            
0001C156                            .next
0001C156 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C15A 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C15E                            
0001C15E                            .update
0001C15E 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C162                            	dDoTracker				; process tracker
0001C162 286D 0002                M 	movea.l	cdata(a5),a4
0001C166                          M .data
0001C166 7A00                     M 	moveq	#0,d5
0001C168 1A1C                     M 	move.b	(a4)+,d5
0001C16A 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C16E 6500                     M 	blo.s	.notcomm
0001C170 4EBA 0000                M 	jsr	dcommands(pc)
0001C174 60F0                     M 	bra.s	.data
0001C176 60DE                     M 	bra.s	.next
0001C178                          M .notcomm
0001C178 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0001C17C 4A05                       		tst.b	d5			; check if note is being played
0001C17E 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C180                            
0001C180 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C184 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C186 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C188 534C                       		subq.w	#1,a4			; if not, then return back
0001C18A 6000                       		bra.s	.pcnote			; do some extra clearing
0001C18C                            
0001C18C                            .timer
0001C18C 4EBA F5EC                  		jsr	dCalcDuration(pc)	; calculate duration
0001C190                            .pcnote
0001C190                            	dProcNote 1, 0				; reset necessary channel memory
0001C190 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C194 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C19A 0815 0002                M 	btst	#cfbhold,(a5)
0001C19E 6600                     M 	bne.s	.endpn
0001C1A0 0815 0003                M 	btst	#cfbmod,(a5)
0001C1A4 6700                     M 	beq.s	.endpn
0001C1A6 226D 0010                M 	movea.l	cmod(a5),a1
0001C1AA 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C1AE 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C1B2 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C1B6 1011                     M 	move.b	(a1),d0
0001C1B8 E208                     M 	lsr.b	#1,d0
0001C1BA 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C1BE 426D 0014                M 	clr.w	cmodfreq(a5)
0001C1C2                          M .endpn
0001C1C2 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0001C1C6                            	dKeyOnFM 1				; send key-on command to YM
0001C1C6 0815 0002                M 	btst	#cfbhold,(a5)
0001C1CA 6600                     M 	bne.s	.k
0001C1CC 0815 0000                M 	btst	#cfbrest,(a5)
0001C1D0 6600                     M 	bne.s	.k
0001C1D2 7028                     M 	moveq	#$28,d0
0001C1D4 122D 0001                M 	move.b	ctype(a5),d1
0001C1D8 0001 00F0                M 	ori.b	#$f0,d1
0001C1DC 6100 0000                M 	bsr.w	writeym_pt1
0001C1E0                          M .k
0001C1E0                            
0001C1E0 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C1E4 6700                       		beq.s	.noupdate		; if not, branch
0001C1E6 4EBA FE74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C1EA                            
0001C1EA 51CF FEEA                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C1EE 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C1F2                            ; ===========================================================================
0001C1F2                            ; ---------------------------------------------------------------------------
0001C1F2                            ; Process music FM channels
0001C1F2                            ; ---------------------------------------------------------------------------
0001C1F2                            
0001C1F2                            dAMPSdoFM:
0001C1F2 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0001C1F6 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0001C1F8                            
0001C1F8                            dAMPSnextFM:
0001C1F8 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0001C1FC 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C1FE 6A00 0000                  		bpl.w	.next			; if not, branch
0001C202 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C206 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C20A                            
0001C20A                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0001C20A                          M 	dnotetouthandler
0001C20A 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C20E 6700                     M 	beq.s	.endt
0001C210 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C214 6600                     M 	bne.s	.endt
0001C216 08D5 0000                M 	bset	#cfbrest,(a5)
0001C21A 6100 0000                M 	bsr.w	dkeyofffm
0001C21E 6000 0000                M 	bra.w	.next
0001C222                          M .endt
0001C222                            	dCalcFreq				; calculate channel base frequency
0001C222 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C226 4886                     M 	ext.w	d6
0001C228 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C22C                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0001C22C 0815 0003                M 	btst	#cfbmod,(a5)
0001C230 6700                     M 	beq.s	.noret
0001C232 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C236 6700                     M 	beq.s	.started
0001C238 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C23C                          M .noret
0001C23C 0895 0005                M 	bclr	#cfbvol,(a5)
0001C240 6700                     M 	beq.s	.noupdatevol
0001C242 4EBA FE18                M 	jsr	dupdatevolfm(pc)
0001C246                          M 	.noupdatevol:
0001C246 51CF FFB0                M 	dbf	d7,dampsnextfm
0001C24A 6000 0000                M 	bra.w	dampsdopsg
0001C24E                          M .started
0001C24E 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C252 66E8                     M 	bne.s	.noret
0001C254 226D 0010                M 	movea.l	cmod(a5),a1
0001C258 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C25E 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C262 6600                     M 	bne.s	.norev
0001C264 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C26A 442D 0017                M 	neg.b	cmodstep(a5)
0001C26E                          M .norev
0001C26E 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C272 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C276 4885                     M 	ext.w	d5
0001C278 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C27C 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C280 DC45                     M 	add.w	d5,d6
0001C282 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0001C286                            
0001C286 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C28A 6700                       		beq.s	.next			; if not, skip
0001C28C 4EBA FDCE                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C290                            
0001C290                            .next
0001C290 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C294 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C298                            
0001C298                            .update
0001C298 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C29C                            	dDoTracker				; process tracker
0001C29C 286D 0002                M 	movea.l	cdata(a5),a4
0001C2A0                          M .data
0001C2A0 7A00                     M 	moveq	#0,d5
0001C2A2 1A1C                     M 	move.b	(a4)+,d5
0001C2A4 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C2A8 6500                     M 	blo.s	.notcomm
0001C2AA 4EBA 0000                M 	jsr	dcommands(pc)
0001C2AE 60F0                     M 	bra.s	.data
0001C2B0 60DE                     M 	bra.s	.next
0001C2B2                          M .notcomm
0001C2B2 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001C2B6 4A05                       		tst.b	d5			; check if note is being played
0001C2B8 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C2BA                            
0001C2BA 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C2BE 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C2C0 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C2C2 534C                       		subq.w	#1,a4			; if not, then return back
0001C2C4 6000                       		bra.s	.pcnote			; do some extra clearing
0001C2C6                            
0001C2C6                            .timer
0001C2C6 4EBA F4B2                  		jsr	dCalcDuration(pc)	; calculate duration
0001C2CA                            .pcnote
0001C2CA                            	dProcNote 0, 0				; reset necessary channel memory
0001C2CA 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C2CE 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C2D4 0815 0002                M 	btst	#cfbhold,(a5)
0001C2D8 6600                     M 	bne.s	.endpn
0001C2DA 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C2E0 0815 0003                M 	btst	#cfbmod,(a5)
0001C2E4 6700                     M 	beq.s	.endpn
0001C2E6 226D 0010                M 	movea.l	cmod(a5),a1
0001C2EA 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C2EE 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C2F2 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C2F6 1011                     M 	move.b	(a1),d0
0001C2F8 E208                     M 	lsr.b	#1,d0
0001C2FA 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C2FE 426D 0014                M 	clr.w	cmodfreq(a5)
0001C302                          M .endpn
0001C302 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0001C304                            	dKeyOnFM				; send key-on command to YM
0001C304 0815 0002                M 	btst	#cfbhold,(a5)
0001C308 6600                     M 	bne.s	.k
0001C30A 0815 0000                M 	btst	#cfbrest,(a5)
0001C30E 6600                     M 	bne.s	.k
0001C310 0815 0001                M 	btst	#cfbint,(a5)
0001C314 6600                     M 	bne.s	.k
0001C316 7028                     M 	moveq	#$28,d0
0001C318 122D 0001                M 	move.b	ctype(a5),d1
0001C31C 0001 00F0                M 	ori.b	#$f0,d1
0001C320 6100 0000                M 	bsr.w	writeym_pt1
0001C324                          M .k
0001C324                            
0001C324 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C328 6700                       		beq.s	.noupdate		; if not, branch
0001C32A 4EBA FD30                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C32E                            
0001C32E                            .noupdate
0001C32E 51CF FEC8                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C332 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C336                            ; ===========================================================================
0001C336                            ; ---------------------------------------------------------------------------
0001C336                            ; Write FM frequency to Dual PCM YMCue
0001C336                            ; ---------------------------------------------------------------------------
0001C336                            
0001C336                            dUpdateFreqFM:
0001C336 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C33A 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0001C33C 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0001C340 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0001C342                            
0001C342 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C346 4880                       		ext.w	d0			; extend to word
0001C348 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C34A                            
0001C34A 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C34E 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0001C350 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0001C354                            
0001C354                            dUpdateFreqFM2:
0001C354 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C358 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0001C35A                            
0001C35A                            dUpdateFreqFM3:
0001C35A 3206                       		move.w	d6,d1			; copy frequency to d1
0001C35C E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0001C35E 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0001C360 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001C364                            
0001C364 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0001C366 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0001C36A 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001C36E                            
0001C36E                            dUpdFreqFMrest:
0001C36E 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C372                            
0001C372                            locret_UpdFreqFM:
0001C372 4E75                       		rts
0001C374                            ; ===========================================================================
0001C374                            ; ---------------------------------------------------------------------------
0001C374                            ; Process a note in FM channel (enable resting or get frequency)
0001C374                            ; ---------------------------------------------------------------------------
0001C374                            
0001C374                            dGetFreqFM:
0001C374 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001C378 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0001C37A 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C37E 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0001C382 4E75                       		rts
0001C384                            
0001C384                            .norest
0001C384 DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0001C388 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0001C38C DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0001C38E                            
0001C38E 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0001C392 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001C398                            
0001C398 4E75                       		rts
0001C39A                            ; ===========================================================================
0001C39A                            ; ---------------------------------------------------------------------------
0001C39A                            ; Subroutine for doing keying-off FM channel
0001C39A                            ; ---------------------------------------------------------------------------
0001C39A                            
0001C39A                            dKeyOffFM:
0001C39A 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0001C39E 66D2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3A0                            
0001C3A0                            dKeyOffFM2:
0001C3A0 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001C3A4 66CC                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C3A6                            
0001C3A6 7028                       		moveq	#$28,d0			; YM command: Key on
0001C3A8 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0001C3AC 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0001C3AE                            ; ===========================================================================
0001C3AE                            ; ---------------------------------------------------------------------------
0001C3AE                            ; Write to YMCue according to channel and check if interrupted by sfx
0001C3AE                            ; ---------------------------------------------------------------------------
0001C3AE                            
0001C3AE                            dWriteYMchnInt:
0001C3AE 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0001C3B2 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0001C3B4                            ; ===========================================================================
0001C3B4                            ; ---------------------------------------------------------------------------
0001C3B4                            ; Write to YMCue according to channel
0001C3B4                            ; ---------------------------------------------------------------------------
0001C3B4                            
0001C3B4                            WriteChYM:
0001C3B4 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0001C3BA 6600                       		bne.s	WriteChYM2		; if part 2, branch
0001C3BC D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0001C3C0                            ; ===========================================================================
0001C3C0                            ; ---------------------------------------------------------------------------
0001C3C0                            ; Write to YMCue using part 1
0001C3C0                            ; ---------------------------------------------------------------------------
0001C3C0                            
0001C3C0                            WriteYM_Pt1:
0001C3C0                            	StopZ80					; wait for Z80 to stop
0001C3C0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C3C8                          M 	waitz80stop
0001C3C8 0839 0000 00A1 1100      M .wait_340:	btst	#0,z80_bus_req
0001C3D0 66F6                     M 	bne.s	.wait_340
0001C3D2 51D8                       		sf	(a0)+			; set YM port address as 0
0001C3D4 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C3D6 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C3D8                            	;	st	(a0)			; mark as the end of the cue data
0001C3D8                            	StartZ80				; enable Z80 execution
0001C3D8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C3E0                            
0001C3E0                            WriteYM_Pt1_rts:
0001C3E0 4E75                       		rts
0001C3E2                            ; ===========================================================================
0001C3E2                            ; ---------------------------------------------------------------------------
0001C3E2                            ; Write to YMCue according to channel in part 2
0001C3E2                            ; ---------------------------------------------------------------------------
0001C3E2                            
0001C3E2                            WriteChYM2:
0001C3E2 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0001C3E6 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0001C3EA D002                       		add.b	d2,d0			; add to YM address
0001C3EC                            ; ===========================================================================
0001C3EC                            ; ---------------------------------------------------------------------------
0001C3EC                            ; Write to YMCue using part 2
0001C3EC                            ; ---------------------------------------------------------------------------
0001C3EC                            
0001C3EC                            WriteYM_Pt2:
0001C3EC                            	StopZ80					; wait for Z80 to stop
0001C3EC 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C3F4                          M 	waitz80stop
0001C3F4 0839 0000 00A1 1100      M .wait_343:	btst	#0,z80_bus_req
0001C3FC 66F6                     M 	bne.s	.wait_343
0001C3FE 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0001C402 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C404 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C406                            	;	st	(a0)			; mark as the end of the cue data
0001C406                            	StartZ80				; enable Z80 execution
0001C406 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C40E 4E75                       		rts
0001C410                            ; ===========================================================================
0001C410                            ; ---------------------------------------------------------------------------
0001C410                            ; Note to FM frequency conversion table
0001C410                            ; ---------------------------------------------------------------------------
0001C410                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C410 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0001C412 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0001C42A 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0001C442 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0001C45A 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0001C472 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0001C48A 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0001C4A2 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0001C4BA 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0001C4D0                            dFreqFM_:
0001C4D0                            ; ===========================================================================
0001C4D0                            ; ---------------------------------------------------------------------------
0001C4D0                            ; Note to Dual PCM frequency conversion table
0001C4D0                            ; ---------------------------------------------------------------------------
0001C4D0                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C4D0 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0001C4D2 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0001C4EA 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0001C502 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0001C51A 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0001C532 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0001C54A 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0001C562 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0001C57A 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0001C592 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0001C5AA 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0001C5C2 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0001C5D0                            
0001C5D0 F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0001C5E0 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0001C5F8 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0001C610 F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0001C628 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0001C640 FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0001C658 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0001C670 FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0001C688 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0001C6A0 FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0001C6B8 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0001C6D0                            ; ===========================================================================
0001C6D0                            ; ---------------------------------------------------------------------------
0001C6D0                            ; Note to PSG frequency conversion table
0001C6D0                            ; ---------------------------------------------------------------------------
0001C6D0                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C6D0 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0001C6E8 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0001C700 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0001C718 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0001C730 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0001C748 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0001C75A 0000                       	dc.w  $0000								     ; Note (C6)
0001C75C                            dFreqPSG_:
0001C75C                            ; ===========================================================================
0001C75C                            ; ---------------------------------------------------------------------------
0001C75C                            ; Process SFX PSG channels
0001C75C                            ; ---------------------------------------------------------------------------
0001C75C                            
0001C75C                            dAMPSdoPSGSFX:
0001C75C 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0001C75E 4DFA FF70                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C762                            
0001C762                            dAMPSnextPSGSFX:
0001C762 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C766 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C768 6A00                       		bpl.s	.next			; if not, branch
0001C76A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C76E 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C772                            
0001C772                            	dCalcFreq				; calculate channel base frequency
0001C772 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C776 4886                     M 	ext.w	d6
0001C778 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C77C                            	dModulate				; run modulation code
0001C77C 0815 0003                M 	btst	#cfbmod,(a5)
0001C780 6700                     M 	beq.s	.noret
0001C782 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C786 6700                     M 	beq.s	.started
0001C788 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C78C                          M .noret
0001C78C 6000                     M 	bra.s	.endm
0001C78E                          M .started
0001C78E 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C792 66F8                     M 	bne.s	.noret
0001C794 226D 0010                M 	movea.l	cmod(a5),a1
0001C798 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C79E 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C7A2 6600                     M 	bne.s	.norev
0001C7A4 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C7AA 442D 0017                M 	neg.b	cmodstep(a5)
0001C7AE                          M .norev
0001C7AE 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C7B2 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C7B6 4885                     M 	ext.w	d5
0001C7B8 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C7BC 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C7C0 DC45                     M 	add.w	d5,d6
0001C7C2 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0001C7C6                            
0001C7C6                            .endm
0001C7C6 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C7CA                            .next
0001C7CA 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C7CE 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0001C7D2                            
0001C7D2                            .update
0001C7D2 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C7D6                            	dDoTracker				; process tracker
0001C7D6 286D 0002                M 	movea.l	cdata(a5),a4
0001C7DA                          M .data
0001C7DA 7A00                     M 	moveq	#0,d5
0001C7DC 1A1C                     M 	move.b	(a4)+,d5
0001C7DE 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C7E2 6500                     M 	blo.s	.notcomm
0001C7E4 4EBA 0000                M 	jsr	dcommands(pc)
0001C7E8 60F0                     M 	bra.s	.data
0001C7EA 60DE                     M 	bra.s	.next
0001C7EC                          M .notcomm
0001C7EC 4A05                       		tst.b	d5			; check if note is being played
0001C7EE 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C7F0                            
0001C7F0                            	dGetFreqPSG				; get PSG frequency
0001C7F0 0405 0081                M 	subi.b	#$81,d5
0001C7F4 6400                     M 	bhs.s	.norest
0001C7F6 08D5 0000                M 	bset	#cfbrest,(a5)
0001C7FA 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C800 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C804 6000                     M 	bra.s	.freqgot
0001C806                          M .norest
0001C806 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C80A 0245 007F                M 	andi.w	#$7f,d5
0001C80E DA45                     M 	add.w	d5,d5
0001C810 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C816                          M .freqgot
0001C816 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C818 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C81A 534C                       		subq.w	#1,a4			; else, undo the increment
0001C81C 6000                       		bra.s	.pcnote			; do not calculate duration
0001C81E                            
0001C81E                            .timer
0001C81E 4EBA EF5A                  		jsr	dCalcDuration(pc)	; calculate duration
0001C822                            .pcnote
0001C822                            	dProcNote 1, 1				; reset necessary channel memory
0001C822 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C826 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C82C 0815 0002                M 	btst	#cfbhold,(a5)
0001C830 6600                     M 	bne.s	.endpn
0001C832 422D 0006                M 	clr.b	cenvpos(a5)
0001C836 0815 0003                M 	btst	#cfbmod,(a5)
0001C83A 6700                     M 	beq.s	.endpn
0001C83C 226D 0010                M 	movea.l	cmod(a5),a1
0001C840 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C844 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C848 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C84C 1011                     M 	move.b	(a1),d0
0001C84E E208                     M 	lsr.b	#1,d0
0001C850 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C854 426D 0014                M 	clr.w	cmodfreq(a5)
0001C858                          M .endpn
0001C858                            
0001C858 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0001C85C 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C860 51CF FF00                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C864                            	; continue to check tracker and end loop
0001C864                            ; ===========================================================================
0001C864                            ; ---------------------------------------------------------------------------
0001C864                            ; End channel loop and check if tracker debugger should be opened
0001C864                            ; ---------------------------------------------------------------------------
0001C864                            
0001C864                            dCheckTracker:
0001C864                            .rts
0001C864 4E75                       		rts
0001C866                            ; ===========================================================================
0001C866                            ; ---------------------------------------------------------------------------
0001C866                            ; Music PSG channel loop
0001C866                            ; ---------------------------------------------------------------------------
0001C866                            
0001C866                            dAMPSdoPSG:
0001C866 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0001C868 4DFA FE66                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C86C                            
0001C86C                            dAMPSnextPSG:
0001C86C DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0001C870 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C872 6A00 0000                  		bpl.w	.next			; if not, branch
0001C876 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C87A 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C87E                            
0001C87E                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0001C87E                          M 	dnotetouthandler
0001C87E 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C882 6700                     M 	beq.s	.endt
0001C884 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C888 6600                     M 	bne.s	.endt
0001C88A 08D5 0000                M 	bset	#cfbrest,(a5)
0001C88E 6100 0000                M 	bsr.w	dmutepsgmus
0001C892 6000                     M 	bra.s	.next
0001C894                          M .endt
0001C894                            	dCalcFreq				; calculate channel base frequency
0001C894 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C898 4886                     M 	ext.w	d6
0001C89A DC6D 000E                M 	add.w	cfreq(a5),d6
0001C89E                            	dModulate				; run modulation code
0001C89E 0815 0003                M 	btst	#cfbmod,(a5)
0001C8A2 6700                     M 	beq.s	.noret
0001C8A4 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C8A8 6700                     M 	beq.s	.started
0001C8AA 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C8AE                          M .noret
0001C8AE 6000                     M 	bra.s	.endm
0001C8B0                          M .started
0001C8B0 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C8B4 66F8                     M 	bne.s	.noret
0001C8B6 226D 0010                M 	movea.l	cmod(a5),a1
0001C8BA 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C8C0 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C8C4 6600                     M 	bne.s	.norev
0001C8C6 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C8CC 442D 0017                M 	neg.b	cmodstep(a5)
0001C8D0                          M .norev
0001C8D0 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C8D4 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C8D8 4885                     M 	ext.w	d5
0001C8DA DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C8DE 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C8E2 DC45                     M 	add.w	d5,d6
0001C8E4 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0001C8E8                            
0001C8E8                            .endm
0001C8E8 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C8EC                            .next
0001C8EC 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C8F0 4EFA EEA0                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C8F4                            
0001C8F4                            .update
0001C8F4 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C8F8                            	dDoTracker				; process tracker
0001C8F8 286D 0002                M 	movea.l	cdata(a5),a4
0001C8FC                          M .data
0001C8FC 7A00                     M 	moveq	#0,d5
0001C8FE 1A1C                     M 	move.b	(a4)+,d5
0001C900 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C904 6500                     M 	blo.s	.notcomm
0001C906 4EBA 0000                M 	jsr	dcommands(pc)
0001C90A 60F0                     M 	bra.s	.data
0001C90C 60DE                     M 	bra.s	.next
0001C90E                          M .notcomm
0001C90E 4A05                       		tst.b	d5			; check if note is being played
0001C910 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C912                            
0001C912                            	dGetFreqPSG				; get PSG frequency
0001C912 0405 0081                M 	subi.b	#$81,d5
0001C916 6400                     M 	bhs.s	.norest
0001C918 08D5 0000                M 	bset	#cfbrest,(a5)
0001C91C 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C922 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C926 6000                     M 	bra.s	.freqgot
0001C928                          M .norest
0001C928 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C92C 0245 007F                M 	andi.w	#$7f,d5
0001C930 DA45                     M 	add.w	d5,d5
0001C932 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C938                          M .freqgot
0001C938 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C93A 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C93C 534C                       		subq.w	#1,a4			; else, undo the increment
0001C93E 6000                       		bra.s	.pcnote			; do not calculate duration
0001C940                            
0001C940                            .timer
0001C940 4EBA EE38                  		jsr	dCalcDuration(pc)	; calculate duration
0001C944                            .pcnote
0001C944                            	dProcNote 0, 1				; reset necessary channel memory
0001C944 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C948 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C94E 0815 0002                M 	btst	#cfbhold,(a5)
0001C952 6600                     M 	bne.s	.endpn
0001C954 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C95A 422D 0006                M 	clr.b	cenvpos(a5)
0001C95E 0815 0003                M 	btst	#cfbmod,(a5)
0001C962 6700                     M 	beq.s	.endpn
0001C964 226D 0010                M 	movea.l	cmod(a5),a1
0001C968 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C96C 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C970 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C974 1011                     M 	move.b	(a1),d0
0001C976 E208                     M 	lsr.b	#1,d0
0001C978 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C97C 426D 0014                M 	clr.w	cmodfreq(a5)
0001C980                          M .endpn
0001C980                            
0001C980 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0001C982 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C986 51CF FEE4                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C98A 4EFA EE06                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C98E                            ; ===========================================================================
0001C98E                            ; ---------------------------------------------------------------------------
0001C98E                            ; Write PSG frequency to hardware
0001C98E                            ; ---------------------------------------------------------------------------
0001C98E                            
0001C98E                            dUpdateFreqPSG:
0001C98E 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001C992 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0001C994 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C998 4E75                       		rts
0001C99A                            
0001C99A                            .detune
0001C99A 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C99E 4880                       		ext.w	d0			; extend to word
0001C9A0 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C9A2                            
0001C9A2 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C9A6 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001C9A8 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001C9AC                            
0001C9AC                            dUpdateFreqPSG2:
0001C9AC 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001C9B0 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9B2                            
0001C9B2                            dUpdateFreqPSG3:
0001C9B2 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C9B6 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001C9B8                            
0001C9B8 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0001C9BC 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0001C9C0 6600                       		bne.s	.notPSG4		; if not, branch
0001C9C2 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001C9C4                            
0001C9C4                            .notPSG4
0001C9C4 3206                       		move.w	d6,d1			; copy frequency to d1
0001C9C6 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001C9CA 8001                       		or.b	d1,d0			; combine with channel type
0001C9CC                            ; ---------------------------------------------------------------------------
0001C9CC                            ; Note about the and instruction below: If this instruction is
0001C9CC                            ; not commented out, the instashield SFX will not sound correct.
0001C9CC                            ; This instruction was removed in Sonic 3K because of this, but
0001C9CC                            ; this can cause issues when values overflow the valid range of
0001C9CC                            ; PSG frequency. This may cause erroneous behavior if not anded,
0001C9CC                            ; but will also make the instashield SFX not sound correctly.
0001C9CC                            ; Comment out the instruction with caution, if you are planning
0001C9CC                            ; to port said sound effect to this driver. This has not caused
0001C9CC                            ; any issues for me, and if you are careful you can avoid any
0001C9CC                            ; such case, but beware of this issue!
0001C9CC                            ; ---------------------------------------------------------------------------
0001C9CC                            
0001C9CC E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0001C9CE 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001C9D2 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001C9D8 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0001C9DE                            
0001C9DE                            locret_dUpdateFreqPSG:
0001C9DE 4E75                       		rts
0001C9E0                            ; ===========================================================================
0001C9E0                            ; ---------------------------------------------------------------------------
0001C9E0                            ; Routine for running envelope programs
0001C9E0                            ; ---------------------------------------------------------------------------
0001C9E0                            
0001C9E0                            dEnvProgPSG:
0001C9E0 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001C9E4 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001C9E8                            
0001C9E8 7800                       		moveq	#0,d4
0001C9EA 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001C9EE 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0001C9F0 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001C9F2                            
0001C9F2                            dEnvelopePSG:
0001C9F2 7800                       		moveq	#0,d4
0001C9F4 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001C9F8 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001C9FA                            
0001C9FA 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001C9FE DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CA02                            
0001CA02                            dEnvProgPSG2:
0001CA02                            
0001CA02 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0001CA06 D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001CA08 D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001CA0A 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0001CA0E                            
0001CA0E 7200                       		moveq	#0,d1
0001CA10 7000                       		moveq	#0,d0
0001CA12                            
0001CA12                            dEnvProgPSG3:
0001CA12 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0001CA16 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001CA1A 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001CA1C                            
0001CA1C 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0001CA20 DA00                       		add.b	d0,d5			; add envelope volume to d5
0001CA22                            	; continue to update PSG volume
0001CA22                            ; ===========================================================================
0001CA22                            ; ---------------------------------------------------------------------------
0001CA22                            ; Routine for updating PSG volume to hardware
0001CA22                            ; ---------------------------------------------------------------------------
0001CA22                            
0001CA22                            dUpdateVolPSG2:
0001CA22 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0001CA26 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001CA28 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001CA2A                            
0001CA2A                            dUpdateVolPSG:
0001CA2A 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001CA2E 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA30 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001CA34 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CA36                            
0001CA36 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001CA3A 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA3C BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0001CA40 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0001CA42                            
0001CA42 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0001CA46 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CA48 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001CA4C 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0001CA4E                            
0001CA4E                            dUpdVolPSGset:
0001CA4E 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0001CA52 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0001CA56 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001CA5C                            
0001CA5C                            locret_UpdVolPSG:
0001CA5C 4E75                       		rts
0001CA5E                            ; ===========================================================================
0001CA5E                            ; ---------------------------------------------------------------------------
0001CA5E                            ; Subroutine for handling volume envelope commands
0001CA5E                            ; ---------------------------------------------------------------------------
0001CA5E                            
0001CA5E                            dEnvCommand:
0001CA5E                            
0001CA5E 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001CA62                            
0001CA62                            .comm
0001CA62 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001CA64 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001CA66 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001CA68                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001CA68                            ; ---------------------------------------------------------------------------
0001CA68                            
0001CA68                            .stop
0001CA68 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0001CA6C 6000                       		bra.s	dMutePSGmus		; nute the channel
0001CA6E                            ; ---------------------------------------------------------------------------
0001CA6E                            
0001CA6E                            .hold
0001CA6E 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001CA72 4EFA FF9E                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001CA76                            ; ---------------------------------------------------------------------------
0001CA76                            
0001CA76                            .reset
0001CA76 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0001CA7A 4EFA FF96                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CA7E                            ; ---------------------------------------------------------------------------
0001CA7E                            
0001CA7E                            .loop
0001CA7E 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001CA84 4EFA FF8C                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CA88                            ; ===========================================================================
0001CA88                            ; ---------------------------------------------------------------------------
0001CA88                            ; Routine for hardware muting a PSG channel
0001CA88                            ; ---------------------------------------------------------------------------
0001CA88                            
0001CA88                            dMutePSGmus:
0001CA88 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0001CA8C 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0001CA8E                            
0001CA8E                            dMutePSGsfx:
0001CA8E 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001CA90 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001CA94 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0001CA9A                            
0001CA9A                            locret_MutePSG:
0001CA9A 4E75                       		rts
0001CA9C                            
0001CA9C 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001CAA4                            ; ===========================================================================
0001CAA4                            ; ---------------------------------------------------------------------------
0001CAA4                            ; Routine to execute tracker commands
0001CAA4                            ;
0001CAA4                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001CAA4                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001CAA4                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001CAA4                            ; but it may be helpful with speed anyway.
0001CAA4                            ; ---------------------------------------------------------------------------
0001CAA4                            
0001CAA4                            dCommands:
0001CAA4 DA05                       		add.b	d5,d5			; quadruple command ID
0001CAA6 DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001CAA8                            
0001CAA8 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0001CAAC 6600 0000                  		bne.w	.falsecomm		; branch if false
0001CAB0 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001CAB4                            ; ===========================================================================
0001CAB4                            ; ---------------------------------------------------------------------------
0001CAB4                            ; Command handlers for normal execution
0001CAB4                            ; ---------------------------------------------------------------------------
0001CAB4                            
0001CAB4                            .comm
0001CAB4 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CAB8 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0001CABC 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001CAC0 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CAC4 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CAC8 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CACC 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CAD0 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CAD4 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CAD8 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0001CADC 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CAE0 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CAE4 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CAE8 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CAEC 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CAF0 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CAF4 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0001CAF8 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CAFC 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CB00 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001CB04 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0001CB08 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0001CB0C 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001CB10 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CB14 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CB18 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0001CB1C 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CB20 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CB24 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001CB28 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CB2C 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0001CB30                            				; FF - META
0001CB30                            ; ===========================================================================
0001CB30                            ; ---------------------------------------------------------------------------
0001CB30                            ; Routine to execute tracker meta and false condition commands
0001CB30                            ; ---------------------------------------------------------------------------
0001CB30                            
0001CB30                            .metacall
0001CB30 1A1C                       		move.b	(a4)+,d5		; get next command byte
0001CB32 DA45                       		add.w	d5,d5			; quadruple ID
0001CB34 DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001CB36 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0001CB3A                            
0001CB3A                            .falsecomm
0001CB3A 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0001CB3E                            ; ===========================================================================
0001CB3E                            ; ---------------------------------------------------------------------------
0001CB3E                            ; Command handlers for meta commands
0001CB3E                            ; ---------------------------------------------------------------------------
0001CB3E                            
0001CB3E                            .meta
0001CB3E 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0001CB42 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001CB46 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0001CB4A 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0001CB4E 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001CB52 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001CB56 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0001CB5A 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CB5E 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001CB62 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001CB66 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0001CB6A 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0001CB6E 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001CB72 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001CB76                            
0001CB76                            ; ===========================================================================
0001CB76                            ; ---------------------------------------------------------------------------
0001CB76                            ; Command handlers for false condition execution
0001CB76                            ; ---------------------------------------------------------------------------
0001CB76                            
0001CB76                            .false
0001CB76 524C                       	addq.w	#1,a4
0001CB78 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CB7A 524C                       	addq.w	#1,a4
0001CB7C 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001CB7E 524C                       	addq.w	#1,a4
0001CB80 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0001CB82 524C                       	addq.w	#1,a4
0001CB84 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CB86 524C                       	addq.w	#1,a4
0001CB88 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CB8A 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CB8E 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CB92 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CB96 524C                       	addq.w	#1,a4
0001CB98 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CB9A 524C                       	addq.w	#1,a4
0001CB9C 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CB9E 524C                       	addq.w	#1,a4
0001CBA0 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CBA2 4E75                       	rts
0001CBA4 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CBA6 4E75                       	rts
0001CBA8 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CBAA 524C                       	addq.w	#1,a4
0001CBAC 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CBAE 524C                       	addq.w	#1,a4
0001CBB0 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CBB2 524C                       	addq.w	#1,a4
0001CBB4 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CBB6 584C                       	addq.w	#4,a4
0001CBB8 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001CBBA 4E75                       	rts
0001CBBC 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CBBE 4E75                       	rts
0001CBC0 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CBC2 524C                       	addq.w	#1,a4
0001CBC4 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0001CBC6 544C                       	addq.w	#2,a4
0001CBC8 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001CBCA 4E75                       	rts
0001CBCC 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0001CBCE 544C                       	addq.w	#2,a4
0001CBD0 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0001CBD2 584C                       	addq.w	#4,a4
0001CBD4 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CBD6 544C                       	addq.w	#2,a4
0001CBD8 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CBDA 4E75                       	rts
0001CBDC 4E75                       	rts			; F9 - Return (RETURN)
0001CBDE 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CBE2 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CBE6 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001CBEA 524C                       	addq.w	#1,a4
0001CBEC 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CBEE 524C                       	addq.w	#1,a4
0001CBF0 4E75                       	rts			; FE - YM command (YMCMD)
0001CBF2 6000 FF3C                  	bra.w	.metacall	; FF - META
0001CBF6                            ; ===========================================================================
0001CBF6                            ; ---------------------------------------------------------------------------
0001CBF6                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0001CBF6                            ; Note that this will override any DAC already being played,
0001CBF6                            ; and in turn trackers may override these DAC samples at any
0001CBF6                            ; time. Use with caution!
0001CBF6                            ; ---------------------------------------------------------------------------
0001CBF6                            
0001CBF6                            dcWriteDAC1:
0001CBF6 7000                       		moveq	#0,d0
0001CBF8 101C                       		move.b	(a4)+,d0		; get note to write
0001CBFA 4EFA EA98                  		jmp	dNoteWriteDAC1(pc)	; note-on
0001CBFE                            
0001CBFE                            dcWriteDAC2:
0001CBFE 7000                       		moveq	#0,d0
0001CC00 101C                       		move.b	(a4)+,d0		; get note to write
0001CC02 4EFA EA82                  		jmp	dNoteWriteDAC2(pc)	; note-on
0001CC06                            ; ===========================================================================
0001CC06                            ; ---------------------------------------------------------------------------
0001CC06                            ; Tracker commands for handling spindash revving.
0001CC06                            ; The way spindash revving works, is it actually just
0001CC06                            ; increments a counter each time, and this counter is
0001CC06                            ; added into the channel pitch offset.
0001CC06                            ; ---------------------------------------------------------------------------
0001CC06                            
0001CC06                            dcSpRev:
0001CC06 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001CC0A 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001CC0E D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0001CC12                            
0001CC12 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0001CC16 6500                       		blo.s	.rts			; if not, skip
0001CC18 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001CC1C                            
0001CC1C                            .rts
0001CC1C 4E75                       		rts
0001CC1E                            
0001CC1E                            dcSpReset:
0001CC1E 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0001CC22 4E75                       		rts
0001CC24                            ; ===========================================================================
0001CC24                            ; ---------------------------------------------------------------------------
0001CC24                            ; Tracker command for changing channel panning
0001CC24                            ; ---------------------------------------------------------------------------
0001CC24                            
0001CC24                            dcPan:
0001CC24                            
0001CC24 7237                       		moveq	#$37,d1			; prepare bits to keep
0001CC26 C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001CC2A 821C                       		or.b	(a4)+,d1		; or panning value
0001CC2C 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001CC30                            
0001CC30 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001CC32 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CC38 6700 F774                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001CC3C                            ; ---------------------------------------------------------------------------
0001CC3C                            ; Since the DAC channels have or based panning behavior, we need this
0001CC3C                            ; piece of code to update its panning
0001CC3C                            ; ---------------------------------------------------------------------------
0001CC3C                            
0001CC3C 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001CC40 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001CC46 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001CC48 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001CC4C                            
0001CC4C                            .nodacsfx
0001CC4C 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001CC50 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001CC52 4EFA F798                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001CC56                            ; ===========================================================================
0001CC56                            ; ---------------------------------------------------------------------------
0001CC56                            ; Tracker commands for changing detune offset
0001CC56                            ; ---------------------------------------------------------------------------
0001CC56                            
0001CC56                            dcaDetune:
0001CC56 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0001CC58 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001CC5C 4E75                       		rts
0001CC5E                            
0001CC5E                            dcsDetune:
0001CC5E 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001CC62 4E75                       		rts
0001CC64                            ; ===========================================================================
0001CC64                            ; ---------------------------------------------------------------------------
0001CC64                            ; Tracker command for changing channel volume
0001CC64                            ; ---------------------------------------------------------------------------
0001CC64                            
0001CC64                            dcsVolume:
0001CC64 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001CC68 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC6C 4E75                       		rts
0001CC6E                            
0001CC6E                            dcaVolume:
0001CC6E 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001CC70 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001CC74 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CC78 4E75                       		rts
0001CC7A                            ; ===========================================================================
0001CC7A                            ; ---------------------------------------------------------------------------
0001CC7A                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001CC7A                            ; ---------------------------------------------------------------------------
0001CC7A                            
0001CC7A                            dcSampDAC:
0001CC7A 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
0001CC80 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001CC84 4E75                       		rts
0001CC86                            ; ===========================================================================
0001CC86                            ; ---------------------------------------------------------------------------
0001CC86                            ; Tracker command for setting DAC to pitch mode
0001CC86                            ; ---------------------------------------------------------------------------
0001CC86                            
0001CC86                            dcPitchDAC:
0001CC86 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001CC8A 4E75                       		rts
0001CC8C                            ; ===========================================================================
0001CC8C                            ; ---------------------------------------------------------------------------
0001CC8C                            ; Tracker commands for changing channel tick multiplier
0001CC8C                            ; ---------------------------------------------------------------------------
0001CC8C                            
0001CC8C                            dcsTmulCh:
0001CC8C 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
0001CC90 4E75                       		rts
0001CC92                            
0001CC92                            dcsTmul:
0001CC92 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001CC94 =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001CC94                            	rept Mus_Ch				; do for all music channels
0001CC94                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001CC94                            .x =		.x+cSize			; go to next channel
0001CC94                            	endr
0001CC94 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001CC98 =FFFFC4F0                M .x	=	.x+csize
0001CC98 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001CC9C =FFFFC51C                M .x	=	.x+csize
0001CC9C 11C0 C526                M 	move.b	d0,ctick+.x.w
0001CCA0 =FFFFC548                M .x	=	.x+csize
0001CCA0 11C0 C552                M 	move.b	d0,ctick+.x.w
0001CCA4 =FFFFC574                M .x	=	.x+csize
0001CCA4 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001CCA8 =FFFFC5A0                M .x	=	.x+csize
0001CCA8 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001CCAC =FFFFC5CC                M .x	=	.x+csize
0001CCAC 11C0 C5D6                M 	move.b	d0,ctick+.x.w
0001CCB0 =FFFFC5F8                M .x	=	.x+csize
0001CCB0 11C0 C602                M 	move.b	d0,ctick+.x.w
0001CCB4 =FFFFC624                M .x	=	.x+csize
0001CCB4 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001CCB8 =FFFFC650                M .x	=	.x+csize
0001CCB8 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001CCBC =FFFFC67C                M .x	=	.x+csize
0001CCBC 4E75                       		rts
0001CCBE                            ; ===========================================================================
0001CCBE                            ; ---------------------------------------------------------------------------
0001CCBE                            ; Tracker command for enabling or disabling the hold flag
0001CCBE                            ; ---------------------------------------------------------------------------
0001CCBE                            
0001CCBE                            dcHold:
0001CCBE 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
0001CCC2 4E75                       		rts
0001CCC4                            ; ===========================================================================
0001CCC4                            ; ---------------------------------------------------------------------------
0001CCC4                            ; Tracker command for enabling or disabling note timeout
0001CCC4                            ; ---------------------------------------------------------------------------
0001CCC4                            
0001CCC4                            dcTimeout:
0001CCC4                            
0001CCC4 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001CCC8 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001CCCC 4E75                       		rts
0001CCCE                            ; ===========================================================================
0001CCCE                            ; ---------------------------------------------------------------------------
0001CCCE                            ; Tracker commands for changing channel pitch
0001CCCE                            ; ---------------------------------------------------------------------------
0001CCCE                            
0001CCCE                            dcaTransp:
0001CCCE 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
0001CCD0 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
0001CCD4 4E75                       		rts
0001CCD6                            
0001CCD6                            dcsTransp:
0001CCD6 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001CCDA 4E75                       		rts
0001CCDC                            ; ===========================================================================
0001CCDC                            ; ---------------------------------------------------------------------------
0001CCDC                            ; Tracker commands for tempo control
0001CCDC                            ; ---------------------------------------------------------------------------
0001CCDC                            
0001CCDC                            dcsTempoShoes:
0001CCDC 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CCDE 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
0001CCE2 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CCE8 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001CCEA 4E75                       		rts
0001CCEC                            
0001CCEC                            dcsTempo:
0001CCEC 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CCEE 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
0001CCF2 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CCF8 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001CCFA                            
0001CCFA                            dcsTempoCur:
0001CCFA 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
0001CCFE                            
0001CCFE                            locret_Tempo:
0001CCFE 4E75                       		rts
0001CD00                            
0001CD00                            dcaTempoShoes:
0001CD00 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD02 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001CD06 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD0C 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
0001CD0E 4E75                       		rts
0001CD10                            
0001CD10                            dcaTempo:
0001CD10 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CD12 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001CD16 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CD1C 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
0001CD1E                            
0001CD1E                            dcaTempoCur:
0001CD1E D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
0001CD22 4E75                       		rts
0001CD24                            ; ===========================================================================
0001CD24                            ; ---------------------------------------------------------------------------
0001CD24                            ; Tracker command for enabling or disabling PSG4 noise mode
0001CD24                            ; ---------------------------------------------------------------------------
0001CD24                            
0001CD24                            dcNoisePSG:
0001CD24 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001CD28 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001CD2A 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001CD30 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001CD36 4E75                       		rts
0001CD38                            
0001CD38                            .psg3
0001CD38 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001CD3E 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001CD46 524C                       		addq.w	#1,a4			; skip param
0001CD48 4E75                       		rts
0001CD4A                            ; ===========================================================================
0001CD4A                            ; ---------------------------------------------------------------------------
0001CD4A                            ; Tracker command for playing another music or SFX
0001CD4A                            ; ---------------------------------------------------------------------------
0001CD4A                            
0001CD4A                            dcSound:
0001CD4A 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001CD4E                            
0001CD4E                            Return_dcSound:
0001CD4E 4E75                       		rts
0001CD50                            ; ===========================================================================
0001CD50                            ; ---------------------------------------------------------------------------
0001CD50                            ; Tracker command for setting DAC filter bank
0001CD50                            ; ---------------------------------------------------------------------------
0001CD50                            
0001CD50                            dcFilter:
0001CD50 7000                       		moveq	#0,d0
0001CD52 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001CD54 4EFA F23E                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001CD58                            ; ===========================================================================
0001CD58                            ; ---------------------------------------------------------------------------
0001CD58                            ; Tracker command for writing a YM command to YMCue
0001CD58                            ; ---------------------------------------------------------------------------
0001CD58                            
0001CD58                            dcYM:
0001CD58 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
0001CD5A 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
0001CD5C 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001CD60 66EC                       		bne.s	Return_dcSound		; if so, skip
0001CD62                            
0001CD62 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001CD66 6500 F658                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD6A                            
0001CD6A 1400                       		move.b	d0,d2			; copy address to d2
0001CD6C 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001CD70 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001CD74 6500 F64A                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CD78 4EFA F63A                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001CD7C                            ; ===========================================================================
0001CD7C                            ; ---------------------------------------------------------------------------
0001CD7C                            ; Tracker command for setting channel base frequency
0001CD7C                            ; ---------------------------------------------------------------------------
0001CD7C                            
0001CD7C                            dcsFreq:
0001CD7C 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001CD80 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001CD84                            
0001CD84                            .rts
0001CD84 4E75                       		rts
0001CD86                            ; ===========================================================================
0001CD86                            ; ---------------------------------------------------------------------------
0001CD86                            ; Tracker command for setting channel base frequency from the note table
0001CD86                            ; ---------------------------------------------------------------------------
0001CD86                            
0001CD86                            dcsFreqNote:
0001CD86 7000                       		moveq	#0,d0
0001CD88 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001CD8A D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001CD8E D040                       		add.w	d0,d0			; double offset (each entry is a word)
0001CD90                            
0001CD90 43FA F73E                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001CD94 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
0001CD9A                            
0001CD9A                            .rts
0001CD9A 4E75                       		rts
0001CD9C                            ; ===========================================================================
0001CD9C                            ; ---------------------------------------------------------------------------
0001CD9C                            ; Tracker command for doing a continous SFX loop
0001CD9C                            ; ---------------------------------------------------------------------------
0001CD9C                            
0001CD9C                            dcCont:
0001CD9C 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001CDA0 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001CDA2 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
0001CDA6 544C                       		addq.w	#2,a4			; skip over jump offset
0001CDA8 4E75                       		rts
0001CDAA                            ; ===========================================================================
0001CDAA                            ; ---------------------------------------------------------------------------
0001CDAA                            ; Tracker command for calling a tracker subroutine
0001CDAA                            ; ---------------------------------------------------------------------------
0001CDAA                            
0001CDAA                            dcCall:
0001CDAA                            
0001CDAA 7000                       		moveq	#0,d0
0001CDAC 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CDB0 5900                       		subq.b	#4,d0			; allocate space for another routine
0001CDB2                            
0001CDB2 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
0001CDB6 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CDBA                            ; ===========================================================================
0001CDBA                            ; ---------------------------------------------------------------------------
0001CDBA                            ; Tracker command for jumping to another tracker location
0001CDBA                            ; ---------------------------------------------------------------------------
0001CDBA                            
0001CDBA                            dcJump:
0001CDBA                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001CDBA 1E9C                     M 	move.b	(a4)+,(sp)
0001CDBC 3017                     M 	move.w	(sp),d0
0001CDBE 1014                     M 	move.b	(a4),d0
0001CDC0 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001CDC2 4E75                       		rts
0001CDC4                            ; ===========================================================================
0001CDC4                            ; ---------------------------------------------------------------------------
0001CDC4                            ; Tracker command for handling loops
0001CDC4                            ; ---------------------------------------------------------------------------
0001CDC4                            
0001CDC4                            dcLoop:
0001CDC4 7000                       		moveq	#0,d0
0001CDC6 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001CDC8                            
0001CDC8 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001CDCC 6600                       		bne.s	.loopok			; if nonzero, branch
0001CDCE 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
0001CDD4                            
0001CDD4                            .loopok
0001CDD4 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001CDD8 66E0                       		bne.s	dcJump			; if not 0, jump to routine
0001CDDA 564C                       		addq.w	#3,a4			; skip over jump offset
0001CDDC 4E75                       		rts
0001CDDE                            ; ===========================================================================
0001CDDE                            ; ---------------------------------------------------------------------------
0001CDDE                            ; Tracker command for initializing modulation
0001CDDE                            ; ---------------------------------------------------------------------------
0001CDDE                            
0001CDDE                            dcMod68K:
0001CDDE 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
0001CDE2 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
0001CDE6 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001CDEA 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001CDEE                            
0001CDEE 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001CDF0 E208                       		lsr.b	#1,d0			; halve it
0001CDF2 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
0001CDF6 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001CDFA                            	; continue to enabling modulation
0001CDFA                            ; ===========================================================================
0001CDFA                            ; ---------------------------------------------------------------------------
0001CDFA                            ; Tracker commands for enabling and disabling modulation
0001CDFA                            ; ---------------------------------------------------------------------------
0001CDFA                            
0001CDFA                            dcModOn:
0001CDFA 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001CDFE 4E75                       		rts
0001CE00                            
0001CE00                            dcModOff:
0001CE00 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
0001CE04 4E75                       		rts
0001CE06                            ; ===========================================================================
0001CE06                            ; ---------------------------------------------------------------------------
0001CE06                            ; Tracker command for returning from tracker subroutine
0001CE06                            ; ---------------------------------------------------------------------------
0001CE06                            
0001CE06                            dcReturn:
0001CE06 7000                       		moveq	#0,d0
0001CE08 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CE0C 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
0001CE10                            
0001CE10 544C                       		addq.w	#2,a4			; skip the call address parameter
0001CE12 5800                       		addq.b	#4,d0			; deallocate stack space
0001CE14 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CE18                            
0001CE18 4E75                       		rts
0001CE1A                            ; ===========================================================================
0001CE1A                            ; ---------------------------------------------------------------------------
0001CE1A                            ; Tracker command for initializing special FM3 mode
0001CE1A                            ; ---------------------------------------------------------------------------
0001CE1A                            
0001CE1A                            dcSpecFM3:
0001CE1A 4E75                       		rts
0001CE1C                            ; ===========================================================================
0001CE1C                            ; ---------------------------------------------------------------------------
0001CE1C                            ; Tracker command for enabling raw frequency mode
0001CE1C                            ; ---------------------------------------------------------------------------
0001CE1C                            
0001CE1C                            dcFreqOn:
0001CE1C 4E75                       		rts
0001CE1E                            ; ===========================================================================
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            ; Tracker command for disabling raw frequency mode
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            
0001CE1E                            dcFreqOff:
0001CE1E                            
0001CE1E                            locret_FreqOff:
0001CE1E 4E75                       		rts
0001CE20                            ; ===========================================================================
0001CE20                            ; ---------------------------------------------------------------------------
0001CE20                            ; Tracker command for changing voice, volume envelope or sample
0001CE20                            ; ---------------------------------------------------------------------------
0001CE20                            
0001CE20                            dcVoice:
0001CE20 7000                       		moveq	#0,d0
0001CE22 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
0001CE24 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001CE28                            
0001CE28 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001CE2C 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001CE2E 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CE34 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001CE36                            
0001CE36 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001CE3A 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001CE3C 224E                       		move.l	a6,a1			; load voice table to a1
0001CE3E                            	; continue to send FM voice
0001CE3E                            ; ===========================================================================
0001CE3E                            ; ---------------------------------------------------------------------------
0001CE3E                            ; Subroutine for sending the FM voice to YM2612
0001CE3E                            ; This routine is speed optimized in a way that allows Dual PCM
0001CE3E                            ; to only be stopped for as long as it must be. This will waste
0001CE3E                            ; some cycles for 68000, but it will help improve DAC quality.
0001CE3E                            ; ---------------------------------------------------------------------------
0001CE3E                            
0001CE3E                            dUpdateVoiceFM:
0001CE3E                            	dCALC_VOICE				; get address of the specific voice to a1
0001CE3E EB48                     M 	lsl.w	#5,d0
0001CE40 D2C0                     M 	add.w	d0,a1
0001CE42 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001CE46 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001CE48                            
0001CE48 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001CE4A 16C4                       		move.b	d4,(a3)+		; save it to free space
0001CE4C 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001CE50                            
0001CE50 45FA F262                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001CE54                            	rept VoiceRegs-5
0001CE54                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001CE54                            		move.b	(a2)+,(a3)+		; copy each command
0001CE54                            	endr
0001CE54 16D9                     M 	move.b	(a1)+,(a3)+
0001CE56 16DA                     M 	move.b	(a2)+,(a3)+
0001CE58 16D9                     M 	move.b	(a1)+,(a3)+
0001CE5A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE5C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE5E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE60 16D9                     M 	move.b	(a1)+,(a3)+
0001CE62 16DA                     M 	move.b	(a2)+,(a3)+
0001CE64 16D9                     M 	move.b	(a1)+,(a3)+
0001CE66 16DA                     M 	move.b	(a2)+,(a3)+
0001CE68 16D9                     M 	move.b	(a1)+,(a3)+
0001CE6A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE6C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE6E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE70 16D9                     M 	move.b	(a1)+,(a3)+
0001CE72 16DA                     M 	move.b	(a2)+,(a3)+
0001CE74 16D9                     M 	move.b	(a1)+,(a3)+
0001CE76 16DA                     M 	move.b	(a2)+,(a3)+
0001CE78 16D9                     M 	move.b	(a1)+,(a3)+
0001CE7A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE7C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE7E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE80 16D9                     M 	move.b	(a1)+,(a3)+
0001CE82 16DA                     M 	move.b	(a2)+,(a3)+
0001CE84 16D9                     M 	move.b	(a1)+,(a3)+
0001CE86 16DA                     M 	move.b	(a2)+,(a3)+
0001CE88 16D9                     M 	move.b	(a1)+,(a3)+
0001CE8A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE8C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE8E 16DA                     M 	move.b	(a2)+,(a3)+
0001CE90 16D9                     M 	move.b	(a1)+,(a3)+
0001CE92 16DA                     M 	move.b	(a2)+,(a3)+
0001CE94 16D9                     M 	move.b	(a1)+,(a3)+
0001CE96 16DA                     M 	move.b	(a2)+,(a3)+
0001CE98 16D9                     M 	move.b	(a1)+,(a3)+
0001CE9A 16DA                     M 	move.b	(a2)+,(a3)+
0001CE9C 16D9                     M 	move.b	(a1)+,(a3)+
0001CE9E 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA0 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA2 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA4 16D9                     M 	move.b	(a1)+,(a3)+
0001CEA6 16DA                     M 	move.b	(a2)+,(a3)+
0001CEA8 16D9                     M 	move.b	(a1)+,(a3)+
0001CEAA 16DA                     M 	move.b	(a2)+,(a3)+
0001CEAC 16D9                     M 	move.b	(a1)+,(a3)+
0001CEAE 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB0 16D9                     M 	move.b	(a1)+,(a3)+
0001CEB2 16DA                     M 	move.b	(a2)+,(a3)+
0001CEB4                            
0001CEB4 7C00                       		moveq	#0,d6			; reset the modulator offset
0001CEB6 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001CEBA D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001CEBE 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001CEC0 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001CEC2                            
0001CEC2                            .noover
0001CEC2 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001CEC8 6700                       		beq.s	.uwdone			; if not, skip
0001CECA 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001CECC 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001CED0 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001CED2 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001CED4                            
0001CED4                            .uwdone
0001CED4 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001CED6                            
0001CED6                            .tlloop
0001CED6 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001CED8 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001CEDA                            
0001CEDA D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001CEDC 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001CEDE 727F                       		moveq	#$7F,d1			; cap to silent volume
0001CEE0 6000                       		bra.s	.slot
0001CEE2                            
0001CEE2                            .noslot
0001CEE2 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001CEE4                            .slot
0001CEE4 16C1                       		move.b	d1,(a3)+		; save the Total Level value
0001CEE6 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
0001CEE8 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001CEEC                            
0001CEEC                            
0001CEEC 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001CEF0 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001CEF4 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001CEF8                            
0001CEF8 7400                       		moveq	#0,d2			; prepare part 1 value
0001CEFA 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001CEFE 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001CF02 6700                       		beq.s	.ptok			; if so, branch
0001CF04 0203 0003                  		and.b	#3,d3			; get channel offset only
0001CF08 7402                       		moveq	#2,d2			; prepare part 2 value
0001CF0A                            
0001CF0A                            .ptok
0001CF0A 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001CF0C 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001CF0E                            	StopZ80					; wait for Z80 to stop
0001CF0E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001CF16                          M 	waitz80stop
0001CF16 0839 0000 00A1 1100      M .wait_360:	btst	#0,z80_bus_req
0001CF1E 66F6                     M 	bne.s	.wait_360
0001CF20                            
0001CF20                            .write
0001CF20 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
0001CF22 10DB                       		move.b	(a3)+,(a0)+		; write command values
0001CF24                            
0001CF24 101B                       		move.b	(a3)+,d0		; load YM command
0001CF26 8003                       		or.b	d3,d0			; add the channel offset to command
0001CF28 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001CF2A 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001CF2E 50D0                       		st	(a0)			; mark as end of the cue
0001CF30                            
0001CF30                            	StartZ80				; enable Z80 execution
0001CF30 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001CF38 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001CF3C 4E75                       		rts
0001CF3E                            ; ===========================================================================
0001CF3E                            ; ---------------------------------------------------------------------------
0001CF3E                            ; Tracker command for stopping the current channel
0001CF3E                            ; ---------------------------------------------------------------------------
0001CF3E                            
0001CF3E                            dcStop:
0001CF3E 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
0001CF42 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001CF46 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001CF48                            
0001CF48 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001CF4E 6600                       		bne.s	.cont			; if we are, skip
0001CF50 4EBA F448                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001CF54 6000                       		bra.s	.cont
0001CF56                            ; ---------------------------------------------------------------------------
0001CF56                            
0001CF56                            .mutePSG
0001CF56 4EBA FB30                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001CF5A                            
0001CF5A                            .cont
0001CF5A BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001CF5E 6500                       		blo.s	.exit			; if not, skip all this mess
0001CF60 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001CF64                            
0001CF64 43FA ED74                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001CF68 7600                       		moveq	#0,d3
0001CF6A 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
0001CF6E 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001CF70 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001CF72                            
0001CF72 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001CF76 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001CF78 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001CF7A 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
0001CF7E                            
0001CF7E                            .dacdone
0001CF7E 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001CF80 6A00                       		bpl.s	.fixch			; if not, branch
0001CF82                            
0001CF82 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
0001CF86 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
0001CF8A 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001CF90 6600                       		bne.s	.fixch			; if yes, skip
0001CF92                            
0001CF92 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
0001CF96 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
0001CF9A 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CF9E 4EBA FE9E                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001CFA2                            
0001CFA2                            .fixch
0001CFA2 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001CFA4                            .exit
0001CFA4 5497                       		addq.l	#2,(sp)			; go to next channel immediately
0001CFA6 4E75                       		rts
0001CFA8                            ; ---------------------------------------------------------------------------
0001CFA8                            ; There is nothing that would break even if the channel is not
0001CFA8                            ; running a tracker, so we do not bother checking
0001CFA8                            ; ---------------------------------------------------------------------------
0001CFA8                            
0001CFA8                            .psg
0001CFA8 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
0001CFAA 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001CFAE 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001CFB2 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
0001CFB6                            
0001CFB6 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001CFBC 66E6                       		bne.s	.exit			; if not, skip
0001CFBE 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
0001CFC6 60DC                       		bra.s	.exit
0001CFC8                            ; ===========================================================================
0001CFC8                            ; ---------------------------------------------------------------------------
0001CFC8                            ; Tracker command for enabling LFO
0001CFC8                            ; ---------------------------------------------------------------------------
0001CFC8                            
0001CFC8                            dcsLFO:
0001CFC8 7000                       		moveq	#0,d0
0001CFCA 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CFCE 224E                       		move.l	a6,a1			; load voice table to a1
0001CFD0                            
0001CFD0                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001CFD0 EB48                     M 	lsl.w	#5,d0
0001CFD2 0640 0009                M 	add.w	#9,d0
0001CFD6 D2C0                     M 	add.w	d0,a1
0001CFD8 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
0001CFDA 45FA F0E0                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001CFDE 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001CFE0                            
0001CFE0                            .decayloop
0001CFE0 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001CFE2 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001CFE4                            
0001CFE4 D603                       		add.b	d3,d3			; check if LFO is enabled for this channeö
0001CFE6 6400                       		bcc.s	.noLFO			; if not, skip
0001CFE8 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001CFEC 4EBA F3C6                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001CFF0                            
0001CFF0                            .noLFO
0001CFF0 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001CFF4                            
0001CFF4 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001CFF6 7022                       		moveq	#$22,d0			; YM command: LFO
0001CFF8 4EBA F3C6                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001CFFC                            
0001CFFC 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001CFFE 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
0001D002                            
0001D002 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001D004 4EFA F3A8                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001D008                            ; ===========================================================================
0001D008                            ; ---------------------------------------------------------------------------
0001D008                            ; Tracker command for resetting condition
0001D008                            ; ---------------------------------------------------------------------------
0001D008                            
0001D008                            dcResetCond:
0001D008 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001D00C 4E75                       		rts
0001D00E                            ; ===========================================================================
0001D00E                            ; ---------------------------------------------------------------------------
0001D00E                            ; Tracker command for writing to communications flags
0001D00E                            ; ---------------------------------------------------------------------------
0001D00E                            
0001D00E                            dcsComm:
0001D00E 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D012 7000                       		moveq	#0,d0
0001D014 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001D016 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001D01A 4E75                       		rts
0001D01C                            ; ===========================================================================
0001D01C                            ; ---------------------------------------------------------------------------
0001D01C                            ; RAM addresses for special condition code
0001D01C                            ; ---------------------------------------------------------------------------
0001D01C                            
0001D01C                            dcCondRegTable:
0001D01C C744 C4A6                  	dc.w rHWVersion, mFlags	; 0
0001D020 C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
0001D024 0000 0000                  	dc.w 0, 0			; 4
0001D028 0000 0000                  	dc.w 0, 0			; 6
0001D02C 0000 0000                  	dc.w 0, 0			; 8
0001D030 0000 0000                  	dc.w 0, 0			; $A
0001D034 0000 0000                  	dc.w 0, 0			; $C
0001D038 0000 0001                  	dc.w 0, cType			; $E
0001D03C                            ; ===========================================================================
0001D03C                            ; ---------------------------------------------------------------------------
0001D03C                            ; Tracker command for checking special RAM addresses
0001D03C                            ; ---------------------------------------------------------------------------
0001D03C                            
0001D03C                            dcCondReg:
0001D03C 101C                       		move.b	(a4)+,d0		; get value from tracker
0001D03E 1200                       		move.b	d0,d1			; copy to d1
0001D040                            
0001D040 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
0001D044 D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001D046 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001D04A 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
0001D04C D04D                       		add.w	a5,d0			; else it was a channel offset
0001D04E                            
0001D04E                            .gotit
0001D04E 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
0001D050 1011                       		move.b	(a1),d0			; read byte from it
0001D052 6000                       		bra.s	dcCondCom
0001D054                            ; ===========================================================================
0001D054                            ; ---------------------------------------------------------------------------
0001D054                            ; Tracker command for checking communications bytes
0001D054                            ; ---------------------------------------------------------------------------
0001D054                            
0001D054                            dcCond:
0001D054 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D058 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001D05A 1200                       		move.b	d0,d1			; copy to d1
0001D05C 0240 000F                  		and.w	#$F,d0			; get offset only
0001D060 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
0001D064                            
0001D064                            dcCondCom:
0001D064 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001D068 0241 00F0                  		and.w	#$F0,d1			; get condition value only
0001D06C E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
0001D06E B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
0001D070 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
0001D074                            ; ===========================================================================
0001D074                            ; ---------------------------------------------------------------------------
0001D074                            ; Code for setting the condition flag
0001D074                            ; ---------------------------------------------------------------------------
0001D074                            
0001D074                            .c	macro x
0001D074                            	\x	.false
0001D074                            	rts
0001D074                                 endm
0001D074                            
0001D074                            .false
0001D074 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001D078                            
0001D078 4E75                       .cond	rts		; T
0001D07A 4E75                       	rts
0001D07C                            	.c bra.s	; F
0001D07C 60F6                     M 	bra.s	.false
0001D07E 4E75                     M 	rts
0001D080                            	.c bls.s	; HI
0001D080 63F2                     M 	bls.s	.false
0001D082 4E75                     M 	rts
0001D084                            	.c bhi.s	; LS
0001D084 62EE                     M 	bhi.s	.false
0001D086 4E75                     M 	rts
0001D088                            	.c blo.s	; HS/CC
0001D088 65EA                     M 	blo.s	.false
0001D08A 4E75                     M 	rts
0001D08C                            	.c bhs.s	; LO/CS
0001D08C 64E6                     M 	bhs.s	.false
0001D08E 4E75                     M 	rts
0001D090                            	.c beq.s	; NE
0001D090 67E2                     M 	beq.s	.false
0001D092 4E75                     M 	rts
0001D094                            	.c bne.s	; EQ
0001D094 66DE                     M 	bne.s	.false
0001D096 4E75                     M 	rts
0001D098                            	.c bvs.s	; VC
0001D098 69DA                     M 	bvs.s	.false
0001D09A 4E75                     M 	rts
0001D09C                            	.c bvc.s	; VS
0001D09C 68D6                     M 	bvc.s	.false
0001D09E 4E75                     M 	rts
0001D0A0                            	.c bmi.s	; PL
0001D0A0 6BD2                     M 	bmi.s	.false
0001D0A2 4E75                     M 	rts
0001D0A4                            	.c bpl.s	; MI
0001D0A4 6ACE                     M 	bpl.s	.false
0001D0A6 4E75                     M 	rts
0001D0A8                            	.c blt.s	; GE
0001D0A8 6DCA                     M 	blt.s	.false
0001D0AA 4E75                     M 	rts
0001D0AC                            	.c bge.s	; LT
0001D0AC 6CC6                     M 	bge.s	.false
0001D0AE 4E75                     M 	rts
0001D0B0                            	.c ble.s	; GT
0001D0B0 6FC2                     M 	ble.s	.false
0001D0B2 4E75                     M 	rts
0001D0B4                            	.c bgt.s	; LE
0001D0B4 6EBE                     M 	bgt.s	.false
0001D0B6 4E75                     M 	rts
0001D0B8                            ; ===========================================================================
0001D0B8                            ; ---------------------------------------------------------------------------
0001D0B8                            ; Tracker command for freezing the CPU. DEBUG FLAG
0001D0B8                            ; ---------------------------------------------------------------------------
0001D0B8                            
0001D0B8                            ; ===========================================================================
0001D0B8                            ; ---------------------------------------------------------------------------
0001D0B8                            ; Check if a song is playing
0001D0B8                            ; ---------------------------------------------------------------------------
0001D0B8                            
0001D0B8                            dChkSongPlay:
0001D0B8 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
0001D0BC 7209                       	moveq	#Mus_Ch-1,d1
0001D0BE                            
0001D0BE                            .ChkTracks:
0001D0BE 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
0001D0C0 6B00                       	bmi.s	.Playing		; If so, branch
0001D0C2 43E9 002C                  	lea	cSize(a1),a1		; Next track
0001D0C6 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
0001D0CA 7200                       	moveq	#0,d1
0001D0CC 4E75                       	rts
0001D0CE                            
0001D0CE                            .Playing:
0001D0CE 50C1                       	st	d1
0001D0D0 4E75                       	rts
0001D0D2                            ; ===========================================================================
0001D0D2                            ; ---------------------------------------------------------------------------
0001D0D2                            ; Define music and SFX
0001D0D2                            ; ---------------------------------------------------------------------------
0001D0D2                            
0001D0D2                            	opt oz-				; disable zero-offset optimization
000C3988                            	list				; continue source listing
000C3988                            ; ===========================================================================
000C3988                            DualPCM:
000C3988                            		z80prog	0
000C3988                          M 	pusho
000C3988                          M 	opt	ae-
000C3988                          M 	opt	an+
00000000                            		include	"../amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_Fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_Fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000C54BF =00000000                M z80prg	=	0
000C54BF                          M 	mexit
000C54BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            ; Error handler
000C54BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            		include	"_ERROR_/error.asm"
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Mighty The Armadillo in PRISM PARADISE
000C54BF                            ; By Nat The Porcupine 2021
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Vladikcomper's debugger
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            
000C54BF                            exBus	EQU	ICD_BLK
000C54BF                            exAddr	EQU	ICD_BLK
000C54BF                            exIll	EQU	ICD_BLK
000C54BF                            exDiv	EQU	ICD_BLK
000C54BF                            exChk	EQU	ICD_BLK
000C54BF                            Trapv	EQU	ICD_BLK
000C54BF                            exPriv	EQU	ICD_BLK
000C54BF                            exTrace	EQU	ICD_BLK
000C54BF                            exLineA	EQU	ICD_BLK
000C54BF                            exLineF	EQU	ICD_BLK
000C54BF                            exMisc	EQU	ICD_BLK
000C54BF                            
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; =========================================================================================================================================================
